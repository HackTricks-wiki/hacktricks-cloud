# GCP - Persistance des tokens

{{#include ../../../banners/hacktricks-training.md}}

### Tokens d'utilisateurs authentifiés

Pour obtenir le **token actuel** d'un utilisateur, vous pouvez exécuter :

<details>

<summary>Obtenir l'access token depuis la base de données SQLite</summary>
```bash
sqlite3 $HOME/.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
</details>

Consultez cette page pour voir comment **utiliser directement ce token avec gcloud** :

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#gcp
{{#endref}}

Pour obtenir les détails pour **générer un nouvel access token**, exécutez :

<details>

<summary>Obtenir le refresh token depuis la base de données SQLite</summary>
```bash
sqlite3 $HOME/.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
</details>

Il est aussi possible de trouver des refresh tokens dans **`$HOME/.config/gcloud/application_default_credentials.json`** et dans **`$HOME/.config/gcloud/legacy_credentials/*/adc.json`**.

Pour obtenir un nouvel access token rafraîchi avec le **refresh token**, le client ID et le client secret, exécutez :

<details>

<summary>Obtenir un nouvel access token en utilisant le refresh token</summary>
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
</details>

La validité des refresh tokens peut être gérée dans **Admin** > **Security** > **Google Cloud session control**, et par défaut elle est réglée sur 16h bien qu'elle puisse être configurée pour n'expirer jamais :

<figure><img src="../../../images/image (11).png" alt=""><figcaption></figcaption></figure>

### Flux d'authentification

Le flux d'authentification lors de l'utilisation de quelque chose comme `gcloud auth login` ouvrira une fenêtre dans le navigateur et, après avoir accepté tous les scopes, le navigateur enverra une requête comme celle-ci au port http ouvert par l'outil :
```
/?state=EN5AK1GxwrEKgKog9ANBm0qDwWByYO&code=4/0AeaYSHCllDzZCAt2IlNWjMHqr4XKOuNuhOL-TM541gv-F6WOUsbwXiUgMYvo4Fg0NGzV9A&scope=email%20openid%20https://www.googleapis.com/auth/userinfo.email%20https://www.googleapis.com/auth/cloud-platform%20https://www.googleapis.com/auth/appengine.admin%20https://www.googleapis.com/auth/sqlservice.login%20https://www.googleapis.com/auth/compute%20https://www.googleapis.com/auth/accounts.reauth&authuser=0&prompt=consent HTTP/1.1
```
Ensuite, gcloud utilisera le state et le code avec un `client_id` codé en dur (`32555940559.apps.googleusercontent.com`) et **`client_secret`** (`ZmssLNjJy2998hD4CTg2ejr2`) pour obtenir les **données finales du refresh token**.

> [!CAUTION]
> Notez que la communication avec localhost se fait en HTTP, il est donc possible d'intercepter les données pour obtenir un refresh token ; toutefois ces données ne sont valables qu'une seule fois, donc cela serait inutile — il est plus simple de lire le refresh token depuis le fichier.

### Portées OAuth

Vous pouvez trouver toutes les portées Google sur [https://developers.google.com/identity/protocols/oauth2/scopes] ou les obtenir en exécutant:

<details>

<summary>Récupérer toutes les portées OAuth de Google</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-A/\-\._]*' | sort -u
```
</details>

Il est possible de voir quels scopes l'application que **`gcloud`** utilise pour s'authentifier peut supporter avec ce script :

<details>

<summary>Tester les scopes pris en charge par gcloud</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope         \r"
if ! curl -v "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=32555940559.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+$scope+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fsqlservice.login+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&state=AjvFqBW5XNIw3VADagy5pvUSPraLQu&access_type=offline&code_challenge=IOk5F08WLn5xYPGRAHP9CTGHbLFDUElsP551ni2leN4&code_challenge_method=S256" 2>&1 | grep -q "error"; then
echo ""
echo $scope
fi
done
```
</details>

Après exécution, il a été vérifié que cette application prend en charge ces scopes :
```
https://www.googleapis.com/auth/appengine.admin
https://www.googleapis.com/auth/bigquery
https://www.googleapis.com/auth/cloud-platform
https://www.googleapis.com/auth/compute
https://www.googleapis.com/auth/devstorage.full_control
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/userinfo.email
```
c'est intéressant de voir comment cette app prend en charge le **`drive`** scope, ce qui pourrait permettre à un utilisateur d'escalader de GCP vers Workspace si un attaquant parvient à forcer l'utilisateur à générer un token avec ce scope.

**Check how to** [**abuse this here**](../gcp-to-workspace-pivoting/index.html#abusing-gcloud)**.**

### Comptes de service

Tout comme pour les utilisateurs authentifiés, si vous parvenez à **compromettre le fichier de clé privée** d'un compte de service vous pourrez **y accéder généralement aussi longtemps que vous le souhaitez**.\
Cependant, si vous volez le **OAuth token** d'un compte de service cela peut être encore plus intéressant, car, même si par défaut ces tokens ne sont utiles qu'une heure, si la **victime supprime la clé API privée, le OAuth token restera valide jusqu'à son expiration**.

### Métadonnées

Évidemment, tant que vous êtes à l'intérieur d'une machine exécutée dans l'environnement GCP vous pourrez **accéder au compte de service attaché à cette machine en contactant le metadata endpoint** (notez que les OAuth tokens accessibles via cet endpoint sont généralement restreints par des scopes).

### Remédiations

Certaines remédiations pour ces techniques sont expliquées dans [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

### Références

- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
- [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)

{{#include ../../../banners/hacktricks-training.md}}
