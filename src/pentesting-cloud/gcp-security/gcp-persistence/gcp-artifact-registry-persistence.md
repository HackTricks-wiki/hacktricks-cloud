# GCP - Artifact Registry Persistence

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

有关 Artifact Registry 的更多信息，请查看：

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### 依赖混淆

- 如果一个 **远程和一个标准** 的仓库 **在一个虚拟** 仓库中混合，并且一个包在两个仓库中都存在，会发生什么？
- 使用 **在虚拟仓库中设置的最高优先级** 的那个
- 如果 **优先级相同**：
- 如果 **版本** 是 **相同的**，则使用 **在虚拟仓库中按字母顺序排列的策略名称** 第一个
- 如果不是，则使用 **最高版本**

> [!CAUTION]
> 因此，如果远程仓库具有更高或相同的优先级，则可以在公共包注册表中 **滥用最高版本（依赖混淆）**

此技术对于 **持久性** 和 **未经身份验证的访问** 非常有用，因为滥用它只需 **知道存储在 Artifact Registry 中的库名称** 并 **在公共仓库（例如 Python 的 PyPi）中创建相同的库**，并使用更高的版本。

对于持久性，您需要遵循以下步骤：

- **要求**：必须 **存在** 一个 **虚拟仓库** 并被使用，必须使用一个 **名称** 在 **公共仓库** 中不存在的 **内部包**。
- 如果不存在，则创建一个远程仓库
- 将远程仓库添加到虚拟仓库
- 编辑虚拟注册表的策略，以给予远程仓库更高（或相同）的优先级。\
运行类似以下命令：
- [gcloud artifacts repositories update --upstream-policy-file ...](https://cloud.google.com/sdk/gcloud/reference/artifacts/repositories/update#--upstream-policy-file)
- 下载合法包，添加您的恶意代码，并以相同版本在公共仓库中注册。每次开发者安装它时，他将安装您的版本！

有关依赖混淆的更多信息，请查看：

{{#ref}}
https://book.hacktricks.xyz/pentesting-web/dependency-confusion
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
