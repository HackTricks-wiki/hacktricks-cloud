# GCP - Artifact Registry Persistence

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Artifact Registry에 대한 자세한 정보는 다음을 확인하세요:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### Dependency Confusion

- **원격 및 표준** 저장소가 **가상** 저장소에서 **혼합**되고 두 곳 모두에 패키지가 존재하면 어떻게 됩니까?
- **가상 저장소에서 설정된 우선 순위가 가장 높은** 것이 사용됩니다.
- **우선 순위가 동일한 경우**:
- **버전**이 **동일하면**, 가상 저장소에서 **정책 이름이 알파벳 순서로 먼저** 사용됩니다.
- 그렇지 않으면, **가장 높은 버전**이 사용됩니다.

> [!CAUTION]
> 따라서, 원격 저장소의 우선 순위가 더 높거나 동일한 경우, 공개 패키지 레지스트리에서 **가장 높은 버전(의존성 혼란)**을 **악용**할 수 있습니다.

이 기술은 **지속성** 및 **인증되지 않은 접근**에 유용할 수 있으며, 이를 악용하기 위해서는 Artifact Registry에 저장된 **라이브러리 이름**을 **알고**, **공개 저장소(예: Python의 PyPi)**에 더 높은 버전으로 동일한 라이브러리를 **생성**하기만 하면 됩니다.

지속성을 위해 따라야 할 단계는 다음과 같습니다:

- **요구 사항**: **가상 저장소**가 **존재**하고 사용되어야 하며, **공개 저장소**에 존재하지 않는 **이름**을 가진 **내부 패키지**가 사용되어야 합니다.
- 원격 저장소가 존재하지 않으면 생성합니다.
- 원격 저장소를 가상 저장소에 추가합니다.
- 원격 저장소에 더 높은 우선 순위(또는 동일한)를 부여하기 위해 가상 레지스트리의 정책을 편집합니다.\
다음과 같은 명령을 실행합니다:
- [gcloud artifacts repositories update --upstream-policy-file ...](https://cloud.google.com/sdk/gcloud/reference/artifacts/repositories/update#--upstream-policy-file)
- 정품 패키지를 다운로드하고, 악성 코드를 추가한 후 동일한 버전으로 공개 저장소에 등록합니다. 개발자가 이를 설치할 때마다, 그는 당신의 것을 설치하게 됩니다!

의존성 혼란에 대한 자세한 정보는 다음을 확인하세요:

{{#ref}}
https://book.hacktricks.xyz/pentesting-web/dependency-confusion
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
