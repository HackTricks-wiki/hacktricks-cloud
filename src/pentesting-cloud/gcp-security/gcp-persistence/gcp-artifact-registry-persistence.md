# GCP - Artifact Registry Persistence

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

有关 Artifact Registry 的更多信息，请查看：

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### 依赖混淆

- 如果 **远程和标准** 存储库 **在一个虚拟** 存储库中混合，并且两个存储库中都存在一个包，会发生什么？
- 使用 **在虚拟存储库中设置的最高优先级**
- 如果 **优先级相同**：
- 如果 **版本** 是 **相同的**，则使用 **在虚拟存储库中按字母顺序排列的策略名称**
- 如果不是，则使用 **最高版本**

> [!CAUTION]
> 因此，如果远程存储库具有更高或相同的优先级，则可以在公共包注册表中 **滥用最高版本（依赖混淆）**

此技术对于 **持久性** 和 **未经身份验证的访问** 非常有用，因为要滥用它，只需 **知道存储在 Artifact Registry 中的库名称** 并 **在公共存储库中创建相同的库（例如 Python 的 PyPi）**，并使用更高版本。

对于持久性，您需要遵循以下步骤：

- **要求**：必须 **存在** 并使用 **虚拟存储库**，必须使用 **在公共存储库中不存在的名称** 的 **内部包**。
- 如果不存在，则创建一个远程存储库
- 将远程存储库添加到虚拟存储库
- 编辑虚拟注册表的策略，以给予远程存储库更高（或相同）的优先级。\
运行类似以下内容：
- [gcloud artifacts repositories update --upstream-policy-file ...](https://cloud.google.com/sdk/gcloud/reference/artifacts/repositories/update#--upstream-policy-file)
- 下载合法包，添加您的恶意代码，并以相同版本在公共存储库中注册。每次开发人员安装它时，他将安装您的版本！

有关依赖混淆的更多信息，请查看：

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/dependency-confusion.html
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
