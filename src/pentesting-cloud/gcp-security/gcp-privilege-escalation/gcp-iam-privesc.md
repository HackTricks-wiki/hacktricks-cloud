# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Per maggiori informazioni su IAM:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Un attacker con i permessi indicati potrà aggiornare un ruolo assegnato a te e concederti permessi aggiuntivi su altre risorse come:

<details><summary>Aggiornare il ruolo IAM per aggiungere permessi</summary>
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
</details>

Puoi trovare uno script per automatizzare la **creazione, lo sfruttamento e la pulizia di un ambiente vulnerabile qui** e uno script Python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Per maggiori informazioni consulta la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Un attaccante con i permessi menzionati sarà in grado di **richiedere un access token che appartiene a un Service Account**, quindi è possibile ottenere un access token di un Service Account con privilegi superiori ai nostri.

<details><summary>Impersonare un Service Account per ottenere un access token</summary>
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
</details>

Puoi trovare uno script per automatizzare la [**creazione, lo sfruttamento e la pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) e uno script Python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Per maggiori informazioni consulta la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Un attaccante con i permessi menzionati sarà in grado di **creare una chiave gestita dall'utente per un Service Account**, cosa che ci permetterà di accedere a GCP come quel Service Account.

<details><summary>Creare una chiave per il Service Account e autenticarsi</summary>
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
</details>

Puoi trovare uno script per automatizzare la [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) e uno script python per abusare di questo privilegio [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Per maggiori informazioni consulta la [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Nota che **`iam.serviceAccountKeys.update` non funzionerà per modificare la chiave** di un SA perché per fare ciò è necessario anche il permesso `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Se hai il permesso **`iam.serviceAccounts.implicitDelegation`** su un Service Account che ha il permesso **`iam.serviceAccounts.getAccessToken`** su un terzo Service Account, allora puoi usare implicitDelegation per **creare un token per quel terzo Service Account**. Qui c'è un diagramma per aiutare a spiegare.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Nota che secondo la [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts), la delegazione di `gcloud` funziona solo per generare un token utilizzando il metodo [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken). Quindi qui viene mostrato come ottenere un token usando direttamente l'API:

<details><summary>Generare un token di accesso con delega usando l'API</summary>
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
</details>

È disponibile uno script per automatizzare la [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) e uno script python per abusare di questo privilegio [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Per maggiori informazioni consulta la [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Un attacker con le autorizzazioni menzionate sarà in grado di **firmare payload arbitrari in GCP**. Quindi sarà possibile **create an unsigned JWT of the SA and then send it as a blob to get the JWT signed** dal SA che stiamo prendendo di mira. Per maggiori informazioni [**read this**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

È disponibile uno script per automatizzare la [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) e uno script python per abusare di questo privilegio [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) e [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Per maggiori informazioni consulta la [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Un attacker con le autorizzazioni menzionate sarà in grado di **firmare JSON web token ben formati (JWT)**. La differenza con il metodo precedente è che **invece di far sì che google firmi un blob contenente un JWT, usiamo il metodo signJWT che si aspetta già un JWT**. Questo lo rende più facile da usare ma puoi firmare solo JWT invece di qualsiasi byte.

È disponibile uno script per automatizzare la [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) e uno script python per abusare di questo privilegio [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Per maggiori informazioni consulta la [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Un attacker con le autorizzazioni menzionate sarà in grado di **add IAM policies to service accounts**. Puoi abusarne per **grant yourself** i permessi necessari per impersonare il service account. Nel seguente esempio ci stiamo assegnando il ruolo `roles/iam.serviceAccountTokenCreator` sul SA di interesse:

<details><summary>Add IAM policy binding to service account</summary>
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
</details>

Puoi trovare uno script per automatizzare la [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

La **iam.serviceAccounts.actAs permission** è simile alla **iam:PassRole permission from AWS**. È essenziale per eseguire attività, come avviare un'istanza di Compute Engine, poiché concede la capacità di "actAs" un Service Account, garantendo una gestione sicura dei permessi. Senza questo, gli utenti potrebbero ottenere accessi indebiti. Inoltre, sfruttare la **iam.serviceAccounts.actAs** comporta vari metodi, ognuno dei quali richiede un insieme di permessi, in contrasto con altri metodi che ne richiedono solo uno.

#### Impersonazione di Service account <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Impersonare un Service account può essere molto utile per **ottenere privilegi nuovi e migliori**. Ci sono tre modi in cui puoi [impersonate another service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Autenticazione **using RSA private keys** (trattato sopra)
- Autorizzazione **using Cloud IAM policies** (trattato qui)
- **Deploying jobs on GCP services** (più applicabile al compromesso di un account utente)

### `iam.serviceAccounts.getOpenIdToken`

Un attaccante con i permessi menzionati potrà generare un OpenID JWT. Questi token sono usati per attestare l'identità e non implicano necessariamente un'autorizzazione su una risorsa.

Secondo questo [**interesting post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), è necessario indicare l'audience (il servizio presso il quale vuoi usare il token per autenticarti) e riceverai un JWT firmato da google che indica il service account e l'audience del JWT.

Puoi generare un OpenIDToken (se hai l'accesso) con:

<details><summary>Genera OpenID token per Service account</summary>
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
</details>

Puoi quindi usarlo per accedere al servizio con:

<details><summary>Usa un token OpenID per autenticarti</summary>
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
</details>

Alcuni servizi che supportano l'autenticazione tramite questo tipo di token sono:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (se si usa Google OIDC)

Puoi trovare un esempio su come creare un OpenID token per conto di un service account [**here**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Riferimenti

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
