# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Pronađite više informacija o IAM u:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Napadač sa pomenutim dozvolama će moći da ažurira role dodeljene vama i dodeli vam dodatne dozvole nad drugim resursima, kao što su:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
Možete pronaći skriptu za automatizaciju **kreiranja, exploit-a i čišćenja vuln okruženja ovde** i python skriptu za zloupotrebu ove privilegije [**ovde**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Za više informacija pogledajte [**izvorno istraživanje**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).
```bash
gcloud iam roles update <Rol_NAME> --project <PROJECT_ID> --add-permissions <Permission>
```
### `iam.roles.create` & `iam.serviceAccounts.setIamPolicy`
Permisija `iam.roles.create` omogućava kreiranje prilagođenih uloga u projektu/organizaciji. U rukama napadača, ovo je opasno jer im omogućava da definišu nove skupove dozvola koje kasnije mogu biti dodeljene entitetima (na primer, koristeći `iam.serviceAccounts.setIamPolicy` dozvolu) sa ciljem eskalacije privilegija.
```bash
gcloud iam roles create <ROLE_ID> \
--project=<PROJECT_ID> \
--title="<Title>" \
--description="<Description>" \
--permissions="permission1,permission2,permission3"
```
### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

An attacker sa pomenutim dozvolama će moći da **zahteva access token koji pripada Service Account-a**, tako da je moguće zatražiti access token Service Account-a koji ima više privilegija od našeg.
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
Možete pronaći skriptu koja automatizuje [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) i python skriptu za zloupotrebu ovog privilegija [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Za više informacija pogledajte [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Napadač sa pomenutim dozvolama će moći da **create a user-managed key for a Service Account**, što će nam omogućiti pristup GCP-u kao taj Service Account.
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
Možete pronaći skriptu za automatizaciju [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) i python skriptu za zloupotrebu ove privilegije [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Za više informacija pogledajte [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Imajte na umu da **`iam.serviceAccountKeys.update` won't work to modify the key** SA, jer je za to potrebna i permisija `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Ukoliko imate dozvolu **`iam.serviceAccounts.implicitDelegation`** nad Service Account-om koji ima dozvolu **`iam.serviceAccounts.getAccessToken`** nad trećim Service Account-om, onda možete upotrebiti implicitDelegation da **kreirate token za taj treći Service Account**. Evo dijagrama koji pomaže da se objasni.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Imajte na umu da prema [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts), delegacija `gcloud` radi samo za generisanje tokena koristeći metodu [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken). Dakle, ovde imate kako da dobijete token koristeći API direktno:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
Možete pronaći skriptu za automatizaciju the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) i python skriptu za zloupotrebu ovog privilegija [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Za više informacija pogledajte [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Napadač sa pomenutim privilegijama moći će da **potpiše proizvoljne payloads u GCP**. Dakle biće moguće **kreirati nepotpisani JWT od SA i potom ga poslati kao blob da bi JWT bio potpisan** od strane ciljanog SA. Za više informacija [**read this**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Možete pronaći skriptu za automatizaciju the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) i python skriptu za zloupotrebu ovog privilegija [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) i [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Za više informacija pogledajte [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Napadač sa pomenutim privilegijama moći će da **potpiše ispravno formirane JSON web tokene (JWTs)**. Razlika u odnosu na prethodni metod je što **umesto da google potpiše blob koji sadrži JWT, koristimo signJWT metodu koja već očekuje JWT**. To ga čini lakšim za upotrebu ali možete potpisivati samo JWT umesto proizvoljnih bajtova.

Možete pronaći skriptu za automatizaciju the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) i python skriptu za zloupotrebu ovog privilegija [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Za više informacija pogledajte [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Napadač sa pomenutim privilegijama moći će da **dodaje IAM policies na service accounts**. Možete to zloupotrebiti da **dodelite sebi** permisije koje su vam potrebne da se lažno predstavite kao service account. U sledećem primeru dodeljujemo sebi ulogu `roles/iam.serviceAccountTokenCreator` nad interesantnim SA:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
You can find a script to automate the [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Dozvola **iam.serviceAccounts.actAs** je kao dozvola **iam:PassRole** iz AWS-a. Neophodna je za izvršavanje zadataka, kao što je pokretanje Compute Engine instance, jer omogućava da "actAs" Service Account, što obezbeđuje sigurno upravljanje privilegijama. Bez nje korisnici mogu dobiti neprimeren pristup. Dodatno, eksploatisanje **iam.serviceAccounts.actAs** uključuje različite metode, od kojih svaka zahteva skup dozvola, za razliku od drugih metoda koje zahtevaju samo jednu.

#### Service account impersonation <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Impersonating a service account can be very useful to **obtain new and better privileges**. Postoje tri načina na koja možete [impersonate another service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Authentication **using RSA private keys** (pokazano iznad)
- Authorization **using Cloud IAM policies** (pokazano ovde)
- **Deploying jobs on GCP services** (više primenljivo na kompromitaciju korisničkog naloga)

### `iam.serviceAccounts.getOpenIdToken`

Napadač sa pomenutim dozvolama moći će da generiše OpenID JWT. Oni se koriste za potvrđivanje identiteta i ne nose nužno implicitnu autorizaciju nad resursom.

Prema ovom [**interesting post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), neophodno je navesti audience (servis na kojem želite da koristite token za autentikaciju) i dobićete JWT potpisan od strane Google-a koji označava service account i audience JWT-a.

Možete generisati OpenIDToken (ako imate pristup) pomoću:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
Zatim ga možete jednostavno koristiti za pristup servisu pomoću:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
Neke usluge koje podržavaju autentifikaciju putem ovakvih tokena su:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (if using Google OIDC)

Primer kako da kreirate OpenID token u ime servisnog naloga možete pronaći [**ovde**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Reference

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
