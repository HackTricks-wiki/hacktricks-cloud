# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Trova ulteriori informazioni su IAM in:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Un attaccante con i permessi menzionati sarà in grado di aggiornare un ruolo assegnato a te e darti permessi aggiuntivi su altre risorse come:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
Puoi trovare uno script per automatizzare la **creazione, sfruttamento e pulizia di un ambiente vulnerabile qui** e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Per ulteriori informazioni, controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Un attaccante con i permessi menzionati sarà in grado di **richiedere un token di accesso che appartiene a un Service Account**, quindi è possibile richiedere un token di accesso di un Service Account con più privilegi dei nostri.
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Per ulteriori informazioni, controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Un attaccante con i permessi menzionati sarà in grado di **creare una chiave gestita dall'utente per un Service Account**, che ci permetterà di accedere a GCP come quel Service Account.
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Per ulteriori informazioni, controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Nota che **`iam.serviceAccountKeys.update` non funzionerà per modificare la chiave** di un SA perché per farlo sono necessari anche i permessi `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Se hai il permesso **`iam.serviceAccounts.implicitDelegation`** su un Service Account che ha il permesso **`iam.serviceAccounts.getAccessToken`** su un terzo Service Account, allora puoi usare implicitDelegation per **creare un token per quel terzo Service Account**. Ecco un diagramma per aiutare a spiegare.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Nota che secondo la [**documentazione**](https://cloud.google.com/iam/docs/understanding-service-accounts), la delega di `gcloud` funziona solo per generare un token utilizzando il metodo [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken). Quindi qui hai come ottenere un token utilizzando direttamente l'API:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Per ulteriori informazioni controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Un attaccante con i permessi menzionati sarà in grado di **firmare payload arbitrari in GCP**. Quindi sarà possibile **creare un JWT non firmato del SA e poi inviarlo come blob per ottenere il JWT firmato** dal SA che stiamo prendendo di mira. Per ulteriori informazioni [**leggi questo**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) e [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Per ulteriori informazioni controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Un attaccante con i permessi menzionati sarà in grado di **firmare token web JSON (JWT) ben formati**. La differenza con il metodo precedente è che **invece di far firmare a Google un blob contenente un JWT, utilizziamo il metodo signJWT che già si aspetta un JWT**. Questo rende più facile l'uso, ma puoi solo firmare JWT invece di qualsiasi byte.

Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) e uno script python per abusare di questo privilegio [**qui**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Per ulteriori informazioni controlla la [**ricerca originale**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Un attaccante con i permessi menzionati sarà in grado di **aggiungere politiche IAM agli account di servizio**. Puoi abusarne per **concederti** i permessi di cui hai bisogno per impersonare l'account di servizio. Nel seguente esempio ci stiamo concedendo il ruolo `roles/iam.serviceAccountTokenCreator` sull'interessante SA:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
Puoi trovare uno script per automatizzare la [**creazione, sfruttamento e pulizia di un ambiente vulnerabile qui**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Il **permesso iam.serviceAccounts.actAs** è simile al **permesso iam:PassRole di AWS**. È essenziale per eseguire compiti, come avviare un'istanza di Compute Engine, poiché concede la possibilità di "agire come" un Service Account, garantendo una gestione sicura dei permessi. Senza questo, gli utenti potrebbero ottenere accessi indebiti. Inoltre, sfruttare il **iam.serviceAccounts.actAs** comporta vari metodi, ognuno dei quali richiede un insieme di permessi, a differenza di altri metodi che necessitano solo di uno.

#### Impersonificazione di un service account <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Impersonare un service account può essere molto utile per **ottenere nuovi e migliori privilegi**. Ci sono tre modi in cui puoi [impersonare un altro service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Autenticazione **utilizzando chiavi private RSA** (trattato sopra)
- Autorizzazione **utilizzando politiche Cloud IAM** (trattato qui)
- **Distribuzione di lavori sui servizi GCP** (più applicabile al compromesso di un account utente)

### `iam.serviceAccounts.getOpenIdToken`

Un attaccante con i permessi menzionati sarà in grado di generare un OpenID JWT. Questi vengono utilizzati per affermare l'identità e non portano necessariamente alcuna autorizzazione implicita contro una risorsa.

Secondo questo [**interessante post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), è necessario indicare il pubblico (servizio dove si desidera utilizzare il token per autenticarsi) e si riceverà un JWT firmato da google che indica il service account e il pubblico del JWT.

Puoi generare un OpenIDToken (se hai accesso) con:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
Puoi quindi semplicemente usarlo per accedere al servizio con:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
Alcuni servizi che supportano l'autenticazione tramite questo tipo di token sono:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (se si utilizza Google OIDC)

Puoi trovare un esempio su come creare un token OpenID per conto di un account di servizio [**qui**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Riferimenti

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
