# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

IAM के बारे में अधिक जानकारी प्राप्त करें:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

उल्लेखित अनुमतियों के साथ एक हमलावर आपके लिए असाइन की गई भूमिका को अपडेट कर सकेगा और आपको अन्य संसाधनों के लिए अतिरिक्त अनुमतियाँ दे सकेगा जैसे:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
आप **यहां एक स्क्रिप्ट** पा सकते हैं जो **एक vuln वातावरण के निर्माण, शोषण और सफाई को स्वचालित करती है** और इस विशेषाधिकार का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहां**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py) है। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) देखें।

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

उल्लेखित अनुमतियों के साथ एक हमलावर **एक सेवा खाते से संबंधित एक एक्सेस टोकन का अनुरोध करने में सक्षम होगा**, इसलिए यह संभव है कि एक सेवा खाते का एक्सेस टोकन अनुरोध किया जाए जिसमें हमारे से अधिक विशेषाधिकार हों।
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
आप [**यहां**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) एक स्क्रिप्ट पा सकते हैं जो एक vuln वातावरण के **निर्माण, शोषण और सफाई** को स्वचालित करती है और इस विशेषता का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहां**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py) है। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) देखें।

### `iam.serviceAccountKeys.create`

उपरोक्त अनुमतियों के साथ एक हमलावर **एक सेवा खाते के लिए एक उपयोगकर्ता-प्रबंधित कुंजी बनाने** में सक्षम होगा, जो हमें उस सेवा खाते के रूप में GCP तक पहुंचने की अनुमति देगा।
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
आप [**यहां**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) एक स्क्रिप्ट पा सकते हैं जो एक vuln वातावरण के [**निर्माण, शोषण और सफाई**] को स्वचालित करती है और इस विशेषता का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहां**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py) है। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) की जांच करें।

ध्यान दें कि **`iam.serviceAccountKeys.update` एक SA की कुंजी को संशोधित करने के लिए काम नहीं करेगा** क्योंकि ऐसा करने के लिए `iam.serviceAccountKeys.create` अनुमति भी आवश्यक है।

### `iam.serviceAccounts.implicitDelegation`

यदि आपके पास एक सेवा खाते पर **`iam.serviceAccounts.implicitDelegation`** अनुमति है जो तीसरे सेवा खाते पर **`iam.serviceAccounts.getAccessToken`** अनुमति रखता है, तो आप उस तीसरे सेवा खाते के लिए **एक टोकन बनाने के लिए implicitDelegation का उपयोग कर सकते हैं**। इसे समझाने के लिए यहां एक चित्र है।

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

ध्यान दें कि [**दस्तावेज़ीकरण**](https://cloud.google.com/iam/docs/understanding-service-accounts) के अनुसार, `gcloud` का प्रतिनिधित्व केवल [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken) विधि का उपयोग करके एक टोकन उत्पन्न करने के लिए काम करता है। तो यहां आपके पास सीधे API का उपयोग करके एक टोकन प्राप्त करने का तरीका है:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
आप एक स्क्रिप्ट पा सकते हैं जो [**एक कमजोर वातावरण के निर्माण, शोषण और सफाई को स्वचालित करने के लिए यहाँ है**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) और इस विशेषाधिकार का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहाँ है**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py)। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) देखें।

### `iam.serviceAccounts.signBlob`

उपरोक्त अनुमतियों के साथ एक हमलावर **GCP में मनमाने पेलोड पर हस्ताक्षर करने में सक्षम होगा**। इसलिए यह संभव होगा कि **SA का एक असाइन किया हुआ JWT बनाएं और फिर इसे एक ब्लॉब के रूप में भेजें ताकि हम जिस SA को लक्षित कर रहे हैं, उसके द्वारा JWT पर हस्ताक्षर किया जा सके**। अधिक जानकारी के लिए [**यह पढ़ें**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed)।

आप एक स्क्रिप्ट पा सकते हैं जो [**एक कमजोर वातावरण के निर्माण, शोषण और सफाई को स्वचालित करने के लिए यहाँ है**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) और इस विशेषाधिकार का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहाँ है**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) और [**यहाँ है**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py)। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) देखें।

### `iam.serviceAccounts.signJwt`

उपरोक्त अनुमतियों के साथ एक हमलावर **अच्छी तरह से निर्मित JSON वेब टोकन (JWTs) पर हस्ताक्षर करने में सक्षम होगा**। पिछले तरीके के साथ अंतर यह है कि **ब्लॉब में JWT पर हस्ताक्षर करने के बजाय, हम signJWT विधि का उपयोग करते हैं जो पहले से ही JWT की अपेक्षा करता है**। यह उपयोग में आसान बनाता है लेकिन आप केवल JWT पर हस्ताक्षर कर सकते हैं न कि किसी भी बाइट्स पर।

आप एक स्क्रिप्ट पा सकते हैं जो [**एक कमजोर वातावरण के निर्माण, शोषण और सफाई को स्वचालित करने के लिए यहाँ है**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) और इस विशेषाधिकार का दुरुपयोग करने के लिए एक पायथन स्क्रिप्ट [**यहाँ है**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py)। अधिक जानकारी के लिए [**मूल शोध**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/) देखें।

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

उपरोक्त अनुमतियों के साथ एक हमलावर **सेवा खातों में IAM नीतियाँ जोड़ने में सक्षम होगा**। आप इसका दुरुपयोग करके **अपने लिए** आवश्यक अनुमतियाँ प्रदान कर सकते हैं ताकि सेवा खाते का अनुकरण किया जा सके। निम्नलिखित उदाहरण में हम अपने लिए `roles/iam.serviceAccountTokenCreator` भूमिका प्रदान कर रहे हैं:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
आप [**यहां एक स्क्रिप्ट पा सकते हैं जो एक vuln वातावरण के निर्माण, शोषण और सफाई को स्वचालित करती है**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**।**

### `iam.serviceAccounts.actAs`

**iam.serviceAccounts.actAs अनुमति** AWS से **iam:PassRole अनुमति** के समान है। यह कार्यों को निष्पादित करने के लिए आवश्यक है, जैसे कि Compute Engine उदाहरण शुरू करना, क्योंकि यह एक सेवा खाते के रूप में "actAs" करने की क्षमता प्रदान करता है, जो सुरक्षित अनुमति प्रबंधन सुनिश्चित करता है। इसके बिना, उपयोगकर्ता अनुचित पहुंच प्राप्त कर सकते हैं। इसके अतिरिक्त, **iam.serviceAccounts.actAs** का शोषण विभिन्न तरीकों में शामिल है, प्रत्येक को एक सेट अनुमति की आवश्यकता होती है, जबकि अन्य तरीकों को केवल एक की आवश्यकता होती है।

#### सेवा खाता अनुकरण <a href="#service-account-impersonation" id="service-account-impersonation"></a>

एक सेवा खाते का अनुकरण **नए और बेहतर विशेषाधिकार प्राप्त करने** के लिए बहुत उपयोगी हो सकता है। आप [दूसरे सेवा खाते का अनुकरण](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account) करने के तीन तरीके हैं:

- प्रमाणीकरण **RSA निजी कुंजी का उपयोग करके** (ऊपर कवर किया गया)
- प्राधिकरण **Cloud IAM नीतियों का उपयोग करके** (यहां कवर किया गया)
- **GCP सेवाओं पर नौकरियों को तैनात करना** (एक उपयोगकर्ता खाते के समझौते के लिए अधिक लागू)

### `iam.serviceAccounts.getOpenIdToken`

उपरोक्त अनुमति वाले एक हमलावर OpenID JWT उत्पन्न करने में सक्षम होगा। इनका उपयोग पहचान को प्रमाणित करने के लिए किया जाता है और ये किसी संसाधन के खिलाफ किसी निहित प्राधिकरण को अनिवार्य रूप से नहीं ले जाते हैं।

इस [**दिलचस्प पोस्ट**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b) के अनुसार, यह आवश्यक है कि दर्शक (सेवा जहां आप टोकन का उपयोग करके प्रमाणित होना चाहते हैं) को इंगित किया जाए और आपको एक JWT प्राप्त होगा जो google द्वारा हस्ताक्षरित होगा जो सेवा खाते और JWT के दर्शक को इंगित करता है।

आप OpenIDToken उत्पन्न कर सकते हैं (यदि आपके पास पहुंच है) के साथ:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
फिर आप इसे सेवा तक पहुँचने के लिए बस उपयोग कर सकते हैं:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
कुछ सेवाएँ जो इस प्रकार के टोकन के माध्यम से प्रमाणीकरण का समर्थन करती हैं:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (यदि Google OIDC का उपयोग कर रहे हैं)

आप एक सेवा खाते की ओर से OpenID टोकन बनाने का उदाहरण [**यहाँ**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py) पा सकते हैं।

## संदर्भ

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
