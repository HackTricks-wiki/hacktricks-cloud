# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Знайдіть більше інформації про IAM у:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Зловмисник з вказаними дозволами зможе оновити роль, призначену вам, і надати вам додаткові дозволи на інші ресурси, такі як:
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
Ви можете знайти скрипт для автоматизації **створення, експлуатації та очищення вразливого середовища тут** і python-скрипт для зловживання цими привілеями [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Зловмисник з вказаними дозволами зможе **запросити токен доступу, що належить обліковому запису служби**, тому можливо запросити токен доступу облікового запису служби з більшими привілеями, ніж у нас.
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) та скрипт на python для зловживання цим правом [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Зловмисник з вказаними правами зможе **створити ключ, керований користувачем, для облікового запису служби**, що дозволить нам отримати доступ до GCP як цей обліковий запис служби.
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) та python-скрипт для зловживання цим привілеєм [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Зверніть увагу, що **`iam.serviceAccountKeys.update` не працюватиме для зміни ключа** SA, оскільки для цього також потрібні дозволи `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Якщо у вас є **`iam.serviceAccounts.implicitDelegation`** дозвіл на обліковий запис служби, який має дозвіл **`iam.serviceAccounts.getAccessToken`** на третьому обліковому записі служби, то ви можете використовувати implicitDelegation для **створення токена для цього третього облікового запису служби**. Ось діаграма, яка допоможе пояснити.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Зверніть увагу, що відповідно до [**документації**](https://cloud.google.com/iam/docs/understanding-service-accounts), делегування `gcloud` працює лише для генерації токена за допомогою методу [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken). Отже, ось як отримати токен, використовуючи API безпосередньо:
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) та python-скрипт для зловживання цим привілеєм [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Зловмисник з вказаними дозволами зможе **підписувати довільні дані в GCP**. Отже, буде можливим **створити непідписаний JWT сервісного облікового запису, а потім надіслати його як блоб, щоб отримати підписаний JWT** від сервісного облікового запису, на який ми націлюємося. Для отримання додаткової інформації [**читайте це**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) та python-скрипт для зловживання цим привілеєм [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) і [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Зловмисник з вказаними дозволами зможе **підписувати коректно сформовані JSON веб-токени (JWT)**. Різниця з попереднім методом полягає в тому, що **замість того, щоб змусити Google підписати блоб, що містить JWT, ми використовуємо метод signJWT, який вже очікує JWT**. Це робить його простішим у використанні, але ви можете підписувати лише JWT, а не будь-які байти.

Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) та python-скрипт для зловживання цим привілеєм [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Для отримання додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Зловмисник з вказаними дозволами зможе **додавати політики IAM до сервісних облікових записів**. Ви можете зловживати цим, щоб **наділити себе** дозволами, необхідними для наслідування сервісного облікового запису. У наступному прикладі ми наділяємо себе роллю `roles/iam.serviceAccountTokenCreator` над цікавим SA:
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Дозвіл **iam.serviceAccounts.actAs** подібний до дозволу **iam:PassRole з AWS**. Він є необхідним для виконання завдань, таких як ініціювання екземпляра Compute Engine, оскільки надає можливість "діяти від імені" облікового запису служби, забезпечуючи безпечне управління дозволами. Без цього користувачі можуть отримати невиправданий доступ. Крім того, експлуатація **iam.serviceAccounts.actAs** включає різні методи, кожен з яких вимагає набору дозволів, на відміну від інших методів, які потребують лише одного.

#### Імітація облікового запису служби <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Імітація облікового запису служби може бути дуже корисною для **отримання нових і кращих привілеїв**. Є три способи, якими ви можете [імітувати інший обліковий запис служби](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Аутентифікація **за допомогою приватних ключів RSA** (викладено вище)
- Авторизація **за допомогою політик Cloud IAM** (викладено тут)
- **Розгортання завдань на службах GCP** (більш застосовно до компрометації облікового запису користувача)

### `iam.serviceAccounts.getOpenIdToken`

Зловмисник з вказаними дозволами зможе згенерувати OpenID JWT. Ці токени використовуються для підтвердження особи і не обов'язково містять будь-яку неявну авторизацію щодо ресурсу.

Згідно з цим [**цікавим постом**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), необхідно вказати аудиторію (сервіс, до якого ви хочете використовувати токен для аутентифікації), і ви отримаєте JWT, підписаний google, що вказує на обліковий запис служби та аудиторію JWT.

Ви можете згенерувати OpenIDToken (якщо у вас є доступ) за допомогою:
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
Тоді ви можете просто використовувати це для доступу до сервісу за допомогою:
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
Деякі сервіси, які підтримують аутентифікацію за допомогою таких токенів:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (якщо використовується Google OIDC)

Ви можете знайти приклад того, як створити OpenID токен від імені облікового запису служби [**тут**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Посилання

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
