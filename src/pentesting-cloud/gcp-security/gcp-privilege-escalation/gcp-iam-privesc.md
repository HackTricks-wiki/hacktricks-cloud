# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Weitere Informationen zu IAM finden Sie in:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Ein Angreifer mit den genannten Berechtigungen kann eine Ihnen zugewiesene Rolle aktualisieren und Ihnen zusätzliche Berechtigungen für andere Ressourcen geben, z. B.:

<details><summary>IAM-Rolle aktualisieren, um Berechtigungen hinzuzufügen</summary>
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
</details>

Du findest ein script, um die **creation, exploit and cleaning of a vuln environment here** zu automatisieren und ein python script, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Ein Angreifer mit den genannten Berechtigungen kann ein **access token anfordern, das zu einem Service Account gehört**, wodurch es möglich ist, ein access token eines Service Accounts mit mehr Berechtigungen als unserem anzufordern.

<details><summary>Service Account impersonieren, um ein access token zu erhalten</summary>
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
</details>

Sie finden ein Skript, das die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) automatisiert, und ein Python-Skript, um dieses Privileg [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py) auszunutzen. Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Ein Angreifer mit den genannten Berechtigungen kann **create a user-managed key for a Service Account**, was es uns ermöglicht, auf GCP als dieser Service Account zuzugreifen.

<details><summary>Service Account key erstellen und authentifizieren</summary>
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
</details>

Sie können ein Script finden, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) zu automatisieren und ein Python-Script, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Beachte, dass **`iam.serviceAccountKeys.update` nicht funktioniert, um den Key** eines Service Accounts zu ändern, weil dafür die Berechtigung `iam.serviceAccountKeys.create` ebenfalls benötigt wird.

### `iam.serviceAccounts.implicitDelegation`

Wenn Sie die Berechtigung **`iam.serviceAccounts.implicitDelegation`** auf einem Service Account haben, der die Berechtigung **`iam.serviceAccounts.getAccessToken`** auf einem dritten Service Account besitzt, können Sie implicitDelegation verwenden, um **ein Token für diesen dritten Service Account zu erstellen**. Hier ist ein Diagramm zur Veranschaulichung.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Beachte, dass laut der [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts) die Delegation von `gcloud` nur funktioniert, um ein Token mit der Methode [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken) zu erzeugen. Hier wird gezeigt, wie man ein Token direkt über die API erhält:

<details><summary>Zugriffstoken mit Delegation über die API erzeugen</summary>
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
</details>

Sie finden ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) zu automatisieren und ein python-Skript, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Ein Angreifer mit den genannten Berechtigungen kann **beliebige Payloads in GCP signieren**. Es ist also möglich, **ein nicht signiertes JWT des SA zu erstellen und es dann als Blob zu senden, damit das JWT vom Ziel-SA signiert wird**. Für mehr Informationen [**read this**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Sie finden ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) zu automatisieren und ein python-Skript, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) und [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Ein Angreifer mit den genannten Berechtigungen kann **wohlgeformte JSON web tokens (JWTs) signieren**. Der Unterschied zur vorherigen Methode ist, dass **anstatt google ein Blob signieren zu lassen, das ein JWT enthält, wir die signJWT-Methode verwenden, die bereits ein JWT erwartet**. Das macht die Nutzung einfacher, aber du kannst nur JWTs signieren, statt beliebiger Bytes.

Sie finden ein Skript, um die [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) zu automatisieren und ein python-Skript, um dieses Privileg auszunutzen [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Für mehr Informationen siehe die [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Ein Angreifer mit den genannten Berechtigungen kann **IAM-Policies zu Service Accounts hinzufügen**. Du kannst dies ausnutzen, um dir **selbst** die Berechtigungen zu gewähren, die du benötigst, um dich als das Servicekonto auszugeben. Im folgenden Beispiel gewähren wir uns die Rolle `roles/iam.serviceAccountTokenCreator` für das interessante SA:

<details><summary>IAM-Policy-Bindung zum Servicekonto hinzufügen</summary>
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
</details>

Du findest ein Skript zur Automatisierung der [**Erstellung, Exploit und Bereinigung einer verwundbaren Umgebung hier**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Die Berechtigung `iam.serviceAccounts.actAs` ist vergleichbar mit der `iam:PassRole`-Berechtigung von AWS. Sie ist essenziell, um Aufgaben auszuführen, z. B. das Starten einer Compute Engine-Instanz, da sie die Fähigkeit gewährt, "actAs" ein Servicekonto auszuführen und damit eine sichere Rechteverwaltung ermöglicht. Ohne diese Berechtigung könnten Benutzer unberechtigten Zugriff erlangen. Außerdem beinhaltet das Ausnutzen von `iam.serviceAccounts.actAs` verschiedene Methoden, die jeweils eine Menge von Berechtigungen erfordern — im Gegensatz zu anderen Methoden, die nur eine einzelne Berechtigung benötigen.

#### Service account impersonation <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Die Impersonation (Vortäuschen) eines Servicekontos kann sehr nützlich sein, um neue und bessere Privilegien zu erhalten. Es gibt drei Wege, wie man ein anderes Servicekonto impersonifizieren kann:

- Authentifizierung mittels RSA-Privatschlüsseln (weiter oben behandelt)
- Autorisierung mittels Cloud IAM policies (hier behandelt)
- Deployment von Jobs auf GCP-Services (mehr relevant bei der Kompromittierung eines Benutzerkontos)

### `iam.serviceAccounts.getOpenIdToken`

Ein Angreifer mit den genannten Rechten kann ein OpenID JWT erzeugen. Diese werden verwendet, um Identität zu bestätigen und tragen nicht notwendigerweise eine implizite Autorisierung gegenüber einer Ressource.

Laut diesem [**interessanten Beitrag**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b) muss die audience (der Service, bei dem Du das Token zur Authentifizierung verwenden willst) angegeben werden; Du erhältst ein von google signiertes JWT, das das Servicekonto und die audience des JWT angibt.

Du kannst ein OpenIDToken erzeugen (wenn Du Zugriff hast) mit:

<details><summary>OpenID-Token für Servicekonto erzeugen</summary>
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
</details>

Dann kannst du es einfach verwenden, um auf den Service zuzugreifen mit:

<details><summary>Use OpenID token to authenticate</summary>
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
</details>

Einige Dienste, die Authentifizierung über diese Art von Tokens unterstützen, sind:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (if using Google OIDC)

Ein Beispiel, wie man ein OpenID-Token im Namen eines Service Accounts erstellt, finden Sie [**hier**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Referenzen

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
