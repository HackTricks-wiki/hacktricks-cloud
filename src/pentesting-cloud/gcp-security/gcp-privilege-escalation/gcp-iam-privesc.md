# GCP - IAM Privesc

{{#include ../../../banners/hacktricks-training.md}}

## IAM

Додаткову інформацію про IAM див. у:

{{#ref}}
../gcp-services/gcp-iam-and-org-policies-enum.md
{{#endref}}

### `iam.roles.update` (`iam.roles.get`)

Зловмисник з переліченими дозволами зможе оновити роль, призначену вам, і надати вам додаткові дозволи для інших ресурсів, таких як:

<details><summary>Оновити роль IAM, щоб додати дозволи</summary>
```bash
gcloud iam roles update <rol name> --project <project> --add-permissions <permission>
```
</details>

Ви можете знайти скрипт для автоматизації **створення, експлуатації та очищення vuln середовища тут** і python скрипт для зловживання цим привілеєм [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.roles.update.py). Для додаткової інформації див. [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.getAccessToken` (`iam.serviceAccounts.get`)

Атакуючий із зазначеними дозволами зможе **запитати access token, що належить Service Account**, тож можливо запросити access token Service Account з більшими привілеями, ніж у нас.

<details><summary>Імперсонувати Service Account, щоб отримати access token</summary>
```bash
gcloud --impersonate-service-account="${victim}@${PROJECT_ID}.iam.gserviceaccount.com" \
auth print-access-token
```
</details>

Ви можете знайти скрипт для автоматизації [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/4-iam.serviceAccounts.getAccessToken.sh) та python-скрипт для зловживання цим правом [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getAccessToken.py). Для отримання додаткової інформації перегляньте [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccountKeys.create`

Зловмисник із зазначеними дозволами зможе **create a user-managed key for a Service Account**, що дозволить нам отримати доступ до GCP від імені цієї Service Account.

<details><summary>Створити service account key та автентифікуватися</summary>
```bash
gcloud iam service-accounts keys create --iam-account <name> /tmp/key.json

gcloud auth activate-service-account --key-file=sa_cred.json
```
</details>

Ви можете знайти скрипт для автоматизації [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/3-iam.serviceAccountKeys.create.sh) та python-скрипт для зловживання цим дозволом [**here**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccountKeys.create.py). Для додаткової інформації див. [**original research**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

Зверніть увагу, що **`iam.serviceAccountKeys.update` won't work to modify the key** of a SA, бо для цього також потрібні права `iam.serviceAccountKeys.create`.

### `iam.serviceAccounts.implicitDelegation`

Якщо у вас є дозвіл **`iam.serviceAccounts.implicitDelegation`** на Service Account, який має дозвіл **`iam.serviceAccounts.getAccessToken`** на третій Service Account, то ви можете використати implicitDelegation, щоб **створити токен для тієї третьої Service Account**. Нижче — діаграма для пояснення.

![](https://rhinosecuritylabs.com/wp-content/uploads/2020/04/image2-500x493.png)

Зауважте, що відповідно до [**documentation**](https://cloud.google.com/iam/docs/understanding-service-accounts), делегування через `gcloud` працює лише для генерації токена за допомогою методу [**generateAccessToken()**](https://cloud.google.com/iam/credentials/reference/rest/v1/projects.serviceAccounts/generateAccessToken). Отже, нижче показано, як отримати токен безпосередньо через API:

<details><summary>Генерація токена доступу через делегування за допомогою API</summary>
```bash
curl -X POST \
'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/'"${TARGET_SERVICE_ACCOUNT}"':generateAccessToken' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer '"$(gcloud auth print-access-token)" \
-d '{
"delegates": ["projects/-/serviceAccounts/'"${DELEGATED_SERVICE_ACCOUNT}"'"],
"scope": ["https://www.googleapis.com/auth/cloud-platform"]
}'
```
</details>

Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/5-iam.serviceAccounts.implicitDelegation.sh) та python скрипт для зловживання цією привілеєю [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.implicitDelegation.py). Для додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signBlob`

Зловмисник із зазначеними дозволами зможе **підписувати довільні payloads у GCP**. Тому стане можливим **створити непідписаний JWT для SA і потім відправити його як blob, щоб отримати підпис JWT** від цільового SA. Для додаткової інформації [**читайте це**](https://medium.com/google-cloud/using-serviceaccountactor-iam-role-for-account-impersonation-on-google-cloud-platform-a9e7118480ed).

Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/6-iam.serviceAccounts.signBlob.sh) та python скрипт для зловживання цією привілеєю [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-accessToken.py) і [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signBlob-gcsSignedUrl.py). Для додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.signJwt`

Зловмисник із згаданими дозволами зможе **підписувати коректно сформовані JSON web tokens (JWTs)**. Відмінність від попереднього методу в тому, що **замість того, щоб змусити google підписати blob, який містить JWT, ми використовуємо метод signJWT, який вже очікує JWT**. Це спрощує використання, але дозволяє підписувати лише JWT, а не будь-які байти.

Ви можете знайти скрипт для автоматизації [**створення, експлуатації та очищення вразливого середовища тут**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/7-iam.serviceAccounts.signJWT.sh) та python скрипт для зловживання цією привілеєю [**тут**](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.signJWT.py). Для додаткової інформації перегляньте [**оригінальне дослідження**](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/).

### `iam.serviceAccounts.setIamPolicy` <a href="#iam.serviceaccounts.setiampolicy" id="iam.serviceaccounts.setiampolicy"></a>

Зловмисник із зазначеними дозволами зможе **додавати IAM політики до service accounts**. Це можна зловживати, щоб **наділити себе** дозволами, необхідними для імперсонації service account. У наведеному прикладі ми надаємо собі роль `roles/iam.serviceAccountTokenCreator` над цікавим SA:

<details><summary>Додати прив'язку IAM-політики до service account</summary>
```bash
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountTokenCreator"

# If you still have prblem grant yourself also this permission
gcloud iam service-accounts add-iam-policy-binding "${VICTIM_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \ \
--member="user:username@domain.com" \
--role="roles/iam.serviceAccountUser"
```
</details>

Ви можете знайти скрипт для автоматизації [**creation, exploit and cleaning of a vuln environment here**](https://github.com/carlospolop/gcp_privesc_scripts/blob/main/tests/d-iam.serviceAccounts.setIamPolicy.sh)**.**

### `iam.serviceAccounts.actAs`

Дозвіл **iam.serviceAccounts.actAs** схожий на **iam:PassRole permission from AWS**. Він необхідний для виконання певних завдань, наприклад ініціювання інстансу Compute Engine, оскільки дає змогу «actAs» Service Account та забезпечує безпечне управління правами. За відсутності цього користувачі можуть отримати надмірний доступ. Крім того, експлуатація **iam.serviceAccounts.actAs** може здійснюватися різними методами, кожен з яких вимагає набору дозволів, на відміну від інших методів, що потребують лише одного.

#### Service account impersonation <a href="#service-account-impersonation" id="service-account-impersonation"></a>

Імперсонування service account може бути дуже корисним для **отримання нових і кращих привілеїв**. Існує три способи, якими ви можете [impersonate another service account](https://cloud.google.com/iam/docs/understanding-service-accounts#impersonating_a_service_account):

- Аутентифікація **using RSA private keys** (описано вище)
- Авторизація **using Cloud IAM policies** (описано тут)
- **Deploying jobs on GCP services** (більш застосовно при компрометації user account)

### `iam.serviceAccounts.getOpenIdToken`

Атакуючий з переліченими дозволами зможе згенерувати OpenID JWT. Вони використовуються для підтвердження особи і не обов’язково надають будь-яку неявну авторизацію щодо ресурсу.

Згідно з цим [**interesting post**](https://medium.com/google-cloud/authenticating-using-google-openid-connect-tokens-e7675051213b), потрібно вказати audience (сервіс, де ви хочете використати токен для аутентифікації), і ви отримаєте підписаний google JWT, в якому вказано service account та audience JWT.

Ви можете згенерувати OpenIDToken (якщо маєте доступ) за допомогою:

<details><summary>Згенерувати OpenID token для service account</summary>
```bash
# First activate the SA with iam.serviceAccounts.getOpenIdToken over the other SA
gcloud auth activate-service-account --key-file=/path/to/svc_account.json
# Then, generate token
gcloud auth print-identity-token "${ATTACK_SA}@${PROJECT_ID}.iam.gserviceaccount.com" --audiences=https://example.com
```
</details>

Тоді ви можете просто використати його для доступу до сервісу за допомогою:

<details><summary>Використати OpenID token для автентифікації</summary>
```bash
curl -v -H "Authorization: Bearer id_token" https://some-cloud-run-uc.a.run.app
```
</details>

Деякі сервіси, що підтримують автентифікацію за допомогою такого типу токенів:

- [Google Cloud Run](https://cloud.google.com/run/)
- [Google Cloud Functions](https://cloud.google.com/functions/docs/)
- [Google Identity Aware Proxy](https://cloud.google.com/iap/docs/authentication-howto)
- [Google Cloud Endpoints](https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id) (якщо використовується Google OIDC)

Ви можете знайти приклад того, як створити OpenID-токен від імені service account [**тут**](https://github.com/carlospolop-forks/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/iam.serviceAccounts.getOpenIdToken.py).

## Посилання

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
