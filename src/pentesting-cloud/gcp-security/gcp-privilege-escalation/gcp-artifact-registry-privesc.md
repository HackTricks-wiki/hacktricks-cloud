# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Weitere Informationen zu Artifact Registry:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Mit dieser Berechtigung könnte ein attacker neue Versionen der Artefakte mit bösartigem Code, z. B. Docker-Images, hochladen:

<details>
<summary>Docker-Image in Artifact Registry hochladen</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Es wurde überprüft, dass es **möglich ist, ein neues bösartiges docker image** mit demselben Namen und Tag wie das bereits vorhandene hochzuladen, sodass das **alte den Tag verliert** und beim nächsten Download dieses Images mit diesem Tag **das bösartige heruntergeladen wird**.

<details>

<summary>Eine Python-Bibliothek hochladen</summary>

**Beginnen Sie damit, die Bibliothek zu erstellen, die Sie hochladen möchten** (wenn Sie die neueste Version aus der Registry herunterladen können, können Sie diesen Schritt überspringen):

1.  **Richten Sie die Projektstruktur ein**:

- Erstellen Sie ein neues Verzeichnis für Ihre Bibliothek, z. B. `hello_world_library`.
- Erstellen Sie innerhalb dieses Verzeichnisses ein weiteres Verzeichnis mit dem Namen Ihres Pakets, z. B. `hello_world`.
- Erstellen Sie in Ihrem Paketverzeichnis eine `__init__.py`-Datei. Diese Datei kann leer sein oder Initialisierungen für Ihr Paket enthalten.

<details>
<summary>Projektstruktur erstellen</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Schreiben Sie Ihren Bibliothekscode**:

- Erstellen Sie im Verzeichnis `hello_world` eine neue Python-Datei für Ihr Modul, z. B. `greet.py`.
- Schreiben Sie Ihre "Hello, World!"-Funktion:

<details>
<summary>Library-Modul erstellen</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Erstellen Sie eine `setup.py`-Datei**:

- Erstellen Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses eine `setup.py`-Datei.
- Diese Datei enthält Metadaten über Ihre Bibliothek und teilt Python mit, wie sie installiert werden soll.

<details>
<summary>setup.py-Datei erstellen</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Jetzt laden wir die Bibliothek hoch:**

1.  **Bauen Sie Ihr Paket**:

- Führen Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses aus:

<details>
<summary>Paket bauen</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Konfigurieren Sie die Authentifizierung für twine** (wird zum Hochladen Ihres Pakets verwendet):
- Stellen Sie sicher, dass `twine` installiert ist (`pip install twine`).
- Verwenden Sie `gcloud`, um die Anmeldeinformationen zu konfigurieren:

<details>
<summary>Paket mit twine hochladen</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Build bereinigen**

<details>
<summary>Build-Artefakte bereinigen</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Es ist nicht möglich, eine python-Bibliothek mit derselben Version wie die bereits vorhandene hochzuladen, aber es ist möglich, **größere Versionen** hochzuladen (oder eine zusätzliche **`.0` am Ende** der Version hinzuzufügen, falls das funktioniert - nicht bei python), oder die **letzte Version zu löschen und eine neue hochzuladen** (benötigt `artifactregistry.versions.delete`):

<details>
<summary>Delete artifact version</summary>

```sh
gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
```

</details>

### `artifactregistry.repositories.downloadArtifacts`

Mit dieser Berechtigung können Sie **Artefakte herunterladen** und nach **sensiblen Informationen** und **Schwachstellen** suchen.

Download a **Docker** image:

<details>
<summary>Download Docker image from Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Lade eine **python**-Bibliothek herunter:

<details>
<summary>Python-Bibliothek aus Artifact Registry herunterladen</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Was passiert, wenn remote- und standard-Registries in einer virtuellen Registry gemischt werden und ein Paket in beiden existiert? Siehe diese Seite:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Artefakte aus der Registry löschen, z. B. docker images:

<details>
<summary>Docker-Image aus Artifact Registry löschen</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Ein komplettes Repository löschen (auch wenn es Inhalte hat):

<details>
<summary>Artifact Registry-Repository löschen</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Ein Angreifer mit dieser Berechtigung könnte sich selbst Rechte geben, um einige der zuvor genannten Repository-Angriffe durchzuführen.

### Pivoting zu anderen Services durch Artifact Registry Read & Write

- **Cloud Functions**

Wenn eine Cloud Function erstellt wird, wird ein neues docker image in das Artifact Registry des Projekts hochgeladen. Ich habe versucht, das Image durch ein neues zu ersetzen und sogar das aktuelle Image (und das `cache` image) zu löschen, und es änderte sich nichts — die Cloud Function lief weiterhin. Daher könnte es **möglicherweise möglich sein, eine Race Condition attack auszunutzen** wie bei den buckets, um den docker container zu ändern, der ausgeführt wird, aber **allein das Ändern des gespeicherten Images reicht offenbar nicht aus, um die Cloud Function zu kompromittieren**.

- **App Engine**

Obwohl App Engine docker images im Artifact Registry erstellt. Es wurde getestet, dass **selbst wenn man das Image innerhalb dieses Dienstes ändert** und die App Engine-Instanz entfernt (so dass eine neue bereitgestellt wird), sich der **ausgeführte Code nicht ändert**.\
Es könnte möglich sein, dass das Durchführen einer **Race Condition attack wie bei den buckets möglicherweise den ausgeführten Code überschreiben kann**, aber das wurde nicht getestet.

{{#include ../../../banners/hacktricks-training.md}}
