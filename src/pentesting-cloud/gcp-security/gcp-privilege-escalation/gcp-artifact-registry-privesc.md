# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Για περισσότερες πληροφορίες σχετικά με το Artifact Registry, δείτε:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Με αυτή την άδεια, ένας επιτιθέμενος θα μπορούσε να ανεβάσει νέες εκδόσεις των artifacts με κακόβουλο κώδικα, όπως Docker images:

<details>
<summary>Μεταφόρτωση εικόνας Docker στο Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Ελέγχθηκε ότι είναι **δυνατό να ανεβάσετε μια νέα κακόβουλη docker** εικόνα με το ίδιο όνομα και tag με αυτή που υπάρχει ήδη, οπότε η **παλιά θα χάσει το tag** και την επόμενη φορά που αυτή η εικόνα με αυτό το tag θα **κατέβει, θα κατέβει η κακόβουλη**.

<details>

<summary>Ανέβασμα βιβλιοθήκης Python</summary>

**Ξεκινήστε δημιουργώντας τη βιβλιοθήκη που θα ανεβάσετε** (αν μπορείτε να κατεβάσετε την τελευταία έκδοση από το αποθετήριο μπορείτε να αποφύγετε αυτό το βήμα):

1.  **Ρυθμίστε τη δομή του project σας**:

- Δημιουργήστε έναν νέο φάκελο για τη βιβλιοθήκη σας, π.χ. `hello_world_library`.
- Μέσα σε αυτόν τον φάκελο, δημιουργήστε έναν άλλο φάκελο με το όνομα του πακέτου σας, π.χ. `hello_world`.
- Μέσα στο φάκελο του πακέτου σας, δημιουργήστε ένα αρχείο `__init__.py`. Αυτό το αρχείο μπορεί να είναι κενό ή να περιέχει αρχικοποιήσεις για το πακέτο σας.

<details>
<summary>Δημιουργία δομής project</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Γράψτε τον κώδικα της βιβλιοθήκης σας**:

- Μέσα στον φάκελο `hello_world`, δημιουργήστε ένα νέο αρχείο Python για το module σας, π.χ. `greet.py`.
- Γράψτε τη συνάρτηση "Hello, World!":

<details>
<summary>Δημιουργία module βιβλιοθήκης</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Δημιουργήστε ένα αρχείο `setup.py`**:

- Στη ρίζα του φακέλου `hello_world_library`, δημιουργήστε ένα αρχείο `setup.py`.
- Αυτό το αρχείο περιέχει metadata για τη βιβλιοθήκη σας και λέει στο Python πώς να την εγκαταστήσει.

<details>
<summary>Δημιουργία setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Τώρα, ας ανεβάσουμε τη βιβλιοθήκη:**

1.  **Δημιουργήστε το πακέτο σας**:

- Από τη ρίζα του φακέλου `hello_world_library`, εκτελέστε:

<details>
<summary>Κατασκευή πακέτου Python</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Διαμορφώστε την αυθεντικοποίηση για το twine** (χρησιμοποιείται για το ανέβασμα του πακέτου σας):
- Βεβαιωθείτε ότι έχετε εγκαταστήσει το `twine` (`pip install twine`).
- Χρησιμοποιήστε το `gcloud` για να διαμορφώσετε credentials:

<details>
<summary>Ανέβασμα πακέτου με twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Καθαρισμός του build**

<details>
<summary>Καθαρισμός build artifacts</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Δεν είναι δυνατό να ανεβάσετε μια βιβλιοθήκη python με την ίδια έκδοση που υπάρχει ήδη, αλλά είναι δυνατό να ανεβάσετε **μεγαλύτερες εκδόσεις** (ή να προσθέσετε ένα επιπλέον **`.0` στο τέλος** της έκδοσης αν αυτό λειτουργεί — όχι όμως σε python), ή να **διαγράψετε την τελευταία έκδοση και να ανεβάσετε μια νέα με** (needed `artifactregistry.versions.delete)`**:**
>
> <details>
> <summary>Διαγραφή έκδοσης artifact</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Με αυτήν την άδεια μπορείτε να **κατεβάζετε artifacts** και να αναζητάτε **ευαίσθητες πληροφορίες** και **ευπάθειες**.

Download a **Docker** image:

<details>
<summary>Λήψη Docker image από Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Κατεβάστε μια βιβλιοθήκη **python**:

<details>
<summary>Κατεβάστε βιβλιοθήκη Python από το Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Τι συμβαίνει αν ένα remote και ένα standard registries αναμειχθούν σε ένα virtual και ένα package υπάρχει και στα δύο; Δες αυτή τη σελίδα:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Διαγραφή artifacts από το Artifact Registry, όπως docker images:

<details>
<summary>Διαγραφή Docker image από το Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Διαγραφή ενός πλήρους repository (ακόμη κι αν έχει περιεχόμενο):

<details>
<summary>Διαγραφή repository του Artifact Registry</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Ένας επιτιθέμενος με αυτό το δικαίωμα θα μπορούσε να χορηγήσει στον εαυτό του δικαιώματα για να εκτελέσει μερικές από τις προαναφερθείσες επιθέσεις στο repository.

### Pivoting σε άλλες υπηρεσίες μέσω Artifact Registry Read & Write

- **Cloud Functions**

Όταν δημιουργείται μια Cloud Function, μια νέα docker image ανεβαίνει στο Artifact Registry του project. Προσπάθησα να τροποποιήσω την εικόνα με μια καινούργια, και ακόμη να διαγράψω την τρέχουσα εικόνα (και την `cache` image) και τίποτα δεν άλλαξε — η Cloud Function συνέχισε να λειτουργεί. Επομένως, ίσως **να είναι δυνατό να καταχραστείς μια Race Condition attack** όπως με το bucket για να αλλάξεις το docker container που θα εκτελεστεί, αλλά **απλώς τροποποιώντας την αποθηκευμένη εικόνα δεν είναι δυνατό να παραβιάσεις την Cloud Function**.

- **App Engine**

Παρόλο που το App Engine δημιουργεί docker images μέσα στο Artifact Registry. Δοκιμάστηκε ότι **ακόμη και αν τροποποιήσεις την εικόνα μέσα σε αυτήν την υπηρεσία** και αφαιρέσεις το App Engine instance (οπότε γίνεται deploy ενός νέου), ο **εκτελούμενος κώδικας δεν αλλάζει**.\
Μπορεί να είναι δυνατό ότι πραγματοποιώντας μια **Race Condition attack όπως με τα buckets θα ήταν πιθανό να αντικαταστήσεις τον εκτελούμενο κώδικα**, αλλά αυτό δεν δοκιμάστηκε.

{{#include ../../../banners/hacktricks-training.md}}
