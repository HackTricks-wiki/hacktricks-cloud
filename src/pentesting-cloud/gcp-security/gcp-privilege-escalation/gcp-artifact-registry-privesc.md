# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Pour plus d'informations sur Artifact Registry, consultez :

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Avec cette permission, un attacker pourrait téléverser de nouvelles versions des artifacts contenant du code malveillant, par exemple des images Docker :

<details>
<summary>Téléverser une image Docker dans Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Il a été vérifié qu'il est **possible de téléverser une nouvelle image docker malveillante** avec le même nom et tag que celle déjà présente, donc l'**ancienne perdra le tag** et la prochaine fois que l'image avec ce tag sera **téléchargée, ce sera la malveillante qui sera récupérée**.

<details>

<summary>Téléverser une bibliothèque Python</summary>

**Commencez par créer la bibliothèque à téléverser** (si vous pouvez télécharger la dernière version depuis le registry vous pouvez éviter cette étape) :

1.  **Mettez en place la structure du projet** :

- Créez un nouveau répertoire pour votre bibliothèque, p.ex., `hello_world_library`.
- À l'intérieur de ce répertoire, créez un autre répertoire avec le nom de votre package, p.ex., `hello_world`.
- Dans le répertoire de votre package, créez un fichier `__init__.py`. Ce fichier peut être vide ou contenir des initialisations pour votre package.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Écrivez le code de votre bibliothèque** :

- À l'intérieur du répertoire `hello_world`, créez un nouveau fichier Python pour votre module, p.ex., `greet.py`.
- Écrivez votre fonction "Hello, World !" :

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Créez un fichier `setup.py`** :

- À la racine de votre répertoire `hello_world_library`, créez un fichier `setup.py`.
- Ce fichier contient des métadonnées sur votre bibliothèque et indique à Python comment l'installer.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Maintenant, téléversons la bibliothèque :**

1.  **Construisez votre package** :

- Depuis la racine de votre répertoire `hello_world_library`, exécutez :

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Configurez l'authentification pour twine** (utilisé pour téléverser votre package) :
- Assurez-vous d'avoir `twine` installé (`pip install twine`).
- Utilisez `gcloud` pour configurer les credentials :

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Nettoyer la compilation**

<details>
<summary>Supprimer les artefacts de compilation</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Il n'est pas possible d'uploader une bibliothèque python avec la même version que celle déjà présente, mais il est possible d'uploader des **versions supérieures** (ou d'ajouter un **`.0` à la fin** de la version si cela fonctionne — pas en python toutefois), ou de **supprimer la dernière version et d'uploader une nouvelle** (nécessite `artifactregistry.versions.delete)`**:**
>
> <details>
> <summary>Supprimer une version d'un artifact</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Avec cette permission, vous pouvez **télécharger des artifacts** et rechercher des **informations sensibles** et des **vulnérabilités**.

Télécharger une image **Docker** :

<details>
<summary>Télécharger une image Docker depuis Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Télécharger une bibliothèque **python** :

<details>
<summary>Télécharger une bibliothèque Python depuis Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Que se passe-t-il si des registres distants et standard sont mélangés dans un registre virtuel et qu'un package existe dans les deux ? Consultez cette page :

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Supprimer des artefacts du registre, comme des images Docker :

<details>
<summary>Supprimer une image Docker depuis Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Supprimer un repository complet (même s'il contient du contenu) :

<details>
<summary>Supprimer le repository Artifact Registry</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Un attaquant disposant de cette permission pourrait s'octroyer des droits lui permettant d'effectuer certaines des attaques de repository mentionnées précédemment.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

Lorsqu'une Cloud Function est créée, une nouvelle image docker est poussée dans l'Artifact Registry du projet. J'ai essayé de remplacer l'image par une nouvelle, et même de supprimer l'image actuelle (et l'image `cache`) et rien n'a changé : la Cloud Function a continué de fonctionner. Par conséquent, il **pourrait être possible d'abuser d'une Race Condition attack** comme avec le bucket pour changer le docker container qui sera exécuté, mais **seulement modifier l'image stockée ne permet pas de compromettre la Cloud Function**.

- **App Engine**

Même si App Engine crée des docker images dans l'Artifact Registry, il a été testé que **même si vous modifiez l'image dans ce service** et supprimez l'instance App Engine (donc une nouvelle est déployée), le **code exécuté ne change pas**.\
Il est possible que la réalisation d'une **Race Condition attack comme avec les buckets puisse permettre d'écraser le code exécuté**, mais cela n'a pas été testé.

{{#include ../../../banners/hacktricks-training.md}}
