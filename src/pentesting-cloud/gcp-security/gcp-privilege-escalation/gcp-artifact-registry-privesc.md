# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Vir meer inligting oor Artifact Registry sien:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Met hierdie toestemming kan 'n aanvaller nuwe weergawes van die artefakte met kwaadwillige kode, soos Docker-images, oplaai:

<details>
<summary>Laai Docker-image op na Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Daar is getoets dat dit **moontlik is om 'n nuwe kwaadwillige docker** image op te laai met dieselfde naam en tag as die een wat reeds bestaan, sodat die **oude een die tag sal verloor** en die volgende keer dat daardie image met daardie tag **afgehaal word die kwaadwillige een afgelaai sal word**.

<details>

<summary>Laai 'n Python-biblioteek op</summary>

**Begin deur die biblioteek te skep wat jy wil oplaai** (as jy die nuutste weergawe van die registry kan aflaai kan jy hierdie stap oorskiet):

1.  **Stel jou projekstruktuur op**:

- Skep 'n nuwe gids vir jou biblioteek, bv. `hello_world_library`.
- Binne hierdie gids, skep nog 'n gids met jou pakketnaam, bv. `hello_world`.
- Binne jou pakketgids, skep 'n `__init__.py`-lêer. Hierdie lêer kan leeg wees of inisialisasies vir jou pakket bevat.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Skryf jou biblioteekkode**:

- Binne die `hello_world`-gids, skep 'n nuwe Python-lêer vir jou module, bv. `greet.py`.
- Skryf jou "Hello, World!"-funksie:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Skep 'n `setup.py`-lêer**:

- In die wortel van jou `hello_world_library`-gids, skep 'n `setup.py`-lêer.
- Hierdie lêer bevat metadata oor jou biblioteek en vertel Python hoe om dit te installeer.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Nou, kom ons laai die biblioteek op:**

1.  **Bou jou pakket**:

- Vanaf die wortel van jou `hello_world_library`-gids, voer uit:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Konfigureer verifikasie vir twine** (wat gebruik word om jou pakket op te laai):
- Maak seker jy het `twine` geïnstalleer (`pip install twine`).
- Gebruik `gcloud` om geloofsbriewe te konfigureer:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Maak die build skoon**

<details>
<summary>Maak build-artefakte skoon</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Dit is nie moontlik om 'n python-biblioteek met dieselfde weergawe as die een wat reeds daar is op te laai nie, maar dit is moontlik om **hoër weergawes** op te laai (of 'n ekstra **`.0` aan die einde** van die weergawe by te voeg indien dit werk — nie in python nie), of om die **laaste weergawe te verwyder en 'n nuwe een op te laai** (benodig `artifactregistry.versions.delete`): 
>
> <details>
> <summary>Verwyder artefakweergawe</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Met hierdie toestemming kan jy **artefakte aflaai** en soek na **sensitiewe inligting** en **kwesbaarhede**.

Laai 'n **Docker** beeld af:

<details>
<summary>Laai Docker-beeld van Artifact Registry af</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Laai 'n **python**-biblioteek af:

<details>
<summary>Laai Python-biblioteek vanaf Artifact Registry af</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Wat gebeur as 'n remote- en 'n standaard-register in 'n virtuele een gemeng word en 'n pakket in albei bestaan? Kyk hierdie bladsy:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Verwyder artefakte uit die register, soos Docker images:

<details>
<summary>Verwyder Docker image vanaf Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Verwyder 'n volledige repository (selfs al het dit inhoud):

<details>
<summary>Verwyder Artifact Registry repository</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

'n Aanvaller met hierdie toestemming kan homself toestemmings gee om sommige van die voorafgenoemde repository-aanvalle uit te voer.

### Pivoting na ander dienste deur Artifact Registry Read & Write

- **Cloud Functions**

Wanneer 'n Cloud Function geskep word, word 'n nuwe docker image na die Artifact Registry van die projek gestoot. Ek het probeer om die image te vervang met 'n nuwe een, en selfs die huidige image (en die `cache` image) te verwyder, maar niks het verander nie; die Cloud Function het voortgegaan om te werk. Daarom is dit dalk moontlik om 'n **Race Condition attack** te misbruik soos met die bucket om die docker container wat uitgevoer sal word te verander, maar **slegs die wysiging van die gestoorde image maak nie die Cloud Function kwesbaar nie**.

- **App Engine**

Alhoewel App Engine docker images binne Artifact Registry skep, is dit getoets dat **selfs as jy die image binne hierdie diens wysig** en die App Engine-instance verwyder (sodat 'n nuwe een gedeploy word), die **uitgevoerde kode nie verander nie**.\
Dit mag moontlik wees dat deur 'n **Race Condition attack soos met die buckets dit moontlik is om die uitgevoerde kode oor te skryf**, maar dit is nie getoets nie.

{{#include ../../../banners/hacktricks-training.md}}
