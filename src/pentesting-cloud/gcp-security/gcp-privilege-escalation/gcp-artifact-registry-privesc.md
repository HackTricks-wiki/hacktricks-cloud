# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Artifact Registry hakkında daha fazla bilgi için bakınız:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Bu izinle bir saldırgan, Docker imajları gibi kötü amaçlı kod içeren artifact'ların yeni sürümlerini yükleyebilir:

<details>
<summary>Artifact Registry'ye Docker imajı yükle</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Aynı isim ve tag'e sahip yeni bir **kötü amaçlı docker yüklemek mümkün** olduğu doğrulandı, bu yüzden **eski olan tag'i kaybedecek** ve bu tag ile bir dahaki indirmede **kötü amaçlı olan** indirilecektir.

<details>

<summary>Bir Python kütüphanesi yükle</summary>

**Yüklemek için kütüphaneyi oluşturarak başlayın** (registry'den en son sürümü indirebiliyorsanız bu adımı atlayabilirsiniz):

1.  **Proje yapınızı oluşturun**:

- Kütüphaneniz için yeni bir dizin oluşturun, örn., `hello_world_library`.
- Bu dizinin içinde paket adınızla başka bir dizin oluşturun, örn., `hello_world`.
- Paket dizininizin içinde bir `__init__.py` dosyası oluşturun. Bu dosya boş olabilir veya paketiniz için başlangıç kodu içerebilir.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Kütüphane kodunuzu yazın**:

- `hello_world` dizini içinde modülünüz için yeni bir Python dosyası oluşturun, örn., `greet.py`.
- "Hello, World!" fonksiyonunuzu yazın:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Bir `setup.py` dosyası oluşturun**:

- `hello_world_library` dizininizin kökünde bir `setup.py` dosyası oluşturun.
- Bu dosya kütüphaneniz hakkında metadata içerir ve Python'a nasıl kurulacağını söyler.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Şimdi kütüphaneyi yükleyelim:**

1.  **Paketinizi oluşturun**:

- `hello_world_library` dizininin kökünden şu komutu çalıştırın:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **twine için doğrulamayı yapılandırın** (paketinizi yüklemek için kullanılır):
- `twine`'in yüklü olduğundan emin olun (`pip install twine`).
- Kimlik bilgilerini yapılandırmak için `gcloud` kullanın:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Derlemeyi temizle**

<details>
<summary>Derleme çıktılarını temizle</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Aynı sürüme sahip bir python kütüphanesini yüklemek mümkün değil, ancak daha yüksek sürümleri yüklemek mümkündür (veya sürümün sonuna işe yarıyorsa ekstra **`.0` eklemek** — python'da işe yaramaz), veya son sürümü silip yeni bir sürüm yüklemek mümkündür (gerekli: `artifactregistry.versions.delete`):
>
> <details>
> <summary>Artifact sürümünü sil</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Bu izinle **artifact'leri indirebilir** ve **hassas bilgileri** ve **güvenlik açıklarını** arayabilirsiniz.

Bir **Docker** imajı indir:

<details>
<summary>Artifact Registry'den Docker imajı indir</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Download a **python** library:

<details>
<summary>Artifact Registry'den Python kütüphanesini indir</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Uzak (remote) ve standard registry'ler sanal bir registry içinde karıştığında ve bir paket her ikisinde de varsa ne olur? Bu sayfaya bakın:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Registry'den docker images gibi artefaktları silin:

<details>
<summary>Artifact Registry'den Docker image silme</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Tam bir Artifact Registry repository'sini sil (içinde içerik olsa bile):

<details>
<summary>Artifact Registry repository'sini sil</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Bu izne sahip bir attacker kendisine daha önce bahsedilen bazı repository saldırılarını gerçekleştirmek için izinler verebilir.

### Artifact Registry Read & Write üzerinden diğer servislere Pivoting

- **Cloud Functions**

Bir Cloud Function oluşturulduğunda proje Artifact Registry'sine yeni bir docker image push edilir. Görüntüyü yeni bir tane ile değiştirmeyi, hatta mevcut image'ı (ve `cache` image'ını) silmeyi denedim fakat hiçbir şey değişmedi; cloud function çalışmaya devam etti. Bu yüzden, tıpkı bucket'larda olduğu gibi çalıştırılacak docker container'ı değiştirmek için bir Race Condition attack'ı suistimal etmek mümkün olabilir, fakat sadece depolanan image'ı değiştirmek Cloud Function'ı ele geçirmek için yeterli değil.

- **App Engine**

App Engine, Artifact Registry içinde docker image'lar oluşturmasına rağmen. Servis içindeki image'ı **değiştirseniz bile** ve App Engine instance'ını kaldırıp (yeni bir tane deploy edildiğinde) **çalıştırılan kod değişmiyor**.\
Bucket'larda olduğu gibi bir **Race Condition attack** gerçekleştirilerek çalıştırılan kodun overwrite edilmesi mümkün olabilir, ancak bu test edilmedi.

{{#include ../../../banners/hacktricks-training.md}}
