# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Artifact Registry के बारे में अधिक जानकारी के लिए देखें:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

इस permission के साथ attacker malicious code वाले artifacts (जैसे Docker images) के नए संस्करण अपलोड कर सकता है:

<details>
<summary>Artifact Registry में Docker image अपलोड करें</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> यह जाँच किया गया कि यह **संभव है कि एक नया malicious docker** image उसी नाम और tag के साथ upload किया जा सके जो पहले से मौजूद है, इसलिए पुराना image **tag खो देगा** और अगली बार जब उस tag के साथ image **download** किया जाएगा तो malicious वाला ही डाउनलोड होगा।

<details>

<summary>Upload a Python library</summary>

**अपलोड करने के लिए लाइब्रेरी बनाकर शुरू करें** (यदि आप registry से नवीनतम संस्करण डाउनलोड कर सकते हैं तो आप यह कदम छोड़ सकते हैं):

1.  **अपने प्रोजेक्ट की संरचना सेट अप करें**:

- अपनी लाइब्रेरी के लिए एक नया डायरेक्टरी बनाएं, उदाहरण के लिए `hello_world_library`.
- इस डायरेक्टरी के अंदर, अपने पैकेज नाम के साथ एक और डायरेक्टरी बनाएं, उदाहरण के लिए `hello_world`.
- अपने पैकेज डायरेक्टरी के अंदर एक `__init__.py` फ़ाइल बनाएं। यह फ़ाइल खाली हो सकती है या आपके पैकेज के शुरुआती initializations रख सकती है।

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **अपनी लाइब्रेरी कोड लिखें**:

- `hello_world` डायरेक्टरी के अंदर अपने मॉड्यूल के लिए एक नया Python फ़ाइल बनाएं, उदाहरण के लिए `greet.py`.
- अपनी "Hello, World!" फ़ंक्शन लिखें:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **एक `setup.py` फ़ाइल बनाएं**:

- `hello_world_library` डायरेक्टरी की root में एक `setup.py` फ़ाइल बनाएं।
- यह फ़ाइल आपकी लाइब्रेरी के बारे में metadata रखती है और Python को बताती है कि इसे कैसे install करना है।

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**अब, चलिए लाइब्रेरी अपलोड करते हैं:**

1.  **अपना पैकेज बनाएं**:

- `hello_world_library` डायरेक्टरी की root से, चलाएँ:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **twine के लिए authentication कॉन्फ़िगर करें** (जो पैकेज upload करने के लिए उपयोग होता है):
- सुनिश्चित करें कि आपके पास `twine` installed है (`pip install twine`).
- credentials कॉन्फ़िगर करने के लिए `gcloud` का उपयोग करें:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **बिल्ड को साफ़ करें**

<details>
<summary>बिल्ड आर्टिफैक्ट्स को साफ़ करें</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> एक ही संस्करण वाली python लाइब्रेरी को फिर से अपलोड करना संभव नहीं है, पर आप **बड़े संस्करण** अपलोड कर सकते हैं (या यदि काम करे तो संस्करण के अंत में अतिरिक्त **`.0` जोड़ सकते हैं** -हालाँकि python में नहीं-), या आप **अंतिम संस्करण को हटाकर नया संस्करण अपलोड कर सकते हैं** (needed `artifactregistry.versions.delete)`**:**
>
> <details>
> <summary>Delete artifact version</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

इस अनुमति के साथ आप **आर्टिफैक्ट्स डाउनलोड** कर सकते हैं और **संवेदनशील जानकारी** तथा **कमज़ोरियाँ** खोज सकते हैं।

Download a **Docker** image:

<details>
<summary>Artifact Registry से **Docker** इमेज डाउनलोड करें</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

एक **python** लाइब्रेरी डाउनलोड करें:

<details>
<summary>Artifact Registry से Python लाइब्रेरी डाउनलोड करें</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- क्या होता है अगर एक virtual registry में remote और standard registries मिश्रित हों और कोई package दोनों में मौजूद हो? इस पेज को देखें:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

रजिस्ट्री से artifacts हटाएँ, जैसे docker images:

<details>
<summary>Artifact Registry से Docker image हटाएँ</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

एक पूरा repository हटाएँ (यहाँ तक कि इसमें content हो):

<details>
<summary>Artifact Registry repository हटाएँ</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

इस permission वाले attacker अपने आप को पहले बताए गए कुछ repository attacks करने की permissions दे सकता है।

### Artifact Registry Read & Write के माध्यम से अन्य Services पर Pivoting

- **Cloud Functions**

जब कोई Cloud Function बनाई जाती है तो प्रोजेक्ट के Artifact Registry में एक नया docker image push हो जाता है। मैंने image को नए वाले से बदलने की कोशिश की, और वर्तमान image (और `cache` image) को हटा भी दिया, पर कुछ नहीं बदला — cloud function चलते रहे। इसलिए, शायद bucket के साथ की तरह **Race Condition attack का दुरुपयोग** करके चलने वाले docker container को बदलना संभव हो सकता है, लेकिन **सिर्फ़ संग्रहित image को modify करने से Cloud Function compromise करना संभव नहीं है**।

- **App Engine**

हालाँकि App Engine Artifact Registry के अंदर docker images बनाता है। परीक्षण में पाया गया कि **भले ही आप इस service के अंदर image को modify कर दें** और App Engine instance को हटा दें (तो नया deploy किया जाता है) तब भी **code executed doesn't change**।\
यह संभव हो सकता है कि buckets के साथ जैसे **Race Condition attack कर के executed code को overwrite करना संभव हो**, लेकिन इसे टेस्ट नहीं किया गया।

{{#include ../../../banners/hacktricks-training.md}}
