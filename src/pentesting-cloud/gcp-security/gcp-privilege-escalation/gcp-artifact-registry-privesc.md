# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Für weitere Informationen über das Artifact Registry siehe:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Mit dieser Berechtigung könnte ein Angreifer neue Versionen der Artefakte mit schädlichem Code wie Docker-Images hochladen:
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
> [!CAUTION]
> Es wurde überprüft, dass es **möglich ist, ein neues bösartiges Docker**-Image mit demselben Namen und Tag wie das bereits vorhandene hochzuladen, sodass das **alte den Tag verliert** und beim nächsten Mal, wenn dieses Image mit diesem Tag **heruntergeladen wird, das bösartige** heruntergeladen wird.

<details>

<summary>Eine Python-Bibliothek hochladen</summary>

**Beginnen Sie mit der Erstellung der Bibliothek, die hochgeladen werden soll** (wenn Sie die neueste Version aus dem Repository herunterladen können, können Sie diesen Schritt überspringen):

1.  **Richten Sie Ihre Projektstruktur ein**:

- Erstellen Sie ein neues Verzeichnis für Ihre Bibliothek, z.B. `hello_world_library`.
- Erstellen Sie in diesem Verzeichnis ein weiteres Verzeichnis mit Ihrem Paketnamen, z.B. `hello_world`.
- Erstellen Sie in Ihrem Paketverzeichnis eine `__init__.py`-Datei. Diese Datei kann leer sein oder Initialisierungen für Ihr Paket enthalten.

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

2.  **Schreiben Sie Ihren Bibliothekscode**:

- Erstellen Sie im Verzeichnis `hello_world` eine neue Python-Datei für Ihr Modul, z.B. `greet.py`.
- Schreiben Sie Ihre "Hello, World!"-Funktion:

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

3.  **Erstellen Sie eine `setup.py`-Datei**:

- Erstellen Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses eine `setup.py`-Datei.
- Diese Datei enthält Metadaten über Ihre Bibliothek und sagt Python, wie es installiert werden soll.

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Alle Abhängigkeiten, die Ihre Bibliothek benötigt
],
)
```

**Jetzt lassen Sie uns die Bibliothek hochladen:**

1.  **Bauen Sie Ihr Paket**:

- Führen Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses Folgendes aus:

```sh
python3 setup.py sdist bdist_wheel
```

2.  **Konfigurieren Sie die Authentifizierung für twine** (wird verwendet, um Ihr Paket hochzuladen):
- Stellen Sie sicher, dass Sie `twine` installiert haben (`pip install twine`).
- Verwenden Sie `gcloud`, um die Anmeldeinformationen zu konfigurieren:
````
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
````
3. **Bauen Sie auf**
```bash
rm -rf dist build hello_world.egg-info
```
</details>

> [!CAUTION]
> Es ist nicht möglich, eine Python-Bibliothek mit der gleichen Version wie die bereits vorhandene hochzuladen, aber es ist möglich, **größere Versionen** hochzuladen (oder eine zusätzliche **`.0` am Ende** der Version hinzuzufügen, wenn das funktioniert - nicht in Python jedoch), oder die **letzte Version zu löschen und eine neue mit** (benötigt `artifactregistry.versions.delete)`** hochzuladen:**
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```

### `artifactregistry.repositories.downloadArtifacts`

Mit dieser Berechtigung können Sie **Artefakte herunterladen** und nach **sensiblen Informationen** und **Schwachstellen** suchen.

Laden Sie ein **Docker**-Image herunter:
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
Laden Sie eine **python**-Bibliothek herunter:
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
- Was passiert, wenn ein Remote- und ein Standard-Registry in einer virtuellen gemischt werden und ein Paket in beiden vorhanden ist? Überprüfen Sie diese Seite:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Löschen Sie Artefakte aus dem Registry, wie Docker-Images:
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
### `artifactregistry.repositories.delete`

Löschen Sie ein vollständiges Repository (auch wenn es Inhalte hat):
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
### `artifactregistry.repositories.setIamPolicy`

Ein Angreifer mit dieser Berechtigung könnte sich selbst Berechtigungen erteilen, um einige der zuvor genannten Repository-Angriffe durchzuführen.

### Pivoting zu anderen Diensten über Artifact Registry Lesen & Schreiben

- **Cloud Functions**

Wenn eine Cloud-Funktion erstellt wird, wird ein neues Docker-Image in das Artifact Registry des Projekts hochgeladen. Ich habe versucht, das Image durch ein neues zu ändern und sogar das aktuelle Image (und das `cache`-Image) zu löschen, und es hat sich nichts geändert, die Cloud-Funktion funktioniert weiterhin. Daher könnte es **möglich sein, einen Race Condition-Angriff auszunutzen**, wie beim Bucket, um den Docker-Container zu ändern, der ausgeführt wird, aber **einfach das gespeicherte Image zu ändern, ist nicht möglich, um die Cloud-Funktion zu kompromittieren**.

- **App Engine**

Obwohl App Engine Docker-Images im Artifact Registry erstellt, wurde getestet, dass **selbst wenn Sie das Image innerhalb dieses Dienstes ändern** und die App Engine-Instanz entfernen (damit eine neue bereitgestellt wird), der **ausgeführte Code sich nicht ändert**.\
Es könnte möglich sein, dass durch die Durchführung eines **Race Condition-Angriffs wie bei den Buckets der ausgeführte Code überschrieben werden kann**, aber dies wurde nicht getestet.

{{#include ../../../banners/hacktricks-training.md}}
