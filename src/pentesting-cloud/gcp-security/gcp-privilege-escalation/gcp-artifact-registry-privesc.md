# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

有关 Artifact Registry 的更多信息，请查看：

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

拥有此权限的攻击者可以上传包含恶意代码（例如 Docker 镜像）的制品新版本：

<details>
<summary>上传 Docker 镜像到 Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> 经检查，存在可以上传一个与已存在相同名称和 tag 的恶意 docker image 的情况，因此旧的会失去该 tag，下一次按该 tag 下载时会拉取到恶意的那个。

<details>

<summary>Upload a Python library</summary>

**首先创建要上传的库**（如果你能从 registry 下载到最新版本，可以省略这一步）：

1.  **设置你的项目结构**：

- 为你的库创建一个新目录，例如 `hello_world_library`。
- 在该目录中创建一个以包名命名的子目录，例如 `hello_world`。
- 在包目录中创建一个 `__init__.py` 文件。该文件可以为空，也可以包含包的初始化代码。

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **编写库代码**：

- 在 `hello_world` 目录中为你的模块创建一个新的 Python 文件，例如 `greet.py`。
- 编写你的 "Hello, World!" 函数：

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **创建一个 `setup.py` 文件**：

- 在 `hello_world_library` 根目录下创建 `setup.py` 文件。
- 该文件包含库的元数据，并告诉 Python 如何安装该库。

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**现在，上传库：**

1.  **构建你的包**：

- 在 `hello_world_library` 根目录下运行：

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **为 twine 配置认证**（用于上传包）：
- 确保已安装 `twine`（`pip install twine`）。
- 使用 `gcloud` 配置凭据：

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **清理构建**

<details>
<summary>清理构建产物</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> 无法上传与已存在版本相同的 python 库，但可以上传 **更高的版本**（或者在版本末尾添加额外的 **`.0`**，如果这行得通 —— 不过在 python 中通常不可行），或者可以 **删除最后一个版本并上传一个新的版本**（需要 `artifactregistry.versions.delete`）**：**
>
> <details>
> <summary>删除 artifact 版本</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

拥有此权限，您可以**下载 artifacts**并搜索**敏感信息**和**漏洞**。

下载一个 **Docker** 镜像：

<details>
<summary>从 Artifact Registry 下载 Docker 镜像</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

下载一个 **python** 库：

<details>
<summary>从 Artifact Registry 下载 Python 库</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- 如果在一个 virtual registry 中同时混合了 remote 和 standard registries，并且同一个 package 在两者中都存在，会发生什么？请查看此页面：

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

从 registry 删除 artifacts，例如 docker images：

<details>
<summary>从 Artifact Registry 删除 Docker 镜像</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

删除整个仓库（即使它有内容）：

<details>
<summary>删除 Artifact Registry 仓库</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

具有此权限的攻击者可以赋予自己执行前面提到的一些仓库攻击的权限。

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

当创建 Cloud Function 时，会将新的 docker image 推送到该项目的 Artifact Registry。我尝试用新的镜像修改该 image，甚至删除当前镜像（以及 `cache` image），但什么都没有改变，Cloud Function 仍继续工作。因此，可能像对 bucket 的情况一样，**可能可以滥用 Race Condition 攻击**来更改将要运行的 docker 容器，但**仅仅修改存储的镜像无法用来攻破 Cloud Function**。

- **App Engine**

尽管 App Engine 会在 Artifact Registry 中创建 docker images。测试显示，**即便你在该服务中修改镜像**并移除 App Engine 实例（因此会部署一个新的实例），**实际执行的代码并不会改变**。\
可能像对 buckets 那样通过执行 **Race Condition 攻击** 有可能覆盖被执行的代码，但这并未经过测试。

{{#include ../../../banners/hacktricks-training.md}}
