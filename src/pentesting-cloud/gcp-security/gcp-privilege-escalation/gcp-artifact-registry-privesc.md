# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

For more information about Artifact Registry check:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

この権限があると、攻撃者はDockerイメージのような悪意あるコードを含むアーティファクトの新しいバージョンをアップロードできます:

<details>
<summary>Artifact Registry に Docker イメージをアップロード</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> 確認の結果、同じ名前とタグで新しい悪意のある docker イメージをアップロードすることが**可能**であるため、**古いイメージはタグを失い**、次回そのタグでイメージが**ダウンロードされると悪意のあるものがダウンロードされます**。

<details>

<summary>Upload a Python library</summary>

**アップロードするライブラリを作成することから始めます**（registry から最新バージョンをダウンロードできる場合はこの手順は不要です）:

1.  **プロジェクト構成を設定する**:

- ライブラリ用の新しいディレクトリを作成します（例: `hello_world_library`）。
- このディレクトリ内に、パッケージ名のディレクトリを作成します（例: `hello_world`）。
- パッケージディレクトリ内に `__init__.py` ファイルを作成します。空でも、パッケージの初期化を含めても構いません。

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **ライブラリコードを書く**:

- `hello_world` ディレクトリ内に、モジュール用の新しい Python ファイルを作成します（例: `greet.py`）。
- 「Hello, World!」関数を書きます:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **`setup.py` ファイルを作成する**:

- `hello_world_library` ディレクトリのルートに `setup.py` ファイルを作成します。
- このファイルにはライブラリのメタデータと、Python にインストール方法を伝える情報が含まれます。

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**では、ライブラリをアップロードします:**

1.  **パッケージをビルドする**:

- `hello_world_library` ディレクトリのルートから以下を実行します:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **twine の認証を設定する**（パッケージをアップロードするために使用）:
- `twine` をインストールしていることを確認します（`pip install twine`）。
- 認証情報を設定するために `gcloud` を使用します:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **ビルドをクリーンアップする**

<details>
<summary>ビルド成果物をクリーンアップする</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> 既に存在するのと同じバージョンの python ライブラリをアップロードすることはできませんが、**より新しいバージョン**をアップロードすることは可能です（またはバージョンの末尾に **`.0` を追加**することで回避できる場合があります — ただし python では動作しないことがあります）、あるいは**最後のバージョンを削除して新しいものをアップロードする**こともできます（この場合 `artifactregistry.versions.delete` が必要です）。

<details>
<summary>アーティファクトのバージョンを削除</summary>

```sh
gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
```

</details>

### `artifactregistry.repositories.downloadArtifacts`

この権限があれば **アーティファクトをダウンロード** して、**機密情報** や **脆弱性** を検索できます。

Download a **Docker** image:

<details>
<summary>Artifact Registry から Docker イメージをダウンロード</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

**python** ライブラリをダウンロード:

<details>
<summary>Artifact RegistryからPythonライブラリをダウンロード</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- リモートと標準のレジストリが仮想レジストリ内で混在し、パッケージが両方に存在する場合はどうなりますか？次のページを確認してください：

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

レジストリからアーティファクト（例: Docker イメージ）を削除する:

<details>
<summary>Artifact Registry から Docker イメージを削除</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

コンテンツがあってもリポジトリ全体を削除します:

<details>
<summary>Artifact Registry リポジトリを削除</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

この権限を持つ攻撃者は、前述のリポジトリに対する攻撃のいくつかを実行するための権限を自分に付与できる可能性があります。

### Artifact Registry Read & Write を通じた他サービスへのピボット

- **Cloud Functions**

Cloud Function が作成されると、プロジェクトの Artifact Registry に新しい docker イメージがプッシュされます。イメージを新しいものに置き換えたり、現在のイメージ（および `cache` イメージ）を削除してみても何も変わらず、Cloud Function は動作し続けました。したがって、bucket と同様に実行される docker コンテナを変更するために**Race Condition attack を悪用できる可能性はあるかもしれません**が、**保存されているイメージを単に変更するだけでは Cloud Function を侵害することはできない**。

- **App Engine**

App Engine は Artifact Registry 内に docker イメージを作成します。テストの結果、**このサービス内のイメージを変更しても** App Engine インスタンスを削除（つまり新しいインスタンスがデプロイされる）しても、**実行されるコードは変わらない**ことが確認されました。\
bucket と同様の **Race Condition attack によって実行されるコードを上書きできる可能性がある**かもしれませんが、これはテストしていません。

{{#include ../../../banners/hacktricks-training.md}}
