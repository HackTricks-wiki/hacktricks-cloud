# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Για περισσότερες πληροφορίες σχετικά με το Artifact Registry, ελέγξτε:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Με αυτή την άδεια, ένας επιτιθέμενος θα μπορούσε να ανεβάσει νέες εκδόσεις των artifacts με κακόβουλο κώδικα όπως εικόνες Docker:
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
> [!CAUTION]
> Ελέγχθηκε ότι είναι **δυνατό να ανεβάσετε μια νέα κακόβουλη docker** εικόνα με το ίδιο όνομα και tag όπως αυτή που είναι ήδη παρούσα, οπότε η **παλιά θα χάσει το tag** και την επόμενη φορά που αυτή η εικόνα με αυτό το tag θα **κατεβεί, η κακόβουλη θα κατέβει**.

<details>

<summary>Ανεβάστε μια βιβλιοθήκη Python</summary>

**Ξεκινήστε δημιουργώντας τη βιβλιοθήκη που θα ανεβάσετε** (αν μπορείτε να κατεβάσετε την τελευταία έκδοση από το registry μπορείτε να παραλείψετε αυτό το βήμα):

1.  **Ρυθμίστε τη δομή του έργου σας**:

- Δημιουργήστε έναν νέο φάκελο για τη βιβλιοθήκη σας, π.χ., `hello_world_library`.
- Μέσα σε αυτόν τον φάκελο, δημιουργήστε έναν άλλο φάκελο με το όνομα του πακέτου σας, π.χ., `hello_world`.
- Μέσα στον φάκελο του πακέτου σας, δημιουργήστε ένα αρχείο `__init__.py`. Αυτό το αρχείο μπορεί να είναι κενό ή να περιέχει αρχικοποιήσεις για το πακέτο σας.

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

2.  **Γράψτε τον κώδικα της βιβλιοθήκης σας**:

- Μέσα στον φάκελο `hello_world`, δημιουργήστε ένα νέο αρχείο Python για το module σας, π.χ., `greet.py`.
- Γράψτε τη συνάρτηση "Hello, World!":

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

3.  **Δημιουργήστε ένα αρχείο `setup.py`**:

- Στη ρίζα του φακέλου `hello_world_library`, δημιουργήστε ένα αρχείο `setup.py`.
- Αυτό το αρχείο περιέχει μεταδεδομένα σχετικά με τη βιβλιοθήκη σας και λέει στην Python πώς να την εγκαταστήσει.

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Οποιεσδήποτε εξαρτήσεις χρειάζεται η βιβλιοθήκη σας
],
)
```

**Τώρα, ας ανεβάσουμε τη βιβλιοθήκη:**

1.  **Δημιουργήστε το πακέτο σας**:

- Από τη ρίζα του φακέλου `hello_world_library`, εκτελέστε:

```sh
python3 setup.py sdist bdist_wheel
```

2.  **Ρυθμίστε την αυθεντικοποίηση για το twine** (χρησιμοποιείται για να ανεβάσετε το πακέτο σας):
- Βεβαιωθείτε ότι έχετε εγκαταστήσει το `twine` (`pip install twine`).
- Χρησιμοποιήστε το `gcloud` για να ρυθμίσετε τα διαπιστευτήρια:
````
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
````
3. **Καθαρίστε την κατασκευή**
```bash
rm -rf dist build hello_world.egg-info
```
</details>

> [!CAUTION]
> Δεν είναι δυνατόν να ανεβάσετε μια βιβλιοθήκη python με την ίδια έκδοση που είναι ήδη παρούσα, αλλά είναι δυνατόν να ανεβάσετε **μεγαλύτερες εκδόσεις** (ή να προσθέσετε ένα επιπλέον **`.0` στο τέλος** της έκδοσης αν αυτό λειτουργεί - όχι σε python όμως), ή να **διαγράψετε την τελευταία έκδοση και να ανεβάσετε μια νέα με** (απαιτείται `artifactregistry.versions.delete)`**:**
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```

### `artifactregistry.repositories.downloadArtifacts`

Με αυτή την άδεια μπορείτε να **κατεβάσετε artifacts** και να αναζητήσετε **ευαίσθητες πληροφορίες** και **ευπάθειες**.

Κατεβάστε μια **Docker** εικόνα:
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
Κατεβάστε μια βιβλιοθήκη **python**:
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
- Τι συμβαίνει αν αναμειχθούν ένα απομακρυσμένο και ένα κανονικό μητρώο σε ένα εικονικό και ένα πακέτο υπάρχει και στα δύο; Ελέγξτε αυτή τη σελίδα:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Διαγράψτε τα αρχεία από το μητρώο, όπως εικόνες docker:
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
### `artifactregistry.repositories.delete`

Διαγράψτε ένα πλήρες αποθετήριο (ακόμα και αν έχει περιεχόμενο):
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
### `artifactregistry.repositories.setIamPolicy`

Ένας επιτιθέμενος με αυτή την άδεια θα μπορούσε να δώσει στον εαυτό του άδειες για να εκτελέσει μερικές από τις προηγουμένως αναφερόμενες επιθέσεις αποθετηρίου.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

Όταν δημιουργείται μια Cloud Function, μια νέα εικόνα docker αποστέλλεται στο Artifact Registry του έργου. Προσπάθησα να τροποποιήσω την εικόνα με μια νέα και ακόμη και να διαγράψω την τρέχουσα εικόνα (και την εικόνα `cache`) και τίποτα δεν άλλαξε, η cloud function συνεχίζει να λειτουργεί. Επομένως, ίσως **να είναι δυνατόν να εκμεταλλευτεί κανείς μια επίθεση Race Condition** όπως με τον κάδο για να αλλάξει το docker container που θα εκτελείται, αλλά **απλά τροποποιώντας την αποθηκευμένη εικόνα δεν είναι δυνατόν να συμβιβαστεί η Cloud Function**.

- **App Engine**

Ακόμη και αν το App Engine δημιουργεί εικόνες docker μέσα στο Artifact Registry. Δοκιμάστηκε ότι **ακόμη και αν τροποποιήσεις την εικόνα μέσα σε αυτή την υπηρεσία** και αφαιρέσεις την παρουσία του App Engine (έτσι ώστε να αναπτυχθεί μια νέα) ο **κώδικας που εκτελείται δεν αλλάζει**.\
Ενδέχεται να είναι δυνατόν να εκτελέσεις μια **επίθεση Race Condition όπως με τους κάδους, μπορεί να είναι δυνατόν να αντικαταστήσεις τον εκτελούμενο κώδικα**, αλλά αυτό δεν δοκιμάστηκε.

{{#include ../../../banners/hacktricks-training.md}}
