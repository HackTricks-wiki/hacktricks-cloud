# GCP - Artefak Registrasie Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artefak Registrasie

Vir meer inligting oor Artefak Registrasie, kyk:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Met hierdie toestemming kan 'n aanvaller nuwe weergawes van die artefakte met kwaadwillige kode soos Docker beelde oplaai:
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
> [!CAUTION]
> Dit is nagegaan dat dit **moontlik is om 'n nuwe kwaadwillige docker** beeld op te laai met dieselfde naam en etiket as die een wat reeds teenwoordig is, so die **ou een sal die etiket verloor** en die volgende keer dat daardie beeld met daardie etiket **afgelaai word, sal die kwaadwillige een** afgelaai word.

<details>

<summary>Laai 'n Python-biblioteek op</summary>

**Begin deur die biblioteek te skep om op te laai** (as jy die nuutste weergawe van die registrasie kan aflaai, kan jy hierdie stap vermy):

1.  **Stel jou projekstruktuur op**:

- Skep 'n nuwe gids vir jou biblioteek, byvoorbeeld, `hello_world_library`.
- Binne hierdie gids, skep 'n ander gids met jou pakketnaam, byvoorbeeld, `hello_world`.
- Binne jou pakketgids, skep 'n `__init__.py` lêer. Hierdie lêer kan leeg wees of kan inisiatiewe vir jou pakket bevat.

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

2.  **Skryf jou biblioteekkode**:

- Binne die `hello_world` gids, skep 'n nuwe Python-lêer vir jou module, byvoorbeeld, `greet.py`.
- Skryf jou "Hello, World!" funksie:

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

3.  **Skep 'n `setup.py` lêer**:

- In die wortel van jou `hello_world_library` gids, skep 'n `setup.py` lêer.
- Hierdie lêer bevat metadata oor jou biblioteek en vertel Python hoe om dit te installeer.

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Enige afhanklikhede wat jou biblioteek benodig
],
)
```

**Nou, kom ons laai die biblioteek op:**

1.  **Bou jou pakket**:

- Van die wortel van jou `hello_world_library` gids, hardloop:

```sh
python3 setup.py sdist bdist_wheel
```

2.  **Konfigureer outentisering vir twine** (gebruik om jou pakket op te laai):
- Verseker dat jy `twine` geïnstalleer het (`pip install twine`).
- Gebruik `gcloud` om akrediteer te konfigureer:
````
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
````
3. **Skoon die bou**
```bash
rm -rf dist build hello_world.egg-info
```
</details>

> [!CAUTION]
> Dit is nie moontlik om 'n python biblioteek met dieselfde weergawe as die een wat reeds teenwoordig is, op te laai nie, maar dit is moontlik om **groter weergawes** op te laai (of 'n ekstra **`.0` aan die einde** van die weergawe by te voeg as dit werk - nie in python nie), of om die **laaste weergawe te verwyder en 'n nuwe een op te laai met** (benodigde `artifactregistry.versions.delete)`**:**
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```

### `artifactregistry.repositories.downloadArtifacts`

Met hierdie toestemming kan jy **artefakte aflaai** en soek na **sensitiewe inligting** en **kwesbaarhede**.

Laai 'n **Docker** beeld af:
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
Laai 'n **python** biblioteek af:
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
- Wat gebeur as 'n afstands- en 'n standaard registries in 'n virtuele een gemeng word en 'n pakket in albei bestaan? Kyk na hierdie bladsy:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Verwyder artefakte uit die registrasie, soos docker beelde:
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
### `artifactregistry.repositories.delete`

Verwyder 'n volledige repository (selfs al het dit inhoud):
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
### `artifactregistry.repositories.setIamPolicy`

'n Aanvaller met hierdie toestemming kan homself toestemming gee om sommige van die voorheen genoemde repository-aanvalle uit te voer.

### Pivoting na ander Dienste deur Artifact Registry Lees & Skryf

- **Cloud Functions**

Wanneer 'n Cloud Function geskep word, word 'n nuwe docker beeld na die Artifact Registry van die projek gepush. Ek het probeer om die beeld met 'n nuwe een te wysig, en selfs die huidige beeld (en die `cache` beeld) te verwyder, en niks het verander nie, die cloud function het voortgegaan om te werk. Daarom, miskien **kan dit moontlik wees om 'n Race Condition aanval te misbruik** soos met die emmer om die docker houer wat uitgevoer sal word te verander, maar **net deur die gestoor beeld te wysig is dit nie moontlik om die Cloud Function te kompromitteer nie**.

- **App Engine**

Alhoewel App Engine docker beelde binne Artifact Registry skep. Dit is getoets dat **selfs as jy die beeld binne hierdie diens wysig** en die App Engine instansie verwyder (sodat 'n nuwe een ontplooi word) die **kode wat uitgevoer word nie verander nie**.\
Dit mag moontlik wees dat die uitvoering van 'n **Race Condition aanval soos met die emmers dit moontlik mag wees om die uitgevoerde kode te oorskryf**, maar dit is nie getoets nie.

{{#include ../../../banners/hacktricks-training.md}}
