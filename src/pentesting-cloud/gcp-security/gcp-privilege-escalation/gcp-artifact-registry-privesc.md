# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Para más información sobre Artifact Registry consulta:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Con este permiso un atacante podría subir nuevas versiones de los artefactos con código malicioso, como imágenes Docker:

<details>
<summary>Subir una imagen Docker a Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Se comprobó que es **posible subir una nueva imagen docker maliciosa** con el mismo nombre y tag que la ya presente, por lo que la **antigua perderá el tag** y la próxima vez que se descargue esa imagen con ese tag se descargará la **maliciosa**.

<details>

<summary>Upload a Python library</summary>

**Empieza creando la librería para subir** (si puedes descargar la última versión desde el registry puedes evitar este paso):

1.  **Prepara la estructura del proyecto**:

- Crea un nuevo directorio para tu librería, p. ej., `hello_world_library`.
- Dentro de este directorio, crea otro directorio con el nombre del paquete, p. ej., `hello_world`.
- Dentro del directorio del paquete, crea un archivo `__init__.py`. Este archivo puede estar vacío o contener inicializaciones del paquete.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Escribe el código de la librería**:

- Dentro del directorio `hello_world`, crea un nuevo archivo Python para tu módulo, p. ej., `greet.py`.
- Escribe la función "Hello, World!":

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Crea un archivo `setup.py`**:

- En la raíz del directorio `hello_world_library`, crea un archivo `setup.py`.
- Este archivo contiene metadatos sobre tu librería y le indica a Python cómo instalarla.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Ahora, vamos a subir la librería:**

1.  **Construye tu paquete**:

- Desde la raíz del directorio `hello_world_library`, ejecuta:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Configura la autenticación para twine** (usado para subir tu paquete):
- Asegúrate de tener `twine` instalado (`pip install twine`).
- Usa `gcloud` para configurar las credenciales:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Limpiar la compilación**

<details>
<summary>Limpiar artefactos de compilación</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> No es posible subir una librería de python con la misma versión que la ya presente, pero es posible subir **versiones superiores** (o añadir un **`.0` al final** de la versión si eso funciona —no en python, sin embargo—), o **eliminar la última versión y subir una nueva** (se necesita `artifactregistry.versions.delete`):
>
> <details>
> <summary>Eliminar versión del artefacto</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>
>
### `artifactregistry.repositories.downloadArtifacts`

Con este permiso puedes **descargar artefactos** y buscar **información sensible** y **vulnerabilidades**.

Descargar una imagen de Docker:

<details>
<summary>Descargar imagen Docker desde Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Descargar una biblioteca de **python**:

<details>
<summary>Descargar una biblioteca de Python desde Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- ¿Qué sucede si se mezclan un registro remoto y uno estándar en uno virtual y un paquete existe en ambos? Consulta esta página:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Eliminar artefactos del registro, como imágenes docker:

<details>
<summary>Eliminar imagen Docker de Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Eliminar un repositorio completo (incluso si tiene contenido):

<details>
<summary>Eliminar repositorio de Artifact Registry</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Un atacante con este permiso podría otorgarse permisos para realizar algunos de los ataques al repositorio mencionados anteriormente.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

When a Cloud Function is created a new docker image is pushed to the Artifact Registry of the project. Intenté modificar la imagen por una nueva, e incluso eliminar la imagen actual (y la imagen `cache`) y nada cambió, la Cloud Function siguió funcionando. Por lo tanto, quizá **podría ser posible abusar de un Race Condition attack** como con el bucket para cambiar el contenedor docker que se ejecutará, pero **solo modificar la imagen almacenada no parece posible para comprometer la Cloud Function**.

- **App Engine**

Although App Engine creates docker images inside Artifact Registry. Se probó que **incluso si modificas la imagen dentro de este servicio** y eliminas la instancia de App Engine (por lo que se despliega una nueva) el **código ejecutado no cambia**.\
Podría ser posible que realizando un **Race Condition attack como con los buckets** sea posible sobrescribir el código ejecutado, pero esto no fue probado.

{{#include ../../../banners/hacktricks-training.md}}
