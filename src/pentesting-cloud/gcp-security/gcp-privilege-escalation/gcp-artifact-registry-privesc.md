# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Za više informacija o Artifact Registry pogledajte:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Sa ovom dozvolom napadač može da otpremi nove verzije artefakata sa zlonamernim kodom, kao što su Docker images:

<details>
<summary>Otpremi Docker image u Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Provereno je da je **moguće otpremiti novu malicioznu docker** sliku sa istim imenom i tagom kao ona koja je već prisutna, tako da će **stara izgubiti tag** i sledeći put kada se slika sa tim tagom bude **preuzimala biće preuzeta maliciozna**.

<details>

<summary>Otpremanje Python biblioteke</summary>

**Počnite kreiranjem biblioteke koju ćete otpremiti** (ako možete da preuzmete najnoviju verziju iz registry-ja, možete izbeći ovaj korak):

1.  **Postavite strukturu projekta**:

- Napravite novi direktorijum za vašu biblioteku, npr. `hello_world_library`.
- Unutar ovog direktorijuma, kreirajte još jedan direktorijum sa imenom paketa, npr. `hello_world`.
- Unutar direktorijuma paketa, kreirajte fajl `__init__.py`. Ovaj fajl može biti prazan ili može sadržati inicijalizacije za vaš paket.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Napišite kod biblioteke**:

- Unutar direktorijuma `hello_world`, kreirajte novu Python datoteku za vaš modul, npr. `greet.py`.
- Napišite vašu "Hello, World!" funkciju:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Kreirajte fajl `setup.py`**:

- U korenu vašeg direktorijuma `hello_world_library`, kreirajte fajl `setup.py`.
- Ovaj fajl sadrži metapodatke o vašoj biblioteci i govori Pythonu kako da je instalira.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Sada, hajde da otpremimo biblioteku:**

1.  **Izgradite svoj paket**:

- Iz korena direktorijuma `hello_world_library` pokrenite:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **Konfigurišite autentifikaciju za twine** (koristi se za otpremanje vašeg paketa):
- Uverite se da imate instaliran `twine` (`pip install twine`).
- Koristite `gcloud` da konfigurišete kredencijale:

<details>
<summary>Otpremanje paketa pomoću twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Očistite build**

<details>
<summary>Očistite artefakte build-a</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Nije moguće otpremiti python biblioteku istom verzijom koja je već prisutna, ali je moguće otpremiti **veće verzije** (ili dodati dodatno **`.0` na kraju** verzije ako to radi — ne u pythonu, međutim), ili **obrisati poslednju verziju i otpremiti novu koristeći** (potrebno `artifactregistry.versions.delete`):
>
> <details>
> <summary>Obriši verziju artefakta</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Sa ovom dozvolom možete **preuzimati artefakte** i pretraživati **osetljive informacije** i **ranjivosti**.

Preuzmi **Docker** sliku:

<details>
<summary>Preuzmi Docker sliku iz Artifact Registry</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Preuzmi **python** biblioteku:

<details>
<summary>Preuzmi Python biblioteku iz Artifact Registry</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Šta se dešava ako su remote i standard registri pomešani u virtuelnom registru i paket postoji u oba? Pogledaj ovu stranicu:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Briše artefakte iz registra, kao što su Docker images:

<details>
<summary>Obriši Docker image iz Artifact Registry</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Obrišite ceo Artifact Registry repozitorijum (čak i ako sadrži sadržaj):

<details>
<summary>Obriši Artifact Registry repozitorijum</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Napadač sa ovom dozvolom može sebi dodeliti privilegije da izvrši neke od prethodno pomenutih repository napada.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

Kada se kreira Cloud Function novi docker image se gura u Artifact Registry projekta. Pokušao sam da izmenim image novim, pa čak i da obrišem trenutni image (i `cache` image) i ništa se nije promenilo — Cloud Function je nastavila da radi. Dakle, možda bi bilo moguće zloupotrebiti Race Condition attack kao kod bucket-a da se promeni docker container koji će se pokrenuti, ali samo izmena sačuvanog image-a nije dovoljna da kompromituje Cloud Function.

- **App Engine**

Iako App Engine kreira docker image-e unutar Artifact Registry. Testirano je da **čak i ako izmenite image unutar ovog servisa** i uklonite App Engine instancu (tako da se deploy-uje nova) **izvršeni code se ne menja**.\
Moguće je da izvođenjem **Race Condition attack-a kao kod bucket-ova može biti moguće prepisati izvršeni code**, ali to nije testirano.

{{#include ../../../banners/hacktricks-training.md}}
