# GCP - AppEngine Privesc

{{#include ../../../banners/hacktricks-training.md}}

## App Engine

Для отримання додаткової інформації про App Engine перегляньте:

{{#ref}}
../gcp-services/gcp-app-engine-enum.md
{{#endref}}

### `appengine.applications.get`, `appengine.instances.get`, `appengine.instances.list`, `appengine.operations.get`, `appengine.operations.list`, `appengine.services.get`, `appengine.services.list`, `appengine.versions.create`, `appengine.versions.get`, `appengine.versions.list`, `cloudbuild.builds.get`,`iam.serviceAccounts.actAs`, `resourcemanager.projects.get`, `storage.objects.create`, `storage.objects.list`

Це необхідні дозволи для **розгортання додатку за допомогою `gcloud` cli**. Можливо, дозволи **`get`** та **`list`** можна **опустити**.

Приклади python-коду можна знайти в [https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/appengine](https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/appengine)

За замовчуванням назва сервісу додатку буде **`default`**, і може бути лише 1 екземпляр з тією ж назвою.\
Щоб змінити це і створити другий додаток, у **`app.yaml`** змініть значення кореневого ключа на щось на кшталт **`service: my-second-app`**
```bash
cd python-docs-samples/appengine/flexible/hello_world
gcloud app deploy #Upload and start application inside the folder
```
Дайте цьому принаймні 10–15 хвилин; якщо це не допоможе — виконайте **deploy ще кілька разів** і зачекайте кілька хвилин.

> [!NOTE]
> Можна **вказати Service Account, який використовувати**, але за замовчуванням використовується App Engine default SA.

URL додатка приблизно такий: `https://<proj-name>.oa.r.appspot.com/` або `https://<service_name>-dot-<proj-name>.oa.r.appspot.com`

### Оновлення еквівалентних дозволів

Можливо, у вас є достатні дозволи для оновлення AppEngine, але не для створення нового. У такому випадку ось як ви можете оновити поточний App Engine:
```bash
# Find the code of the App Engine in the buckets
gsutil ls

# Download code
mkdir /tmp/appengine2
cd /tmp/appengine2
## In this case it was found in this custom bucket but you could also use the
## buckets generated when the App Engine is created
gsutil cp gs://appengine-lab-1-gcp-labs-4t04m0i6-3a97003354979ef6/labs_appengine_1_premissions_privesc.zip .
unzip labs_appengine_1_premissions_privesc.zip

## Now modify the code..

## If you don't have an app.yaml, create one like:
cat >> app.yaml <<EOF
runtime: python312

entrypoint: gunicorn -b :\$PORT main:app

env_variables:
A_VARIABLE: "value"
EOF

# Deploy the changes
gcloud app deploy

# Update the SA if you need it (and if you have actas permissions)
gcloud app update --service-account=<sa>@$PROJECT_ID.iam.gserviceaccount.com
```
Якщо ви **вже скомпрометували AppEngine** і маєте дозвіл **`appengine.applications.update`** та **actAs** над сервісним обліковим записом, який використовує AppEngine, ви можете змінити сервісний обліковий запис, що використовується AppEngine, за допомогою:
```bash
gcloud app update --service-account=<sa>@$PROJECT_ID.iam.gserviceaccount.com
```
### `appengine.instances.enableDebug`, `appengine.instances.get`, `appengine.instances.list`, `appengine.operations.get`, `appengine.services.get`, `appengine.services.list`, `appengine.versions.get`, `appengine.versions.list`, `compute.projects.get`

З цими дозволами можна **підключитися через ssh до App Engine instances** типу **flexible** (не standard). Деякі з **`list`** та **`get`** дозволів **можуть фактично не знадобитися**.
```bash
gcloud app instances ssh --service <app-name> --version <version-id> <ID>
```
### `appengine.applications.update`, `appengine.operations.get`

Я вважаю, це просто змінює фоновий SA, якого google використовуватиме для налаштування додатків, тож я не думаю, що цим можна зловживати, щоб вкрасти service account.
```bash
gcloud app update --service-account=<sa_email>
```
### `appengine.versions.getFileContents`, `appengine.versions.update`

Не впевнений, як використовувати ці дозволи або чи вони корисні (зауважте, що коли ви змінюєте код, створюється нова версія, тому я не знаю, чи можна просто оновити код або IAM role однієї версії, але, мабуть, це можливо — можливо, змінивши код всередині bucket??).

### `bigquery.tables.delete`, `bigquery.datasets.delete` & `bigquery.models.delete` (`bigquery.models.getMetadata`)

Щоб видалити таблиці, набір даних або моделі:
```bash
# Table removal
bq rm -f -t <PROJECT_ID>.<DATASET>.<TABLE_NAME>

# Dataset removal
bq rm -r -f <PROJECT_ID>:<DATASET>

# Model removal
bq rm -m <PROJECT_ID>:<DATASET_NAME>.<MODEL_NAME>
```
### Зловживання Scheduled Queries

Маючи дозволи `bigquery.datasets.get`, `bigquery.jobs.create` та `iam.serviceAccounts.actAs`, суб’єкт може запитувати метадані dataset, запускати BigQuery jobs і виконувати їх з використанням Service Account з вищими привілеями.

Ця атака дозволяє зловмисному використанню Scheduled Queries для автоматизації запитів (що виконуються під обраним Service Account), що, наприклад, може призвести до читання чутливих даних та запису їх в іншу table або dataset, до яких зловмисник має доступ — полегшуючи непряму та безперервну ексфільтрацію без потреби вивозити дані назовні.

Як тільки зловмисник дізнається, який Service Account має необхідні дозволи для виконання потрібного запиту, він може створити конфігурацію Scheduled Query, яка працює від імені цього Service Account і періодично записує результати в dataset на його вибір.
```bash
bq mk \
--transfer_config \
--project_id=<PROJECT_ID> \
--location=US \
--data_source=scheduled_query \
--target_dataset=<DEST_DATASET> \
--display_name="Generic Scheduled Query" \
--service_account_name="<SERVICE_ACCOUNT>@<PROJECT_ID>.iam.gserviceaccount.com" \
--schedule="every 10 minutes" \
--params='{
"query": "SELECT * FROM `<PROJECT_ID>.<SOURCE_DATASET>.<source_table>`;",
"destination_table_name_template": "<destination_table>",
"write_disposition": "WRITE_TRUNCATE"
}'

```
### Доступ на запис до buckets

Як згадувалося, версії appengine генерують деякі дані всередині bucket з іменем у форматі: `staging.<project-id>.appspot.com`. Зауважте, що заздалегідь перехопити цей bucket неможливо, оскільки користувачам GCP не дозволено створювати buckets з доменом `appspot.com`.

Однак, маючи доступ на читання й запис до цього bucket, можна підвищити привілеї до SA, прикріпленого до версії AppEngine, відстежуючи bucket і щоразу при зміні якомога швидше змінювати код. Таким чином контейнер, що створиться з цього коду, буде **виконувати backdoored code**.

Для додаткової інформації та **PoC перевірте відповідну інформацію на цій сторінці**:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

### Доступ на запис до Artifact Registry

Хоч App Engine і створює docker images в Artifact Registry, було перевірено, що **навіть якщо ви зміните image всередині цього сервісу** і видалите App Engine instance (тоді розгортається новий), **виконуваний код не змінюється**.\
Можливо, що виконання **Race Condition attack, як у випадку з buckets, могло б перезаписати виконуваний код**, але це не було протестовано.

{{#include ../../../banners/hacktricks-training.md}}
