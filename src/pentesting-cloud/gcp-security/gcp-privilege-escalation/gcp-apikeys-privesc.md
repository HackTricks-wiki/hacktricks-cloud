# GCP - AppEngine Privesc

{{#include ../../../banners/hacktricks-training.md}}

## App Engine

App Engine hakkında daha fazla bilgi için bakınız:

{{#ref}}
../gcp-services/gcp-app-engine-enum.md
{{#endref}}

### `appengine.applications.get`, `appengine.instances.get`, `appengine.instances.list`, `appengine.operations.get`, `appengine.operations.list`, `appengine.services.get`, `appengine.services.list`, `appengine.versions.create`, `appengine.versions.get`, `appengine.versions.list`, `cloudbuild.builds.get`,`iam.serviceAccounts.actAs`, `resourcemanager.projects.get`, `storage.objects.create`, `storage.objects.list`

Bunlar, **`gcloud` cli** kullanarak bir App'i dağıtmak için gereken izinlerdir. Muhtemelen **`get`** ve **`list`** olanlar **hariç bırakılabilir**.

Python kod örneklerini şu adreste bulabilirsiniz: [https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/appengine](https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/appengine)

Varsayılan olarak, App servisinin adı **`default`** olacaktır ve aynı ada sahip yalnızca 1 örnek olabilir.\
Bunu değiştirmek ve ikinci bir App oluşturmak için **`app.yaml`** içinde kök anahtarın değerini şu şekilde değiştirin: **`service: my-second-app`**
```bash
cd python-docs-samples/appengine/flexible/hello_world
gcloud app deploy #Upload and start application inside the folder
```
Buna en az 10-15 dakika verin; işe yaramazsa **deploy another of times** çağırın ve birkaç dakika bekleyin.

> [!NOTE]
> Kullanılacak **Service Account'u belirtmek** mümkündür; ancak varsayılan olarak App Engine default SA kullanılır.

The URL of the application is something like `https://<proj-name>.oa.r.appspot.com/` or `https://<service_name>-dot-<proj-name>.oa.r.appspot.com`

### Güncelleme için eşdeğer izinler

Yeni bir tane oluşturmak için izniniz olmayabilir, ancak mevcut bir AppEngine'i güncellemek için yeterli izne sahip olabilirsiniz. Bu durumda mevcut App Engine'i şu şekilde güncelleyebilirsiniz:
```bash
# Find the code of the App Engine in the buckets
gsutil ls

# Download code
mkdir /tmp/appengine2
cd /tmp/appengine2
## In this case it was found in this custom bucket but you could also use the
## buckets generated when the App Engine is created
gsutil cp gs://appengine-lab-1-gcp-labs-4t04m0i6-3a97003354979ef6/labs_appengine_1_premissions_privesc.zip .
unzip labs_appengine_1_premissions_privesc.zip

## Now modify the code..

## If you don't have an app.yaml, create one like:
cat >> app.yaml <<EOF
runtime: python312

entrypoint: gunicorn -b :\$PORT main:app

env_variables:
A_VARIABLE: "value"
EOF

# Deploy the changes
gcloud app deploy

# Update the SA if you need it (and if you have actas permissions)
gcloud app update --service-account=<sa>@$PROJECT_ID.iam.gserviceaccount.com
```
Eğer **zaten bir AppEngine'i ele geçirdiyseniz** ve kullanmak için servis hesabı üzerinde **`appengine.applications.update`** iznine ve **actAs** yetkisine sahipseniz, AppEngine tarafından kullanılan servis hesabını şu şekilde değiştirebilirsiniz:
```bash
gcloud app update --service-account=<sa>@$PROJECT_ID.iam.gserviceaccount.com
```
### `appengine.instances.enableDebug`, `appengine.instances.get`, `appengine.instances.list`, `appengine.operations.get`, `appengine.services.get`, `appengine.services.list`, `appengine.versions.get`, `appengine.versions.list`, `compute.projects.get`

Bu izinlerle, **flexible** türündeki App Engine örneklerine **ssh ile giriş yapmak** mümkün (standard değil). Bazı **`list`** ve **`get`** izinleri **gerçekte gerekli olmayabilir**.
```bash
gcloud app instances ssh --service <app-name> --version <version-id> <ID>
```
### `appengine.applications.update`, `appengine.operations.get`

Bence bu yalnızca uygulamaları kurmak için google'ın kullanacağı arka plan SA'sını değiştiriyor, bu yüzden bunu kötüye kullanıp service account'u çalamayacağınızı düşünüyorum.
```bash
gcloud app update --service-account=<sa_email>
```
### `appengine.versions.getFileContents`, `appengine.versions.update`

Bu izinlerin nasıl kullanılacağını veya faydalı olup olmadığını bilmiyorum (kod değiştirildiğinde yeni bir versiyon oluşturulduğunu unutmayın, bu yüzden sadece kodu veya birinin IAM rolünü güncelleyip güncelleyemeyeceğimi bilmiyorum, ama sanırım yapabilmelisiniz, belki bucket içindeki kodu değiştirerek??).

### `bigquery.tables.delete`, `bigquery.datasets.delete` & `bigquery.models.delete` (`bigquery.models.getMetadata`)

Tabloları, veri kümesini veya modelleri kaldırmak için:
```bash
# Table removal
bq rm -f -t <PROJECT_ID>.<DATASET>.<TABLE_NAME>

# Dataset removal
bq rm -r -f <PROJECT_ID>:<DATASET>

# Model removal
bq rm -m <PROJECT_ID>:<DATASET_NAME>.<MODEL_NAME>
```
### Scheduled Queries'in Kötüye Kullanımı

With the `bigquery.datasets.get`, `bigquery.jobs.create`, and `iam.serviceAccounts.actAs` permissions, an identity can query dataset metadata, launch BigQuery jobs, and execute them using a Service Account with higher privileges.

Bu saldırı, Scheduled Queries'in kötü niyetli şekilde kullanılarak (seçilen Service Account altında çalışan) sorguların otomatikleştirilmesine imkân tanır; bu, örneğin hassas verilerin saldırganın erişimi olan başka bir tabloya veya dataset'e okunup yazılmasına yol açabilir — verileri harici olarak çıkarmaya gerek kalmadan dolaylı ve sürekli exfiltration sağlar.

Saldırgan, hangi Service Account'un istenen sorguyu yürütmek için gerekli izinlere sahip olduğunu öğrendiğinde, o Service Account'u kullanacak şekilde çalışan ve sonuçları periyodik olarak kendi seçtikleri bir dataset'e yazan bir Scheduled Query yapılandırması oluşturabilir.
```bash
bq mk \
--transfer_config \
--project_id=<PROJECT_ID> \
--location=US \
--data_source=scheduled_query \
--target_dataset=<DEST_DATASET> \
--display_name="Generic Scheduled Query" \
--service_account_name="<SERVICE_ACCOUNT>@<PROJECT_ID>.iam.gserviceaccount.com" \
--schedule="every 10 minutes" \
--params='{
"query": "SELECT * FROM `<PROJECT_ID>.<SOURCE_DATASET>.<source_table>`;",
"destination_table_name_template": "<destination_table>",
"write_disposition": "WRITE_TRUNCATE"
}'

```
### Write Access over the buckets

Daha önce bahsedildiği gibi App Engine sürümleri `staging.<project-id>.appspot.com` formatında bir bucket içinde bazı veriler oluşturur. Önceden bu bucket'ı ele geçirmek mümkün değildir çünkü GCP kullanıcıları `appspot.com` etki alanını kullanarak bucket oluşturma yetkisine sahip değildir.

Ancak, bu bucket üzerinde okuma & yazma erişimi ile bucket'ı izleyip herhangi bir değişiklik yapıldığında kodu mümkün olan en hızlı şekilde değiştirerek AppEngine sürümüne bağlı SA'ya escalate privileges etmek mümkündür. Bu şekilde, bu koddan oluşturulan container **execute the backdoored code**.

For more information and a **PoC check the relevant information from this page**:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

### Write Access over the Artifact Registry

Even though App Engine creates docker images inside Artifact Registry. It was tested that **even if you modify the image inside this service** and removes the App Engine instance (so a new one is deployed) the **code executed doesn't change**.\
It might be possible that performing a **Race Condition attack like with the buckets it might be possible to overwrite the executed code**, but this wasn't tested.

{{#include ../../../banners/hacktricks-training.md}}
