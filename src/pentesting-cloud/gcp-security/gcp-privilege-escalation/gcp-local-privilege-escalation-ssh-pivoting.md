# GCP - local privilege escalation ssh pivoting

{{#include ../../../banners/hacktricks-training.md}}

이 시나리오에서는 Compute Engine 프로젝트의 VM 내부에서 비권한 계정(non privilege account)을 **침해한 상태**라고 가정합니다.

놀랍게도, 침해한 Compute Engine의 GPC 권한은 머신 내부에서 **로컬 권한 상승(escalate privileges locally inside a machine)** 에 도움을 줄 수 있습니다. 클라우드 환경에서는 항상 유용하지 않을 수 있지만, 가능하다는 것을 아는 것이 중요합니다.

## Read the scripts <a href="#follow-the-scripts" id="follow-the-scripts"></a>

**Compute Instances**는 종종 서비스 계정으로 작업을 수행하기 위해 **스크립트를 실행**하도록 설정되어 있습니다.

IAM이 점점 더 세분화되면서, 어떤 계정은 리소스에 대해 **읽기/쓰기(read/write)** 권한은 있지만 **목록(list)** 권한은 없을 수 있습니다.

좋은 가상의 예로, `instance82736-long-term-xyz-archive-0332893`라는 storage bucket에 백업을 읽고 쓸 수 있는 권한이 있는 Compute Instance가 있습니다.

커맨드라인에서 `gsutil ls`를 실행하면 아무 것도 반환하지 않을 수 있습니다. 서비스 계정에 `storage.buckets.list` IAM 권한이 없기 때문입니다. 그러나 `gsutil ls gs://instance82736-long-term-xyz-archive-0332893`를 실행하면 전체 파일시스템 백업을 찾을 수 있고, 로컬 Linux 계정에 없는 평문 데이터에 접근할 수 있게 됩니다.

이 버킷 이름은 스크립트(bash, Python, Ruby...) 내부에서 발견될 수 있습니다.

## Custom Metadata

관리자는 인스턴스 수준과 프로젝트 수준에서 [custom metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#custom)를 추가할 수 있습니다. 이는 인스턴스로 임의의 key/value 쌍을 전달하는 방법으로, 환경 변수나 startup/shutdown 스크립트에 자주 사용됩니다.

또한 userdata를 추가할 수 있는데, 이는 머신이 시작되거나 재시작될 때 **매번 실행되는 스크립트**이며 메타데이터 엔드포인트에서 **접근할 수 있습니다.**

자세한 내용은 다음을 확인하세요:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html
{{#endref}}

## **Abusing IAM permissions**

다음에 제시된 권한들 대부분은 **default Compute SA**에 부여되는 경우가 많습니다. 유일한 문제는 **default access scope**가 SA가 해당 권한을 사용하는 것을 제한할 수 있다는 점입니다. 하지만 **`cloud-platform`** 스코프가 활성화되어 있거나 단지 **`compute`** 스코프만 활성화되어 있어도, 이러한 권한을 **악용할 수 있습니다.**

다음 권한들을 확인하세요:

- [**compute.instances.osLogin**](gcp-compute-privesc/index.html#compute.instances.oslogin)
- [**compute.instances.osAdminLogin**](gcp-compute-privesc/index.html#compute.instances.osadminlogin)
- [**compute.projects.setCommonInstanceMetadata**](gcp-compute-privesc/index.html#compute.projects.setcommoninstancemetadata)
- [**compute.instances.setMetadata**](gcp-compute-privesc/index.html#compute.instances.setmetadata)
- [**compute.instances.setIamPolicy**](gcp-compute-privesc/index.html#compute.instances.setiampolicy)

## Search for Keys in the filesystem

박스 내에서 다른 사용자가 gcloud로 로그인하고 자격 증명을 파일시스템에 남겼는지 확인하세요:

<details><summary>파일 시스템에서 gcloud 자격 증명 검색</summary>
```
sudo find / -name "gcloud"
```
</details>

가장 흥미로운 파일들:

- `~/.config/gcloud/credentials.db`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/adc.json`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/.boto`
- `~/.credentials.json`

### 추가 API Keys regexes

<details><summary>Grep patterns for GCP credentials and keys</summary>
```bash
TARGET_DIR="/path/to/whatever"

# Service account keys
grep -Pzr "(?s){[^{}]*?service_account[^{}]*?private_key.*?}" \
"$TARGET_DIR"

# Legacy GCP creds
grep -Pzr "(?s){[^{}]*?client_id[^{}]*?client_secret.*?}" \
"$TARGET_DIR"

# Google API keys
grep -Pr "AIza[a-zA-Z0-9\\-_]{35}" \
"$TARGET_DIR"

# Google OAuth tokens
grep -Pr "ya29\.[a-zA-Z0-9_-]{100,200}" \
"$TARGET_DIR"

# Generic SSH keys
grep -Pzr "(?s)-----BEGIN[ A-Z]*?PRIVATE KEY[a-zA-Z0-9/\+=\n-]*?END[ A-Z]*?PRIVATE KEY-----" \
"$TARGET_DIR"

# Signed storage URLs
grep -Pir "storage.googleapis.com.*?Goog-Signature=[a-f0-9]+" \
"$TARGET_DIR"

# Signed policy documents in HTML
grep -Pzr '(?s)<form action.*?googleapis.com.*?name="signature" value=".*?">' \
"$TARGET_DIR"
```
</details>

## 참고 자료

- [https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/](https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/)

{{#include ../../../banners/hacktricks-training.md}}
