# GCP - local privilege escalation ssh pivoting

{{#include ../../../banners/hacktricks-training.md}}

在这个场景中，我们假设你已经在一个 Compute Engine 项目的 VM 内攻陷了一个 **non privilege account**。

令人惊讶的是，GPC 对你所攻陷的 compute engine 的权限可能会帮助你 **escalate privileges locally inside a machine**。即便在云环境中这并不总是很有用，但知道这是可能的仍然很重要。

## Read the scripts <a href="#follow-the-scripts" id="follow-the-scripts"></a>

**Compute Instances** 可能被用来 **execute some scripts**，以便使用它们的 service accounts 执行操作。

由于 IAM 非常细粒度，一个账号可能对某个资源拥有 **read/write** 权限，但 **no list privileges**。

一个很好的假设例子是一个 Compute Instance 拥有将备份读/写到一个名为 `instance82736-long-term-xyz-archive-0332893` 的 storage bucket 的权限。

在命令行运行 `gsutil ls` 不会返回任何内容，因为 service account 缺少 `storage.buckets.list` IAM permission。然而，如果你运行 `gsutil ls gs://instance82736-long-term-xyz-archive-0332893`，你可能会发现完整的文件系统备份，从而获得本地 Linux 账号所没有的明文数据访问权限。

你可能能在脚本（如 bash、Python、Ruby...）中找到这个 bucket 名称。

## Custom Metadata

Administrators can add [custom metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#custom) at the **instance** and **project level**. 这只是将 **arbitrary key/value pairs into an instance** 的一种方式，常用于环境变量和 startup/shutdown scripts。

此外，可以添加 **userdata**，它是一个在机器每次启动或重启时都会被 **executed everytime** 的脚本，并且也可以 **accessed from the metadata endpoint also.**

For more info check:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html
{{#endref}}

## **Abusing IAM permissions**

下面列出的多数权限通常被 **given to the default Compute SA,** 唯一的问题是 **default access scope prevents the SA from using them**。然而，如果启用了 **`cloud-platform`** scope 或仅启用了 **`compute`** scope，你就能够滥用它们。

Check the following permissions:

- [**compute.instances.osLogin**](gcp-compute-privesc/index.html#compute.instances.oslogin)
- [**compute.instances.osAdminLogin**](gcp-compute-privesc/index.html#compute.instances.osadminlogin)
- [**compute.projects.setCommonInstanceMetadata**](gcp-compute-privesc/index.html#compute.projects.setcommoninstancemetadata)
- [**compute.instances.setMetadata**](gcp-compute-privesc/index.html#compute.instances.setmetadata)
- [**compute.instances.setIamPolicy**](gcp-compute-privesc/index.html#compute.instances.setiampolicy)

## Search for Keys in the filesystem

检查是否有其他用户在该机器内通过 gcloud 登录并将凭据留在文件系统中：

<details><summary>在文件系统中搜索 gcloud 凭据</summary>
```
sudo find / -name "gcloud"
```
</details>

以下是最重要的文件：

- `~/.config/gcloud/credentials.db`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/adc.json`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/.boto`
- `~/.credentials.json`

### 更多 API Keys 正则

<details><summary>用于 GCP 凭据和密钥的 Grep 模式</summary>
```bash
TARGET_DIR="/path/to/whatever"

# Service account keys
grep -Pzr "(?s){[^{}]*?service_account[^{}]*?private_key.*?}" \
"$TARGET_DIR"

# Legacy GCP creds
grep -Pzr "(?s){[^{}]*?client_id[^{}]*?client_secret.*?}" \
"$TARGET_DIR"

# Google API keys
grep -Pr "AIza[a-zA-Z0-9\\-_]{35}" \
"$TARGET_DIR"

# Google OAuth tokens
grep -Pr "ya29\.[a-zA-Z0-9_-]{100,200}" \
"$TARGET_DIR"

# Generic SSH keys
grep -Pzr "(?s)-----BEGIN[ A-Z]*?PRIVATE KEY[a-zA-Z0-9/\+=\n-]*?END[ A-Z]*?PRIVATE KEY-----" \
"$TARGET_DIR"

# Signed storage URLs
grep -Pir "storage.googleapis.com.*?Goog-Signature=[a-f0-9]+" \
"$TARGET_DIR"

# Signed policy documents in HTML
grep -Pzr '(?s)<form action.*?googleapis.com.*?name="signature" value=".*?">' \
"$TARGET_DIR"
```
</details>

## 参考资料

- [https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/](https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/)

{{#include ../../../banners/hacktricks-training.md}}
