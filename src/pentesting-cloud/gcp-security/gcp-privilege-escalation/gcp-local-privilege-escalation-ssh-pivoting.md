# GCP - ローカル特権昇格 SSH ピボティング

{{#include ../../../banners/hacktricks-training.md}}

このシナリオでは、あなたが **VM内の非特権アカウントを侵害した** と仮定します。

驚くべきことに、あなたが侵害した Compute Engine の GPC 権限は、**マシン内でローカルに特権を昇格させる**のに役立つかもしれません。クラウド環境では常に非常に役立つわけではありませんが、可能であることを知っておくのは良いことです。

## スクリプトを読む <a href="#follow-the-scripts" id="follow-the-scripts"></a>

**Compute インスタンス**は、おそらくそのサービスアカウントを使用してアクションを実行するために **いくつかのスクリプトを実行する** ために存在しています。

IAMは非常に細かく設定できるため、アカウントはリソースに対して **読み取り/書き込み** 権限を持っているが **リスト権限は持っていない** 可能性があります。

この良い仮想的な例は、`instance82736-long-term-xyz-archive-0332893` というストレージバケットにバックアップを読み書きする権限を持つ Compute インスタンスです。

コマンドラインから `gsutil ls` を実行すると何も返されません。なぜなら、サービスアカウントが `storage.buckets.list` IAM 権限を欠いているからです。しかし、`gsutil ls gs://instance82736-long-term-xyz-archive-0332893` を実行すると、完全なファイルシステムバックアップが見つかり、あなたのローカル Linux アカウントが持っていないデータへの平文アクセスが得られるかもしれません。

このバケット名は、スクリプト（bash、Python、Rubyなど）内で見つけることができるかもしれません。

## カスタムメタデータ

管理者は、**インスタンス**および **プロジェクトレベル**で [カスタムメタデータ](https://cloud.google.com/compute/docs/storing-retrieving-metadata#custom) を追加できます。これは、**任意のキー/値ペアをインスタンスに渡す**方法であり、環境変数や起動/シャットダウンスクリプトに一般的に使用されます。

さらに、**ユーザーデータ**を追加することも可能で、これはマシンが起動または再起動されるたびに **実行されるスクリプト**であり、**メタデータエンドポイントからもアクセス可能です。**

詳細については、以下を確認してください：

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html
{{#endref}}

## **IAM権限の悪用**

以下に提案するほとんどの権限は、**デフォルトの Compute SA に与えられています**。唯一の問題は、**デフォルトのアクセススコープが SA の使用を妨げる**ことです。しかし、**`cloud-platform`** **スコープ**が有効になっているか、単に **`compute`** **スコープ**が有効になっている場合、あなたはそれらを **悪用することができる**でしょう。

以下の権限を確認してください：

- [**compute.instances.osLogin**](gcp-compute-privesc/index.html#compute.instances.oslogin)
- [**compute.instances.osAdminLogin**](gcp-compute-privesc/index.html#compute.instances.osadminlogin)
- [**compute.projects.setCommonInstanceMetadata**](gcp-compute-privesc/index.html#compute.projects.setcommoninstancemetadata)
- [**compute.instances.setMetadata**](gcp-compute-privesc/index.html#compute.instances.setmetadata)
- [**compute.instances.setIamPolicy**](gcp-compute-privesc/index.html#compute.instances.setiampolicy)

## ファイルシステム内のキーを検索

他のユーザーがボックス内で gcloud にログインし、ファイルシステムに資格情報を残しているか確認してください：
```
sudo find / -name "gcloud"
```
これらは最も興味深いファイルです：

- `~/.config/gcloud/credentials.db`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/adc.json`
- `~/.config/gcloud/legacy_credentials/[ACCOUNT]/.boto`
- `~/.credentials.json`

### さらにAPIキーの正規表現
```bash
TARGET_DIR="/path/to/whatever"

# Service account keys
grep -Pzr "(?s){[^{}]*?service_account[^{}]*?private_key.*?}" \
"$TARGET_DIR"

# Legacy GCP creds
grep -Pzr "(?s){[^{}]*?client_id[^{}]*?client_secret.*?}" \
"$TARGET_DIR"

# Google API keys
grep -Pr "AIza[a-zA-Z0-9\\-_]{35}" \
"$TARGET_DIR"

# Google OAuth tokens
grep -Pr "ya29\.[a-zA-Z0-9_-]{100,200}" \
"$TARGET_DIR"

# Generic SSH keys
grep -Pzr "(?s)-----BEGIN[ A-Z]*?PRIVATE KEY[a-zA-Z0-9/\+=\n-]*?END[ A-Z]*?PRIVATE KEY-----" \
"$TARGET_DIR"

# Signed storage URLs
grep -Pir "storage.googleapis.com.*?Goog-Signature=[a-f0-9]+" \
"$TARGET_DIR"

# Signed policy documents in HTML
grep -Pzr '(?s)<form action.*?googleapis.com.*?name="signature" value=".*?">' \
"$TARGET_DIR"
```
## 参考文献

- [https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/](https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/)

{{#include ../../../banners/hacktricks-training.md}}
