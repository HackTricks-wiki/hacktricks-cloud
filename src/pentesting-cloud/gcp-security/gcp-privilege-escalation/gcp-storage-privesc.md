# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

基本情報:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

この権限は、**Cloud Storageに保存されたファイルをダウンロードする**ことを許可します。これは、場合によっては**機密情報がそこに保存されているため**、権限を昇格させる可能性があります。さらに、いくつかのGCPサービスは、バケットに情報を保存します:

- **GCP Composer**: Composer環境を作成すると、**すべてのDAGのコード**が**バケット**内に保存されます。これらのタスクは、そのコード内に興味深い情報を含む可能性があります。
- **GCR (Container Registry)**: コンテナの**イメージ**は**バケット**内に保存されており、バケットを読み取ることができれば、イメージをダウンロードして**漏洩やソースコードを検索する**ことができます。

### `storage.objects.setIamPolicy`

このセクションの以前のシナリオを**悪用するための権限を与える**ことができます。

### **`storage.buckets.setIamPolicy`**

この権限で権限を変更する方法の例については、このページを確認してください:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storageの「相互運用性」機能は、AWS S3との**クロスクラウドインタラクション**のために設計されており、**サービスアカウントとユーザーのためのHMACキーの作成**を含みます。攻撃者は、**権限のあるサービスアカウントのためにHMACキーを生成することによって**、**Cloud Storage内で権限を昇格させる**ことができます。ユーザーに関連付けられたHMACキーはウェブコンソールを介してのみ取得可能ですが、アクセスキーとシークレットキーは**永続的にアクセス可能**であり、潜在的なバックアップアクセスストレージを可能にします。一方、サービスアカウントにリンクされたHMACキーはAPI経由でアクセス可能ですが、作成後はそのアクセスキーとシークレットキーは取得できず、継続的なアクセスのための複雑さを加えます。
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

## `storage.objects.create`, `storage.objects.delete` = ストレージ書き込み権限

バケット内に**新しいオブジェクトを作成する**には、`storage.objects.create`が必要で、[ドキュメント](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions)によると、既存のオブジェクトを**変更する**には`storage.objects.delete`も必要です。

クラウドに書き込むことができるバケットの**一般的な悪用**は、**バケットがウェブサーバーファイルを保存している場合**であり、ウェブアプリケーションで使用される**新しいコードを保存できる**可能性があります。

### Composer

**Composer**はGCP内で管理されている**Apache Airflow**です。いくつかの興味深い機能があります：

- **GKEクラスター内で実行される**ため、**クラスターが使用するSAはComposer内で実行されるコードからアクセス可能**です。
- Composer環境のすべてのコンポーネント（**DAGのコード**、プラグイン、データ）はGCPバケット内に保存されます。攻撃者がそれに対して読み取りおよび書き込み権限を持っている場合、バケットを監視し、**DAGが作成または更新されるたびに、バックドア付きのバージョンを提出する**ことができるため、Composer環境はストレージからバックドア付きのバージョンを取得します。

**この攻撃のPoCはリポジトリにあります：** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functionsのコードはストレージに保存され、新しいバージョンが作成されると、コードがバケットにプッシュされ、その後新しいコンテナがこのコードからビルドされます。したがって、**新しいバージョンがビルドされる前にコードを上書きすることで、クラウド関数が任意のコードを実行することが可能になります**。

**この攻撃のPoCはリポジトリにあります：** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngineのバージョンは、`staging.<project-id>.appspot.com`という形式のバケット内にデータを生成します。このバケット内には、AppEngineアプリのバージョンごとにフォルダを含む`ae`というフォルダがあります。これらのフォルダ内には、特定のバージョンを作成するために使用されるすべてのファイルを含むjsonを持つ`manifest.json`ファイルがあります。さらに、**ファイルの実際の名前、GCPバケット内のURL（バケット内のファイルはそのsha1ハッシュのために名前が変更されています）、および各ファイルのsha1ハッシュを見つけることができます。**

_このバケットを事前に取得することはできません。なぜなら、GCPユーザーはappspot.comのドメイン名を使用してバケットを生成する権限がないからです。_

しかし、このバケットに対して読み取りおよび書き込みアクセスがあれば、バケットを監視し、変更が行われるたびに（新しいバージョン）、新しいバージョンをできるだけ早く変更することで、App Engineバージョンに付随するSAの権限を昇格させることが可能です。このようにして、このコードから作成されるコンテナはバックドア付きのコードを実行します。

前述の攻撃はさまざまな方法で実行できますが、すべては`staging.<project-id>.appspot.com`バケットを監視することから始まります：

- AppEngineバージョンの完全な新しいコードを別の利用可能なバケットにアップロードし、**新しいバケット名とそれらのsha1ハッシュを持つ`manifest.json`ファイルを準備します**。次に、バケット内で新しいバージョンが作成されると、`manifest.json`ファイルを変更し、悪意のあるものをアップロードするだけです。
- **悪意のある依存関係のコードを使用する`requirements.txt`の修正バージョンをアップロードし、`manifest.json`ファイルを新しいファイル名、URL、およびそのハッシュで更新します。**
- **悪意のあるコードを実行する`main.py`または`app.yaml`ファイルをアップロードし、`manifest.json`ファイルを新しいファイル名、URL、およびそのハッシュで更新します。**

**この攻撃のPoCはリポジトリにあります：** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry**はバケット内にイメージを保存します。**これらのバケットに書き込むことができれば、後でそれらのバケットが実行されている場所に横移動できる可能性があります。**
- GCRが使用するバケットは、`gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com`のようなURLを持ちます（トップレベルのサブドメインは[こちら](https://cloud.google.com/container-registry/docs/pushing-and-pulling)で指定されています）。

> [!TIP]
> このサービスは廃止されているため、この攻撃はもはや有効ではありません。さらに、このサービスの代わりとなるArtifact Registryは、バケットにイメージを保存しません。

## **参考文献**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
