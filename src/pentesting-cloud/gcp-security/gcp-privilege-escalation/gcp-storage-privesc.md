# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Βασικές Πληροφορίες:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Αυτή η άδεια σας επιτρέπει να **κατεβάσετε αρχεία που είναι αποθηκευμένα στο Cloud Storage**. Αυτό θα μπορούσε ενδεχομένως να σας επιτρέψει να κλιμακώσετε τα προνόμια σας, διότι σε ορισμένες περιπτώσεις **ευαίσθητες πληροφορίες αποθηκεύονται εκεί**. Επιπλέον, ορισμένες υπηρεσίες GCP αποθηκεύουν τις πληροφορίες τους σε buckets:

- **GCP Composer**: Όταν δημιουργείτε ένα Περιβάλλον Composer, ο **κώδικας όλων των DAGs** θα αποθηκευτεί μέσα σε ένα **bucket**. Αυτές οι εργασίες μπορεί να περιέχουν ενδιαφέρουσες πληροφορίες μέσα στον κώδικά τους.
- **GCR (Container Registry)**: Η **εικόνα** των κοντέινερ αποθηκεύεται μέσα σε **buckets**, που σημαίνει ότι αν μπορείτε να διαβάσετε τα buckets, θα μπορείτε να κατεβάσετε τις εικόνες και **να αναζητήσετε διαρροές και/ή πηγαίο κώδικα**.

### `storage.objects.setIamPolicy`

Μπορείτε να σας δώσετε άδεια να **καταχραστείτε οποιοδήποτε από τα προηγούμενα σενάρια αυτής της ενότητας**.

### **`storage.buckets.setIamPolicy`**

Για ένα παράδειγμα σχετικά με το πώς να τροποποιήσετε τις άδειες με αυτή την άδεια, ελέγξτε αυτή τη σελίδα:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Η δυνατότητα "διαλειτουργικότητας" του Cloud Storage, σχεδιασμένη για **διασυνοριακές αλληλεπιδράσεις** όπως με το AWS S3, περιλαμβάνει τη **δημιουργία HMAC κλειδιών για Λογαριασμούς Υπηρεσιών και χρήστες**. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό δημιουργώντας ένα HMAC κλειδί για έναν Λογαριασμό Υπηρεσίας με ανυψωμένα προνόμια, έτσι **κλιμακώνοντας τα προνόμια μέσα στο Cloud Storage**. Ενώ τα HMAC κλειδιά που σχετίζονται με χρήστες είναι προσβάσιμα μόνο μέσω της διαδικτυακής κονσόλας, τόσο τα κλειδιά πρόσβασης όσο και τα μυστικά κλειδιά παραμένουν **μόνιμα προσβάσιμα**, επιτρέποντας πιθανή αποθήκευση πρόσβασης backup. Αντίθετα, τα HMAC κλειδιά που συνδέονται με Λογαριασμούς Υπηρεσιών είναι προσβάσιμα μέσω API, αλλά τα κλειδιά πρόσβασης και τα μυστικά κλειδιά τους δεν είναι ανακτήσιμα μετά τη δημιουργία τους, προσθέτοντας μια επιπλέον στρώση πολυπλοκότητας για συνεχή πρόσβαση.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Ένα άλλο exploit script για αυτή τη μέθοδο μπορεί να βρεθεί [εδώ](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

## `storage.objects.create`, `storage.objects.delete` = Δικαιώματα Εγγραφής Αποθήκης

Για να **δημιουργήσετε ένα νέο αντικείμενο** μέσα σε ένα bucket χρειάζεστε `storage.objects.create` και, σύμφωνα με [τα docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), χρειάζεστε επίσης `storage.objects.delete` για να **τροποποιήσετε** ένα υπάρχον αντικείμενο.

Μια πολύ **συνηθισμένη εκμετάλλευση** των buckets όπου μπορείτε να γράψετε στο cloud είναι στην περίπτωση που το **bucket αποθηκεύει αρχεία web server**, μπορεί να είστε σε θέση να **αποθηκεύσετε νέο κώδικα** που θα χρησιμοποιηθεί από την web εφαρμογή.

### Composer

**Composer** είναι **Apache Airflow** που διαχειρίζεται μέσα στο GCP. Έχει αρκετές ενδιαφέρουσες δυνατότητες:

- Εκτελείται μέσα σε ένα **GKE cluster**, οπότε ο **SA που χρησιμοποιεί το cluster είναι προσβάσιμος** από τον κώδικα που εκτελείται μέσα στο Composer
- Όλα τα στοιχεία ενός περιβάλλοντος composer (**κώδικας DAGs**, plugins και δεδομένα) αποθηκεύονται μέσα σε ένα GCP bucket. Αν ο επιτιθέμενος έχει δικαιώματα ανάγνωσης και εγγραφής σε αυτό, θα μπορούσε να παρακολουθεί το bucket και **όποτε δημιουργείται ή ενηρώνεται ένα DAG, να υποβάλει μια εκδοχή με backdoor** ώστε το περιβάλλον composer να πάρει από την αποθήκη την εκδοχή με backdoor.

**Μπορείτε να βρείτε ένα PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Ο κώδικας των Cloud Functions αποθηκεύεται στο Storage και όποτε δημιουργείται μια νέα έκδοση, ο κώδικας σπρώχνεται στο bucket και στη συνέχεια το νέο container κατασκευάζεται από αυτόν τον κώδικα. Επομένως, **η αντικατάσταση του κώδικα πριν κατασκευαστεί η νέα έκδοση είναι δυνατή για να εκτελέσει η cloud function αυθαίρετο κώδικα**.

**Μπορείτε να βρείτε ένα PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

Οι εκδόσεις του AppEngine δημιουργούν κάποια δεδομένα μέσα σε ένα bucket με τη μορφή ονόματος: `staging.<project-id>.appspot.com`. Μέσα σε αυτό το bucket, είναι δυνατή η εύρεση ενός φακέλου που ονομάζεται `ae` που θα περιέχει έναν φάκελο ανά έκδοση της εφαρμογής AppEngine και μέσα σε αυτούς τους φακέλους θα είναι δυνατή η εύρεση του αρχείου `manifest.json`. Αυτό το αρχείο περιέχει ένα json με όλα τα αρχεία που πρέπει να χρησιμοποιηθούν για τη δημιουργία της συγκεκριμένης έκδοσης. Επιπλέον, είναι δυνατή η εύρεση των **πραγματικών ονομάτων των αρχείων, της διεύθυνσης URL τους μέσα στο GCP bucket (τα αρχεία μέσα στο bucket άλλαξαν το όνομά τους για το sha1 hash τους) και του sha1 hash κάθε αρχείου.**

_Σημειώστε ότι δεν είναι δυνατή η προ-κατάληψη αυτού του bucket επειδή οι χρήστες GCP δεν είναι εξουσιοδοτημένοι να δημιουργούν buckets χρησιμοποιώντας το όνομα τομέα appspot.com._

Ωστόσο, με δικαιώματα ανάγνωσης και εγγραφής σε αυτό το bucket, είναι δυνατή η κλιμάκωση των προνομίων στον SA που συνδέεται με την έκδοση του App Engine παρακολουθώντας το bucket και κάθε φορά που γίνεται μια αλλαγή (νέα έκδοση), να τροποποιείτε τη νέα έκδοση όσο το δυνατόν πιο γρήγορα. Με αυτόν τον τρόπο, το container που δημιουργείται από αυτόν τον κώδικα θα εκτελεί τον κώδικα με backdoor.

Η αναφερόμενη επίθεση μπορεί να εκτελεστεί με πολλούς διαφορετικούς τρόπους, όλοι ξεκινούν παρακολουθώντας το bucket `staging.<project-id>.appspot.com`:

- Ανεβάστε τον πλήρη νέο κώδικα της έκδοσης του AppEngine σε ένα διαφορετικό και διαθέσιμο bucket και ετοιμάστε ένα **`manifest.json` αρχείο με το νέο όνομα bucket και τα sha1 hashes τους**. Στη συνέχεια, όταν δημιουργείται μια νέα έκδοση μέσα στο bucket, απλώς χρειάζεται να τροποποιήσετε το αρχείο `manifest.json` και να ανεβάσετε το κακόβουλο.
- Ανεβάστε μια τροποποιημένη έκδοση του `requirements.txt` που θα χρησιμοποιεί τον **κακόβουλο κώδικα εξαρτήσεων και θα ενημερώνει το αρχείο `manifest.json`** με το νέο όνομα αρχείου, τη διεύθυνση URL και το hash του.
- Ανεβάστε ένα **τροποποιημένο αρχείο `main.py` ή `app.yaml` που θα εκτελεί τον κακόβουλο κώδικα** και θα ενημερώνει το αρχείο `manifest.json` με το νέο όνομα αρχείου, τη διεύθυνση URL και το hash του.

**Μπορείτε να βρείτε ένα PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** αποθηκεύει τις εικόνες μέσα σε buckets, αν μπορείτε να **γράψετε σε αυτά τα buckets** μπορεί να είστε σε θέση να **μετακινηθείτε πλευρικά εκεί όπου εκτελούνται αυτά τα buckets.**
- Το bucket που χρησιμοποιείται από το GCR θα έχει μια διεύθυνση URL παρόμοια με `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Οι κορυφαίοι υποτομείς καθορίζονται [εδώ](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Αυτή η υπηρεσία είναι απαρχαιωμένη, οπότε αυτή η επίθεση δεν είναι πλέον χρήσιμη. Επιπλέον, το Artifact Registry, η υπηρεσία που αντικαθιστά αυτήν, δεν αποθηκεύει τις εικόνες σε buckets.

## **Αναφορές**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
