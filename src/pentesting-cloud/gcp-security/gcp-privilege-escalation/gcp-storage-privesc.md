# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Osnovne informacije:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Ova dozvola vam omogućava da **preuzimate fajlove uskladištene u Cloud Storage**. To potencijalno može dovesti do eskalacije privilegija jer se u nekim slučajevima tamo čuvaju **osetljive informacije**. Pored toga, neke GCP usluge čuvaju svoje informacije u buckets:

- **GCP Composer**: Kada kreirate Composer Environment, **code of all the DAGs** biće sačuvan u **bucket**. Ti zadaci mogu sadržati interesantne informacije u svom kodu.
- **GCR (Container Registry)**: The **image** of the containers are stored inside **buckets**, što znači da ako možete čitati buckets moći ćete da preuzmete image-e i **pretražite leaks i/ili source code**.

### `storage.objects.setIamPolicy`

Možete sebi dodeliti dozvolu da **iskoristite bilo koji od prethodnih scenarija iz ovog odeljka**.

### **`storage.buckets.setIamPolicy`**

Za primer kako modifikovati dozvole koristeći ovu dozvolu pogledajte ovu stranicu:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage's "interoperability" feature, dizajnirana za **cross-cloud interactions** kao što je AWS S3, podrazumeva **kreiranje HMAC keys za Service Accounts i users**. Napadač to može iskoristiti tako što će **generisati HMAC key za Service Account sa povišenim privilegijama**, čime **escalating privileges within Cloud Storage**. Dok se HMAC keys povezani sa korisnicima mogu preuzeti samo preko web console, i access and secret keys ostaju **perpetually accessible**, što omogućava potencijalno skladištenje rezervnog pristupa. Suprotno tome, HMAC keys vezani za Service Account se mogu pristupiti preko API-ja, ali njihovi access and secret keys nisu dostupni za preuzimanje nakon kreiranja, što dodaje sloj složenosti za kontinuirani pristup.

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

Još jedan exploit script za ovu metodu može se naći [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage dozvole za pisanje

Da biste **kreirali novi objekat** unutar bucket-a potrebno je `storage.objects.create` i, prema [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), potrebno je i `storage.objects.delete` da biste **izmenili** postojeći objekat.

Veoma česta eksploatacija bucket-a u kojima imate mogućnost pisanja u cloud dešava se kada bucket čuva fajlove web servera — moguće je uskladištiti novi code koji će koristiti web aplikacija.

### Composer

**Composer** je **Apache Airflow** koji se upravlja unutar GCP. Ima nekoliko interesantnih karakteristika:

- Radi unutar **GKE cluster-a**, tako da je **SA koji cluster koristi dostupan** kodu koji se izvršava unutar Composer-a
- Sve komponente composer environment-a (**code of DAGs**, plugins i data) su smeštene unutar GCP bucket-a. Ako napadač ima read i write permisije nad njim, mogao bi da prati bucket i **kad god se DAG kreira ili ažurira, ubaci backdoored verziju** tako da composer environment iz storage-a preuzme backdoored verziju.

**Možete naći PoC ovog napada u repo-u:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions code je smešten u Storage i kad god se kreira nova verzija, code se push-uje u bucket i zatim se iz tog code-a gradi novi container. Dakle, **prepisivanjem code-a pre nego što se nova verzija sagradi moguće je naterati cloud function da izvrši proizvoljan code**.

**Možete naći PoC ovog napada u repo-u:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine verzije generišu neke podatke unutar bucket-a sa formatom imena: `staging.<project-id>.appspot.com`. Unutar ovog bucket-a moguće je naći folder nazvan `ae` koji će sadržati folder po verziji AppEngine aplikacije, a u tim folderima moguće je pronaći fajl `manifest.json`. Taj fajl sadrži json sa svim fajlovima koji moraju biti korišćeni za kreiranje određene verzije. Pored toga, moguće je naći **prava imena fajlova, URL do njih unutar GCP bucket-a (fajlovi u bucket-u su promenili ime u svoje sha1 hash-ove) i sha1 hash svakog fajla.**

_Napomena: nije moguće prethodno takeover-ovati ovaj bucket jer GCP korisnici nisu autorizovani da kreiraju bucket-ove koristeći domen appspot.com._

Međutim, uz read & write pristup ovom bucket-u, moguće je eskalirati privilegije na SA vezan za App Engine verziju tako što se prati bucket i svaki put kad se izvrši promena (nova verzija), izmeni nova verzija što je brže moguće. Na taj način container koji se kreira iz tog code-a će izvršiti backdoored code.

Navedeni napad se može izvesti na više različitih načina, svi počinju praćenjem `staging.<project-id>.appspot.com` bucket-a:

- Upload-ujte kompletan novi code AppEngine verzije u drugi dostupan bucket i pripremite **`manifest.json` fajl sa novim imenom bucket-a i sha1 hash-ovima fajlova**. Zatim, kada se kreira nova verzija unutar bucket-a, jednostavno izmenite `manifest.json` i upload-ujte malicioznu verziju.
- Upload-ujte izmenjenu verziju `requirements.txt` koja će koristiti maliciozni dependencies code i ažurirajte `manifest.json` fajl sa novim imenom fajla, URL-om i hash-om.
- Upload-ujte **izmenjeni `main.py` ili `app.yaml` fajl koji će izvršiti maliciozni code** i ažurirajte `manifest.json` fajl sa novim imenom fajla, URL-om i hash-om.

**Možete naći PoC ovog napada u repo-u:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** čuva image-e unutar bucket-ova; ako možete pisati u te bucket-ove, mogli biste se lateralno pomeriti tamo gde se ti bucket-ovi izvršavaju.
- Bucket koji koristi GCR će imati URL sličan `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (top-level subdomene su specificirane [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Ova usluga je deprecated pa ovaj napad više nije koristan. Pored toga, Artifact Registry, servis koji zamenjuje ovu uslugu, ne čuva image-e u bucket-ovima.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
