# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Informazioni di base:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Questa permission ti permette di **download files stored inside Cloud Storage**. Questo può potenzialmente consentire escalation di privilegi perché in alcune occasioni **sensitive information is saved there**. Inoltre, alcuni servizi GCP salvano le loro informazioni in buckets:

- **GCP Composer**: Quando crei un Composer Environment il **codice di tutti i DAGs** sarà salvato dentro un **bucket**. Questi task potrebbero contenere informazioni interessanti nel loro codice.
- **GCR (Container Registry)**: le **image** dei container sono memorizzate dentro **buckets**, il che significa che se puoi leggere i buckets potrai scaricare le image e **cercare leak e/o codice sorgente**.

### `storage.objects.setIamPolicy`

Questa permission ti permette di abusare di uno qualsiasi degli scenari precedenti in questa sezione.

### **`storage.buckets.setIamPolicy`**

Per un esempio su come modificare i permessi con questa permission controlla questa pagina:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

La feature "interoperability" di Cloud Storage, progettata per le **cross-cloud interactions** come con AWS S3, comporta la **creazione di HMAC keys per Service Accounts e utenti**. Un attaccante può sfruttare questo generando una HMAC key per un Service Account con privilegi elevati, elevando così i privilegi all'interno di Cloud Storage. Mentre le HMAC keys associate a utenti sono recuperabili solo tramite la web console, sia l'access che la secret key restano **permanentemente accessibili**, permettendo possibili backup per lo storage dell'accesso. Al contrario, le HMAC keys legate ai Service Account sono accessibili via API, ma le loro access e secret keys non sono recuperabili dopo la creazione, aggiungendo un livello di complessità per l'accesso continuo.

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

Un altro script di exploit per questo metodo può essere trovato [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

Per poter **creare un nuovo oggetto** dentro un bucket serve `storage.objects.create` e, secondo [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), serve anche `storage.objects.delete` per **modificare** un oggetto esistente.

Una **sfruttamento molto comune** dei bucket scrivibili è quando il **bucket salva file del web server**: potresti essere in grado di **caricare nuovo codice** che verrà usato dall'applicazione web.

### Composer

**Composer** è **Apache Airflow** gestito in GCP. Ha diverse caratteristiche interessanti:

- Esegue all'interno di un **GKE cluster**, quindi la **SA usata dal cluster è accessibile** dal codice che gira dentro Composer
- Tutti i componenti di un ambiente Composer (**code of DAGs**, plugin e dati) sono memorizzati dentro un bucket GCP. Se l'attaccante ha permessi di lettura e scrittura su di esso, può monitorare il bucket e **ogni volta che viene creato o aggiornato un DAG, sottomettere una versione backdoored** così l'ambiente Composer prenderà dalla storage la versione backdoored.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Il codice di Cloud Functions è salvato in Storage e ogni volta che viene creata una nuova versione il codice viene pushato nel bucket e poi dal codice viene buildato il nuovo container. Di conseguenza, **sovrascrivendo il codice prima che la nuova versione venga buildata è possibile far eseguire codice arbitrario alla cloud function**.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

Le versioni di AppEngine generano alcuni dati dentro un bucket con il formato nome: `staging.<project-id>.appspot.com`. Dentro questo bucket è possibile trovare una cartella chiamata `ae` che conterrà una cartella per ogni versione dell'app AppEngine e all'interno di queste cartelle si può trovare il file `manifest.json`. Questo file contiene un json con tutti i file che devono essere usati per creare la specifica versione. Inoltre, è possibile trovare i **nomi reali dei file, l'URL a essi dentro il bucket GCP (i file nel bucket cambiano nome con il loro sha1 hash) e lo sha1 hash di ciascun file.**

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

Tuttavia, con accesso di lettura e scrittura su questo bucket è possibile scalare privilegi all'SA collegato alla versione di App Engine monitorando il bucket e ogni volta che viene effettuata una modifica (nuova versione), modificare la nuova versione il più rapidamente possibile. In questo modo il container creato da quel codice eseguirà il codice backdoored.

L'attacco menzionato può essere eseguito in molti modi diversi; tutti iniziano monitorando il bucket `staging.<project-id>.appspot.com`:

- Caricare il codice completo della nuova versione di AppEngine in un bucket diverso e disponibile e preparare un file **`manifest.json` con il nuovo nome del bucket e gli sha1 hash** dei file. Quando viene creata una nuova versione nel bucket, basta modificare il `manifest.json` e caricare quello maligno.
- Caricare una versione modificata di `requirements.txt` che userà dipendenze malevole e aggiornare il `manifest.json` con il nuovo filename, URL e hash.
- Caricare un **`main.py` o `app.yaml` modificato che eseguirà il codice maligno** e aggiornare il `manifest.json` con il nuovo filename, URL e hash.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** memorizza le immagini dentro bucket; se puoi **scrivere in quei bucket** potresti essere in grado di **muoverti lateralmente verso dove quelle immagini vengono eseguite.**
- Il bucket usato da GCR avrà un URL simile a `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (i sottodomini di primo livello sono specificati [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Questo servizio è deprecato quindi questo attacco non è più utile. Inoltre, Artifact Registry, il servizio che lo sostituisce, non memorizza le immagini in bucket.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
