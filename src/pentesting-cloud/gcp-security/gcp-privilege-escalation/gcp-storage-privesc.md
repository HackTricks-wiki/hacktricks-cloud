# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Basiese inligting:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Hierdie toestemming laat jou toe om **lêers af te laai wat in Cloud Storage gestoor is**. Dit kan jou moontlik toelaat om escalate privileges omdat in sommige gevalle **sensitiewe inligting daar gestoor word**. Boonop bewaar sommige GCP-dienste hulle inligting in buckets:

- **GCP Composer**: Wanneer jy 'n Composer Environment skep, sal die **code of all the DAGs** binne 'n **bucket** gestoor word. Hierdie take kan interessante inligting in hul kode bevat.
- **GCR (Container Registry)**: Die **image** van die containers word in **buckets** gestoor, wat beteken dat as jy die buckets kan lees jy die images kan aflaai en vir leaks en/of source code kan soek.

### `storage.objects.setIamPolicy`

Hierdie toestemming kan jou die vermoë gee om **enige van die vorige scenario's in hierdie afdeling te misbruik**.
```bash
# Add binding
gcloud storage objects add-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Remove binding
gcloud storage objects remove-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Change Policy
gcloud storage objects set-iam-policy gs://<BUCKET_NAME>/<OBJECT_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
### **`storage.buckets.setIamPolicy`**

Vir 'n voorbeeld van hoe om toestemmings te wysig met hierdie toestemming, sien hierdie bladsy:
```bash
# Add binding
gcloud storage buckets add-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Remove binding
gcloud storage buckets remove-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Change policy
gcloud storage buckets set-iam-policy gs://<BUCKET_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Die "interoperability"-funksie van Cloud Storage, ontwerp vir **cross-cloud interactions** soos met AWS S3, behels die **skepping van HMAC-sleutels vir Service Accounts en users**. 'n Aanvaller kan dit misbruik deur **'n HMAC-sleutel te genereer vir 'n Service Account met verhoogde voorregte**, en sodoende **voorregte binne Cloud Storage op te skaal**. Terwyl gebruikers-geassosieerde HMAC-sleutels slegs via die web console opgevra kan word, bly beide die toegang- en geheime sleutels **permanent toeganklik**, wat die moontlikheid bied om toegang as 'n rugsteun te berg. Omgekeerd is Service Account-gekoppelde HMAC-sleutels via die API toeganklik, maar hul toegang- en geheime sleutels kan ná skepping nie opgehaal word nie, wat 'n ekstra laag kompleksiteit vir volgehoue toegang inhou.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

Om 'n **nuwe object te skep** binne 'n bucket het jy `storage.objects.create` nodig en, volgens [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), benodig jy ook `storage.objects.delete` om 'n bestaande object te **wysig**.

'n Baie **common exploitation** van buckets waar jy in die cloud kan skryf, is wanneer die **bucket webserver lêers stoor**, jy dalk in staat wees om **nuwe kode te stoor** wat deur die webtoepassing gebruik sal word.

### Composer

**Composer** is **Apache Airflow** wat binne GCP bestuur word. Dit het 'n paar interessante kenmerke:

- Dit hardloop binne 'n **GKE cluster**, so die **SA die cluster uses is accessible** deur die kode wat binne Composer loop
- Alle komponente van 'n composer-omgewing (**code of DAGs**, plugins en data) word gestoor binne 'n GCP bucket. As die aanvaller lees- en skryf-toestemmings daaroor het, kan hy die bucket monitor en **whenever a DAG is created or updated, submit a backdoored version** sodat die composer-omgewing die gemanipuleerde weergawe uit die storage sal haal.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions-kode word in Storage gestoor en elke keer as 'n nuwe weergawe geskep word, word die kode na die bucket gepusht en dan word die nuwe container uit hierdie kode gebou. Dus, deur die kode te oorskryf voordat die nuwe weergawe gebou word, is dit moontlik om die cloud function te laat uitvoer arbitrêre kode.
  
**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine-weergawes genereer sekere data binne 'n bucket met die formaat naam: `staging.<project-id>.appspot.com`. Binne hierdie bucket is dit moontlik om 'n gids genaamd `ae` te vind wat 'n gids per weergawe van die AppEngine-app sal bevat en binne daardie gidse sal die `manifest.json`-lêer gevind kan word. Hierdie lêer bevat 'n json met al die lêers wat gebruik moet word om die spesifieke weergawe te skep. Verder is dit moontlik om die **ware name van die lêers, die URL na hulle binne die GCP bucket (die lêers binne die bucket verander hul name in hul sha1 hash) en die sha1 hash van elke lêer** te vind.

Let wel dat dit nie moontlik is om hierdie bucket vooraf te takeover nie omdat GCP-gebruikers nie gemagtig is om buckets te genereer wat die domeinnaam appspot.com gebruik nie.

Met lees- en skryftoegang oor hierdie bucket is dit egter moontlik om voorregte te eskaleer na die SA wat aan die App Engine-weergawe geheg is deur die bucket te monitor en enige keer as 'n verandering uitgevoer word (nuwe weergawe), die nuwe weergawe so vinnig as moontlik te wysig. Op hierdie manier sal die container wat uit hierdie kode geskep word, die backdoored kode uitvoer.

Die genoemde aanval kan op baie verskillende maniere uitgevoer word, almal begin deur die `staging.<project-id>.appspot.com` bucket te monitor:

- Upload die volledige nuwe kode van die AppEngine-weergawe na 'n ander en beskikbare bucket en maak 'n **`manifest.json` file met die nuwe bucketnaam en sha1 hashes van hulle**. Dan, wanneer 'n nuwe weergawe binne die bucket geskep word, hoef jy net die `manifest.json`-lêer te wysig en die kwaadwillige een op te laai.
- Upload 'n gemodifiseerde `requirements.txt`-weergawe wat die **kwaadwillige afhanklikhede-kode** sal gebruik en werk die `manifest.json`-lêer by met die nuwe lêernaam, URL en die hash daarvan.
- Upload 'n **gemodifiseerde `main.py` of `app.yaml` lêer wat die kwaadwillige kode sal uitvoer** en werk die `manifest.json`-lêer by met die nuwe lêernaam, URL en die hash daarvan.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** stoor die images binne buckets; as jy daardie buckets kan **skryf** kan jy moontlik lateral beweeg na waar daardie buckets gehardloop word.
- Die bucket wat deur GCR gebruik word sal 'n URL hê soortgelyk aan `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Die topvlak subdomeine word hier gespesifiseer [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Hierdie diens is verouderd, so hierdie aanval is nou nie meer nuttig nie. Verder stoor Artifact Registry, die diens wat hierdie een vervang, nie die images in buckets nie.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
