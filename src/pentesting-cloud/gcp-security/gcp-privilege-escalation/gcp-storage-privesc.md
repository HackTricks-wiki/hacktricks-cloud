# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Informações básicas:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Essa permissão permite que você **faça download de arquivos armazenados dentro do Cloud Storage**. Isso pode potencialmente permitir escalada de privilégios, porque em algumas ocasiões **informações sensíveis são salvas lá**. Além disso, alguns serviços do GCP armazenam suas informações em buckets:

- **GCP Composer**: Quando você cria um Composer Environment, o **código de todos os DAGs** será salvo dentro de um **bucket**. Essas tasks podem conter informações interessantes dentro do seu código.
- **GCR (Container Registry)**: a **imagem** dos containers é armazenada dentro de **buckets**, o que significa que se você conseguir ler os buckets você poderá baixar as imagens e **buscar por leaks e/ou código fonte**.

### `storage.objects.setIamPolicy`

Isso pode te dar permissão para **abusar de qualquer um dos cenários anteriores desta seção**.

### **`storage.buckets.setIamPolicy`**

Para um exemplo de como modificar permissões com essa permissão, veja esta página:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

O recurso "interoperability" do Cloud Storage, projetado para **interações cross-cloud** como com AWS S3, envolve a **criação de HMAC keys para Service Accounts e usuários**. Um atacante pode explorar isso **gerando uma HMAC key para um Service Account com privilégios elevados**, assim **escalando privilégios dentro do Cloud Storage**. Enquanto HMAC keys associadas a usuários são recuperáveis apenas via console web, tanto as access quanto secret keys permanecem **perpetuamente acessíveis**, permitindo potencial armazenamento de acesso de backup. Por outro lado, HMAC keys vinculadas a Service Accounts são acessíveis via API, mas suas access e secret keys não são recuperáveis após a criação, adicionando uma camada de complexidade para acesso contínuo.

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

Para **criar um novo objeto** dentro de um bucket você precisa de `storage.objects.create` e, segundo [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), você também precisa de `storage.objects.delete` para **modificar** um objeto existente.

Uma exploração muito **comum** de buckets onde você pode escrever na cloud é quando o **bucket está servindo arquivos de um web server** — você pode ser capaz de **armazenar novo código** que será usado pela aplicação web.

### Composer

**Composer** é o **Apache Airflow** gerenciado dentro do GCP. Ele tem várias características interessantes:

- Roda dentro de um **GKE cluster**, então o **SA que o cluster usa é acessível** pelo código executado dentro do Composer
- Todos os componentes de um ambiente do composer (**code of DAGs**, plugins e data) são armazenados dentro de um GCP bucket. Se o atacante tiver permissões de leitura e escrita sobre ele, pode monitorar o bucket e **sempre que um DAG for criado ou atualizado, submeter uma versão backdoorada** para que o ambiente do composer obtenha do storage a versão comprometida.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- O código do Cloud Functions é armazenado no Storage e sempre que uma nova versão é criada o código é enviado para o bucket e então o novo container é buildado a partir desse código. Portanto, **sobrescrever o código antes da nova versão ser buildada permite fazer a cloud function executar código arbitrário**.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

As versões do AppEngine geram alguns dados dentro de um bucket com o nome no formato: `staging.<project-id>.appspot.com`. Dentro desse bucket, é possível encontrar uma pasta chamada `ae` que conterá uma pasta por versão da app AppEngine e dentro dessas pastas será possível encontrar o arquivo `manifest.json`. Esse arquivo contém um json com todos os arquivos que devem ser usados para criar a versão específica. Além disso, é possível encontrar os **nomes reais dos arquivos, a URL deles dentro do GCP bucket (os arquivos dentro do bucket mudaram de nome para o seu sha1 hash) e o sha1 hash de cada arquivo.**

_Note que não é possível pré-takeover desse bucket porque usuários GCP não estão autorizados a gerar buckets usando o domínio appspot.com._

No entanto, com acesso de leitura e escrita sobre esse bucket, é possível escalar privilégios para o SA associado à versão do App Engine monitorando o bucket e, toda vez que uma mudança for feita (nova versão), modificar a nova versão o mais rápido possível. Desse modo, o container criado a partir desse código executará o código backdoorado.

O ataque mencionado pode ser realizado de várias maneiras, todas começam monitorando o bucket `staging.<project-id>.appspot.com`:

- Faça upload do código completo da nova versão do AppEngine para um bucket diferente e disponível e prepare um arquivo **`manifest.json` com o novo nome do bucket e os sha1 hashes dos arquivos**. Então, quando uma nova versão for criada dentro do bucket, basta modificar o `manifest.json` e enviar o malicioso.
- Faça upload de uma versão modificada do `requirements.txt` que use dependências maliciosas e atualize o `manifest.json` com o novo filename, URL e hash.
- Faça upload de um **`main.py` ou `app.yaml` modificado que executará o código malicioso** e atualize o `manifest.json` com o novo filename, URL e hash.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** armazena as imagens dentro de buckets; se você puder **escrever nesses buckets** pode ser capaz de **mover lateralmente para onde essas buckets são executadas.**
- O bucket usado pelo GCR terá uma URL similar a `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Os subdomínios de topo são especificados [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> This service is deprecated so this attack is no longer useful. Moreover, Artifact Registry, the service that substitutes this one, does't store the images in buckets.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
