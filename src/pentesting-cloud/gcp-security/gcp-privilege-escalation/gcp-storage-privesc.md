# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Basic Information:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

This permission allows you to **download files stored inside Cloud Storage**. This will potentially allow you to escalate privileges because in some occasions **sensitive information is saved there**. Moreover, some GCP services stores their information in buckets:

- **GCP Composer**: When you create a Composer Environment the **code of all the DAGs** will be saved inside a **bucket**. These tasks might contain interesting information inside of their code.
- **GCR (Container Registry)**: The **image** of the containers are stored inside **buckets**, which means that if you can read the buckets you will be able to download the images and **search for leaks and/or source code**.

### `storage.objects.setIamPolicy`

You can give you permission to **abuse any of the previous scenarios of this section**.

### **`storage.buckets.setIamPolicy`**

For an example on how to modify permissions with this permission check this page:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage's "interoperability" feature, designed for **cross-cloud interactions** like with AWS S3, involves the **creation of HMAC keys for Service Accounts and users**. An attacker can exploit this by **generating an HMAC key for a Service Account with elevated privileges**, thus **escalating privileges within Cloud Storage**. While user-associated HMAC keys are only retrievable via the web console, both the access and secret keys remain **perpetually accessible**, allowing for potential backup access storage. Conversely, Service Account-linked HMAC keys are API-accessible, but their access and secret keys are not retrievable post-creation, adding a layer of complexity for continuous access.

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Δικαιώματα εγγραφής Storage

Για να **δημιουργήσετε ένα νέο αντικείμενο** μέσα σε ένα bucket χρειάζεστε `storage.objects.create` και, σύμφωνα με [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), χρειάζεστε επίσης `storage.objects.delete` για να **τροποποιήσετε** ένα υπάρχον αντικείμενο.

Μια πολύ **συνηθισμένη εκμετάλλευση** buckets όπου μπορείτε να γράψετε στο cloud είναι στην περίπτωση που το **bucket αποθηκεύει αρχεία web server**, μπορεί να καταφέρετε να **αποθηκεύσετε νέο κώδικα** που θα χρησιμοποιηθεί από την web εφαρμογή.

### Composer

**Composer** είναι **Apache Airflow** που διαχειρίζεται εντός GCP. Έχει αρκετά ενδιαφέροντα χαρακτηριστικά:

- Τρέχει μέσα σε ένα **GKE cluster**, οπότε το **SA που χρησιμοποιεί το cluster είναι προσβάσιμο** από τον κώδικα που εκτελείται μέσα στο Composer
- Όλα τα components ενός composer environment (**code of DAGs**, plugins και data) αποθηκεύονται σε ένα GCP bucket. Αν ο επιτιθέμενος έχει δικαιώματα ανάγνωσης και εγγραφής σε αυτό, μπορεί να παρακολουθεί το bucket και **όποτε ένα DAG δημιουργηθεί ή ενημερωθεί, να υποβάλει μια backdoored έκδοση** έτσι ώστε το composer environment να λάβει από το storage την backdoored έκδοση.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Ο κώδικας των Cloud Functions αποθηκεύεται στο Storage και όποτε δημιουργείται νέα έκδοση ο κώδικας προωθείται στο bucket και μετά γίνεται build του νέου container από αυτόν τον κώδικα. Επομένως, **αντικαθιστώντας τον κώδικα πριν χτιστεί η νέα έκδοση είναι δυνατό να κάνετε την cloud function να εκτελέσει αυθαίρετο κώδικα**.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

Οι εκδόσεις AppEngine δημιουργούν κάποια δεδομένα μέσα σε ένα bucket με τη μορφή ονόματος: `staging.<project-id>.appspot.com`. Μέσα σε αυτό το bucket, είναι δυνατό να βρεθεί ένας φάκελος με όνομα `ae` που θα περιέχει έναν φάκελο ανά έκδοση της AppEngine εφαρμογής και μέσα σε αυτούς τους φακέλους θα είναι δυνατό να βρεθεί το αρχείο `manifest.json`. Αυτό το αρχείο περιέχει ένα json με όλα τα αρχεία που πρέπει να χρησιμοποιηθούν για να δημιουργηθεί η συγκεκριμένη έκδοση. Επιπλέον, είναι δυνατό να βρείτε τα **πραγματικά ονόματα των αρχείων, το URL τους μέσα στο GCP bucket (τα αρχεία μέσα στο bucket άλλαξαν το όνομά τους σε sha1 hash) και το sha1 hash κάθε αρχείου.**

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

Ωστόσο, με δικαιώματα ανάγνωσης & εγγραφής σε αυτό το bucket, είναι δυνατό να πραγματοποιηθεί escalation προνομίων στο SA που είναι συνημμένο στην έκδοση App Engine παρακολουθώντας το bucket και κάθε φορά που γίνεται μια αλλαγή (νέα έκδοση), να τροποποιήσετε τη νέα έκδοση όσο πιο γρήγορα γίνεται. Με αυτόν τον τρόπο, ο container που δημιουργείται από αυτόν τον κώδικα θα εκτελέσει τον backdoored κώδικα.

Η προαναφερθείσα επίθεση μπορεί να πραγματοποιηθεί με πολλούς διαφορετικούς τρόπους, όλοι ξεκινούν παρακολουθώντας το `staging.<project-id>.appspot.com` bucket:

- Ανεβάστε τον πλήρη νέο κώδικα της έκδοσης AppEngine σε ένα διαφορετικό και διαθέσιμο bucket και ετοιμάστε ένα **`manifest.json` αρχείο με το νέο όνομα bucket και τα sha1 hashes τους**. Έπειτα, όταν δημιουργηθεί μια νέα έκδοση μέσα στο bucket, απλά χρειάζεται να τροποποιήσετε το `manifest.json` και να ανεβάσετε το κακόβουλο αρχείο.
- Ανεβάστε μια τροποποιημένη `requirements.txt` έκδοση που θα χρησιμοποιεί **κακόβουλο κώδικα εξαρτήσεων** και ενημερώστε το `manifest.json` με το νέο όνομα αρχείου, το URL και το hash του.
- Ανεβάστε ένα **τροποποιημένο `main.py` ή `app.yaml` αρχείο που θα εκτελέσει τον κακόβουλο κώδικα** και ενημερώστε το `manifest.json` με το νέο όνομα αρχείου, το URL και το hash του.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** αποθηκεύει τα images μέσα σε buckets, αν μπορείτε να **γράψετε σε αυτά τα buckets** μπορεί να είστε σε θέση να **μετακινηθείτε πλευρικά προς εκεί που αυτά τα buckets τρέχουν.**
- Το bucket που χρησιμοποιείται από GCR θα έχει ένα URL παρόμοιο με `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Τα top level subdomains καθορίζονται [εδώ](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Αυτή η υπηρεσία είναι deprecated οπότε αυτή η επίθεση δεν είναι πλέον χρήσιμη. Επιπλέον, Artifact Registry, η υπηρεσία που την αντικαθιστά, δεν αποθηκεύει τα images σε buckets.

## **Αναφορές**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
