# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Basic Information:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

이 권한은 **Cloud Storage에 저장된 파일을 다운로드할 수 있게 합니다**. 경우에 따라 **민감한 정보가 그곳에 저장되어 있기 때문에** 이는 권한 상승으로 이어질 수 있습니다. 또한 일부 GCP 서비스는 정보를 buckets에 저장합니다:

- **GCP Composer**: Composer Environment를 생성하면 **모든 DAG의 코드**가 **bucket** 안에 저장됩니다. 이러한 작업의 코드 안에는 흥미로운 정보가 포함되어 있을 수 있습니다.
- **GCR (Container Registry)**: 컨테이너의 **이미지**는 **buckets**에 저장되므로, 해당 buckets를 읽을 수 있다면 이미지를 다운로드하여 **leaks 및/또는 소스 코드**를 검색할 수 있습니다.

### `storage.objects.setIamPolicy`

이 권한은 **이 섹션의 이전 시나리오들을 악용할 수 있는 권한을 부여할 수 있습니다**.
```bash
# Add binding
gcloud storage objects add-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Remove binding
gcloud storage objects remove-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Change Policy
gcloud storage objects set-iam-policy gs://<BUCKET_NAME>/<OBJECT_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
### **`storage.buckets.setIamPolicy`**

이 권한으로 권한을 수정하는 방법의 예시는 이 페이지를 확인하세요:
```bash
# Add binding
gcloud storage buckets add-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Remove binding
gcloud storage buckets remove-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Change policy
gcloud storage buckets set-iam-policy gs://<BUCKET_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage의 "interoperability" 기능은 AWS S3와 같은 **크로스-클라우드 상호작용**을 위해 설계되었으며, **Service Accounts와 사용자용 HMAC 키 생성**을 포함합니다. 공격자는 **권한이 높은 Service Account에 대한 HMAC 키 생성**을 이용해 이를 악용할 수 있으며, 그 결과 Cloud Storage 내에서 **권한 상승**이 발생할 수 있습니다. 사용자 연동 HMAC 키는 웹 콘솔을 통해서만 조회할 수 있지만, 액세스 및 시크릿 키는 **영구적으로 접근 가능**하여 백업 용도로 저장될 수 있습니다. 반면 Service Account에 연결된 HMAC 키는 API로 접근 가능하지만, 생성 후에는 액세스 및 시크릿 키를 조회할 수 없어 지속적인 접근 확보에 추가적인 복잡성이 발생합니다.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage 쓰기 권한

In order to **create a new object** inside a bucket you need `storage.objects.create` and, according to [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), you need also `storage.objects.delete` to **modify** an existent object.

A very **common exploitation** of buckets where you can write in cloud is in case the **bucket is saving web server files**, you might be able to **store new code** that will be used by the web application.

### Composer

**Composer**는 GCP 내에서 관리되는 Apache Airflow입니다. 다음과 같은 흥미로운 특성이 있습니다:

- Composer는 **GKE cluster** 내부에서 실행되므로, 클러스터가 사용하는 **SA에 Composer 내부에서 실행되는 코드가 접근할 수 있습니다**
- Composer 환경의 모든 구성 요소(**DAGs 코드**, 플러그인 및 데이터)는 GCP 버킷에 저장됩니다. 공격자가 해당 버킷에 대한 읽기/쓰기 권한을 가지고 있다면 버킷을 모니터링하면서 **DAG가 생성되거나 업데이트될 때마다 backdoored version을 제출**하여 Composer 환경이 storage에서 백도어된 버전을 가져오도록 할 수 있습니다.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions의 코드는 Storage에 저장되며 새 버전이 생성될 때 코드가 버킷으로 푸시되고 그 코드로부터 새로운 컨테이너가 빌드됩니다. 따라서, **새 버전이 빌드되기 전에 코드를 덮어쓰면 해당 cloud function이 임의 코드를 실행하도록 만들 수 있습니다.**

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine 버전은 `staging.<project-id>.appspot.com` 형식 이름의 버킷 안에 일부 데이터를 생성합니다. 이 버킷 안에서는 `ae`라는 폴더를 찾을 수 있으며, 그 안에는 AppEngine 앱의 각 버전별 폴더가 들어 있고, 이 폴더들 내부에서 `manifest.json` 파일을 확인할 수 있습니다. 이 파일은 특정 버전을 생성하는 데 사용되는 모든 파일 목록을 담은 json을 포함합니다. 또한, **파일의 실제 이름, GCP 버킷 내에서의 URL(버킷 내부의 파일들은 sha1 해시로 이름이 변경됨) 및 각 파일의 sha1 해시**를 찾을 수 있습니다.

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

하지만 이 버킷에 대한 읽기 및 쓰기 권한이 있다면 버킷을 모니터링하면서 변경(새 버전)이 발생할 때마다 가능한 한 빠르게 새 버전을 수정함으로써 App Engine 버전에 연결된 SA로 권한 상승이 가능합니다. 이렇게 하면 해당 코드로부터 생성되는 컨테이너가 backdoored 코드를 실행하게 됩니다.

앞서 언급한 공격은 여러 방식으로 수행될 수 있으며, 모두 `staging.<project-id>.appspot.com` 버킷을 모니터링하는 것으로 시작합니다:

- AppEngine 버전의 전체 새 코드를 다른 사용 가능한 버킷에 업로드하고 **새 버킷 이름과 각 파일의 sha1 해시를 포함한 `manifest.json` 파일을 준비**합니다. 그런 다음 버킷 안에 새 버전이 생성될 때 `manifest.json` 파일을 수정하여 악성 것으로 업로드하면 됩니다.
- 악성 종속성 코드를 사용하도록 변경한 `requirements.txt`를 업로드하고 `manifest.json`을 새로운 파일명, URL 및 해시로 업데이트합니다.
- 악성 코드를 실행하도록 변경한 `main.py` 또는 `app.yaml` 파일을 업로드하고 `manifest.json`을 새로운 파일명, URL 및 해시로 업데이트합니다.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry**는 이미지를 버킷에 저장합니다. 이 버킷들에 **쓰기 권한**이 있으면 해당 버킷이 실행되는 곳으로 **lateral movement(횡적 이동)**을 시도할 수 있습니다.
- GCR에서 사용하는 버킷은 `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com`와 유사한 URL을 가지며 (최상위 서브도메인은 [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)에 명시되어 있습니다).

> [!TIP]
> 이 서비스는 deprecated 상태이므로 이 공격은 더 이상 유용하지 않습니다. 또한 이 서비스를 대체하는 Artifact Registry는 이미지를 버킷에 저장하지 않습니다.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
