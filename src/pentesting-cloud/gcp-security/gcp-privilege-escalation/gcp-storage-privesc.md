# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Basic Information:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

이 권한은 **Cloud Storage에 저장된 파일을 다운로드**할 수 있게 합니다. 경우에 따라 **민감한 정보가 그곳에 저장되어 있는 경우**가 있어 이로 인해 권한 상승이 가능해질 수 있습니다. 또한 일부 GCP 서비스는 정보를 버킷에 저장합니다:

- **GCP Composer**: Composer Environment를 생성하면 **모든 DAGs의 코드**가 **버킷**에 저장됩니다. 이러한 작업의 코드 안에는 흥미로운 정보가 포함되어 있을 수 있습니다.
- **GCR (Container Registry)**: 컨테이너의 **이미지**가 **버킷** 안에 저장되므로, 버킷을 읽을 수 있다면 이미지를 다운로드하여 **leaks 및/또는 소스 코드**를 검색할 수 있습니다.

### `storage.objects.setIamPolicy`

이 권한은 이 섹션의 이전 시나리오들을 **악용할 수 있는 권한을 부여**할 수 있게 합니다.

### **`storage.buckets.setIamPolicy`**

이 권한으로 권한을 수정하는 방법의 예제는 다음 페이지를 확인하세요:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage의 "interoperability" 기능은 AWS S3와 같은 cross-cloud 상호작용을 위해 설계되었으며, Service Accounts 및 사용자에 대한 HMAC 키 생성과 관련됩니다. 공격자는 권한이 높은 Service Account에 대해 HMAC 키를 생성함으로써 Cloud Storage 내에서 권한을 상승시킬 수 있습니다. 사용자에 연관된 HMAC 키는 웹 콘솔을 통해서만 조회할 수 있는 반면, access 및 secret 키는 영구적으로 접근 가능하여 백업 목적으로 저장될 수 있습니다. 반대로 Service Account에 연결된 HMAC 키는 API로 접근 가능하지만, 생성 이후에는 access 및 secret 키를 조회할 수 없어 지속적인 접근 측면에서 복잡성이 추가됩니다.

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

이 방법에 대한 또 다른 익스플로잇 스크립트는 [여기](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py)에서 확인할 수 있습니다.

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

버킷 안에 **새 객체를 생성**하려면 `storage.objects.create`가 필요하고, [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions)에 따르면 기존 객체를 **수정**하려면 `storage.objects.delete`도 필요합니다.

클라우드에 쓰기 가능한 버킷을 악용하는 매우 **일반적인 사례**는 **버킷이 web server files 를 저장**하는 경우로, 웹 애플리케이션에서 사용될 **새 코드를 저장**할 수 있다는 점입니다.

### Composer

**Composer**는 GCP 내부에서 관리되는 **Apache Airflow**입니다. 다음과 같은 흥미로운 특성이 있습니다:

- **GKE cluster** 안에서 실행되므로, **the SA the cluster uses is accessible** by the code running inside Composer.
- composer 환경의 모든 구성요소(**code of DAGs**, plugins 및 data)는 GCP 버킷에 저장됩니다. 공격자가 해당 버킷에 대해 읽기 및 쓰기 권한을 가지고 있다면 버킷을 모니터링하여 **whenever a DAG is created or updated, submit a backdoored version** 하여 composer 환경이 storage에서 백도어된 버전을 가져오게 할 수 있습니다.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions의 코드는 Storage에 저장되며 새로운 버전이 생성되면 코드가 버킷으로 푸시되고 그 코드로부터 새로운 컨테이너가 빌드됩니다. 따라서 **새 버전이 빌드되기 전에 코드를 덮어쓰는 것만으로도 cloud function이 arbitrary code를 실행하게 만드는 것이 가능합니다.**

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine 버전은 `staging.<project-id>.appspot.com` 형식의 버킷 안에 일부 데이터를 생성합니다. 이 버킷 안에는 `ae`라는 폴더를 찾을 수 있으며, 그 안에는 AppEngine 앱의 각 버전별 폴더가 있고 해당 폴더들 안에서 `manifest.json` 파일을 찾을 수 있습니다. 이 파일은 특정 버전을 생성하는 데 사용되어야 할 모든 파일의 json을 포함합니다. 또한 **파일의 실제 이름, GCP 버킷 내에서의 URL(버킷 내부의 파일들은 sha1 해시로 이름이 바뀌어 있음) 및 각 파일의 sha1 해시**를 확인할 수 있습니다.

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

그러나 이 버킷에 대한 읽기 및 쓰기 접근 권한이 있다면 버킷을 모니터링하면서 변경(새 버전)이 발생할 때마다 가능한 한 빨리 새 버전을 수정하여 App Engine 버전에 연결된 SA로 권한 상승할 수 있습니다. 이렇게 하면 이 코드로부터 생성된 컨테이너가 backdoored 코드를 실행하게 됩니다.

언급한 공격은 여러 가지 방법으로 수행될 수 있으며, 모두 `staging.<project-id>.appspot.com` 버킷을 모니터링하는 것에서 시작합니다:

- AppEngine 버전의 전체 새 코드를 다른 사용 가능한 버킷에 업로드하고, **새 버킷 이름과 그들에 대한 sha1 해시를 포함한 `manifest.json` 파일을 준비**합니다. 그런 다음 버킷에 새 버전이 생성되면 `manifest.json` 파일을 수정하여 악성 버전으로 업로드하면 됩니다.
- 수정된 `requirements.txt` 버전을 업로드하여 **malicious dependencies code** 를 사용하게 하고 `manifest.json` 파일을 새 파일명, URL 및 해시로 업데이트합니다.
- **수정된 `main.py` 또는 `app.yaml` 파일을 업로드하여 malicious code를 실행**하게 하고 `manifest.json` 파일을 새 파일명, URL 및 해시로 업데이트합니다.

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry**는 이미지를 버킷 안에 저장합니다. 해당 버킷에 **쓰기 권한**이 있다면 그 버킷이 실행되는 지점으로 **lateral 이동**할 수 있을지도 모릅니다.
- GCR에서 사용하는 버킷은 `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com`과 유사한 URL을 갖습니다(최상위 서브도메인은 [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)에 지정되어 있습니다).

> [!TIP]
> This service is deprecated so this attack is no longer useful. Moreover, Artifact Registry, the service that substitutes this one, does't store the images in buckets.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
