# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Βασικές Πληροφορίες:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Αυτή η άδεια σας επιτρέπει να **κατεβάσετε αρχεία που είναι αποθηκευμένα στο Cloud Storage**. Αυτό θα μπορούσε ενδεχομένως να σας επιτρέψει να κλιμακώσετε τα προνόμια σας, διότι σε ορισμένες περιπτώσεις **ευαίσθητες πληροφορίες αποθηκεύονται εκεί**. Επιπλέον, ορισμένες υπηρεσίες GCP αποθηκεύουν τις πληροφορίες τους σε buckets:

- **GCP Composer**: Όταν δημιουργείτε ένα Περιβάλλον Composer, ο **κώδικας όλων των DAGs** θα αποθηκευτεί μέσα σε ένα **bucket**. Αυτές οι εργασίες μπορεί να περιέχουν ενδιαφέρουσες πληροφορίες μέσα στον κώδικά τους.
- **GCR (Container Registry)**: Η **εικόνα** των κοντέινερ αποθηκεύεται μέσα σε **buckets**, που σημαίνει ότι αν μπορείτε να διαβάσετε τα buckets θα μπορείτε να κατεβάσετε τις εικόνες και **να αναζητήσετε leaks και/ή πηγαίο κώδικα**.

### `storage.objects.setIamPolicy`

Μπορείτε να σας δώσετε άδεια να **καταχραστείτε οποιοδήποτε από τα προηγούμενα σενάρια αυτής της ενότητας**.

### **`storage.buckets.setIamPolicy`**

Για ένα παράδειγμα σχετικά με το πώς να τροποποιήσετε τις άδειες με αυτή την άδεια, ελέγξτε αυτή τη σελίδα:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Η δυνατότητα "διαλειτουργικότητας" του Cloud Storage, σχεδιασμένη για **διασυνοριακές αλληλεπιδράσεις** όπως με το AWS S3, περιλαμβάνει τη **δημιουργία HMAC κλειδιών για Λογαριασμούς Υπηρεσιών και χρήστες**. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό δημιουργώντας ένα HMAC κλειδί για έναν Λογαριασμό Υπηρεσίας με ανυψωμένα προνόμια, έτσι **κλιμακώνοντας τα προνόμια μέσα στο Cloud Storage**. Ενώ τα HMAC κλειδιά που σχετίζονται με χρήστες είναι προσβάσιμα μόνο μέσω της διαδικτυακής κονσόλας, τόσο τα κλειδιά πρόσβασης όσο και τα μυστικά κλειδιά παραμένουν **μόνιμα προσβάσιμα**, επιτρέποντας πιθανή αποθήκευση πρόσβασης backup. Αντίθετα, τα HMAC κλειδιά που συνδέονται με Λογαριασμούς Υπηρεσιών είναι προσβάσιμα μέσω API, αλλά τα κλειδιά πρόσβασης και τα μυστικά κλειδιά τους δεν είναι ανακτήσιμα μετά τη δημιουργία, προσθέτοντας ένα επίπεδο πολυπλοκότητας για συνεχή πρόσβαση.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

## `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

Για να **δημιουργήσετε ένα νέο αντικείμενο** μέσα σε έναν κάδο χρειάζεστε `storage.objects.create` και, σύμφωνα με [την τεκμηρίωση](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions), χρειάζεστε επίσης `storage.objects.delete` για να **τροποποιήσετε** ένα υπάρχον αντικείμενο.

Μια πολύ **συνηθισμένη εκμετάλλευση** των κάδων όπου μπορείτε να γράψετε στο cloud είναι στην περίπτωση που ο **κάδος αποθηκεύει αρχεία διακομιστή ιστού**, μπορεί να είστε σε θέση να **αποθηκεύσετε νέο κώδικα** που θα χρησιμοποιηθεί από την εφαρμογή ιστού.

### Composer

**Composer** είναι **Apache Airflow** που διαχειρίζεται μέσα στο GCP. Έχει αρκετές ενδιαφέρουσες δυνατότητες:

- Εκτελείται μέσα σε ένα **GKE cluster**, οπότε ο **SA που χρησιμοποιεί το cluster είναι προσβάσιμος** από τον κώδικα που εκτελείται μέσα στο Composer
- Όλα τα στοιχεία ενός περιβάλλοντος composer (**κώδικας DAGs**, plugins και δεδομένα) αποθηκεύονται μέσα σε έναν κάδο GCP. Εάν ο επιτιθέμενος έχει δικαιώματα ανάγνωσης και εγγραφής πάνω σε αυτόν, θα μπορούσε να παρακολουθεί τον κάδο και **όποτε δημιουργείται ή ενημερώνεται ένα DAG, να υποβάλει μια εκδοχή με backdoor** ώστε το περιβάλλον composer να πάρει από την αποθήκευση την εκδοχή με backdoor.

**Μπορείτε να βρείτε μια PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Ο κώδικας των Cloud Functions αποθηκεύεται στο Storage και όποτε δημιουργείται μια νέα έκδοση, ο κώδικας προωθείται στον κάδο και στη συνέχεια το νέο κοντέινερ κατασκευάζεται από αυτόν τον κώδικα. Επομένως, **η αντικατάσταση του κώδικα πριν κατασκευαστεί η νέα έκδοση είναι δυνατή για να εκτελέσει η cloud function αυθαίρετο κώδικα**.

**Μπορείτε να βρείτε μια PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

Οι εκδόσεις του AppEngine δημιουργούν κάποια δεδομένα μέσα σε έναν κάδο με τη μορφή ονόματος: `staging.<project-id>.appspot.com`. Μέσα σε αυτόν τον κάδο, είναι δυνατή η εύρεση ενός φακέλου που ονομάζεται `ae` που θα περιέχει έναν φάκελο ανά έκδοση της εφαρμογής AppEngine και μέσα σε αυτούς τους φακέλους θα είναι δυνατή η εύρεση του αρχείου `manifest.json`. Αυτό το αρχείο περιέχει ένα json με όλα τα αρχεία που πρέπει να χρησιμοποιηθούν για τη δημιουργία της συγκεκριμένης έκδοσης. Επιπλέον, είναι δυνατή η εύρεση των **πραγματικών ονομάτων των αρχείων, του URL τους μέσα στον κάδο GCP (τα αρχεία μέσα στον κάδο άλλαξαν το όνομά τους για το sha1 hash τους) και του sha1 hash κάθε αρχείου.**

_Σημειώστε ότι δεν είναι δυνατή η προ-κατάληψη αυτού του κάδου επειδή οι χρήστες GCP δεν είναι εξουσιοδοτημένοι να δημιουργούν κάδους χρησιμοποιώντας το όνομα τομέα appspot.com._

Ωστόσο, με δικαιώματα ανάγνωσης και εγγραφής πάνω σε αυτόν τον κάδο, είναι δυνατή η κλιμάκωση των δικαιωμάτων στον SA που συνδέεται με την έκδοση App Engine παρακολουθώντας τον κάδο και κάθε φορά που πραγματοποιείται μια αλλαγή (νέα έκδοση), να τροποποιείτε τη νέα έκδοση όσο το δυνατόν πιο γρήγορα. Με αυτόν τον τρόπο, το κοντέινερ που δημιουργείται από αυτόν τον κώδικα θα εκτελεί τον κώδικα με backdoor.

Η αναφερόμενη επίθεση μπορεί να πραγματοποιηθεί με πολλούς διαφορετικούς τρόπους, όλοι ξεκινούν παρακολουθώντας τον κάδο `staging.<project-id>.appspot.com`:

- Ανεβάστε τον πλήρη νέο κώδικα της έκδοσης AppEngine σε έναν διαφορετικό και διαθέσιμο κάδο και ετοιμάστε ένα **`manifest.json` αρχείο με το νέο όνομα κάδου και τα sha1 hashes τους**. Στη συνέχεια, όταν δημιουργείται μια νέα έκδοση μέσα στον κάδο, απλώς χρειάζεται να τροποποιήσετε το αρχείο `manifest.json` και να ανεβάσετε το κακόβουλο.
- Ανεβάστε μια τροποποιημένη έκδοση `requirements.txt` που θα χρησιμοποιεί τον **κακόβουλο κώδικα εξαρτήσεων και να ενημερώσετε το αρχείο `manifest.json`** με το νέο όνομα αρχείου, URL και το hash του.
- Ανεβάστε ένα **τροποποιημένο αρχείο `main.py` ή `app.yaml` που θα εκτελεί τον κακόβουλο κώδικα** και να ενημερώσετε το αρχείο `manifest.json` με το νέο όνομα αρχείου, URL και το hash του.

**Μπορείτε να βρείτε μια PoC αυτής της επίθεσης στο repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** αποθηκεύει τις εικόνες μέσα σε κάδους, αν μπορείτε να **γράψετε σε αυτούς τους κάδους** μπορεί να είστε σε θέση να **κινηθείτε οριζόντια εκεί όπου εκτελούνται αυτοί οι κάδοι.**
- Ο κάδος που χρησιμοποιείται από το GCR θα έχει μια διεύθυνση URL παρόμοια με `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Οι υποτομείς πρώτου επιπέδου καθορίζονται [εδώ](https://cloud.google.com/container-registry/docs/pushing-and-pulling)).

> [!TIP]
> Αυτή η υπηρεσία είναι απαρχαιωμένη, επομένως αυτή η επίθεση δεν είναι πλέον χρήσιμη. Επιπλέον, το Artifact Registry, η υπηρεσία που αντικαθιστά αυτήν, δεν αποθηκεύει τις εικόνες σε κάδους.

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
