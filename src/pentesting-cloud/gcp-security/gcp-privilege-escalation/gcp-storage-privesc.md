# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Basic Information:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Bu izin, Cloud Storage içinde saklanan dosyaları **indirmeyi** sağlar. Bu, bazı durumlarda **hassas bilgilerin orada saklanması** nedeniyle potansiyel olarak yetki yükseltmeye olanak verebilir. Ayrıca bazı GCP servisleri bilgilerini bucket'larda saklar:

- **GCP Composer**: Bir Composer Environment oluşturduğunuzda **tüm DAG'ların kodu** bir **bucket** içinde saklanır. Bu görevler kodlarının içinde ilginç bilgiler barındırabilir.
- **GCR (Container Registry)**: Container'ların **image'leri** **buckets** içinde saklanır; bu da bucket'ları okuyabilirseniz image'leri indirip **leaks** ve/veya **source code** arayabileceğiniz anlamına gelir.

### `storage.objects.setIamPolicy`

Bu izin, bu bölümdeki önceki senaryoların herhangi birini **kötüye kullanma** yetkisi verebilir.
```bash
# Add binding
gcloud storage objects add-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Remove binding
gcloud storage objects remove-iam-policy-binding gs://<BUCKET_NAME>/<OBJECT_NAME> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role="<ROLE>" \
--project=<PROJECT_ID>

# Change Policy
gcloud storage objects set-iam-policy gs://<BUCKET_NAME>/<OBJECT_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
### **`storage.buckets.setIamPolicy`**

Bu iznin kullanımıyla izinleri nasıl değiştirebileceğinize dair bir örnek için bu sayfaya bakın:
```bash
# Add binding
gcloud storage buckets add-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Remove binding
gcloud storage buckets remove-iam-policy-binding gs://<MY_BUCKET> \
--member="<MEMBER_TYPE>:<MEMBER_IDENTIFIER>" \
--role=<ROLE> \
--project=<MY_PROJECT>

# Change policy
gcloud storage buckets set-iam-policy gs://<BUCKET_NAME> - \
--project=<PROJECT_ID> <<'POLICY'
{
"bindings": [
{
"role": "<ROLE>",
"members": [
"<MEMBER_TYPE>:<MEMBER_IDENTIFIER>"
]
}
]
}
POLICY

```
{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage'ın "interoperability" özelliği, AWS S3 gibi **bulutlar arası etkileşimler** için tasarlanmıştır ve **Service Accounts ve users için HMAC anahtarlarının oluşturulmasını** içerir. Bir saldırgan bunu, **ayrıcalıkları yükseltilmiş bir Service Account için bir HMAC anahtarı oluşturarak** suistimal edebilir; böylece **Cloud Storage içinde ayrıcalık yükseltme** gerçekleşir. Kullanıcıya bağlı HMAC anahtarları yalnızca web konsolu üzerinden alınabilirken, hem access hem de secret anahtarlar **sürekli erişilebilir** durumda kalarak potansiyel yedek erişim depolamaya izin verir. Buna karşılık, Service Account'a bağlı HMAC anahtarları API üzerinden erişilebilir, ancak oluşturma sonrası access ve secret anahtarları alınamaz; bu da sürekli erişim için ek bir karmaşıklık katmanı ekler.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

Bir bucket içine **yeni bir object oluşturmak** için `storage.objects.create` gerekir ve, [docs](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions)'a göre, mevcut bir object'i **değiştirmek** için ayrıca `storage.objects.delete` gereklidir.

Bulutta yazma izniniz olan bucket'ların çok **yaygın bir sömürüsü**, bucket web sunucu dosyalarını saklıyorsa, web uygulaması tarafından kullanılacak **yeni kodu depolayabilmenizdir**.

### Composer

**Composer**, GCP içinde yönetilen **Apache Airflow**'dur. Birkaç ilgi çekici özelliği vardır:

- **GKE cluster** içinde çalışır, bu yüzden cluster'ın kullandığı **SA, Composer içinde çalışan kod tarafından erişilebilir**.
- Bir composer ortamının tüm bileşenleri (**DAGs kodu**, pluginler ve veriler) bir GCP bucket içinde saklanır. Eğer bir saldırganın bu bucket üzerinde okuma ve yazma izinleri varsa, bucket'ı izleyip **herhangi bir DAG oluşturulduğunda veya güncellendiğinde, arka kapılı bir sürüm göndererek** composer ortamının storage'dan arka kapılı sürümü almasını sağlayabilir.

**Bu saldırının PoC'unu repo'da bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions kodu Storage içinde saklanır ve yeni bir versiyon oluşturulduğunda kod bucket'a gönderilir ve ardından bu koddan yeni container build edilir. Bu nedenle, **yeni versiyon build edilmeden önce kodu overwrite etmek, cloud function'ın rastgele kod çalıştırmasını sağlamak için mümkündür**.

**Bu saldırının PoC'unu repo'da bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine versiyonları, `staging.<project-id>.appspot.com` formatında bir bucket içinde bazı veriler üretir. Bu bucket içinde, her AppEngine versiyonu için bir klasör içeren `ae` adında bir klasör bulunabilir ve bu klasörlerin içinde `manifest.json` dosyasını bulmak mümkün olur. Bu dosya, belirli versiyonun oluşturulmasında kullanılacak tüm dosyaların json'unu içerir. Ayrıca, **dosyaların gerçek isimlerini, GCP bucket içindeki URL'lerini (bucket içindeki dosyalar isimlerini sha1 hash'leri ile değiştirmiştir) ve her dosyanın sha1 hash'ini** bulmak mümkündür.

_Note that it's not possible to pre-takeover this bucket because GCP users aren't authorized to generate buckets using the domain name appspot.com._

Ancak, bu bucket üzerinde okuma & yazma erişimi ile, bucket'ı izleyerek ve her değişiklik (yeni versiyon) yapıldığında yeni versiyonu mümkün olan en hızlı şekilde değiştirerek App Engine versiyonuna bağlı SA'ya ayrıcalık yükseltmesi yapmak mümkündür. Bu şekilde, bu koddan oluşturulan container arka kapılı kodu çalıştıracaktır.

Bahsedilen saldırı birçok farklı şekilde gerçekleştirilebilir, hepsi `staging.<project-id>.appspot.com` bucket'ını izlemekle başlar:

- AppEngine versiyonunun tamamını farklı ve kullanılabilir bir bucket'a yükleyin ve yeni bucket adı ile bunların sha1 hash'lerini içeren bir **`manifest.json` dosyası hazırlayın**. Ardından, bucket içinde yeni bir versiyon oluşturulduğunda sadece `manifest.json` dosyasını değiştirip kötü amaçlı olanı yüklemeniz yeterlidir.
- Kötü amaçlı bağımlılık kodunu kullanacak şekilde değiştirilmiş bir `requirements.txt` sürümü yükleyin ve `manifest.json` dosyasını yeni dosya adı, URL ve hash ile güncelleyin.
- Kötü amaçlı kodu çalıştıracak şekilde değiştirilmiş bir `main.py` veya `app.yaml` dosyası yükleyin ve `manifest.json` dosyasını yeni dosya adı, URL ve hash ile güncelleyin.

**Bu saldırının PoC'unu repo'da bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry**, görüntüleri bucket'lar içinde saklar; eğer bu bucket'lara **yazabiliyorsanız**, daha sonra bu bucket'ların çalıştırıldığı yerlere doğru **lateral hareket edebilmeniz** mümkün olabilir.
- GCR tarafından kullanılan bucket URL'si `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` benzeri olacaktır (üst seviye alt alan adları [burada](https://cloud.google.com/container-registry/docs/pushing-and-pulling) belirtilmiştir).

> [!TIP]
> Bu servis deprecated olduğu için bu saldırı artık kullanışlı değildir. Ayrıca, bu servisin yerine geçen Artifact Registry görüntüleri bucket'larda saklamamaktadır.

## **Referanslar**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
