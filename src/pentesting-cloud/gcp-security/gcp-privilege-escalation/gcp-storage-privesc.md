# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Storage

Temel Bilgiler:

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

Bu izin, **Cloud Storage içinde saklanan dosyaları indirmenize** olanak tanır. Bu, bazı durumlarda **hassas bilgilerin orada saklanması** nedeniyle yetki yükseltmenize olanak sağlayabilir. Ayrıca, bazı GCP hizmetleri bilgilerini bucket'larda saklar:

- **GCP Composer**: Bir Composer Ortamı oluşturduğunuzda, **tüm DAG'ların kodu** bir **bucket** içinde saklanacaktır. Bu görevler, kodlarının içinde ilginç bilgiler içerebilir.
- **GCR (Container Registry)**: Konteynerlerin **görüntüleri** **bucket'larda** saklanır, bu da bucket'ları okuyabiliyorsanız görüntüleri indirebileceğiniz ve **sızıntıları ve/veya kaynak kodunu** arayabileceğiniz anlamına gelir.

### `storage.objects.setIamPolicy`

Bu bölümdeki önceki senaryoları **istismar etme izni** verebilirsiniz.

### **`storage.buckets.setIamPolicy`**

Bu izni kullanarak izinleri nasıl değiştireceğinize dair bir örnek için bu sayfayı kontrol edin:

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage'ın "işletilebilirlik" özelliği, AWS S3 gibi **bulutlar arası etkileşimler** için tasarlanmıştır ve **HMAC anahtarlarının Hizmet Hesapları ve kullanıcılar için oluşturulmasını** içerir. Bir saldırgan, **yükseltilmiş yetkilere sahip bir Hizmet Hesabı için HMAC anahtarı üreterek** bunu istismar edebilir ve böylece **Cloud Storage içinde yetki yükseltebilir**. Kullanıcıya bağlı HMAC anahtarları yalnızca web konsolu aracılığıyla alınabilirken, hem erişim hem de gizli anahtarlar **sürekli erişilebilir** kalır ve potansiyel yedek erişim depolamasına olanak tanır. Öte yandan, Hizmet Hesabı ile bağlantılı HMAC anahtarları API erişimine açıktır, ancak erişim ve gizli anahtarları oluşturulduktan sonra alınamaz, bu da sürekli erişim için bir katman karmaşıklık ekler.
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
Başka bir istismar scripti bu yöntem için [burada](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py) bulunabilir.

## `storage.objects.create`, `storage.objects.delete` = Depolama Yazma izinleri

Bir **nesne oluşturmak** için bir bucket içinde `storage.objects.create` iznine ihtiyacınız var ve [belgelere](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions) göre, mevcut bir nesneyi **değiştirmek** için de `storage.objects.delete` iznine ihtiyacınız var.

Bulut içinde yazma iznine sahip olduğunuz bucket'ların çok **yaygın bir istismar** durumu, eğer **bucket web sunucusu dosyalarını kaydediyorsa**, web uygulaması tarafından kullanılacak **yeni kodlar depolayabilmenizdir**.

### Composer

**Composer**, GCP içinde yönetilen **Apache Airflow**'dur. Birçok ilginç özelliği vardır:

- **GKE kümesi** içinde çalışır, bu nedenle **kümenin kullandığı SA, Composer içinde çalışan kod tarafından erişilebilir**.
- Bir composer ortamının tüm bileşenleri (**DAG'lerin kodu**, eklentiler ve veriler) bir GCP bucket'ında depolanır. Eğer saldırganın buna okuma ve yazma izinleri varsa, bucket'ı izleyebilir ve **herhangi bir DAG oluşturulduğunda veya güncellendiğinde, arka kapılı bir versiyon gönderebilir** böylece composer ortamı depolamadan arka kapılı versiyonu alır.

**Bu saldırının bir PoC'sini repoda bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions kodu Storage'da depolanır ve yeni bir versiyon oluşturulduğunda kod bucket'a yüklenir ve ardından bu koddan yeni bir konteyner oluşturulur. Bu nedenle, **yeni versiyon oluşturulmadan önce kodu üzerine yazmak, bulut fonksiyonunun rastgele kod çalıştırmasını sağlamak için mümkündür**.

**Bu saldırının bir PoC'sini repoda bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine versiyonları, `staging.<project-id>.appspot.com` formatında bir bucket içinde bazı veriler oluşturur. Bu bucket içinde, her AppEngine uygulama versiyonu için bir klasör içerecek `ae` adında bir klasör bulmak mümkündür ve bu klasörlerin içinde `manifest.json` dosyasını bulmak mümkündür. Bu dosya, belirli versiyonu oluşturmak için kullanılacak tüm dosyaların bulunduğu bir json içerir. Ayrıca, **dosyaların gerçek adlarını, GCP bucket'ındaki URL'lerini (bucket içindeki dosyalar adlarını sha1 hash'leri ile değiştirmiştir) ve her dosyanın sha1 hash'ini bulmak mümkündür.**

_Bu bucket'ı önceden ele geçirmenin mümkün olmadığını unutmayın çünkü GCP kullanıcıları appspot.com alan adını kullanarak bucket oluşturmak için yetkilendirilmemiştir._

Ancak, bu bucket üzerinde okuma ve yazma erişimi ile, bucket'ı izleyerek ve herhangi bir değişiklik yapıldığında (yeni versiyon), yeni versiyonu mümkün olan en hızlı şekilde değiştirmek suretiyle App Engine versiyonuna bağlı SA'ya yetki yükseltmek mümkündür. Bu şekilde, bu koddan oluşturulan konteyner arka kapılı kodu çalıştıracaktır.

Bahsedilen saldırı birçok farklı şekilde gerçekleştirilebilir, hepsi `staging.<project-id>.appspot.com` bucket'ını izlemekle başlar:

- AppEngine versiyonunun tamamını yeni bir bucket'a yükleyin ve **yeni bucket adı ve sha1 hash'leri ile bir `manifest.json` dosyası hazırlayın**. Ardından, bucket içinde yeni bir versiyon oluşturulduğunda, sadece `manifest.json` dosyasını değiştirip kötü niyetli olanı yüklemeniz yeterlidir.
- **Kötü niyetli bağımlılık kodunu kullanacak** değiştirilmiş bir `requirements.txt` versiyonu yükleyin ve `manifest.json` dosyasını yeni dosya adı, URL ve hash ile güncelleyin.
- **Kötü niyetli kodu çalıştıracak** değiştirilmiş bir `main.py` veya `app.yaml` dosyası yükleyin ve `manifest.json` dosyasını yeni dosya adı, URL ve hash ile güncelleyin.

**Bu saldırının bir PoC'sini repoda bulabilirsiniz:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry**, görüntüleri bucket'larda depolar, eğer bu **bucket'lara yazabiliyorsanız** daha sonra bu bucket'ların çalıştığı yere **yanal hareket edebilirsiniz.**
- GCR tarafından kullanılan bucket, `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` benzeri bir URL'ye sahip olacaktır (En üst düzey alt alan adları [burada](https://cloud.google.com/container-registry/docs/pushing-and-pulling) belirtilmiştir).

> [!TIP]
> Bu hizmet kullanımdan kaldırılmıştır, bu nedenle bu saldırı artık işe yaramaz. Ayrıca, bu hizmetin yerini alan Artifact Registry, görüntüleri bucket'larda depolamaz.

## **Referanslar**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
