# GCP - Storage Privesc

{{#include ../../../banners/hacktricks-training.md}}

## 存储

基本信息：

{{#ref}}
../gcp-services/gcp-storage-enum.md
{{#endref}}

### `storage.objects.get`

该权限允许你**下载保存在 Cloud Storage 中的文件**。这可能让你提升权限，因为在某些情况下**敏感信息就保存在那里**。此外，一些 GCP 服务会将其信息存放在 buckets 中：

- **GCP Composer**：当你创建一个 Composer Environment 时，所有 DAGs 的**代码**会被保存到一个 **bucket** 中。这些任务的代码中可能包含有价值的信息。
- **GCR (Container Registry)**：容器的**镜像**存储在 **buckets** 中，这意味着如果你能读取这些 buckets，就可以下载镜像并**搜索 leaks 和/或 源代码**。

### `storage.objects.setIamPolicy`

该权限可以让你**滥用本节之前列出的任何情形**。

### **`storage.buckets.setIamPolicy`**

关于如何使用该权限修改权限的示例，请查看此页面：

{{#ref}}
../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md
{{#endref}}

### `storage.hmacKeys.create`

Cloud Storage 的 “interoperability” 功能用于像 AWS S3 这样的**跨云交互**，涉及为 Service Accounts 和用户**创建 HMAC keys**。攻击者可以通过**为具有提升权限的 Service Account 生成 HMAC key**来滥用此功能，从而**在 Cloud Storage 中提升权限**。用户关联的 HMAC keys 只能通过 web 控制台检索，但 access 和 secret keys 在检索后仍然**持续可用**，可用于备份或持久访问。相反，关联到 Service Account 的 HMAC keys 可通过 API 使用，但其 access 和 secret keys 在创建后无法再次检索，这使得维持持续访问变得更复杂。

<details><summary>Create and use HMAC key for privilege escalation</summary>
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
</details>

Another exploit script for this method can be found [here](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

### `storage.objects.create`, `storage.objects.delete` = Storage Write permissions

为了在 bucket 内**创建新对象**，你需要 `storage.objects.create`，并且根据[文档](https://cloud.google.com/storage/docs/access-control/iam-permissions#object_permissions)，要**修改**已有对象还需要 `storage.objects.delete`。

在可以写入云存储的 bucket 中，一种非常**常见的利用方式**是当这个**bucket 存放着 web 服务器文件**时，攻击者可能能**存放新的代码**，被 web 应用使用。

### Composer

**Composer** 是在 GCP 内托管的 **Apache Airflow**。它有几个值得注意的特性：

- 它运行在 **GKE cluster** 内，所以集群使用的 **SA 对代码是可访问的**，运行在 Composer 内的代码可以访问该 SA。
- composer environment 的所有组件（**DAGs 的代码**、plugins 和数据）都存储在一个 GCP bucket 里。如果攻击者对其有读写权限，就可以监控该 bucket，**每当某个 DAG 被创建或更新时，提交一个带后门的版本**，使 composer environment 从 storage 获取到带后门的版本。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

- Cloud Functions 的代码存储在 Storage 中，每当创建新版本时，代码会被推送到 bucket，然后从这些代码构建新的容器。因此，**在新版本构建之前覆盖代码可以让 cloud function 执行任意代码**。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine 的版本会在名为 `staging.<project-id>.appspot.com` 的 bucket 中生成一些数据。该 bucket 内通常有一个名为 `ae` 的文件夹，里面会按 AppEngine 应用的每个版本各有一个文件夹，在这些文件夹中可以找到 `manifest.json` 文件。该文件包含一个 json，列出创建特定版本必须使用的所有文件。此外，还可以找到**文件的真实名称、它们在 GCP bucket 中的 URL（bucket 内文件会以其 sha1 hash 改名）以及每个文件的 sha1 hash。**

_注意：无法事先 takeover 该 bucket，因为 GCP 用户无权使用 appspot.com 域名创建 bucket。_

但是，若对该 bucket 具有读写权限，可以通过监控 bucket 在有变更（新版本）发生时尽快修改新版本，从而提升到附加在 App Engine 版本上的 SA 权限。这样由这些代码创建的容器就会执行带后门的代码。

上述攻击可以通过多种方式实现，所有方法都从监控 `staging.<project-id>.appspot.com` bucket 开始：

- 将完整的新 AppEngine 版本代码上传到另一个可用的 bucket，并准备一个带有新 bucket 名称和文件 sha1 hashes 的 **`manifest.json`**。然后，当原 bucket 中创建新版本时，只需修改 `manifest.json` 并上传恶意版本即可。
- 上传一个被修改的 `requirements.txt`，使其使用恶意依赖代码并更新 `manifest.json`，包括新文件名、URL 以及其 hash。
- 上传被修改的 `main.py` 或 `app.yaml`，使其执行恶意代码，并更新 `manifest.json`，包括新文件名、URL 以及其 hash。

**You can find a PoC of this attack in the repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

- **Google Container Registry** 将镜像存储在 buckets 中，如果你能**写入这些 buckets**，可能能够**横向移动到那些运行这些镜像的地方**。
- GCR 使用的 bucket URL 类似于 `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com`（顶级子域在[此处](https://cloud.google.com/container-registry/docs/pushing-and-pulling)有说明）。

> [!TIP]
> 该服务已被弃用，因此此类攻击现在不再有用。此外，作为替代的 Artifact Registry 并不将镜像存储在 buckets 中。

## **References**

- [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{{#include ../../../banners/hacktricks-training.md}}
