# GCP - Network Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## Estado Inicial

Em ambos os writeups onde essa técnica é especificada, os atacantes conseguiram obter acesso **root** dentro de um container **Docker** gerenciado pela GCP com acesso à rede do host (e as capacidades **`CAP_NET_ADMIN`** e **`CAP_NET_RAW`**).

## Explicação do Ataque

Em uma instância do Google Compute Engine, a inspeção regular do tráfego de rede revela numerosas **requisições HTTP em texto claro** ao **metadata instance** em `169.254.169.254`. O [**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent), um serviço open-source, frequentemente faz esse tipo de requisição.

Esse agente foi projetado para **monitorar mudanças no metadata**. Notavelmente, o metadata inclui um **campo para chaves públicas SSH**. Quando uma nova chave pública SSH é adicionada ao metadata, o agente automaticamente a **autoriza** no arquivo `.authorized_key`. Ele também pode **criar um novo usuário** e adicioná-lo aos **sudoers** se necessário.

O agente monitora mudanças enviando uma requisição para **recuperar todos os valores do metadata recursivamente** (`GET /computeMetadata/v1/?recursive=true`). Essa requisição é desenhada para provocar que o metadata server envie uma resposta somente se houver qualquer mudança no metadata desde a última recuperação, identificada por um Etag (`wait_for_change=true&last_etag=`). Adicionalmente, um parâmetro de **timeout** (`timeout_sec=`) é incluído. Se nenhuma mudança ocorrer dentro do timeout especificado, o servidor responde com os **valores inalterados**.

Esse processo permite que o **IMDS** (Instance Metadata Service) responda após **60 segundos** se nenhuma mudança de configuração tiver ocorrido, criando uma potencial **janela para injetar uma resposta de configuração falsa** para o guest agent.

Um atacante poderia explorar isso realizando um **Man-in-the-Middle (MitM) attack**, forjando a resposta do servidor IMDS e **inserindo uma nova chave pública**. Isso poderia permitir acesso SSH não autorizado ao host.

### Técnica de Escape

Enquanto ARP spoofing é ineficaz nas redes do Google Compute Engine, uma [**versão modificada do rshijack**](https://github.com/ezequielpereira/rshijack) desenvolvida por [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html) pode ser usada para injeção de pacotes na comunicação para injetar o usuário SSH.

Essa versão do rshijack permite informar os números ACK e SEQ como argumentos de linha de comando, facilitando a falsificação de uma resposta antes da resposta real do Metadata server. Adicionalmente, um [**pequeno Shell script**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh) é usado para retornar um **payload especialmente forjado**. Esse payload aciona o Google Guest Agent para **criar um usuário `wouter`** com uma chave pública especificada no arquivo `.authorized_keys`.

O script usa o mesmo ETag para evitar que o Metadata server notifique imediatamente o Google Guest Agent sobre valores de metadata diferentes, atrasando assim a resposta.

Para executar o spoofing, os seguintes passos são necessários:

1. **Monitorar requisições ao servidor de Metadata** usando **tcpdump**:

<details>
<summary>Monitorar requisições ao servidor de metadata com tcpdump</summary>
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
</details>

Procure por uma linha semelhante a:

<details>
<summary>Exemplo de linha de saída do tcpdump</summary>
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
</details>

2. Enviar os metadados falsos com o ETAG correto para rshijack:

<details>
<summary>Enviar metadados falsos e conectar via SSH ao host</summary>
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
</details>

Esta etapa autoriza a chave pública, permitindo a conexão SSH com a chave privada correspondente.

## Referências

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
