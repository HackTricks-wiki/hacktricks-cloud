# GCP - Network Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## Aanvangstoestand

In beide writeups waar hierdie tegniek gespesifiseer word, het die aanvallers daarin geslaag om **root** toegang te kry binne 'n **Docker** kontenaar wat deur GCP bestuur is met toegang tot die host-netwerk (en die vermoëns **`CAP_NET_ADMIN`** en **`CAP_NET_RAW`**).

## Verduideliking van die aanval

Op 'n Google Compute Engine instansie openbaar gereelde inspeksie van netwerkverkeer talle **onversleutelde HTTP-versoeke** na die **metadata-instansie** by `169.254.169.254`. Die [**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent), 'n open-source diens, maak dikwels sulke versoeke.

Hierdie agent is ontwerp om **veranderinge in die metadata dop te hou**. Noemenswaardig is dat die metadata 'n **veld vir SSH openbare sleutels** insluit. Wanneer 'n nuwe openbare SSH-sleutel by die metadata gevoeg word, **gisautoriseer** die agent dit outomaties in die `.authorized_key` lêer. Dit kan ook **'n nuwe gebruiker skep** en hulle indien nodig by **sudoers** voeg.

Die agent monitor veranderinge deur 'n versoek te stuur om alle metadata-waardes rekursief op te haal (`GET /computeMetadata/v1/?recursive=true`). Hierdie versoek is ontwerp om die metadata-bediener te laat reageer slegs as daar enige verandering in die metadata sedert die laaste opvraging was, geïdentifiseer deur 'n Etag (`wait_for_change=true&last_etag=`). Bykomend is 'n **timeout** parameter (`timeout_sec=`) ingesluit. Indien geen verandering binne die gespesifiseerde timeout plaasvind nie, antwoord die bediener met die **onveranderde waardes**.

Hierdie proses laat die IMDS (Instance Metadata Service) toe om ná **60 sekondes** te reageer as geen konfigurasiewijziging plaasgevind het nie, wat 'n potensiële **venster skep om 'n vals konfigurasie-antwoord in te spuit** aan die guest agent.

'n Aanvaller kan dit uitbuit deur 'n Man-in-the-Middle (MitM) aanval uit te voer, die reaksie van die IMDS-bediener te spooff, en 'n nuwe openbare sleutel in te voeg. Dit kan ongemagtigde SSH-toegang tot die host moontlik maak.

### Ontsnaptegniek

Terwyl ARP spoofing op Google Compute Engine netwerke ondoeltreffend is, kan 'n [**gewysigde weergawe van rshijack**](https://github.com/ezequielpereira/rshijack) ontwikkel deur [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html) gebruik word vir pakketinspuiting in die kommunikasie om die SSH-gebruiker in te spuit.

Hierdie weergawe van rshijack laat toe om die ACK- en SEQ-nommers as opdragreëlargumente in te voer, wat die spoofing van 'n reaksie voor die werklike Metadata-bediener-reaksie vergemaklik. Bykomend word 'n [**klein Shell script**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh) gebruik om 'n **spesiaal saamgestelde payload** terug te gee. Hierdie payload veroorsaak dat die Google Guest Agent 'n gebruiker `wouter` skep met 'n gespesifiseerde publieke sleutel in die `.authorized_keys` lêer.

Die script gebruik dieselfde ETag om te verhoed dat die Metadata-bediener die Google Guest Agent onmiddellik in kennis stel van verskillende metadata-waardes, en stel sodoende die reaksie uit.

Om die spoofing uit te voer, is die volgende stappe nodig:

1. Hou versoeke na die Metadata-bediener dop met tcpdump:

<details>
<summary>Hou versoeke na die metadata-bediener dop met tcpdump</summary>
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
</details>

Soek na 'n reël soortgelyk aan:

<details>
<summary>Voorbeeld van 'n tcpdump-uitsetreël</summary>
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
</details>

2. Stuur die vals metadata met die korrekte ETAG na rshijack:

<details>
<summary>Stuur vals metadata en SSH na die gasheer</summary>
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
</details>

Hierdie stap autoriseer die public key, wat 'n SSH-verbinding met die ooreenstemmende private key moontlik maak.

## Verwysings

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
