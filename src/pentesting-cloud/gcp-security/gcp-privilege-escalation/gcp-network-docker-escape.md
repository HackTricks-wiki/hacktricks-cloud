# GCP - Network Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## Initial State

在这两篇描述该技术的文章中，攻击者成功获得了在 GCP 管理的 **Docker** 容器内的 **root** 访问权限，并能够访问主机网络（以及 **`CAP_NET_ADMIN`** 和 **`CAP_NET_RAW`** 权限）。

## Attack Explanation

在 Google Compute Engine 实例上，定期检查网络流量会发现大量对 **元数据实例** 的 **明文 HTTP 请求**，地址为 `169.254.169.254`。 [**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent) 是一个开源服务，频繁发出此类请求。

该代理旨在 **监控元数据的变化**。值得注意的是，元数据中包含 **SSH 公钥字段**。当新的公钥被添加到元数据时，代理会自动在 `.authorized_key` 文件中 **授权** 它。如果需要，它还可以 **创建新用户** 并将其添加到 **sudoers**。

该代理通过发送请求 **递归检索所有元数据值** (`GET /computeMetadata/v1/?recursive=true`) 来监控变化。该请求旨在促使元数据服务器仅在自上次检索以来元数据发生变化时发送响应，通过 Etag 进行识别 (`wait_for_change=true&last_etag=`)。此外，还包含一个 **超时** 参数 (`timeout_sec=`)。如果在指定的超时时间内没有发生变化，服务器将以 **未更改的值** 响应。

这个过程允许 **IMDS**（实例元数据服务）在 **60 秒** 后响应，如果没有配置更改，创建一个潜在的 **注入假配置响应** 的窗口给来宾代理。

攻击者可以通过执行 **中间人攻击（MitM）** 来利用这一点，伪造来自 IMDS 服务器的响应并 **插入新的公钥**。这可能使未经授权的 SSH 访问主机成为可能。

### Escape Technique

虽然 ARP 欺骗在 Google Compute Engine 网络上无效，但 [**修改版的 rshijack**](https://github.com/ezequielpereira/rshijack) 由 [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html) 开发，可以用于在通信中进行数据包注入，以注入 SSH 用户。

这个版本的 rshijack 允许将 ACK 和 SEQ 数字作为命令行参数输入，从而在真实的元数据服务器响应之前伪造响应。此外，使用 [**小 Shell 脚本**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh) 返回 **特制的有效负载**。该有效负载触发 Google Guest Agent **创建一个名为 `wouter` 的用户**，并在 `.authorized_keys` 文件中指定公钥。

该脚本使用相同的 ETag，以防止元数据服务器立即通知 Google Guest Agent 不同的元数据值，从而延迟响应。

要执行伪造，必须进行以下步骤：

1. **使用 tcpdump 监控对元数据服务器的请求**：
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
请寻找类似于：
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
2. 将伪造的元数据与正确的 ETAG 发送到 rshijack:
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
此步骤授权公钥，使得可以使用相应的私钥进行SSH连接。

## 参考

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
