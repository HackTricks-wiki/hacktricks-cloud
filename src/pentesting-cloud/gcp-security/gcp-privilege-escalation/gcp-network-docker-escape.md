# GCP - Network Docker Escape

{{#include ../../../banners/hacktricks-training.md}}

## 初始状态

在两个描述此技术的 writeups 中，攻击者设法在由 GCP 管理、具有主机网络访问权限（以及能力 **`CAP_NET_ADMIN`** 和 **`CAP_NET_RAW`**）的 **Docker** 容器内获得了 **root** 访问权限。

## 攻击说明

在 Google Compute Engine 实例上，常规的网络流量检查会发现大量针对元数据实例 `169.254.169.254` 的明文 **HTTP 请求**。[**Google Guest Agent**](https://github.com/GoogleCloudPlatform/guest-agent)（开源服务）经常发出此类请求。

该 agent 旨在**监控元数据的更改**。值得注意的是，元数据包括一个用于 **SSH 公钥** 的字段。当新的公钥被添加到元数据中时，agent 会自动在 `.authorized_key` 文件中**授权**它。根据需要，它还可能**创建新用户**并将其添加到 **sudoers**。

agent 通过发送请求来检索**所有元数据值（递归）**（`GET /computeMetadata/v1/?recursive=true`）以监控更改。该请求被设计为仅在自上次检索以来元数据有更改时才让元数据服务器返回响应，这通过 Etag 来标识（`wait_for_change=true&last_etag=`）。此外，还包含一个 **timeout** 参数（`timeout_sec=`）。如果在指定的超时时间内没有发生更改，服务器会返回**未更改的值**。

该过程允许 IMDS（Instance Metadata Service）在没有配置更改的情况下在 **60 seconds** 后响应，从而产生一个可能的窗口，用以向 guest agent 注入伪造的配置响应。

攻击者可以通过实施中间人（Man-in-the-Middle, MitM）攻击来利用这一点，伪造来自 IMDS 服务器的响应并插入新的公钥。这样可能使攻击者获得对主机的未授权 SSH 访问。

### 逃逸技术

虽然 **ARP spoofing** 在 Google Compute Engine 网络上无效，但可以使用 [**modified version of rshijack**](https://github.com/ezequielpereira/rshijack)（由 [**Ezequiel**](https://www.ezequiel.tech/2020/08/dropping-shell-in.html) 开发）对通信进行包注入，以注入 SSH 用户。

该版本的 rshijack 允许将 ACK 和 SEQ 数值作为命令行参数输入，从而便于在真实 Metadata 服务器响应到达之前伪造响应。此外，使用了一个[**小型 Shell 脚本**](https://gist.github.com/ezequielpereira/914c2aae463409e785071213b059f96c#file-fakedata-sh)来返回**特制的 payload**。该 payload 会触发 Google Guest Agent **创建用户 `wouter`**，并在 `.authorized_keys` 文件中添加指定的公钥。

该脚本使用相同的 ETag 以防止 Metadata 服务器立即向 Google Guest Agent 通知不同的元数据值，从而延迟响应。

要执行该伪造，需进行以下步骤：

1. 使用 **tcpdump** 监控到 Metadata 服务器的请求：

<details>
<summary>Monitor metadata server requests with tcpdump</summary>
```bash
tcpdump -S -i eth0 'host 169.254.169.254 and port 80' &
```
</details>

查找类似于以下的行：

<details>
<summary>tcpdump 示例输出行</summary>
```
<TIME> IP <LOCAL_IP>.<PORT> > 169.254.169.254.80: Flags [P.], seq <NUM>:<TARGET_ACK>, ack <TARGET_SEQ>, win <NUM>, length <NUM>: HTTP: GET /computeMetadata/v1/?timeout_sec=<SECONDS>&last_etag=<ETAG>&alt=json&recursive=True&wait_for_change=True HTTP/1.1
```
</details>

2. 将伪造的 metadata 数据（带正确的 ETAG）发送到 rshijack：

<details>
<summary>发送伪造的 metadata 并通过 SSH 连接主机</summary>
```bash
fakeData.sh <ETAG> | rshijack -q eth0 169.254.169.254:80 <LOCAL_IP>:<PORT> <TARGET_SEQ> <TARGET_ACK>; ssh -i id_rsa -o StrictHostKeyChecking=no wouter@localhost
```
</details>

这一步授权了公钥，从而允许使用对应的私钥进行 SSH 连接。

## 参考资料

- [https://www.ezequiel.tech/2020/08/dropping-shell-in.html](https://www.ezequiel.tech/2020/08/dropping-shell-in.html)
- [https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)

{{#include ../../../banners/hacktricks-training.md}}
