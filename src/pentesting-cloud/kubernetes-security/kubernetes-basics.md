# Kubernetes Basics

## Kubernetes Basics

{{#include ../../banners/hacktricks-training.md}}

**Oryginalnym autorem tej strony jest** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(przeczytaj jego oryginalny post** [**tutaj**](https://sickrov.github.io)**)**

## Architektura i podstawy

### Co robi Kubernetes?

- UmoÅ¼liwia uruchamianie kontenerÃ³w w silniku kontenerowym.
- Harmonogram pozwala na efektywne planowanie misji kontenerÃ³w.
- Utrzymuje kontenery przy Å¼yciu.
- UmoÅ¼liwia komunikacjÄ™ miÄ™dzy kontenerami.
- UmoÅ¼liwia techniki wdraÅ¼ania.
- ObsÅ‚uguje wolumeny informacji.

### Architektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **WÄ™zeÅ‚**: system operacyjny z podami.
- **Pod**: opakowanie wokÃ³Å‚ kontenera lub wielu kontenerÃ³w. Pod powinien zawieraÄ‡ tylko jednÄ… aplikacjÄ™ (zazwyczaj pod uruchamia tylko 1 kontener). Pod to sposÃ³b, w jaki Kubernetes abstrahuje technologiÄ™ kontenerowÄ….
- **UsÅ‚uga**: KaÅ¼dy pod ma 1 wewnÄ™trzny **adres IP** z wewnÄ™trznego zakresu wÄ™zÅ‚a. MoÅ¼e byÄ‡ rÃ³wnieÅ¼ udostÄ™pniony za poÅ›rednictwem usÅ‚ugi. **UsÅ‚uga ma rÃ³wnieÅ¼ adres IP** i jej celem jest utrzymanie komunikacji miÄ™dzy podami, wiÄ™c jeÅ›li jeden z nich zginie, **nowa zastÄ™pcza** (z innym wewnÄ™trznym IP) **bÄ™dzie dostÄ™pna** pod **tym samym adresem IP usÅ‚ugi**. MoÅ¼e byÄ‡ skonfigurowana jako wewnÄ™trzna lub zewnÄ™trzna. UsÅ‚uga dziaÅ‚a rÃ³wnieÅ¼ jako **load balancer, gdy 2 pody sÄ… poÅ‚Ä…czone** z tÄ… samÄ… usÅ‚ugÄ….\
Gdy **usÅ‚uga** jest **tworzona**, moÅ¼na znaleÅºÄ‡ punkty koÅ„cowe kaÅ¼dej usÅ‚ugi uruchamiajÄ…c `kubectl get endpoints`
- **Kubelet**: GÅ‚Ã³wny agent wÄ™zÅ‚a. Komponent, ktÃ³ry nawiÄ…zuje komunikacjÄ™ miÄ™dzy wÄ™zÅ‚em a kubectl, i moÅ¼e uruchamiaÄ‡ tylko pody (przez API server). Kubelet nie zarzÄ…dza kontenerami, ktÃ³re nie zostaÅ‚y utworzone przez Kubernetes.
- **Kube-proxy**: jest usÅ‚ugÄ… odpowiedzialnÄ… za komunikacjÄ™ (usÅ‚ugi) miÄ™dzy apiserver a wÄ™zÅ‚em. PodstawÄ… jest IPtables dla wÄ™zÅ‚Ã³w. Najbardziej doÅ›wiadczeni uÅ¼ytkownicy mogÄ… zainstalowaÄ‡ inne kube-proxy od innych dostawcÃ³w.
- **Kontener sidecar**: Kontenery sidecar to kontenery, ktÃ³re powinny dziaÅ‚aÄ‡ razem z gÅ‚Ã³wnym kontenerem w podzie. Wzorzec sidecar rozszerza i poprawia funkcjonalnoÅ›Ä‡ obecnych kontenerÃ³w bez ich zmiany. Obecnie wiemy, Å¼e uÅ¼ywamy technologii kontenerowej do opakowania wszystkich zaleÅ¼noÅ›ci, aby aplikacja mogÅ‚a dziaÅ‚aÄ‡ wszÄ™dzie. Kontener robi tylko jednÄ… rzecz i robi to bardzo dobrze.
- **Proces master:**
- **Api Server:** To sposÃ³b, w jaki uÅ¼ytkownicy i pody komunikujÄ… siÄ™ z procesem master. Tylko uwierzytelnione Å¼Ä…dania powinny byÄ‡ dozwolone.
- **Harmonogram**: Harmonogram odnosi siÄ™ do zapewnienia, Å¼e pody sÄ… dopasowane do wÄ™zÅ‚Ã³w, aby Kubelet mÃ³gÅ‚ je uruchomiÄ‡. Ma wystarczajÄ…cÄ… inteligencjÄ™, aby zdecydowaÄ‡, ktÃ³ry wÄ™zeÅ‚ ma wiÄ™cej dostÄ™pnych zasobÃ³w, a nastÄ™pnie przypisaÄ‡ nowy pod do niego. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e harmonogram nie uruchamia nowych podÃ³w, tylko komunikuje siÄ™ z procesem Kubelet dziaÅ‚ajÄ…cym wewnÄ…trz wÄ™zÅ‚a, ktÃ³ry uruchomi nowy pod.
- **Kube Controller manager**: Sprawdza zasoby, takie jak zestawy replik lub wdroÅ¼enia, aby sprawdziÄ‡, czy na przykÅ‚ad dziaÅ‚a odpowiednia liczba podÃ³w lub wÄ™zÅ‚Ã³w. W przypadku braku poda skomunikuje siÄ™ z harmonogramem, aby uruchomiÄ‡ nowy. Kontroluje replikacjÄ™, tokeny i usÅ‚ugi konta do API.
- **etcd**: Przechowywanie danych, trwaÅ‚e, spÃ³jne i rozproszone. Jest bazÄ… danych Kubernetes i przechowuje stan klastrÃ³w (kaÅ¼da zmiana jest tutaj rejestrowana). Komponenty, takie jak Harmonogram czy MenedÅ¼er Kontrolera, polegajÄ… na tych danych, aby wiedzieÄ‡, jakie zmiany zaszÅ‚y (dostÄ™pne zasoby wÄ™zÅ‚Ã³w, liczba dziaÅ‚ajÄ…cych podÃ³w...)
- **Cloud controller manager**: Jest to specyficzny kontroler do kontroli przepÅ‚ywu i aplikacji, tzn. jeÅ›li masz klastry w AWS lub OpenStack.

NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e poniewaÅ¼ moÅ¼e byÄ‡ kilka wÄ™zÅ‚Ã³w (uruchamiajÄ…cych kilka podÃ³w), moÅ¼e byÄ‡ rÃ³wnieÅ¼ kilka procesÃ³w master, ktÃ³rych dostÄ™p do Api server jest rÃ³wnowaÅ¼ony obciÄ…Å¼eniem, a ich etcd synchronizowane.

**Wolumeny:**

Gdy pod tworzy dane, ktÃ³re nie powinny zostaÄ‡ utracone, gdy pod zniknie, powinny byÄ‡ przechowywane w fizycznym wolumenie. **Kubernetes pozwala na podÅ‚Ä…czenie wolumenu do poda, aby zachowaÄ‡ dane**. Wolumen moÅ¼e znajdowaÄ‡ siÄ™ na lokalnej maszynie lub w **zdalnym magazynie**. JeÅ›li uruchamiasz pody na rÃ³Å¼nych fizycznych wÄ™zÅ‚ach, powinieneÅ› uÅ¼yÄ‡ zdalnego magazynu, aby wszystkie pody mogÅ‚y uzyskaÄ‡ do niego dostÄ™p.

**Inne konfiguracje:**

- **ConfigMap**: MoÅ¼esz skonfigurowaÄ‡ **URL** do uzyskiwania dostÄ™pu do usÅ‚ug. Pod uzyska dane stÄ…d, aby wiedzieÄ‡, jak komunikowaÄ‡ siÄ™ z pozostaÅ‚ymi usÅ‚ugami (podami). NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e to nie jest zalecane miejsce do przechowywania poÅ›wiadczeÅ„!
- **Secret**: To miejsce do **przechowywania tajnych danych** takich jak hasÅ‚a, klucze API... zakodowane w B64. Pod bÄ™dzie mÃ³gÅ‚ uzyskaÄ‡ dostÄ™p do tych danych, aby uÅ¼yÄ‡ wymaganych poÅ›wiadczeÅ„.
- **WdroÅ¼enia**: To tutaj wskazuje siÄ™ komponenty, ktÃ³re majÄ… byÄ‡ uruchamiane przez Kubernetes. UÅ¼ytkownik zazwyczaj nie pracuje bezpoÅ›rednio z podami, pody sÄ… abstrakowane w **ReplicaSets** (liczba tych samych replikowanych podÃ³w), ktÃ³re sÄ… uruchamiane za pomocÄ… wdroÅ¼eÅ„. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e wdroÅ¼enia sÄ… dla aplikacji **bezstanowych**. Minimalna konfiguracja dla wdroÅ¼enia to nazwa i obraz do uruchomienia.
- **StatefulSet**: Ten komponent jest przeznaczony specjalnie dla aplikacji takich jak **bazy danych**, ktÃ³re muszÄ… **uzyskiwaÄ‡ dostÄ™p do tego samego magazynu**.
- **Ingress**: To konfiguracja, ktÃ³ra jest uÅ¼ywana do **udostÄ™pnienia aplikacji publicznie za pomocÄ… URL**. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e moÅ¼na to rÃ³wnieÅ¼ zrobiÄ‡ za pomocÄ… zewnÄ™trznych usÅ‚ug, ale to jest poprawny sposÃ³b na udostÄ™pnienie aplikacji.
- JeÅ›li wdroÅ¼ysz Ingress, bÄ™dziesz musiaÅ‚ utworzyÄ‡ **Ingress Controllers**. Kontroler Ingress to **pod**, ktÃ³ry bÄ™dzie punktem koÅ„cowym, ktÃ³ry otrzyma Å¼Ä…dania, sprawdzi je i zrÃ³wnowaÅ¼y obciÄ…Å¼enie do usÅ‚ug. Kontroler ingress **wyÅ›le Å¼Ä…danie na podstawie skonfigurowanych reguÅ‚ ingress**. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e reguÅ‚y ingress mogÄ… wskazywaÄ‡ na rÃ³Å¼ne Å›cieÅ¼ki lub nawet subdomeny do rÃ³Å¼nych wewnÄ™trznych usÅ‚ug Kubernetes.
- LepszÄ… praktykÄ… bezpieczeÅ„stwa byÅ‚oby uÅ¼ycie chmurowego load balancera lub serwera proxy jako punktu wejÅ›cia, aby Å¼adna czÄ™Å›Ä‡ klastra Kubernetes nie byÅ‚a wystawiona.
- Gdy otrzymane zostanie Å¼Ä…danie, ktÃ³re nie pasuje do Å¼adnej reguÅ‚y ingress, kontroler ingress skieruje je do "**DomyÅ›lnego backendu**". MoÅ¼esz `describe` kontroler ingress, aby uzyskaÄ‡ adres tego parametru.
- `minikube addons enable ingress`

### Infrastruktura PKI - Certyfikacja CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA jest zaufanym korzeniem dla wszystkich certyfikatÃ³w w klastrze.
- UmoÅ¼liwia komponentom wzajemnÄ… weryfikacjÄ™.
- Wszystkie certyfikaty klastra sÄ… podpisane przez CA.
- ETCd ma swÃ³j wÅ‚asny certyfikat.
- typy:
- certyfikat apiserver.
- certyfikat kubelet.
- certyfikat harmonogramu.

## Podstawowe dziaÅ‚ania

### Minikube

**Minikube** moÅ¼e byÄ‡ uÅ¼ywany do przeprowadzania kilku **szybkich testÃ³w** na Kubernetes bez potrzeby wdraÅ¼ania caÅ‚ego Å›rodowiska Kubernetes. Uruchomi **procesy master i wÄ™zÅ‚a na jednej maszynie**. Minikube uÅ¼yje virtualbox do uruchomienia wÄ™zÅ‚a. Zobacz [**tutaj, jak go zainstalowaÄ‡**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Podstawy Kubectl

**`Kubectl`** to narzÄ™dzie wiersza poleceÅ„ dla klastrÃ³w kubernetes. Komunikuje siÄ™ z serwerem Api procesu gÅ‚Ã³wnego, aby wykonywaÄ‡ dziaÅ‚ania w kubernetes lub aby Å¼Ä…daÄ‡ danych.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Panel sterowania pozwala Å‚atwiej zobaczyÄ‡, co uruchamia minikube, moÅ¼esz znaleÅºÄ‡ URL do jego dostÄ™pu w:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### PrzykÅ‚ady plikÃ³w konfiguracyjnych YAML

KaÅ¼dy plik konfiguracyjny ma 3 czÄ™Å›ci: **metadane**, **specyfikacja** (co naleÅ¼y uruchomiÄ‡), **status** (poÅ¼Ä…dany stan).\
WewnÄ…trz specyfikacji pliku konfiguracyjnego wdroÅ¼enia moÅ¼na znaleÅºÄ‡ szablon z nowÄ… strukturÄ… konfiguracyjnÄ… definiujÄ…cÄ… obraz do uruchomienia:

**PrzykÅ‚ad WdroÅ¼enia + UsÅ‚ugi zadeklarowanej w tym samym pliku konfiguracyjnym (z** [**tutaj**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

PoniewaÅ¼ usÅ‚uga zazwyczaj jest zwiÄ…zana z jednym wdroÅ¼eniem, moÅ¼liwe jest zadeklarowanie obu w tym samym pliku konfiguracyjnym (usÅ‚uga zadeklarowana w tej konfiguracji jest dostÄ™pna tylko wewnÄ™trznie):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**PrzykÅ‚ad konfiguracji usÅ‚ugi zewnÄ™trznej**

Ta usÅ‚uga bÄ™dzie dostÄ™pna zewnÄ™trznie (sprawdÅº atrybuty `nodePort` i `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> To jest przydatne do testowania, ale w produkcji powinieneÅ› mieÄ‡ tylko usÅ‚ugi wewnÄ™trzne i Ingress, aby udostÄ™pniÄ‡ aplikacjÄ™.

**PrzykÅ‚ad pliku konfiguracyjnego Ingress**

To udostÄ™pni aplikacjÄ™ pod adresem `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**PrzykÅ‚ad pliku konfiguracyjnego sekretÃ³w**

ZauwaÅ¼, Å¼e hasÅ‚a sÄ… zakodowane w B64 (co nie jest bezpieczne!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**PrzykÅ‚ad ConfigMap**

A **ConfigMap** to konfiguracja, ktÃ³ra jest przekazywana do podÃ³w, aby wiedziaÅ‚y, jak lokalizowaÄ‡ i uzyskiwaÄ‡ dostÄ™p do innych usÅ‚ug. W tym przypadku kaÅ¼dy pod bÄ™dzie wiedziaÅ‚, Å¼e nazwa `mongodb-service` jest adresem poda, z ktÃ³rym mogÄ… siÄ™ komunikowaÄ‡ (ten pod bÄ™dzie wykonywaÅ‚ mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
NastÄ™pnie, wewnÄ…trz **deployment config** ten adres moÅ¼na okreÅ›liÄ‡ w nastÄ™pujÄ…cy sposÃ³b, aby zostaÅ‚ zaÅ‚adowany do env pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**PrzykÅ‚ad konfiguracji wolumenu**

MoÅ¼esz znaleÅºÄ‡ rÃ³Å¼ne przykÅ‚ady plikÃ³w konfiguracyjnych storage w formacie yaml w [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**ZauwaÅ¼, Å¼e wolumeny nie znajdujÄ… siÄ™ w przestrzeniach nazw**

### Przestrzenie nazw

Kubernetes obsÅ‚uguje **wiele wirtualnych klastrÃ³w** opartych na tym samym fizycznym klastrze. Te wirtualne klastry nazywane sÄ… **przestrzeniami nazw**. SÄ… one przeznaczone do uÅ¼ytku w Å›rodowiskach z wieloma uÅ¼ytkownikami rozproszonymi w rÃ³Å¼nych zespoÅ‚ach lub projektach. W przypadku klastrÃ³w z kilkoma do kilkunastu uÅ¼ytkownikÃ³w, nie powinieneÅ› w ogÃ³le tworzyÄ‡ ani myÅ›leÄ‡ o przestrzeniach nazw. PowinieneÅ› zaczÄ…Ä‡ uÅ¼ywaÄ‡ przestrzeni nazw, aby lepiej kontrolowaÄ‡ i organizowaÄ‡ kaÅ¼dÄ… czÄ™Å›Ä‡ aplikacji wdroÅ¼onej w kubernetes.

Przestrzenie nazw zapewniajÄ… zakres dla nazw. Nazwy zasobÃ³w muszÄ… byÄ‡ unikalne w obrÄ™bie przestrzeni nazw, ale nie w rÃ³Å¼nych przestrzeniach nazw. Przestrzenie nazw nie mogÄ… byÄ‡ zagnieÅ¼dÅ¼ane w sobie nawzajem, a **kaÅ¼dy** zasÃ³b **Kubernetes** moÅ¼e byÄ‡ **tylko** **w** **jednej** **przestrzeni** **nazw**.

DomyÅ›lnie sÄ… 4 przestrzenie nazw, jeÅ›li uÅ¼ywasz minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: Nie jest przeznaczony do uÅ¼ytku przez uÅ¼ytkownikÃ³w i nie powinieneÅ› go dotykaÄ‡. Jest to przestrzeÅ„ dla procesÃ³w master i kubectl.
- **kube-public**: Publicznie dostÄ™pne dane. Zawiera configmap, ktÃ³ry zawiera informacje o klastrze.
- **kube-node-lease**: OkreÅ›la dostÄ™pnoÅ›Ä‡ wÄ™zÅ‚a.
- **default**: PrzestrzeÅ„ nazw, ktÃ³rej uÅ¼ytkownik uÅ¼yje do tworzenia zasobÃ³w.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> ZauwaÅ¼, Å¼e wiÄ™kszoÅ›Ä‡ zasobÃ³w Kubernetes (np. pods, services, replication controllers i inne) znajduje siÄ™ w pewnych przestrzeniach nazw. Jednak inne zasoby, takie jak zasoby przestrzeni nazw i zasoby niskiego poziomu, takie jak nodes i persistentVolumes, nie znajdujÄ… siÄ™ w przestrzeni nazw. Aby zobaczyÄ‡, ktÃ³re zasoby Kubernetes sÄ… i nie sÄ… w przestrzeni nazw:
>
> ```bash
> kubectl api-resources --namespaced=true #W przestrzeni nazw
> kubectl api-resources --namespaced=false #Nie w przestrzeni nazw
> ```

MoÅ¼esz zapisaÄ‡ przestrzeÅ„ nazw dla wszystkich kolejnych poleceÅ„ kubectl w tym kontekÅ›cie.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm to **menedÅ¼er pakietÃ³w** dla Kubernetes. UmoÅ¼liwia pakowanie plikÃ³w YAML i dystrybucjÄ™ ich w publicznych i prywatnych repozytoriach. Te pakiety nazywane sÄ… **Helm Charts**.
```
helm search <keyword>
```
Helm jest rÃ³wnieÅ¼ silnikiem szablonÃ³w, ktÃ³ry pozwala generowaÄ‡ pliki konfiguracyjne z zmiennymi:

## Kubernetes secrets

**Secret** to obiekt, ktÃ³ry **zawiera wraÅ¼liwe dane**, takie jak hasÅ‚o, token lub klucz. Takie informacje mogÅ‚yby byÄ‡ umieszczone w specyfikacji Pod lub w obrazie. UÅ¼ytkownicy mogÄ… tworzyÄ‡ Secrets, a system rÃ³wnieÅ¼ tworzy Secrets. Nazwa obiektu Secret musi byÄ‡ waÅ¼nÄ… **nazwÄ… subdomeny DNS**. Przeczytaj tutaj [oficjalnÄ… dokumentacjÄ™](https://kubernetes.io/docs/concepts/configuration/secret/).

Secrets mogÄ… byÄ‡ takie jak:

- Klucze API, SSH.
- Tokeny OAuth.
- PoÅ›wiadczenia, HasÅ‚a (czysty tekst lub b64 + szyfrowanie).
- Informacje lub komentarze.
- Kod poÅ‚Ä…czenia z bazÄ… danych, ciÄ…giâ€¦ .

IstniejÄ… rÃ³Å¼ne typy sekretÃ³w w Kubernetes

| Typ wbudowany                       | UÅ¼ycie                                    |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **dowolne dane zdefiniowane przez uÅ¼ytkownika (DomyÅ›lnie)** |
| kubernetes.io/service-account-token | token konta usÅ‚ugi                       |
| kubernetes.io/dockercfg             | zserializowany plik \~/.dockercfg        |
| kubernetes.io/dockerconfigjson      | zserializowany plik \~/.docker/config.json |
| kubernetes.io/basic-auth            | poÅ›wiadczenia do podstawowej autoryzacji  |
| kubernetes.io/ssh-auth              | poÅ›wiadczenia do autoryzacji SSH         |
| kubernetes.io/tls                   | dane dla klienta lub serwera TLS         |
| bootstrap.kubernetes.io/token       | dane tokena bootstrap                     |

> [!NOTE]
> **Typ Opaque jest domyÅ›lnym typem, typowÄ… parÄ… klucz-wartoÅ›Ä‡ zdefiniowanÄ… przez uÅ¼ytkownikÃ³w.**

**Jak dziaÅ‚ajÄ… sekrety:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

PoniÅ¼szy plik konfiguracyjny definiuje **secret** o nazwie `mysecret` z 2 parami klucz-wartoÅ›Ä‡ `username: YWRtaW4=` i `password: MWYyZDFlMmU2N2Rm`. Definiuje rÃ³wnieÅ¼ **pod** o nazwie `secretpod`, ktÃ³ry bÄ™dzie miaÅ‚ `username` i `password` zdefiniowane w `mysecret` wystawione w **zmiennych Å›rodowiskowych** `SECRET_USERNAME` \_\_ i \_\_ `SECRET_PASSWOR`. BÄ™dzie rÃ³wnieÅ¼ **montowaÄ‡** sekret `username` wewnÄ…trz `mysecret` w Å›cieÅ¼ce `/etc/foo/my-group/my-username` z uprawnieniami `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Sekrety w etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** to spÃ³jny i wysoko dostÄ™pny **magazyn klucz-wartoÅ›Ä‡** uÅ¼ywany jako zaplecze Kubernetes dla wszystkich danych klastra. Uzyskajmy dostÄ™p do sekretÃ³w przechowywanych w etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Zobaczysz certy, klucze i adresy URL, ktÃ³re znajdujÄ… siÄ™ w systemie plikÃ³w. Gdy je zdobÄ™dziesz, bÄ™dziesz mÃ³gÅ‚ poÅ‚Ä…czyÄ‡ siÄ™ z etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Gdy nawiÄ…Å¼esz komunikacjÄ™, bÄ™dziesz w stanie uzyskaÄ‡ sekrety:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodawanie szyfrowania do ETCD**

DomyÅ›lnie wszystkie sekrety sÄ… **przechowywane w postaci niezaszyfrowanej** wewnÄ…trz etcd, chyba Å¼e zastosujesz warstwÄ™ szyfrowania. PoniÅ¼szy przykÅ‚ad oparty jest na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Po tym musisz ustawiÄ‡ flagÄ™ `--encryption-provider-config` na `kube-apiserver`, aby wskazywaÅ‚a na lokalizacjÄ™ utworzonego pliku konfiguracyjnego. MoÅ¼esz zmodyfikowaÄ‡ `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodaÄ‡ nastÄ™pujÄ…ce linie:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
PrzewiÅ„ w dÃ³Å‚ w volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
PrzewiÅ„ w dÃ³Å‚ w volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Weryfikacja, Å¼e dane sÄ… zaszyfrowane**

Dane sÄ… zaszyfrowane podczas zapisywania do etcd. Po ponownym uruchomieniu `kube-apiserver`, kaÅ¼dy nowo utworzony lub zaktualizowany sekret powinien byÄ‡ zaszyfrowany podczas przechowywania. Aby to sprawdziÄ‡, moÅ¼esz uÅ¼yÄ‡ programu wiersza poleceÅ„ `etcdctl`, aby pobraÄ‡ zawartoÅ›Ä‡ swojego sekretu.

1.  UtwÃ³rz nowy sekret o nazwie `secret1` w przestrzeni nazw `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  UÅ¼ywajÄ…c wiersza poleceÅ„ etcdctl, odczytaj ten sekret z etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gdzie `[...]` musi byÄ‡ dodatkowymi argumentami do poÅ‚Ä…czenia z serwerem etcd.

3.  Zweryfikuj, Å¼e przechowywany sekret jest poprzedzony prefiksem `k8s:enc:aescbc:v1:`, co wskazuje, Å¼e dostawca `aescbc` zaszyfrowaÅ‚ wynikowe dane.
4.  Zweryfikuj, Å¼e sekret jest poprawnie odszyfrowany po pobraniu za pomocÄ… API:

```
kubectl describe secret secret1 -n default
```

powinno odpowiadaÄ‡ `mykey: bXlkYXRh`, mydata jest zakodowane, sprawdÅº [dekodowanie sekretu](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret), aby caÅ‚kowicie dekodowaÄ‡ sekret.

**PoniewaÅ¼ sekrety sÄ… szyfrowane podczas zapisu, wykonanie aktualizacji sekretu zaszyfruje tÄ™ zawartoÅ›Ä‡:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Ostateczne wskazÃ³wki:**

- Staraj siÄ™ nie przechowywaÄ‡ sekretÃ³w w FS, pozyskuj je z innych miejsc.
- SprawdÅº [https://www.vaultproject.io/](https://www.vaultproject.io), aby dodaÄ‡ wiÄ™cej ochrony do swoich sekretÃ³w.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Odniesienia

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
