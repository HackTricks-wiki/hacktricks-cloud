# Kubernetes Basics

## Kubernetes Basics

{{#include ../../banners/hacktricks-training.md}}

**O autor original desta p√°gina √©** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(leia seu post original** [**aqui**](https://sickrov.github.io)**)**

## Arquitetura & Fundamentos

### O que o Kubernetes faz?

- Permite executar cont√™iner/es em um mecanismo de cont√™iner.
- O agendador permite que as miss√µes dos cont√™ineres sejam eficientes.
- Mant√©m os cont√™ineres ativos.
- Permite comunica√ß√µes entre cont√™ineres.
- Permite t√©cnicas de implanta√ß√£o.
- Gerencia volumes de informa√ß√£o.

### Arquitetura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Node**: sistema operacional com pod ou pods.
- **Pod**: Envolt√≥rio em torno de um cont√™iner ou m√∫ltiplos cont√™ineres. Um pod deve conter apenas uma aplica√ß√£o (ent√£o, geralmente, um pod executa apenas 1 cont√™iner). O pod √© a forma como o Kubernetes abstrai a tecnologia de cont√™iner em execu√ß√£o.
- **Service**: Cada pod tem 1 **endere√ßo IP** interno da faixa interna do n√≥. No entanto, tamb√©m pode ser exposto por meio de um servi√ßo. O **servi√ßo tamb√©m tem um endere√ßo IP** e seu objetivo √© manter a comunica√ß√£o entre os pods, ent√£o, se um falhar, o **novo substituto** (com um IP interno diferente) **ser√° acess√≠vel** exposto no **mesmo IP do servi√ßo**. Pode ser configurado como interno ou externo. O servi√ßo tamb√©m atua como um **balanceador de carga quando 2 pods est√£o conectados** ao mesmo servi√ßo.\
Quando um **servi√ßo** √© **criado**, voc√™ pode encontrar os endpoints de cada servi√ßo executando `kubectl get endpoints`
- **Kubelet**: Agente principal do n√≥. O componente que estabelece a comunica√ß√£o entre o n√≥ e o kubectl, e s√≥ pode executar pods (atrav√©s do servidor API). O kubelet n√£o gerencia cont√™ineres que n√£o foram criados pelo Kubernetes.
- **Kube-proxy**: √© o servi√ßo respons√°vel pelas comunica√ß√µes (servi√ßos) entre o apiserver e o n√≥. A base √© um IPtables para n√≥s. Usu√°rios mais experientes podem instalar outros kube-proxies de outros fornecedores.
- **Cont√™iner Sidecar**: Cont√™ineres sidecar s√£o os cont√™ineres que devem ser executados junto com o cont√™iner principal no pod. Este padr√£o sidecar estende e aprimora a funcionalidade dos cont√™ineres atuais sem alter√°-los. Hoje em dia, sabemos que usamos a tecnologia de cont√™iner para envolver todas as depend√™ncias para que a aplica√ß√£o funcione em qualquer lugar. Um cont√™iner faz apenas uma coisa e faz isso muito bem.
- **Processo mestre:**
- **Api Server:** √â a forma como os usu√°rios e os pods se comunicam com o processo mestre. Apenas solicita√ß√µes autenticadas devem ser permitidas.
- **Scheduler**: O agendamento refere-se a garantir que os Pods sejam correspondidos aos N√≥s para que o Kubelet possa execut√°-los. Ele tem intelig√™ncia suficiente para decidir qual n√≥ tem mais recursos dispon√≠veis e atribuir o novo pod a ele. Note que o agendador n√£o inicia novos pods, ele apenas se comunica com o processo Kubelet em execu√ß√£o dentro do n√≥, que lan√ßar√° o novo pod.
- **Kube Controller manager**: Ele verifica recursos como conjuntos de r√©plicas ou implanta√ß√µes para verificar se, por exemplo, o n√∫mero correto de pods ou n√≥s est√° em execu√ß√£o. Caso um pod esteja faltando, ele se comunicar√° com o agendador para iniciar um novo. Ele controla replica√ß√£o, tokens e servi√ßos de conta para a API.
- **etcd**: Armazenamento de dados, persistente, consistente e distribu√≠do. √â o banco de dados do Kubernetes e o armazenamento de chave-valor onde mant√©m o estado completo dos clusters (cada altera√ß√£o √© registrada aqui). Componentes como o Scheduler ou o Controller manager dependem desses dados para saber quais altera√ß√µes ocorreram (recursos dispon√≠veis dos n√≥s, n√∫mero de pods em execu√ß√£o...)
- **Cloud controller manager**: √â o controlador espec√≠fico para controle de fluxo e aplica√ß√µes, ou seja: se voc√™ tem clusters na AWS ou OpenStack.

Note que, como pode haver v√°rios n√≥s (executando v√°rios pods), tamb√©m pode haver v√°rios processos mestres, cujo acesso ao servidor API √© balanceado e seu etcd sincronizado.

**Volumes:**

Quando um pod cria dados que n√£o devem ser perdidos quando o pod desaparecer, eles devem ser armazenados em um volume f√≠sico. **O Kubernetes permite anexar um volume a um pod para persistir os dados**. O volume pode estar na m√°quina local ou em um **armazenamento remoto**. Se voc√™ estiver executando pods em diferentes n√≥s f√≠sicos, deve usar um armazenamento remoto para que todos os pods possam acess√°-lo.

**Outras configura√ß√µes:**

- **ConfigMap**: Voc√™ pode configurar **URLs** para acessar servi√ßos. O pod obter√° dados daqui para saber como se comunicar com o restante dos servi√ßos (pods). Note que este n√£o √© o lugar recomendado para salvar credenciais!
- **Secret**: Este √© o lugar para **armazenar dados secretos** como senhas, chaves de API... codificados em B64. O pod poder√° acessar esses dados para usar as credenciais necess√°rias.
- **Deployments**: Este √© o local onde os componentes a serem executados pelo Kubernetes s√£o indicados. Um usu√°rio geralmente n√£o trabalhar√° diretamente com pods, os pods s√£o abstra√≠dos em **ReplicaSets** (n√∫mero de pods iguais replicados), que s√£o executados por meio de implanta√ß√µes. Note que as implanta√ß√µes s√£o para aplica√ß√µes **sem estado**. A configura√ß√£o m√≠nima para uma implanta√ß√£o √© o nome e a imagem a ser executada.
- **StatefulSet**: Este componente √© destinado especificamente a aplica√ß√µes como **bancos de dados** que precisam **acessar o mesmo armazenamento**.
- **Ingress**: Esta √© a configura√ß√£o que √© usada para **expor a aplica√ß√£o publicamente com uma URL**. Note que isso tamb√©m pode ser feito usando servi√ßos externos, mas esta √© a forma correta de expor a aplica√ß√£o.
- Se voc√™ implementar um Ingress, precisar√° criar **Ingress Controllers**. O Ingress Controller √© um **pod** que ser√° o endpoint que receber√° as solicita√ß√µes e verificar√° e balancear√° elas para os servi√ßos. O ingress controller **enviar√° a solicita√ß√£o com base nas regras de ingress configuradas**. Note que as regras de ingress podem apontar para diferentes caminhos ou at√© mesmo subdom√≠nios para diferentes servi√ßos internos do Kubernetes.
- Uma pr√°tica de seguran√ßa melhor seria usar um balanceador de carga em nuvem ou um servidor proxy como ponto de entrada para n√£o ter nenhuma parte do cluster Kubernetes exposta.
- Quando uma solicita√ß√£o que n√£o corresponde a nenhuma regra de ingress √© recebida, o ingress controller a direcionar√° para o "**Default backend**". Voc√™ pode `describe` o ingress controller para obter o endere√ßo deste par√¢metro.
- `minikube addons enable ingress`

### Infraestrutura PKI - Autoridade Certificadora CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA √© a raiz confi√°vel para todos os certificados dentro do cluster.
- Permite que os componentes se validem mutuamente.
- Todos os certificados do cluster s√£o assinados pela CA.
- O etcd tem seu pr√≥prio certificado.
- tipos:
- certificado apiserver.
- certificado kubelet.
- certificado scheduler.

## A√ß√µes B√°sicas

### Minikube

**Minikube** pode ser usado para realizar alguns **testes r√°pidos** no Kubernetes sem precisar implantar um ambiente Kubernetes completo. Ele executar√° os **processos mestre e n√≥ em uma m√°quina**. O Minikube usar√° o virtualbox para executar o n√≥. Veja [**aqui como instal√°-lo**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### No√ß√µes B√°sicas do Kubectl

**`Kubectl`** √© a ferramenta de linha de comando para clusters kubernetes. Ele se comunica com o servidor Api do processo mestre para realizar a√ß√µes no kubernetes ou para solicitar dados.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

O painel permite que voc√™ veja mais facilmente o que o minikube est√° executando, voc√™ pode encontrar a URL para acess√°-lo em:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Exemplos de arquivos de configura√ß√£o YAML

Cada arquivo de configura√ß√£o tem 3 partes: **metadados**, **especifica√ß√£o** (o que precisa ser lan√ßado), **status** (estado desejado).\
Dentro da especifica√ß√£o do arquivo de configura√ß√£o de implanta√ß√£o, voc√™ pode encontrar o template definido com uma nova estrutura de configura√ß√£o definindo a imagem a ser executada:

**Exemplo de Implanta√ß√£o + Servi√ßo declarado no mesmo arquivo de configura√ß√£o (de** [**aqui**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Como um servi√ßo geralmente est√° relacionado a uma implanta√ß√£o, √© poss√≠vel declarar ambos no mesmo arquivo de configura√ß√£o (o servi√ßo declarado nesta configura√ß√£o √© acess√≠vel apenas internamente):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Exemplo de configura√ß√£o de servi√ßo externo**

Este servi√ßo ser√° acess√≠vel externamente (verifique os atributos `nodePort` e `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Isso √© √∫til para testes, mas para produ√ß√£o voc√™ deve ter apenas servi√ßos internos e um Ingress para expor a aplica√ß√£o.

**Exemplo de arquivo de configura√ß√£o do Ingress**

Isso expor√° a aplica√ß√£o em `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Exemplo de arquivo de configura√ß√£o de segredos**

Note como as senhas est√£o codificadas em B64 (o que n√£o √© seguro!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Exemplo de ConfigMap**

Um **ConfigMap** √© a configura√ß√£o que √© dada aos pods para que eles saibam como localizar e acessar outros servi√ßos. Neste caso, cada pod saber√° que o nome `mongodb-service` √© o endere√ßo de um pod com o qual eles podem se comunicar (este pod estar√° executando um mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Ent√£o, dentro de uma **deployment config**, este endere√ßo pode ser especificado da seguinte maneira para que seja carregado dentro do env do pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Exemplo de configura√ß√£o de volume**

Voc√™ pode encontrar diferentes exemplos de arquivos de configura√ß√£o de armazenamento yaml em [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Note que volumes n√£o est√£o dentro de namespaces**

### Namespaces

Kubernetes suporta **m√∫ltiplos clusters virtuais** suportados pelo mesmo cluster f√≠sico. Esses clusters virtuais s√£o chamados de **namespaces**. Eles s√£o destinados ao uso em ambientes com muitos usu√°rios espalhados por v√°rias equipes ou projetos. Para clusters com poucos a dezenas de usu√°rios, voc√™ n√£o deve precisar criar ou pensar em namespaces. Voc√™ s√≥ deve come√ßar a usar namespaces para ter um melhor controle e organiza√ß√£o de cada parte da aplica√ß√£o implantada no kubernetes.

Namespaces fornecem um escopo para nomes. Nomes de recursos precisam ser √∫nicos dentro de um namespace, mas n√£o entre namespaces. Namespaces n√£o podem ser aninhados dentro de outros e **cada** recurso **Kubernetes** pode estar **em** **um** **namespace** **apenas**.

Existem 4 namespaces por padr√£o se voc√™ estiver usando minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: N√£o √© destinado ao uso dos usu√°rios e voc√™ n√£o deve toc√°-lo. √â para processos de master e kubectl.
- **kube-public**: Dados acess√≠veis publicamente. Cont√©m um configmap que cont√©m informa√ß√µes do cluster.
- **kube-node-lease**: Determina a disponibilidade de um n√≥.
- **default**: O namespace que o usu√°rio usar√° para criar recursos.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Note que a maioria dos recursos do Kubernetes (por exemplo, pods, servi√ßos, controladores de replica√ß√£o e outros) est√£o em alguns namespaces. No entanto, outros recursos, como recursos de namespace e recursos de baixo n√≠vel, como nodes e persistentVolumes, n√£o est√£o em um namespace. Para ver quais recursos do Kubernetes est√£o e n√£o est√£o em um namespace:
>
> ```bash
> kubectl api-resources --namespaced=true #Em um namespace
> kubectl api-resources --namespaced=false #N√£o em um namespace
> ```

Voc√™ pode salvar o namespace para todos os comandos kubectl subsequentes nesse contexto.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm √© o **gerenciador de pacotes** para Kubernetes. Ele permite empacotar arquivos YAML e distribu√≠-los em reposit√≥rios p√∫blicos e privados. Esses pacotes s√£o chamados de **Helm Charts**.
```
helm search <keyword>
```
Helm tamb√©m √© um mecanismo de template que permite gerar arquivos de configura√ß√£o com vari√°veis:

## Segredos do Kubernetes

Um **Secret** √© um objeto que **cont√©m dados sens√≠veis** como uma senha, um token ou uma chave. Essas informa√ß√µes poderiam ser colocadas em uma especifica√ß√£o de Pod ou em uma imagem. Os usu√°rios podem criar Secrets e o sistema tamb√©m cria Secrets. O nome de um objeto Secret deve ser um **nome de subdom√≠nio DNS** v√°lido. Leia aqui [a documenta√ß√£o oficial](https://kubernetes.io/docs/concepts/configuration/secret/).

Os Secrets podem ser coisas como:

- Chaves de API, SSH.
- Tokens OAuth.
- Credenciais, Senhas (texto simples ou b64 + criptografia).
- Informa√ß√µes ou coment√°rios.
- C√≥digo de conex√£o com banco de dados, strings‚Ä¶ .

Existem diferentes tipos de secrets no Kubernetes

| Tipo Integrado                      | Uso                                       |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **dados arbitr√°rios definidos pelo usu√°rio (Padr√£o)** |
| kubernetes.io/service-account-token | token de conta de servi√ßo                 |
| kubernetes.io/dockercfg             | arquivo \~/.dockercfg serializado         |
| kubernetes.io/dockerconfigjson      | arquivo \~/.docker/config.json serializado |
| kubernetes.io/basic-auth            | credenciais para autentica√ß√£o b√°sica      |
| kubernetes.io/ssh-auth              | credenciais para autentica√ß√£o SSH         |
| kubernetes.io/tls                   | dados para um cliente ou servidor TLS     |
| bootstrap.kubernetes.io/token       | dados do token de bootstrap               |

> [!NOTE]
> **O tipo Opaque √© o padr√£o, o t√≠pico par chave-valor definido pelos usu√°rios.**

**Como os secrets funcionam:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

O seguinte arquivo de configura√ß√£o define um **secret** chamado `mysecret` com 2 pares chave-valor `username: YWRtaW4=` e `password: MWYyZDFlMmU2N2Rm`. Ele tamb√©m define um **pod** chamado `secretpod` que ter√° o `username` e `password` definidos em `mysecret` expostos nas **vari√°veis de ambiente** `SECRET_USERNAME` \_\_ e \_\_ `SECRET_PASSWOR`. Ele tamb√©m **montar√°** o secret `username` dentro de `mysecret` no caminho `/etc/foo/my-group/my-username` com permiss√µes `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Segredos no etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** √© um armazenamento de **chave-valor** consistente e altamente dispon√≠vel usado como armazenamento de suporte do Kubernetes para todos os dados do cluster. Vamos acessar os segredos armazenados no etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Voc√™ ver√° que certs, chaves e URLs est√£o localizados no FS. Uma vez que voc√™ os obtenha, poder√° se conectar ao etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Uma vez que voc√™ estabele√ßa a comunica√ß√£o, voc√™ poder√° obter os segredos:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Adicionando criptografia ao ETCD**

Por padr√£o, todos os segredos s√£o **armazenados em texto simples** dentro do etcd, a menos que voc√™ aplique uma camada de criptografia. O seguinte exemplo √© baseado em [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Depois disso, voc√™ precisa definir a flag `--encryption-provider-config` no `kube-apiserver` para apontar para a localiza√ß√£o do arquivo de configura√ß√£o criado. Voc√™ pode modificar `/etc/kubernetes/manifest/kube-apiserver.yaml` e adicionar as seguintes linhas:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Role para baixo em volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Role para baixo em volumeMounts at√© hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verificando se os dados est√£o criptografados**

Os dados s√£o criptografados quando escritos no etcd. Ap√≥s reiniciar seu `kube-apiserver`, qualquer segredo rec√©m-criado ou atualizado deve ser criptografado ao ser armazenado. Para verificar, voc√™ pode usar o programa de linha de comando `etcdctl` para recuperar o conte√∫do do seu segredo.

1.  Crie um novo segredo chamado `secret1` no namespace `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  Usando a linha de comando etcdctl, leia esse segredo do etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

onde `[...]` deve ser os argumentos adicionais para conectar ao servidor etcd.

3.  Verifique se o segredo armazenado est√° prefixado com `k8s:enc:aescbc:v1:`, o que indica que o provedor `aescbc` criptografou os dados resultantes.
4.  Verifique se o segredo √© corretamente descriptografado quando recuperado via API:

```
kubectl describe secret secret1 -n default
```

deve corresponder a `mykey: bXlkYXRh`, mydata est√° codificado, verifique [decodificando um segredo](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) para decodificar completamente o segredo.

**Como os segredos s√£o criptografados na grava√ß√£o, realizar uma atualiza√ß√£o em um segredo criptografar√° esse conte√∫do:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Dicas finais:**

- Tente n√£o manter segredos no FS, obtenha-os de outros lugares.
- Confira [https://www.vaultproject.io/](https://www.vaultproject.io) para adicionar mais prote√ß√£o aos seus segredos.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Refer√™ncias

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
