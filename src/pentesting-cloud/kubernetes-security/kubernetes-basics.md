# Kubernetes Basics

## Kubernetes Basics

{{#include ../../banners/hacktricks-training.md}}

**El autor original de esta p√°gina es** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lee su publicaci√≥n original** [**aqu√≠**](https://sickrov.github.io)**)**

## Arquitectura y conceptos b√°sicos

### ¬øQu√© hace Kubernetes?

- Permite ejecutar contenedor/es en un motor de contenedores.
- La programaci√≥n permite que las misiones de los contenedores sean eficientes.
- Mantiene los contenedores vivos.
- Permite la comunicaci√≥n entre contenedores.
- Permite t√©cnicas de despliegue.
- Maneja vol√∫menes de informaci√≥n.

### Arquitectura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Nodo**: sistema operativo con pod o pods.
- **Pod**: envoltura alrededor de un contenedor o m√∫ltiples contenedores. Un pod debe contener solo una aplicaci√≥n (por lo general, un pod ejecuta solo 1 contenedor). El pod es la forma en que Kubernetes abstrae la tecnolog√≠a de contenedores en ejecuci√≥n.
- **Servicio**: Cada pod tiene 1 **direcci√≥n IP interna** del rango interno del nodo. Sin embargo, tambi√©n puede ser expuesto a trav√©s de un servicio. El **servicio tambi√©n tiene una direcci√≥n IP** y su objetivo es mantener la comunicaci√≥n entre pods, por lo que si uno muere, el **nuevo reemplazo** (con una IP interna diferente) **ser√° accesible** expuesto en la **misma IP del servicio**. Puede configurarse como interno o externo. El servicio tambi√©n act√∫a como un **balanceador de carga cuando 2 pods est√°n conectados** al mismo servicio.\
Cuando se **crea un servicio**, puedes encontrar los puntos finales de cada servicio ejecutando `kubectl get endpoints`
- **Kubelet**: Agente principal del nodo. El componente que establece la comunicaci√≥n entre el nodo y kubectl, y solo puede ejecutar pods (a trav√©s del servidor API). El kubelet no gestiona contenedores que no fueron creados por Kubernetes.
- **Kube-proxy**: es el servicio encargado de las comunicaciones (servicios) entre el apiserver y el nodo. La base es un IPtables para nodos. Los usuarios m√°s experimentados podr√≠an instalar otros kube-proxies de otros proveedores.
- **Contenedor Sidecar**: Los contenedores sidecar son los contenedores que deben ejecutarse junto con el contenedor principal en el pod. Este patr√≥n sidecar extiende y mejora la funcionalidad de los contenedores actuales sin cambiarlos. Hoy en d√≠a, sabemos que usamos tecnolog√≠a de contenedores para envolver todas las dependencias para que la aplicaci√≥n se ejecute en cualquier lugar. Un contenedor hace solo una cosa y la hace muy bien.
- **Proceso maestro:**
- **Api Server:** Es la forma en que los usuarios y los pods se comunican con el proceso maestro. Solo se deben permitir solicitudes autenticadas.
- **Scheduler**: La programaci√≥n se refiere a asegurarse de que los Pods est√©n emparejados con los Nodos para que Kubelet pueda ejecutarlos. Tiene suficiente inteligencia para decidir qu√© nodo tiene m√°s recursos disponibles y asignar el nuevo pod a √©l. Ten en cuenta que el scheduler no inicia nuevos pods, solo se comunica con el proceso Kubelet que se ejecuta dentro del nodo, que lanzar√° el nuevo pod.
- **Kube Controller manager**: Verifica recursos como conjuntos de r√©plicas o despliegues para comprobar si, por ejemplo, el n√∫mero correcto de pods o nodos est√° en ejecuci√≥n. En caso de que falte un pod, se comunicar√° con el scheduler para iniciar uno nuevo. Controla la replicaci√≥n, tokens y servicios de cuenta para la API.
- **etcd**: Almacenamiento de datos, persistente, consistente y distribuido. Es la base de datos de Kubernetes y el almacenamiento clave-valor donde mantiene el estado completo de los cl√∫steres (cada cambio se registra aqu√≠). Componentes como el Scheduler o el Controller manager dependen de estos datos para saber qu√© cambios han ocurrido (recursos disponibles de los nodos, n√∫mero de pods en ejecuci√≥n...)
- **Cloud controller manager**: Es el controlador espec√≠fico para el control de flujo y aplicaciones, es decir: si tienes cl√∫steres en AWS o OpenStack.

Ten en cuenta que como puede haber varios nodos (ejecutando varios pods), tambi√©n puede haber varios procesos maestros cuyos accesos al Api server est√°n balanceados y su etcd sincronizado.

**Vol√∫menes:**

Cuando un pod crea datos que no deber√≠an perderse cuando el pod desaparece, deben almacenarse en un volumen f√≠sico. **Kubernetes permite adjuntar un volumen a un pod para persistir los datos**. El volumen puede estar en la m√°quina local o en un **almacenamiento remoto**. Si est√°s ejecutando pods en diferentes nodos f√≠sicos, deber√≠as usar un almacenamiento remoto para que todos los pods puedan acceder a √©l.

**Otras configuraciones:**

- **ConfigMap**: Puedes configurar **URLs** para acceder a servicios. El pod obtendr√° datos de aqu√≠ para saber c√≥mo comunicarse con el resto de los servicios (pods). Ten en cuenta que este no es el lugar recomendado para guardar credenciales.
- **Secret**: Este es el lugar para **almacenar datos secretos** como contrase√±as, claves API... codificados en B64. El pod podr√° acceder a estos datos para usar las credenciales requeridas.
- **Deployments**: Aqu√≠ es donde se indican los componentes que ser√°n ejecutados por Kubernetes. Un usuario generalmente no trabajar√° directamente con pods, los pods est√°n abstra√≠dos en **ReplicaSets** (n√∫mero de pods id√©nticos replicados), que se ejecutan a trav√©s de despliegues. Ten en cuenta que los despliegues son para aplicaciones **sin estado**. La configuraci√≥n m√≠nima para un despliegue es el nombre y la imagen a ejecutar.
- **StatefulSet**: Este componente est√° destinado espec√≠ficamente a aplicaciones como **bases de datos** que necesitan **acceder al mismo almacenamiento**.
- **Ingress**: Esta es la configuraci√≥n que se utiliza para **exponer la aplicaci√≥n p√∫blicamente con una URL**. Ten en cuenta que esto tambi√©n se puede hacer utilizando servicios externos, pero esta es la forma correcta de exponer la aplicaci√≥n.
- Si implementas un Ingress, necesitar√°s crear **Ingress Controllers**. El Ingress Controller es un **pod** que ser√° el punto final que recibir√° las solicitudes y las verificar√° y las balancear√° a los servicios. El controlador de ingreso **enviar√° la solicitud seg√∫n las reglas de ingreso configuradas**. Ten en cuenta que las reglas de ingreso pueden apuntar a diferentes rutas o incluso subdominios a diferentes servicios internos de Kubernetes.
- Una mejor pr√°ctica de seguridad ser√≠a usar un balanceador de carga en la nube o un servidor proxy como punto de entrada para no tener ninguna parte del cl√∫ster de Kubernetes expuesta.
- Cuando se recibe una solicitud que no coincide con ninguna regla de ingreso, el controlador de ingreso la dirigir√° al "**backend predeterminado**". Puedes `describe` el controlador de ingreso para obtener la direcci√≥n de este par√°metro.
- `minikube addons enable ingress`

### Infraestructura PKI - Autoridad de Certificaci√≥n CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA es la ra√≠z de confianza para todos los certificados dentro del cl√∫ster.
- Permite que los componentes se validen entre s√≠.
- Todos los certificados del cl√∫ster son firmados por la CA.
- etcd tiene su propio certificado.
- tipos:
- certificado del apiserver.
- certificado del kubelet.
- certificado del scheduler.

## Acciones B√°sicas

### Minikube

**Minikube** se puede usar para realizar algunas **pruebas r√°pidas** en Kubernetes sin necesidad de desplegar un entorno completo de Kubernetes. Ejecutar√° los **procesos maestro y nodo en una m√°quina**. Minikube utilizar√° virtualbox para ejecutar el nodo. Consulta [**aqu√≠ c√≥mo instalarlo**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Basics

**`Kubectl`** es la herramienta de l√≠nea de comandos para cl√∫steres de kubernetes. Se comunica con el servidor Api del proceso maestro para realizar acciones en kubernetes o para solicitar datos.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

El panel de control te permite ver m√°s f√°cilmente lo que est√° ejecutando minikube, puedes encontrar la URL para acceder a √©l en:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Ejemplos de archivos de configuraci√≥n YAML

Cada archivo de configuraci√≥n tiene 3 partes: **metadata**, **specification** (lo que necesita ser lanzado), **status** (estado deseado).\
Dentro de la especificaci√≥n del archivo de configuraci√≥n de despliegue, puedes encontrar la plantilla definida con una nueva estructura de configuraci√≥n que define la imagen a ejecutar:

**Ejemplo de Deployment + Service declarados en el mismo archivo de configuraci√≥n (de** [**aqu√≠**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Como un servicio generalmente est√° relacionado con un despliegue, es posible declarar ambos en el mismo archivo de configuraci√≥n (el servicio declarado en esta configuraci√≥n solo es accesible internamente):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Ejemplo de configuraci√≥n de servicio externo**

Este servicio ser√° accesible externamente (ver los atributos `nodePort` y `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Esto es √∫til para pruebas, pero para producci√≥n solo deber√≠as tener servicios internos y un Ingress para exponer la aplicaci√≥n.

**Ejemplo de archivo de configuraci√≥n de Ingress**

Esto expondr√° la aplicaci√≥n en `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Ejemplo de archivo de configuraci√≥n de secretos**

Nota c√≥mo las contrase√±as est√°n codificadas en B64 (¬°lo cual no es seguro!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Ejemplo de ConfigMap**

Un **ConfigMap** es la configuraci√≥n que se le da a los pods para que sepan c√≥mo localizar y acceder a otros servicios. En este caso, cada pod sabr√° que el nombre `mongodb-service` es la direcci√≥n de un pod con el que pueden comunicarse (este pod estar√° ejecutando un mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Luego, dentro de una **deployment config**, esta direcci√≥n se puede especificar de la siguiente manera para que se cargue dentro del env del pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Ejemplo de configuraci√≥n de volumen**

Puedes encontrar diferentes ejemplos de archivos de configuraci√≥n de almacenamiento yaml en [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Nota que los vol√∫menes no est√°n dentro de los espacios de nombres**

### Espacios de nombres

Kubernetes soporta **m√∫ltiples cl√∫steres virtuales** respaldados por el mismo cl√∫ster f√≠sico. Estos cl√∫steres virtuales se llaman **espacios de nombres**. Est√°n destinados para su uso en entornos con muchos usuarios distribuidos en m√∫ltiples equipos o proyectos. Para cl√∫steres con unos pocos a decenas de usuarios, no deber√≠as necesitar crear o pensar en espacios de nombres en absoluto. Solo deber√≠as comenzar a usar espacios de nombres para tener un mejor control y organizaci√≥n de cada parte de la aplicaci√≥n desplegada en kubernetes.

Los espacios de nombres proporcionan un alcance para los nombres. Los nombres de los recursos deben ser √∫nicos dentro de un espacio de nombres, pero no entre espacios de nombres. Los espacios de nombres no pueden estar anidados uno dentro de otro y **cada** recurso de Kubernetes **solo puede estar** **en** **un** **espacio de nombres**.

Hay 4 espacios de nombres por defecto si est√°s usando minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: No est√° destinado para el uso de los usuarios y no deber√≠as tocarlo. Es para procesos de master y kubectl.
- **kube-public**: Datos accesibles p√∫blicamente. Contiene un configmap que contiene informaci√≥n del cl√∫ster.
- **kube-node-lease**: Determina la disponibilidad de un nodo.
- **default**: El namespace que el usuario utilizar√° para crear recursos.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Tenga en cuenta que la mayor√≠a de los recursos de Kubernetes (por ejemplo, pods, servicios, controladores de replicaci√≥n y otros) est√°n en algunos namespaces. Sin embargo, otros recursos como los recursos de namespace y recursos de bajo nivel, como nodos y persistenVolumes, no est√°n en un namespace. Para ver qu√© recursos de Kubernetes est√°n y no est√°n en un namespace:
>
> ```bash
> kubectl api-resources --namespaced=true #En un namespace
> kubectl api-resources --namespaced=false #No en un namespace
> ```

Puede guardar el namespace para todos los comandos kubectl subsiguientes en ese contexto.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm es el **gestor de paquetes** para Kubernetes. Permite empaquetar archivos YAML y distribuirlos en repositorios p√∫blicos y privados. Estos paquetes se llaman **Helm Charts**.
```
helm search <keyword>
```
Helm tambi√©n es un motor de plantillas que permite generar archivos de configuraci√≥n con variables:

## Secretos de Kubernetes

Un **Secret** es un objeto que **contiene datos sensibles** como una contrase√±a, un token o una clave. Tal informaci√≥n podr√≠a de otro modo ser colocada en una especificaci√≥n de Pod o en una imagen. Los usuarios pueden crear Secrets y el sistema tambi√©n crea Secrets. El nombre de un objeto Secret debe ser un **nombre de subdominio DNS v√°lido**. Lea aqu√≠ [la documentaci√≥n oficial](https://kubernetes.io/docs/concepts/configuration/secret/).

Los Secrets pueden ser cosas como:

- Claves API, SSH.
- Tokens de OAuth.
- Credenciales, Contrase√±as (texto plano o b64 + cifrado).
- Informaci√≥n o comentarios.
- C√≥digo de conexi√≥n a bases de datos, cadenas‚Ä¶ .

Hay diferentes tipos de secretos en Kubernetes

| Tipo incorporado                     | Uso                                      |
| ------------------------------------ | ---------------------------------------- |
| **Opaque**                           | **datos arbitrarios definidos por el usuario (Predeterminado)** |
| kubernetes.io/service-account-token  | token de cuenta de servicio              |
| kubernetes.io/dockercfg              | archivo \~/.dockercfg serializado        |
| kubernetes.io/dockerconfigjson       | archivo \~/.docker/config.json serializado |
| kubernetes.io/basic-auth             | credenciales para autenticaci√≥n b√°sica   |
| kubernetes.io/ssh-auth               | credenciales para autenticaci√≥n SSH      |
| kubernetes.io/tls                    | datos para un cliente o servidor TLS     |
| bootstrap.kubernetes.io/token        | datos del token de arranque              |

> [!NOTE]
> **El tipo Opaque es el predeterminado, el t√≠pico par clave-valor definido por los usuarios.**

**C√≥mo funcionan los secretos:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

El siguiente archivo de configuraci√≥n define un **secret** llamado `mysecret` con 2 pares clave-valor `username: YWRtaW4=` y `password: MWYyZDFlMmU2N2Rm`. Tambi√©n define un **pod** llamado `secretpod` que tendr√° el `username` y `password` definidos en `mysecret` expuestos en las **variables de entorno** `SECRET_USERNAME` \_\_ y \_\_ `SECRET_PASSWOR`. Tambi√©n **montar√°** el secreto `username` dentro de `mysecret` en la ruta `/etc/foo/my-group/my-username` con permisos `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** es un almac√©n de **clave-valor** consistente y altamente disponible utilizado como almac√©n de respaldo de Kubernetes para todos los datos del cl√∫ster. Accedamos a los secretos almacenados en etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Ver√°s que los certs, claves y URL est√°n ubicados en el FS. Una vez que los obtengas, podr√°s conectarte a etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Una vez que logres establecer comunicaci√≥n, podr√°s obtener los secretos:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Agregar cifrado al ETCD**

Por defecto, todos los secretos est√°n **almacenados en texto plano** dentro de etcd a menos que apliques una capa de cifrado. El siguiente ejemplo se basa en [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Despu√©s de eso, necesitas establecer la bandera `--encryption-provider-config` en el `kube-apiserver` para apuntar a la ubicaci√≥n del archivo de configuraci√≥n creado. Puedes modificar `/etc/kubernetes/manifest/kube-apiserver.yaml` y agregar las siguientes l√≠neas:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Despl√°cese hacia abajo en los volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Despl√°cese hacia abajo en los volumeMounts hasta hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verificando que los datos est√°n encriptados**

Los datos est√°n encriptados cuando se escriben en etcd. Despu√©s de reiniciar tu `kube-apiserver`, cualquier secreto creado o actualizado deber√≠a estar encriptado al almacenarse. Para verificar, puedes usar el programa de l√≠nea de comandos `etcdctl` para recuperar el contenido de tu secreto.

1.  Crea un nuevo secreto llamado `secret1` en el espacio de nombres `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  Usando la l√≠nea de comandos etcdctl, lee ese secreto de etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

donde `[...]` debe ser los argumentos adicionales para conectarse al servidor etcd.

3.  Verifica que el secreto almacenado est√© precedido por `k8s:enc:aescbc:v1:` lo que indica que el proveedor `aescbc` ha encriptado los datos resultantes.
4.  Verifica que el secreto se descifre correctamente al recuperarlo a trav√©s de la API:

```
kubectl describe secret secret1 -n default
```

deber√≠a coincidir con `mykey: bXlkYXRh`, mydata est√° codificado, consulta [decodificando un secreto](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) para decodificar completamente el secreto.

**Dado que los secretos est√°n encriptados al escribir, realizar una actualizaci√≥n en un secreto encriptar√° ese contenido:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Consejos finales:**

- Intenta no guardar secretos en el FS, obt√©nlos de otros lugares.
- Consulta [https://www.vaultproject.io/](https://www.vaultproject.io) para agregar m√°s protecci√≥n a tus secretos.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Referencias

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
