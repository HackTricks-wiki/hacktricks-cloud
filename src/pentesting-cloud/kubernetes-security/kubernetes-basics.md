# Kubernetes Grundlagen

## Kubernetes Grundlagen

{{#include ../../banners/hacktricks-training.md}}

**Der urspr√ºngliche Autor dieser Seite ist** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lesen Sie seinen urspr√ºnglichen Beitrag** [**hier**](https://sickrov.github.io)**)**

## Architektur & Grundlagen

### Was macht Kubernetes?

- Erm√∂glicht das Ausf√ºhren von Containern in einer Container-Engine.
- Der Scheduler erm√∂glicht eine effiziente Planung von Containern.
- H√§lt Container am Leben.
- Erm√∂glicht die Kommunikation zwischen Containern.
- Erm√∂glicht Bereitstellungstechniken.
- Verarbeitet Informationsvolumen.

### Architektur

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Node**: Betriebssystem mit Pod oder Pods.
- **Pod**: Wrapper um einen Container oder mehrere Container. Ein Pod sollte nur eine Anwendung enthalten (normalerweise l√§uft ein Pod nur 1 Container). Der Pod ist die Art und Weise, wie Kubernetes die Containertechnologie abstrahiert.
- **Service**: Jeder Pod hat 1 interne **IP-Adresse** aus dem internen Bereich des Nodes. Er kann jedoch auch √ºber einen Service exponiert werden. Der **Service hat ebenfalls eine IP-Adresse** und sein Ziel ist es, die Kommunikation zwischen Pods aufrechtzuerhalten, sodass, wenn einer ausf√§llt, der **neue Ersatz** (mit einer anderen internen IP) **√ºber die gleiche IP des Services zug√§nglich ist**. Er kann als intern oder extern konfiguriert werden. Der Service fungiert auch als **Lastenausgleich, wenn 2 Pods mit demselben Service verbunden sind**.\
Wenn ein **Service** **erstellt** wird, k√∂nnen Sie die Endpunkte jedes Services mit `kubectl get endpoints` finden.
- **Kubelet**: Prim√§rer Node-Agent. Die Komponente, die die Kommunikation zwischen Node und kubectl herstellt und nur Pods ausf√ºhren kann (√ºber den API-Server). Der Kubelet verwaltet keine Container, die nicht von Kubernetes erstellt wurden.
- **Kube-proxy**: Ist der Service, der f√ºr die Kommunikation (Services) zwischen dem apiserver und dem Node verantwortlich ist. Die Basis ist ein IPtables f√ºr Nodes. Erfahrene Benutzer k√∂nnten andere Kube-Proxys von anderen Anbietern installieren.
- **Sidecar-Container**: Sidecar-Container sind die Container, die zusammen mit dem Hauptcontainer im Pod ausgef√ºhrt werden sollten. Dieses Sidecar-Muster erweitert und verbessert die Funktionalit√§t der aktuellen Container, ohne sie zu √§ndern. Heutzutage wissen wir, dass wir Containertechnologie verwenden, um alle Abh√§ngigkeiten f√ºr die Anwendung zu verpacken, damit sie √ºberall ausgef√ºhrt werden kann. Ein Container macht nur eine Sache und macht diese Sache sehr gut.
- **Master-Prozess:**
- **Api Server:** Ist der Weg, wie die Benutzer und die Pods mit dem Master-Prozess kommunizieren. Nur authentifizierte Anfragen sollten erlaubt sein.
- **Scheduler**: Die Planung bezieht sich darauf, sicherzustellen, dass Pods den Nodes zugeordnet werden, damit Kubelet sie ausf√ºhren kann. Er hat genug Intelligenz, um zu entscheiden, welcher Node mehr verf√ºgbare Ressourcen hat, um den neuen Pod zuzuweisen. Beachten Sie, dass der Scheduler keine neuen Pods startet, sondern nur mit dem Kubelet-Prozess kommuniziert, der im Node l√§uft und den neuen Pod starten wird.
- **Kube Controller Manager**: Er √ºberpr√ºft Ressourcen wie Replica-Sets oder Deployments, um zu √ºberpr√ºfen, ob beispielsweise die richtige Anzahl von Pods oder Nodes l√§uft. Falls ein Pod fehlt, kommuniziert er mit dem Scheduler, um einen neuen zu starten. Er steuert Replikation, Tokens und Kontodienste f√ºr die API.
- **etcd**: Datenspeicher, persistent, konsistent und verteilt. Ist die Datenbank von Kubernetes und der Schl√ºssel-Wert-Speicher, in dem der vollst√§ndige Zustand der Cluster gespeichert wird (jede √Ñnderung wird hier protokolliert). Komponenten wie der Scheduler oder der Controller Manager h√§ngen von diesen Daten ab, um zu wissen, welche √Ñnderungen aufgetreten sind (verf√ºgbare Ressourcen der Nodes, Anzahl der laufenden Pods...).
- **Cloud Controller Manager**: Ist der spezifische Controller f√ºr Flusskontrollen und Anwendungen, d.h.: wenn Sie Cluster in AWS oder OpenStack haben.

Beachten Sie, dass es mehrere Nodes (die mehrere Pods ausf√ºhren) geben kann, und es kann auch mehrere Master-Prozesse geben, deren Zugriff auf den Api-Server lastenausgeglichen und deren etcd synchronisiert ist.

**Volumes:**

Wenn ein Pod Daten erstellt, die nicht verloren gehen sollten, wenn der Pod verschwindet, sollten sie in einem physischen Volume gespeichert werden. **Kubernetes erm√∂glicht es, ein Volume an einen Pod anzuh√§ngen, um die Daten zu persistieren**. Das Volume kann auf der lokalen Maschine oder in einem **Remote-Speicher** sein. Wenn Sie Pods auf verschiedenen physischen Nodes ausf√ºhren, sollten Sie einen Remote-Speicher verwenden, damit alle Pods darauf zugreifen k√∂nnen.

**Weitere Konfigurationen:**

- **ConfigMap**: Sie k√∂nnen **URLs** konfigurieren, um auf Services zuzugreifen. Der Pod wird Daten von hier abrufen, um zu wissen, wie er mit den anderen Services (Pods) kommunizieren kann. Beachten Sie, dass dies nicht der empfohlene Ort ist, um Anmeldeinformationen zu speichern!
- **Secret**: Dies ist der Ort, um **geheime Daten** wie Passw√∂rter, API-Schl√ºssel... in B64 kodiert zu speichern. Der Pod kann auf diese Daten zugreifen, um die erforderlichen Anmeldeinformationen zu verwenden.
- **Deployments**: Hier werden die Komponenten angegeben, die von Kubernetes ausgef√ºhrt werden sollen. Ein Benutzer arbeitet normalerweise nicht direkt mit Pods, Pods sind in **ReplicaSets** abstrahiert (Anzahl der gleichen Pods, die repliziert werden), die √ºber Deployments ausgef√ºhrt werden. Beachten Sie, dass Deployments f√ºr **zustandslose** Anwendungen gedacht sind. Die minimale Konfiguration f√ºr ein Deployment ist der Name und das auszuf√ºhrende Image.
- **StatefulSet**: Diese Komponente ist speziell f√ºr Anwendungen wie **Datenbanken** gedacht, die **auf denselben Speicher zugreifen** m√ºssen.
- **Ingress**: Dies ist die Konfiguration, die verwendet wird, um die Anwendung √∂ffentlich mit einer URL **auszusetzen**. Beachten Sie, dass dies auch mit externen Services erfolgen kann, aber dies ist der richtige Weg, um die Anwendung exponiert zu machen.
- Wenn Sie ein Ingress implementieren, m√ºssen Sie **Ingress-Controller** erstellen. Der Ingress-Controller ist ein **Pod**, der der Endpunkt sein wird, der die Anfragen empf√§ngt, √ºberpr√ºft und sie an die Services lastenausgleicht. Der Ingress-Controller wird **die Anfrage basierend auf den konfigurierten Ingress-Regeln senden**. Beachten Sie, dass die Ingress-Regeln auf verschiedene Pfade oder sogar Subdomains zu verschiedenen internen Kubernetes-Services verweisen k√∂nnen.
- Eine bessere Sicherheitspraktik w√§re es, einen Cloud-Lastenausgleich oder einen Proxy-Server als Einstiegspunkt zu verwenden, um keinen Teil des Kubernetes-Clusters exponiert zu haben.
- Wenn eine Anfrage eingeht, die keiner Ingress-Regel entspricht, wird der Ingress-Controller sie an den "**Default backend**" weiterleiten. Sie k√∂nnen den Ingress-Controller `describe` verwenden, um die Adresse dieses Parameters zu erhalten.
- `minikube addons enable ingress`

### PKI-Infrastruktur - Zertifizierungsstelle CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA ist die vertrauensw√ºrdige Wurzel f√ºr alle Zertifikate innerhalb des Clusters.
- Erm√∂glicht es Komponenten, sich gegenseitig zu validieren.
- Alle Clusterzertifikate werden von der CA signiert.
- etcd hat sein eigenes Zertifikat.
- Typen:
- apiserver-Zertifikat.
- kubelet-Zertifikat.
- scheduler-Zertifikat.

## Grundlegende Aktionen

### Minikube

**Minikube** kann verwendet werden, um einige **schnelle Tests** auf Kubernetes durchzuf√ºhren, ohne eine vollst√§ndige Kubernetes-Umgebung bereitstellen zu m√ºssen. Es wird die **Master- und Node-Prozesse auf einer Maschine** ausf√ºhren. Minikube verwendet VirtualBox, um den Node auszuf√ºhren. Siehe [**hier, wie man es installiert**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Grundlagen

**`Kubectl`** ist das Befehlszeilenwerkzeug f√ºr Kubernetes-Cluster. Es kommuniziert mit dem API-Server des Master-Prozesses, um Aktionen in Kubernetes auszuf√ºhren oder um Daten anzufordern.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Das Dashboard erm√∂glicht es Ihnen, einfacher zu sehen, was Minikube ausf√ºhrt. Sie finden die URL, um darauf zuzugreifen, in:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML-Konfigurationsdateien Beispiele

Jede Konfigurationsdatei hat 3 Teile: **Metadaten**, **Spezifikation** (was gestartet werden muss), **Status** (gew√ºnschter Zustand).\
Innerhalb der Spezifikation der Bereitstellungskonfigurationsdatei finden Sie die Vorlage, die mit einer neuen Konfigurationsstruktur definiert ist, die das auszuf√ºhrende Image definiert:

**Beispiel f√ºr Bereitstellung + Dienst, die in derselben Konfigurationsdatei deklariert sind (von** [**hier**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Da ein Dienst normalerweise mit einer Bereitstellung verbunden ist, ist es m√∂glich, beide in derselben Konfigurationsdatei zu deklarieren (der in dieser Konfiguration deklarierte Dienst ist nur intern zug√§nglich):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Beispiel f√ºr die Konfiguration eines externen Dienstes**

Dieser Dienst wird extern zug√§nglich sein (√ºberpr√ºfen Sie die Attribute `nodePort` und `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Dies ist n√ºtzlich f√ºr Tests, aber f√ºr die Produktion sollten Sie nur interne Dienste und ein Ingress haben, um die Anwendung bereitzustellen.

**Beispiel einer Ingress-Konfigurationsdatei**

Dies wird die Anwendung unter `http://dashboard.com` bereitstellen.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Beispiel einer Geheimnisse-Konfigurationsdatei**

Beachten Sie, dass die Passw√∂rter in B64 codiert sind (was nicht sicher ist!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Beispiel f√ºr ConfigMap**

Eine **ConfigMap** ist die Konfiguration, die den Pods gegeben wird, damit sie wissen, wie sie andere Dienste finden und darauf zugreifen k√∂nnen. In diesem Fall wird jeder Pod wissen, dass der Name `mongodb-service` die Adresse eines Pods ist, mit dem sie kommunizieren k√∂nnen (dieser Pod wird ein mongodb ausf√ºhren):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Dann kann diese Adresse innerhalb einer **Deployment-Konfiguration** folgenderma√üen angegeben werden, damit sie in die Umgebungsvariablen des Pods geladen wird:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Beispiel f√ºr die Volumen-Konfiguration**

Sie finden verschiedene Beispiele f√ºr Speicher-Konfigurations-YAML-Dateien in [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Beachten Sie, dass Volumes nicht innerhalb von Namespaces sind**

### Namespaces

Kubernetes unterst√ºtzt **mehrere virtuelle Cluster**, die von demselben physischen Cluster unterst√ºtzt werden. Diese virtuellen Cluster werden **Namespaces** genannt. Sie sind f√ºr den Einsatz in Umgebungen mit vielen Benutzern, die √ºber mehrere Teams oder Projekte verteilt sind, gedacht. F√ºr Cluster mit wenigen bis mehreren Dutzend Benutzern sollten Sie keine Namespaces erstellen oder dar√ºber nachdenken m√ºssen. Sie sollten nur beginnen, Namespaces zu verwenden, um eine bessere Kontrolle und Organisation jedes Teils der in Kubernetes bereitgestellten Anwendung zu haben.

Namespaces bieten einen Geltungsbereich f√ºr Namen. Die Namen von Ressourcen m√ºssen innerhalb eines Namespaces eindeutig sein, jedoch nicht √ºber Namespaces hinweg. Namespaces k√∂nnen nicht ineinander geschachtelt werden und **jede** Kubernetes **Ressource** kann nur **in** **einem** **Namespace** sein.

Es gibt standardm√§√üig 4 Namespaces, wenn Sie Minikube verwenden:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: Es ist nicht f√ºr die Benutzer gedacht und Sie sollten es nicht anfassen. Es ist f√ºr Master- und kubectl-Prozesse.
- **kube-public**: √ñffentlich zug√§ngliche Daten. Enth√§lt ein ConfigMap, das Clusterinformationen enth√§lt.
- **kube-node-lease**: Bestimmt die Verf√ºgbarkeit eines Knotens.
- **default**: Der Namespace, den der Benutzer verwenden wird, um Ressourcen zu erstellen.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Beachten Sie, dass die meisten Kubernetes-Ressourcen (z. B. Pods, Dienste, Replikationscontroller und andere) in einigen Namespaces sind. Andere Ressourcen wie Namespace-Ressourcen und Low-Level-Ressourcen, wie Knoten und persistentVolumes, sind jedoch nicht in einem Namespace. Um zu sehen, welche Kubernetes-Ressourcen sich in einem Namespace befinden und welche nicht:
>
> ```bash
> kubectl api-resources --namespaced=true #In einem Namespace
> kubectl api-resources --namespaced=false #Nicht in einem Namespace
> ```

Sie k√∂nnen den Namespace f√ºr alle nachfolgenden kubectl-Befehle in diesem Kontext speichern.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm ist der **Paketmanager** f√ºr Kubernetes. Er erm√∂glicht das Verpacken von YAML-Dateien und deren Verteilung in √∂ffentlichen und privaten Repositories. Diese Pakete werden **Helm Charts** genannt.
```
helm search <keyword>
```
Helm ist auch eine Template-Engine, die es erm√∂glicht, Konfigurationsdateien mit Variablen zu generieren:

## Kubernetes Secrets

Ein **Secret** ist ein Objekt, das **sensible Daten** wie ein Passwort, ein Token oder einen Schl√ºssel **enth√§lt**. Solche Informationen k√∂nnten andernfalls in einer Pod-Spezifikation oder in einem Image abgelegt werden. Benutzer k√∂nnen Secrets erstellen und das System erstellt ebenfalls Secrets. Der Name eines Secret-Objekts muss ein g√ºltiger **DNS-Subdom√§nenname** sein. Lesen Sie hier [die offizielle Dokumentation](https://kubernetes.io/docs/concepts/configuration/secret/).

Secrets k√∂nnen Dinge sein wie:

- API, SSH-Schl√ºssel.
- OAuth-Token.
- Anmeldeinformationen, Passw√∂rter (im Klartext oder b64 + Verschl√ºsselung).
- Informationen oder Kommentare.
- Datenbankverbindungs-Code, Strings‚Ä¶ .

Es gibt verschiedene Arten von Secrets in Kubernetes

| Eingebauter Typ                      | Verwendung                                 |
| ------------------------------------- | ------------------------------------------ |
| **Opaque**                            | **willk√ºrliche benutzerdefinierte Daten (Standard)** |
| kubernetes.io/service-account-token   | Token des Dienstkontos                    |
| kubernetes.io/dockercfg               | serialisierte \~/.dockercfg-Datei         |
| kubernetes.io/dockerconfigjson        | serialisierte \~/.docker/config.json-Datei |
| kubernetes.io/basic-auth              | Anmeldeinformationen f√ºr die grundlegende Authentifizierung |
| kubernetes.io/ssh-auth                | Anmeldeinformationen f√ºr die SSH-Authentifizierung |
| kubernetes.io/tls                     | Daten f√ºr einen TLS-Client oder -Server   |
| bootstrap.kubernetes.io/token         | Bootstrap-Token-Daten                     |

> [!NOTE]
> **Der Opaque-Typ ist der Standardtyp, das typische Schl√ºssel-Wert-Paar, das von Benutzern definiert wird.**

**Wie Secrets funktionieren:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Die folgende Konfigurationsdatei definiert ein **Secret** namens `mysecret` mit 2 Schl√ºssel-Wert-Paaren `username: YWRtaW4=` und `password: MWYyZDFlMmU2N2Rm`. Sie definiert auch einen **Pod** namens `secretpod`, der die in `mysecret` definierten `username` und `password` in den **Umgebungsvariablen** `SECRET_USERNAME` \_\_ und \_\_ `SECRET_PASSWOR` verf√ºgbar macht. Es wird auch das `username`-Secret innerhalb von `mysecret` im Pfad `/etc/foo/my-group/my-username` mit `0640` Berechtigungen **gemountet**.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** ist ein konsistenter und hochverf√ºgbarer **Key-Value-Speicher**, der als Kubernetes-Backend-Speicher f√ºr alle Cluster-Daten verwendet wird. Lassen Sie uns auf die in etcd gespeicherten Geheimnisse zugreifen:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Sie werden sehen, dass Zertifikate, Schl√ºssel und URLs im Dateisystem (FS) gespeichert sind. Sobald Sie diese haben, k√∂nnen Sie sich mit etcd verbinden.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Sobald Sie die Kommunikation hergestellt haben, k√∂nnen Sie die Geheimnisse erhalten:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Verschl√ºsselung zum ETCD hinzuf√ºgen**

Standardm√§√üig werden alle Geheimnisse **im Klartext** in etcd gespeichert, es sei denn, Sie wenden eine Verschl√ºsselungsschicht an. Das folgende Beispiel basiert auf [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Danach m√ºssen Sie das Flag `--encryption-provider-config` auf dem `kube-apiserver` setzen, um auf den Speicherort der erstellten Konfigurationsdatei zu verweisen. Sie k√∂nnen `/etc/kubernetes/manifest/kube-apiserver.yaml` bearbeiten und die folgenden Zeilen hinzuf√ºgen:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Scrollen Sie nach unten in den volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Scrollen Sie nach unten in den volumeMounts zu hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**√úberpr√ºfen, ob Daten verschl√ºsselt sind**

Daten werden verschl√ºsselt, wenn sie in etcd geschrieben werden. Nach dem Neustart Ihres `kube-apiserver` sollte jedes neu erstellte oder aktualisierte Geheimnis verschl√ºsselt gespeichert werden. Um dies zu √ºberpr√ºfen, k√∂nnen Sie das `etcdctl`-Befehlszeilenprogramm verwenden, um den Inhalt Ihres Geheimnisses abzurufen.

1.  Erstellen Sie ein neues Geheimnis mit dem Namen `secret1` im `default`-Namespace:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  Lesen Sie dieses Geheimnis mit dem etcdctl-Befehlszeilenprogramm aus etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

wobei `[...]` die zus√§tzlichen Argumente f√ºr die Verbindung zum etcd-Server sein m√ºssen.

3.  √úberpr√ºfen Sie, ob das gespeicherte Geheimnis mit `k8s:enc:aescbc:v1:` vorangestellt ist, was darauf hinweist, dass der `aescbc`-Provider die resultierenden Daten verschl√ºsselt hat.
4.  √úberpr√ºfen Sie, ob das Geheimnis korrekt entschl√ºsselt wird, wenn es √ºber die API abgerufen wird:

```
kubectl describe secret secret1 -n default
```

sollte `mykey: bXlkYXRh` entsprechen, mydata ist kodiert, √ºberpr√ºfen Sie [decoding a secret](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret), um das Geheimnis vollst√§ndig zu dekodieren.

**Da Geheimnisse beim Schreiben verschl√ºsselt werden, wird das Aktualisieren eines Geheimnisses diesen Inhalt verschl√ºsseln:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Abschlie√üende Tipps:**

- Versuche, keine Geheimnisse im FS zu speichern, hole sie dir aus anderen Quellen.
- Schau dir [https://www.vaultproject.io/](https://www.vaultproject.io) an, um zus√§tzlichen Schutz f√ºr deine Geheimnisse zu erhalten.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Referenzen

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
