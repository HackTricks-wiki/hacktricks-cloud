# Msingi wa Kubernetes

## Msingi wa Kubernetes

{{#include ../../banners/hacktricks-training.md}}

**Mwandishi wa awali wa ukurasa huu ni** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(soma chapisho lake la awali** [**hapa**](https://sickrov.github.io)**)**

## Muktadha & Msingi

### Kubernetes inafanya nini?

- Inaruhusu kuendesha kontena/kontena katika injini ya kontena.
- Ratiba inaruhusu misheni ya kontena kuwa na ufanisi.
- Inahakikisha kontena zinabaki hai.
- Inaruhusu mawasiliano ya kontena.
- Inaruhusu mbinu za kutekeleza.
- Inashughulikia kiasi cha taarifa.

### Muktadha

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Node**: mfumo wa uendeshaji wenye pod au pods.
- **Pod**: Kifungashio kilichozunguka kontena au kontena nyingi. Pod inapaswa kuwa na programu moja tu (hivyo kawaida, pod inakimbia kontena 1 tu). Pod ndiyo njia ambayo kubernetes inafanya teknolojia ya kontena kuwa rahisi.
- **Huduma**: Kila pod ina **anwani ya IP** 1 ya ndani kutoka kwa anuwai ya ndani ya node. Hata hivyo, inaweza pia kufichuliwa kupitia huduma. **Huduma pia ina anwani ya IP** na lengo lake ni kudumisha mawasiliano kati ya pods ili ikiwa moja itakufa **mbadala mpya** (ikiwa na IP ya ndani tofauti) **itaweza kufikiwa** ikifichuliwa katika **IP ile ile ya huduma**. Inaweza kuwekewa mipangilio kama ya ndani au ya nje. Huduma pia inafanya kazi kama **mshiriki wa mzigo wakati pods 2 zimeunganishwa** kwenye huduma ile ile.\
Wakati **huduma** inaundwa unaweza kupata viunganishi vya kila huduma kwa kukimbia `kubectl get endpoints`
- **Kubelet**: Wakala mkuu wa node. Kipengele kinachoweka mawasiliano kati ya node na kubectl, na kinaweza tu kuendesha pods (kupitia API server). Kubelet haiwezi kudhibiti kontena ambazo hazikuundwa na Kubernetes.
- **Kube-proxy**: ni huduma inayosimamia mawasiliano (huduma) kati ya apiserver na node. Msingi ni IPtables kwa nodes. Watumiaji wenye uzoefu zaidi wanaweza kufunga kube-proxies nyingine kutoka kwa wauzaji wengine.
- **Sidecar container**: Sidecar containers ni kontena ambazo zinapaswa kuendesha pamoja na kontena kuu katika pod. Mwelekeo huu wa sidecar unapanua na kuboresha kazi za kontena za sasa bila kuzibadilisha. Siku hizi, tunajua kwamba tunatumia teknolojia ya kontena kufunga utegemezi wote ili programu ifanye kazi popote. Kontena inafanya kitu kimoja tu na inafanya hicho vizuri sana.
- **Mchakato mkuu:**
- **Api Server:** Ni njia ambayo watumiaji na pods hutumia kuwasiliana na mchakato mkuu. Maombi tu yaliyothibitishwa yanapaswa kuruhusiwa.
- **Ratibu**: Ratiba inahusisha kuhakikisha kwamba Pods zinapatana na Nodes ili Kubelet iweze kuziendesha. Ina akili ya kutosha kuamua ni node ipi ina rasilimali zaidi zinazopatikana na kupeana pod mpya kwake. Kumbuka kwamba ratibu haianzishi pods mpya, inawasiliana tu na mchakato wa Kubelet unaokimbia ndani ya node, ambayo itazindua pod mpya.
- **Meneja wa Kube Controller**: Inakagua rasilimali kama seti za replica au kutekeleza ili kuangalia ikiwa, kwa mfano, idadi sahihi ya pods au nodes inakimbia. Ikiwa pod inakosekana, itawasiliana na ratibu kuanzisha mpya. Inadhibiti uzalishaji, tokeni, na huduma za akaunti kwa API.
- **etcd**: Hifadhi ya data, ya kudumu, thabiti, na iliyosambazwa. Ni hifadhidata ya Kubernetes na hifadhi ya funguo-thamani ambapo inahifadhi hali kamili ya makundi (kila mabadiliko yanarekodiwa hapa). Vipengele kama Ratibu au Meneja wa Controller vinategemea tarehe hii kujua ni mabadiliko gani yamefanyika (rasilimali zinazopatikana za nodes, idadi ya pods zinazokimbia...)
- **Meneja wa Cloud controller**: Ni meneja maalum wa udhibiti wa mtiririko na programu, yaani: ikiwa una makundi katika AWS au OpenStack.

Kumbuka kwamba kama kuna nodes kadhaa (zinazoendesha pods kadhaa), pia kuna mchakato kadhaa mkuu ambao ufikiaji wao kwa Api server umewekwa sawa na etcd zao zimeunganishwa.

**Vikundi:**

Wakati pod inaunda data ambayo haipaswi kupotea wakati pod inatoweka inapaswa kuhifadhiwa katika kikundi cha kimwili. **Kubernetes inaruhusu kuunganisha kikundi kwa pod ili kudumisha data**. Kikundi kinaweza kuwa katika mashine ya ndani au katika **hifadhi ya mbali**. Ikiwa unakimbia pods katika nodes tofauti za kimwili unapaswa kutumia hifadhi ya mbali ili pods zote ziweze kuifikia.

**Mipangilio mingine:**

- **ConfigMap**: Unaweza kuunda **URLs** za kufikia huduma. Pod itapata data kutoka hapa ili kujua jinsi ya kuwasiliana na huduma zingine (pods). Kumbuka kwamba hii si mahali panapopendekezwa kuhifadhi hati za siri!
- **Siri**: Hapa ndiko **kuhifadhi data za siri** kama nywila, funguo za API... zilizokodishwa kwa B64. Pod itakuwa na uwezo wa kufikia data hii ili kutumia hati zinazohitajika.
- **Mtekelezaji**: Hapa ndipo vipengele vinavyopaswa kuendeshwa na kubernetes vinapoonyeshwa. Mtumiaji kwa kawaida hatofanya kazi moja kwa moja na pods, pods zimefichwa katika **ReplicaSets** (idadi ya pods sawa zilizorejelewa), ambazo zinaendeshwa kupitia mtekelezaji. Kumbuka kwamba mtekelezaji ni kwa ajili ya programu **zisizo na hali**. Mipangilio ya chini kabisa ya mtekelezaji ni jina na picha ya kuendesha.
- **StatefulSet**: Kipengele hiki kimekusudiwa hasa kwa programu kama **hifadhidata** ambazo zinahitaji **kufikia hifadhi ile ile**.
- **Ingress**: Hii ni mipangilio inayotumika **kufichua programu hadharani kwa URL**. Kumbuka kwamba hii inaweza pia kufanywa kwa kutumia huduma za nje, lakini hii ndiyo njia sahihi ya kufichua programu.
- Ikiwa unatekeleza Ingress utahitaji kuunda **Ingress Controllers**. Ingress Controller ni **pod** ambayo itakuwa kiunganishi kitakachopokea maombi na kuangalia na kupakia mizigo kwa huduma. Ingress controller it **tuma ombi kulingana na sheria za ingress zilizowekwa**. Kumbuka kwamba sheria za ingress zinaweza kuelekeza kwenye njia tofauti au hata subdomains kwa huduma tofauti za ndani za kubernetes.
- Praktiki bora za usalama zingekuwa kutumia mshiriki wa mzigo wa wingu au seva ya proxy kama kiingilio ili kusiwe na sehemu yoyote ya kundi la Kubernetes iliyofichuliwa.
- Wakati ombi ambalo halifai sheria yoyote ya ingress linapokelewa, ingress controller italipeleka kwa "**Backend ya Kawaida**". Unaweza `describe` ingress controller ili kupata anwani ya kiparameter hiki.
- `minikube addons enable ingress`

### Miundombinu ya PKI - Mamlaka ya Cheti CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA ni mzizi unaotegemewa kwa vyeti vyote ndani ya kundi.
- Inaruhusu vipengele kuthibitisha kwa kila mmoja.
- Vyeti vyote vya kundi vinatiwa saini na CA.
- ETCd ina cheti chake mwenyewe.
- aina:
- cheti cha apiserver.
- cheti cha kubelet.
- cheti cha ratibu.

## Vitendo vya Msingi

### Minikube

**Minikube** inaweza kutumika kufanya **majaribio ya haraka** kwenye kubernetes bila kuhitaji kupeleka mazingira yote ya kubernetes. Itakimbia **mchakato mkuu na wa node katika mashine moja**. Minikube itatumia virtualbox kuendesha node. Tazama [**hapa jinsi ya kuisakinisha**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Msingi wa Kubectl

**`Kubectl`** ni chombo cha mistari ya amri kwa ajili ya makundi ya kubernetes. Kinawasiliana na seva ya Api ya mchakato mkuu ili kutekeleza vitendo katika kubernetes au kuomba data.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Dashibodi inakuwezesha kuona kwa urahisi kile minikube inachokimbia, unaweza kupata URL ya kuifikia katika:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Mifano ya faili za usanidi wa YAML

Kila faili la usanidi lina sehemu 3: **metadata**, **specification** (kitu kinachohitajika kuanzishwa), **status** (hali inayotakiwa).\
Ndani ya specification ya faili la usanidi wa uanzishaji unaweza kupata kiolezo kilichofafanuliwa na muundo mpya wa usanidi unaofafanua picha ya kuendesha:

**Mfano wa Uanzishaji + Huduma iliyotangazwa katika faili moja la usanidi (kutoka** [**hapa**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Kama huduma kwa kawaida inahusishwa na uanzishaji mmoja, inawezekana kutangaza zote mbili katika faili moja la usanidi (huduma iliyotangazwa katika usanidi huu inapatikana tu ndani):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Mfano wa usanidi wa huduma ya nje**

Huduma hii itapatikana nje (angalia sifa za `nodePort` na `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Hii ni muhimu kwa majaribio lakini kwa uzalishaji unapaswa kuwa na huduma za ndani tu na Ingress ili kufichua programu.

**Mfano wa faili ya usanidi wa Ingress**

Hii itafichua programu katika `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Mfano wa faili ya usanidi wa siri**

Kumbuka jinsi nywila zilivyoandikwa kwa B64 (ambayo si salama!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Mfano wa ConfigMap**

A **ConfigMap** ni usanidi ambao unapeanwa kwa pods ili wajue jinsi ya kutafuta na kufikia huduma nyingine. Katika kesi hii, kila pod itajua kwamba jina `mongodb-service` ni anwani ya pod ambayo wanaweza kuwasiliana nayo (hii pod itakuwa ikitekeleza mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Kisha, ndani ya **deployment config** anwani hii inaweza kuainishwa kwa njia ifuatayo ili ipakuliwe ndani ya env ya pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Mfano wa usanidi wa volumu**

You can find different example of storage configuration yaml files in [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Kumbuka kwamba volumu si ndani ya namespaces**

### Namespaces

Kubernetes supports **multiple virtual clusters** backed by the same physical cluster. These virtual clusters are called **namespaces**. These are intended for use in environments with many users spread across multiple teams, or projects. For clusters with a few to tens of users, you should not need to create or think about namespaces at all. You only should start using namespaces to have a better control and organization of each part of the application deployed in kubernetes.

Namespaces provide a scope for names. Names of resources need to be unique within a namespace, but not across namespaces. Namespaces cannot be nested inside one another and **each** Kubernetes **resource** can only be **in** **one** **namespace**.

There are 4 namespaces by default if you are using minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: Haikusudiwi kwa matumizi ya watumiaji na haupaswi kuguswa. Ni kwa ajili ya mchakato wa master na kubectl.
- **kube-public**: Taarifa inayopatikana hadharani. Inajumuisha configmap ambayo ina taarifa za klasta.
- **kube-node-lease**: Inabaini upatikanaji wa node.
- **default**: Namespace ambayo mtumiaji atatumia kuunda rasilimali.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Kumbuka kwamba rasilimali nyingi za Kubernetes (k.m. pods, services, replication controllers, na nyinginezo) ziko katika majina fulani. Hata hivyo, rasilimali nyingine kama rasilimali za namespace na rasilimali za kiwango cha chini, kama nodes na persistenVolumes haziko katika namespace. Ili kuona ni rasilimali zipi za Kubernetes ziko na haziko katika namespace:
>
> ```bash
> kubectl api-resources --namespaced=true #Katika namespace
> kubectl api-resources --namespaced=false #Hazi katika namespace
> ```

Unaweza kuhifadhi namespace kwa amri zote za kubectl zinazofuata katika muktadha huo.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm ni **meneja wa kifurushi** kwa Kubernetes. Inaruhusu kufunga faili za YAML na kuzisambaza katika hifadhi za umma na za kibinafsi. Kifurushi hizi zinaitwa **Helm Charts**.
```
helm search <keyword>
```
Helm pia ni injini ya kigezo inayoruhusu kuunda faili za usanidi zenye mabadiliko:

## Siri za Kubernetes

**Siri** ni kitu ambacho **kina data nyeti** kama vile nenosiri, token au ufunguo. Taarifa kama hizo zinaweza kuwekwa katika spesifikesheni ya Pod au katika picha. Watumiaji wanaweza kuunda Siri na mfumo pia huunda Siri. Jina la kitu cha Siri lazima liwe jina halali la **DNS subdomain**. Soma hapa [nyaraka rasmi](https://kubernetes.io/docs/concepts/configuration/secret/).

Siri zinaweza kuwa vitu kama:

- API, SSH Keys.
- OAuth tokens.
- Credentials, Passwords (plain text au b64 + encryption).
- Taarifa au maoni.
- Msimbo wa muunganisho wa database, nyuzi‚Ä¶ .

Kuna aina tofauti za siri katika Kubernetes

| Aina ya Builtin                     | Matumizi                                   |
| ----------------------------------- | ------------------------------------------ |
| **Opaque**                          | **data isiyo na mpangilio iliyofafanuliwa na mtumiaji (Default)** |
| kubernetes.io/service-account-token | token ya akaunti ya huduma                 |
| kubernetes.io/dockercfg             | faili ya \~/.dockercfg iliyosimbwa         |
| kubernetes.io/dockerconfigjson      | faili ya \~/.docker/config.json iliyosimbwa |
| kubernetes.io/basic-auth            | credentials kwa uthibitishaji wa msingi    |
| kubernetes.io/ssh-auth              | credentials kwa uthibitishaji wa SSH       |
| kubernetes.io/tls                   | data kwa mteja au seva ya TLS              |
| bootstrap.kubernetes.io/token       | data ya token ya bootstrap                  |

> [!NOTE]
> **Aina ya Opaque ndiyo ya default, jozi ya kawaida ya funguo-thamani iliyofafanuliwa na watumiaji.**

**Jinsi siri zinavyofanya kazi:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Faili ya usanidi ifuatayo inafafanua **siri** inayoitwa `mysecret` yenye jozi 2 za funguo-thamani `username: YWRtaW4=` na `password: MWYyZDFlMmU2N2Rm`. Pia inafafanua **pod** inayoitwa `secretpod` ambayo itakuwa na `username` na `password` zilizofafanuliwa katika `mysecret` zikiwa wazi katika **mabadiliko ya mazingira** `SECRET_USERNAME` \_\_ na \_\_ `SECRET_PASSWOR`. Pia itakuwa **imeweka** siri ya `username` ndani ya `mysecret` katika njia `/etc/foo/my-group/my-username` ikiwa na ruhusa `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Siri katika etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** ni duka la **key-value** linalofanya kazi kwa usahihi na lina upatikanaji wa juu ambalo linatumika kama duka la nyuma la Kubernetes kwa data zote za klasta. Hebu tuingie kwenye siri zilizohifadhiwa katika etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Utapata vyeti, funguo na URL ambazo ziko katika FS. Mara utakapovipata, utaweza kuungana na etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Mara tu unapofanikiwa kuanzisha mawasiliano utaweza kupata siri:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Kuongeza usimbaji fiche kwa ETCD**

Kwa default, siri zote **zinahifadhiwa kwa maandiko** wazi ndani ya etcd isipokuwa uweke safu ya usimbaji fiche. Mfano ufuatao unategemea [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Baada ya hapo, unahitaji kuweka bendera ya `--encryption-provider-config` kwenye `kube-apiserver` kuonyesha mahali ilipo faili ya usanidi iliyoundwa. Unaweza kubadilisha `/etc/kubernetes/manifest/kube-apiserver.yaml` na kuongeza mistari ifuatayo:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Piga chini katika volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Piga chini katika volumeMounts hadi hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Kuthibitisha kwamba data imeandikwa kwa usalama**

Data imeandikwa kwa usalama inapokuwa imeandikwa kwenye etcd. Baada ya kuanzisha upya `kube-apiserver` yako, siri yoyote mpya iliyoundwa au iliyosasishwa inapaswa kuwa imeandikwa kwa usalama inapohifadhiwa. Ili kuangalia, unaweza kutumia programu ya amri ya `etcdctl` kupata maudhui ya siri yako.

1.  Unda siri mpya inayoitwa `secret1` katika eneo la `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  Kwa kutumia amri ya etcdctl, soma siri hiyo kutoka etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

ambapo `[...]` lazima iwe ni hoja za ziada za kuungana na seva ya etcd.

3.  Kuthibitisha kwamba siri iliyohifadhiwa ina mwanzo wa `k8s:enc:aescbc:v1:` ambayo inaonyesha kuwa mtoa huduma wa `aescbc` ameandika data inayotokana.
4.  Kuthibitisha kwamba siri imeandikwa kwa usahihi inapopatikana kupitia API:

```
kubectl describe secret secret1 -n default
```

inapaswa kulingana na `mykey: bXlkYXRh`, mydata imeandikwa, angalia [decoding a secret](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) ili kufungua siri hiyo kabisa.

**Kwa kuwa siri zimeandikwa kwa usalama, kufanya sasisho kwenye siri kutandika maudhui hayo:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Vidokezo vya Mwisho:**

- Jaribu kutoweka siri katika FS, zipate kutoka sehemu nyingine.
- Angalia [https://www.vaultproject.io/](https://www.vaultproject.io) kuongeza ulinzi zaidi kwa siri zako.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Marejeo

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
