# Kubernetes Basics

## Kubernetes Basics

{{#include ../../banners/hacktricks-training.md}}

**L'auteur original de cette page est** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lisez son post original** [**ici**](https://sickrov.github.io)**)**

## Architecture & Basics

### Que fait Kubernetes ?

- Permet d'ex√©cuter des conteneurs dans un moteur de conteneurs.
- La planification permet une mission efficace des conteneurs.
- Maintient les conteneurs en vie.
- Permet les communications entre conteneurs.
- Permet des techniques de d√©ploiement.
- G√®re des volumes d'informations.

### Architecture

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Node** : syst√®me d'exploitation avec pod ou pods.
- **Pod** : Enveloppe autour d'un conteneur ou de plusieurs conteneurs. Un pod ne doit contenir qu'une seule application (donc g√©n√©ralement, un pod ex√©cute juste 1 conteneur). Le pod est la mani√®re dont Kubernetes abstrait la technologie des conteneurs en cours d'ex√©cution.
- **Service** : Chaque pod a 1 **adresse IP interne** de la plage interne du n≈ìud. Cependant, il peut √©galement √™tre expos√© via un service. Le **service a √©galement une adresse IP** et son objectif est de maintenir la communication entre les pods, donc si l'un meurt, le **nouveau remplacement** (avec une adresse IP interne diff√©rente) **sera accessible** expos√© √† la **m√™me IP du service**. Il peut √™tre configur√© comme interne ou externe. Le service agit √©galement comme un **√©quilibreur de charge lorsque 2 pods sont connect√©s** au m√™me service.\
Lorsque un **service** est **cr√©√©**, vous pouvez trouver les points de terminaison de chaque service en ex√©cutant `kubectl get endpoints`
- **Kubelet** : Agent principal du n≈ìud. Le composant qui √©tablit la communication entre le n≈ìud et kubectl, et ne peut ex√©cuter que des pods (via l'API server). Le kubelet ne g√®re pas les conteneurs qui n'ont pas √©t√© cr√©√©s par Kubernetes.
- **Kube-proxy** : est le service charg√© des communications (services) entre l'apiserver et le n≈ìud. La base est un IPtables pour les n≈ìuds. Les utilisateurs les plus exp√©riment√©s pourraient installer d'autres kube-proxies d'autres fournisseurs.
- **Sidecar container** : Les conteneurs sidecar sont les conteneurs qui doivent s'ex√©cuter avec le conteneur principal dans le pod. Ce mod√®le sidecar √©tend et am√©liore la fonctionnalit√© des conteneurs actuels sans les modifier. De nos jours, nous savons que nous utilisons la technologie des conteneurs pour envelopper toutes les d√©pendances n√©cessaires au fonctionnement de l'application n'importe o√π. Un conteneur ne fait qu'une seule chose et le fait tr√®s bien.
- **Master process :**
- **Api Server :** C'est la mani√®re dont les utilisateurs et les pods communiquent avec le processus ma√Ætre. Seules les requ√™tes authentifi√©es doivent √™tre autoris√©es.
- **Scheduler** : La planification fait r√©f√©rence √† s'assurer que les Pods sont associ√©s aux N≈ìuds afin que Kubelet puisse les ex√©cuter. Il a suffisamment d'intelligence pour d√©cider quel n≈ìud a le plus de ressources disponibles et attribuer le nouveau pod √† celui-ci. Notez que le planificateur ne d√©marre pas de nouveaux pods, il communique simplement avec le processus Kubelet en cours d'ex√©cution √† l'int√©rieur du n≈ìud, qui lancera le nouveau pod.
- **Kube Controller manager** : Il v√©rifie les ressources comme les ensembles de r√©plicas ou les d√©ploiements pour v√©rifier si, par exemple, le nombre correct de pods ou de n≈ìuds est en cours d'ex√©cution. En cas de pod manquant, il communiquera avec le planificateur pour en d√©marrer un nouveau. Il contr√¥le la r√©plication, les jetons et les services de compte √† l'API.
- **etcd** : Stockage de donn√©es, persistant, coh√©rent et distribu√©. C'est la base de donn√©es de Kubernetes et le stockage cl√©-valeur o√π il conserve l'√©tat complet des clusters (chaque changement est enregistr√© ici). Des composants comme le Scheduler ou le Controller manager d√©pendent de ces donn√©es pour savoir quels changements ont eu lieu (ressources disponibles des n≈ìuds, nombre de pods en cours d'ex√©cution...)
- **Cloud controller manager** : C'est le contr√¥leur sp√©cifique pour les contr√¥les de flux et les applications, c'est-√†-dire : si vous avez des clusters dans AWS ou OpenStack.

Notez qu'il peut y avoir plusieurs n≈ìuds (ex√©cutant plusieurs pods), il peut √©galement y avoir plusieurs processus ma√Ætres dont l'acc√®s √† l'Api server est √©quilibr√© et leur etcd synchronis√©.

**Volumes :**

Lorsqu'un pod cr√©e des donn√©es qui ne doivent pas √™tre perdues lorsque le pod dispara√Æt, elles doivent √™tre stock√©es dans un volume physique. **Kubernetes permet d'attacher un volume √† un pod pour persister les donn√©es**. Le volume peut √™tre sur la machine locale ou dans un **stockage distant**. Si vous ex√©cutez des pods sur diff√©rents n≈ìuds physiques, vous devez utiliser un stockage distant afin que tous les pods puissent y acc√©der.

**Autres configurations :**

- **ConfigMap** : Vous pouvez configurer des **URLs** pour acc√©der aux services. Le pod obtiendra des donn√©es d'ici pour savoir comment communiquer avec le reste des services (pods). Notez que ce n'est pas l'endroit recommand√© pour enregistrer des identifiants !
- **Secret** : C'est l'endroit pour **stocker des donn√©es secr√®tes** comme des mots de passe, des cl√©s API... encod√©es en B64. Le pod pourra acc√©der √† ces donn√©es pour utiliser les identifiants requis.
- **Deployments** : C'est ici que les composants √† ex√©cuter par Kubernetes sont indiqu√©s. Un utilisateur ne travaillera g√©n√©ralement pas directement avec des pods, les pods sont abstraits dans des **ReplicaSets** (nombre de m√™mes pods r√©pliqu√©s), qui sont ex√©cut√©s via des d√©ploiements. Notez que les d√©ploiements sont pour des applications **sans √©tat**. La configuration minimale pour un d√©ploiement est le nom et l'image √† ex√©cuter.
- **StatefulSet** : Ce composant est sp√©cifiquement destin√© aux applications comme les **bases de donn√©es** qui ont besoin d'**acc√©der au m√™me stockage**.
- **Ingress** : C'est la configuration utilis√©e pour **exposer l'application publiquement avec une URL**. Notez que cela peut √©galement √™tre fait en utilisant des services externes, mais c'est la mani√®re correcte d'exposer l'application.
- Si vous impl√©mentez un Ingress, vous devrez cr√©er des **Ingress Controllers**. L'Ingress Controller est un **pod** qui sera le point de terminaison qui recevra les requ√™tes et les v√©rifiera et les √©quilibrera vers les services. L'Ingress Controller **enverra la requ√™te en fonction des r√®gles d'ingress configur√©es**. Notez que les r√®gles d'ingress peuvent pointer vers diff√©rents chemins ou m√™me des sous-domaines vers diff√©rents services Kubernetes internes.
- Une meilleure pratique de s√©curit√© serait d'utiliser un √©quilibreur de charge cloud ou un serveur proxy comme point d'entr√©e pour ne pas avoir de partie du cluster Kubernetes expos√©e.
- Lorsque une requ√™te qui ne correspond √† aucune r√®gle d'ingress est re√ßue, l'Ingress Controller la dirigera vers le "**Default backend**". Vous pouvez `describe` l'Ingress Controller pour obtenir l'adresse de ce param√®tre.
- `minikube addons enable ingress`

### Infrastructure PKI - Autorit√© de Certification CA :

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA est la racine de confiance pour tous les certificats √† l'int√©rieur du cluster.
- Permet aux composants de se valider mutuellement.
- Tous les certificats du cluster sont sign√©s par la CA.
- ETCd a son propre certificat.
- types :
- certificat apiserver.
- certificat kubelet.
- certificat scheduler.

## Actions de base

### Minikube

**Minikube** peut √™tre utilis√© pour effectuer des **tests rapides** sur Kubernetes sans avoir besoin de d√©ployer un environnement Kubernetes complet. Il ex√©cutera les **processus ma√Ætre et n≈ìud sur une seule machine**. Minikube utilisera VirtualBox pour ex√©cuter le n≈ìud. Voir [**ici comment l'installer**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Basics

**`Kubectl`** est l'outil en ligne de commande pour les clusters kubernetes. Il communique avec le serveur Api du processus ma√Ætre pour effectuer des actions dans kubernetes ou pour demander des donn√©es.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Le tableau de bord vous permet de voir plus facilement ce que minikube ex√©cute, vous pouvez trouver l'URL pour y acc√©der dans :
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Exemples de fichiers de configuration YAML

Chaque fichier de configuration a 3 parties : **m√©tadonn√©es**, **sp√©cification** (ce qui doit √™tre lanc√©), **√©tat** (√©tat d√©sir√©).\
√Ä l'int√©rieur de la sp√©cification du fichier de configuration de d√©ploiement, vous pouvez trouver le mod√®le d√©fini avec une nouvelle structure de configuration d√©finissant l'image √† ex√©cuter :

**Exemple de D√©ploiement + Service d√©clar√©s dans le m√™me fichier de configuration (de** [**ici**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Comme un service est g√©n√©ralement li√© √† un d√©ploiement, il est possible de d√©clarer les deux dans le m√™me fichier de configuration (le service d√©clar√© dans cette configuration n'est accessible qu'en interne) :
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Exemple de configuration de service externe**

Ce service sera accessible de l'ext√©rieur (v√©rifiez les attributs `nodePort` et `type: LoadBlancer`) :
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Cela est utile pour les tests, mais pour la production, vous ne devriez avoir que des services internes et un Ingress pour exposer l'application.

**Exemple de fichier de configuration Ingress**

Cela exposera l'application √† `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Exemple de fichier de configuration des secrets**

Notez comment les mots de passe sont encod√©s en B64 (ce qui n'est pas s√©curis√© !)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Exemple de ConfigMap**

Un **ConfigMap** est la configuration qui est donn√©e aux pods afin qu'ils sachent comment localiser et acc√©der √† d'autres services. Dans ce cas, chaque pod saura que le nom `mongodb-service` est l'adresse d'un pod avec lequel ils peuvent communiquer (ce pod ex√©cutera un mongodb) :
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Ensuite, √† l'int√©rieur d'une **deployment config**, cette adresse peut √™tre sp√©cifi√©e de la mani√®re suivante afin qu'elle soit charg√©e dans l'env du pod :
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Exemple de configuration de volume**

Vous pouvez trouver diff√©rents exemples de fichiers de configuration de stockage yaml sur [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Notez que les volumes ne sont pas √† l'int√©rieur des namespaces**

### Namespaces

Kubernetes prend en charge **plusieurs clusters virtuels** soutenus par le m√™me cluster physique. Ces clusters virtuels sont appel√©s **namespaces**. Ils sont destin√©s √† √™tre utilis√©s dans des environnements avec de nombreux utilisateurs r√©partis sur plusieurs √©quipes ou projets. Pour les clusters avec quelques √† des dizaines d'utilisateurs, vous ne devriez pas avoir besoin de cr√©er ou de penser aux namespaces. Vous devriez seulement commencer √† utiliser les namespaces pour avoir un meilleur contr√¥le et une meilleure organisation de chaque partie de l'application d√©ploy√©e dans kubernetes.

Les namespaces fournissent un champ d'application pour les noms. Les noms des ressources doivent √™tre uniques au sein d'un namespace, mais pas entre les namespaces. Les namespaces ne peuvent pas √™tre imbriqu√©s les uns dans les autres et **chaque** ressource **Kubernetes** ne peut √™tre **que** **dans** **un** **seul** **namespace**.

Il y a 4 namespaces par d√©faut si vous utilisez minikube :
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system** : Ce n'est pas destin√© √† l'utilisation des utilisateurs et vous ne devriez pas y toucher. C'est pour les processus master et kubectl.
- **kube-public** : Donn√©es accessibles publiquement. Contient un configmap qui contient des informations sur le cluster.
- **kube-node-lease** : D√©termine la disponibilit√© d'un n≈ìud.
- **default** : L'espace de noms que l'utilisateur utilisera pour cr√©er des ressources.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Notez que la plupart des ressources Kubernetes (par exemple, les pods, les services, les contr√¥leurs de r√©plication, et d'autres) se trouvent dans certains espaces de noms. Cependant, d'autres ressources comme les ressources d'espace de noms et les ressources de bas niveau, telles que les n≈ìuds et les persistenVolumes ne se trouvent pas dans un espace de noms. Pour voir quelles ressources Kubernetes sont et ne sont pas dans un espace de noms :
>
> ```bash
> kubectl api-resources --namespaced=true #Dans un espace de noms
> kubectl api-resources --namespaced=false #Pas dans un espace de noms
> ```

Vous pouvez enregistrer l'espace de noms pour toutes les commandes kubectl suivantes dans ce contexte.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm est le **gestionnaire de paquets** pour Kubernetes. Il permet de regrouper des fichiers YAML et de les distribuer dans des d√©p√¥ts publics et priv√©s. Ces paquets sont appel√©s **Helm Charts**.
```
helm search <keyword>
```
Helm est √©galement un moteur de mod√®les qui permet de g√©n√©rer des fichiers de configuration avec des variables :

## Secrets Kubernetes

Un **Secret** est un objet qui **contient des donn√©es sensibles** telles qu'un mot de passe, un jeton ou une cl√©. De telles informations pourraient autrement √™tre mises dans une sp√©cification de Pod ou dans une image. Les utilisateurs peuvent cr√©er des Secrets et le syst√®me cr√©e √©galement des Secrets. Le nom d'un objet Secret doit √™tre un **nom de sous-domaine DNS valide**. Lisez ici [la documentation officielle](https://kubernetes.io/docs/concepts/configuration/secret/).

Les Secrets peuvent √™tre des choses comme :

- Cl√©s API, SSH.
- Jetons OAuth.
- Identifiants, Mots de passe (texte brut ou b64 + chiffrement).
- Informations ou commentaires.
- Code de connexion √† la base de donn√©es, cha√Ænes‚Ä¶ .

Il existe diff√©rents types de secrets dans Kubernetes

| Type int√©gr√©                        | Utilisation                                 |
| ----------------------------------- | ------------------------------------------- |
| **Opaque**                          | **donn√©es arbitraires d√©finies par l'utilisateur (par d√©faut)** |
| kubernetes.io/service-account-token | jeton de compte de service                  |
| kubernetes.io/dockercfg             | fichier \~/.dockercfg s√©rialis√©             |
| kubernetes.io/dockerconfigjson      | fichier \~/.docker/config.json s√©rialis√©    |
| kubernetes.io/basic-auth            | identifiants pour l'authentification de base |
| kubernetes.io/ssh-auth              | identifiants pour l'authentification SSH    |
| kubernetes.io/tls                   | donn√©es pour un client ou un serveur TLS    |
| bootstrap.kubernetes.io/token       | donn√©es de jeton de d√©marrage               |

> [!NOTE]
> **Le type Opaque est le type par d√©faut, la paire cl√©-valeur typique d√©finie par les utilisateurs.**

**Comment fonctionnent les secrets :**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Le fichier de configuration suivant d√©finit un **secret** appel√© `mysecret` avec 2 paires cl√©-valeur `username: YWRtaW4=` et `password: MWYyZDFlMmU2N2Rm`. Il d√©finit √©galement un **pod** appel√© `secretpod` qui aura le `username` et le `password` d√©finis dans `mysecret` expos√©s dans les **variables d'environnement** `SECRET_USERNAME` \_\_ et \_\_ `SECRET_PASSWOR`. Il **montera** √©galement le secret `username` √† l'int√©rieur de `mysecret` dans le chemin `/etc/foo/my-group/my-username` avec des permissions `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets dans etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** est un magasin de **valeurs-cl√©s** coh√©rent et hautement disponible utilis√© comme magasin de support Kubernetes pour toutes les donn√©es du cluster. Acc√©dons aux secrets stock√©s dans etcd :
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Vous verrez o√π se trouvent les certs, les cl√©s et les URL dans le syst√®me de fichiers. Une fois que vous les aurez, vous pourrez vous connecter √† etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Une fois que vous avez √©tabli la communication, vous serez en mesure d'obtenir les secrets :
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Ajout de chiffrement √† l'ETCD**

Par d√©faut, tous les secrets sont **stock√©s en texte clair** √† l'int√©rieur d'etcd, √† moins que vous n'appliquiez une couche de chiffrement. L'exemple suivant est bas√© sur [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Apr√®s cela, vous devez d√©finir le drapeau `--encryption-provider-config` sur le `kube-apiserver` pour pointer vers l'emplacement du fichier de configuration cr√©√©. Vous pouvez modifier `/etc/kubernetes/manifest/kube-apiserver.yaml` et ajouter les lignes suivantes :
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Faites d√©filer vers le bas dans les volumeMounts :
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Faites d√©filer vers le bas dans les volumeMounts jusqu'√† hostPath :
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**V√©rification que les donn√©es sont chiffr√©es**

Les donn√©es sont chiffr√©es lorsqu'elles sont √©crites dans etcd. Apr√®s avoir red√©marr√© votre `kube-apiserver`, tout secret nouvellement cr√©√© ou mis √† jour devrait √™tre chiffr√© lors de son stockage. Pour v√©rifier, vous pouvez utiliser le programme en ligne de commande `etcdctl` pour r√©cup√©rer le contenu de votre secret.

1.  Cr√©ez un nouveau secret appel√© `secret1` dans l'espace de noms `default` :

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  En utilisant la ligne de commande etcdctl, lisez ce secret √† partir d'etcd :

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

o√π `[...]` doit √™tre les arguments suppl√©mentaires pour se connecter au serveur etcd.

3.  V√©rifiez que le secret stock√© est pr√©fix√© par `k8s:enc:aescbc:v1:` ce qui indique que le fournisseur `aescbc` a chiffr√© les donn√©es r√©sultantes.
4.  V√©rifiez que le secret est correctement d√©chiffr√© lorsqu'il est r√©cup√©r√© via l'API :

```
kubectl describe secret secret1 -n default
```

devrait correspondre √† `mykey: bXlkYXRh`, mydata est encod√©, consultez [d√©codage d'un secret](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) pour d√©coder compl√®tement le secret.

**Puisque les secrets sont chiffr√©s √† l'√©criture, effectuer une mise √† jour sur un secret chiffrera ce contenu :**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Conseils finaux :**

- Essayez de ne pas garder de secrets dans le FS, obtenez-les d'autres endroits.
- Consultez [https://www.vaultproject.io/](https://www.vaultproject.io) pour ajouter plus de protection √† vos secrets.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## R√©f√©rences

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
