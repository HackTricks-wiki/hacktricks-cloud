# Kubernetes Temelleri

## Kubernetes Temelleri

{{#include ../../banners/hacktricks-training.md}}

**Bu sayfanÄ±n orijinal yazarÄ±** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(orijinal yazÄ±sÄ±nÄ±** [**buradan**](https://sickrov.github.io)**) okuyun**

## Mimari ve Temeller

### Kubernetes ne yapar?

- Bir veya daha fazla konteynerin bir konteyner motorunda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±na izin verir.
- GÃ¶rev zamanlamasÄ±, konteynerlerin gÃ¶revlerini verimli bir ÅŸekilde planlar.
- Konteynerleri hayatta tutar.
- Konteyner iletiÅŸimlerine izin verir.
- DaÄŸÄ±tÄ±m tekniklerine izin verir.
- Bilgi hacimlerini yÃ¶netir.

### Mimari

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **DÃ¼ÄŸÃ¼m**: pod veya pod'larla birlikte bir iÅŸletim sistemi.
- **Pod**: Bir konteyner veya birden fazla konteynerin etrafÄ±nda bir sargÄ±dÄ±r. Bir pod yalnÄ±zca bir uygulama iÃ§ermelidir (bu nedenle genellikle bir pod sadece 1 konteyner Ã§alÄ±ÅŸtÄ±rÄ±r). Pod, Kubernetes'in Ã§alÄ±ÅŸan konteyner teknolojisini soyutlama yoludur.
- **Hizmet**: Her pod'un dÃ¼ÄŸÃ¼mÃ¼n iÃ§ aralÄ±ÄŸÄ±ndan 1 iÃ§ **IP adresi** vardÄ±r. Ancak, bir hizmet aracÄ±lÄ±ÄŸÄ±yla da aÃ§Ä±ÄŸa Ã§Ä±karÄ±labilir. **Hizmetin de bir IP adresi vardÄ±r** ve amacÄ±, podlar arasÄ±ndaki iletiÅŸimi sÃ¼rdÃ¼rmektir, bÃ¶ylece biri Ã¶ldÃ¼ÄŸÃ¼nde **yeni yedek** (farklÄ± bir iÃ§ IP ile) **aynÄ± hizmet IP'sinde eriÅŸilebilir** olacaktÄ±r. Ä°Ã§ veya dÄ±ÅŸ olarak yapÄ±landÄ±rÄ±labilir. Hizmet, aynÄ± zamanda **2 pod'un aynÄ± hizmete baÄŸlÄ± olduÄŸunda yÃ¼k dengeleyici** olarak da iÅŸlev gÃ¶rÃ¼r.\
Bir **hizmet** **oluÅŸturulduÄŸunda**, her hizmetin uÃ§ noktalarÄ±nÄ± bulmak iÃ§in `kubectl get endpoints` komutunu Ã§alÄ±ÅŸtÄ±rabilirsiniz.
- **Kubelet**: Ana dÃ¼ÄŸÃ¼m ajanÄ±. DÃ¼ÄŸÃ¼m ile kubectl arasÄ±ndaki iletiÅŸimi saÄŸlayan bileÅŸen ve yalnÄ±zca pod'larÄ± Ã§alÄ±ÅŸtÄ±rabilir (API sunucusu aracÄ±lÄ±ÄŸÄ±yla). Kubelet, Kubernetes tarafÄ±ndan oluÅŸturulmamÄ±ÅŸ konteynerleri yÃ¶netmez.
- **Kube-proxy**: apiserver ile dÃ¼ÄŸÃ¼m arasÄ±ndaki iletiÅŸimlerden (hizmetlerden) sorumlu olan hizmettir. Temel olarak dÃ¼ÄŸÃ¼mler iÃ§in bir IPtables'tÄ±r. En deneyimli kullanÄ±cÄ±lar, diÄŸer satÄ±cÄ±lardan baÅŸka kube-proxy'ler kurabilir.
- **Sidecar konteyner**: Sidecar konteynerler, pod'daki ana konteynerle birlikte Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± gereken konteynerlerdir. Bu sidecar modeli, mevcut konteynerlerin iÅŸlevselliÄŸini deÄŸiÅŸtirmeden geniÅŸletir ve artÄ±rÄ±r. GÃ¼nÃ¼mÃ¼zde, konteyner teknolojisini uygulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in tÃ¼m baÄŸÄ±mlÄ±lÄ±klarÄ± sarmak iÃ§in kullandÄ±ÄŸÄ±mÄ±zÄ± biliyoruz. Bir konteyner yalnÄ±zca bir ÅŸey yapar ve o ÅŸeyi Ã§ok iyi yapar.
- **Ana sÃ¼reÃ§:**
- **Api Sunucusu:** KullanÄ±cÄ±larÄ±n ve pod'larÄ±n ana sÃ¼reÃ§le iletiÅŸim kurma yoludur. Sadece kimlik doÄŸrulamasÄ± yapÄ±lmÄ±ÅŸ istekler kabul edilmelidir.
- **ZamanlayÄ±cÄ±**: Zamanlama, Pod'larÄ±n DÃ¼ÄŸÃ¼mlere eÅŸleÅŸtirilmesini saÄŸlamayÄ± ifade eder, bÃ¶ylece Kubelet bunlarÄ± Ã§alÄ±ÅŸtÄ±rabilir. Hangi dÃ¼ÄŸÃ¼mde daha fazla kaynak mevcut olduÄŸunu belirlemek iÃ§in yeterli zekaya sahiptir ve yeni pod'u ona atar. ZamanlayÄ±cÄ±nÄ±n yeni pod'larÄ± baÅŸlatmadÄ±ÄŸÄ±nÄ±, yalnÄ±zca dÃ¼ÄŸÃ¼m iÃ§inde Ã§alÄ±ÅŸan Kubelet sÃ¼reciyle iletiÅŸim kurduÄŸunu unutmayÄ±n; bu sÃ¼reÃ§ yeni pod'u baÅŸlatacaktÄ±r.
- **Kube Controller yÃ¶neticisi**: Replica setleri veya daÄŸÄ±tÄ±mlarÄ± gibi kaynaklarÄ± kontrol eder, Ã¶rneÄŸin doÄŸru sayÄ±da pod veya dÃ¼ÄŸÃ¼mÃ¼n Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol eder. Bir pod eksikse, yeni bir tane baÅŸlatmak iÃ§in zamanlayÄ±cÄ± ile iletiÅŸim kurar. API'ye replikasyon, jetonlar ve hesap hizmetlerini kontrol eder.
- **etcd**: Veri depolama, kalÄ±cÄ±, tutarlÄ± ve daÄŸÄ±tÄ±lmÄ±ÅŸtÄ±r. Kubernetes'in veritabanÄ±dÄ±r ve kÃ¼melerin tam durumunu sakladÄ±ÄŸÄ± anahtar-deÄŸer depolamasÄ±dÄ±r (her deÄŸiÅŸiklik burada kaydedilir). ZamanlayÄ±cÄ± veya KontrolcÃ¼ yÃ¶neticisi gibi bileÅŸenler, hangi deÄŸiÅŸikliklerin meydana geldiÄŸini bilmek iÃ§in bu veriye baÄŸÄ±mlÄ±dÄ±r (dÃ¼ÄŸÃ¼mlerin mevcut kaynaklarÄ±, Ã§alÄ±ÅŸan pod sayÄ±sÄ±...)
- **Cloud controller yÃ¶neticisi**: AWS veya OpenStack'ta kÃ¼meleriniz varsa, akÄ±ÅŸ kontrolleri ve uygulamalar iÃ§in Ã¶zel kontrolÃ¶rdÃ¼r.

Birden fazla dÃ¼ÄŸÃ¼m (birden fazla pod Ã§alÄ±ÅŸtÄ±ran) olabileceÄŸinden, Api sunucusuna eriÅŸimleri yÃ¼k dengelemesi yapÄ±lmÄ±ÅŸ ve etcd'leri senkronize edilmiÅŸ birden fazla ana sÃ¼reÃ§ de olabilir.

**Hacimler:**

Bir pod, kaybolmamasÄ± gereken veriler oluÅŸturduÄŸunda, bu verilerin fiziksel bir hacimde saklanmasÄ± gerekir. **Kubernetes, verileri kalÄ±cÄ± hale getirmek iÃ§in bir pod'a bir hacim eklemeye izin verir**. Hacim, yerel makinede veya **uzaktan depolama** alanÄ±nda olabilir. FarklÄ± fiziksel dÃ¼ÄŸÃ¼mlerde pod'lar Ã§alÄ±ÅŸtÄ±rÄ±yorsanÄ±z, tÃ¼m pod'larÄ±n eriÅŸebilmesi iÃ§in uzaktan depolama kullanmalÄ±sÄ±nÄ±z.

**DiÄŸer yapÄ±landÄ±rmalar:**

- **ConfigMap**: Hizmetlere eriÅŸim iÃ§in **URL'leri** yapÄ±landÄ±rabilirsiniz. Pod, diÄŸer hizmetlerle (pod'lar) nasÄ±l iletiÅŸim kuracaÄŸÄ±nÄ± bilmek iÃ§in buradan veri alacaktÄ±r. Bu, kimlik bilgilerini saklamak iÃ§in Ã¶nerilen yer deÄŸildir!
- **Secret**: Bu, ÅŸifreler, API anahtarlarÄ± gibi **gizli verileri** saklamak iÃ§in yerdir... B64 ile kodlanmÄ±ÅŸtÄ±r. Pod, gerekli kimlik bilgilerini kullanmak iÃ§in bu verilere eriÅŸebilecektir.
- **DaÄŸÄ±tÄ±mlar**: Kubernetes tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lacak bileÅŸenlerin belirtildiÄŸi yerdir. Bir kullanÄ±cÄ± genellikle doÄŸrudan pod'larla Ã§alÄ±ÅŸmaz, pod'lar **ReplicaSets** (aynÄ± pod'larÄ±n sayÄ±sÄ±) iÃ§inde soyutlanÄ±r ve daÄŸÄ±tÄ±mlar aracÄ±lÄ±ÄŸÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. DaÄŸÄ±tÄ±mlarÄ±n **durumsuz** uygulamalar iÃ§in olduÄŸunu unutmayÄ±n. Bir daÄŸÄ±tÄ±m iÃ§in minimum yapÄ±landÄ±rma, Ã§alÄ±ÅŸtÄ±rÄ±lacak ad ve gÃ¶rÃ¼ntÃ¼dÃ¼r.
- **StatefulSet**: Bu bileÅŸen, **veritabanlarÄ±** gibi aynÄ± depolama alanÄ±na eriÅŸmesi gereken uygulamalar iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸtÄ±r.
- **Ingress**: Bu, uygulamayÄ± **bir URL ile halka aÃ§mak iÃ§in kullanÄ±lan yapÄ±landÄ±rmadÄ±r**. Bunun ayrÄ±ca harici hizmetler kullanÄ±larak da yapÄ±labileceÄŸini unutmayÄ±n, ancak bu, uygulamayÄ± aÃ§manÄ±n doÄŸru yoludur.
- Bir Ingress uyguladÄ±ÄŸÄ±nÄ±zda, **Ingress KontrolcÃ¼leri** oluÅŸturmanÄ±z gerekecektir. Ingress KontrolcÃ¼sÃ¼, istekleri alacak ve kontrol edecek ve bunlarÄ± hizmetlere yÃ¼k dengeleyecek bir **pod**'dur. Ingress kontrolcÃ¼sÃ¼, **yapÄ±landÄ±rÄ±lan ingress kurallarÄ±na dayalÄ± olarak isteÄŸi gÃ¶nderecektir**. Ingress kurallarÄ±nÄ±n farklÄ± yollarÄ± veya hatta farklÄ± iÃ§ Kubernetes hizmetlerine farklÄ± alt alan adlarÄ±nÄ± iÅŸaret edebileceÄŸini unutmayÄ±n.
- Daha iyi bir gÃ¼venlik uygulamasÄ±, Kubernetes kÃ¼mesinin herhangi bir kÄ±smÄ±nÄ± aÃ§Ä±ÄŸa Ã§Ä±karmamak iÃ§in bir bulut yÃ¼k dengeleyici veya bir proxy sunucusu kullanmak olacaktÄ±r.
- HiÃ§bir ingress kuralÄ±na uymayan bir istek alÄ±ndÄ±ÄŸÄ±nda, ingress kontrolcÃ¼sÃ¼ bunu "**VarsayÄ±lan arka uÃ§**"a yÃ¶nlendirecektir. Bu parametrenin adresini almak iÃ§in ingress kontrolcÃ¼sÃ¼nÃ¼ `describe` edebilirsiniz.
- `minikube addons enable ingress`

### PKI altyapÄ±sÄ± - Sertifika Otoritesi CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA, kÃ¼me iÃ§indeki tÃ¼m sertifikalar iÃ§in gÃ¼venilir kÃ¶k noktasÄ±dÄ±r.
- BileÅŸenlerin birbirini doÄŸrulamasÄ±na izin verir.
- TÃ¼m kÃ¼me sertifikalarÄ± CA tarafÄ±ndan imzalanmÄ±ÅŸtÄ±r.
- ETCd'nin kendi sertifikasÄ± vardÄ±r.
- tÃ¼rler:
- apiserver sertifikasÄ±.
- kubelet sertifikasÄ±.
- zamanlayÄ±cÄ± sertifikasÄ±.

## Temel Eylemler

### Minikube

**Minikube**, tam bir Kubernetes ortamÄ± daÄŸÄ±tmaya gerek kalmadan Kubernetes Ã¼zerinde bazÄ± **hÄ±zlÄ± testler** yapmak iÃ§in kullanÄ±labilir. **Ana ve dÃ¼ÄŸÃ¼m sÃ¼reÃ§lerini tek bir makinede** Ã§alÄ±ÅŸtÄ±racaktÄ±r. Minikube, dÃ¼ÄŸÃ¼mÃ¼ Ã§alÄ±ÅŸtÄ±rmak iÃ§in virtualbox kullanacaktÄ±r. [**Kurulumunu buradan**](https://minikube.sigs.k8s.io/docs/start/) gÃ¶rebilirsiniz.
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Kubectl Temelleri

**`Kubectl`**, kubernetes kÃ¼meleri iÃ§in komut satÄ±rÄ± aracÄ±dÄ±r. Kubernetes'te eylemler gerÃ§ekleÅŸtirmek veya veri istemek iÃ§in ana sÃ¼recin Api sunucusuyla iletiÅŸim kurar.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Dashboard, minikube'un ne Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ± daha kolay gÃ¶rmenizi saÄŸlar, ona eriÅŸmek iÃ§in URL'yi ÅŸurada bulabilirsiniz:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML yapÄ±landÄ±rma dosyasÄ± Ã¶rnekleri

Her yapÄ±landÄ±rma dosyasÄ±nÄ±n 3 kÄ±smÄ± vardÄ±r: **metadata**, **specification** (baÅŸlatÄ±lmasÄ± gereken), **status** (istenen durum).\
DaÄŸÄ±tÄ±m yapÄ±landÄ±rma dosyasÄ±nÄ±n spesifikasyonunun iÃ§inde, Ã§alÄ±ÅŸtÄ±rÄ±lacak gÃ¶rÃ¼ntÃ¼yÃ¼ tanÄ±mlayan yeni bir yapÄ±landÄ±rma yapÄ±sÄ±yla tanÄ±mlanan ÅŸablonu bulabilirsiniz:

**AynÄ± yapÄ±landÄ±rma dosyasÄ±nda bildirilen DaÄŸÄ±tÄ±m + Servis Ã¶rneÄŸi (ÅŸuradan** [**buraya**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Bir servis genellikle bir daÄŸÄ±tÄ±mla iliÅŸkili olduÄŸundan, her ikisini de aynÄ± yapÄ±landÄ±rma dosyasÄ±nda bildirmek mÃ¼mkÃ¼ndÃ¼r (bu yapÄ±landÄ±rmada bildirilen servis yalnÄ±zca dahili olarak eriÅŸilebilir):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**DÄ±ÅŸ hizmet yapÄ±landÄ±rmasÄ± Ã¶rneÄŸi**

Bu hizmet harici olarak eriÅŸilebilir olacak ( `nodePort` ve `type: LoadBlancer` niteliklerini kontrol edin):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Bu test iÃ§in faydalÄ±dÄ±r ama Ã¼retim iÃ§in yalnÄ±zca iÃ§ hizmetleriniz olmalÄ± ve uygulamayÄ± aÃ§Ä±ÄŸa Ã§Ä±karmak iÃ§in bir Ingress kullanmalÄ±sÄ±nÄ±z.

**Ingress yapÄ±landÄ±rma dosyasÄ± Ã¶rneÄŸi**

Bu, uygulamayÄ± `http://dashboard.com` adresinde aÃ§Ä±ÄŸa Ã§Ä±karacaktÄ±r.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Gizli yapÄ±landÄ±rma dosyasÄ± Ã¶rneÄŸi**

ParolalarÄ±n B64 ile kodlandÄ±ÄŸÄ±na dikkat edin (bu gÃ¼venli deÄŸil!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**ConfigMap Ã–rneÄŸi**

Bir **ConfigMap**, pod'lara diÄŸer hizmetleri nasÄ±l bulacaklarÄ± ve eriÅŸecekleri konusunda bilgi veren yapÄ±landÄ±rmadÄ±r. Bu durumda, her pod `mongodb-service` adÄ±nÄ±n iletiÅŸim kurabilecekleri bir pod'un adresi olduÄŸunu bilecektir (bu pod bir mongodb Ã§alÄ±ÅŸtÄ±racaktÄ±r):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Daha sonra, bir **deployment config** iÃ§inde bu adres aÅŸaÄŸÄ±daki ÅŸekilde belirtilerek pod'un env'ine yÃ¼klenecek ÅŸekilde ayarlanabilir:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Ã–rnek hacim yapÄ±landÄ±rmasÄ±**

FarklÄ± depolama yapÄ±landÄ±rma yaml dosyalarÄ±nÄ±n Ã¶rneklerini [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes) adresinde bulabilirsiniz.\
**Hacimlerin ad alanlarÄ±nÄ±n iÃ§inde olmadÄ±ÄŸÄ±nÄ± unutmayÄ±n**

### Ad AlanlarÄ±

Kubernetes, aynÄ± fiziksel kÃ¼me tarafÄ±ndan desteklenen **birden fazla sanal kÃ¼me**yi destekler. Bu sanal kÃ¼melere **ad alanlarÄ±** denir. Bu, birÃ§ok kullanÄ±cÄ±nÄ±n birden fazla ekip veya proje arasÄ±nda daÄŸÄ±ldÄ±ÄŸÄ± ortamlarda kullanÄ±lmak Ã¼zere tasarlanmÄ±ÅŸtÄ±r. BirkaÃ§ ila on kullanÄ±cÄ±ya sahip kÃ¼meler iÃ§in, ad alanlarÄ± oluÅŸturmanÄ±z veya dÃ¼ÅŸÃ¼nmeniz gerekmez. Sadece Kubernetes'te daÄŸÄ±tÄ±lan uygulamanÄ±n her bir parÃ§asÄ±nÄ±n daha iyi kontrolÃ¼ ve organizasyonu iÃ§in ad alanlarÄ±nÄ± kullanmaya baÅŸlamalÄ±sÄ±nÄ±z.

Ad alanlarÄ±, adlar iÃ§in bir kapsam saÄŸlar. KaynaklarÄ±n adlarÄ± bir ad alanÄ± iÃ§inde benzersiz olmalÄ±dÄ±r, ancak ad alanlarÄ± arasÄ±nda deÄŸil. Ad alanlarÄ± birbirinin iÃ§ine yerleÅŸtirilemez ve **her** Kubernetes **kaynaÄŸÄ±** yalnÄ±zca **bir** **ad alanÄ±nda** **bulunabilir**.

Minikube kullanÄ±yorsanÄ±z varsayÄ±lan olarak 4 ad alanÄ± vardÄ±r:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: KullanÄ±cÄ±lar iÃ§in tasarlanmamÄ±ÅŸtÄ±r ve buna dokunmamalÄ±sÄ±nÄ±z. Master ve kubectl sÃ¼reÃ§leri iÃ§indir.
- **kube-public**: Kamuya aÃ§Ä±k verilerdir. KÃ¼me bilgilerini iÃ§eren bir configmap iÃ§erir.
- **kube-node-lease**: Bir dÃ¼ÄŸÃ¼mÃ¼n kullanÄ±labilirliÄŸini belirler.
- **default**: KullanÄ±cÄ±nÄ±n kaynak oluÅŸturmak iÃ§in kullanacaÄŸÄ± ad alanÄ±dÄ±r.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Ã‡oÄŸu Kubernetes kaynaÄŸÄ±nÄ±n (Ã¶rneÄŸin, podlar, hizmetler, Ã§oÄŸaltma denetleyicileri ve diÄŸerleri) bazÄ± ad alanlarÄ±nda olduÄŸunu unutmayÄ±n. Ancak, ad alanÄ± kaynaklarÄ± ve dÃ¼zyÃ¼z kaynaklar, Ã¶rneÄŸin dÃ¼ÄŸÃ¼mler ve kalÄ±cÄ± hacimler gibi diÄŸer kaynaklar bir ad alanÄ±nda deÄŸildir. Hangi Kubernetes kaynaklarÄ±nÄ±n bir ad alanÄ±nda olduÄŸunu ve olmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in:
>
> ```bash
> kubectl api-resources --namespaced=true #Bir ad alanÄ±nda
> kubectl api-resources --namespaced=false #Bir ad alanÄ±nda deÄŸil
> ```

O baÄŸlamda tÃ¼m sonraki kubectl komutlarÄ± iÃ§in ad alanÄ±nÄ± kaydedebilirsiniz.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm, Kubernetes iÃ§in **paket yÃ¶neticisidir**. YAML dosyalarÄ±nÄ± paketlemeye ve bunlarÄ± kamu ve Ã¶zel depolarda daÄŸÄ±tmaya olanak tanÄ±r. Bu paketlere **Helm Charts** denir.
```
helm search <keyword>
```
Helm ayrÄ±ca deÄŸiÅŸkenlerle yapÄ±landÄ±rma dosyalarÄ± oluÅŸturmayÄ± saÄŸlayan bir ÅŸablon motorudur:

## Kubernetes gizli bilgileri

Bir **Secret**, bir ÅŸifre, bir token veya bir anahtar gibi **hassas verileri iÃ§eren** bir nesnedir. Bu tÃ¼r bilgiler, aksi takdirde bir Pod spesifikasyonuna veya bir imaja konulabilir. KullanÄ±cÄ±lar Secrets oluÅŸturabilir ve sistem de Secrets oluÅŸturur. Bir Secret nesnesinin adÄ± geÃ§erli bir **DNS alt alan adÄ±** olmalÄ±dÄ±r. Buradan [resmi belgeleri](https://kubernetes.io/docs/concepts/configuration/secret/) okuyun.

Secrets ÅŸunlar olabilir:

- API, SSH AnahtarlarÄ±.
- OAuth tokenlarÄ±.
- Kimlik bilgileri, Åifreler (dÃ¼z metin veya b64 + ÅŸifreleme).
- Bilgiler veya yorumlar.
- VeritabanÄ± baÄŸlantÄ± kodu, dizgilerâ€¦ .

Kubernetes'te farklÄ± tÃ¼rde gizli bilgiler vardÄ±r

| YerleÅŸik TÃ¼r                          | KullanÄ±m                                   |
| ------------------------------------- | ------------------------------------------ |
| **Opaque**                            | **kullanÄ±cÄ± tanÄ±mlÄ± rastgele veri (VarsayÄ±lan)** |
| kubernetes.io/service-account-token   | hizmet hesabÄ± tokenÄ±                      |
| kubernetes.io/dockercfg               | serileÅŸtirilmiÅŸ \~/.dockercfg dosyasÄ±     |
| kubernetes.io/dockerconfigjson        | serileÅŸtirilmiÅŸ \~/.docker/config.json dosyasÄ± |
| kubernetes.io/basic-auth              | temel kimlik doÄŸrulama iÃ§in kimlik bilgileri |
| kubernetes.io/ssh-auth                | SSH kimlik doÄŸrulamasÄ± iÃ§in kimlik bilgileri |
| kubernetes.io/tls                     | TLS istemcisi veya sunucusu iÃ§in veri      |
| bootstrap.kubernetes.io/token         | baÅŸlangÄ±Ã§ tokenÄ± verisi                   |

> [!NOTE]
> **Opaque tÃ¼rÃ¼ varsayÄ±lan olanÄ±dÄ±r, kullanÄ±cÄ±lar tarafÄ±ndan tanÄ±mlanan tipik anahtar-deÄŸer Ã§iftidir.**

**Gizli bilgilerin Ã§alÄ±ÅŸma ÅŸekli:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

AÅŸaÄŸÄ±daki yapÄ±landÄ±rma dosyasÄ±, `mysecret` adÄ±nda 2 anahtar-deÄŸer Ã§ifti `username: YWRtaW4=` ve `password: MWYyZDFlMmU2N2Rm` ile bir **secret** tanÄ±mlar. AyrÄ±ca, `mysecret` iÃ§inde tanÄ±mlanan `username` ve `password`'un **Ã§evre deÄŸiÅŸkenleri** `SECRET_USERNAME` \_\_ ve \_\_ `SECRET_PASSWOR` olarak aÃ§Ä±ÄŸa Ã§Ä±kacaÄŸÄ± `secretpod` adÄ±nda bir **pod** tanÄ±mlar. AyrÄ±ca, `mysecret` iÃ§indeki `username` gizli bilgisini `/etc/foo/my-group/my-username` yoluna `0640` izinleriyle **monte** edecektir.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd**, Kubernetes'in tÃ¼m kÃ¼me verileri iÃ§in arka uÃ§ deposu olarak kullanÄ±lan tutarlÄ± ve yÃ¼ksek eriÅŸilebilir **anahtar-deÄŸer deposu**dur. etcd'de saklanan gizli bilgilere eriÅŸelim:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
SertifikalarÄ±n, anahtarlarÄ±n ve URL'lerin dosya sisteminde nerede bulunduÄŸunu gÃ¶receksiniz. Bunu elde ettiÄŸinizde, etcd'ye baÄŸlanabileceksiniz.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Ä°letiÅŸimi saÄŸladÄ±ktan sonra sÄ±rlarÄ± elde edebileceksiniz:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**ETCD'ye ÅŸifreleme ekleme**

VarsayÄ±lan olarak, tÃ¼m gizli bilgiler **dÃ¼z** metin olarak etcd iÃ§inde saklanÄ±r, bu nedenle bir ÅŸifreleme katmanÄ± uygulamazsanÄ±z. AÅŸaÄŸÄ±daki Ã¶rnek [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/) adresine dayanmaktadÄ±r.
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Bundan sonra, oluÅŸturulan yapÄ±landÄ±rma dosyasÄ±nÄ±n konumunu gÃ¶stermek iÃ§in `kube-apiserver` Ã¼zerinde `--encryption-provider-config` bayraÄŸÄ±nÄ± ayarlamanÄ±z gerekir. `/etc/kubernetes/manifest/kube-apiserver.yaml` dosyasÄ±nÄ± deÄŸiÅŸtirebilir ve aÅŸaÄŸÄ±daki satÄ±rlarÄ± ekleyebilirsiniz:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
volumeMounts iÃ§inde aÅŸaÄŸÄ± kaydÄ±rÄ±n:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
volumeMounts iÃ§inde hostPath'a kaydÄ±rÄ±n:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verilerin ÅŸifrelenip ÅŸifrelenmediÄŸini doÄŸrulama**

Veriler, etcd'ye yazÄ±ldÄ±ÄŸÄ±nda ÅŸifrelenir. `kube-apiserver`'Ä±nÄ±zÄ± yeniden baÅŸlattÄ±ktan sonra, yeni oluÅŸturulan veya gÃ¼ncellenen herhangi bir gizli bilgi, depolandÄ±ÄŸÄ±nda ÅŸifrelenmiÅŸ olmalÄ±dÄ±r. Kontrol etmek iÃ§in, gizli bilginizin iÃ§eriÄŸini almak iÃ§in `etcdctl` komut satÄ±rÄ± programÄ±nÄ± kullanabilirsiniz.

1.  `default` ad alanÄ±nda `secret1` adÄ±nda yeni bir gizli bilgi oluÅŸturun:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  etcdctl komut satÄ±rÄ±nÄ± kullanarak, o gizli bilgiyi etcd'den okuyun:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

burada `[...]` etcd sunucusuna baÄŸlanmak iÃ§in ek argÃ¼manlar olmalÄ±dÄ±r.

3.  Depolanan gizli bilginin `k8s:enc:aescbc:v1:` ile baÅŸladÄ±ÄŸÄ±nÄ± doÄŸrulayÄ±n; bu, `aescbc` saÄŸlayÄ±cÄ±sÄ±nÄ±n sonuÃ§lanan veriyi ÅŸifrelediÄŸini gÃ¶sterir.
4.  Gizli bilginin API aracÄ±lÄ±ÄŸÄ±yla alÄ±ndÄ±ÄŸÄ±nda doÄŸru bir ÅŸekilde ÅŸifresinin Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayÄ±n:

```
kubectl describe secret secret1 -n default
```

`mykey: bXlkYXRh` ile eÅŸleÅŸmelidir, mydata kodlanmÄ±ÅŸtÄ±r, gizli bilgiyi tamamen Ã§Ã¶zmek iÃ§in [gizli bilgiyi Ã§Ã¶zme](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) kÄ±smÄ±nÄ± kontrol edin.

**Gizli bilgiler yazÄ±ldÄ±ÄŸÄ±nda ÅŸifrelendiÄŸinden, bir gizli bilgi Ã¼zerinde gÃ¼ncelleme yapmak o iÃ§eriÄŸi ÅŸifreleyecektir:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Son ipuÃ§larÄ±:**

- FS'de sÄ±r tutmamaya Ã§alÄ±ÅŸÄ±n, onlarÄ± baÅŸka yerlerden alÄ±n.
- SÄ±rlarÄ±nÄ±za daha fazla koruma eklemek iÃ§in [https://www.vaultproject.io/](https://www.vaultproject.io) adresine gÃ¶z atÄ±n.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Referanslar

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
