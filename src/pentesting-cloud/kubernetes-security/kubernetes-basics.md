# Kubernetes Basics

## Kubernetes Basics

{{#include ../../banners/hacktricks-training.md}}

**L'autore originale di questa pagina √®** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(leggi il suo post originale** [**qui**](https://sickrov.github.io)**)**

## Architettura & Fondamenti

### Cosa fa Kubernetes?

- Consente di eseguire container in un motore di container.
- La pianificazione consente missioni efficienti per i container.
- Mantiene i container attivi.
- Consente comunicazioni tra container.
- Consente tecniche di distribuzione.
- Gestisce volumi di informazioni.

### Architettura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **Node**: sistema operativo con pod o pods.
- **Pod**: involucro attorno a un container o pi√π container. Un pod dovrebbe contenere solo un'applicazione (quindi di solito, un pod esegue solo 1 container). Il pod √® il modo in cui Kubernetes astrae la tecnologia dei container in esecuzione.
- **Service**: Ogni pod ha 1 **indirizzo IP interno** dall'intervallo interno del nodo. Tuttavia, pu√≤ essere anche esposto tramite un servizio. Il **servizio ha anche un indirizzo IP** e il suo obiettivo √® mantenere la comunicazione tra i pod, quindi se uno muore il **nuovo sostituto** (con un IP interno diverso) **sar√† accessibile** esposto nel **stesso IP del servizio**. Pu√≤ essere configurato come interno o esterno. Il servizio agisce anche come un **bilanciatore di carico quando 2 pod sono connessi** allo stesso servizio.\
Quando un **servizio** √® **creato** puoi trovare gli endpoint di ciascun servizio eseguendo `kubectl get endpoints`
- **Kubelet**: agente principale del nodo. Il componente che stabilisce la comunicazione tra il nodo e kubectl, e pu√≤ eseguire solo pod (attraverso l'API server). Il kubelet non gestisce i container che non sono stati creati da Kubernetes.
- **Kube-proxy**: √® il servizio responsabile delle comunicazioni (servizi) tra l'apiserver e il nodo. La base √® un IPtables per i nodi. Gli utenti pi√π esperti potrebbero installare altri kube-proxy di altri fornitori.
- **Sidecar container**: I container sidecar sono i container che dovrebbero essere eseguiti insieme al container principale nel pod. Questo modello sidecar estende e migliora la funzionalit√† dei container attuali senza modificarli. Oggi sappiamo che utilizziamo la tecnologia dei container per avvolgere tutte le dipendenze affinch√© l'applicazione possa essere eseguita ovunque. Un container fa solo una cosa e la fa molto bene.
- **Master process:**
- **Api Server:** √à il modo in cui gli utenti e i pod comunicano con il processo master. Solo le richieste autenticate dovrebbero essere consentite.
- **Scheduler**: La pianificazione si riferisce a garantire che i Pod siano abbinati ai Node in modo che Kubelet possa eseguirli. Ha abbastanza intelligenza per decidere quale nodo ha pi√π risorse disponibili e assegnare il nuovo pod ad esso. Nota che lo scheduler non avvia nuovi pod, comunica solo con il processo Kubelet in esecuzione all'interno del nodo, che lancer√† il nuovo pod.
- **Kube Controller manager**: Controlla le risorse come i replica set o le distribuzioni per verificare se, ad esempio, il numero corretto di pod o nodi √® in esecuzione. In caso di un pod mancante, comunicher√† con lo scheduler per avviarne uno nuovo. Controlla la replicazione, i token e i servizi di account per l'API.
- **etcd**: Archiviazione dati, persistente, coerente e distribuita. √à il database di Kubernetes e l'archiviazione chiave-valore in cui mantiene lo stato completo dei cluster (ogni modifica √® registrata qui). Componenti come lo Scheduler o il Controller manager dipendono da questi dati per sapere quali modifiche sono avvenute (risorse disponibili dei nodi, numero di pod in esecuzione...)
- **Cloud controller manager**: √à il controller specifico per il controllo del flusso e le applicazioni, ad esempio: se hai cluster in AWS o OpenStack.

Nota che poich√© potrebbero esserci diversi nodi (che eseguono diversi pod), potrebbero esserci anche diversi processi master i cui accessi all'Api server sono bilanciati e il loro etcd sincronizzato.

**Volumi:**

Quando un pod crea dati che non dovrebbero essere persi quando il pod scompare, dovrebbero essere memorizzati in un volume fisico. **Kubernetes consente di allegare un volume a un pod per persistere i dati**. Il volume pu√≤ essere nella macchina locale o in un **archiviazione remota**. Se stai eseguendo pod in nodi fisici diversi, dovresti utilizzare un'archiviazione remota in modo che tutti i pod possano accedervi.

**Altre configurazioni:**

- **ConfigMap**: Puoi configurare **URL** per accedere ai servizi. Il pod otterr√† dati da qui per sapere come comunicare con il resto dei servizi (pod). Nota che questo non √® il posto consigliato per salvare le credenziali!
- **Secret**: Questo √® il posto per **memorizzare dati segreti** come password, chiavi API... codificati in B64. Il pod sar√† in grado di accedere a questi dati per utilizzare le credenziali richieste.
- **Deployments**: Qui vengono indicati i componenti da eseguire tramite Kubernetes. Un utente di solito non lavora direttamente con i pod, i pod sono astratti in **ReplicaSets** (numero di pod identici replicati), che vengono eseguiti tramite distribuzioni. Nota che le distribuzioni sono per applicazioni **stateless**. La configurazione minima per una distribuzione √® il nome e l'immagine da eseguire.
- **StatefulSet**: Questo componente √® specificamente destinato ad applicazioni come **database** che necessitano di **accedere alla stessa archiviazione**.
- **Ingress**: Questa √® la configurazione utilizzata per **esporre l'applicazione pubblicamente con un URL**. Nota che questo pu√≤ essere fatto anche utilizzando servizi esterni, ma questo √® il modo corretto per esporre l'applicazione.
- Se implementi un Ingress dovrai creare **Ingress Controllers**. L'Ingress Controller √® un **pod** che sar√† l'endpoint che ricever√† le richieste e le verificher√† e le bilancer√† ai servizi. L'Ingress Controller **invier√† la richiesta in base alle regole di ingress configurate**. Nota che le regole di ingress possono puntare a percorsi diversi o persino a sottodomini diversi per diversi servizi Kubernetes interni.
- Una migliore pratica di sicurezza sarebbe utilizzare un bilanciatore di carico cloud o un server proxy come punto di ingresso per non avere alcuna parte del cluster Kubernetes esposta.
- Quando viene ricevuta una richiesta che non corrisponde a nessuna regola di ingress, l'Ingress Controller la diriger√† al "**Default backend**". Puoi `describe` l'Ingress Controller per ottenere l'indirizzo di questo parametro.
- `minikube addons enable ingress`

### Infrastruttura PKI - Autorit√† di Certificazione CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA √® la radice fidata per tutti i certificati all'interno del cluster.
- Consente ai componenti di convalidarsi a vicenda.
- Tutti i certificati del cluster sono firmati dalla CA.
- ETCd ha il proprio certificato.
- tipi:
- certificato apiserver.
- certificato kubelet.
- certificato scheduler.

## Azioni di Base

### Minikube

**Minikube** pu√≤ essere utilizzato per eseguire alcuni **test rapidi** su Kubernetes senza dover distribuire un intero ambiente Kubernetes. Eseguir√† i **processi master e nodo su una macchina**. Minikube utilizzer√† VirtualBox per eseguire il nodo. Vedi [**qui come installarlo**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Basics

**`Kubectl`** √® lo strumento da riga di comando per i cluster kubernetes. Comunica con il server Api del processo master per eseguire azioni in kubernetes o per richiedere dati.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Il dashboard ti consente di vedere pi√π facilmente cosa sta eseguendo minikube, puoi trovare l'URL per accedervi in:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Esempi di file di configurazione YAML

Ogni file di configurazione ha 3 parti: **metadata**, **specifica** (cosa deve essere lanciato), **stato** (stato desiderato).\
All'interno della specifica del file di configurazione del deployment puoi trovare il template definito con una nuova struttura di configurazione che definisce l'immagine da eseguire:

**Esempio di Deployment + Service dichiarati nello stesso file di configurazione (da** [**qui**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Poich√© un servizio √® solitamente correlato a un deployment, √® possibile dichiarare entrambi nello stesso file di configurazione (il servizio dichiarato in questa configurazione √® accessibile solo internamente):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Esempio di configurazione del servizio esterno**

Questo servizio sar√† accessibile esternamente (controlla gli attributi `nodePort` e `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Questo √® utile per i test, ma per la produzione dovresti avere solo servizi interni e un Ingress per esporre l'applicazione.

**Esempio di file di configurazione Ingress**

Questo esporr√† l'applicazione in `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Esempio di file di configurazione dei segreti**

Nota come le password siano codificate in B64 (che non √® sicuro!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Esempio di ConfigMap**

Una **ConfigMap** √® la configurazione che viene fornita ai pod affinch√© sappiano come localizzare e accedere ad altri servizi. In questo caso, ogni pod sapr√† che il nome `mongodb-service` √® l'indirizzo di un pod con cui possono comunicare (questo pod eseguir√† un mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Poi, all'interno di una **deployment config**, questo indirizzo pu√≤ essere specificato nel seguente modo affinch√© venga caricato all'interno dell'env del pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Esempio di configurazione del volume**

Puoi trovare diversi esempi di file di configurazione dello storage in formato yaml su [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Nota che i volumi non sono all'interno dei namespace**

### Namespace

Kubernetes supporta **pi√π cluster virtuali** supportati dallo stesso cluster fisico. Questi cluster virtuali sono chiamati **namespace**. Sono destinati all'uso in ambienti con molti utenti distribuiti su pi√π team o progetti. Per cluster con pochi o decine di utenti, non dovresti aver bisogno di creare o pensare ai namespace. Dovresti iniziare a utilizzare i namespace per avere un migliore controllo e organizzazione di ciascuna parte dell'applicazione distribuita in kubernetes.

I namespace forniscono un ambito per i nomi. I nomi delle risorse devono essere unici all'interno di un namespace, ma non tra i namespace. I namespace non possono essere annidati l'uno dentro l'altro e **ogni** risorsa **Kubernetes** pu√≤ essere **in** **un** **solo** **namespace**.

Ci sono 4 namespace per impostazione predefinita se stai usando minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: Non √® destinato all'uso degli utenti e non dovresti toccarlo. √à per i processi master e kubectl.
- **kube-public**: Dati accessibili pubblicamente. Contiene un configmap che contiene informazioni sul cluster.
- **kube-node-lease**: Determina la disponibilit√† di un nodo.
- **default**: Lo spazio dei nomi che l'utente utilizzer√† per creare risorse.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Nota che la maggior parte delle risorse Kubernetes (ad es. pod, servizi, controller di replica e altre) si trovano in alcuni namespace. Tuttavia, altre risorse come le risorse di namespace e risorse a basso livello, come nodi e persistenVolumes, non si trovano in un namespace. Per vedere quali risorse Kubernetes sono e non sono in un namespace:
>
> ```bash
> kubectl api-resources --namespaced=true #In un namespace
> kubectl api-resources --namespaced=false #Non in un namespace
> ```

Puoi salvare il namespace per tutti i successivi comandi kubectl in quel contesto.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm √® il **gestore di pacchetti** per Kubernetes. Consente di impacchettare file YAML e distribuirli in repository pubblici e privati. Questi pacchetti sono chiamati **Helm Charts**.
```
helm search <keyword>
```
Helm √® anche un motore di template che consente di generare file di configurazione con variabili:

## Kubernetes secrets

Un **Secret** √® un oggetto che **contiene dati sensibili** come una password, un token o una chiave. Tali informazioni potrebbero altrimenti essere inserite in una specifica di Pod o in un'immagine. Gli utenti possono creare Secrets e il sistema crea anche Secrets. Il nome di un oggetto Secret deve essere un valido **nome di sottodominio DNS**. Leggi qui [la documentazione ufficiale](https://kubernetes.io/docs/concepts/configuration/secret/).

I Secrets possono essere cose come:

- API, chiavi SSH.
- Token OAuth.
- Credenziali, password (testo normale o b64 + crittografia).
- Informazioni o commenti.
- Codice di connessione al database, stringhe‚Ä¶ .

Ci sono diversi tipi di secrets in Kubernetes

| Tipo incorporato                     | Utilizzo                                   |
| ------------------------------------ | ------------------------------------------ |
| **Opaque**                           | **dati arbitrari definiti dall'utente (Predefinito)** |
| kubernetes.io/service-account-token  | token dell'account di servizio            |
| kubernetes.io/dockercfg              | file \~/.dockercfg serializzato           |
| kubernetes.io/dockerconfigjson       | file \~/.docker/config.json serializzato  |
| kubernetes.io/basic-auth             | credenziali per l'autenticazione di base  |
| kubernetes.io/ssh-auth               | credenziali per l'autenticazione SSH      |
| kubernetes.io/tls                    | dati per un client o server TLS           |
| bootstrap.kubernetes.io/token        | dati del token di avvio                   |

> [!NOTE]
> **Il tipo Opaque √® quello predefinito, la tipica coppia chiave-valore definita dagli utenti.**

**Come funzionano i secrets:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Il seguente file di configurazione definisce un **secret** chiamato `mysecret` con 2 coppie chiave-valore `username: YWRtaW4=` e `password: MWYyZDFlMmU2N2Rm`. Definisce anche un **pod** chiamato `secretpod` che avr√† il `username` e la `password` definiti in `mysecret` esposti nelle **variabili di ambiente** `SECRET_USERNAME` \_\_ e \_\_ `SECRET_PASSWOR`. Monta anche il secret `username` all'interno di `mysecret` nel percorso `/etc/foo/my-group/my-username` con permessi `0640`.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** √® un archivio **key-value** consistente e altamente disponibile utilizzato come archivio di supporto per tutti i dati del cluster in Kubernetes. Accediamo ai segreti memorizzati in etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Vedrai i certificati, le chiavi e gli URL che si trovano nel FS. Una volta ottenuti, sarai in grado di connetterti a etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Una volta stabilita la comunicazione, sarai in grado di ottenere i segreti:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Aggiungere crittografia all'ETCD**

Per impostazione predefinita, tutti i segreti sono **memorizzati in testo semplice** all'interno di etcd a meno che non si applichi uno strato di crittografia. L'esempio seguente si basa su [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Dopo di ci√≤, √® necessario impostare il flag `--encryption-provider-config` sul `kube-apiserver` per puntare alla posizione del file di configurazione creato. Puoi modificare `/etc/kubernetes/manifest/kube-apiserver.yaml` e aggiungere le seguenti righe:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Scorri verso il basso in volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Scorri verso il basso in volumeMounts fino a hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verifica che i dati siano crittografati**

I dati sono crittografati quando scritti in etcd. Dopo aver riavviato il tuo `kube-apiserver`, qualsiasi segreto creato o aggiornato dovrebbe essere crittografato quando memorizzato. Per controllare, puoi utilizzare il programma da riga di comando `etcdctl` per recuperare il contenuto del tuo segreto.

1.  Crea un nuovo segreto chiamato `secret1` nel namespace `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  Utilizzando la riga di comando etcdctl, leggi quel segreto da etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

dove `[...]` deve essere gli argomenti aggiuntivi per connettersi al server etcd.

3.  Verifica che il segreto memorizzato sia preceduto da `k8s:enc:aescbc:v1:`, il che indica che il provider `aescbc` ha crittografato i dati risultanti.
4.  Verifica che il segreto sia correttamente decrittografato quando recuperato tramite l'API:

```
kubectl describe secret secret1 -n default
```

dovrebbe corrispondere a `mykey: bXlkYXRh`, mydata √® codificato, controlla [decodifica di un segreto](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) per decodificare completamente il segreto.

**Poich√© i segreti sono crittografati in scrittura, eseguire un aggiornamento su un segreto crittografer√† quel contenuto:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Suggerimenti finali:**

- Cerca di non tenere segreti nel FS, prendili da altri luoghi.
- Controlla [https://www.vaultproject.io/](https://www.vaultproject.io) per aggiungere pi√π protezione ai tuoi segreti.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Riferimenti

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
