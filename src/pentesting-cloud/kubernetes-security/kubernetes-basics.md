# Osnovi Kubernetesa

## Osnovi Kubernetesa

{{#include ../../banners/hacktricks-training.md}}

**Originalni autor ove stranice je** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(proÄitajte njegov originalni post** [**ovde**](https://sickrov.github.io)**)**

## Arhitektura i Osnovi

### Å ta radi Kubernetes?

- OmoguÄ‡ava pokretanje kontejnera u kontejnerskom motoru.
- RasporeÄ‘uje kontejnerske misije efikasno.
- OdrÅ¾ava kontejnere aktivnim.
- OmoguÄ‡ava komunikaciju izmeÄ‘u kontejnera.
- OmoguÄ‡ava tehnike implementacije.
- Rukuje koliÄinama informacija.

### Arhitektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

- **ÄŒvor**: operativni sistem sa podom ili podovima.
- **Pod**: OmotaÄ oko kontejnera ili viÅ¡e kontejnera. Pod bi trebao sadrÅ¾ati samo jednu aplikaciju (tako da obiÄno, pod pokreÄ‡e samo 1 kontejner). Pod je naÄin na koji Kubernetes apstrahuje tehnologiju kontejnera koja se pokreÄ‡e.
- **Servis**: Svaki pod ima 1 internu **IP adresu** iz unutraÅ¡njeg opsega Ävora. MeÄ‘utim, moÅ¾e biti izloÅ¾en i putem servisa. **Servis takoÄ‘e ima IP adresu** i njegov cilj je odrÅ¾avanje komunikacije izmeÄ‘u podova, tako da ako jedan umre, **novi zamenski** (sa drugaÄijom internom IP) **Ä‡e biti dostupan** izloÅ¾en na **isto IP servisa**. MoÅ¾e se konfigurisati kao unutraÅ¡nji ili spoljaÅ¡nji. Servis takoÄ‘e deluje kao **balansirnik optereÄ‡enja kada su 2 poda povezana** na isti servis.\
Kada se **servis** **kreira**, moÅ¾ete pronaÄ‡i krajnje taÄke svakog servisa pokretanjem `kubectl get endpoints`
- **Kubelet**: Primarni agent Ävora. Komponenta koja uspostavlja komunikaciju izmeÄ‘u Ävora i kubectl, i moÅ¾e pokretati samo podove (putem API servera). Kubelet ne upravlja kontejnerima koji nisu kreirani od strane Kubernetesa.
- **Kube-proxy**: je servis zaduÅ¾en za komunikaciju (servise) izmeÄ‘u apiservera i Ävora. Osnova je IPtables za Ävorove. Najiskusniji korisnici mogu instalirati druge kube-proxije od drugih dobavljaÄa.
- **Sidecar kontejner**: Sidecar kontejneri su kontejneri koji bi trebali raditi zajedno sa glavnim kontejnerom u podu. Ovaj sidecar obrazac proÅ¡iruje i poboljÅ¡ava funkcionalnost trenutnih kontejnera bez njihovog menjanja. Danas znamo da koristimo tehnologiju kontejnera da obavijemo sve zavisnosti za aplikaciju da bi radila bilo gde. Kontejner radi samo jednu stvar i radi tu stvar veoma dobro.
- **Glavni proces:**
- **Api Server:** Je naÄin na koji korisnici i podovi komuniciraju sa glavnim procesom. Samo autentifikovani zahtevi bi trebali biti dozvoljeni.
- **RasporeÄ‘ivaÄ**: RasporeÄ‘ivanje se odnosi na osiguranje da su podovi usklaÄ‘eni sa Ävorovima kako bi Kubelet mogao da ih pokrene. Ima dovoljno inteligencije da odluÄi koji Ävor ima viÅ¡e dostupnih resursa i dodeli novi pod njemu. Imajte na umu da rasporeÄ‘ivaÄ ne pokreÄ‡e nove podove, samo komunicira sa Kubelet procesom koji se pokreÄ‡e unutar Ävora, koji Ä‡e pokrenuti novi pod.
- **Kube Controller menadÅ¾er**: Proverava resurse kao Å¡to su replikacione grupe ili implementacije da proveri da li, na primer, ispravan broj podova ili Ävorova radi. U sluÄaju da nedostaje pod, komuniciraÄ‡e sa rasporeÄ‘ivaÄem da pokrene novi. KontroliÅ¡e replikaciju, tokene i usluge raÄuna za API.
- **etcd**: SkladiÅ¡te podataka, postojano, konzistentno i distribuirano. To je baza podataka Kubernetesa i skladiÅ¡te kljuÄ-vrednost gde Äuva potpuno stanje klastera (svaka promena se ovde beleÅ¾i). Komponente kao Å¡to su RasporeÄ‘ivaÄ ili MenadÅ¾er kontrolera zavise od ovih podataka da bi znale koje su promene nastale (dostupni resursi Ävorova, broj pokrenutih podova...)
- **Cloud controller menadÅ¾er**: SpecifiÄni je kontroler za tokove kontrole i aplikacije, tj: ako imate klastere u AWS-u ili OpenStack-u.

Imajte na umu da kako moÅ¾e biti nekoliko Ävorova (koji pokreÄ‡u nekoliko podova), moÅ¾e biti i nekoliko glavnih procesa Äiji je pristup API serveru balansiran optereÄ‡enjem i njihov etcd sinhronizovan.

**Volumeni:**

Kada pod kreira podatke koji ne bi trebali biti izgubljeni kada pod nestane, trebali bi biti smeÅ¡teni u fiziÄkom volumenu. **Kubernetes omoguÄ‡ava povezivanje volumena sa podom kako bi se podaci saÄuvali**. Volumen moÅ¾e biti na lokalnoj maÅ¡ini ili u **daljinskom skladiÅ¡tu**. Ako pokreÄ‡ete podove na razliÄitim fiziÄkim Ävorovima, trebali biste koristiti daljinsko skladiÅ¡te kako bi svi podovi mogli da mu pristupe.

**Druge konfiguracije:**

- **ConfigMap**: MoÅ¾ete konfigurisati **URL-ove** za pristup servisima. Pod Ä‡e dobiti podatke odavde da zna kako da komunicira sa ostalim servisima (podovima). Imajte na umu da ovo nije preporuÄeno mesto za Äuvanje akreditiva!
- **Secret**: Ovo je mesto za **Äuvanje tajnih podataka** kao Å¡to su lozinke, API kljuÄevi... kodirani u B64. Pod Ä‡e moÄ‡i da pristupi ovim podacima da koristi potrebne akreditive.
- **Implementacije**: Ovo je mesto gde su navedeni komponenti koje Ä‡e Kubernetes pokrenuti. Korisnik obiÄno ne radi direktno sa podovima, podovi su apstrahovani u **ReplicaSets** (broj istih podova replikovanih), koji se pokreÄ‡u putem implementacija. Imajte na umu da su implementacije za **stateless** aplikacije. Minimalna konfiguracija za implementaciju je ime i slika koja se pokreÄ‡e.
- **StatefulSet**: Ova komponenta je namenjena posebno za aplikacije kao Å¡to su **baze podataka** koje trebaju **pristup istom skladiÅ¡tu**.
- **Ingress**: Ovo je konfiguracija koja se koristi za **izlaganje aplikacije javno putem URL-a**. Imajte na umu da se ovo moÅ¾e uraditi i koriÅ¡Ä‡enjem spoljaÅ¡njih servisa, ali ovo je ispravan naÄin za izlaganje aplikacije.
- Ako implementirate Ingress, biÄ‡e potrebno da kreirate **Ingress kontrolere**. Ingress kontroler je **pod** koji Ä‡e biti krajnja taÄka koja Ä‡e primati zahteve, proveravati ih i balansirati ih na servise. Ingress kontroler Ä‡e **slati zahtev na osnovu konfigurisanih ingress pravila**. Imajte na umu da ingress pravila mogu ukazivati na razliÄite putanje ili Äak poddomene razliÄitim internim Kubernetes servisima.
- Bolja praksa u vezi sa bezbednoÅ¡Ä‡u bi bila koriÅ¡Ä‡enje cloud balansirnika optereÄ‡enja ili proxy servera kao ulazne taÄke kako ne bi bilo koje delove Kubernetes klastera izloÅ¾ene.
- Kada se primi zahtev koji ne odgovara nijednom ingress pravilu, ingress kontroler Ä‡e ga usmeriti na "**Default backend**". MoÅ¾ete `describe` ingress kontroler da dobijete adresu ovog parametra.
- `minikube addons enable ingress`

### PKI infrastruktura - Sertifikacijska vlast CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

- CA je poverljivi koren za sve sertifikate unutar klastera.
- OmoguÄ‡ava komponentama da se meÄ‘usobno validiraju.
- Svi klasterski sertifikati su potpisani od strane CA.
- ETCd ima svoj sertifikat.
- tipovi:
- apiserver sertifikat.
- kubelet sertifikat.
- rasporeÄ‘ivaÄ sertifikat.

## Osnovne Akcije

### Minikube

**Minikube** se moÅ¾e koristiti za izvoÄ‘enje nekih **brzih testova** na Kubernetesu bez potrebe za implementacijom celog Kubernetes okruÅ¾enja. PokrenuÄ‡e **glavne i Ävorne procese na jednoj maÅ¡ini**. Minikube Ä‡e koristiti virtualbox za pokretanje Ävora. Pogledajte [**ovde kako da ga instalirate**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Kubectl Osnovi

**`Kubectl`** je alat za komandnu liniju za kubernetes klastere. Komunicira sa Api serverom glavnog procesa kako bi izvrÅ¡io akcije u kubernetesu ili zatraÅ¾io podatke.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Dashboard vam omoguÄ‡ava da lakÅ¡e vidite Å¡ta minikube radi, moÅ¾ete pronaÄ‡i URL za pristup u:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğµ Ğ´Ğ°Ñ‚Ğ¾Ñ‚ĞµĞºĞµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ¸

Ğ¡Ğ²Ğ°ĞºĞ° ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ° Ğ´Ğ°Ñ‚Ğ¾Ñ‚ĞµĞºĞ° Ğ¸Ğ¼Ğ° 3 Ğ´ĞµĞ»Ğ°: **Ğ¼ĞµÑ‚Ğ°Ğ¿Ğ¾Ğ´Ğ°Ñ†Ğ¸**, **ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ˜Ğ°** (ÑˆÑ‚Ğ° Ñ‚Ñ€ĞµĞ±Ğ° Ğ´Ğ° ÑĞµ Ğ¿Ğ¾ĞºÑ€ĞµĞ½Ğµ), **ÑÑ‚Ğ°Ñ‚ÑƒÑ** (Ğ¶ĞµÑ™ĞµĞ½Ğ¾ ÑÑ‚Ğ°ÑšĞµ).\
Ğ£Ğ½ÑƒÑ‚Ğ°Ñ€ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ˜Ğµ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğµ Ğ´Ğ°Ñ‚Ğ¾Ñ‚ĞµĞºĞµ Ğ·Ğ° Ñ€Ğ°ÑĞ¿Ğ¾Ñ€ĞµÑ’Ğ¸Ğ²Ğ°ÑšĞµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ½Ğ°Ñ›Ğ¸ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½ Ğ´ĞµÑ„Ğ¸Ğ½Ğ¸ÑĞ°Ğ½ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ¾Ğ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¾Ğ¼ ĞºĞ¾Ñ˜Ğ° Ğ´ĞµÑ„Ğ¸Ğ½Ğ¸ÑˆĞµ ÑĞ»Ğ¸ĞºÑƒ Ğ·Ğ° Ğ¿Ğ¾ĞºÑ€ĞµÑ‚Ğ°ÑšĞµ:

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ñ€Ğ°ÑĞ¿Ğ¾Ñ€ĞµÑ’Ğ¸Ğ²Ğ°ÑšĞ° + ÑƒÑĞ»ÑƒĞ³Ğµ Ğ´ĞµĞºĞ»Ğ°Ñ€Ğ¸ÑĞ°Ğ½Ğµ Ñƒ Ğ¸ÑÑ‚Ğ¾Ñ˜ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ¾Ñ˜ Ğ´Ğ°Ñ‚Ğ¾Ñ‚ĞµÑ†Ğ¸ (Ğ¸Ğ·** [**Ğ¾Ğ²Ğ´Ğµ**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

ĞšĞ°ĞºĞ¾ Ñ˜Ğµ ÑƒÑĞ»ÑƒĞ³Ğ° Ğ¾Ğ±Ğ¸Ñ‡Ğ½Ğ¾ Ğ¿Ğ¾Ğ²ĞµĞ·Ğ°Ğ½Ğ° ÑĞ° Ñ˜ĞµĞ´Ğ½Ğ¸Ğ¼ Ñ€Ğ°ÑĞ¿Ğ¾Ñ€ĞµÑ’Ğ¸Ğ²Ğ°ÑšĞµĞ¼, Ğ¼Ğ¾Ğ³ÑƒÑ›Ğµ Ñ˜Ğµ Ğ´ĞµĞºĞ»Ğ°Ñ€Ğ¸ÑĞ°Ñ‚Ğ¸ Ğ¾Ğ±Ğµ Ñƒ Ğ¸ÑÑ‚Ğ¾Ñ˜ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ¾Ñ˜ Ğ´Ğ°Ñ‚Ğ¾Ñ‚ĞµÑ†Ğ¸ (ÑƒÑĞ»ÑƒĞ³Ğ° Ğ´ĞµĞºĞ»Ğ°Ñ€Ğ¸ÑĞ°Ğ½Ğ° Ñƒ Ğ¾Ğ²Ğ¾Ñ˜ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ˜Ğ¸ Ñ˜Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ° ÑĞ°Ğ¼Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ½Ğ¾):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Primer konfiguracije spoljne usluge**

Ova usluga Ä‡e biti dostupna spolja (proverite atribute `nodePort` i `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
> [!NOTE]
> Ovo je korisno za testiranje, ali za produkciju trebate imati samo interne usluge i Ingress za izlaganje aplikacije.

**Primer Ingress konfiguracione datoteke**

Ovo Ä‡e izloÅ¾iti aplikaciju na `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Primer konfiguracione datoteke za tajne**

Obratite paÅ¾nju na to kako su lozinke kodirane u B64 (Å¡to nije sigurno!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Primer ConfigMap-a**

A **ConfigMap** je konfiguracija koja se daje podovima kako bi znali kako da lociraju i pristupaju drugim servisima. U ovom sluÄaju, svaki pod Ä‡e znati da je ime `mongodb-service` adresa poda sa kojim mogu da komuniciraju (ovaj pod Ä‡e izvrÅ¡avati mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Zatim, unutar **deployment config** ova adresa moÅ¾e biti specificirana na sledeÄ‡i naÄin kako bi se uÄitala unutar env pod-a:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Primer konfiguracije volumena**

MoÅ¾ete pronaÄ‡i razliÄite primere yaml datoteka za konfiguraciju skladiÅ¡ta na [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Napomena: volumeni nisu unutar imenskih prostora**

### Imenski prostori

Kubernetes podrÅ¾ava **viÅ¡e virtuelnih klastera** koji se oslanjaju na isti fiziÄki klaster. Ovi virtuelni klasteri se nazivaju **imenski prostori**. Namenjeni su za koriÅ¡Ä‡enje u okruÅ¾enjima sa mnogo korisnika rasporeÄ‘enih u viÅ¡e timova ili projekata. Za klastere sa nekoliko do desetina korisnika, ne bi trebalo da kreirate ili razmiÅ¡ljate o imenskim prostorima. Trebalo bi da poÄnete da koristite imenske prostore kako biste imali bolju kontrolu i organizaciju svake komponente aplikacije koja je implementirana u kubernetesu.

Imenski prostori pruÅ¾aju opseg za imena. Imena resursa moraju biti jedinstvena unutar imenskog prostora, ali ne i izmeÄ‘u imenskih prostora. Imenski prostori ne mogu biti ugnjeÅ¾deni jedni unutar drugih i **svaki** Kubernetes **resurs** moÅ¾e biti **samo** **u** **jednom** **imenskom prostoru**.

Postoje 4 imenska prostora po defaultu ako koristite minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
- **kube-system**: Nije namenjen za koriÅ¡Ä‡enje od strane korisnika i ne biste trebali da ga dirate. To je za master i kubectl procese.
- **kube-public**: Javno dostupni podaci. SadrÅ¾i configmap koji sadrÅ¾i informacije o klasteru.
- **kube-node-lease**: OdreÄ‘uje dostupnost Ävora.
- **default**: Namespace koji korisnik koristi za kreiranje resursa.
```bash
#Create namespace
kubectl create namespace my-namespace
```
> [!NOTE]
> Imajte na umu da su veÄ‡ina Kubernetes resursa (npr. pods, services, replication controllers i drugi) u nekim namespaces. MeÄ‘utim, drugi resursi kao Å¡to su namespace resursi i niskonivo resursi, kao Å¡to su nodes i persistentVolumes, nisu u namespace-u. Da biste videli koji Kubernetes resursi su i nisu u namespace-u:
>
> ```bash
> kubectl api-resources --namespaced=true #U namespace-u
> kubectl api-resources --namespaced=false #Nije u namespace-u
> ```

MoÅ¾ete saÄuvati namespace za sve naredne kubectl komande u tom kontekstu.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm je **menadÅ¾er paketa** za Kubernetes. OmoguÄ‡ava pakovanje YAML datoteka i distribuciju u javnim i privatnim repozitorijumima. Ovi paketi se nazivaju **Helm Charts**.
```
helm search <keyword>
```
Helm je takoÄ‘e engine za Å¡ablone koji omoguÄ‡ava generisanje konfiguracionih fajlova sa promenljivim:

## Kubernetes tajne

**Tajna** je objekat koji **sadrÅ¾i osetljive podatke** kao Å¡to su lozinka, token ili kljuÄ. Takve informacije bi inaÄe mogle biti stavljene u specifikaciju Pod-a ili u sliku. Korisnici mogu kreirati Tajne, a sistem takoÄ‘e kreira Tajne. Ime objekta Tajne mora biti validno **DNS poddomen ime**. ProÄitajte ovde [zvaniÄnu dokumentaciju](https://kubernetes.io/docs/concepts/configuration/secret/).

Tajne mogu biti stvari poput:

- API, SSH kljuÄevi.
- OAuth tokeni.
- Akreditivi, Lozinke (obiÄni tekst ili b64 + enkripcija).
- Informacije ili komentari.
- Kod za povezivanje sa bazom podataka, stringoviâ€¦ .

Postoje razliÄite vrste tajni u Kubernetes-u

| UgraÄ‘ena vrsta                      | Upotreba                                   |
| ----------------------------------- | ------------------------------------------ |
| **Opaque**                          | **arbitrarni podaci koje definiÅ¡e korisnik (Podrazumevano)** |
| kubernetes.io/service-account-token | token za servisni nalog                   |
| kubernetes.io/dockercfg             | serijalizovana \~/.dockercfg datoteka     |
| kubernetes.io/dockerconfigjson      | serijalizovana \~/.docker/config.json datoteka |
| kubernetes.io/basic-auth            | akreditivi za osnovnu autentifikaciju      |
| kubernetes.io/ssh-auth              | akreditivi za SSH autentifikaciju          |
| kubernetes.io/tls                   | podaci za TLS klijent ili server           |
| bootstrap.kubernetes.io/token       | podaci o bootstrap tokenu                  |

> [!NOTE]
> **Opaque tip je podrazumevani, tipiÄni par kljuÄ-vrednost koji definiÅ¡u korisnici.**

**Kako tajne funkcioniÅ¡u:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

SledeÄ‡i konfiguracioni fajl definiÅ¡e **tajnu** pod nazivom `mysecret` sa 2 para kljuÄ-vrednost `username: YWRtaW4=` i `password: MWYyZDFlMmU2N2Rm`. TakoÄ‘e definiÅ¡e **pod** pod nazivom `secretpod` koji Ä‡e imati `username` i `password` definisane u `mysecret` izloÅ¾ene u **promenljivim okruÅ¾enja** `SECRET_USERNAME` \_\_ i \_\_ `SECRET_PASSWOR`. TakoÄ‘e Ä‡e **montirati** tajnu `username` unutar `mysecret` na putanji `/etc/foo/my-group/my-username` sa `0640` dozvolama.
```yaml:secretpod.yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Tajne u etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** je konzistentna i visoko dostupna **key-value skladiÅ¡te** koje se koristi kao pozadinsko skladiÅ¡te za sve podatke klastera u Kubernetes-u. Hajde da pristupimo tajnama koje su pohranjene u etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
VideÄ‡ete certifikate, kljuÄeve i URL-ove koji se nalaze u FS-u. Kada ih dobijete, moÄ‡i Ä‡ete da se poveÅ¾ete na etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Kada uspostavite komunikaciju, moÄ‡i Ä‡ete da dobijete tajne:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodavanje enkripcije u ETCD**

Po defaultu, sve tajne su **smeÅ¡tene u obiÄnom** tekstu unutar etcd-a, osim ako ne primenite sloj enkripcije. SledeÄ‡i primer se zasniva na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
```yaml:encryption.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
Nakon toga, potrebno je postaviti `--encryption-provider-config` zastavicu na `kube-apiserver` da ukazuje na lokaciju kreirane konfiguracione datoteke. MoÅ¾ete izmeniti `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodati sledeÄ‡e linije:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Pomaknite se prema dolje u volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Pomaknite se prema dolje u volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Proveravanje da su podaci enkriptovani**

Podaci su enkriptovani kada se zapisuju u etcd. Nakon ponovnog pokretanja vaÅ¡eg `kube-apiserver`, svaka nova ili aÅ¾urirana tajna treba da bude enkriptovana kada se skladiÅ¡ti. Da biste proverili, moÅ¾ete koristiti `etcdctl` komandnu liniju da dobijete sadrÅ¾aj vaÅ¡e tajne.

1.  Kreirajte novu tajnu pod nazivom `secret1` u `default` imenskom prostoru:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```

2.  KoristeÄ‡i etcdctl komandnu liniju, proÄitajte tu tajnu iz etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gde `[...]` moraju biti dodatni argumenti za povezivanje sa etcd serverom.

3.  Proverite da je saÄuvana tajna prefiksirana sa `k8s:enc:aescbc:v1:` Å¡to ukazuje da je `aescbc` provajder enkriptovao dobijene podatke.
4.  Proverite da je tajna ispravno dekriptovana kada se preuzme putem API-ja:

```
kubectl describe secret secret1 -n default
```

trebalo bi da odgovara `mykey: bXlkYXRh`, mydata je kodirana, proverite [dekodiranje tajne](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) da biste potpuno dekodirali tajnu.

**PoÅ¡to su tajne enkriptovane prilikom pisanja, izvrÅ¡avanje aÅ¾uriranja na tajni Ä‡e enkriptovati taj sadrÅ¾aj:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**ZavrÅ¡ni saveti:**

- PokuÅ¡ajte da ne Äuvate tajne u FS-u, uzmite ih iz drugih izvora.
- Pogledajte [https://www.vaultproject.io/](https://www.vaultproject.io) za dodatnu zaÅ¡titu vaÅ¡ih tajni.
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes_deployApplicationsConjur-k8s-Secrets.htm)

## Reference

{{#ref}}
https://sickrov.github.io/
{{#endref}}

{{#ref}}
https://www.youtube.com/watch?v=X48VuDVv0do
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
