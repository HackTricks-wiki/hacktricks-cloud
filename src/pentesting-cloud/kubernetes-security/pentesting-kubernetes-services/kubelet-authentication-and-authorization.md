# Kubelet Authentication & Authorization

{{#include ../../../banners/hacktricks-training.md}}

## Kubelet Authentication <a href="#kubelet-authentication" id="kubelet-authentication"></a>

[**З документації:**](https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/)

За замовчуванням, запити до HTTPS-інтерфейсу kubelet, які не відхилені іншими налаштованими методами аутентифікації, розглядаються як анонімні запити і отримують **ім'я користувача `system:anonymous`** та **групу `system:unauthenticated`**.

**3** методи **аутентифікації**:

- **Анонімний** (за замовчуванням): Використовуйте налаштування, встановивши параметр **`--anonymous-auth=true` або конфігурацію:**
```json
"authentication": {
"anonymous": {
"enabled": true
},
```
- **Webhook**: Це **дозволить** токени **API bearer** kubectl як авторизацію (будь-який дійсний токен буде дійсним). Дозвольте це з:
- переконайтеся, що група API `authentication.k8s.io/v1beta1` увімкнена на сервері API
- запустіть kubelet з прапорами **`--authentication-token-webhook`** та **`--kubeconfig`** або використайте наступне налаштування:
```json
"authentication": {
"webhook": {
"cacheTTL": "2m0s",
"enabled": true
},
```
> [!NOTE]
> Kubelet викликає **`TokenReview` API** на налаштованому API сервері, щоб **визначити інформацію про користувача** з токенів доступу

- **X509 клієнтські сертифікати:** Дозволяють аутентифікацію через X509 клієнтські сертифікати
- дивіться [документацію з аутентифікації apiserver](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs) для отримання додаткової інформації
- запустіть kubelet з прапором `--client-ca-file`, надаючи пакет CA для перевірки клієнтських сертифікатів. Або з конфігурацією:
```json
"authentication": {
"x509": {
"clientCAFile": "/etc/kubernetes/pki/ca.crt"
}
}
```
## Kubelet Authorization <a href="#kubelet-authentication" id="kubelet-authentication"></a>

Будь-який запит, який успішно аутентифіковано (включаючи анонімний запит) **потім авторизується**. **За замовчуванням** режим авторизації - **`AlwaysAllow`**, який **дозволяє всі запити**.

Однак інше можливе значення - **`webhook`** (що ви **в основному будете знаходити там**). Цей режим **перевіряє дозволи аутентифікованого користувача** для дозволу або заборони дії.

> [!WARNING]
> Зверніть увагу, що навіть якщо **анонімна аутентифікація увімкнена**, **анонімний доступ** може **не мати жодних дозволів** для виконання будь-якої дії.

Авторизацію через webhook можна налаштувати, використовуючи **параметр `--authorization-mode=Webhook`** або через конфігураційний файл з:
```json
"authorization": {
"mode": "Webhook",
"webhook": {
"cacheAuthorizedTTL": "5m0s",
"cacheUnauthorizedTTL": "30s"
}
},
```
The kubelet викликає **`SubjectAccessReview`** API на налаштованому API сервері, щоб **визначити**, чи кожен запит є **авторизованим.**

Kubelet авторизує API запити, використовуючи той же [атрибути запиту](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#review-your-request-attributes) підхід, що й apiserver:

- **Дія**

| HTTP verb | request verb                                                                                                                                                  |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| POST      | create                                                                                                                                                        |
| GET, HEAD | get (для окремих ресурсів), list (для колекцій, включаючи повний вміст об'єкта), watch (для спостереження за окремим ресурсом або колекцією ресурсів) |
| PUT       | update                                                                                                                                                        |
| PATCH     | patch                                                                                                                                                         |
| DELETE    | delete (для окремих ресурсів), deletecollection (для колекцій)                                                                                             |

- **Ресурс**, що спілкується з Kubelet api, **завжди** **вузли**, а **субресурс** **визначається** з шляху вхідного запиту:

| Kubelet API  | ресурс | субресурс |
| ------------ | ------ | --------- |
| /stats/\*    | вузли  | stats     |
| /metrics/\*  | вузли  | metrics   |
| /logs/\*     | вузли  | log       |
| /spec/\*     | вузли  | spec      |
| _всі інші_   | вузли  | proxy     |

Наприклад, наступний запит намагався отримати доступ до інформації про поди kubelet без дозволу:
```bash
curl -k --header "Authorization: Bearer ${TOKEN}" 'https://172.31.28.172:10250/pods'
Forbidden (user=system:node:ip-172-31-28-172.ec2.internal, verb=get, resource=nodes, subresource=proxy)
```
- Ми отримали **Заборонено**, тому запит **пройшов перевірку автентифікації**. Якщо б ні, ми отримали б лише повідомлення `Неавторизовано`.
- Ми можемо бачити **ім'я користувача** (в даному випадку з токена)
- Перевірте, як **ресурсом** були **вузли**, а **субресурсом** **проксі** (що має сенс з попередньою інформацією)

## References

- [https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/](https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/)

{{#include ../../../banners/hacktricks-training.md}}
