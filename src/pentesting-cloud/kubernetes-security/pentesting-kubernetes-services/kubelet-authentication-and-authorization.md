# Kubelet-Authentifizierung & Autorisierung

{{#include ../../../banners/hacktricks-training.md}}

## Kubelet-Authentifizierung <a href="#kubelet-authentication" id="kubelet-authentication"></a>

[**Aus den Dokumenten:**](https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/)

Standardmäßig werden Anfragen an den HTTPS-Endpunkt des Kubelets, die von anderen konfigurierten Authentifizierungsmethoden nicht abgelehnt werden, als anonyme Anfragen behandelt und erhalten einen **Benutzernamen von `system:anonymous`** und eine **Gruppe von `system:unauthenticated`**.

Die **3** Authentifizierung **Methoden** sind:

- **Anonym** (Standard): Verwenden Sie die Einstellung des Parameters **`--anonymous-auth=true` oder die Konfiguration:**
```json
"authentication": {
"anonymous": {
"enabled": true
},
```
- **Webhook**: Dies wird die **API-Bearer-Token** von kubectl als Autorisierung **aktivieren** (jedes gültige Token wird gültig sein). Erlauben Sie es mit:
- Stellen Sie sicher, dass die API-Gruppe `authentication.k8s.io/v1beta1` im API-Server aktiviert ist
- Starten Sie den Kubelet mit den **`--authentication-token-webhook`** und **`--kubeconfig`** Flags oder verwenden Sie die folgende Einstellung:
```json
"authentication": {
"webhook": {
"cacheTTL": "2m0s",
"enabled": true
},
```
> [!NOTE]
> Der kubelet ruft die **`TokenReview` API** auf dem konfigurierten API-Server auf, um **Benutzerinformationen** aus Bearer-Token zu bestimmen.

- **X509-Clientzertifikate:** Ermöglichen die Authentifizierung über X509-Clientzertifikate
- siehe die [apiserver authentication documentation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs) für weitere Details
- starten Sie den kubelet mit dem `--client-ca-file` Flag, um ein CA-Bundle bereitzustellen, um Clientzertifikate zu überprüfen. Oder mit der Konfiguration:
```json
"authentication": {
"x509": {
"clientCAFile": "/etc/kubernetes/pki/ca.crt"
}
}
```
## Kubelet-Authentifizierung <a href="#kubelet-authentication" id="kubelet-authentication"></a>

Jede Anfrage, die erfolgreich authentifiziert wird (einschließlich einer anonymen Anfrage), **wird dann autorisiert**. Der **Standard**-Autorisierungsmodus ist **`AlwaysAllow`**, der **alle Anfragen erlaubt**.

Der andere mögliche Wert ist jedoch **`webhook`** (was Sie **hauptsächlich dort finden werden**). Dieser Modus **prüft die Berechtigungen des authentifizierten Benutzers**, um eine Aktion zu erlauben oder abzulehnen.

> [!WARNING]
> Beachten Sie, dass selbst wenn die **anonyme Authentifizierung aktiviert ist**, der **anonyme Zugriff** möglicherweise **keine Berechtigungen** hat, um eine Aktion auszuführen.

Die Autorisierung über Webhook kann mit dem **Parameter `--authorization-mode=Webhook`** oder über die Konfigurationsdatei konfiguriert werden mit:
```json
"authorization": {
"mode": "Webhook",
"webhook": {
"cacheAuthorizedTTL": "5m0s",
"cacheUnauthorizedTTL": "30s"
}
},
```
Der Kubelet ruft die **`SubjectAccessReview`** API auf dem konfigurierten API-Server auf, um **festzustellen**, ob jede Anfrage **autorisierte** ist.

Der Kubelet autorisiert API-Anfragen mit demselben [Anfrageattribut](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#review-your-request-attributes) Ansatz wie der Apiserver:

- **Aktion**

| HTTP-Verb | Anfrage-Verb                                                                                                                                                  |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| POST      | erstellen                                                                                                                                                     |
| GET, HEAD | abrufen (für einzelne Ressourcen), auflisten (für Sammlungen, einschließlich des vollständigen Objektinhalts), beobachten (für das Beobachten einer einzelnen Ressource oder Sammlung von Ressourcen) |
| PUT       | aktualisieren                                                                                                                                                 |
| PATCH     | patch                                                                                                                                                          |
| DELETE    | löschen (für einzelne Ressourcen), sammlunglöschen (für Sammlungen)                                                                                          |

- Die **Ressource**, die mit der Kubelet-API kommuniziert, ist **immer** **nodes** und **subresource** wird **bestimmt** aus dem Pfad der eingehenden Anfrage:

| Kubelet API  | Ressource | Subressource |
| ------------ | --------- | ------------ |
| /stats/\*    | nodes     | stats        |
| /metrics/\*  | nodes     | metrics      |
| /logs/\*     | nodes     | log          |
| /spec/\*     | nodes     | spec         |
| _alle anderen_ | nodes   | proxy        |

Zum Beispiel versuchte die folgende Anfrage, auf die Pods-Informationen des Kubelet ohne Berechtigung zuzugreifen:
```bash
curl -k --header "Authorization: Bearer ${TOKEN}" 'https://172.31.28.172:10250/pods'
Forbidden (user=system:node:ip-172-31-28-172.ec2.internal, verb=get, resource=nodes, subresource=proxy)
```
- Wir haben ein **Forbidden** erhalten, also hat die Anfrage die **Authentifizierungsprüfung bestanden**. Andernfalls hätten wir nur eine `Unauthorised`-Nachricht erhalten.
- Wir können den **Benutzernamen** sehen (in diesem Fall aus dem Token)
- Überprüfen Sie, wie die **Ressource** **nodes** und die **Subressource** **proxy** war (was mit den vorherigen Informationen Sinn macht)

## References

- [https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/](https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/)

{{#include ../../../banners/hacktricks-training.md}}
