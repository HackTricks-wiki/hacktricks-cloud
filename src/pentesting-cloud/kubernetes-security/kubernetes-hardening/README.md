# Kubernetes Hardening

{{#include ../../../banners/hacktricks-training.md}}

## Narzędzia do analizy klastra

### [Steampipe - Kubernetes Compliance](https://github.com/turbot/steampipe-mod-kubernetes-compliance)

Wykonuje **kilka kontroli zgodności w klastrze Kubernetes**. Zawiera wsparcie dla CIS oraz raportów technicznych National Security Agency (NSA) i Cybersecurity and Infrastructure Security Agency (CISA) dotyczących hardeningu Kubernetes.
```bash
# Install Steampipe
brew install turbot/tap/powerpipe
brew install turbot/tap/steampipe
steampipe plugin install kubernetes

# Start the service
steampipe service start

# Install the module
mkdir dashboards
cd dashboards
powerpipe mod init
powerpipe mod install github.com/turbot/steampipe-mod-kubernetes-compliance

# Run the module
powerpipe server
```
### [**Kubescape**](https://github.com/armosec/kubescape)

[**Kubescape**](https://github.com/armosec/kubescape) to otwartoźródłowe narzędzie dla K8s, oferujące jednolity widok K8s dla środowisk multi-cloud, obejmujące analizę ryzyka, zgodność bezpieczeństwa, wizualizator RBAC oraz skanowanie podatności obrazów. Kubescape skanuje klastry K8s, pliki YAML oraz HELM charts, wykrywając błędy konfiguracji zgodnie z wieloma frameworkami (takimi jak the [NSA-CISA](https://www.armosec.io/blog/kubernetes-hardening-guidance-summary-by-armo) , [MITRE ATT\&CK®](https://www.microsoft.com/security/blog/2021/03/23/secure-containerized-environments-with-updated-threat-matrix-for-kubernetes/)), podatności oprogramowania oraz naruszenia RBAC (kontrola dostępu oparta na rolach) we wczesnych etapach potoku CI/CD, natychmiast oblicza wynik ryzyka i pokazuje trendy ryzyka w czasie.
```bash
curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
kubescape scan --verbose
```
### [**Popeye**](https://github.com/derailed/popeye)

[**Popeye**](https://github.com/derailed/popeye) to narzędzie, które skanuje działający klaster Kubernetes i **zgłasza potencjalne problemy z wdrożonymi zasobami i konfiguracjami**. Ocenia stan klastra na podstawie tego, co jest wdrożone, a nie tego, co znajduje się na dysku. Skanując klaster, wykrywa błędne konfiguracje i pomaga zapewnić stosowanie najlepszych praktyk, zapobiegając w ten sposób przyszłym problemom. Ma na celu zmniejszenie obciążenia poznawczego — cognitive \_over_load — z jakim mierzy się operator klastra Kubernetes w środowisku produkcyjnym. Ponadto, jeśli klaster korzysta z metric-server, raportuje potencjalne nadmierne/niedostateczne przydziały zasobów i próbuje ostrzec, jeśli klaster wyczerpie dostępne zasoby.

### [**Kube-bench**](https://github.com/aquasecurity/kube-bench)

Narzędzie [**kube-bench**](https://github.com/aquasecurity/kube-bench) sprawdza, czy Kubernetes jest wdrożony bezpiecznie, uruchamiając testy opisane w [**CIS Kubernetes Benchmark**].\
Możesz wybrać:

- uruchomić kube-bench z wnętrza kontenera (dzieląc namespace PID z hostem)
- uruchomić kontener, który zainstaluje kube-bench na hoście, a następnie uruchomić kube-bench bezpośrednio na hoście
- zainstalować najnowsze binaria ze strony [Releases page],
- skompilować je ze źródeł.

### [**Kubeaudit**](https://github.com/Shopify/kubeaudit)

**[DEPRECATED]** Narzędzie [**kubeaudit**](https://github.com/Shopify/kubeaudit) to narzędzie wiersza poleceń i pakiet Go do **audytowania klastrów Kubernetes** pod kątem różnych zagadnień związanych z bezpieczeństwem.

Kubeaudit potrafi wykryć, czy działa wewnątrz kontenera w klastrze. Jeśli tak, spróbuje audytować wszystkie zasoby Kubernetes w tym klastrze:
```
kubeaudit all
```
To narzędzie ma także argument `autofix`, który pozwala **automatycznie naprawiać wykryte problemy.**

### [**Kube-hunter**](https://github.com/aquasecurity/kube-hunter)

**[PRZESTARZAŁE]** Narzędzie [**kube-hunter**](https://github.com/aquasecurity/kube-hunter) wyszukuje luki bezpieczeństwa w klastrach Kubernetes. Narzędzie zostało opracowane, aby zwiększyć świadomość i widoczność problemów związanych z bezpieczeństwem w środowiskach Kubernetes.
```bash
kube-hunter --remote some.node.com
```
### [Trivy](https://github.com/aquasecurity/trivy)

[Trivy](https://github.com/aquasecurity/trivy) posiada skanery, które wyszukują problemy z bezpieczeństwem oraz cele, w których może znaleźć te problemy:

- Obraz kontenera
- System plików
- Repozytorium Git (zdalne)
- Obraz maszyny wirtualnej
- Kubernetes


### [**Kubei**](https://github.com/Erezf-p/kubei)

**[Wygląda na nieutrzymywany]**

[**Kubei**](https://github.com/Erezf-p/kubei) to narzędzie do skanowania podatności oraz narzędzie CIS Docker benchmark, które pozwala użytkownikom uzyskać dokładną i natychmiastową ocenę ryzyka ich klastrów Kubernetes. Kubei skanuje wszystkie obrazy używane w klastrze Kubernetes, w tym obrazy podów aplikacyjnych oraz podów systemowych.

### [**KubiScan**](https://github.com/cyberark/KubiScan)

[**KubiScan**](https://github.com/cyberark/KubiScan) to narzędzie do skanowania klastra Kubernetes pod kątem ryzykownych uprawnień w modelu autoryzacji Role-based access control (RBAC).

### [Managed Kubernetes Auditing Toolkit](https://github.com/DataDog/managed-kubernetes-auditing-toolkit)

[**Mkat**](https://github.com/DataDog/managed-kubernetes-auditing-toolkit) to narzędzie stworzone do testowania innych typów kontroli wysokiego ryzyka w porównaniu z innymi narzędziami. Posiada głównie 3 różne tryby:

- **`find-role-relationships`**: który znajdzie, które role AWS działają w których podach
- **`find-secrets`**: który próbuje zidentyfikować sekrety w zasobach K8s, takich jak Pods, ConfigMaps i Secrets.
- **`test-imds-access`**: który spróbuje uruchomić pody i uzyskać dostęp do metadanych v1 i v2. UWAGA: To uruchomi poda w klastrze — bądź bardzo ostrożny, ponieważ być może nie chcesz tego robić!

## **Audyt kodu IaC**

### [**KICS**](https://github.com/Checkmarx/kics)

[**KICS**](https://github.com/Checkmarx/kics) znajduje **luki bezpieczeństwa**, problemy ze zgodnością oraz błędne konfiguracje infrastruktury w następujących rozwiązaniach Infrastructure as Code: Terraform, Kubernetes, Docker, AWS CloudFormation, Ansible, Helm, Microsoft ARM oraz specyfikacjach OpenAPI 3.0.

### [**Checkov**](https://github.com/bridgecrewio/checkov)

[**Checkov**](https://github.com/bridgecrewio/checkov) to narzędzie do analizy statycznej kodu dla infrastructure-as-code.

Skanuje infrastrukturę chmurową prowizjonowaną przy użyciu [Terraform](https://terraform.io), Terraform plan, [Cloudformation](https://aws.amazon.com/cloudformation/), [AWS SAM](https://aws.amazon.com/serverless/sam/), [Kubernetes](https://kubernetes.io), [Dockerfile](https://www.docker.com), [Serverless](https://www.serverless.com) lub [ARM Templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) i wykrywa błędne konfiguracje bezpieczeństwa i zgodności przy użyciu skanowania opartego na grafie.

### [**Kube-score**](https://github.com/zegl/kube-score)

[**kube-score**](https://github.com/zegl/kube-score) to narzędzie wykonujące statyczną analizę kodu definicji obiektów Kubernetes.

Aby zainstalować:

| Dystrybucja                                         | Polecenie / Link                                                                         |
| --------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| Pre-built binaries for macOS, Linux, and Windows    | [GitHub releases](https://github.com/zegl/kube-score/releases)                          |
| Docker                                              | `docker pull zegl/kube-score` ([Docker Hub)](https://hub.docker.com/r/zegl/kube-score/) |
| Homebrew (macOS and Linux)                          | `brew install kube-score`                                                               |
| [Krew](https://krew.sigs.k8s.io/) (macOS and Linux) | `kubectl krew install score`                                                            |

## Narzędzia do analizy plików YAML & Helm Charts

### [**Kube-linter**](https://github.com/stackrox/kube-linter)
```bash
# Install Kube-linter
brew install kube-linter

# Run Kube-linter
## lint ./path/to/yaml/or/chart
```
### [Checkov](https://github.com/bridgecrewio/checkov)
```bash
# Install Checkov
pip install checkov

# Run Checkov
checkov -d ./path/to/yaml/or/chart
```
### [kube‑score](https://github.com/zegl/kube-score)
```bash
# Install kube-score
brew install kube-score

# Run kube-score
kube-score score ./path/to/yaml
# or
helm template chart /path/to/chart | kube-score score -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kube-score score -
```
### [Kubesec](https://github.com/controlplaneio/kubesec)
```bash
# Install Kubesec
## Download from https://github.com/controlplaneio/kubesec/releases

# Run Kubesec in a yaml
kubesec scan ./path/to/yaml
# or
helm template chart /path/to/chart | kubesec scan -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kubesec scan -
```
## Skanowanie problemów z zależnościami

### Skanowanie obrazów
```bash
#!/bin/bash
export images=$(kubectl get pods --all-namespaces -o jsonpath="{range .items[]}{.spec.containers[].image}{'\n'}{end}" | sort | uniq)
echo "All images found: $images"
echo ""
echo ""
for image in $images; do
# Run trivy scan and save JSON output
trivy image --format json --output /tmp/result.json --severity HIGH,CRITICAL "$image" >/dev/null 2>&1
# Extract binary targets that have vulnerabilities
binaries=$(jq -r '.Results[] | select(.Vulnerabilities != null) | .Target' /tmp/result.json)
if [ -n "$binaries" ]; then
echo "- **Image:** $image"
while IFS= read -r binary; do
echo "  - **Binary:** $binary"
jq -r --arg target "$binary" '
.Results[] | select(.Target == $target) | .Vulnerabilities[] |
"    - **\(.Title)** (\(.Severity)): Affecting `\(.PkgName)` fixed in version `\(.FixedVersion)` (current version is `\(.InstalledVersion)`)."
' /tmp/result.json
done <<< "$binaries"
echo ""
echo ""
echo ""
fi
done
```
### Skanowanie Helm charts
```bash
#!/bin/bash
# scan-helm-charts.sh
# This script lists all Helm releases, renders their manifests,
# and then scans each manifest with Trivy for configuration issues.

# Check that jq is installed
if ! command -v jq &>/dev/null; then
echo "jq is required but not installed. Please install jq and rerun."
exit 1
fi

# List all helm releases and extract namespace and release name
echo "Listing Helm releases..."
helm list --all-namespaces -o json | jq -r '.[] | "\(.namespace) \(.name)"' > helm_releases.txt

# Check if any releases were found
if [ ! -s helm_releases.txt ]; then
echo "No Helm releases found."
exit 0
fi

# Loop through each Helm release and scan its rendered manifest
while IFS=" " read -r namespace release; do
echo "---------------------------------------------"
echo "Scanning Helm release '$release' in namespace '$namespace'..."
# Render the Helm chart manifest
manifest_file="${release}-manifest.yaml"
helm get manifest "$release" -n "$namespace" > "$manifest_file"
if [ $? -ne 0 ]; then
echo "Failed to get manifest for $release in $namespace. Skipping."
continue
fi
# Scan the manifest with Trivy (configuration scan)
echo "Running Trivy config scan on $manifest_file..."
trivy config --severity MEDIUM,HIGH,CRITICAL "$manifest_file"
echo "Completed scan for $release."
done < helm_releases.txt

echo "---------------------------------------------"
echo "Helm chart scanning complete."
```
## Tips

### Kubernetes PodSecurityContext and SecurityContext

You can configure the **security context of the Pods** (with _PodSecurityContext_) and of the **containers** that are going to be run (with _SecurityContext_). For more information read:

{{#ref}}
kubernetes-securitycontext-s.md
{{#endref}}

### Kubernetes API Hardening

To bardzo ważne, aby **chronić dostęp do Kubernetes Api Server**, ponieważ złośliwy aktor z wystarczającymi uprawnieniami mógłby go nadużyć i w różny sposób uszkodzić środowisko.\
Ważne jest zabezpieczenie zarówno **dostępu** ( **whitelist** originów, które mogą łączyć się z API Server i odrzucanie innych połączeń) jak i [**uwierzytelniania**](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/) (zgodnie z zasadą **najmniejszych** **uprawnień**). I zdecydowanie **nigdy** **nie** **zezwalaj** **na** **anonimowe** **żądania**.

**Typowy proces żądania:**\
Użytkownik lub K8s ServiceAccount –> Uwierzytelnianie –> Autoryzacja –> Admission Control.

**Wskazówki**:

- Zamknij porty.
- Unikaj dostępu anonimowego.
- NodeRestriction; brak dostępu z określonych węzłów do API.
- [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction)
- W praktyce uniemożliwia kubeletom dodawanie/usuwanie/aktualizowanie etykiet z prefiksem node-restriction.kubernetes.io/. Ten prefiks etykiety jest zarezerwowany dla administratorów do oznaczania ich Node objects w celach izolacji workloadów, i kubeletom nie będzie wolno modyfikować etykiet z tym prefiksem.
- A także pozwala kubeletom na dodawanie/usuwanie/aktualizowanie tych etykiet i prefiksów etykiet.
- Zapewnij bezpieczną izolację workloadów za pomocą etykiet.
- Uniemożliwiaj konkretnym pods dostęp do API.
- Unikaj wystawienia ApiServer do internetu.
- Zapobiegaj nieautoryzowanemu dostępowi — RBAC.
- Port ApiServer zabezpiecz zaporą i whitelistą IP.

### SecurityContext Hardening

Domyślnie użytkownik root będzie używany, gdy Pod zostanie uruchomiony, jeśli nie zostanie określony inny użytkownik. Możesz uruchomić swoją aplikację w bardziej bezpiecznym kontekście, używając szablonu podobnego do poniższego:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: security-context-demo
spec:
securityContext:
runAsUser: 1000
runAsGroup: 3000
fsGroup: 2000
volumes:
- name: sec-ctx-vol
emptyDir: {}
containers:
- name: sec-ctx-demo
image: busybox
command: [ "sh", "-c", "sleep 1h" ]
securityContext:
runAsNonRoot: true
volumeMounts:
- name: sec-ctx-vol
mountPath: /data/demo
securityContext:
allowPrivilegeEscalation: true
```
- [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
- [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)

### General Hardening

Należy aktualizować środowisko Kubernetes tak często, jak to konieczne, aby zapewnić:

- Zaktualizowane zależności.
- Poprawki błędów i bezpieczeństwa.

[**Release cycles**](https://kubernetes.io/docs/setup/release/version-skew-policy/): Co 3 miesiące pojawia się nowe wydanie minor -- 1.20.3 = 1(Major).20(Minor).3(patch)

**Najlepszy sposób aktualizacji klastra Kubernetes jest (z** [**here**](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/)**):**

- Zaktualizuj komponenty Master Node według następującej kolejności:
- etcd (all instances).
- kube-apiserver (all control plane hosts).
- kube-controller-manager.
- kube-scheduler.
- cloud controller manager, if you use one.
- Zaktualizuj komponenty Worker Node, takie jak kube-proxy, kubelet.

## Kubernetes monitoring & security:

- Kyverno Policy Engine
- Cilium Tetragon - oparte na eBPF obserwowalność bezpieczeństwa i egzekwowanie w czasie wykonywania
- Network Security Policies
- Falco - monitorowanie bezpieczeństwa w czasie wykonywania i wykrywanie

{{#include ../../../banners/hacktricks-training.md}}
