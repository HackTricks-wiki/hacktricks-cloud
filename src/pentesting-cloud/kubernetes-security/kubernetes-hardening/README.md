# Kubernetes Hardening

{{#include ../../../banners/hacktricks-training.md}}

## Herramientas para analizar un cluster

### [Steampipe - Kubernetes Compliance](https://github.com/turbot/steampipe-mod-kubernetes-compliance)

Realiza **varias comprobaciones de cumplimiento en el cluster de Kubernetes**. Incluye soporte para CIS y para los informes técnicos de ciberseguridad de la National Security Agency (NSA) y de la Cybersecurity and Infrastructure Security Agency (CISA) sobre Kubernetes hardening.
```bash
# Install Steampipe
brew install turbot/tap/powerpipe
brew install turbot/tap/steampipe
steampipe plugin install kubernetes

# Start the service
steampipe service start

# Install the module
mkdir dashboards
cd dashboards
powerpipe mod init
powerpipe mod install github.com/turbot/steampipe-mod-kubernetes-compliance

# Run the module
powerpipe server
```
### [**Kubescape**](https://github.com/armosec/kubescape)

[**Kubescape**](https://github.com/armosec/kubescape) es una herramienta de código abierto para K8s que ofrece un panel único para K8s multi-cloud, incluyendo análisis de riesgo, cumplimiento de seguridad, visualizador de RBAC y escaneo de vulnerabilidades en imágenes. Kubescape analiza clusters K8s, archivos YAML y charts HELM, detectando malas configuraciones según múltiples marcos (como el [NSA-CISA](https://www.armosec.io/blog/kubernetes-hardening-guidance-summary-by-armo) , [MITRE ATT\&CK®](https://www.microsoft.com/security/blog/2021/03/23/secure-containerized-environments-with-updated-threat-matrix-for-kubernetes/)), vulnerabilidades de software y violaciones de RBAC (role-based-access-control) en etapas tempranas del pipeline CI/CD, calcula la puntuación de riesgo al instante y muestra las tendencias de riesgo a lo largo del tiempo.
```bash
curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
kubescape scan --verbose
```
### [**Popeye**](https://github.com/derailed/popeye)

[**Popeye**](https://github.com/derailed/popeye) es una utilidad que escanea un Kubernetes cluster en vivo y **informa de posibles problemas con los recursos y las configuraciones desplegadas**. Sanitiza tu cluster basándose en lo que está desplegado y no en lo que hay en disco. Al escanear tu cluster, detecta configuraciones incorrectas y te ayuda a garantizar que las mejores prácticas estén en su lugar, evitando dolores de cabeza futuros. Su objetivo es reducir la sobrecarga cognitiva que se enfrenta al operar un Kubernetes cluster en entornos reales. Además, si tu cluster emplea un metric-server, informa sobre posibles asignaciones de recursos por exceso/insuficiencia e intenta advertirte si tu cluster se queda sin capacidad.

### [**Kube-bench**](https://github.com/aquasecurity/kube-bench)

La herramienta [**kube-bench**](https://github.com/aquasecurity/kube-bench) comprueba si Kubernetes está desplegado de forma segura ejecutando las verificaciones documentadas en el [**CIS Kubernetes Benchmark**](https://www.cisecurity.org/benchmark/kubernetes/).\
Puedes elegir:

- ejecutar kube-bench desde dentro de un contenedor (compartiendo el PID namespace con el host)
- ejecutar un contenedor que instale kube-bench en el host y luego ejecutar kube-bench directamente en el host
- instalar los binarios más recientes desde la [Releases page](https://github.com/aquasecurity/kube-bench/releases),
- compilarlo desde el código fuente.

### [**Kubeaudit**](https://github.com/Shopify/kubeaudit)

**[DEPRECATED]** La herramienta [**kubeaudit**](https://github.com/Shopify/kubeaudit) es una herramienta de línea de comandos y un paquete Go para **auditar Kubernetes clusters** por diversas cuestiones de seguridad.

Kubeaudit puede detectar si se está ejecutando dentro de un contenedor en un cluster. Si es así, intentará auditar todos los recursos de Kubernetes en ese cluster:
```
kubeaudit all
```
Esta herramienta también tiene el argumento `autofix` para **corregir automáticamente los problemas detectados.**

### [**Kube-hunter**](https://github.com/aquasecurity/kube-hunter)

**[OBSOLETO]** La herramienta [**kube-hunter**](https://github.com/aquasecurity/kube-hunter) busca vulnerabilidades de seguridad en clusters de Kubernetes. La herramienta fue desarrollada para aumentar la conciencia y la visibilidad de los problemas de seguridad en entornos de Kubernetes.
```bash
kube-hunter --remote some.node.com
```
### [Trivy](https://github.com/aquasecurity/trivy)

[Trivy](https://github.com/aquasecurity/trivy) tiene scanners que buscan problemas de seguridad, y objetivos donde puede encontrar esos problemas:

- Imagen de contenedor
- Sistema de archivos
- Repositorio Git (remoto)
- Imagen de máquina virtual
- Kubernetes


### [**Kubei**](https://github.com/Erezf-p/kubei)

[**Parece no mantenido**]

[**Kubei**](https://github.com/Erezf-p/kubei) es una herramienta de escaneo de vulnerabilidades y CIS Docker benchmark que permite a los usuarios obtener una evaluación de riesgo precisa e inmediata de sus clústeres de Kubernetes. Kubei escanea todas las imágenes que se usan en un clúster de Kubernetes, incluyendo las imágenes de los pods de aplicación y de sistema.

### [**KubiScan**](https://github.com/cyberark/KubiScan)

[**KubiScan**](https://github.com/cyberark/KubiScan) es una herramienta para escanear clústeres de Kubernetes en busca de permisos riesgosos en el modelo de autorización de control de acceso basado en roles (RBAC) de Kubernetes.

### [Managed Kubernetes Auditing Toolkit](https://github.com/DataDog/managed-kubernetes-auditing-toolkit)

[**Mkat**](https://github.com/DataDog/managed-kubernetes-auditing-toolkit) es una herramienta creada para probar otro tipo de comprobaciones de alto riesgo en comparación con las demás herramientas. Principalmente tiene 3 modos diferentes:

- **`find-role-relationships`**: Que encontrará qué roles de AWS se están ejecutando en qué pods
- **`find-secrets`**: Que intenta identificar secretos en recursos de K8s como Pods, ConfigMaps y Secrets.
- **`test-imds-access`**: Que intentará ejecutar pods e intentar acceder a la metadata v1 y v2. ADVERTENCIA: Esto ejecutará un pod en el clúster, ten mucho cuidado porque quizá no quieras hacer esto!

## **Auditar código IaC**

### [**KICS**](https://github.com/Checkmarx/kics)

[**KICS**](https://github.com/Checkmarx/kics) encuentra **vulnerabilidades de seguridad**, problemas de cumplimiento y errores de configuración de infraestructura en las siguientes **soluciones de Infraestructura como Código**: Terraform, Kubernetes, Docker, AWS CloudFormation, Ansible, Helm, Microsoft ARM y especificaciones OpenAPI 3.0

### [**Checkov**](https://github.com/bridgecrewio/checkov)

[**Checkov**](https://github.com/bridgecrewio/checkov) es una herramienta de análisis estático de código para infraestructura como código.

Escanea infraestructura en la nube provisionada usando [Terraform](https://terraform.io), Terraform plan, [Cloudformation](https://aws.amazon.com/cloudformation/), [AWS SAM](https://aws.amazon.com/serverless/sam/), [Kubernetes](https://kubernetes.io), [Dockerfile](https://www.docker.com), [Serverless](https://www.serverless.com) o [ARM Templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) y detecta errores de configuración de seguridad y cumplimiento usando escaneo basado en grafos.

### [**Kube-score**](https://github.com/zegl/kube-score)

[**kube-score**](https://github.com/zegl/kube-score) es una herramienta que realiza análisis estático de las definiciones de objetos de Kubernetes.

To install:

| Distribución                                        | Comando / Link                                                                          |
| --------------------------------------------------- | --------------------------------------------------------------------------------------- |
| Pre-built binaries for macOS, Linux, and Windows    | [GitHub releases](https://github.com/zegl/kube-score/releases)                          |
| Docker                                              | `docker pull zegl/kube-score` ([Docker Hub)](https://hub.docker.com/r/zegl/kube-score/) |
| Homebrew (macOS and Linux)                          | `brew install kube-score`                                                               |
| [Krew](https://krew.sigs.k8s.io/) (macOS and Linux) | `kubectl krew install score`                                                            |

## Tools to analyze YAML files & Helm Charts

### [**Kube-linter**](https://github.com/stackrox/kube-linter)
```bash
# Install Kube-linter
brew install kube-linter

# Run Kube-linter
## lint ./path/to/yaml/or/chart
```
### [Checkov](https://github.com/bridgecrewio/checkov)
```bash
# Install Checkov
pip install checkov

# Run Checkov
checkov -d ./path/to/yaml/or/chart
```
### [kube‑score](https://github.com/zegl/kube-score)
```bash
# Install kube-score
brew install kube-score

# Run kube-score
kube-score score ./path/to/yaml
# or
helm template chart /path/to/chart | kube-score score -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kube-score score -
```
### [Kubesec](https://github.com/controlplaneio/kubesec)
```bash
# Install Kubesec
## Download from https://github.com/controlplaneio/kubesec/releases

# Run Kubesec in a yaml
kubesec scan ./path/to/yaml
# or
helm template chart /path/to/chart | kubesec scan -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kubesec scan -
```
## Escanear problemas de dependencias

### Escanear imágenes
```bash
#!/bin/bash
export images=$(kubectl get pods --all-namespaces -o jsonpath="{range .items[]}{.spec.containers[].image}{'\n'}{end}" | sort | uniq)
echo "All images found: $images"
echo ""
echo ""
for image in $images; do
# Run trivy scan and save JSON output
trivy image --format json --output /tmp/result.json --severity HIGH,CRITICAL "$image" >/dev/null 2>&1
# Extract binary targets that have vulnerabilities
binaries=$(jq -r '.Results[] | select(.Vulnerabilities != null) | .Target' /tmp/result.json)
if [ -n "$binaries" ]; then
echo "- **Image:** $image"
while IFS= read -r binary; do
echo "  - **Binary:** $binary"
jq -r --arg target "$binary" '
.Results[] | select(.Target == $target) | .Vulnerabilities[] |
"    - **\(.Title)** (\(.Severity)): Affecting `\(.PkgName)` fixed in version `\(.FixedVersion)` (current version is `\(.InstalledVersion)`)."
' /tmp/result.json
done <<< "$binaries"
echo ""
echo ""
echo ""
fi
done
```
### Escanear Helm charts
```bash
#!/bin/bash
# scan-helm-charts.sh
# This script lists all Helm releases, renders their manifests,
# and then scans each manifest with Trivy for configuration issues.

# Check that jq is installed
if ! command -v jq &>/dev/null; then
echo "jq is required but not installed. Please install jq and rerun."
exit 1
fi

# List all helm releases and extract namespace and release name
echo "Listing Helm releases..."
helm list --all-namespaces -o json | jq -r '.[] | "\(.namespace) \(.name)"' > helm_releases.txt

# Check if any releases were found
if [ ! -s helm_releases.txt ]; then
echo "No Helm releases found."
exit 0
fi

# Loop through each Helm release and scan its rendered manifest
while IFS=" " read -r namespace release; do
echo "---------------------------------------------"
echo "Scanning Helm release '$release' in namespace '$namespace'..."
# Render the Helm chart manifest
manifest_file="${release}-manifest.yaml"
helm get manifest "$release" -n "$namespace" > "$manifest_file"
if [ $? -ne 0 ]; then
echo "Failed to get manifest for $release in $namespace. Skipping."
continue
fi
# Scan the manifest with Trivy (configuration scan)
echo "Running Trivy config scan on $manifest_file..."
trivy config --severity MEDIUM,HIGH,CRITICAL "$manifest_file"
echo "Completed scan for $release."
done < helm_releases.txt

echo "---------------------------------------------"
echo "Helm chart scanning complete."
```
## Consejos

### Kubernetes PodSecurityContext y SecurityContext

Puedes configurar el **contexto de seguridad de los Pods** (con _PodSecurityContext_) y de los **contenedores** que se van a ejecutar (con _SecurityContext_). Para más información lee:

{{#ref}}
kubernetes-securitycontext-s.md
{{#endref}}

### Kubernetes API Hardening

Es muy importante **proteger el acceso al Kubernetes API Server** ya que un actor malicioso con suficientes privilegios podría abusar de él y dañar de muchas maneras el entorno.\
Es importante asegurar tanto el **acceso** (**whitelist** orígenes que pueden acceder al API Server y denegar cualquier otra conexión) como la [**autenticación**](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/) (siguiendo el principio de **mínimo** **privilegio**). Y definitivamente **nunca** **permitas** **peticiones** **anónimas**.

**Proceso común de las solicitudes:**\
Usuario o K8s ServiceAccount –> Autenticación –> Autorización –> Admission Control.

**Consejos**:

- Cerrar puertos.
- Evitar acceso anónimo.
- NodeRestriction; No permitir acceso desde nodos específicos a la API.
- [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction)
- Básicamente evita que los kubelets añadan/elimininen/actualicen labels con el prefijo node-restriction.kubernetes.io/. Este prefijo de label está reservado para que los administradores etiqueten sus objetos Node para fines de aislamiento de workloads, y a los kubelets no se les permitirá modificar labels con ese prefijo.
- Y además, permite a los kubelets añadir/eliminar/actualizar estas labels y prefijos de label.
- Asegurar con labels el aislamiento seguro de workloads.
- Evitar que pods específicos accedan a la API.
- Evitar exponer el ApiServer a Internet.
- Evitar acceso no autorizado mediante RBAC.
- Puerto del ApiServer protegido con firewall y whitelist de IPs.

### SecurityContext Hardening

Por defecto se usará el usuario root cuando se inicie un Pod si no se especifica otro usuario. Puedes ejecutar tu aplicación dentro de un contexto más seguro usando una plantilla similar a la siguiente:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: security-context-demo
spec:
securityContext:
runAsUser: 1000
runAsGroup: 3000
fsGroup: 2000
volumes:
- name: sec-ctx-vol
emptyDir: {}
containers:
- name: sec-ctx-demo
image: busybox
command: [ "sh", "-c", "sleep 1h" ]
securityContext:
runAsNonRoot: true
volumeMounts:
- name: sec-ctx-vol
mountPath: /data/demo
securityContext:
allowPrivilegeEscalation: true
```
- [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
- [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)

### Endurecimiento general

Debe actualizar su entorno de Kubernetes con la frecuencia necesaria para tener:

- Dependencias actualizadas.
- Parches de errores y de seguridad.

[**Release cycles**](https://kubernetes.io/docs/setup/release/version-skew-policy/): Cada 3 meses hay una nueva versión menor -- 1.20.3 = 1(Major).20(Minor).3(patch)

**La mejor manera de actualizar un clúster de Kubernetes es (desde** [**here**](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/)**):**

- Actualice los componentes del Master Node siguiendo esta secuencia:
- etcd (todas las instancias).
- kube-apiserver (todos los hosts del control plane).
- kube-controller-manager.
- kube-scheduler.
- cloud controller manager, si usa uno.
- Actualice los componentes de los Worker Node como kube-proxy, kubelet.

## Monitoreo y seguridad de Kubernetes:

- Kyverno Policy Engine
- Cilium Tetragon - Observabilidad de seguridad basada en eBPF y aplicación en tiempo de ejecución
- Políticas de seguridad de red
- Falco - Monitoreo y detección de seguridad en tiempo de ejecución

{{#include ../../../banners/hacktricks-training.md}}
