# Kubernetes Durcissement

{{#include ../../../banners/hacktricks-training.md}}

## Outils pour analyser un cluster

### [Steampipe - Kubernetes Compliance](https://github.com/turbot/steampipe-mod-kubernetes-compliance)

Il effectuera **plusieurs contrôles de conformité sur le cluster Kubernetes**. Il inclut la prise en charge des recommandations CIS, du National Security Agency (NSA) et du Cybersecurity and Infrastructure Security Agency (CISA) — rapport technique sur la cybersécurité pour le durcissement de Kubernetes.
```bash
# Install Steampipe
brew install turbot/tap/powerpipe
brew install turbot/tap/steampipe
steampipe plugin install kubernetes

# Start the service
steampipe service start

# Install the module
mkdir dashboards
cd dashboards
powerpipe mod init
powerpipe mod install github.com/turbot/steampipe-mod-kubernetes-compliance

# Run the module
powerpipe server
```
### [**Kubescape**](https://github.com/armosec/kubescape)

[**Kubescape**](https://github.com/armosec/kubescape) est un outil open-source K8s offrant une vue centralisée multi-cloud pour K8s, incluant l'analyse des risques, la conformité de sécurité, un visualiseur RBAC et l'analyse des vulnérabilités d'images. Kubescape scanne les clusters K8s, les fichiers YAML et les HELM charts, détectant les mauvaises configurations selon plusieurs frameworks (tels que le [NSA-CISA](https://www.armosec.io/blog/kubernetes-hardening-guidance-summary-by-armo) , le [MITRE ATT\&CK®](https://www.microsoft.com/security/blog/2021/03/23/secure-containerized-environments-with-updated-threat-matrix-for-kubernetes/)), les vulnérabilités logicielles et les violations RBAC (role-based-access-control) dès les premières phases du pipeline CI/CD, calcule instantanément un score de risque et affiche les tendances de risque dans le temps.
```bash
curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
kubescape scan --verbose
```
### [**Popeye**](https://github.com/derailed/popeye)

[**Popeye**](https://github.com/derailed/popeye) est un utilitaire qui analyse un cluster Kubernetes en production et **signale les problèmes potentiels liés aux ressources déployées et aux configurations**. Il assainit votre cluster en se basant sur ce qui est déployé et non sur ce qui est présent sur le disque. En scannant votre cluster, il détecte les mauvaises configurations et vous aide à garantir que les bonnes pratiques sont en place, évitant ainsi des maux de tête ultérieurs. Il vise à réduire la charge cognitive \_over_load rencontrée lors de l'exploitation d'un cluster Kubernetes en environnement réel. De plus, si votre cluster utilise un metric-server, il signale les éventuelles sur/sous-allocations de ressources et tente de vous avertir si votre cluster manque de capacité.

### [**Kube-bench**](https://github.com/aquasecurity/kube-bench)

L'outil [**kube-bench**](https://github.com/aquasecurity/kube-bench) vérifie si Kubernetes est déployé de manière sécurisée en exécutant les contrôles documentés dans le [**CIS Kubernetes Benchmark**].\
Vous pouvez choisir de :

- exécuter kube-bench depuis l'intérieur d'un conteneur (en partageant le PID namespace avec l'hôte)
- exécuter un conteneur qui installe kube-bench sur l'hôte, puis lancer kube-bench directement sur l'hôte
- installer les derniers binaires depuis la [Releases page](https://github.com/aquasecurity/kube-bench/releases),
- le compiler depuis les sources.

### [**Kubeaudit**](https://github.com/Shopify/kubeaudit)

**[OBSOLÈTE]** L'outil [**kubeaudit**](https://github.com/Shopify/kubeaudit) est un outil en ligne de commande et un package Go pour **auditer des clusters Kubernetes** concernant diverses problématiques de sécurité.

Kubeaudit peut détecter s'il s'exécute à l'intérieur d'un conteneur dans un cluster. Dans ce cas, il tentera d'auditer toutes les ressources Kubernetes de ce cluster :
```
kubeaudit all
```
Cet outil possède également l'argument `autofix` pour **corriger automatiquement les problèmes détectés.**

### [**Kube-hunter**](https://github.com/aquasecurity/kube-hunter)

**[DÉPRÉCIÉ]** L'outil [**kube-hunter**](https://github.com/aquasecurity/kube-hunter) recherche des faiblesses de sécurité dans les clusters Kubernetes. L'outil a été développé pour accroître la sensibilisation et la visibilité des problèmes de sécurité dans les environnements Kubernetes.
```bash
kube-hunter --remote some.node.com
```
### [Trivy](https://github.com/aquasecurity/trivy)

[Trivy](https://github.com/aquasecurity/trivy) dispose de scanners qui recherchent des problèmes de sécurité, et des cibles où ils peuvent trouver ces problèmes :

- Image de conteneur
- Système de fichiers
- Dépôt Git (remote)
- Image de machine virtuelle
- Kubernetes


### [**Kubei**](https://github.com/Erezf-p/kubei)

**[Semble non maintenu]**

[**Kubei**](https://github.com/Erezf-p/kubei) est un outil de scan de vulnérabilités et de benchmark CIS Docker qui permet aux utilisateurs d'obtenir une évaluation précise et immédiate du risque de leurs clusters kubernetes. Kubei scanne toutes les images utilisées dans un cluster Kubernetes, y compris les images des pods d'application et des pods système.

### [**KubiScan**](https://github.com/cyberark/KubiScan)

[**KubiScan**](https://github.com/cyberark/KubiScan) est un outil pour scanner les clusters Kubernetes à la recherche de permissions risquées dans le modèle d'autorisation Role-based access control (RBAC) de Kubernetes.

### [Managed Kubernetes Auditing Toolkit](https://github.com/DataDog/managed-kubernetes-auditing-toolkit)

[**Mkat**](https://github.com/DataDog/managed-kubernetes-auditing-toolkit) est un outil conçu pour tester d'autres types de contrôles à haut risque comparé aux autres outils. Il possède principalement 3 modes différents :

- **`find-role-relationships`**: Qui trouvera quels rôles AWS s'exécutent dans quels pods
- **`find-secrets`**: Qui tente d'identifier des secrets dans les ressources K8s telles que Pods, ConfigMaps et Secrets.
- **`test-imds-access`**: Qui essaiera de lancer des pods et d'accéder aux metadata v1 et v2. ATTENTION : Cela exécutera un pod dans le cluster, soyez très prudent car peut-être vous ne voulez pas faire cela !

## **Auditer le code IaC**

### [**KICS**](https://github.com/Checkmarx/kics)

[**KICS**](https://github.com/Checkmarx/kics) trouve des vulnérabilités de sécurité, des problèmes de conformité et des mauvaises configurations d'infrastructure dans les solutions Infrastructure as Code suivantes : Terraform, Kubernetes, Docker, AWS CloudFormation, Ansible, Helm, Microsoft ARM, et les spécifications OpenAPI 3.0

### [**Checkov**](https://github.com/bridgecrewio/checkov)

[**Checkov**](https://github.com/bridgecrewio/checkov) est un outil d'analyse statique de code pour l'infrastructure-as-code.

Il scanne l'infrastructure cloud provisionnée en utilisant [Terraform](https://terraform.io), Terraform plan, [Cloudformation](https://aws.amazon.com/cloudformation/), [AWS SAM](https://aws.amazon.com/serverless/sam/), [Kubernetes](https://kubernetes.io), [Dockerfile](https://www.docker.com), [Serverless](https://www.serverless.com) ou [ARM Templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) et détecte les erreurs de configuration de sécurité et de conformité en utilisant une analyse basée sur un graphe.

### [**Kube-score**](https://github.com/zegl/kube-score)

[**kube-score**](https://github.com/zegl/kube-score) est un outil qui effectue une analyse statique des définitions d'objets Kubernetes.

Pour installer :

| Distribution                                        | Commande / Lien                                                                          |
| --------------------------------------------------- | --------------------------------------------------------------------------------------- |
| Binaries précompilés pour macOS, Linux, et Windows    | [GitHub releases](https://github.com/zegl/kube-score/releases)                          |
| Docker                                              | `docker pull zegl/kube-score` ([Docker Hub)](https://hub.docker.com/r/zegl/kube-score/) |
| Homebrew (macOS et Linux)                          | `brew install kube-score`                                                               |
| [Krew](https://krew.sigs.k8s.io/) (macOS et Linux) | `kubectl krew install score`                                                            |

## Outils pour analyser les fichiers YAML et les Helm Charts

### [**Kube-linter**](https://github.com/stackrox/kube-linter)
```bash
# Install Kube-linter
brew install kube-linter

# Run Kube-linter
## lint ./path/to/yaml/or/chart
```
### [Checkov](https://github.com/bridgecrewio/checkov)
```bash
# Install Checkov
pip install checkov

# Run Checkov
checkov -d ./path/to/yaml/or/chart
```
### [kube‑score](https://github.com/zegl/kube-score)
```bash
# Install kube-score
brew install kube-score

# Run kube-score
kube-score score ./path/to/yaml
# or
helm template chart /path/to/chart | kube-score score -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kube-score score -
```
### [Kubesec](https://github.com/controlplaneio/kubesec)
```bash
# Install Kubesec
## Download from https://github.com/controlplaneio/kubesec/releases

# Run Kubesec in a yaml
kubesec scan ./path/to/yaml
# or
helm template chart /path/to/chart | kubesec scan -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kubesec scan -
```
## Scan des problèmes de dépendances

### Scan des images
```bash
#!/bin/bash
export images=$(kubectl get pods --all-namespaces -o jsonpath="{range .items[]}{.spec.containers[].image}{'\n'}{end}" | sort | uniq)
echo "All images found: $images"
echo ""
echo ""
for image in $images; do
# Run trivy scan and save JSON output
trivy image --format json --output /tmp/result.json --severity HIGH,CRITICAL "$image" >/dev/null 2>&1
# Extract binary targets that have vulnerabilities
binaries=$(jq -r '.Results[] | select(.Vulnerabilities != null) | .Target' /tmp/result.json)
if [ -n "$binaries" ]; then
echo "- **Image:** $image"
while IFS= read -r binary; do
echo "  - **Binary:** $binary"
jq -r --arg target "$binary" '
.Results[] | select(.Target == $target) | .Vulnerabilities[] |
"    - **\(.Title)** (\(.Severity)): Affecting `\(.PkgName)` fixed in version `\(.FixedVersion)` (current version is `\(.InstalledVersion)`)."
' /tmp/result.json
done <<< "$binaries"
echo ""
echo ""
echo ""
fi
done
```
### Scan Helm charts
```bash
#!/bin/bash
# scan-helm-charts.sh
# This script lists all Helm releases, renders their manifests,
# and then scans each manifest with Trivy for configuration issues.

# Check that jq is installed
if ! command -v jq &>/dev/null; then
echo "jq is required but not installed. Please install jq and rerun."
exit 1
fi

# List all helm releases and extract namespace and release name
echo "Listing Helm releases..."
helm list --all-namespaces -o json | jq -r '.[] | "\(.namespace) \(.name)"' > helm_releases.txt

# Check if any releases were found
if [ ! -s helm_releases.txt ]; then
echo "No Helm releases found."
exit 0
fi

# Loop through each Helm release and scan its rendered manifest
while IFS=" " read -r namespace release; do
echo "---------------------------------------------"
echo "Scanning Helm release '$release' in namespace '$namespace'..."
# Render the Helm chart manifest
manifest_file="${release}-manifest.yaml"
helm get manifest "$release" -n "$namespace" > "$manifest_file"
if [ $? -ne 0 ]; then
echo "Failed to get manifest for $release in $namespace. Skipping."
continue
fi
# Scan the manifest with Trivy (configuration scan)
echo "Running Trivy config scan on $manifest_file..."
trivy config --severity MEDIUM,HIGH,CRITICAL "$manifest_file"
echo "Completed scan for $release."
done < helm_releases.txt

echo "---------------------------------------------"
echo "Helm chart scanning complete."
```
## Conseils

### Kubernetes PodSecurityContext and SecurityContext

Vous pouvez configurer le **contexte de sécurité des Pods** (avec _PodSecurityContext_) et des **containers** qui vont être exécutés (avec _SecurityContext_). Pour plus d'informations lisez :

{{#ref}}
kubernetes-securitycontext-s.md
{{#endref}}

### Renforcement de l'API Kubernetes

Il est très important de **protéger l'accès au Kubernetes Api Server** car un acteur malveillant disposant de privilèges suffisants pourrait l'abuser et endommager l'environnement de nombreuses façons.\
Il est important de sécuriser à la fois **l'accès** (**whitelist** des origines autorisées à accéder à l'API Server et refuser toute autre connexion) et la [**authentication**](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/) (en suivant le principe du **moindre** **privilège**). Et surtout **ne** **laissez** **jamais** **de** **requêtes** **anonymes**.

**Processus de requête courant :**\
Utilisateur ou K8s ServiceAccount –> Authentication –> Authorization –> Admission Control.

**Conseils** :

- Fermer les ports.
- Éviter l'accès anonyme.
- NodeRestriction ; pas d'accès depuis des nœuds spécifiques vers l'API.
- [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction)
- Empêche essentiellement les kubelets d'ajouter/supprimer/mettre à jour des labels avec un préfixe node-restriction.kubernetes.io/. Ce préfixe d'étiquette est réservé aux administrateurs pour étiqueter leurs Node objects à des fins d'isolation des workloads, et les kubelets ne seront pas autorisés à modifier les labels avec ce préfixe.
- Et aussi, permet aux kubelets d'ajouter/supprimer/mettre à jour ces labels et préfixes d'étiquettes.
- Assurer l'isolation sécurisée des workloads via les labels.
- Empêcher l'accès à l'API pour certains pods.
- Éviter l'exposition de l'ApiServer sur Internet.
- Éviter l'accès non autorisé via RBAC.
- Port de l'ApiServer protégé par firewall et IP whitelisting.

### Renforcement de SecurityContext

Par défaut, l'utilisateur root sera utilisé lorsqu'un Pod démarre si aucun autre utilisateur n'est spécifié. Vous pouvez exécuter votre application dans un contexte plus sécurisé en utilisant un template similaire au suivant :
```yaml
apiVersion: v1
kind: Pod
metadata:
name: security-context-demo
spec:
securityContext:
runAsUser: 1000
runAsGroup: 3000
fsGroup: 2000
volumes:
- name: sec-ctx-vol
emptyDir: {}
containers:
- name: sec-ctx-demo
image: busybox
command: [ "sh", "-c", "sleep 1h" ]
securityContext:
runAsNonRoot: true
volumeMounts:
- name: sec-ctx-vol
mountPath: /data/demo
securityContext:
allowPrivilegeEscalation: true
```
- [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
- [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)

### Durcissement général

Vous devriez mettre à jour votre environnement Kubernetes aussi fréquemment que nécessaire pour avoir :

- Dépendances à jour.
- Correctifs de bugs et de sécurité.

[**Release cycles**](https://kubernetes.io/docs/setup/release/version-skew-policy/): Tous les 3 mois il y a une nouvelle version mineure -- 1.20.3 = 1(Majeur).20(Mineur).3(correctif)

**La meilleure façon de mettre à jour un Cluster Kubernetes est (d'après** [**here**](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/)**):**

- Mettre à niveau les composants du Master Node dans l'ordre suivant :
- etcd (toutes les instances).
- kube-apiserver (tous les hôtes du control plane).
- kube-controller-manager.
- kube-scheduler.
- cloud controller manager, si vous en utilisez un.
- Mettre à niveau les composants des Worker Node tels que kube-proxy, kubelet.

## Kubernetes monitoring & security:

- Kyverno Policy Engine
- Cilium Tetragon - eBPF-based Security Observability and Runtime Enforcement
- Network Security Policies
- Falco - Runtime security monitoring & detection

{{#include ../../../banners/hacktricks-training.md}}
