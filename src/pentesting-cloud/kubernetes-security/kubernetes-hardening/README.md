# Kubernetes-Härtung

{{#include ../../../banners/hacktricks-training.md}}

## Tools zur Analyse eines Clusters

### [Steampipe - Kubernetes Compliance](https://github.com/turbot/steampipe-mod-kubernetes-compliance)

Es führt **mehrere Compliance-Checks für den Kubernetes-Cluster** durch. Es enthält Unterstützung für CIS sowie die Empfehlungen der National Security Agency (NSA) und den Cybersecurity Technical Report der Cybersecurity and Infrastructure Security Agency (CISA) zur Kubernetes-Härtung.
```bash
# Install Steampipe
brew install turbot/tap/powerpipe
brew install turbot/tap/steampipe
steampipe plugin install kubernetes

# Start the service
steampipe service start

# Install the module
mkdir dashboards
cd dashboards
powerpipe mod init
powerpipe mod install github.com/turbot/steampipe-mod-kubernetes-compliance

# Run the module
powerpipe server
```
### [**Kubescape**](https://github.com/armosec/kubescape)

[**Kubescape**](https://github.com/armosec/kubescape) ist ein K8s Open-Source-Tool, das ein einheitliches Multi-Cloud-Dashboard bereitstellt und Risikoanalyse, Sicherheits-Compliance, RBAC-Visualizer und Scans auf Image-Schwachstellen umfasst. Kubescape scannt K8s-Cluster, YAML-Dateien und HELM-Charts und erkennt Fehlkonfigurationen gemäß mehreren Frameworks (wie dem [NSA-CISA](https://www.armosec.io/blog/kubernetes-hardening-guidance-summary-by-armo) , [MITRE ATT&CK®](https://www.microsoft.com/security/blog/2021/03/23/secure-containerized-environments-with-updated-threat-matrix-for-kubernetes/)), Software-Schwachstellen und RBAC (role-based-access-control)-Verstöße in frühen Phasen der CI/CD-Pipeline, berechnet sofort einen Risikoscore und zeigt Risikotendenzen im Zeitverlauf.
```bash
curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
kubescape scan --verbose
```
### [**Popeye**](https://github.com/derailed/popeye)

[**Popeye**](https://github.com/derailed/popeye) ist ein Dienstprogramm, das laufende Kubernetes-Cluster scannt und **mögliche Probleme mit bereitgestellten Ressourcen und Konfigurationen meldet**. Es bereinigt Ihren Cluster basierend auf dem, was bereitgestellt ist, und nicht auf dem, was auf der Festplatte liegt. Durch das Scannen Ihres Clusters erkennt es Fehlkonfigurationen und hilft Ihnen sicherzustellen, dass Best Practices eingehalten werden, wodurch zukünftige Probleme vermieden werden. Es hat sich zum Ziel gesetzt, die kognitive \_Überlastung zu reduzieren, der man beim Betreiben eines Kubernetes-Clusters in freier Wildbahn ausgesetzt ist. Außerdem, falls Ihr Cluster einen metric-server verwendet, meldet es mögliche Über-/Unter-Allokationen von Ressourcen und versucht, Sie zu warnen, falls Ihrem Cluster die Kapazität ausgeht.

### [**Kube-bench**](https://github.com/aquasecurity/kube-bench)

Das Tool [**kube-bench**](https://github.com/aquasecurity/kube-bench) prüft, ob Kubernetes sicher bereitgestellt ist, indem es die in den [**CIS Kubernetes Benchmark**](https://www.cisecurity.org/benchmark/kubernetes/).\
dokumentierten Checks ausführt.  
Sie können wählen:

- kube-bench aus einem Container heraus ausführen (PID-Namespace mit dem Host teilen)
- einen Container ausführen, der kube-bench auf dem Host installiert, und dann kube-bench direkt auf dem Host ausführen
- die neuesten Binaries von der [Releases page](https://github.com/aquasecurity/kube-bench/releases) installieren,
- es aus dem Quellcode kompilieren.

### [**Kubeaudit**](https://github.com/Shopify/kubeaudit)

**[DEPRECATED]** Das Tool [**kubeaudit**](https://github.com/Shopify/kubeaudit) ist ein Kommandozeilen-Tool und ein Go-Paket, um **Kubernetes-Cluster zu auditieren** auf verschiedene Sicherheitsaspekte hin.

Kubeaudit kann erkennen, ob es innerhalb eines Containers in einem Cluster läuft. Falls ja, versucht es, alle Kubernetes-Ressourcen in diesem Cluster zu auditieren:
```
kubeaudit all
```
Dieses Tool hat außerdem das Argument `autofix`, um **erkannte Probleme automatisch zu beheben.**

### [**Kube-hunter**](https://github.com/aquasecurity/kube-hunter)

**[VERALTET]** Das Tool [**kube-hunter**](https://github.com/aquasecurity/kube-hunter) sucht nach Sicherheitslücken in Kubernetes-Clustern. Das Tool wurde entwickelt, um das Bewusstsein und die Sichtbarkeit für Sicherheitsprobleme in Kubernetes-Umgebungen zu erhöhen.
```bash
kube-hunter --remote some.node.com
```
### [Trivy](https://github.com/aquasecurity/trivy)

[Trivy](https://github.com/aquasecurity/trivy) hat Scanner, die nach Sicherheitsproblemen suchen, und Zielbereiche, in denen diese Probleme gefunden werden können:

- Container-Image
- Dateisystem
- Git-Repository (remote)
- Virtual Machine Image
- Kubernetes


### [**Kubei**](https://github.com/Erezf-p/kubei)

**[Scheint nicht gepflegt zu sein]**

[**Kubei**](https://github.com/Erezf-p/kubei) ist ein Tool zum Scannen nach Schwachstellen und für das CIS Docker Benchmark, das Benutzern eine genaue und sofortige Risikobewertung ihrer Kubernetes-Cluster ermöglicht. Kubei scannt alle Images, die in einem Kubernetes-Cluster verwendet werden, einschließlich Images von Application Pods und System Pods.

### [**KubiScan**](https://github.com/cyberark/KubiScan)

[**KubiScan**](https://github.com/cyberark/KubiScan) ist ein Tool zum Scannen von Kubernetes-Clustern nach riskanten Berechtigungen im Role-based access control (RBAC)-Autorisierungsmodell von Kubernetes.

### [Managed Kubernetes Auditing Toolkit](https://github.com/DataDog/managed-kubernetes-auditing-toolkit)

[**Mkat**](https://github.com/DataDog/managed-kubernetes-auditing-toolkit) ist ein Tool, das entwickelt wurde, um andere Arten von hochriskanten Prüfungen im Vergleich zu den anderen Tools zu testen. Es verfügt hauptsächlich über 3 verschiedene Modi:

- **`find-role-relationships`**: Findet, welche AWS-Rollen in welchen Pods laufen
- **`find-secrets`**: Versucht, Secrets in K8s-Ressourcen wie Pods, ConfigMaps und Secrets zu identifizieren.
- **`test-imds-access`**: Versucht, Pods zu starten und auf die Metadata v1 und v2 zuzugreifen. WARNUNG: Dies startet einen Pod im Cluster. Seien Sie sehr vorsichtig, da Sie dies möglicherweise nicht ausführen möchten!

## **IaC-Code auditieren**

### [**KICS**](https://github.com/Checkmarx/kics)

[**KICS**](https://github.com/Checkmarx/kics) findet Sicherheitslücken, Compliance-Probleme und Infrastrukturfehlkonfigurationen in den folgenden Infrastructure-as-Code-Lösungen: Terraform, Kubernetes, Docker, AWS CloudFormation, Ansible, Helm, Microsoft ARM und OpenAPI 3.0-Spezifikationen

### [**Checkov**](https://github.com/bridgecrewio/checkov)

[**Checkov**](https://github.com/bridgecrewio/checkov) ist ein statisches Code-Analyse-Tool für Infrastructure-as-Code.

Es scannt Cloud-Infrastruktur, die mit [Terraform](https://terraform.io), Terraform plan, [Cloudformation](https://aws.amazon.com/cloudformation/), [AWS SAM](https://aws.amazon.com/serverless/sam/), [Kubernetes](https://kubernetes.io), [Dockerfile](https://www.docker.com), [Serverless](https://www.serverless.com) oder [ARM Templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) bereitgestellt wurde, und erkennt Sicherheits- und Compliance-Fehlkonfigurationen mittels graphbasierter Scans.

### [**Kube-score**](https://github.com/zegl/kube-score)

[**kube-score**](https://github.com/zegl/kube-score) ist ein Tool, das eine statische Code-Analyse deiner Kubernetes-Objektdefinitionen durchführt.

To install:

| Distribution                                        | Command / Link                                                                          |
| --------------------------------------------------- | --------------------------------------------------------------------------------------- |
| Vorgefertigte Binärdateien für macOS, Linux und Windows    | [GitHub releases](https://github.com/zegl/kube-score/releases)                          |
| Docker                                              | `docker pull zegl/kube-score` ([Docker Hub)](https://hub.docker.com/r/zegl/kube-score/) |
| Homebrew (macOS und Linux)                          | `brew install kube-score`                                                               |
| [Krew](https://krew.sigs.k8s.io/) (macOS and Linux) | `kubectl krew install score`                                                            |

## Tools zur Analyse von YAML-Dateien & Helm Charts

### [**Kube-linter**](https://github.com/stackrox/kube-linter)
```bash
# Install Kube-linter
brew install kube-linter

# Run Kube-linter
## lint ./path/to/yaml/or/chart
```
### [Checkov](https://github.com/bridgecrewio/checkov)
```bash
# Install Checkov
pip install checkov

# Run Checkov
checkov -d ./path/to/yaml/or/chart
```
### [kube‑score](https://github.com/zegl/kube-score)
```bash
# Install kube-score
brew install kube-score

# Run kube-score
kube-score score ./path/to/yaml
# or
helm template chart /path/to/chart | kube-score score -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kube-score score -
```
### [Kubesec](https://github.com/controlplaneio/kubesec)
```bash
# Install Kubesec
## Download from https://github.com/controlplaneio/kubesec/releases

# Run Kubesec in a yaml
kubesec scan ./path/to/yaml
# or
helm template chart /path/to/chart | kubesec scan -
# or if the chart needs some values
helm template chart /path/to/chart \
--set 'config.urls[0]=https://dummy.backend.internal' \
| kubesec scan -
```
## Abhängigkeitsprobleme scannen

### Container-Images scannen
```bash
#!/bin/bash
export images=$(kubectl get pods --all-namespaces -o jsonpath="{range .items[]}{.spec.containers[].image}{'\n'}{end}" | sort | uniq)
echo "All images found: $images"
echo ""
echo ""
for image in $images; do
# Run trivy scan and save JSON output
trivy image --format json --output /tmp/result.json --severity HIGH,CRITICAL "$image" >/dev/null 2>&1
# Extract binary targets that have vulnerabilities
binaries=$(jq -r '.Results[] | select(.Vulnerabilities != null) | .Target' /tmp/result.json)
if [ -n "$binaries" ]; then
echo "- **Image:** $image"
while IFS= read -r binary; do
echo "  - **Binary:** $binary"
jq -r --arg target "$binary" '
.Results[] | select(.Target == $target) | .Vulnerabilities[] |
"    - **\(.Title)** (\(.Severity)): Affecting `\(.PkgName)` fixed in version `\(.FixedVersion)` (current version is `\(.InstalledVersion)`)."
' /tmp/result.json
done <<< "$binaries"
echo ""
echo ""
echo ""
fi
done
```
### Helm charts scannen
```bash
#!/bin/bash
# scan-helm-charts.sh
# This script lists all Helm releases, renders their manifests,
# and then scans each manifest with Trivy for configuration issues.

# Check that jq is installed
if ! command -v jq &>/dev/null; then
echo "jq is required but not installed. Please install jq and rerun."
exit 1
fi

# List all helm releases and extract namespace and release name
echo "Listing Helm releases..."
helm list --all-namespaces -o json | jq -r '.[] | "\(.namespace) \(.name)"' > helm_releases.txt

# Check if any releases were found
if [ ! -s helm_releases.txt ]; then
echo "No Helm releases found."
exit 0
fi

# Loop through each Helm release and scan its rendered manifest
while IFS=" " read -r namespace release; do
echo "---------------------------------------------"
echo "Scanning Helm release '$release' in namespace '$namespace'..."
# Render the Helm chart manifest
manifest_file="${release}-manifest.yaml"
helm get manifest "$release" -n "$namespace" > "$manifest_file"
if [ $? -ne 0 ]; then
echo "Failed to get manifest for $release in $namespace. Skipping."
continue
fi
# Scan the manifest with Trivy (configuration scan)
echo "Running Trivy config scan on $manifest_file..."
trivy config --severity MEDIUM,HIGH,CRITICAL "$manifest_file"
echo "Completed scan for $release."
done < helm_releases.txt

echo "---------------------------------------------"
echo "Helm chart scanning complete."
```
## Tipps

### Kubernetes PodSecurityContext und SecurityContext

Sie können den **security context der Pods** (mit _PodSecurityContext_) und der **Container**, die ausgeführt werden, (mit _SecurityContext_) konfigurieren. Für weitere Informationen lesen:

{{#ref}}
kubernetes-securitycontext-s.md
{{#endref}}

### Kubernetes API-Härtung

Es ist sehr wichtig, den Zugriff auf den Kubernetes Api Server zu schützen, da ein böswilliger Akteur mit ausreichenden Rechten diesen missbrauchen und die Umgebung auf viele Arten schädigen könnte.\
Wichtig ist, sowohl den **Zugriff** (**whitelist** Origins, die auf den API Server zugreifen dürfen, und alle anderen Verbindungen verweigern) als auch die [**authentication**](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/) (nach dem Prinzip der **least** **privilege**) abzusichern. Und auf keinen Fall **anonymous** **requests** zulassen.

**Common Request process:**\
User or K8s ServiceAccount –> Authentication –> Authorization –> Admission Control.

**Tipps**:

- Ports schließen.
- Anonymen Zugriff vermeiden.
- NodeRestriction; kein Zugriff von bestimmten Nodes auf die API.
- [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction)
- Verhindert im Wesentlichen, dass kubelets Labels mit dem Prefix node-restriction.kubernetes.io/ hinzufügen/entfernen/aktualisieren. Dieses Label-Prefix ist Administrators vorbehalten, um ihre Node objects zur Workload-Isolierung zu labeln, und kubelets dürfen Labels mit diesem Prefix nicht ändern.
- Und ermöglicht außerdem kubelets, diese Labels und Label-Prefixes hinzuzufügen/zu entfernen/zu aktualisieren.
- Sichere Workload-Isolierung mit Labels gewährleisten.
- Bestimmte Pods vom API-Zugriff ausschließen.
- ApiServer nicht dem Internet aussetzen.
- Unautorisierten Zugriff durch RBAC vermeiden.
- ApiServer-Port per Firewall und IP-Whitelisting absichern.

### SecurityContext-Härtung

Standardmäßig wird der root user verwendet, wenn ein Pod gestartet wird und kein anderer Benutzer angegeben ist. Du kannst deine Anwendung in einem sichereren Kontext ausführen, indem du eine Vorlage ähnlich der folgenden verwendest:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: security-context-demo
spec:
securityContext:
runAsUser: 1000
runAsGroup: 3000
fsGroup: 2000
volumes:
- name: sec-ctx-vol
emptyDir: {}
containers:
- name: sec-ctx-demo
image: busybox
command: [ "sh", "-c", "sleep 1h" ]
securityContext:
runAsNonRoot: true
volumeMounts:
- name: sec-ctx-vol
mountPath: /data/demo
securityContext:
allowPrivilegeEscalation: true
```
- [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
- [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)

### Allgemeine Härtung

Aktualisieren Sie Ihre Kubernetes-Umgebung so oft wie nötig, um Folgendes zu gewährleisten:

- Abhängigkeiten auf dem neuesten Stand.
- Fehler- und Sicherheitspatches.

[**Release cycles**](https://kubernetes.io/docs/setup/release/version-skew-policy/): Alle 3 Monate erscheint ein neues Minor-Release -- 1.20.3 = 1(Major).20(Minor).3(Patch)

**Der beste Weg, ein Kubernetes-Cluster zu aktualisieren, ist (von** [**here**](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/)**):**

- Aktualisieren Sie die Master-Node-Komponenten in folgender Reihenfolge:
- etcd (alle Instanzen).
- kube-apiserver (auf allen Control-Plane-Hosts).
- kube-controller-manager.
- kube-scheduler.
- cloud controller manager, falls Sie einen verwenden.
- Aktualisieren Sie die Worker-Node-Komponenten wie kube-proxy, kubelet.

## Kubernetes-Monitoring & Sicherheit:

- Kyverno Policy Engine
- Cilium Tetragon - eBPF-basierte Sicherheits-Observability und Laufzeitdurchsetzung
- Network-Sicherheitsrichtlinien
- Falco - Runtime-Sicherheitsüberwachung & Erkennung

{{#include ../../../banners/hacktricks-training.md}}
