# Az - Tokens & Public Applications

{{#include ../../../banners/hacktricks-training.md}}

## Información básica

Entra ID es la plataforma de identity and access management (IAM) basada en la nube de Microsoft, que sirve como el sistema fundamental de autenticación y autorización para servicios como Microsoft 365 y Azure Resource Manager. Azure AD implementa el framework de autorización OAuth 2.0 y el protocolo de autenticación OpenID Connect (OIDC) para gestionar el acceso a recursos.

### OAuth

**Participantes clave en OAuth 2.0:**

1. **Resource Server (RS):** Protege los recursos que pertenecen al resource owner.
2. **Resource Owner (RO):** Normalmente un usuario final que posee los recursos protegidos.
3. **Client Application (CA):** Una aplicación que busca acceder a recursos en nombre del resource owner.
4. **Authorization Server (AS):** Emite access tokens a las client applications tras autenticarlas y autorizarlas.

**Scopes y Consentimiento:**

- **Scopes:** Permisos granulares definidos en el resource server que especifican niveles de acceso.
- **Consent:** El proceso por el cual un resource owner otorga a una client application permiso para acceder a recursos con scopes específicos.

**Integración con Microsoft 365:**

- Microsoft 365 utiliza Azure AD para IAM y está compuesto por múltiples aplicaciones OAuth "first-party".
- Estas aplicaciones están profundamente integradas y a menudo tienen relaciones de servicio interdependientes.
- Para simplificar la experiencia del usuario y mantener la funcionalidad, Microsoft concede "implied consent" o "pre-consent" a estas aplicaciones first-party.
- **Implied Consent:** Ciertas aplicaciones están automáticamente **concedidas acceso a scopes específicos sin la aprobación explícita del usuario o del administrador**.
- Estos scopes pre-consentidos normalmente están ocultos tanto para usuarios como para administradores, lo que los hace menos visibles en las interfaces de gestión estándar.

**Tipos de Client Application:**

1. **Confidential Clients:**
- Poseen sus propias credenciales (p. ej., contraseñas o certificados).
- Pueden **autenticarse de forma segura** ante el authorization server.
2. **Public Clients:**
- No tienen credenciales únicas.
- No pueden autenticarse de forma segura ante el authorization server.
- **Implicación de seguridad:** Un atacante puede suplantar una public client application al solicitar tokens, ya que no existe un mecanismo para que el authorization server verifique la legitimidad de la aplicación.

## Authentication Tokens

Hay **tres tipos de tokens** usados en OIDC:

- [**Access Tokens**](https://learn.microsoft.com/en-us/azure/active-directory/develop/access-tokens)**:** El cliente presenta este token al resource server para **acceder a recursos**. Puede usarse solo para una combinación específica de usuario, client y resource y **no puede ser revocado** hasta su expiración — que por defecto es 1 hora.
- **ID Tokens**: El cliente recibe este **token desde el authorization server**. Contiene información básica sobre el usuario. Está **vinculado a una combinación específica de usuario y client**.
- **Refresh Tokens**: Proporcionados al cliente junto con el access token. Se usan para **obtener nuevos access e ID tokens**. Están vinculados a una combinación específica de usuario y client y pueden ser revocados. La expiración por defecto es **90 días** para refresh tokens inactivos y **sin expiración para tokens activos** (desde un refresh token es posible obtener nuevos refresh tokens).
- Un refresh token debería estar ligado a un **`aud`**, a algunos **scopes**, y a un **tenant** y sólo debería poder generar access tokens para ese aud, scopes (y no más) y tenant. Sin embargo, esto no ocurre con los tokens de aplicaciones **FOCI**.
- Un refresh token está encriptado y solo Microsoft puede desencriptarlo.
- Obtener un nuevo refresh token no revoca el refresh token anterior.

> [!WARNING]
> La información para **conditional access** está **almacenada** dentro del **JWT**. Por lo tanto, si solicitas el **token desde una IP permitida**, esa **IP** quedará **almacenada** en el token y luego puedes usar ese token desde una **IP no permitida para acceder a los recursos**.

### Access Tokens "aud"

El campo indicado en el campo "aud" es el **resource server** (la aplicación) que se utiliza para realizar el login.

El comando `az account get-access-token --resource-type [...]` soporta los siguientes tipos y cada uno de ellos añadirá un "aud" específico en el access token resultante:

> [!CAUTION]
> Ten en cuenta que los siguientes son solo las APIs soportadas por `az account get-access-token` pero existen más.

<details>

<summary>aud ejemplos</summary>

- **aad-graph (Azure Active Directory Graph API)**: Usado para acceder a la legacy Azure AD Graph API (deprecated), que permite a las aplicaciones leer y escribir datos del directorio en Azure Active Directory (Azure AD).
- `https://graph.windows.net/`

* **arm (Azure Resource Manager)**: Usado para gestionar recursos de Azure a través de la Azure Resource Manager API. Esto incluye operaciones como crear, actualizar y eliminar recursos como máquinas virtuales, cuentas de almacenamiento y más.
- `https://management.core.windows.net/ or https://management.azure.com/`

- **batch (Azure Batch Services)**: Usado para acceder a Azure Batch, un servicio que permite ejecutar aplicaciones de computación paralela y de alto rendimiento a gran escala en la nube.
- `https://batch.core.windows.net/`

* **data-lake (Azure Data Lake Storage)**: Usado para interactuar con Azure Data Lake Storage Gen1, que es un servicio escalable de almacenamiento y análisis de datos.
- `https://datalake.azure.net/`

- **media (Azure Media Services)**: Usado para acceder a Azure Media Services, que ofrecen procesamiento y entrega de medios en la nube para contenido de video y audio.
- `https://rest.media.azure.net`

* **ms-graph (Microsoft Graph API)**: Usado para acceder a Microsoft Graph API, el endpoint unificado para datos de Microsoft 365 services. Permite acceder a datos e insights de servicios como Azure AD, Office 365, Enterprise Mobility y Security services.
- `https://graph.microsoft.com`

- **oss-rdbms (Azure Open Source Relational Databases)**: Usado para acceder a los servicios de bases de datos de Azure para motores relacionales de código abierto como MySQL, PostgreSQL y MariaDB.
- `https://ossrdbms-aad.database.windows.net`

</details>

### Access Tokens Scopes "scp"

El scope de un access token se almacena dentro de la clave scp dentro del JWT del access token. Estos scopes definen a qué tiene acceso el access token.

Si un JWT está autorizado para contactar una API específica pero **no tiene el scope** para realizar la acción solicitada, **no podrá realizar la acción** con ese JWT.

### Get refresh & access token example
```python
# Code example from https://github.com/secureworks/family-of-client-ids-research
import msal
import requests
import jwt
from pprint import pprint
from typing import Any, Dict, List


# LOGIN VIA CODE FLOW AUTHENTICATION
azure_cli_client = msal.PublicClientApplication(
"00b41c95-dab0-4487-9791-b9d2c32c80f2" # ID for Office 365 Management
)
device_flow = azure_cli_client.initiate_device_flow(
scopes=["https://graph.microsoft.com/.default"]
)
print(device_flow["message"])

# Perform device code flow authentication

azure_cli_bearer_tokens_for_graph_api = azure_cli_client.acquire_token_by_device_flow(
device_flow
)
pprint(azure_cli_bearer_tokens_for_graph_api)


# DECODE JWT
def decode_jwt(base64_blob: str) -> Dict[str, Any]:
"""Decodes base64 encoded JWT blob"""
return jwt.decode(
base64_blob, options={"verify_signature": False, "verify_aud": False}
)
decoded_access_token = decode_jwt(
azure_cli_bearer_tokens_for_graph_api.get("access_token")
)
pprint(decoded_access_token)


# GET NEW ACCESS TOKEN AND REFRESH TOKEN
new_azure_cli_bearer_tokens_for_graph_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
azure_cli_bearer_tokens_for_graph_api.get("refresh_token"),
# Same scopes as original authorization
scopes=["https://graph.microsoft.com/.default"],
)
)
pprint(new_azure_cli_bearer_tokens_for_graph_api)
```
### Otros campos del access token

- **appid**: ID de la aplicación usada para generar el token
- **appidacr**: La Application Authentication Context Class Reference indica cómo se autenticó el cliente; para un cliente público el valor es 0, y si se usa un client secret el valor es 1
- **acr**: La claim Authentication Context Class Reference es "0" cuando la autenticación del usuario final no cumplió los requisitos de ISO/IEC 29115.
- **amr**: El Authentication method indica cómo se autenticó el token. Un valor "pwd" indica que se usó una contraseña.
- **groups**: Indica los grupos de los que el principal es miembro.
- **iss**: El iss identifica el security token service (STS) que generó el token. p. ej. https://sts.windows.net/fdd066e1-ee37-49bc-b08f-d0e152119b04/ (el uuid es el tenant ID)
- **oid**: El object ID del principal
- **tid**: Tenant ID
- **iat, nbf, exp**: Issued at (cuando fue emitido), Not before (no puede usarse antes de este momento, normalmente el mismo valor que iat), Expiration time (tiempo de expiración).


## Escalada de privilegios con FOCI Tokens

Anteriormente se mencionó que los refresh tokens deberían estar vinculados a los **scopes** con los que se generaron, a la **application** y al **tenant** a los que se generaron. Si cualquiera de estos límites se rompe, es posible escalar privilegios, ya que sería posible generar access tokens para otros recursos y tenants a los que el usuario tiene acceso y con más scopes de los originalmente previstos.

Además, esto es posible con todos los refresh tokens en la [Microsoft identity platform](https://learn.microsoft.com/en-us/entra/identity-platform/) (Microsoft Entra accounts, Microsoft personal accounts, and social accounts like Facebook and Google) porque, como mencionan los [**docs**](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens): "Refresh tokens are bound to a combination of user and client, but **aren't tied to a resource or tenant**. A client can use a refresh token to acquire access tokens **across any combination of resource and tenant** where it has permission to do so. Refresh tokens are encrypted and only the Microsoft identity platform can read them."

Además, ten en cuenta que las aplicaciones FOCI son aplicaciones públicas, por lo que **no se necesita secret** para autenticarse en el servidor.

Los clientes FOCI conocidos reportados en la [**original research**](https://github.com/secureworks/family-of-client-ids-research/tree/main) pueden ser [**found here**](https://github.com/secureworks/family-of-client-ids-research/blob/main/known-foci-clients.csv).

### Obtener un scope diferente

Siguiendo con el código de ejemplo anterior, en este código se solicita un nuevo token para un scope diferente:
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
azure_cli_bearer_tokens_for_outlook_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
new_azure_cli_bearer_tokens_for_graph_api.get(
"refresh_token"
),
# But different scopes than original authorization
scopes=[
"https://outlook.office.com/.default"
],
)
)
pprint(azure_cli_bearer_tokens_for_outlook_api)
```
### Obtener un cliente y scopes diferentes
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
microsoft_office_client = msal.PublicClientApplication("d3590ed6-52b3-4102-aeff-aad2292ab01c")
microsoft_office_bearer_tokens_for_graph_api = (
# This is a different client application than we used in the previous examples
microsoft_office_client.acquire_token_by_refresh_token(
# But we can use the refresh token issued to our original client application
azure_cli_bearer_tokens_for_outlook_api.get("refresh_token"),
# And request different scopes too
scopes=["https://graph.microsoft.com/.default"],
)
)
# How is this possible?
pprint(microsoft_office_bearer_tokens_for_graph_api)
```
## Dónde encontrar tokens

Desde la perspectiva de un atacante es muy interesante saber dónde es posible encontrar access and refresh tokens cuando, por ejemplo, el PC de una víctima está comprometido:

- Dentro de **`<HOME>/.Azure`**
- **`azureProfile.json`** contiene información sobre usuarios que iniciaron sesión en el pasado
- **`clouds.config contains`** contiene información sobre suscripciones
- **`service_principal_entries.json`** contiene credenciales de aplicaciones (tenant id, clients and secret). Solo en Linux & macOS
- **`msal_token_cache.json`** contiene access tokens y refresh tokens. Solo en Linux & macOS
- **`service_principal_entries.bin`** y msal_token_cache.bin se usan en Windows y están cifrados con DPAPI
- **`msal_http_cache.bin`** es una caché de peticiones HTTP
- Cárgalo: `with open("msal_http_cache.bin", 'rb') as f: pickle.load(f)`
- **`AzureRmContext.json`** contiene información sobre inicios de sesión anteriores usando Az PowerShell (pero sin credenciales)
- Dentro de **`C:\Users\<username>\AppData\Local\Microsoft\IdentityCache\*`** hay varios archivos `.bin` con **access tokens**, ID tokens e información de cuentas cifrada con el DPAPI del usuario.
- Es posible encontrar más **access tokens** en los archivos `.tbres` dentro de **`C:\Users\<username>\AppData\Local\Microsoft\TokenBroken\Cache\`**, los cuales contienen un base64 cifrado con DPAPI con access tokens.
- En Linux y macOS puedes obtener **access tokens, refresh tokens and id tokens** desde Az PowerShell (si se usa) ejecutando `pwsh -Command "Save-AzContext -Path /tmp/az-context.json"`
- En Windows esto solo genera id tokens.
- Es posible verificar si Az PowerShell se usó en Linux y macOS comprobando si existe `$HOME/.local/share/.IdentityService/` (aunque los archivos contenidos están vacíos e inútiles)
- Si el usuario está conectado a Azure con el navegador, según este [**post**](https://www.infosecnoodle.com/p/obtaining-microsoft-entra-refresh?r=357m16&utm_campaign=post&utm_medium=web) es posible iniciar el flujo de autenticación con una redirección a localhost, hacer que el navegador autorice automáticamente el inicio de sesión y recibir el refresh token. Ten en cuenta que solo hay unas pocas FOCI applications que permiten redirect to localhost (como az cli o el powershell module), por lo que estas aplicaciones deben estar permitidas.
- Otra opción explicada en el blog es usar la herramienta [**BOF-entra-authcode-flow**](https://github.com/sudonoodle/BOF-entra-authcode-flow) que puede usar cualquier aplicación porque obtendrá el OAuth code para luego obtener un refresh token desde el título de la página de autorización final usando el redirect URI `https://login.microsoftonline.com/common/oauth2/nativeclient`.

## Referencias

- [https://github.com/secureworks/family-of-client-ids-research](https://github.com/secureworks/family-of-client-ids-research)
- [https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md](https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md)

{{#include ../../../banners/hacktricks-training.md}}
