# Az - Tokens & Public Applications

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

Entra ID es la plataforma de gestión de identidad y acceso (IAM) basada en la nube de Microsoft, que sirve como el sistema fundamental de autenticación y autorización para servicios como Microsoft 365 y Azure Resource Manager. Azure AD implementa el marco de autorización OAuth 2.0 y el protocolo de autenticación OpenID Connect (OIDC) para gestionar el acceso a los recursos.

### OAuth

**Participantes Clave en OAuth 2.0:**

1. **Servidor de Recursos (RS):** Protege los recursos propiedad del propietario del recurso.
2. **Propietario del Recurso (RO):** Típicamente un usuario final que posee los recursos protegidos.
3. **Aplicación Cliente (CA):** Una aplicación que busca acceso a recursos en nombre del propietario del recurso.
4. **Servidor de Autorización (AS):** Emite tokens de acceso a las aplicaciones cliente después de autenticarlas y autorizarlas.

**Ámbitos y Consentimiento:**

- **Ámbitos:** Permisos granulares definidos en el servidor de recursos que especifican niveles de acceso.
- **Consentimiento:** El proceso mediante el cual un propietario de recurso otorga a una aplicación cliente permiso para acceder a recursos con ámbitos específicos.

**Integración con Microsoft 365:**

- Microsoft 365 utiliza Azure AD para IAM y está compuesto por múltiples aplicaciones OAuth de "primera parte".
- Estas aplicaciones están profundamente integradas y a menudo tienen relaciones de servicio interdependientes.
- Para simplificar la experiencia del usuario y mantener la funcionalidad, Microsoft otorga "consentimiento implícito" o "pre-consentimiento" a estas aplicaciones de primera parte.
- **Consentimiento Implícito:** Ciertas aplicaciones son automáticamente **otorgadas acceso a ámbitos específicos sin aprobación explícita del usuario o administrador**.
- Estos ámbitos pre-consentidos suelen estar ocultos tanto para los usuarios como para los administradores, haciéndolos menos visibles en las interfaces de gestión estándar.

**Tipos de Aplicaciones Cliente:**

1. **Clientes Confidenciales:**
- Poseen sus propias credenciales (por ejemplo, contraseñas o certificados).
- Pueden **autenticarse de forma segura** ante el servidor de autorización.
2. **Clientes Públicos:**
- No tienen credenciales únicas.
- No pueden autenticarse de forma segura ante el servidor de autorización.
- **Implicación de Seguridad:** Un atacante puede suplantar una aplicación cliente pública al solicitar tokens, ya que no hay un mecanismo para que el servidor de autorización verifique la legitimidad de la aplicación.

## Authentication Tokens

Hay **tres tipos de tokens** utilizados en OIDC:

- [**Access Tokens**](https://learn.microsoft.com/en-us/azure/active-directory/develop/access-tokens)**:** El cliente presenta este token al servidor de recursos para **acceder a recursos**. Solo se puede usar para una combinación específica de usuario, cliente y recurso y **no puede ser revocado** hasta su expiración, que es de 1 hora por defecto.
- **ID Tokens**: El cliente recibe este **token del servidor de autorización**. Contiene información básica sobre el usuario. Está **vinculado a una combinación específica de usuario y cliente**.
- **Refresh Tokens**: Proporcionados al cliente junto con el token de acceso. Se utilizan para **obtener nuevos tokens de acceso e ID**. Está vinculado a una combinación específica de usuario y cliente y puede ser revocado. La expiración por defecto es **90 días** para tokens de actualización inactivos y **sin expiración para tokens activos** (es posible obtener nuevos tokens de actualización a partir de un token de actualización).
- Un token de actualización debe estar vinculado a un **`aud`**, a algunos **ámbitos**, y a un **inquilino** y solo debería poder generar tokens de acceso para ese aud, ámbitos (y no más) e inquilino. Sin embargo, este no es el caso con los **tokens de aplicaciones FOCI**.
- Un token de actualización está cifrado y solo Microsoft puede descifrarlo.
- Obtener un nuevo token de actualización no revoca el token de actualización anterior.

> [!WARNING]
> La información para **acceso condicional** está **almacenada** dentro del **JWT**. Así que, si solicitas el **token desde una dirección IP permitida**, esa **IP** será **almacenada** en el token y luego puedes usar ese token desde una **IP no permitida para acceder a los recursos**.

### Access Tokens "aud"

El campo indicado en el campo "aud" es el **servidor de recursos** (la aplicación) utilizado para realizar el inicio de sesión.

El comando `az account get-access-token --resource-type [...]` admite los siguientes tipos y cada uno de ellos añadirá un "aud" específico en el token de acceso resultante:

> [!CAUTION]
> Ten en cuenta que los siguientes son solo las API admitidas por `az account get-access-token`, pero hay más.

<details>

<summary>ejemplos de aud</summary>

- **aad-graph (Azure Active Directory Graph API)**: Utilizado para acceder a la API de Azure AD Graph heredada (obsoleta), que permite a las aplicaciones leer y escribir datos de directorio en Azure Active Directory (Azure AD).
- `https://graph.windows.net/`

* **arm (Azure Resource Manager)**: Utilizado para gestionar recursos de Azure a través de la API de Azure Resource Manager. Esto incluye operaciones como crear, actualizar y eliminar recursos como máquinas virtuales, cuentas de almacenamiento, y más.
- `https://management.core.windows.net/ or https://management.azure.com/`

- **batch (Azure Batch Services)**: Utilizado para acceder a Azure Batch, un servicio que permite aplicaciones de computación paralela y de alto rendimiento a gran escala de manera eficiente en la nube.
- `https://batch.core.windows.net/`

* **data-lake (Azure Data Lake Storage)**: Utilizado para interactuar con Azure Data Lake Storage Gen1, que es un servicio de almacenamiento y análisis de datos escalable.
- `https://datalake.azure.net/`

- **media (Azure Media Services)**: Utilizado para acceder a Azure Media Services, que proporciona servicios de procesamiento y entrega de medios basados en la nube para contenido de video y audio.
- `https://rest.media.azure.net`

* **ms-graph (Microsoft Graph API)**: Utilizado para acceder a la API de Microsoft Graph, el punto de acceso unificado para los datos de servicios de Microsoft 365. Permite acceder a datos e información de servicios como Azure AD, Office 365, Enterprise Mobility y servicios de Seguridad.
- `https://graph.microsoft.com`

- **oss-rdbms (Azure Open Source Relational Databases)**: Utilizado para acceder a los servicios de base de datos de Azure para motores de bases de datos relacionales de código abierto como MySQL, PostgreSQL y MariaDB.
- `https://ossrdbms-aad.database.windows.net`

</details>

### Access Tokens Scopes "scp"

El ámbito de un token de acceso se almacena dentro de la clave scp dentro del JWT del token de acceso. Estos ámbitos definen a qué tiene acceso el token de acceso.

Si un JWT tiene permitido contactar una API específica pero **no tiene el ámbito** para realizar la acción solicitada, **no podrá realizar la acción** con ese JWT.

### Get refresh & access token example
```python
# Code example from https://github.com/secureworks/family-of-client-ids-research
import msal
import requests
import jwt
from pprint import pprint
from typing import Any, Dict, List


# LOGIN VIA CODE FLOW AUTHENTICATION
azure_cli_client = msal.PublicClientApplication(
"04b07795-8ddb-461a-bbee-02f9e1bf7b46" # ID for Azure CLI client
)
device_flow = azure_cli_client.initiate_device_flow(
scopes=["https://graph.microsoft.com/.default"]
)
print(device_flow["message"])

# Perform device code flow authentication

azure_cli_bearer_tokens_for_graph_api = azure_cli_client.acquire_token_by_device_flow(
device_flow
)
pprint(azure_cli_bearer_tokens_for_graph_api)


# DECODE JWT
def decode_jwt(base64_blob: str) -> Dict[str, Any]:
"""Decodes base64 encoded JWT blob"""
return jwt.decode(
base64_blob, options={"verify_signature": False, "verify_aud": False}
)
decoded_access_token = decode_jwt(
azure_cli_bearer_tokens_for_graph_api.get("access_token")
)
pprint(decoded_access_token)


# GET NEW ACCESS TOKEN AND REFRESH TOKEN
new_azure_cli_bearer_tokens_for_graph_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
azure_cli_bearer_tokens_for_graph_api.get("refresh_token"),
# Same scopes as original authorization
scopes=["https://graph.microsoft.com/.default"],
)
)
pprint(new_azure_cli_bearer_tokens_for_graph_api)
```
### Otros campos del token de acceso

- **appid**: ID de la aplicación utilizada para generar el token
- **appidacr**: La Referencia de Clase de Contexto de Autenticación de la Aplicación indica cómo se autenticó el cliente, para un cliente público el valor es 0, y si se utiliza un secreto de cliente el valor es 1
- **acr**: La reclamación de la Referencia de Clase de Contexto de Autenticación es "0" cuando la autenticación del usuario final no cumplió con los requisitos de ISO/IEC 29115.
- **amr**: El método de autenticación indica cómo se autenticó el token. Un valor de “pwd” indica que se utilizó una contraseña.
- **groups**: Indica los grupos a los que el principal pertenece.
- **iss**: El emisor identifica el servicio de token de seguridad (STS) que generó el token. e.g. https://sts.windows.net/fdd066e1-ee37-49bc-b08f-d0e152119b04/ (el uuid es el ID del inquilino)
- **oid**: El ID del objeto del principal
- **tid**: ID del inquilino
- **iat, nbf, exp**: Emitido en (cuándo fue emitido), No antes (no se puede usar antes de este tiempo, generalmente el mismo valor que iat), Tiempo de expiración.

## Escalación de privilegios de tokens FOCI

Anteriormente se mencionó que los tokens de actualización deben estar vinculados a los **alcances** con los que se generó, a la **aplicación** y al **inquilino** para el que se generó. Si se rompe alguno de estos límites, es posible escalar privilegios ya que será posible generar tokens de acceso a otros recursos e inquilinos a los que el usuario tiene acceso y con más alcances de los que se pretendía originalmente.

Además, **esto es posible con todos los tokens de actualización** en la [plataforma de identidad de Microsoft](https://learn.microsoft.com/en-us/entra/identity-platform/) (cuentas de Microsoft Entra, cuentas personales de Microsoft y cuentas sociales como Facebook y Google) porque como mencionan los [**docs**](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens): "Los tokens de actualización están vinculados a una combinación de usuario y cliente, pero **no están atados a un recurso o inquilino**. Un cliente puede usar un token de actualización para adquirir tokens de acceso **a través de cualquier combinación de recurso e inquilino** donde tenga permiso para hacerlo. Los tokens de actualización están encriptados y solo la plataforma de identidad de Microsoft puede leerlos."

Además, tenga en cuenta que las aplicaciones FOCI son aplicaciones públicas, por lo que **no se necesita secreto** para autenticarse en el servidor.

Luego, los clientes FOCI conocidos reportados en la [**investigación original**](https://github.com/secureworks/family-of-client-ids-research/tree/main) pueden ser [**encontrados aquí**](https://github.com/secureworks/family-of-client-ids-research/blob/main/known-foci-clients.csv).

### Obtener un alcance diferente

Siguiendo con el código de ejemplo anterior, en este código se solicita un nuevo token para un alcance diferente:
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
azure_cli_bearer_tokens_for_outlook_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
new_azure_cli_bearer_tokens_for_graph_api.get(
"refresh_token"
),
# But different scopes than original authorization
scopes=[
"https://outlook.office.com/.default"
],
)
)
pprint(azure_cli_bearer_tokens_for_outlook_api)
```
### Obtener diferentes clientes y ámbitos
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
microsoft_office_client = msal.PublicClientApplication("d3590ed6-52b3-4102-aeff-aad2292ab01c")
microsoft_office_bearer_tokens_for_graph_api = (
# This is a different client application than we used in the previous examples
microsoft_office_client.acquire_token_by_refresh_token(
# But we can use the refresh token issued to our original client application
azure_cli_bearer_tokens_for_outlook_api.get("refresh_token"),
# And request different scopes too
scopes=["https://graph.microsoft.com/.default"],
)
)
# How is this possible?
pprint(microsoft_office_bearer_tokens_for_graph_api)
```
## Dónde encontrar tokens

Desde la perspectiva de un atacante, es muy interesante saber dónde es posible encontrar tokens de acceso y de actualización cuando, por ejemplo, la PC de una víctima está comprometida:

- Dentro de **`<HOME>/.Azure`**
- **`azureProfile.json`** contiene información sobre usuarios conectados en el pasado
- **`clouds.config contiene`** información sobre suscripciones
- **`service_principal_entries.json`** contiene credenciales de aplicaciones (id de inquilino, clientes y secreto). Solo en Linux y macOS
- **`msal_token_cache.json`** contiene tokens de acceso y tokens de actualización. Solo en Linux y macOS
- **`service_principal_entries.bin`** y **`msal_token_cache.bin`** se utilizan en Windows y están encriptados con DPAPI
- **`msal_http_cache.bin`** es un caché de solicitudes HTTP
- Cárgalo: `with open("msal_http_cache.bin", 'rb') as f: pickle.load(f)`
- **`AzureRmContext.json`** contiene información sobre inicios de sesión anteriores usando Az PowerShell (pero sin credenciales)
- Dentro de **`C:\Users\<username>\AppData\Local\Microsoft\IdentityCache\*`** hay varios archivos `.bin` con **tokens de acceso**, tokens de ID e información de cuentas encriptada con el DPAPI de los usuarios.
- Es posible encontrar más **tokens de acceso** en los archivos `.tbres` dentro de **`C:\Users\<username>\AppData\Local\Microsoft\TokenBroken\Cache\`** que contienen un base64 encriptado con DPAPI con tokens de acceso.
- En Linux y macOS puedes obtener **tokens de acceso, tokens de actualización y tokens de ID** desde Az PowerShell (si se usó) ejecutando `pwsh -Command "Save-AzContext -Path /tmp/az-context.json"`
- En Windows, esto solo genera tokens de ID.
- Es posible ver si se utilizó Az PowerShell en Linux y macOS verificando si existe `$HOME/.local/share/.IdentityService/` (aunque los archivos contenidos están vacíos y son inútiles)
- Si el usuario está **conectado a Azure con el navegador**, según este [**post**](https://www.infosecnoodle.com/p/obtaining-microsoft-entra-refresh?r=357m16&utm_campaign=post&utm_medium=web), es posible iniciar el flujo de autenticación con un **redireccionamiento a localhost**, hacer que el navegador autorice automáticamente el inicio de sesión y recibir el token de actualización. Ten en cuenta que solo hay algunas aplicaciones FOCI que permiten redireccionar a localhost (como az cli o el módulo de PowerShell), por lo que estas aplicaciones deben estar permitidas.

## Referencias

- [https://github.com/secureworks/family-of-client-ids-research](https://github.com/secureworks/family-of-client-ids-research)
- [https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md](https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md)

{{#include ../../../banners/hacktricks-training.md}}
