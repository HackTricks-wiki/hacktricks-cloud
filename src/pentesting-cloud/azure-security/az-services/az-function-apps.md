# Az - Function Apps

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Azure Function Apps** ni **huduma ya kompyuta isiyo na seva** inayokuruhusu kuendesha vipande vidogo vya msimbo, vinavyojulikana kama **functions**, bila kusimamia miundombinu ya chini. Zimeundwa kutekeleza msimbo kama jibu kwa vichocheo mbalimbali, kama vile **maombi ya HTTP, timer, au matukio kutoka kwa huduma nyingine za Azure** kama Blob Storage au Event Hubs. Function Apps zinasaidia lugha nyingi za programu, ikiwa ni pamoja na C#, Python, JavaScript, na Java, na kuifanya kuwa rahisi kwa kujenga **maombi yanayoendeshwa na matukio**, kuendesha michakato, au kuunganisha huduma. Ni za gharama nafuu, kwani kwa kawaida unalipa tu kwa muda wa kompyuta ulitumika wakati msimbo wako unakimbia.

> [!NOTE]
> Kumbuka kwamba **Functions ni sehemu ya App Services**, kwa hivyo, nyingi ya vipengele vilivyojadiliwa hapa vitatumika pia na maombi yaliyoundwa kama Azure Apps (`webapp` katika cli).

### Different Plans

- **Flex Consumption Plan**: Inatoa **kupanua kwa njia ya matukio, inayotegemea mahitaji** na bei ya kulipa kadri unavyotumia, ikiongeza au kuondoa mifano ya kazi kulingana na mahitaji. Inasaidia **mtandao wa virtual** na **mifano iliyotayarishwa awali** ili kupunguza kuanza baridi, na kuifanya kuwa bora kwa **mizigo inayobadilika** ambayo haitahitaji msaada wa kontena.
- **Traditional Consumption Plan**: Chaguo la seva isiyo na msingi, ambapo unalipa tu kwa rasilimali za kompyuta wakati kazi zinakimbia. Inapanuka kiotomatiki kulingana na matukio yanayoingia na inajumuisha **mipango ya kuanza baridi**, lakini haisaidii kutekeleza kontena. Inafaa kwa **mizigo ya muda mfupi** inayohitaji kupanuka kiotomatiki.
- **Premium Plan**: Imeundwa kwa ajili ya **utendaji thabiti**, ikiwa na **wafanyakazi waliotayarishwa awali** ili kuondoa kuanza baridi. Inatoa **nyakati za utekelezaji zilizopanuliwa, mtandao wa virtual**, na inasaidia **picha za Linux za kawaida**, na kuifanya kuwa bora kwa **maombi muhimu** yanayohitaji utendaji wa juu na vipengele vya juu.
- **Dedicated Plan**: Inakimbia kwenye mashine halisi zilizo na **malipo yanayoweza kutabiriwa** na inasaidia kupanuka kwa mikono au kiotomatiki. Inaruhusu kuendesha maombi mengi kwenye mpango mmoja, inatoa **kujitegemea kwa kompyuta**, na inahakikisha **ufikiaji salama wa mtandao** kupitia Mazingira ya Huduma ya Programu, na kuifanya kuwa bora kwa **maombi yanayoendelea kwa muda mrefu** yanayohitaji ugawaji wa rasilimali thabiti.
- **Container Apps**: Inaruhusu kutekeleza **maombi ya kazi yaliyowekwa kwenye kontena** katika mazingira yanayosimamiwa, pamoja na huduma ndogo na APIs. Inasaidia maktaba za kawaida, uhamishaji wa maombi ya zamani, na **usindikaji wa GPU**, ikiondoa usimamizi wa klasta za Kubernetes. Inafaa kwa **maombi yanayoendeshwa na matukio, yanayoweza kupanuka yaliyowekwa kwenye kontena**.

### **Storage Buckets**

Unapounda Function App mpya isiyo na kontena (lakini ukitoa msimbo wa kuendesha), **msimbo na data nyingine zinazohusiana na Function zitahifadhiwa kwenye akaunti ya Hifadhi**. Kwa kawaida, console ya wavuti itaunda mpya kwa kila kazi kuhifadhi msimbo.

Zaidi ya hayo, kubadilisha msimbo ndani ya ndoo (katika mifumo tofauti ambayo inaweza kuhifadhiwa), **msimbo wa programu utabadilishwa kuwa mpya na kutekelezwa** wakati kazi inaitwa tena.

> [!CAUTION]
> Hii ni ya kuvutia sana kutoka kwa mtazamo wa washambuliaji kwani **ufikiaji wa kuandika juu ya ndoo hii** utamruhusu mshambuliaji **kudhoofisha msimbo na kupandisha mamlaka** kwa vitambulisho vilivyo ndani ya Function App.
>
> Zaidi kuhusu hili katika **sehemu ya kupandisha mamlaka**.

Pia inawezekana kupata **funguo za master na functions** zilizohifadhiwa katika akaunti ya hifadhi katika kontena **`azure-webjobs-secrets`** ndani ya folda **`<app-name>`** katika faili za JSON ambazo unaweza kupata ndani.

Kumbuka kwamba Functions pia zinaruhusu kuhifadhi msimbo katika eneo la mbali kwa kuashiria tu URL yake.

### Networking

Kwa kutumia kichocheo cha HTTP:

- Inawezekana kutoa **ufikiaji kwa kazi kutoka kwa Intaneti yote** bila kuhitaji uthibitisho wowote au kutoa ufikiaji kulingana na IAM. Ingawa pia inawezekana kuzuia ufikiaji huu.
- Inawezekana pia **kutoa au kuzuia ufikiaji** kwa Function App kutoka **mtandao wa ndani (VPC)**.

> [!CAUTION]
> Hii ni ya kuvutia sana kutoka kwa mtazamo wa washambuliaji kwani inaweza kuwa inawezekana **kuhamasisha kwenye mitandao ya ndani** kutoka kwa Function iliyo hatarini iliyofichuliwa kwa Intaneti.

### **Function App Settings & Environment Variables**

Inawezekana kuunda mazingira ya mabadiliko ndani ya programu, ambayo yanaweza kuwa na taarifa nyeti. Zaidi ya hayo, kwa kawaida mabadiliko ya mazingira **`AzureWebJobsStorage`** na **`WEBSITE_CONTENTAZUREFILECONNECTIONSTRING`** (miongoni mwa mengine) yanaundwa. Haya ni ya kuvutia sana kwa sababu yana **funguo za akaunti kudhibiti kwa ruhusa KAMILI akaunti ya hifadhi inayohifadhi data ya programu**. Mipangilio hii pia inahitajika kutekeleza msimbo kutoka kwa Akaunti ya Hifadhi.

Mabadiliko haya ya mazingira au vigezo vya usanidi pia vinadhibiti jinsi Function inavyotekeleza msimbo, kwa mfano ikiwa **`WEBSITE_RUN_FROM_PACKAGE`** ipo, itadhihirisha URL ambapo msimbo wa programu unapatikana.

### **Function Sandbox**

Ndani ya sandbox ya linux, msimbo wa chanzo unapatikana katika **`/home/site/wwwroot`** katika faili **`function_app.py`** (ikiwa python inatumika) mtumiaji anayekimbia msimbo ni **`app`** (bila ruhusa za sudo).

Katika **Windows** function inayotumia NodeJS msimbo ulikuwa unapatikana katika **`C:\home\site\wwwroot\HttpTrigger1\index.js`**, jina la mtumiaji lilikuwa **`mawsFnPlaceholder8_f_v4_node_20_x86`** na ilikuwa sehemu ya **makundi**: `Mandatory Label\High Mandatory Level Label`, `Everyone`, `BUILTIN\Users`, `NT AUTHORITY\INTERACTIVE`, `CONSOLE LOGON`, `NT AUTHORITY\Authenticated Users`, `NT AUTHORITY\This Organization`, `BUILTIN\IIS_IUSRS`, `LOCAL`, `10-30-4-99\Dwas Site Users`.

### **Managed Identities & Metadata**

Kama [**VMs**](vms/index.html), Functions zinaweza kuwa na **Managed Identities** za aina 2: Iliyotolewa na Mfumo na Iliyotolewa na Mtumiaji.

**iliyotolewa na mfumo** itakuwa ni kitambulisho kinachodhibitiwa ambacho **ni kazi pekee** ambayo ina idhini hiyo itakuwa na uwezo wa kutumia, wakati **iliyotolewa na mtumiaji** ni vitambulisho vinavyodhibitiwa ambavyo **huduma nyingine yoyote ya Azure itakuwa na uwezo wa kutumia**.

> [!NOTE]
> Kama ilivyo katika [**VMs**](vms/index.html), Functions zinaweza kuwa na **1 kitambulisho kilichotolewa na mfumo** na **vitambulisho vingi vilivyotolewa na mtumiaji**, kwa hivyo ni muhimu kila wakati kujaribu kupata vyote ikiwa unadhoofisha kazi kwa sababu unaweza kuwa na uwezo wa kupandisha mamlaka kwa vitambulisho vingi vilivyo na Function moja tu.
>
> Ikiwa kitambulisho kisichotolewa na mfumo hakitumiki lakini kitambulisho kimoja au zaidi kilichotolewa na mtumiaji kimeunganishwa na kazi, kwa kawaida huwezi kupata token yoyote.

Inawezekana kutumia [**PEASS scripts**](https://github.com/peass-ng/PEASS-ng) kupata token kutoka kwa kitambulisho kilichotolewa na mfumo kutoka kwa kiunganishi cha metadata. Au unaweza kuzipata **kwa mikono** kama ilivyoelezwa katika:

{% embed url="https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#azure-vm" %}

Kumbuka unahitaji kupata njia ya **kuangalia vitambulisho vyote vilivyotolewa na kazi** kwani ikiwa hujaashiria, kiunganishi cha metadata kitatumia **tu kimoja cha kawaida** (angalia kiungo kilichopita kwa maelezo zaidi).

## Access Keys

> [!NOTE]
> Kumbuka kwamba hakuna ruhusa za RBAC za kutoa ufikiaji kwa watumiaji kuanzisha kazi. **kuanzisha kazi kunategemea kichocheo** kilichochaguliwa wakati ilipoundwa na ikiwa kichocheo cha HTTP kilichaguliwa, inaweza kuhitajika kutumia **funguo za ufikiaji**.

Unapounda kiunganishi ndani ya kazi kwa kutumia **kichocheo cha HTTP** inawezekana kuashiria **ngazi ya idhini ya funguo za ufikiaji** inayohitajika kuanzisha kazi. Chaguzi tatu zinapatikana:

- **ANONYMOUS**: **Kila mtu** anaweza kufikia kazi kupitia URL.
- **FUNCTION**: Kiunganishi kinapatikana tu kwa watumiaji wanaotumia **funguo, mwenyeji au funguo za master**.
- **ADMIN**: Kiunganishi kinapatikana tu kwa watumiaji wanaotumia **funguo za master**.

**Aina za funguo:**

- **Funguo za Kazi:** Funguo za kazi zinaweza kuwa za kawaida au zilizofanywa na mtumiaji na zimeundwa kutoa ufikiaji pekee kwa **kiunganishi maalum cha kazi** ndani ya Function App ikiruhusu ufikiaji wa kina zaidi juu ya viunganishi.
- **Funguo za Mwenyeji:** Funguo za mwenyeji, ambazo pia zinaweza kuwa za kawaida au zilizofanywa na mtumiaji, zinatoa ufikiaji kwa **viunganishi vyote vya kazi ndani ya Function App kwa ngazi ya ufikiaji wa FUNCTION**.
- **Funguo za Master:** Funguo za master (`_master`) hutumikia kama funguo za usimamizi zinazotoa ruhusa za juu, ikiwa ni pamoja na ufikiaji kwa viunganishi vyote vya kazi (ngazi ya ufikiaji wa ADMIN inajumuishwa). **funguo hii haiwezi kufutwa.**
- **Funguo za Mfumo:** Funguo za mfumo zinadhibitiwa na **nyongeza maalum** na zinahitajika kwa ufikiaji wa viunganishi vya webhook vinavyotumiwa na vipengele vya ndani. Mifano ni pamoja na kichocheo cha Event Grid na Functions za Kudumu, ambazo hutumia funguo za mfumo kuingiliana kwa usalama na APIs zao.

> [!TIP]
> Mfano wa kufikia kiunganishi cha API ya kazi kwa kutumia funguo:
>
> `https://<function_uniq_name>.azurewebsites.net/api/<endpoint_name>?code=<access_key>`

### Basic Authentication

Kama ilivyo katika App Services, Functions pia zinasaidia uthibitishaji wa msingi kuungana na **SCM** na **FTP** ili kutekeleza msimbo kwa kutumia **jina la mtumiaji na nenosiri katika URL** inayotolewa na Azure. Maelezo zaidi kuhusu hili katika:

{{#ref}}
az-app-services.md
{{#endref}}

### Github Based Deployments

Unapounda kazi kutoka kwa repo ya Github, console ya wavuti ya Azure inaruhusu **kuunda kiotomatiki Github Workflow katika hifadhi maalum** ili kila wakati hifadhi hii ikisasishwa, msimbo wa kazi unasasishwa. Kwa kweli, Github Action yaml kwa kazi ya python inaonekana kama ifuatavyo:

<details>

<summary>Github Action Yaml</summary>
```yaml
# Docs for the Azure Web Apps Deploy action: https://github.com/azure/functions-action
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Python, GitHub Actions, and Azure Functions: https://aka.ms/python-webapps-actions

name: Build and deploy Python project to Azure Function App - funcGithub

on:
push:
branches:
- main
workflow_dispatch:

env:
AZURE_FUNCTIONAPP_PACKAGE_PATH: "." # set this to the path to your web app project, defaults to the repository root
PYTHON_VERSION: "3.11" # set this to the python version to use (supports 3.6, 3.7, 3.8)

jobs:
build:
runs-on: ubuntu-latest
steps:
- name: Checkout repository
uses: actions/checkout@v4

- name: Setup Python version
uses: actions/setup-python@v5
with:
python-version: ${{ env.PYTHON_VERSION }}

- name: Create and start virtual environment
run: |
python -m venv venv
source venv/bin/activate

- name: Install dependencies
run: pip install -r requirements.txt

# Optional: Add step to run tests here

- name: Zip artifact for deployment
run: zip release.zip ./* -r

- name: Upload artifact for deployment job
uses: actions/upload-artifact@v4
with:
name: python-app
path: |
release.zip
!venv/

deploy:
runs-on: ubuntu-latest
needs: build

permissions:
id-token: write #This is required for requesting the JWT

steps:
- name: Download artifact from build job
uses: actions/download-artifact@v4
with:
name: python-app

- name: Unzip artifact for deployment
run: unzip release.zip

- name: Login to Azure
uses: azure/login@v2
with:
client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_6C3396368D954957BC58E4C788D37FD1 }}
tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_7E50AEF6222E4C3DA9272D27FB169CCD }}
subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_905358F484A74277BDC20978459F26F4 }}

- name: "Deploy to Azure Functions"
uses: Azure/functions-action@v1
id: deploy-to-function
with:
app-name: "funcGithub"
slot-name: "Production"
package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
```
</details>

Zaidi ya hayo, **Managed Identity** pia inaundwa ili Github Action kutoka kwenye hazina iweze kuingia kwenye Azure kwa kutumia hiyo. Hii inafanywa kwa kuzalisha akiba ya Shirikisho juu ya **Managed Identity** ikiruhusu **Issuer** `https://token.actions.githubusercontent.com` na **Subject Identifier** `repo:<org-name>/<repo-name>:ref:refs/heads/<branch-name>`.

> [!CAUTION]
> Hivyo, mtu yeyote anayekabili hazina hiyo ataweza kukabili kazi na Identiti za Usimamizi zilizounganishwa nayo.

### Mifumo ya Kuweka Mifuko

Sio mipango yote inaruhusu kuweka mifuko, lakini kwa zile zinazoruhusu, usanidi utaonyesha URL ya mfuko. Katika API, mipangilio ya **`linuxFxVersion`** itakuwa na kitu kama: `DOCKER|mcr.microsoft.com/...`, wakati katika console ya wavuti, usanidi utaonyesha **mipangilio ya picha**.

Zaidi ya hayo, **hakuna msimbo wa chanzo utakaohifadhiwa katika akaunti ya hifadhi** inayohusiana na kazi kwani haitahitajika.

## Enumeration
```bash
# List all the functions
az functionapp list

# Get info of 1 funciton (although in the list you already get this info)
az functionapp show --name <app-name> --resource-group <res-group>
## If "linuxFxVersion" has something like: "DOCKER|mcr.microsoft.com/..."
## This is using a container

# Get details about the source of the function code
az functionapp deployment source show \
--name <app-name> \
--resource-group <res-group>
## If error like "This is currently not supported."
## Then, this is probalby using a container

# Get more info if a container is being used
az functionapp config container show \
--name <name> \
--resource-group <res-group>

# Get settings (and privesc to the sorage account)
az functionapp config appsettings list --name <app-name> --resource-group <res-group>

# Check if a domain was assigned to a function app
az functionapp config hostname list --webapp-name <app-name> --resource-group <res-group>

# Get SSL certificates
az functionapp config ssl list --resource-group <res-group>

# Get network restrictions
az functionapp config access-restriction show --name <app-name> --resource-group <res-group>

# Get more info about a function (invoke_url_template is the URL to invoke and script_href allows to see the code)
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/functions?api-version=2024-04-01"

# Get source code with Master Key of the function
curl "<script_href>?code=<master-key>"
## Python example
curl "https://newfuncttest123.azurewebsites.net/admin/vfs/home/site/wwwroot/function_app.py?code=<master-key>" -v

# Get source code
az rest --url "https://management.azure.com/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/hostruntime/admin/vfs/function_app.py?relativePath=1&api-version=2022-03-01"
```
## Kuinua Mamlaka

{{#ref}}
../az-privilege-escalation/az-functions-app-privesc.md
{{#endref}}

## Marejeo

- [https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition](https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition)

{{#include ../../../banners/hacktricks-training.md}}
