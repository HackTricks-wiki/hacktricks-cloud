# Az - Function Apps

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Azure Function Apps** είναι μια **serverless compute service** που σας επιτρέπει να εκτελείτε μικρά κομμάτια κώδικα, που ονομάζονται **functions**, χωρίς να διαχειρίζεστε την υποκείμενη υποδομή. Είναι σχεδιασμένα να εκτελούν κώδικα σε απάντηση σε διάφορους ενεργοποιητές, όπως **HTTP requests, timers, ή events από άλλες υπηρεσίες Azure** όπως Blob Storage ή Event Hubs. Τα Function Apps υποστηρίζουν πολλές γλώσσες προγραμματισμού, συμπεριλαμβανομένων των C#, Python, JavaScript και Java, καθιστώντας τα ευέλικτα για την κατασκευή **event-driven applications**, αυτοματοποίηση ροών εργασίας ή ενσωμάτωση υπηρεσιών. Είναι οικονομικά, καθώς συνήθως πληρώνετε μόνο για τον χρόνο υπολογισμού που χρησιμοποιείται όταν εκτελείται ο κώδικάς σας.

> [!NOTE]
> Σημειώστε ότι **Functions είναι ένα υποσύνολο των App Services**, επομένως, πολλές από τις δυνατότητες που συζητούνται εδώ θα χρησιμοποιηθούν επίσης από εφαρμογές που δημιουργούνται ως Azure Apps (`webapp` στο cli).

### Different Plans

- **Flex Consumption Plan**: Προσφέρει **dynamic, event-driven scaling** με τιμολόγηση pay-as-you-go, προσθέτοντας ή αφαιρώντας παραδείγματα λειτουργιών με βάση τη ζήτηση. Υποστηρίζει **virtual networking** και **pre-provisioned instances** για να μειώσει τις κρύες εκκινήσεις, καθιστώντας το κατάλληλο για **variable workloads** που δεν απαιτούν υποστήριξη κοντέινερ.
- **Traditional Consumption Plan**: Η προεπιλεγμένη serverless επιλογή, όπου **πληρώνετε μόνο για τους υπολογιστικούς πόρους όταν εκτελούνται οι λειτουργίες**. Αυξάνεται αυτόματα με βάση τα εισερχόμενα γεγονότα και περιλαμβάνει **cold start optimizations**, αλλά δεν υποστηρίζει αναπτύξεις κοντέινερ. Ιδανικό για **intermittent workloads** που απαιτούν αυτόματη κλιμάκωση.
- **Premium Plan**: Σχεδιασμένο για **consistent performance**, με **prewarmed workers** για να εξαλείψει τις κρύες εκκινήσεις. Προσφέρει **extended execution times, virtual networking**, και υποστηρίζει **custom Linux images**, καθιστώντας το τέλειο για **mission-critical applications** που χρειάζονται υψηλή απόδοση και προηγμένες δυνατότητες.
- **Dedicated Plan**: Λειτουργεί σε αφιερωμένες εικονικές μηχανές με **predictable billing** και υποστηρίζει χειροκίνητη ή αυτόματη κλιμάκωση. Επιτρέπει την εκτέλεση πολλών εφαρμογών στο ίδιο σχέδιο, παρέχει **compute isolation**, και εξασφαλίζει **secure network access** μέσω App Service Environments, καθιστώντας το ιδανικό για **long-running applications** που χρειάζονται συνεπή κατανομή πόρων.
- **Container Apps**: Επιτρέπει την ανάπτυξη **containerized function apps** σε ένα διαχειριζόμενο περιβάλλον, παράλληλα με μικροϋπηρεσίες και APIs. Υποστηρίζει προσαρμοσμένες βιβλιοθήκες, μετανάστευση κληρονομικών εφαρμογών, και **GPU processing**, εξαλείφοντας τη διαχείριση του Kubernetes cluster. Ιδανικό για **event-driven, scalable containerized applications**.

### **Storage Buckets**

Όταν δημιουργείτε μια νέα Function App που δεν είναι κοντεϊνερized (αλλά δίνετε τον κώδικα για εκτέλεση), τα **κωδικοποιημένα και άλλα δεδομένα που σχετίζονται με τη Function θα αποθηκευτούν σε έναν λογαριασμό Storage**. Από προεπιλογή, η διαδικτυακή κονσόλα θα δημιουργήσει έναν νέο ανά λειτουργία για να αποθηκεύσει τον κώδικα.

Επιπλέον, τροποποιώντας τον κώδικα μέσα στο bucket (στα διάφορα φορμά που μπορεί να αποθηκευτεί), ο **κώδικας της εφαρμογής θα τροποποιηθεί στον νέο και θα εκτελείται** την επόμενη φορά που θα κληθεί η Function.

> [!CAUTION]
> Αυτό είναι πολύ ενδιαφέρον από την προοπτική των επιτιθέμενων καθώς η **write access πάνω σε αυτό το bucket** θα επιτρέψει σε έναν επιτιθέμενο να **συμβιβάσει τον κώδικα και να κλιμακώσει τα προνόμια** στις διαχειριζόμενες ταυτότητες μέσα στην Function App.
>
> Περισσότερα σχετικά με αυτό στην **ενότητα κλιμάκωσης προνομίων**.

Είναι επίσης δυνατό να βρείτε τα **master και functions keys** αποθηκευμένα στον λογαριασμό storage στο κοντέινερ **`azure-webjobs-secrets`** μέσα στον φάκελο **`<app-name>`** στα αρχεία JSON που μπορείτε να βρείτε μέσα.

Σημειώστε ότι οι Functions επιτρέπουν επίσης την αποθήκευση του κώδικα σε μια απομακρυσμένη τοποθεσία απλά υποδεικνύοντας το URL σε αυτήν.

### Networking

Χρησιμοποιώντας έναν HTTP trigger:

- Είναι δυνατό να δώσετε **πρόσβαση σε μια λειτουργία από όλο το Διαδίκτυο** χωρίς να απαιτείται καμία αυθεντικοποίηση ή να δώσετε πρόσβαση με βάση το IAM. Αν και είναι επίσης δυνατό να περιορίσετε αυτήν την πρόσβαση.
- Είναι επίσης δυνατό να **δώσετε ή να περιορίσετε την πρόσβαση** σε μια Function App από **ένα εσωτερικό δίκτυο (VPC)**.

> [!CAUTION]
> Αυτό είναι πολύ ενδιαφέρον από την προοπτική των επιτιθέμενων καθώς μπορεί να είναι δυνατό να **pivot σε εσωτερικά δίκτυα** από μια ευάλωτη Function που εκτίθεται στο Διαδίκτυο.

### **Function App Settings & Environment Variables**

Είναι δυνατό να ρυθμίσετε μεταβλητές περιβάλλοντος μέσα σε μια εφαρμογή, οι οποίες μπορεί να περιέχουν ευαίσθητες πληροφορίες. Επιπλέον, από προεπιλογή οι μεταβλητές env **`AzureWebJobsStorage`** και **`WEBSITE_CONTENTAZUREFILECONNECTIONSTRING`** (μεταξύ άλλων) δημιουργούνται. Αυτές είναι ιδιαίτερα ενδιαφέρουσες γιατί **περιέχουν το κλειδί λογαριασμού για τον έλεγχο με ΠΛΗΡΗ δικαιώματα τον λογαριασμό storage που περιέχει τα δεδομένα της εφαρμογής**. Αυτές οι ρυθμίσεις είναι επίσης απαραίτητες για την εκτέλεση του κώδικα από τον Λογαριασμό Storage.

Αυτές οι μεταβλητές env ή παράμετροι ρύθμισης ελέγχουν επίσης πώς η Function εκτελεί τον κώδικα, για παράδειγμα αν **`WEBSITE_RUN_FROM_PACKAGE`** υπάρχει, θα υποδεικνύει το URL όπου βρίσκεται ο κώδικας της εφαρμογής.

### **Function Sandbox**

Μέσα στο linux sandbox ο πηγαίος κώδικας βρίσκεται στο **`/home/site/wwwroot`** στο αρχείο **`function_app.py`** (αν χρησιμοποιείται python) ο χρήστης που εκτελεί τον κώδικα είναι **`app`** (χωρίς δικαιώματα sudo).

Σε μια **Windows** function που χρησιμοποιεί NodeJS ο κώδικας βρισκόταν στο **`C:\home\site\wwwroot\HttpTrigger1\index.js`**, το όνομα χρήστη ήταν **`mawsFnPlaceholder8_f_v4_node_20_x86`** και ήταν μέρος των **groups**: `Mandatory Label\High Mandatory Level Label`, `Everyone`, `BUILTIN\Users`, `NT AUTHORITY\INTERACTIVE`, `CONSOLE LOGON`, `NT AUTHORITY\Authenticated Users`, `NT AUTHORITY\This Organization`, `BUILTIN\IIS_IUSRS`, `LOCAL`, `10-30-4-99\Dwas Site Users`.

### **Managed Identities & Metadata**

Ακριβώς όπως [**VMs**](vms/index.html), οι Functions μπορούν να έχουν **Managed Identities** 2 τύπων: System assigned και User assigned.

Η **system assigned** θα είναι μια διαχειριζόμενη ταυτότητα που **μόνο η λειτουργία** που έχει ανατεθεί θα μπορεί να χρησιμοποιήσει, ενώ οι **user assigned** διαχειριζόμενες ταυτότητες είναι διαχειριζόμενες ταυτότητες που **οποιαδήποτε άλλη υπηρεσία Azure θα μπορεί να χρησιμοποιήσει**.

> [!NOTE]
> Ακριβώς όπως στις [**VMs**](vms/index.html), οι Functions μπορούν να έχουν **1 system assigned** διαχειριζόμενη ταυτότητα και **πολλές user assigned**, επομένως είναι πάντα σημαντικό να προσπαθείτε να βρείτε όλες αυτές αν συμβιβάσετε τη λειτουργία γιατί μπορεί να μπορείτε να κλιμακώσετε τα προνόμια σε πολλές διαχειριζόμενες ταυτότητες από μόνο μία Function.
>
> Αν δεν χρησιμοποιείται μια διαχειριζόμενη ταυτότητα συστήματος αλλά μία ή περισσότερες διαχειριζόμενες ταυτότητες χρηστών είναι συνδεδεμένες σε μια λειτουργία, από προεπιλογή δεν θα μπορείτε να αποκτήσετε κανένα token.

Είναι δυνατό να χρησιμοποιήσετε τα [**PEASS scripts**](https://github.com/peass-ng/PEASS-ng) για να αποκτήσετε tokens από την προεπιλεγμένη διαχειριζόμενη ταυτότητα από το metadata endpoint. Ή μπορείτε να τα αποκτήσετε **χειροκίνητα** όπως εξηγείται σε:

{% embed url="https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#azure-vm" %}

Σημειώστε ότι πρέπει να βρείτε έναν τρόπο να **ελέγξετε όλες τις Managed Identities που έχει συνδεδεμένες μια λειτουργία** καθώς αν δεν το υποδείξετε, το metadata endpoint θα **χρησιμοποιεί μόνο την προεπιλεγμένη** (ελέγξτε τον προηγούμενο σύνδεσμο για περισσότερες πληροφορίες).

## Access Keys

> [!NOTE]
> Σημειώστε ότι δεν υπάρχουν δικαιώματα RBAC για να δώσετε πρόσβαση σε χρήστες να καλέσουν τις λειτουργίες. Η **κλήση λειτουργίας εξαρτάται από τον ενεργοποιητή** που επιλέχθηκε κατά τη δημιουργία και αν επιλέχθηκε ένας HTTP Trigger, μπορεί να χρειαστεί να χρησιμοποιήσετε ένα **access key**.

Όταν δημιουργείτε ένα endpoint μέσα σε μια λειτουργία χρησιμοποιώντας έναν **HTTP trigger** είναι δυνατό να υποδείξετε το **access key authorization level** που απαιτείται για να ενεργοποιήσετε τη λειτουργία. Διατίθενται τρεις επιλογές:

- **ANONYMOUS**: **Όλοι** μπορούν να έχουν πρόσβαση στη λειτουργία μέσω του URL.
- **FUNCTION**: Το endpoint είναι προσβάσιμο μόνο σε χρήστες που χρησιμοποιούν ένα **function, host ή master key**.
- **ADMIN**: Το endpoint είναι προσβάσιμο μόνο σε χρήστες με ένα **master key**.

**Τύποι κλειδιών:**

- **Function Keys:** Τα κλειδιά λειτουργίας μπορεί να είναι είτε προεπιλεγμένα είτε καθορισμένα από τον χρήστη και έχουν σχεδιαστεί για να παρέχουν πρόσβαση αποκλειστικά σε **συγκεκριμένα endpoints λειτουργίας** εντός μιας Function App επιτρέποντας μια πιο λεπτομερή πρόσβαση στα endpoints.
- **Host Keys:** Τα κλειδιά host, τα οποία μπορεί επίσης να είναι προεπιλεγμένα ή καθορισμένα από τον χρήστη, παρέχουν πρόσβαση σε **όλα τα endpoints λειτουργίας εντός μιας Function App με επίπεδο πρόσβασης FUNCTION**.
- **Master Key:** Το master key (`_master`) χρησιμεύει ως διοικητικό κλειδί που προσφέρει αυξημένα δικαιώματα, συμπεριλαμβανομένης της πρόσβασης σε όλα τα endpoints λειτουργίας (συμπεριλαμβανομένου του επιπέδου πρόσβασης ADMIN). Αυτό το **κλειδί δεν μπορεί να ανακληθεί.**
- **System Keys:** Τα συστήματα κλειδιά είναι **διαχειριζόμενα από συγκεκριμένες επεκτάσεις** και απαιτούνται για την πρόσβαση σε webhook endpoints που χρησιμοποιούνται από εσωτερικά στοιχεία. Παραδείγματα περιλαμβάνουν τον Event Grid trigger και τις Durable Functions, οι οποίες χρησιμοποιούν συστήματα κλειδιά για να αλληλεπιδρούν με τις αντίστοιχες APIs τους με ασφάλεια.

> [!TIP]
> Παράδειγμα για πρόσβαση σε ένα endpoint API λειτουργίας χρησιμοποιώντας ένα κλειδί:
>
> `https://<function_uniq_name>.azurewebsites.net/api/<endpoint_name>?code=<access_key>`

### Basic Authentication

Ακριβώς όπως στις App Services, οι Functions υποστηρίζουν επίσης βασική αυθεντικοποίηση για σύνδεση στο **SCM** και **FTP** για την ανάπτυξη κώδικα χρησιμοποιώντας ένα **όνομα χρήστη και κωδικό πρόσβασης σε ένα URL** που παρέχεται από την Azure. Περισσότερες πληροφορίες σχετικά με αυτό σε:

{{#ref}}
az-app-services.md
{{#endref}}

### Github Based Deployments

Όταν μια λειτουργία δημιουργείται από ένα Github repo, η διαδικτυακή κονσόλα Azure επιτρέπει να **δημιουργηθεί αυτόματα ένα Github Workflow σε ένα συγκεκριμένο αποθετήριο** έτσι ώστε κάθε φορά που αυτό το αποθετήριο ενημερώνεται, ο κώδικας της λειτουργίας ενημερώνεται. Στην πραγματικότητα, το Github Action yaml για μια python function φαίνεται έτσι:

<details>

<summary>Github Action Yaml</summary>
```yaml
# Docs for the Azure Web Apps Deploy action: https://github.com/azure/functions-action
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Python, GitHub Actions, and Azure Functions: https://aka.ms/python-webapps-actions

name: Build and deploy Python project to Azure Function App - funcGithub

on:
push:
branches:
- main
workflow_dispatch:

env:
AZURE_FUNCTIONAPP_PACKAGE_PATH: "." # set this to the path to your web app project, defaults to the repository root
PYTHON_VERSION: "3.11" # set this to the python version to use (supports 3.6, 3.7, 3.8)

jobs:
build:
runs-on: ubuntu-latest
steps:
- name: Checkout repository
uses: actions/checkout@v4

- name: Setup Python version
uses: actions/setup-python@v5
with:
python-version: ${{ env.PYTHON_VERSION }}

- name: Create and start virtual environment
run: |
python -m venv venv
source venv/bin/activate

- name: Install dependencies
run: pip install -r requirements.txt

# Optional: Add step to run tests here

- name: Zip artifact for deployment
run: zip release.zip ./* -r

- name: Upload artifact for deployment job
uses: actions/upload-artifact@v4
with:
name: python-app
path: |
release.zip
!venv/

deploy:
runs-on: ubuntu-latest
needs: build

permissions:
id-token: write #This is required for requesting the JWT

steps:
- name: Download artifact from build job
uses: actions/download-artifact@v4
with:
name: python-app

- name: Unzip artifact for deployment
run: unzip release.zip

- name: Login to Azure
uses: azure/login@v2
with:
client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_6C3396368D954957BC58E4C788D37FD1 }}
tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_7E50AEF6222E4C3DA9272D27FB169CCD }}
subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_905358F484A74277BDC20978459F26F4 }}

- name: "Deploy to Azure Functions"
uses: Azure/functions-action@v1
id: deploy-to-function
with:
app-name: "funcGithub"
slot-name: "Production"
package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
```
</details>

Επιπλέον, μια **Διαχειριζόμενη Ταυτότητα** δημιουργείται ώστε η Github Action από το αποθετήριο να μπορεί να συνδεθεί στο Azure με αυτή. Αυτό γίνεται με τη δημιουργία ενός Ομοσπονδιακού διαπιστευτηρίου πάνω στη **Διαχειριζόμενη Ταυτότητα** επιτρέποντας στον **Εκδότη** `https://token.actions.githubusercontent.com` και τον **Αναγνωριστικό Υποκειμένου** `repo:<org-name>/<repo-name>:ref:refs/heads/<branch-name>`.

> [!CAUTION]
> Επομένως, οποιοσδήποτε συμβιβάσει αυτό το αποθετήριο θα μπορεί να συμβιβάσει τη λειτουργία και τις Διαχειριζόμενες Ταυτότητες που είναι συνδεδεμένες με αυτή.

### Αναπτύξεις Βασισμένες σε Κοντέινερ

Όλα τα σχέδια δεν επιτρέπουν την ανάπτυξη κοντέινερ, αλλά για εκείνα που το επιτρέπουν, η διαμόρφωση θα περιέχει τη διεύθυνση URL του κοντέινερ. Στην API, η ρύθμιση **`linuxFxVersion`** θα έχει κάτι σαν: `DOCKER|mcr.microsoft.com/...`, ενώ στην κονσόλα ιστού, η διαμόρφωση θα δείχνει τις **ρυθμίσεις εικόνας**.

Επιπλέον, **κανένας πηγαίος κώδικας δεν θα αποθηκευτεί στον λογαριασμό αποθήκευσης** που σχετίζεται με τη λειτουργία καθώς δεν είναι απαραίτητος.

## Αριθμητική

{{#tabs }}
{{#tab name="az cli" }}
```bash
# List all the functions
az functionapp list

# Get info of 1 funciton (although in the list you already get this info)
az functionapp show --name <app-name> --resource-group <res-group>
## If "linuxFxVersion" has something like: "DOCKER|mcr.microsoft.com/..."
## This is using a container

# Get details about the source of the function code
az functionapp deployment source show \
--name <app-name> \
--resource-group <res-group>
## If error like "This is currently not supported."
## Then, this is probalby using a container

# Get more info if a container is being used
az functionapp config container show \
--name <name> \
--resource-group <res-group>

# Get settings (and privesc to the sorage account)
az functionapp config appsettings list --name <app-name> --resource-group <res-group>

# Check if a domain was assigned to a function app
az functionapp config hostname list --webapp-name <app-name> --resource-group <res-group>

# Get SSL certificates
az functionapp config ssl list --resource-group <res-group>

# Get network restrictions
az functionapp config access-restriction show --name <app-name> --resource-group <res-group>

# Get more info about a function (invoke_url_template is the URL to invoke and script_href allows to see the code)
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/functions?api-version=2024-04-01"

# Get source code with Master Key of the function
curl "<script_href>?code=<master-key>"
## Python example
curl "https://newfuncttest123.azurewebsites.net/admin/vfs/home/site/wwwroot/function_app.py?code=<master-key>" -v

# Get source code
az rest --url "https://management.azure.com/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/hostruntime/admin/vfs/function_app.py?relativePath=1&api-version=2022-03-01"
```
{{#endtab }}

{{#tab name="Az Powershell" }}
```powershell
Get-Command -Module Az.Functions

# Lists all Function Apps in the current subscription or in a specific resource group.
Get-AzFunctionApp  -ResourceGroupName <String>

# Displays the regions where Azure Function Apps are available for deployment.
Get-AzFunctionAppAvailableLocation

# Retrieves details about Azure Function App plans in a subscription or resource group.
Get-AzFunctionAppPlan -ResourceGroupName <String> -Name <String>

# Retrieves the app settings for a specific Azure Function App.
Get-AzFunctionAppSetting -Name <FunctionAppName> -ResourceGroupName <ResourceGroupName>
```
{{#endtab }}
{{#endtabs }}


## Κλιμάκωση Δικαιωμάτων

{{#ref}}
../az-privilege-escalation/az-functions-app-privesc.md
{{#endref}}

## Αναφορές

- [https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition](https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition)

{{#include ../../../banners/hacktricks-training.md}}
