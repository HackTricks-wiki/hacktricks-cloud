# Az - Function Apps

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

**Azure Function Apps** to **usługa obliczeniowa bezserwerowa**, która pozwala na uruchamianie małych fragmentów kodu, zwanych **funkcjami**, bez zarządzania infrastrukturą. Zostały zaprojektowane do wykonywania kodu w odpowiedzi na różne wyzwalacze, takie jak **żądania HTTP, timery lub zdarzenia z innych usług Azure**, takich jak Blob Storage czy Event Hubs. Function Apps obsługują wiele języków programowania, w tym C#, Python, JavaScript i Java, co czyni je wszechstronnymi do budowania **aplikacji opartych na zdarzeniach**, automatyzacji procesów roboczych lub integracji usług. Są opłacalne, ponieważ zazwyczaj płacisz tylko za czas obliczeniowy używany podczas uruchamiania kodu.

> [!NOTE]
> Zauważ, że **Funkcje są podzbiorem App Services**, dlatego wiele funkcji omówionych tutaj będzie również używanych przez aplikacje tworzone jako Azure Apps (`webapp` w cli).

### Różne plany

- **Plan Flex Consumption**: Oferuje **dynamiczne, oparte na zdarzeniach skalowanie** z ceną płatności za użycie, dodając lub usuwając instancje funkcji w zależności od popytu. Obsługuje **wirtualne sieci** i **wstępnie przydzielone instancje**, aby zredukować zimne uruchomienia, co czyni go odpowiednim dla **zmiennych obciążeń**, które nie wymagają wsparcia kontenerów.
- **Plan Traditional Consumption**: Domyślna opcja bezserwerowa, w której **płacisz tylko za zasoby obliczeniowe, gdy funkcje są uruchamiane**. Automatycznie skaluje się w zależności od nadchodzących zdarzeń i zawiera **optymalizacje zimnego uruchomienia**, ale nie obsługuje wdrożeń kontenerów. Idealny dla **przerywanych obciążeń** wymagających automatycznego skalowania.
- **Plan Premium**: Zaprojektowany dla **spójnej wydajności**, z **wstępnie podgrzanymi pracownikami**, aby wyeliminować zimne uruchomienia. Oferuje **wydłużone czasy wykonania, wirtualne sieci** i obsługuje **niestandardowe obrazy Linux**, co czyni go idealnym dla **aplikacji krytycznych dla misji**, które potrzebują wysokiej wydajności i zaawansowanych funkcji.
- **Plan Dedicated**: Działa na dedykowanych maszynach wirtualnych z **przewidywalnym rozliczeniem** i obsługuje ręczne lub automatyczne skalowanie. Umożliwia uruchamianie wielu aplikacji w tym samym planie, zapewnia **izolację obliczeniową** i zapewnia **bezpieczny dostęp do sieci** za pośrednictwem środowisk App Service, co czyni go idealnym dla **aplikacji długoterminowych** wymagających spójnej alokacji zasobów.
- **Container Apps**: Umożliwia wdrażanie **kontenerowych aplikacji funkcji** w zarządzanym środowisku, obok mikroserwisów i interfejsów API. Obsługuje niestandardowe biblioteki, migrację aplikacji dziedzicznych i **przetwarzanie GPU**, eliminując zarządzanie klastrami Kubernetes. Idealny dla **opartych na zdarzeniach, skalowalnych aplikacji kontenerowych**.

### **Koszyki pamięci**

Podczas tworzenia nowej aplikacji funkcji, która nie jest kontenerowa (ale dostarcza kod do uruchomienia), **kod i inne dane związane z funkcją będą przechowywane w koncie pamięci**. Domyślnie konsola internetowa utworzy nową dla każdej funkcji, aby przechować kod.

Co więcej, modyfikując kod wewnątrz koszyka (w różnych formatach, w jakich może być przechowywany), **kod aplikacji zostanie zmodyfikowany na nowy i wykonany** następnym razem, gdy funkcja zostanie wywołana.

> [!CAUTION]
> To jest bardzo interesujące z perspektywy atakującego, ponieważ **dostęp do zapisu w tym koszyku** pozwoli atakującemu na **kompromitację kodu i eskalację uprawnień** do zarządzanych tożsamości wewnątrz aplikacji funkcji.
>
> Więcej na ten temat w **sekcji eskalacji uprawnień**.

Możliwe jest również znalezienie **kluczy głównych i funkcji** przechowywanych w koncie pamięci w kontenerze **`azure-webjobs-secrets`** wewnątrz folderu **`<app-name>`** w plikach JSON, które można tam znaleźć.

Zauważ, że Funkcje pozwalają również na przechowywanie kodu w zdalnej lokalizacji, wskazując po prostu adres URL do niej.

### Sieci

Używając wyzwalacza HTTP:

- Możliwe jest udzielenie **dostępu do funkcji z całego Internetu** bez wymagania jakiejkolwiek autoryzacji lub udzielenie dostępu opartego na IAM. Chociaż możliwe jest również ograniczenie tego dostępu.
- Możliwe jest również **udzielenie lub ograniczenie dostępu** do aplikacji funkcji z **wewnętrznej sieci (VPC)**.

> [!CAUTION]
> To jest bardzo interesujące z perspektywy atakującego, ponieważ może być możliwe **przejście do wewnętrznych sieci** z podatnej funkcji wystawionej na Internet.

### **Ustawienia aplikacji funkcji i zmienne środowiskowe**

Możliwe jest skonfigurowanie zmiennych środowiskowych wewnątrz aplikacji, które mogą zawierać wrażliwe informacje. Co więcej, domyślnie zmienne środowiskowe **`AzureWebJobsStorage`** i **`WEBSITE_CONTENTAZUREFILECONNECTION
```yaml
# Docs for the Azure Web Apps Deploy action: https://github.com/azure/functions-action
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Python, GitHub Actions, and Azure Functions: https://aka.ms/python-webapps-actions

name: Build and deploy Python project to Azure Function App - funcGithub

on:
push:
branches:
- main
workflow_dispatch:

env:
AZURE_FUNCTIONAPP_PACKAGE_PATH: "." # set this to the path to your web app project, defaults to the repository root
PYTHON_VERSION: "3.11" # set this to the python version to use (supports 3.6, 3.7, 3.8)

jobs:
build:
runs-on: ubuntu-latest
steps:
- name: Checkout repository
uses: actions/checkout@v4

- name: Setup Python version
uses: actions/setup-python@v5
with:
python-version: ${{ env.PYTHON_VERSION }}

- name: Create and start virtual environment
run: |
python -m venv venv
source venv/bin/activate

- name: Install dependencies
run: pip install -r requirements.txt

# Optional: Add step to run tests here

- name: Zip artifact for deployment
run: zip release.zip ./* -r

- name: Upload artifact for deployment job
uses: actions/upload-artifact@v4
with:
name: python-app
path: |
release.zip
!venv/

deploy:
runs-on: ubuntu-latest
needs: build

permissions:
id-token: write #This is required for requesting the JWT

steps:
- name: Download artifact from build job
uses: actions/download-artifact@v4
with:
name: python-app

- name: Unzip artifact for deployment
run: unzip release.zip

- name: Login to Azure
uses: azure/login@v2
with:
client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_6C3396368D954957BC58E4C788D37FD1 }}
tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_7E50AEF6222E4C3DA9272D27FB169CCD }}
subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_905358F484A74277BDC20978459F26F4 }}

- name: "Deploy to Azure Functions"
uses: Azure/functions-action@v1
id: deploy-to-function
with:
app-name: "funcGithub"
slot-name: "Production"
package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
```
</details>

Ponadto, **Zarządzana Tożsamość** jest również tworzona, aby akcja Github z repozytorium mogła się zalogować do Azure. Dzieje się to poprzez wygenerowanie poświadczenia federacyjnego dla **Zarządzanej Tożsamości**, umożliwiającego **Wydawcy** `https://token.actions.githubusercontent.com` oraz **Identyfikatorowi Podmiotu** `repo:<org-name>/<repo-name>:ref:refs/heads/<branch-name>`.

> [!CAUTION]
> Dlatego każdy, kto skompromituje to repozytorium, będzie mógł skompromitować funkcję oraz Zarządzane Tożsamości do niej przypisane.

### Wdrożenia Oparte na Kontenerach

Nie wszystkie plany pozwalają na wdrażanie kontenerów, ale dla tych, które to robią, konfiguracja będzie zawierać URL kontenera. W API ustawienie **`linuxFxVersion`** będzie miało coś takiego jak: `DOCKER|mcr.microsoft.com/...`, podczas gdy w konsoli internetowej konfiguracja pokaże **ustawienia obrazu**.

Ponadto, **żaden kod źródłowy nie będzie przechowywany w koncie** magazynowym związanym z funkcją, ponieważ nie jest to potrzebne.

## Enumeracja
```bash
# List all the functions
az functionapp list

# Get info of 1 funciton (although in the list you already get this info)
az functionapp show --name <app-name> --resource-group <res-group>
## If "linuxFxVersion" has something like: "DOCKER|mcr.microsoft.com/..."
## This is using a container

# Get details about the source of the function code
az functionapp deployment source show \
--name <app-name> \
--resource-group <res-group>
## If error like "This is currently not supported."
## Then, this is probalby using a container

# Get more info if a container is being used
az functionapp config container show \
--name <name> \
--resource-group <res-group>

# Get settings (and privesc to the sorage account)
az functionapp config appsettings list --name <app-name> --resource-group <res-group>

# Check if a domain was assigned to a function app
az functionapp config hostname list --webapp-name <app-name> --resource-group <res-group>

# Get SSL certificates
az functionapp config ssl list --resource-group <res-group>

# Get network restrictions
az functionapp config access-restriction show --name <app-name> --resource-group <res-group>

# Get more info about a function (invoke_url_template is the URL to invoke and script_href allows to see the code)
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/functions?api-version=2024-04-01"

# Get source code with Master Key of the function
curl "<script_href>?code=<master-key>"
## Python example
curl "https://newfuncttest123.azurewebsites.net/admin/vfs/home/site/wwwroot/function_app.py?code=<master-key>" -v

# Get source code
az rest --url "https://management.azure.com/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/hostruntime/admin/vfs/function_app.py?relativePath=1&api-version=2022-03-01"
```
## Eskalacja Uprawnień

{{#ref}}
../az-privilege-escalation/az-functions-app-privesc.md
{{#endref}}

## Odniesienia

- [https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition](https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition)

{{#include ../../../banners/hacktricks-training.md}}
