# Az - Function Apps

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Azure Function Apps** एक **सर्वरलेस कंप्यूट सेवा** हैं जो आपको **फंक्शंस** नामक छोटे कोड के टुकड़े चलाने की अनुमति देती हैं, बिना अंतर्निहित बुनियादी ढांचे का प्रबंधन किए। इन्हें विभिन्न ट्रिगर्स के जवाब में कोड निष्पादित करने के लिए डिज़ाइन किया गया है, जैसे कि **HTTP अनुरोध, टाइमर, या अन्य Azure सेवाओं** से घटनाएँ जैसे Blob Storage या Event Hubs। Function Apps कई प्रोग्रामिंग भाषाओं का समर्थन करते हैं, जिसमें C#, Python, JavaScript, और Java शामिल हैं, जिससे ये **इवेंट-ड्रिवन एप्लिकेशन**, वर्कफ़्लो को स्वचालित करने, या सेवाओं को एकीकृत करने के लिए बहुपरकारी बनाते हैं। ये लागत-कुशल हैं, क्योंकि आप आमतौर पर केवल उस कंप्यूट समय के लिए भुगतान करते हैं जब आपका कोड चलता है।

> [!NOTE]
> ध्यान दें कि **Functions App Services का एक उपसमुच्चय हैं**, इसलिए, यहां चर्चा की गई कई सुविधाएँ Azure Apps (`webapp` in cli) के रूप में बनाए गए अनुप्रयोगों द्वारा भी उपयोग की जाएंगी।

### Different Plans

- **Flex Consumption Plan**: **डायनामिक, इवेंट-ड्रिवन स्केलिंग** के साथ पे-एज़-यू-गो मूल्य निर्धारण प्रदान करता है, मांग के आधार पर फ़ंक्शन उदाहरणों को जोड़ने या हटाने की अनुमति देता है। यह **वर्चुअल नेटवर्किंग** और **पूर्व-प्रावधानित उदाहरणों** का समर्थन करता है ताकि ठंडी शुरुआत को कम किया जा सके, जिससे यह **परिवर्तनीय कार्यभार** के लिए उपयुक्त है जो कंटेनर समर्थन की आवश्यकता नहीं है।
- **Traditional Consumption Plan**: डिफ़ॉल्ट सर्वरलेस विकल्प, जहां आप **केवल तब कंप्यूट संसाधनों के लिए भुगतान करते हैं जब फ़ंक्शन चलते हैं**। यह आने वाली घटनाओं के आधार पर स्वचालित रूप से स्केल करता है और इसमें **कोल्ड स्टार्ट ऑप्टिमाइजेशन** शामिल हैं, लेकिन यह कंटेनर तैनाती का समर्थन नहीं करता है। स्वचालित स्केलिंग की आवश्यकता वाले **अवधिक कार्यभार** के लिए आदर्श।
- **Premium Plan**: **संगत प्रदर्शन** के लिए डिज़ाइन किया गया, जिसमें ठंडी शुरुआत को समाप्त करने के लिए **पूर्व-गर्म श्रमिक** होते हैं। यह **विस्तारित निष्पादन समय, वर्चुअल नेटवर्किंग** प्रदान करता है, और **कस्टम लिनक्स इमेज** का समर्थन करता है, जिससे यह **मिशन-क्रिटिकल एप्लिकेशन** के लिए आदर्श है जिन्हें उच्च प्रदर्शन और उन्नत सुविधाओं की आवश्यकता होती है।
- **Dedicated Plan**: समर्पित वर्चुअल मशीनों पर चलता है जिसमें **पूर्वानुमेय बिलिंग** होती है और मैनुअल या स्वचालित स्केलिंग का समर्थन करता है। यह एक ही योजना पर कई ऐप चलाने की अनुमति देता है, **कंप्यूट आइसोलेशन** प्रदान करता है, और App Service Environments के माध्यम से **सुरक्षित नेटवर्क एक्सेस** सुनिश्चित करता है, जिससे यह **लंबे समय तक चलने वाले अनुप्रयोगों** के लिए आदर्श है जिन्हें लगातार संसाधन आवंटन की आवश्यकता होती है।
- **Container Apps**: एक प्रबंधित वातावरण में **कंटेनराइज्ड फ़ंक्शन ऐप्स** को तैनात करने की अनुमति देता है, माइक्रोसर्विसेज और APIs के साथ। यह कस्टम पुस्तकालयों, विरासती ऐप माइग्रेशन, और **GPU प्रोसेसिंग** का समर्थन करता है, जिससे Kubernetes क्लस्टर प्रबंधन समाप्त हो जाता है। **इवेंट-ड्रिवन, स्केलेबल कंटेनराइज्ड एप्लिकेशन** के लिए आदर्श।

### **Storage Buckets**

जब एक नया फ़ंक्शन ऐप बनाया जाता है जो कंटेनराइज नहीं होता (लेकिन चलाने के लिए कोड देता है), तो **कोड और अन्य फ़ंक्शन से संबंधित डेटा एक स्टोरेज खाते में संग्रहीत किया जाएगा**। डिफ़ॉल्ट रूप से, वेब कंसोल प्रत्येक फ़ंक्शन के लिए कोड संग्रहीत करने के लिए एक नया बनाएगा।

इसके अलावा, बकेट के अंदर कोड को संशोधित करने पर (जिस विभिन्न प्रारूपों में इसे संग्रहीत किया जा सकता है), **ऐप का कोड नए कोड में संशोधित किया जाएगा और अगली बार फ़ंक्शन को कॉल करने पर निष्पादित किया जाएगा**।

> [!CAUTION]
> यह हमलावरों के दृष्टिकोण से बहुत दिलचस्प है क्योंकि **इस बकेट पर लिखने की पहुंच** एक हमलावर को **कोड से समझौता करने और फ़ंक्शन ऐप के अंदर प्रबंधित पहचान को बढ़ाने** की अनुमति देगी।
>
> इस पर अधिक जानकारी **प्रिविलेज एस्कलेशन सेक्शन** में है।

यह भी संभव है कि **मास्टर और फ़ंक्शंस कुंजी** स्टोरेज खाते में **`azure-webjobs-secrets`** कंटेनर में **`<app-name>`** फ़ोल्डर के अंदर JSON फ़ाइलों में संग्रहीत हों।

ध्यान दें कि फ़ंक्शंस को एक दूरस्थ स्थान पर कोड संग्रहीत करने की अनुमति भी है, बस इसके लिए URL निर्दिष्ट करके।

### Networking

HTTP ट्रिगर का उपयोग करते समय:

- यह संभव है कि **इंटरनेट से फ़ंक्शन को सभी के लिए पहुंच प्रदान करें** बिना किसी प्रमाणीकरण की आवश्यकता के या IAM आधारित पहुंच प्रदान करें। हालांकि, इस पहुंच को प्रतिबंधित करना भी संभव है।
- यह भी संभव है कि **एक आंतरिक नेटवर्क (VPC)** से फ़ंक्शन ऐप को **पहुंच दें या प्रतिबंधित करें**।

> [!CAUTION]
> यह हमलावरों के दृष्टिकोण से बहुत दिलचस्प है क्योंकि यह संभव है कि **इंटरनेट पर उजागर एक कमजोर फ़ंक्शन से आंतरिक नेटवर्क पर पिवट किया जा सके**।

### **Function App Settings & Environment Variables**

यह ऐप के अंदर पर्यावरण चर कॉन्फ़िगर करना संभव है, जिसमें संवेदनशील जानकारी हो सकती है। इसके अलावा, डिफ़ॉल्ट रूप से **`AzureWebJobsStorage`** और **`WEBSITE_CONTENTAZUREFILECONNECTIONSTRING`** (अन्य के बीच) पर्यावरण चर बनाए जाते हैं। ये विशेष रूप से दिलचस्प हैं क्योंकि ये **ऐप्लिकेशन के डेटा को नियंत्रित करने के लिए स्टोरेज खाते की कुंजी** को पूर्ण अनुमतियों के साथ शामिल करते हैं। इन सेटिंग्स की आवश्यकता भी स्टोरेज खाते से कोड निष्पादित करने के लिए होती है।

ये पर्यावरण चर या कॉन्फ़िगरेशन पैरामीटर यह भी नियंत्रित करते हैं कि फ़ंक्शन कोड को कैसे निष्पादित करता है, उदाहरण के लिए यदि **`WEBSITE_RUN_FROM_PACKAGE`** मौजूद है, तो यह उस URL को इंगित करेगा जहां ऐप्लिकेशन का कोड स्थित है।

### **Function Sandbox**

लिनक्स सैंडबॉक्स के अंदर स्रोत कोड **`/home/site/wwwroot`** में फ़ाइल **`function_app.py`** (यदि पायथन का उपयोग किया गया है) में स्थित है, कोड चलाने वाला उपयोगकर्ता **`app`** है (बिना sudo अनुमतियों के)।

एक **Windows** फ़ंक्शन में NodeJS का उपयोग करते समय कोड **`C:\home\site\wwwroot\HttpTrigger1\index.js`** में स्थित था, उपयोगकर्ता नाम **`mawsFnPlaceholder8_f_v4_node_20_x86`** था और यह **समूहों** का हिस्सा था: `Mandatory Label\High Mandatory Level Label`, `Everyone`, `BUILTIN\Users`, `NT AUTHORITY\INTERACTIVE`, `CONSOLE LOGON`, `NT AUTHORITY\Authenticated Users`, `NT AUTHORITY\This Organization`, `BUILTIN\IIS_IUSRS`, `LOCAL`, `10-30-4-99\Dwas Site Users`।

### **Managed Identities & Metadata**

जैसे कि [**VMs**](vms/) में, फ़ंक्शंस के पास **Managed Identities** के 2 प्रकार हो सकते हैं: सिस्टम असाइन और यूजर असाइन।

**सिस्टम असाइन** वाला एक प्रबंधित पहचान होगी जिसे **केवल वही फ़ंक्शन** उपयोग कर सकेगा जिसे यह असाइन किया गया है, जबकि **यूजर असाइन** प्रबंधित पहचानें ऐसी प्रबंधित पहचान हैं जिन्हें **कोई अन्य Azure सेवा उपयोग कर सकेगी**।

> [!NOTE]
> जैसे कि [**VMs**](vms/) में, फ़ंक्शंस के पास **1 सिस्टम असाइन** प्रबंधित पहचान और **कई यूजर असाइन** प्रबंधित पहचान हो सकती हैं, इसलिए यदि आप फ़ंक्शन से समझौता करते हैं तो सभी को खोजने का प्रयास करना हमेशा महत्वपूर्ण होता है क्योंकि आप एक फ़ंक्शन से कई प्रबंधित पहचान को बढ़ा सकते हैं।
>
> यदि कोई सिस्टम प्रबंधित पहचान का उपयोग नहीं किया गया है लेकिन एक या अधिक यूजर प्रबंधित पहचानें फ़ंक्शन से जुड़ी हैं, तो डिफ़ॉल्ट रूप से आप कोई टोकन प्राप्त नहीं कर पाएंगे।

आप [**PEASS स्क्रिप्ट्स**](https://github.com/peass-ng/PEASS-ng) का उपयोग करके मेटाडेटा एंडपॉइंट से डिफ़ॉल्ट प्रबंधित पहचान से टोकन प्राप्त कर सकते हैं। या आप उन्हें **हाथ से** प्राप्त कर सकते हैं जैसा कि समझाया गया है:

{% embed url="https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf#azure-vm" %}

ध्यान दें कि आपको यह पता लगाने की आवश्यकता है कि **एक फ़ंक्शन के पास जुड़ी सभी प्रबंधित पहचानें** कैसे जांचें क्योंकि यदि आप इसे निर्दिष्ट नहीं करते हैं, तो मेटाडेटा एंडपॉइंट **केवल डिफ़ॉल्ट एक का उपयोग करेगा** (अधिक जानकारी के लिए पिछले लिंक की जांच करें)।

## Access Keys

> [!NOTE]
> ध्यान दें कि उपयोगकर्ताओं को फ़ंक्शंस को सक्रिय करने के लिए पहुंच देने के लिए कोई RBAC अनुमतियाँ नहीं हैं। **फ़ंक्शन सक्रियण उस ट्रिगर पर निर्भर करता है** जो इसे बनाया गया था और यदि एक HTTP ट्रिगर चुना गया था, तो इसे **एक्सेस की** का उपयोग करने की आवश्यकता हो सकती है।

एक फ़ंक्शन के अंदर एक एंडपॉइंट बनाते समय **HTTP ट्रिगर** का उपयोग करते समय, यह संभव है कि **फ़ंक्शन को सक्रिय करने के लिए आवश्यक एक्सेस की प्राधिकरण स्तर** को निर्दिष्ट करें। तीन विकल्प उपलब्ध हैं:

- **ANONYMOUS**: **हर कोई** URL के माध्यम से फ़ंक्शन तक पहुंच सकता है।
- **FUNCTION**: एंडपॉइंट केवल उन उपयोगकर्ताओं के लिए सुलभ है जो **फंक्शन, होस्ट या मास्टर की** का उपयोग कर रहे हैं।
- **ADMIN**: एंडपॉइंट केवल उन उपयोगकर्ताओं के लिए सुलभ है जिनके पास **मास्टर की** है।

**कुंजी के प्रकार:**

- **Function Keys:** फ़ंक्शन कुंजी या तो डिफ़ॉल्ट या उपयोगकर्ता-परिभाषित हो सकती हैं और इन्हें विशेष रूप से **एक फ़ंक्शन ऐप के भीतर विशिष्ट फ़ंक्शन एंडपॉइंट्स** तक पहुंच प्रदान करने के लिए डिज़ाइन किया गया है जिससे एंडपॉइंट्स पर अधिक बारीक पहुंच मिलती है।
- **Host Keys:** होस्ट कुंजी, जो डिफ़ॉल्ट या उपयोगकर्ता-परिभाषित भी हो सकती हैं, **एक फ़ंक्शन ऐप के भीतर सभी फ़ंक्शन एंडपॉइंट्स तक पहुंच प्रदान करती हैं जिनका FUNCTION एक्सेस स्तर है**।
- **Master Key:** मास्टर कुंजी (`_master`) एक प्रशासनिक कुंजी के रूप में कार्य करती है जो सभी फ़ंक्शन एंडपॉइंट्स (ADMIN एक्सेस स्तर सहित) तक पहुंच प्रदान करती है। यह **कुंजी रद्द नहीं की जा सकती।**
- **System Keys:** सिस्टम कुंजी **विशिष्ट एक्सटेंशन द्वारा प्रबंधित** होती हैं और आंतरिक घटकों द्वारा उपयोग किए जाने वाले वेबहुक एंडपॉइंट्स तक पहुंच के लिए आवश्यक होती हैं। उदाहरणों में इवेंट ग्रिड ट्रिगर और ड्यूरेबल फ़ंक्शंस शामिल हैं, जो अपने संबंधित APIs के साथ सुरक्षित रूप से बातचीत करने के लिए सिस्टम कुंजी का उपयोग करते हैं।

> [!TIP]
> कुंजी का उपयोग करके फ़ंक्शन API एंडपॉइंट तक पहुंचने का उदाहरण:
>
> `https://<function_uniq_name>.azurewebsites.net/api/<endpoint_name>?code=<access_key>`

### Basic Authentication

जैसे कि ऐप सेवाओं में, फ़ंक्शंस भी **SCM** और **FTP** से कनेक्ट करने के लिए बुनियादी प्रमाणीकरण का समर्थन करते हैं ताकि कोड को **Azure द्वारा प्रदान किए गए URL में उपयोगकर्ता नाम और पासवर्ड** का उपयोग करके तैनात किया जा सके। इसके बारे में अधिक जानकारी:

{{#ref}}
az-app-service.md
{{#endref}}

### Github Based Deployments

जब एक फ़ंक्शन एक Github रिपॉजिटरी से उत्पन्न होता है, तो Azure वेब कंसोल **एक विशिष्ट रिपॉजिटरी में स्वचालित रूप से एक Github वर्कफ़्लो बनाने** की अनुमति देता है ताकि जब भी इस रिपॉजिटरी को अपडेट किया जाए, फ़ंक्शन का कोड अपडेट हो जाए। वास्तव में, एक पायथन फ़ंक्शन के लिए Github Action yaml इस तरह दिखता है:

<details>

<summary>Github Action Yaml</summary>
```yaml
# Docs for the Azure Web Apps Deploy action: https://github.com/azure/functions-action
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Python, GitHub Actions, and Azure Functions: https://aka.ms/python-webapps-actions

name: Build and deploy Python project to Azure Function App - funcGithub

on:
push:
branches:
- main
workflow_dispatch:

env:
AZURE_FUNCTIONAPP_PACKAGE_PATH: "." # set this to the path to your web app project, defaults to the repository root
PYTHON_VERSION: "3.11" # set this to the python version to use (supports 3.6, 3.7, 3.8)

jobs:
build:
runs-on: ubuntu-latest
steps:
- name: Checkout repository
uses: actions/checkout@v4

- name: Setup Python version
uses: actions/setup-python@v5
with:
python-version: ${{ env.PYTHON_VERSION }}

- name: Create and start virtual environment
run: |
python -m venv venv
source venv/bin/activate

- name: Install dependencies
run: pip install -r requirements.txt

# Optional: Add step to run tests here

- name: Zip artifact for deployment
run: zip release.zip ./* -r

- name: Upload artifact for deployment job
uses: actions/upload-artifact@v4
with:
name: python-app
path: |
release.zip
!venv/

deploy:
runs-on: ubuntu-latest
needs: build

permissions:
id-token: write #This is required for requesting the JWT

steps:
- name: Download artifact from build job
uses: actions/download-artifact@v4
with:
name: python-app

- name: Unzip artifact for deployment
run: unzip release.zip

- name: Login to Azure
uses: azure/login@v2
with:
client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_6C3396368D954957BC58E4C788D37FD1 }}
tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_7E50AEF6222E4C3DA9272D27FB169CCD }}
subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_905358F484A74277BDC20978459F26F4 }}

- name: "Deploy to Azure Functions"
uses: Azure/functions-action@v1
id: deploy-to-function
with:
app-name: "funcGithub"
slot-name: "Production"
package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
```
</details>

इसके अलावा, एक **Managed Identity** भी बनाई जाती है ताकि रिपॉजिटरी से Github Action इसके साथ Azure में लॉगिन कर सके। यह **Managed Identity** पर एक Federated credential उत्पन्न करके किया जाता है, जो **Issuer** `https://token.actions.githubusercontent.com` और **Subject Identifier** `repo:<org-name>/<repo-name>:ref:refs/heads/<branch-name>` को अनुमति देता है।

> [!CAUTION]
> इसलिए, जो कोई भी उस रिपॉजिटरी को समझौता करेगा, वह फ़ंक्शन और इससे जुड़े Managed Identities को भी समझौता कर सकेगा।

### Container Based Deployments

सभी योजनाएँ कंटेनर को तैनात करने की अनुमति नहीं देती हैं, लेकिन जिनमें अनुमति है, उनके लिए कॉन्फ़िगरेशन में कंटेनर का URL होगा। API में **`linuxFxVersion`** सेटिंग कुछ इस तरह होगी: `DOCKER|mcr.microsoft.com/...`, जबकि वेब कंसोल में, कॉन्फ़िगरेशन **image settings** दिखाएगा।

इसके अलावा, **कोई स्रोत कोड स्टोरेज** खाते में संग्रहीत नहीं किया जाएगा जो फ़ंक्शन से संबंधित है क्योंकि इसकी आवश्यकता नहीं है।

## Enumeration
```bash
# List all the functions
az functionapp list

# Get info of 1 funciton (although in the list you already get this info)
az functionapp show --name <app-name> --resource-group <res-group>
## If "linuxFxVersion" has something like: "DOCKER|mcr.microsoft.com/..."
## This is using a container

# Get details about the source of the function code
az functionapp deployment source show \
--name <app-name> \
--resource-group <res-group>
## If error like "This is currently not supported."
## Then, this is probalby using a container

# Get more info if a container is being used
az functionapp config container show \
--name <name> \
--resource-group <res-group>

# Get settings (and privesc to the sorage account)
az functionapp config appsettings list --name <app-name> --resource-group <res-group>

# Check if a domain was assigned to a function app
az functionapp config hostname list --webapp-name <app-name> --resource-group <res-group>

# Get SSL certificates
az functionapp config ssl list --resource-group <res-group>

# Get network restrictions
az functionapp config access-restriction show --name <app-name> --resource-group <res-group>

# Get more info about a function (invoke_url_template is the URL to invoke and script_href allows to see the code)
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/functions?api-version=2024-04-01"

# Get source code with Master Key of the function
curl "<script_href>?code=<master-key>"
## Python example
curl "https://newfuncttest123.azurewebsites.net/admin/vfs/home/site/wwwroot/function_app.py?code=<master-key>" -v

# Get source code
az rest --url "https://management.azure.com/<subscription>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/hostruntime/admin/vfs/function_app.py?relativePath=1&api-version=2022-03-01"
```
## विशेषाधिकार वृद्धि

{{#ref}}
../az-privilege-escalation/az-functions-app-privesc.md
{{#endref}}

## संदर्भ

- [https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition](https://learn.microsoft.com/en-us/azure/azure-functions/functions-openapi-definition)

{{#include ../../../banners/hacktricks-training.md}}
