# Az - App Services

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base sur App Service

Azure App Services permet aux développeurs de **créer, déployer et mettre à l'échelle des applications web, des backends d'applications mobiles et des API sans effort**. Il prend en charge plusieurs langages de programmation et s'intègre à divers outils et services Azure pour une fonctionnalité et une gestion améliorées.

Chaque application s'exécute dans un bac à sable, mais l'isolation dépend des plans App Service.

- Les applications dans les niveaux Gratuit et Partagé s'exécutent sur des VM partagées.
- Les applications dans les niveaux Standard et Premium s'exécutent sur des VM dédiées.

> [!WARNING]
> Notez que **aucune** de ces isolations **ne prévient** d'autres **vulnérabilités web** courantes (comme le téléchargement de fichiers ou les injections). Et si une **identité de gestion** est utilisée, elle pourrait être en mesure de **faire monter les privilèges**.

Les applications ont quelques configurations intéressantes :

- **Always On** : Assure que l'application est toujours en cours d'exécution. Si ce n'est pas activé, l'application cessera de fonctionner après 20 minutes d'inactivité et redémarrera lorsqu'une demande est reçue.
- Cela est essentiel si vous avez un webjob qui doit s'exécuter en continu, car le webjob s'arrêtera si l'application s'arrête.
- **SSH** : Si activé, un utilisateur ayant suffisamment de permissions peut se connecter à l'application en utilisant SSH.
- **Débogage** : Si activé, un utilisateur ayant suffisamment de permissions peut déboguer l'application. Cependant, cela est désactivé automatiquement toutes les 48 heures.
- **Web App + Base de données** : La console web permet de créer une application avec une base de données. Dans ce cas, il est possible de sélectionner la base de données à utiliser (SQLAzure, PostgreSQL, MySQL, MongoDB) et cela vous permet également de créer un Azure Cache pour Redis.
- L'URL contenant les informations d'identification pour la base de données et Redis sera stockée dans les **appsettings**.
- **Conteneur** : Il est possible de déployer un conteneur sur le App Service en indiquant l'URL du conteneur et les informations d'identification pour y accéder.

## Authentification de base

Lors de la création d'une application web (et d'une fonction Azure généralement), il est possible d'indiquer si vous souhaitez que l'authentification de base soit activée. Cela **active essentiellement SCM et FTP** pour l'application afin qu'il soit possible de déployer l'application en utilisant ces technologies.\
De plus, pour s'y connecter, Azure fournit une **API qui permet d'obtenir le nom d'utilisateur, le mot de passe et l'URL** pour se connecter aux serveurs SCM et FTP.

Il est possible de se connecter au SCM en utilisant un navigateur web à `https://<SMC-URL>/BasicAuth` et de vérifier tous les fichiers et déploiements qui s'y trouvent.

### Kudu

Kudu est un **moteur de déploiement et une plateforme de gestion pour Azure App Service et Function Apps**, fournissant des déploiements basés sur Git, un débogage à distance et des capacités de gestion de fichiers pour les applications web. Il est accessible via l'URL SCM de l'application web.

Notez que les versions Kudu utilisées par App Services et par Function Apps sont différentes, la version des Function Apps étant beaucoup plus limitée.

Quelques points de terminaison intéressants que vous pouvez trouver dans Kudu sont :
- `/DebugConsole` : Une console qui vous permet d'exécuter des commandes dans l'environnement où Kudu s'exécute.
- Notez que cet environnement **n'a pas accès** au service de métadonnées pour obtenir des jetons.
- `/webssh/host` : Un client SSH basé sur le web qui vous permet de vous connecter à l'intérieur du conteneur où l'application s'exécute.
- Cet environnement **a accès au service de métadonnées** afin d'obtenir des jetons des identités gérées assignées.
- `/Env` : Obtenez des informations sur le système, les paramètres de l'application, les variables d'environnement, les chaînes de connexion et les en-têtes HTTP.
- `/wwwroot/` : Le répertoire racine de l'application web. Vous pouvez télécharger tous les fichiers d'ici.

## Sources

Les App Services permettent de télécharger le code sous forme de fichier zip par défaut, mais permettent également de se connecter à un service tiers et d'obtenir le code à partir de là.

- Les sources tierces actuellement prises en charge sont **Github** et **Bitbucket**.
- Vous pouvez obtenir les jetons d'authentification en exécutant `az rest --url "https://management.azure.com/providers/Microsoft.Web/sourcecontrols?api-version=2024-04-01"`.
- Azure configurera par défaut une **action Github** pour déployer le code sur le App Service chaque fois que le code est mis à jour.
- Il est également possible d'indiquer un **dépôt git distant** (avec nom d'utilisateur et mot de passe) pour obtenir le code à partir de là.
- Vous pouvez obtenir les informations d'identification du dépôt distant en exécutant `az webapp deployment source show --name <app-name> --resource-group <res-group>` ou `az rest --method POST --url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Web/sites/<app-name>/config/metadata/list?api-version=2022-03-01" --resource "https://management.azure.com"`.
- Il est également possible d'utiliser un **dépôt Azure**.
- Il est également possible de configurer un **dépôt git local**.
- Vous pouvez obtenir l'URL du dépôt git avec `az webapp deployment source show --name <app-name> --resource-group <res-group>` et ce sera l'URL SCM de l'application.
- Pour le cloner, vous aurez besoin des informations d'identification SCM que vous pouvez obtenir avec `az webapp deployment list-publishing-profiles --resource-group <res-group> -n <name>`.

## Webjobs

Les Azure WebJobs sont des **tâches d'arrière-plan qui s'exécutent dans l'environnement Azure App Service**. Ils permettent aux développeurs d'exécuter des scripts ou des programmes aux côtés de leurs applications web, facilitant ainsi la gestion des opérations asynchrones ou intensives en temps telles que le traitement de fichiers, la gestion de données ou les tâches planifiées.  
Il existe 2 types de web jobs :
- **Continu** : S'exécute indéfiniment dans une boucle et est déclenché dès sa création. Il est idéal pour les tâches nécessitant un traitement constant. Cependant, si l'application cesse de fonctionner parce que Always On est désactivé et qu'elle n'a pas reçu de demande au cours des 20 dernières minutes, le web job s'arrêtera également.
- **Déclenché** : S'exécute à la demande ou selon un calendrier. Il est mieux adapté aux tâches périodiques, telles que les mises à jour de données par lots ou les routines de maintenance.

Les webjobs sont très intéressants du point de vue des attaquants car ils pourraient être utilisés pour **exécuter du code** dans l'environnement et **escalader les privilèges** vers les identités gérées attachées.

De plus, il est toujours intéressant de vérifier les **journaux** générés par les Webjobs car ils pourraient contenir des **informations sensibles**.

### Slots

Les Azure App Service Slots sont utilisés pour **déployer différentes versions de l'application** sur le même App Service. Cela permet aux développeurs de tester de nouvelles fonctionnalités ou modifications dans un environnement séparé avant de les déployer dans l'environnement de production.

De plus, il est possible de diriger un **pourcentage du trafic** vers un slot spécifique, ce qui est utile pour **les tests A/B** et à des fins de porte dérobée.

### Azure Function Apps

Fondamentalement, **les Azure Function apps sont un sous-ensemble d'Azure App Service** dans le web et si vous allez à la console web et listez tous les services d'application ou exécutez `az webapp list` dans az cli, vous pourrez **voir les Function apps également listées ici**.

En fait, certaines des **fonctionnalités liées à la sécurité** que les App services utilisent (`webapp` dans az cli) sont **également utilisées par les Function apps**.

### Énumération

{{#tabs }}
{{#tab name="az" }}
```bash
# List webapps
az webapp list
## Less information
az webapp list --query "[].{hostName: defaultHostName, state: state, name: name, resourcegroup: resourceGroup}" -o table
## Get SCM URL of each webapp
az webapp list | grep '"name"' | grep "\.scm\." | awk '{print $2}' | sed 's/"//g'

# Get info about 1 app
az webapp show --name <name> --resource-group <res-group>

# Get instances of a webapp
az webapp list-instances --name <name> --resource-group <res-group>
## If you have enough perm you can go to the "consoleUrl" and access a shell inside the instance form the web

# Get access restrictions of an app
az webapp config access-restriction show --name <name> --resource-group <res-group>

# Remove access restrictions
az webapp config access-restriction remove --resource-group <res-group> -n <name> --rule-name <rule-name>

# Get connection strings of a webapp
az webapp config connection-string list --name <name> --resource-group <res-group>

# Get appsettings of an app
az webapp config appsettings list --name <name> --resource-group <res-group>

# Get SCM and FTP credentials
az webapp deployment list-publishing-profiles --name <name> --resource-group <res-group>

# Get configured Auth information
az webapp auth show --name <app-name> --resource-group <res-group>

# Get backups of a webapp
az webapp config backup list --webapp-name <name> --resource-group <res-group>

# Get backups scheduled for a webapp
az webapp config backup show --webapp-name <name> --resource-group <res-group>

# Get snapshots
az webapp config snapshot list --resource-group <res-group> -n <name>

# Restore snapshot
az webapp config snapshot restore -g <res-group> -n <name> --time 2018-12-11T23:34:16.8388367

# Get slots
az webapp deployment slot list --name <AppName> --resource-group <ResourceGroupName> --output table
az webapp show --slot <SlotName> --name <AppName> --resource-group <ResourceGroupName>

# Get traffic-routing
az webapp traffic-routing show --name <AppName> --resource-group <ResourceGroupName>

# Get used container by the app
az webapp config container show --name <name> --resource-group <res-group>

# Get storage account configurations of a webapp
az webapp config storage-account list --name <name> --resource-group <res-group>

# Get configured container (if any) in the webapp, it could contain credentials
az webapp config container show --name <name> --resource-group <res-group>

# Get Webjobs
az webapp webjob continuous list --resource-group <res-group> --name <app-name>
az webapp webjob triggered list --resource-group <res-group> --name <app-name>

# Read webjobs logs with Azure permissions
az rest --method GET --url "<SCM-URL>/vfs/data/jobs/<continuous | triggered>/rev5/job_log.txt"  --resource "https://management.azure.com/"
az rest --method GET --url "https://lol-b5fyaeceh4e9dce0.scm.canadacentral-01.azurewebsites.net/vfs/data/jobs/continuous/rev5/job_log.txt"  --resource "https://management.azure.com/"

# Read webjobs logs with SCM credentials
curl "https://windowsapptesting-ckbrg3f0hyc8fkgp.scm.canadacentral-01.azurewebsites.net/vfs/data/jobs/continuous/lala/job_log.txt" \
--user '<username>:<password>' -v

# Get connections of a webapp
az webapp conection list --name <name> --resource-group <res-group>

# Get hybrid-connections of a webapp
az webapp hybrid-connections list --name <name> --resource-group <res-group>
```
{{#endtab }}

{{#tab name="Az Powershell" }}
```powershell
# Get App Services and Function Apps
Get-AzWebApp
# Get only App Services
Get-AzWebApp | ?{$_.Kind -notmatch "functionapp"}
```
{{#endtab }}

{{#tab name="az get all" }}
```bash
#!/bin/bash

# Get all App Service and Function Apps

# Define Azure subscription ID
azure_subscription="your_subscription_id"

# Log in to Azure
az login

# Select Azure subscription
az account set --subscription $azure_subscription

# Get all App Services in the specified subscription
list_app_services=$(az appservice list --query "[].{appServiceName: name, group: resourceGroup}" -o tsv)

# Iterate over each App Service
echo "$list_app_services" | while IFS=$'\t' read -r appServiceName group; do
# Get the type of the App Service
service_type=$(az appservice show --name $appServiceName --resource-group $group --query "kind" -o tsv)

# Check if it is a Function App and print its name
if [ "$service_type" == "functionapp" ]; then
echo "Function App Name: $appServiceName"
fi
done
```
{{#endtab }}
{{#endtabs }}

#### Obtenir des identifiants et accéder au code de l'application web
```bash
# Get connection strings that could contain credentials (with DBs for example)
az webapp config connection-string list --name <name> --resource-group <res-group>
## Check how to use the DBs connection strings in the SQL page

# Get credentials to access the code and DB credentials if configured.
az webapp deployment list-publishing-profiles --resource-group <res-group> -n <name>


# Get git URL to access the code
az webapp deployment source config-local-git --resource-group <res-group> -n <name>

# Access/Modify the code via git
git clone 'https://<username>:<password>@name.scm.azurewebsites.net/repo-name.git'
## In my case the username was: $nameofthewebapp and the password some random chars
## If you change the code and do a push, the app is automatically redeployed
```
{{#ref}}
../az-privilege-escalation/az-app-services-privesc.md
{{#endref}}

## Exemples pour générer des applications Web

### Python depuis local

Ce tutoriel est basé sur celui de [https://learn.microsoft.com/en-us/azure/app-service/quickstart-python](https://learn.microsoft.com/en-us/azure/app-service/quickstart-python?tabs=flask%2Cwindows%2Cazure-cli%2Cazure-cli-deploy%2Cdeploy-instructions-azportal%2Cterminal-bash%2Cdeploy-instructions-zip-azcli).
```bash
# Clone repository
git clone https://github.com/Azure-Samples/msdocs-python-flask-webapp-quickstart
cd msdocs-python-flask-webapp-quickstart

# Create webapp from this code
az webapp up --runtime PYTHON:3.9 --sku B1 --logs
```
Se connecter au portail SCM ou se connecter via FTP permet de voir dans `/wwwroot` le fichier compressé `output.tar.gz` qui contient le code de l'application web.

> [!TIP]
> Se connecter simplement via FTP et modifier le fichier `output.tar.gz` ne suffit pas à changer le code exécuté par l'application web.

**Un attaquant pourrait télécharger ce fichier, le modifier et le télécharger à nouveau pour exécuter du code arbitraire dans l'application web.**

### Python depuis Github

Ce tutoriel est basé sur le précédent mais utilise un dépôt Github.

1. Forkez le dépôt msdocs-python-flask-webapp-quickstart dans votre compte Github.
2. Créez une nouvelle application Web Python dans Azure.
3. Dans `Deployment Center`, changez la source, connectez-vous avec Github, sélectionnez le dépôt forké et cliquez sur `Save`.

Comme dans le cas précédent, se connecter au portail SCM ou se connecter via FTP permet de voir dans `/wwwroot` le fichier compressé `output.tar.gz` qui contient le code de l'application web.

> [!TIP]
> Se connecter simplement via FTP et modifier le fichier `output.tar.gz` et relancer un déploiement ne suffit pas à changer le code exécuté par l'application web.


## Références

- [https://learn.microsoft.com/en-in/azure/app-service/overview](https://learn.microsoft.com/en-in/azure/app-service/overview)

{{#include ../../../banners/hacktricks-training.md}}
