# Az - Service Bus Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Service Bus

Für weitere Informationen siehe:

{{#ref}}
../az-services/az-servicebus-enum.md
{{#endref}}

### Microsoft.ServiceBus/namespaces/authorizationrules/listKeys/action ODER Microsoft.ServiceBus/namespaces/authorizationrules/regenerateKeys/action

Diese Berechtigungen ermöglichen es Ihnen, die Schlüssel für lokale Autorisierungsregeln innerhalb eines Service Bus-Namensraums abzurufen oder zu regenerieren. Mit diesen Schlüsseln ist es möglich, sich als der Service Bus-Namensraum zu authentifizieren, was es Ihnen ermöglicht, Nachrichten an jede Warteschlange oder jedes Thema zu senden, Nachrichten von jeder Warteschlange oder jedem Abonnement zu empfangen oder potenziell mit dem System auf eine Weise zu interagieren, die den Betrieb stören, gültige Benutzer impersonieren oder schädliche Daten in den Nachrichtenworkflow injizieren könnte.

Beachten Sie, dass die **`RootManageSharedAccessKey`-Regel standardmäßig die volle Kontrolle** über den Service Bus-Namensraum hat und von der `az`-CLI verwendet wird. Es können jedoch auch andere Regeln mit anderen Schlüsselwerten existieren.
```bash
# List keys
az servicebus namespace authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --authorization-rule-name RootManageSharedAccessKey [--authorization-rule-name RootManageSharedAccessKey]

# Regenerate keys
az servicebus namespace authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> [--authorization-rule-name RootManageSharedAccessKey]
```
### Microsoft.ServiceBus/namespaces/AuthorizationRules/write

Mit dieser Berechtigung ist es möglich, **eine neue Autorisierungsregel** mit allen Berechtigungen und eigenen Schlüsseln zu erstellen:
```bash
az servicebus namespace authorization-rule create --authorization-rule-name "myRule" --namespace-name mynamespacespdemo --resource-group Resource_Group_1 --rights Manage Listen Send
```
>[!WARNING]
>Dieser Befehl gibt keine Schlüssel zurück, daher müssen Sie diese mit den vorherigen Befehlen (und Berechtigungen) abrufen, um die Berechtigungen zu eskalieren.

Darüber hinaus ist es mit diesem Befehl (und `Microsoft.ServiceBus/namespaces/authorizationRules/read`) möglich, wenn Sie diese Aktion über die Azure CLI ausführen, eine vorhandene Autorisierungsregel zu aktualisieren und ihr mehr Berechtigungen zu geben (falls sie einige fehlten) mit dem folgenden Befehl:
```bash
az servicebus namespace authorization-rule update \
--resource-group <MyResourceGroup> \
--namespace-name <MyNamespace> \
--name RootManageSharedAccessKey \
--rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action ODER Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action

Spezifische Themen und Warteschlangen innerhalb eines Service Bus-Namensraums können eigene Autorisierungsregeln haben, die verwendet werden können, um den Zugriff auf die Entität zu steuern. Durch das Vorhandensein dieser Berechtigungen können Sie **die Schlüssel für diese lokalen Autorisierungsregeln abrufen oder regenerieren**, wodurch Sie sich als die Entität authentifizieren und potenziell Nachrichten senden oder empfangen, Abonnements verwalten oder mit dem System auf eine Weise interagieren können, die den Betrieb stören, gültige Benutzer impersonieren oder schädliche Daten in den Messaging-Workflow injizieren könnte.
```bash
# List keys (topics)
az servicebus topic authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# Regenerate keys (topics)
az servicebus topic authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# List keys (queues)
az servicebus queue authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>

# Regenerate keys (queues)
az servicebus queue authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/write

Mit dieser Berechtigung ist es möglich, **eine neue Autorisierungsregel** mit allen Berechtigungen und eigenen Schlüsseln zu erstellen:
```bash
# In a topic
az servicebus topic authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
>[!WARNING]
>Dieser Befehl gibt keine Schlüssel zurück, daher müssen Sie diese mit den vorherigen Befehlen (und Berechtigungen) abrufen, um die Berechtigungen zu erhöhen.

Darüber hinaus ist es mit diesem Befehl (und `Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/read`), wenn Sie diese Aktion über die Azure CLI ausführen, möglich, eine vorhandene Autorisierungsregel zu aktualisieren und ihr mehr Berechtigungen zu geben (falls sie einige fehlten) mit dem folgenden Befehl:
```bash
# In a topic
az servicebus topic authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/write (& Microsoft.ServiceBus/namespaces/read, wenn az cli verwendet wird)

Mit diesen Berechtigungen **kann ein Angreifer die "lokale Authentifizierung" wieder aktivieren** mit dem folgenden Befehl, und daher werden alle Schlüssel aus den freigegebenen Richtlinien funktionieren.
```bash
az servicebus namespace update --disable-local-auth false -n <namespace-name> --resource-group <res-group>
```
### Nachrichten mit Schlüsseln senden (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action ODER Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Sie können die `PrimaryConnectionString` abrufen, die als Anmeldeinformation für den Service Bus-Namespace fungiert. Mit dieser Verbindungszeichenfolge können Sie sich vollständig als der Service Bus-Namespace authentifizieren, was es Ihnen ermöglicht, Nachrichten an jede Warteschlange oder jedes Thema zu senden und potenziell mit dem System auf eine Weise zu interagieren, die den Betrieb stören, gültige Benutzer impersonieren oder bösartige Daten in den Nachrichtenworkflow injizieren könnte.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage

# Constants
NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"

# Function to send a single message to a Service Bus topic
async def send_individual_message(publisher):
# Prepare a single message with updated content
single_message = ServiceBusMessage("Hacktricks-Training: Single Item")
# Send the message to the topic
await publisher.send_messages(single_message)
print("Sent a single message containing 'Hacktricks-Training'")

# Function to send multiple messages to a Service Bus topic
async def send_multiple_messages(publisher):
# Generate a collection of messages with updated content
message_list = [ServiceBusMessage(f"Hacktricks-Training: Item {i+1} in list") for i in range(5)]
# Send the entire collection of messages to the topic
await publisher.send_messages(message_list)
print("Sent a list of 5 messages containing 'Hacktricks-Training'")

# Function to send a grouped batch of messages to a Service Bus topic
async def send_grouped_messages(publisher):
# Send a grouped batch of messages with updated content
async with publisher:
grouped_message_batch = await publisher.create_message_batch()
for i in range(10):
try:
# Append a message to the batch with updated content
grouped_message_batch.add_message(ServiceBusMessage(f"Hacktricks-Training: Item {i+1}"))
except ValueError:
# If batch reaches its size limit, handle by creating another batch
break
# Dispatch the batch of messages to the topic
await publisher.send_messages(grouped_message_batch)
print("Sent a batch of 10 messages containing 'Hacktricks-Training'")

# Main function to execute all tasks
async def execute():
# Instantiate the Service Bus client with the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as sb_client:
# Create a topic sender for dispatching messages to the topic
publisher = sb_client.get_topic_sender(topic_name=TOPIC_NAME)
async with publisher:
# Send a single message
await send_individual_message(publisher)
# Send multiple messages
await send_multiple_messages(publisher)
# Send a batch of messages
await send_grouped_messages(publisher)

# Run the asynchronous execution
asyncio.run(execute())
print("Messages Sent")
print("----------------------------")

```
### Empfangen mit Schlüsseln (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action ODER Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Sie können die PrimaryConnectionString abrufen, die als Anmeldeinformation für den Service Bus-Namespace dient. Mit dieser Verbindungszeichenfolge können Sie Nachrichten aus jeder Warteschlange oder jedem Abonnement innerhalb des Namensraums empfangen, was den Zugriff auf potenziell sensible oder kritische Daten ermöglicht, Datenexfiltration ermöglicht oder die Nachrichtenverarbeitung und Anwendungsabläufe stört.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient

NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"
SUBSCRIPTION_NAME = "<TOPIC_SUBSCRIPTION_NAME>" #Topic Subscription

# Function to receive and process messages from a Service Bus subscription
async def receive_and_process_messages():
# Create a Service Bus client using the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as servicebus_client:

# Get the Subscription Receiver object for the specified topic and subscription
receiver = servicebus_client.get_subscription_receiver(
topic_name=TOPIC_NAME,
subscription_name=SUBSCRIPTION_NAME,
max_wait_time=5
)

async with receiver:
# Receive messages with a defined maximum wait time and count
received_msgs = await receiver.receive_messages(
max_wait_time=5,
max_message_count=20
)
for msg in received_msgs:
print("Received: " + str(msg))
# Complete the message to remove it from the subscription
await receiver.complete_message(msg)

# Run the asynchronous message processing function
asyncio.run(receive_and_process_messages())
print("Message Receiving Completed")
print("----------------------------")
```
## Referenzen

- https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues
- https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api
- https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes
- https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless
- https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus

{{#include ../../../banners/hacktricks-training.md}}
