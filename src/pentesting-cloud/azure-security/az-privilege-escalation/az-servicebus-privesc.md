# Az - Service Bus Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Service Bus

Für weitere Informationen siehe:

{{#ref}}
../az-services/az-servicebus.md
{{#endref}}

### Microsoft.ServiceBus/namespaces/authorizationrules/listKeys/action ODER Microsoft.ServiceBus/namespaces/authorizationrules/regenerateKeys/action

Diese Berechtigungen ermöglichen es Ihnen, die Schlüssel für lokale Autorisierungsregeln innerhalb eines Service Bus-Namensraums abzurufen oder zu regenerieren. Mit diesen Schlüsseln ist es möglich, sich als der Service Bus-Namensraum zu authentifizieren, was es Ihnen ermöglicht, Nachrichten an jede Warteschlange oder jedes Thema zu senden, Nachrichten von jeder Warteschlange oder jedem Abonnement zu empfangen oder potenziell mit dem System auf eine Weise zu interagieren, die den Betrieb stören, gültige Benutzer impersonieren oder schädliche Daten in den Nachrichtenworkflow injizieren könnte.

Beachten Sie, dass die **`RootManageSharedAccessKey`-Regel standardmäßig die volle Kontrolle** über den Service Bus-Namensraum hat und von der `az`-CLI verwendet wird. Es können jedoch auch andere Regeln mit anderen Schlüsselwerten existieren.
```bash
# List keys
az servicebus namespace authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --authorization-rule-name RootManageSharedAccessKey [--authorization-rule-name RootManageSharedAccessKey]

# Regenerate keys
az servicebus namespace authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> [--authorization-rule-name RootManageSharedAccessKey]
```
### Microsoft.ServiceBus/namespaces/AuthorizationRules/write

Mit dieser Berechtigung ist es möglich, **eine neue Autorisierungsregel** mit allen Berechtigungen und eigenen Schlüsseln zu erstellen mit:
```bash
az servicebus namespace authorization-rule create --authorization-rule-name "myRule" --namespace-name mynamespacespdemo --resource-group Resource_Group_1 --rights Manage Listen Send
```
>[!WARNING]
>Dieser Befehl gibt keine Schlüssel zurück, daher müssen Sie diese mit den vorherigen Befehlen (und Berechtigungen) abrufen, um die Berechtigungen zu erhöhen.

Darüber hinaus ist es mit diesem Befehl (und `Microsoft.ServiceBus/namespaces/authorizationRules/read`) möglich, wenn Sie diese Aktion über die Azure CLI ausführen, eine vorhandene Autorisierungsregel zu aktualisieren und ihr mehr Berechtigungen zu geben (falls sie einige fehlten) mit dem folgenden Befehl:
```bash
az servicebus namespace authorization-rule update \
--resource-group <MyResourceGroup> \
--namespace-name <MyNamespace> \
--name RootManageSharedAccessKey \
--rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action ODER Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action

Spezifische Themen und Warteschlangen innerhalb eines Service Bus-Namensraums können eigene Autorisierungsregeln haben, die verwendet werden können, um den Zugriff auf die Entität zu steuern. Durch das Vorhandensein dieser Berechtigungen können Sie **die Schlüssel für diese lokalen Autorisierungsregeln abrufen oder regenerieren**, wodurch Sie sich als die Entität authentifizieren und potenziell Nachrichten senden oder empfangen, Abonnements verwalten oder mit dem System auf eine Weise interagieren können, die den Betrieb stören, gültige Benutzer impersonieren oder schädliche Daten in den Nachrichtenworkflow injizieren könnte.
```bash
# List keys (topics)
az servicebus topic authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# Regenerate keys (topics)
az servicebus topic authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# List keys (queues)
az servicebus queue authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>

# Regenerate keys (queues)
az servicebus queue authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/write

Mit dieser Berechtigung ist es möglich, **eine neue Autorisierungsregel** mit allen Berechtigungen und eigenen Schlüsseln zu erstellen mit:
```bash
# In a topic
az servicebus topic authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
>[!WARNING]
>Dieser Befehl gibt keine Schlüssel zurück, daher müssen Sie diese mit den vorherigen Befehlen (und Berechtigungen) abrufen, um die Berechtigungen zu erhöhen.

Darüber hinaus ist es mit diesem Befehl (und `Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/read`), wenn Sie diese Aktion über die Azure CLI ausführen, möglich, eine vorhandene Autorisierungsregel zu aktualisieren und ihr mehr Berechtigungen zu geben (falls sie einige fehlten) mit dem folgenden Befehl:
```bash
# In a topic
az servicebus topic authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/write (& Microsoft.ServiceBus/namespaces/read, wenn az cli verwendet wird)

Mit diesen Berechtigungen **kann ein Angreifer die "lokale Authentifizierung" wieder aktivieren** mit dem folgenden Befehl, und daher werden alle Schlüssel aus den freigegebenen Richtlinien funktionieren.
```bash
az servicebus namespace update --disable-local-auth false -n <namespace-name> --resource-group <res-group>
```
### Nachrichten mit Schlüsseln senden (Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action ODER Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action)

Sie können die `PrimaryConnectionString` abrufen, die als Anmeldeinformation für den Service Bus-Namespace fungiert. Mit dieser Verbindungszeichenfolge können Sie sich vollständig als der Service Bus-Namespace authentifizieren, was es Ihnen ermöglicht, Nachrichten an jede Warteschlange oder jedes Thema zu senden und potenziell mit dem System auf eine Weise zu interagieren, die den Betrieb stören, gültige Benutzer impersonieren oder bösartige Daten in den Nachrichtenworkflow injizieren könnte. Diese Methode funktioniert, wenn `--disable-local-auth` auf false gesetzt ist (d.h. lokale Authentifizierung aktiviert ist).
```python
import asyncio
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage
# pip install azure-servicebus

NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_OR_QUEUE_NAME = "<TOPIC_OR_QUEUE_NAME>"

async def send_message():
async with ServiceBusClient.from_connection_string(NAMESPACE_CONNECTION_STR) as client:
async with client.get_topic_sender(topic_name=TOPIC_OR_QUEUE_NAME) as sender:
await sender.send_messages(ServiceBusMessage("Hacktricks-Training: Single Item"))
print("Sent message")

asyncio.run(send_message())
```
Zusätzlich können Sie Nachrichten mit az rest senden. In diesem Fall müssen Sie ein SAS-Token generieren, um es zu verwenden.
```python
import time, urllib.parse, hmac, hashlib, base64

def generate_sas_token(uri, key_name, key, expiry_in_seconds=3600):
expiry = int(time.time() + expiry_in_seconds)
string_to_sign = urllib.parse.quote_plus(uri) + "\n" + str(expiry)
signed_hmac_sha256 = hmac.new(key.encode('utf-8'), string_to_sign.encode('utf-8'), hashlib.sha256).digest()
signature = urllib.parse.quote_plus(base64.b64encode(signed_hmac_sha256))
token = f"SharedAccessSignature sr={urllib.parse.quote_plus(uri)}&sig={signature}&se={expiry}&skn={key_name}"
return token

# Replace these with your actual values
resource_uri = "https://<namespace>.servicebus.windows.net/<queue_or_topic>"
key_name = "<SharedKeyName>"
primary_key = "<PrimaryKey>"

sas_token = generate_sas_token(resource_uri, key_name, primary_key)
print(sas_token)
```

```bash
az rest --method post \
--uri "https://<NAMESPACE>.servicebus.windows.net/<queue>/messages" \
--headers "Content-Type=application/atom+xml;type=entry;charset=utf-8" "Authorization=SharedAccessSignature sr=https%3A%2F%2F<NAMESPACE>.servicebus.windows.net%2F<TOPIC_OR_QUEUE_NAME>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>" \
--body "<MESSAGE_BODY>"

```
### Receive with keys (Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action OR Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action)

Sie können den PrimaryConnectionString abrufen, der als Anmeldeinformation für den Service Bus-Namespace dient. Mit diesem Verbindungsstring können Sie Nachrichten aus jeder Warteschlange oder Abonnements innerhalb des Namensraums empfangen, was den Zugriff auf potenziell sensible oder kritische Daten ermöglicht, Datenexfiltration ermöglicht oder die Nachrichtenverarbeitung und Anwendungsabläufe stört. Diese Methode funktioniert, wenn `--disable-local-auth` auf false gesetzt ist.
```python
import asyncio
from azure.servicebus.aio import ServiceBusClient
# pip install azure-servicebus

CONN_STR = "<PrimaryConnectionString>"
QUEUE = "<QUEUE_NAME>"

# For topics/subscriptions, you would use:
# TOPIC = "<TOPIC_NAME>"
# SUBSCRIPTION = "<TOPIC_SUBSCRIPTION_NAME>"

async def receive():
async with ServiceBusClient.from_connection_string(CONN_STR) as client:
# For a queue receiver:
async with client.get_queue_receiver(queue_name=QUEUE, max_wait_time=5) as receiver:
msgs = await receiver.receive_messages(max_wait_time=5, max_message_count=20)
for msg in msgs:
print("Received:", msg)
await receiver.complete_message(msg)

# For a topic/subscription receiver (commented out):
# async with client.get_subscription_receiver(topic_name=TOPIC, subscription_name=SUBSCRIPTION, max_wait_time=5) as receiver:
#     msgs = await receiver.receive_messages(max_wait_time=5, max_message_count=20)
#     for msg in msgs:
#         print("Received:", msg)
#         await receiver.complete_message(msg)

asyncio.run(receive())
print("Done receiving messages")
```
Zusätzlich können Sie Nachrichten mit az rest senden. In diesem Fall müssen Sie ein SAS-Token generieren, um es zu verwenden.
```python
import time, urllib.parse, hmac, hashlib, base64

def generate_sas_token(uri, key_name, key, expiry_in_seconds=3600):
expiry = int(time.time() + expiry_in_seconds)
string_to_sign = urllib.parse.quote_plus(uri) + "\n" + str(expiry)
signature = urllib.parse.quote_plus(base64.b64encode(
hmac.new(key.encode('utf-8'), string_to_sign.encode('utf-8'), hashlib.sha256).digest()
))
token = f"SharedAccessSignature sr={urllib.parse.quote_plus(uri)}&sig={signature}&se={expiry}&skn={key_name}"
return token

# Example usage:
resource_uri = "https://<namespace>.servicebus.windows.net/queue"  # For queue
# resource_uri = "https://<namespace>.servicebus.windows.net/<topic>/subscriptions/<subscription>"  # For topic subscription
sas_token = generate_sas_token(resource_uri, "<KEYNAME>", "<PRIMARY_KEY>")
print(sas_token)

```
Für eine Warteschlange können Sie die Nachricht abrufen oder einen Blick darauf werfen (das Abrufen von Nachrichten würde sie entfernen, während das Blicken dies nicht tut):
```bash
#Get a message
az rest --method post \
--uri "https://<NAMESPACE>.servicebus.windows.net/<QUEUE>/messages/head?timeout=60" \
--headers "Content-Type=application/atom+xml;type=entry;charset=utf-8" "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"

#Peek a message
az rest --method get \
--uri "https://<NAMESPACE>.servicebus.windows.net/<QUEUE>/messages/head?peekonly=true&timeout=60" \
--headers "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"

#You can select the meesage changing the field PreviousSequenceNumber
az rest --method get \
--uri "https://<NAMESPACE>.servicebus.windows.net/<ENTITY>/messages?timeout=60&PreviousSequenceNumber=<LAST_SEQUENCE_NUMBER>&api-version=2017-04" \
--headers "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"
```
Bitte geben Sie den Text an, den Sie übersetzen möchten.
```bash
#Get a message
az rest --method post \
--uri "https://<NAMESPACE>.servicebus.windows.net/<TOPIC>/subscriptions/<SUBSCRIPTION>/messages/head?timeout=60" \
--headers "Content-Type=application/atom+xml;type=entry;charset=utf-8" "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"

#Peek a message
az rest --method get \
--uri "https://<NAMESPACE>.servicebus.windows.net/<TOPIC>/subscriptions/<SUBSCRIPTION>/messages/head?timeout=60&api-version=2017-04" \
--headers "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"

#You can select the meesage changing the field PreviousSequenceNumber
az rest --method get \
--uri "https://<NAMESPACE>.servicebus.windows.net/<TOPIC>/subscriptions/<SUBSCRIPTION>/messages?timeout=60&PreviousSequenceNumber=<LAST_SEQUENCE_NUMBER>&api-version=2017-04" \
--headers "Authorization=SharedAccessSignature sr=<URI_ENCODED_RESOURCE>&sig=<SIGNATURE>&se=<EXPIRY>&skn=<KEYNAME>"
```
### Nachrichten senden. DataActions: `Microsoft.ServiceBus/namespaces/messages/send/action`

Sie können diese Berechtigungen verwenden, um Nachrichten zu senden, selbst wenn `--disable-local-auth` auf true gesetzt ist.
```python
import asyncio
from azure.identity.aio import DefaultAzureCredential
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage
# pip install azure-servicebus

NS = "<namespace>.servicebus.windows.net"  # Your namespace
QUEUE_OR_TOPIC = "<QUEUE_OR_TOPIC>"        # Your queue name

async def run():
credential = DefaultAzureCredential()
async with ServiceBusClient(fully_qualified_namespace=NS, credential=credential) as client:
#async with client.get_topic_sender(topic_name=TOPIC) as sender: # Use this to send the message to a topic
async with client.get_queue_sender(queue_name=QUEUE) as sender:
await sender.send_messages(ServiceBusMessage("Single Message"))
print("Sent a single message")
await credential.close()

if __name__ == "__main__":
asyncio.run(run())
```
### Nachrichten empfangen. DataActions: `Microsoft.ServiceBus/namespaces/messages/receive/action`

Sie können diese Berechtigungen verwenden, um Nachrichten zu empfangen, selbst wenn `--disable-local-auth` auf true gesetzt ist.
```python
import asyncio
from azure.identity.aio import DefaultAzureCredential
from azure.servicebus.aio import ServiceBusClient
# pip install azure-servicebus

NS = "<namespace>.servicebus.windows.net"
QUEUE = "<QUEUE>"

# For a topic subscription, uncomment and set these values:
# TOPIC = "<TOPIC>"
# SUBSCRIPTION = "<SUBSCRIPTION>"

async def run():
credential = DefaultAzureCredential()
async with ServiceBusClient(fully_qualified_namespace=NS, credential=credential) as client:
# Receiving from a queue:
async with client.get_queue_receiver(queue_name=QUEUE, max_wait_time=5) as receiver:
async for msg in receiver:
print("Received from Queue:", msg)
await receiver.complete_message(msg)

# To receive from a topic subscription, uncomment the code below and comment out the queue receiver above:
# async with client.get_subscription_receiver(topic_name=TOPIC, subscription_name=SUBSCRIPTION, max_wait_time=5) as receiver:
#     async for msg in receiver:
#         print("Received from Topic Subscription:", msg)
#         await receiver.complete_message(msg)

await credential.close()

asyncio.run(run())
print("Done receiving messages")
```
## Referenzen

- [https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues](https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues)
- [https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api](https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api)
- [https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes](https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes)
- [https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless)
- [https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus](https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus)

{{#include ../../../banners/hacktricks-training.md}}
