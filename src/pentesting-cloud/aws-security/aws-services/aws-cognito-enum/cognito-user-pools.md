# Cognito User Pools

{{#include ../../../../banners/hacktricks-training.md}}

## Grundinformationen

Ein Benutzerpool ist ein Benutzerdirectory in Amazon Cognito. Mit einem Benutzerpool können sich Ihre Benutzer **in Ihre Web- oder mobile App** über Amazon Cognito **einloggen** oder über einen **drittanbieter** Identitätsanbieter (IdP) **föderieren**. Egal, ob sich Ihre Benutzer direkt oder über einen Drittanbieter einloggen, alle Mitglieder des Benutzerpools haben ein Verzeichnisprofil, auf das Sie über ein SDK zugreifen können.

Benutzerpools bieten:

- Anmelde- und Registrierungsdienste.
- Eine integrierte, anpassbare Web-Benutzeroberfläche, um Benutzer anzumelden.
- Soziale Anmeldungen mit Facebook, Google, Login mit Amazon und Anmelden mit Apple sowie über SAML- und OIDC-Identitätsanbieter aus Ihrem Benutzerpool.
- Verwaltung des Benutzerdirectorys und Benutzerprofile.
- Sicherheitsfunktionen wie Multi-Faktor-Authentifizierung (MFA), Überprüfungen auf kompromittierte Anmeldeinformationen, Schutz vor Kontoübernahme sowie Telefon- und E-Mail-Verifizierung.
- Angepasste Workflows und Benutzermigration durch AWS Lambda-Trigger.

**Quellcode** von Anwendungen enthält normalerweise auch die **Benutzerpool-ID** und die **Client-Anwendungs-ID** (und manchmal das **Anwendungsgeheimnis**?), die benötigt werden, damit sich ein **Benutzer** in einen Cognito-Benutzerpool **einloggen** kann.

### Potenzielle Angriffe

- **Registrierung**: Standardmäßig kann sich ein Benutzer selbst registrieren, sodass er einen Benutzer für sich selbst erstellen könnte.
- **Benutzerenumeration**: Die Registrierungsfunktionalität kann verwendet werden, um Benutzernamen zu finden, die bereits existieren. Diese Informationen können für den Brute-Force-Angriff nützlich sein.
- **Login-Brute-Force**: Im Abschnitt [**Authentifizierung**](cognito-user-pools.md#authentication) finden Sie alle **Methoden**, die ein Benutzer hat, um sich **einzuloggen**. Sie könnten versuchen, diese **gültigen Anmeldeinformationen** zu brute-forcen.

### Tools für Pentesting

- [Pacu](https://github.com/RhinoSecurityLabs/pacu) enthält jetzt die Module `cognito__enum` und `cognito__attack`, die die Enumeration aller Cognito-Ressourcen in einem Konto automatisieren und schwache Konfigurationen, Benutzerattribute, die für die Zugriffskontrolle verwendet werden, usw. kennzeichnen. Außerdem automatisieren sie die Benutzererstellung (einschließlich MFA-Unterstützung) und die Privilegieneskalation basierend auf modifizierbaren benutzerdefinierten Attributen, verwendbaren Identitätspool-Anmeldeinformationen, übernehmbaren Rollen in ID-Token usw.\
Für eine Beschreibung der Funktionen der Module siehe Teil 2 des [Blogbeitrags](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Für Installationsanweisungen siehe die Hauptseite [Pacu](https://github.com/RhinoSecurityLabs/pacu).
```bash
# Run cognito__enum usage to gather all user pools, user pool clients, identity pools, users, etc. visible in the current AWS account
Pacu (new:test) > run cognito__enum

# cognito__attack usage to attempt user creation and all privesc vectors against a given identity pool and user pool client:
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
- [Cognito Scanner](https://github.com/padok-team/cognito-scanner) ist ein CLI-Tool in Python, das verschiedene Angriffe auf Cognito implementiert, einschließlich unerwünschter Kontoerstellung und Konto-Orakel. Weitere Informationen finden Sie [unter diesem Link](https://github.com/padok-team/cognito-scanner).
```bash
# Install
pip install cognito-scanner
# Run
cognito-scanner --help
```
- [CognitoAttributeEnum](https://github.com/punishell/CognitoAttributeEnum): Dieses Skript ermöglicht es, gültige Attribute für Benutzer aufzulisten.
```bash
python cognito-attribute-enu.py -client_id 16f1g98bfuj9i0g3f8be36kkrl
```
## Registrierung

User Pools erlaubt standardmäßig die **Registrierung neuer Benutzer**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Wenn sich jeder registrieren kann

Möglicherweise finden Sie einen Fehler, der Ihnen anzeigt, dass Sie **mehr Details** über den Benutzer bereitstellen müssen:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Sie können die benötigten Details mit einem JSON wie folgt bereitstellen:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Sie könnten diese Funktionalität auch verwenden, um **bestehende Benutzer aufzulisten.** Dies ist die Fehlermeldung, wenn ein Benutzer mit diesem Namen bereits existiert:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
> [!NOTE]
> Beachten Sie im vorherigen Befehl, wie die **benutzerdefinierten Attribute mit "custom:" beginnen**.\
> Wissen Sie auch, dass Sie bei der Registrierung **keine neuen benutzerdefinierten Attribute für den Benutzer erstellen können**. Sie können nur Werte für **Standardattribute** (auch wenn sie nicht erforderlich sind) und **angegebene benutzerdefinierte Attribute** angeben.

Oder um einfach zu testen, ob eine Client-ID existiert. Dies ist der Fehler, wenn die Client-ID nicht existiert:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Wenn nur der Administrator Benutzer registrieren kann

Sie werden diesen Fehler finden und Sie werden nicht in der Lage sein, Benutzer zu registrieren oder aufzulisten:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognito allows to **verify a new user by verifying his email or phone number**. Therefore, when creating a user usually you will be required at least the username and password and the **E-Mail und/oder Telefonnummer**. Just set one **die Sie kontrollieren** so you will receive the code to **verifizieren Sie Ihr** newly created user **Konto** like this:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
> [!WARNING]
> Auch wenn **es so aussieht, als könnte man dieselbe E-Mail** und Telefonnummer verwenden, wird Cognito bei der Verifizierung des erstellten Benutzers sich darüber beschweren, dass dieselben Informationen verwendet werden, und **wird die Verifizierung des Kontos nicht zulassen**.

### Privilegieneskalation / Aktualisierung von Attributen

Standardmäßig kann ein Benutzer **den Wert seiner Attribute ändern** mit etwas wie:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Benutzerdefinierte Attribut-Privesc

> [!CAUTION]
> Sie könnten **benutzerdefinierte Attribute** finden (wie `isAdmin`), da Sie standardmäßig **die Werte Ihrer eigenen Attribute ändern** können, könnten Sie in der Lage sein, **Privilegien zu eskalieren**, indem Sie den Wert selbst ändern!

#### E-Mail/Benutzername-Modifikation-Privesc

Sie können dies verwenden, um die **E-Mail und Telefonnummer** eines Benutzers zu **ändern**, aber selbst wenn das Konto als verifiziert bleibt, sind diese Attribute **im unverifizierten Status gesetzt** (Sie müssen sie erneut verifizieren).

> [!WARNING]
> Sie **werden sich nicht mit E-Mail oder Telefonnummer anmelden können**, bis Sie sie verifizieren, aber Sie werden sich **mit dem Benutzernamen anmelden können**.\
> Beachten Sie, dass selbst wenn die E-Mail geändert und nicht verifiziert wurde, sie im ID-Token im **`email`** **Feld** erscheinen wird und das Feld **`email_verified`** **falsch** sein wird, aber wenn die App **nicht überprüft**, könnten Sie **andere Benutzer impersonieren**.

> Darüber hinaus beachten Sie, dass Sie alles in das **`name`** Feld einfügen können, indem Sie das **name-Attribut** ändern. Wenn eine App aus irgendeinem Grund **dieses** Feld **anstatt des `email`** (oder eines anderen Attributs) überprüft, könnten Sie in der Lage sein, **andere Benutzer zu impersonieren**.

Wie auch immer, wenn Sie aus irgendeinem Grund Ihre E-Mail beispielsweise auf eine neue, auf die Sie zugreifen können, geändert haben, können Sie **die E-Mail mit dem Code bestätigen, den Sie an diese E-Mail-Adresse erhalten haben**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Verwenden Sie **`phone_number`** anstelle von **`email`**, um eine **neue Telefonnummer** zu ändern/zu verifizieren.

> [!NOTE]
> Der Administrator könnte auch die Option aktivieren, sich mit einem **benutzerspezifischen Benutzernamen** anzumelden. Beachten Sie, dass Sie diesen Wert nicht in **irgendeinen Benutzernamen oder bevorzugten Benutzernamen, der bereits verwendet wird**, ändern können, um einen anderen Benutzer zu impersonieren.

### Passwort wiederherstellen/ändern

Es ist möglich, ein Passwort nur **mit dem Benutzernamen** (oder E-Mail oder Telefon wird akzeptiert) wiederherzustellen, und der Zugriff darauf ist erforderlich, da ein Code dorthin gesendet wird:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
> [!NOTE]
> Die Antwort des Servers wird immer positiv sein, als ob der Benutzername existiert. Sie können diese Methode nicht verwenden, um Benutzer aufzulisten.

Mit dem Code können Sie das Passwort ändern mit:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Um das Passwort zu ändern, müssen Sie **das vorherige Passwort kennen**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentifizierung

Ein Benutzerpool unterstützt **verschiedene Möglichkeiten zur Authentifizierung**. Wenn Sie einen **Benutzernamen und ein Passwort** haben, werden auch **verschiedene Methoden** zum Anmelden unterstützt.\
Darüber hinaus werden, wenn ein Benutzer im Pool **3 Arten von Tokens vergeben**: Das **ID-Token**, das **Zugriffstoken** und das **Aktualisierungstoken**.

- [**ID-Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Es enthält Ansprüche über die **Identität des authentifizierten Benutzers**, wie `name`, `email` und `phone_number`. Das ID-Token kann auch verwendet werden, um **Benutzer zu Ihren Ressourcenservern oder Serveranwendungen zu authentifizieren**. Sie müssen die **Signatur** des ID-Tokens **überprüfen**, bevor Sie irgendwelche Ansprüche im ID-Token vertrauen können, wenn Sie es in externen Anwendungen verwenden.
- Das ID-Token ist das Token, das **die Attributwerte des Benutzers enthält**, sogar die benutzerdefinierten.
- [**Zugriffstoken**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Es enthält Ansprüche über den authentifizierten Benutzer, eine Liste der **Benutzergruppen** und eine Liste von Scopes. Der Zweck des Zugriffstokens ist es, **API-Operationen** im Kontext des Benutzers im Benutzerpool zu **autorisieren**. Zum Beispiel können Sie das Zugriffstoken verwenden, um **Ihrem Benutzer Zugriff** zu gewähren, um Benutzerattribute hinzuzufügen, zu ändern oder zu löschen.
- [**Aktualisierungstoken**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Mit Aktualisierungstokens können Sie **neue ID-Tokens und Zugriffstokens** für den Benutzer erhalten, bis das **Aktualisierungstoken ungültig** ist. Standardmäßig **läuft das Aktualisierungstoken 30 Tage nach** der Anmeldung Ihres Anwendungsbenutzers in Ihrem Benutzerpool ab. Wenn Sie eine Anwendung für Ihren Benutzerpool erstellen, können Sie die Ablaufzeit des Aktualisierungstokens der Anwendung auf **einen Wert zwischen 60 Minuten und 10 Jahren** festlegen.

### ADMIN_NO_SRP_AUTH & ADMIN_USER_PASSWORD_AUTH

Dies ist der Authentifizierungsfluss auf der Serverseite:

- Die serverseitige Anwendung ruft die **`AdminInitiateAuth` API-Operation** auf (anstatt `InitiateAuth`). Diese Operation erfordert AWS-Anmeldeinformationen mit Berechtigungen, die **`cognito-idp:AdminInitiateAuth`** und **`cognito-idp:AdminRespondToAuthChallenge`** umfassen. Die Operation gibt die erforderlichen Authentifizierungsparameter zurück.
- Nachdem die serverseitige Anwendung die **Authentifizierungsparameter** hat, ruft sie die **`AdminRespondToAuthChallenge` API-Operation** auf. Die `AdminRespondToAuthChallenge` API-Operation ist nur erfolgreich, wenn Sie AWS-Anmeldeinformationen bereitstellen.

Diese **Methode ist standardmäßig NICHT aktiviert**.

Um sich **anzumelden**, müssen Sie wissen:

- Benutzerpool-ID
- Client-ID
- Benutzername
- Passwort
- Client-Geheimnis (nur wenn die Anwendung so konfiguriert ist, dass sie ein Geheimnis verwendet)

> [!NOTE]
> Um mit dieser Methode **einloggen zu können**, muss die Anwendung die Anmeldung mit `ALLOW_ADMIN_USER_PASSWORD_AUTH` erlauben.\
> Darüber hinaus benötigen Sie zur Durchführung dieser Aktion Anmeldeinformationen mit den Berechtigungen **`cognito-idp:AdminInitiateAuth`** und **`cognito-idp:AdminRespondToAuthChallenge`**.
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code zum Einloggen</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_PASSWORD_AUTH

Diese Methode ist ein weiterer einfacher und **traditioneller Benutzer- und Passwort-Authentifizierungs**-Flow. Es wird empfohlen, eine **traditionelle** Authentifizierungsmethode **zu Cognito** zu **migrieren** und sie dann **deaktivieren** und stattdessen die **ALLOW_USER_SRP_AUTH**-Methode **zu verwenden** (da diese das Passwort niemals über das Netzwerk sendet).\
Diese **Methode ist standardmäßig NICHT aktiviert**.

Der Hauptunterschied zur **vorherigen Authentifizierungsmethode** im Code ist, dass Sie **die Benutzerpool-ID nicht kennen müssen** und dass Sie **keine zusätzlichen Berechtigungen** im Cognito-Benutzerpool benötigen.

Um sich **anzumelden**, müssen Sie wissen:

- client id
- username
- password
- client secret (nur wenn die App so konfiguriert ist, dass sie ein Secret verwendet)

> [!NOTE]
> Um sich mit dieser Methode **anmelden zu können**, muss die Anwendung die Anmeldung mit ALLOW_USER_PASSWORD_AUTH erlauben.
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python-Code zum Anmelden</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_SRP_AUTH

Dieses Szenario ist ähnlich wie das vorherige, aber **anstatt das Passwort** über das Netzwerk zu senden, wird eine **Herausforderungsauthentifizierung durchgeführt** (also kein Passwort, das selbst verschlüsselt durch das Netz navigiert).\
Diese **Methode ist standardmäßig aktiviert**.

Um sich **anzumelden**, müssen Sie wissen:

- Benutzerpool-ID
- Client-ID
- Benutzername
- Passwort
- Client-Geheimnis (nur wenn die App so konfiguriert ist, dass sie ein Geheimnis verwendet)

<details>

<summary>Code zur Anmeldung</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH_TOKEN_AUTH & REFRESH_TOKEN

Diese **Methode wird immer gültig sein** (sie kann nicht deaktiviert werden), aber Sie müssen ein gültiges Refresh-Token haben.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Code zum Aktualisieren</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM_AUTH

In diesem Fall wird die **Authentifizierung** durch die **Ausführung einer Lambda-Funktion** durchgeführt.

## Zusätzliche Sicherheit

### Erweiterte Sicherheit

Standardmäßig ist es deaktiviert, aber wenn es aktiviert ist, könnte Cognito in der Lage sein, **Kontenübernahmen zu erkennen**. Um die Wahrscheinlichkeit zu minimieren, sollten Sie sich von einem **Netzwerk innerhalb derselben Stadt anmelden, unter Verwendung desselben User Agents** (und IP, wenn möglich)**.**

### **MFA Gerät merken**

Wenn sich der Benutzer von demselben Gerät anmeldet, könnte die MFA umgangen werden. Versuchen Sie daher, sich mit demselben Browser und denselben Metadaten (IP?) anzumelden, um den MFA-Schutz zu umgehen.

## Benutzerpool-Gruppen IAM-Rollen

Es ist möglich, **Benutzer zu Benutzerpool**-Gruppen hinzuzufügen, die mit einer **IAM-Rolle** verbunden sind.\
Darüber hinaus können **Benutzer** mehreren Gruppen mit unterschiedlichen angehängten IAM-Rollen zugewiesen werden.

Beachten Sie, dass selbst wenn eine Gruppe innerhalb einer Gruppe mit einer angehängten IAM-Rolle ist, es erforderlich ist, dass der **Benutzerpool von einem Identitätspool vertraut wird** (und die Details dieses Identitätspools bekannt sind), um auf die IAM-Anmeldeinformationen dieser Gruppe zugreifen zu können.

Ein weiteres Erfordernis, um die **IAM-Rolle, die im IdToken angegeben ist**, zu erhalten, wenn ein Benutzer im Benutzerpool authentifiziert wird (`aws cognito-idp initiate-auth...`), ist, dass der **Identitätsanbieter** angeben muss, dass die **Rolle aus dem Token ausgewählt werden muss.**

<figure><img src="../../../../images/image (250).png" alt=""><figcaption></figcaption></figure>

Die **Rollen**, auf die ein Benutzer Zugriff hat, sind **im `IdToken`** enthalten, und ein Benutzer kann **auswählen, für welche Rolle er Anmeldeinformationen haben möchte** mit dem **`--custom-role-arn`** von `aws cognito-identity get-credentials-for-identity`.\
Wenn jedoch die **Standardoption** die **konfigurierte** ist (`use default role`), und Sie versuchen, auf eine Rolle aus dem IdToken zuzugreifen, erhalten Sie einen **Fehler** (deshalb ist die vorherige Konfiguration erforderlich):
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
> [!WARNING]
> Beachten Sie, dass die Rolle, die einer **User Pool Group** zugewiesen ist, **vom Identity Provider zugänglich sein muss**, der **dem User Pool vertraut** (da die IAM-Rolle **Sitzungscodes von ihm abgerufen werden**).
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{{#include ../../../../banners/hacktricks-training.md}}
