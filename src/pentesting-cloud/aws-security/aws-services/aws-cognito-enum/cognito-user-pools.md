# Cognito User Pools

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

एक उपयोगकर्ता पूल Amazon Cognito में एक उपयोगकर्ता निर्देशिका है। एक उपयोगकर्ता पूल के साथ, आपके उपयोगकर्ता **Amazon Cognito के माध्यम से आपके वेब या मोबाइल ऐप में साइन इन कर सकते हैं**, **या एक तृतीय-पक्ष** पहचान प्रदाता (IdP) के माध्यम से संघनित कर सकते हैं। चाहे आपके उपयोगकर्ता सीधे साइन इन करें या एक तृतीय पक्ष के माध्यम से, उपयोगकर्ता पूल के सभी सदस्यों के पास एक निर्देशिका प्रोफ़ाइल होती है जिसे आप एक SDK के माध्यम से एक्सेस कर सकते हैं।

उपयोगकर्ता पूल प्रदान करते हैं:

- साइन-अप और साइन-इन सेवाएँ।
- उपयोगकर्ताओं को साइन इन करने के लिए एक अंतर्निहित, अनुकूलन योग्य वेब UI।
- Facebook, Google, Amazon के साथ लॉगिन, और Apple के साथ साइन इन, और आपके उपयोगकर्ता पूल से SAML और OIDC पहचान प्रदाताओं के माध्यम से सामाजिक साइन-इन।
- उपयोगकर्ता निर्देशिका प्रबंधन और उपयोगकर्ता प्रोफाइल।
- सुरक्षा सुविधाएँ जैसे बहु-कारक प्रमाणीकरण (MFA), समझौता किए गए क्रेडेंशियल्स के लिए जांच, खाता अधिग्रहण सुरक्षा, और फोन और ईमेल सत्यापन।
- AWS Lambda ट्रिगर्स के माध्यम से अनुकूलित वर्कफ़्लो और उपयोगकर्ता माइग्रेशन।

**स्रोत कोड** में आमतौर पर **उपयोगकर्ता पूल ID** और **क्लाइंट एप्लिकेशन ID** (और कभी-कभी **एप्लिकेशन सीक्रेट**?) शामिल होते हैं, जो एक **उपयोगकर्ता को Cognito User Pool में लॉगिन** करने के लिए आवश्यक होते हैं।

### Potential attacks

- **पंजीकरण**: डिफ़ॉल्ट रूप से एक उपयोगकर्ता स्वयं को पंजीकृत कर सकता है, इसलिए वह अपने लिए एक उपयोगकर्ता बना सकता है।
- **उपयोगकर्ता गणना**: पंजीकरण कार्यक्षमता का उपयोग उन उपयोगकर्ता नामों को खोजने के लिए किया जा सकता है जो पहले से मौजूद हैं। यह जानकारी ब्रूट-फोर्स हमले के लिए उपयोगी हो सकती है।
- **लॉगिन ब्रूट-फोर्स**: [**प्रमाणीकरण**](cognito-user-pools.md#authentication) अनुभाग में आपके पास सभी **विधियाँ** हैं जिनका उपयोगकर्ता को **लॉगिन** करने के लिए उपयोग करना है, आप उन्हें **वैध क्रेडेंशियल्स** खोजने के लिए ब्रूट-फोर्स करने का प्रयास कर सकते हैं।

### Tools for pentesting

- [Pacu](https://github.com/RhinoSecurityLabs/pacu), अब `cognito__enum` और `cognito__attack` मॉड्यूल शामिल करता है जो एक खाते में सभी Cognito संपत्तियों की गणना को स्वचालित करता है और कमजोर कॉन्फ़िगरेशन, पहुँच नियंत्रण के लिए उपयोगकर्ता विशेषताएँ, आदि को चिह्नित करता है, और उपयोगकर्ता निर्माण (MFA समर्थन सहित) और अनुकूलन योग्य कस्टम विशेषताओं, उपयोग योग्य पहचान पूल क्रेडेंशियल्स, आईडी टोकन में असुमेबल भूमिकाओं के आधार पर विशेषाधिकार वृद्धि को भी स्वचालित करता है।\
मॉड्यूल के कार्यों का विवरण [ब्लॉग पोस्ट](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2) के भाग 2 में देखें। स्थापना निर्देशों के लिए मुख्य [Pacu](https://github.com/RhinoSecurityLabs/pacu) पृष्ठ देखें।
```bash
# Run cognito__enum usage to gather all user pools, user pool clients, identity pools, users, etc. visible in the current AWS account
Pacu (new:test) > run cognito__enum

# cognito__attack usage to attempt user creation and all privesc vectors against a given identity pool and user pool client:
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
- [Cognito Scanner](https://github.com/padok-team/cognito-scanner) एक CLI टूल है जो पायथन में विभिन्न हमलों को लागू करता है, जिसमें अवांछित खाता निर्माण और खाता ओरेकल शामिल हैं। अधिक जानकारी के लिए [इस लिंक](https://github.com/padok-team/cognito-scanner) की जांच करें।
```bash
# Install
pip install cognito-scanner
# Run
cognito-scanner --help
```
- [CognitoAttributeEnum](https://github.com/punishell/CognitoAttributeEnum): यह स्क्रिप्ट उपयोगकर्ताओं के लिए मान्य विशेषताओं को सूचीबद्ध करने की अनुमति देती है।
```bash
python cognito-attribute-enu.py -client_id 16f1g98bfuj9i0g3f8be36kkrl
```
## पंजीकरण

User Pools **डिफ़ॉल्ट** द्वारा **नए उपयोगकर्ताओं** को **पंजीकृत** करने की अनुमति देता है।
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### यदि कोई भी पंजीकरण कर सकता है

आपको एक त्रुटि मिल सकती है जो आपको बताती है कि आपको उपयोगकर्ता के बारे में **अधिक विवरण प्रदान करने** की आवश्यकता है:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
आप आवश्यक विवरण JSON के साथ प्रदान कर सकते हैं जैसे:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
आप इस कार्यक्षमता का उपयोग **मौजूदा उपयोगकर्ताओं की गणना** करने के लिए भी कर सकते हैं। जब उस नाम के साथ एक उपयोगकर्ता पहले से मौजूद होता है, तो यह त्रुटि संदेश होता है:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
> [!NOTE]
> पिछले कमांड में ध्यान दें कि **कस्टम विशेषताएँ "custom:" से शुरू होती हैं**।\
> यह भी जान लें कि पंजीकरण करते समय आप **उपयोगकर्ता के लिए नई कस्टम विशेषताएँ नहीं बना सकते**। आप केवल **डिफ़ॉल्ट विशेषताओं** (भले ही वे आवश्यक न हों) और **निर्धारित कस्टम विशेषताओं** को मान दे सकते हैं।

या बस यह परीक्षण करने के लिए कि क्या एक क्लाइंट आईडी मौजूद है। यदि क्लाइंट-आईडी मौजूद नहीं है तो यह त्रुटि है:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### यदि केवल व्यवस्थापक उपयोगकर्ताओं को पंजीकृत कर सकता है

आप इस त्रुटि को पाएंगे और आप उपयोगकर्ताओं को पंजीकृत या सूचीबद्ध नहीं कर पाएंगे:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### पंजीकरण की पुष्टि करना

Cognito **एक नए उपयोगकर्ता की पुष्टि करने के लिए उसके ईमेल या फोन नंबर की पुष्टि करने** की अनुमति देता है। इसलिए, जब आप एक उपयोगकर्ता बना रहे होते हैं, तो आमतौर पर आपको कम से कम उपयोगकर्ता नाम और पासवर्ड और **ईमेल और/या फोन नंबर** की आवश्यकता होगी। बस एक ऐसा **सेट करें जिसे आप नियंत्रित करते हैं** ताकि आप **अपने** नए बनाए गए उपयोगकर्ता **खाते** की पुष्टि करने के लिए कोड प्राप्त कर सकें।
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
> [!WARNING]
> भले ही **ऐसा लगता है कि आप वही ईमेल** और फोन नंबर का उपयोग कर सकते हैं, जब आपको बनाए गए उपयोगकर्ता को सत्यापित करने की आवश्यकता होती है, तो Cognito समान जानकारी का उपयोग करने के बारे में शिकायत करेगा और **आपको खाता सत्यापित करने नहीं देगा**।

### विशेषाधिकार वृद्धि / गुण अपडेट करना

डिफ़ॉल्ट रूप से, एक उपयोगकर्ता **अपने गुणों के मान को संशोधित कर सकता है** कुछ इस तरह:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### कस्टम विशेषता प्रिवेस्क

> [!CAUTION]
> आप **कस्टम विशेषताओं** का उपयोग करते हुए पा सकते हैं (जैसे `isAdmin`), क्योंकि डिफ़ॉल्ट रूप से आप **अपनी विशेषताओं के मान बदल सकते हैं**, आप **अधिकार बढ़ाने** के लिए मान स्वयं बदल सकते हैं!

#### ईमेल/उपयोगकर्ता नाम संशोधन प्रिवेस्क

आप इसका उपयोग **किसी उपयोगकर्ता का ईमेल और फोन नंबर संशोधित करने** के लिए कर सकते हैं, लेकिन फिर, भले ही खाता सत्यापित रहे, उन विशेषताओं को **असत्यापित स्थिति में सेट किया गया है** (आपको उन्हें फिर से सत्यापित करना होगा)।

> [!WARNING]
> आप **ईमेल या फोन नंबर से लॉगिन नहीं कर पाएंगे** जब तक कि आप उन्हें सत्यापित नहीं करते, लेकिन आप **उपयोगकर्ता नाम से लॉगिन कर पाएंगे**।\
> ध्यान दें कि भले ही ईमेल संशोधित किया गया हो और सत्यापित न किया गया हो, यह **`email`** **क्षेत्र** के अंदर ID Token में दिखाई देगा और **`email_verified`** फ़ील्ड **false** होगी, लेकिन यदि ऐप **यह नहीं देख रहा है तो आप अन्य उपयोगकर्ताओं का अनुकरण कर सकते हैं**।

> इसके अलावा, ध्यान दें कि आप **`name`** फ़ील्ड के अंदर कुछ भी डाल सकते हैं बस **name attribute** को संशोधित करके। यदि कोई ऐप किसी कारण से **उस** फ़ील्ड की **जांच** कर रहा है **`email`** (या किसी अन्य विशेषता) के बजाय, तो आप **अन्य उपयोगकर्ताओं का अनुकरण कर सकते हैं**।

खैर, यदि किसी कारण से आपने अपना ईमेल, उदाहरण के लिए, एक नए ईमेल में बदल दिया है जिसे आप एक्सेस कर सकते हैं, तो आप **उस ईमेल पते पर प्राप्त कोड के साथ ईमेल की पुष्टि कर सकते हैं**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
**`फोन_नंबर`** का उपयोग करें **`ईमेल`** के बजाय **नए फोन नंबर** को बदलने/सत्यापित करने के लिए।

> [!NOTE]
> व्यवस्थापक विकल्प को सक्षम कर सकता है **उपयोगकर्ता द्वारा पसंद किए गए उपयोगकर्ता नाम** के साथ लॉगिन करने के लिए। ध्यान दें कि आप इस मान को **किसी भी उपयोगकर्ता नाम या पसंद किए गए_उपयोगकर्ता नाम** में बदलने में असमर्थ होंगे जो पहले से किसी अन्य उपयोगकर्ता का प्रतिनिधित्व करने के लिए उपयोग किया जा रहा है।

### पासवर्ड पुनर्प्राप्त करें/बदलें

यह संभव है कि केवल **उपयोगकर्ता नाम** (या ईमेल या फोन स्वीकार किया जाता है) को जानकर पासवर्ड को पुनर्प्राप्त किया जा सके और वहां एक कोड भेजा जाएगा:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
> [!NOTE]
> सर्वर की प्रतिक्रिया हमेशा सकारात्मक होगी, जैसे कि यदि उपयोगकर्ता नाम मौजूद है। आप इस विधि का उपयोग उपयोगकर्ताओं की गणना करने के लिए नहीं कर सकते हैं

कोड के साथ आप पासवर्ड बदल सकते हैं:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
पासवर्ड बदलने के लिए आपको **पिछला पासवर्ड जानना होगा**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentication

एक उपयोगकर्ता पूल **प्रमाणित करने के लिए विभिन्न तरीकों** का समर्थन करता है। यदि आपके पास **उपयोगकर्ता नाम और पासवर्ड** है, तो लॉगिन के लिए भी **विभिन्न विधियाँ** समर्थित हैं।\
इसके अलावा, जब एक उपयोगकर्ता पूल में प्रमाणित होता है, तो **3 प्रकार के टोकन दिए जाते हैं**: **ID टोकन**, **एक्सेस टोकन** और **रीफ्रेश टोकन**।

- [**ID Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): इसमें **प्रमाणित उपयोगकर्ता की पहचान** के बारे में दावे होते हैं, जैसे `name`, `email`, और `phone_number`। ID टोकन का उपयोग **आपके संसाधन सर्वरों या सर्वर अनुप्रयोगों में उपयोगकर्ताओं को प्रमाणित करने** के लिए भी किया जा सकता है। यदि आप इसे बाहरी अनुप्रयोगों में उपयोग करते हैं, तो आपको ID टोकन के अंदर किसी भी दावे पर भरोसा करने से पहले **हस्ताक्षर** की **सत्यापन** करनी चाहिए।
- ID टोकन वह टोकन है जो **उपयोगकर्ता के विशेषताओं के मान** को **शामिल करता है**, यहां तक कि कस्टम वाले भी।
- [**Access Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): इसमें प्रमाणित उपयोगकर्ता के बारे में दावे, **उपयोगकर्ता के समूहों की सूची**, और **स्कोप की सूची** होती है। एक्सेस टोकन का उद्देश्य उपयोगकर्ता पूल में उपयोगकर्ता के संदर्भ में **API संचालन को अधिकृत करना** है। उदाहरण के लिए, आप एक्सेस टोकन का उपयोग करके **अपने उपयोगकर्ता को एक्सेस देने** के लिए उपयोगकर्ता विशेषताओं को जोड़ने, बदलने या हटाने के लिए कर सकते हैं।
- [**Refresh Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): रीफ्रेश टोकनों के साथ आप उपयोगकर्ता के लिए **नए ID टोकन और एक्सेस टोकन प्राप्त कर सकते हैं** जब तक कि **रीफ्रेश टोकन अमान्य** न हो जाए। **डिफ़ॉल्ट** रूप से, रीफ्रेश टोकन **30 दिनों के बाद समाप्त हो जाता है** जब आपका अनुप्रयोग उपयोगकर्ता आपके उपयोगकर्ता पूल में साइन इन करता है। जब आप अपने उपयोगकर्ता पूल के लिए एक अनुप्रयोग बनाते हैं, तो आप अनुप्रयोग के रीफ्रेश टोकन की समाप्ति को **60 मिनट से 10 वर्षों के बीच किसी भी मान** पर सेट कर सकते हैं।

### ADMIN_NO_SRP_AUTH & ADMIN_USER_PASSWORD_AUTH

यह सर्वर साइड प्रमाणीकरण प्रवाह है:

- सर्वर-साइड ऐप **`AdminInitiateAuth` API ऑपरेशन** को कॉल करता है ( `InitiateAuth` के बजाय)। इस ऑपरेशन के लिए AWS क्रेडेंशियल्स की आवश्यकता होती है जिनमें **`cognito-idp:AdminInitiateAuth`** और **`cognito-idp:AdminRespondToAuthChallenge`** शामिल हैं। यह ऑपरेशन आवश्यक प्रमाणीकरण पैरामीटर लौटाता है।
- जब सर्वर-साइड ऐप के पास **प्रमाणन पैरामीटर** होते हैं, तो यह **`AdminRespondToAuthChallenge` API ऑपरेशन** को कॉल करता है। `AdminRespondToAuthChallenge` API ऑपरेशन केवल तभी सफल होता है जब आप AWS क्रेडेंशियल्स प्रदान करते हैं।

यह **विधि डिफ़ॉल्ट रूप से सक्षम नहीं है**।

**लॉगिन** करने के लिए आपको **जानना आवश्यक है**:

- उपयोगकर्ता पूल आईडी
- क्लाइंट आईडी
- उपयोगकर्ता नाम
- पासवर्ड
- क्लाइंट सीक्रेट (केवल यदि ऐप को एक सीक्रेट का उपयोग करने के लिए कॉन्फ़िगर किया गया है)

> [!NOTE]
> इस विधि से **लॉगिन करने के लिए** उस अनुप्रयोग को `ALLOW_ADMIN_USER_PASSWORD_AUTH` के साथ लॉगिन करने की अनुमति देनी चाहिए।\
> इसके अलावा, इस क्रिया को करने के लिए आपको **`cognito-idp:AdminInitiateAuth`** और **`cognito-idp:AdminRespondToAuthChallenge`** के साथ अनुमतियों वाले क्रेडेंशियल्स की आवश्यकता है।
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>लॉगिन करने का कोड</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_PASSWORD_AUTH

यह विधि एक और सरल और **पारंपरिक उपयोगकर्ता और पासवर्ड प्रमाणीकरण** प्रवाह है। इसे **Cognito** में **पारंपरिक** प्रमाणीकरण विधि **को माइग्रेट** करने की सिफारिश की जाती है और फिर इसे **अक्षम** करने और इसके बजाय **ALLOW_USER_SRP_AUTH** विधि का **उपयोग** करने की सिफारिश की जाती है (क्योंकि यह नेटवर्क पर पासवर्ड कभी नहीं भेजता)।\
यह **विधि डिफ़ॉल्ट रूप से सक्षम नहीं है**।

कोड के अंदर **पिछली प्रमाणीकरण विधि** के साथ मुख्य **अंतर** यह है कि आपको **उपयोगकर्ता पूल आईडी** जानने की **आवश्यकता नहीं है** और आपको Cognito उपयोगकर्ता पूल में **अतिरिक्त अनुमतियों** की **आवश्यकता नहीं है**।

**लॉगिन** करने के लिए आपको **जानने की आवश्यकता है**:

- क्लाइंट आईडी
- उपयोगकर्ता नाम
- पासवर्ड
- क्लाइंट सीक्रेट (केवल यदि ऐप को एक सीक्रेट का उपयोग करने के लिए कॉन्फ़िगर किया गया है)

> [!NOTE]
> इस विधि के साथ **लॉगिन करने के लिए सक्षम होने के लिए** उस एप्लिकेशन को ALLOW_USER_PASSWORD_AUTH के साथ लॉगिन करने की अनुमति देनी चाहिए।
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>लॉगिन के लिए Python कोड</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_SRP_AUTH

यह परिदृश्य पिछले वाले के समान है लेकिन **पासवर्ड भेजने के बजाय** नेटवर्क के माध्यम से लॉगिन करने के लिए **चुनौती प्रमाणीकरण किया जाता है** (इसलिए कोई पासवर्ड नेटवर्क के माध्यम से एन्क्रिप्टेड भी नहीं जाता)।\
यह **विधि डिफ़ॉल्ट रूप से सक्षम है**।

लॉगिन करने के लिए आपको **जानना आवश्यक है**:

- उपयोगकर्ता पूल आईडी
- क्लाइंट आईडी
- उपयोगकर्ता नाम
- पासवर्ड
- क्लाइंट सीक्रेट (केवल यदि ऐप को सीक्रेट का उपयोग करने के लिए कॉन्फ़िगर किया गया है)

<details>

<summary>लॉगिन करने के लिए कोड</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH_TOKEN_AUTH & REFRESH_TOKEN

यह **विधि हमेशा मान्य रहने वाली है** (इसे बंद नहीं किया जा सकता) लेकिन आपके पास एक मान्य रिफ्रेश टोकन होना चाहिए।
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>रीफ्रेश करने के लिए कोड</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM_AUTH

इस मामले में **प्रमाणीकरण** **lambda फ़ंक्शन** के **निष्पादन** के माध्यम से किया जाएगा।

## अतिरिक्त सुरक्षा

### उन्नत सुरक्षा

डिफ़ॉल्ट रूप से यह बंद है, लेकिन यदि सक्षम किया गया, तो Cognito **खाता अधिग्रहण** को **खोजने** में सक्षम हो सकता है। संभावना को कम करने के लिए, आपको **एक ही शहर के अंदर एक नेटवर्क से लॉगिन करना चाहिए, उसी उपयोगकर्ता एजेंट का उपयोग करते हुए** (और यदि संभव हो तो IP)**।**

### **MFA याद रखें डिवाइस**

यदि उपयोगकर्ता उसी डिवाइस से लॉगिन करता है, तो MFA को बायपास किया जा सकता है, इसलिए MFA सुरक्षा को बायपास करने के लिए उसी मेटाडेटा (IP?) के साथ उसी ब्राउज़र से लॉगिन करने का प्रयास करें।

## उपयोगकर्ता पूल समूह IAM भूमिकाएँ

यह संभव है कि **उपयोगकर्ताओं को उपयोगकर्ता पूल** समूहों में जोड़ा जाए जो एक **IAM भूमिका** से संबंधित हैं।\
इसके अलावा, **उपयोगकर्ताओं** को **अलग-अलग IAM भूमिकाओं** के साथ **1 से अधिक समूहों** में असाइन किया जा सकता है।

ध्यान दें कि भले ही एक समूह एक IAM भूमिका के साथ एक समूह के अंदर हो, उस समूह के IAM क्रेडेंशियल्स तक पहुँचने के लिए आवश्यक है कि **उपयोगकर्ता पूल को एक पहचान पूल द्वारा विश्वसनीय होना चाहिए** (और उस पहचान पूल के विवरण को जानना चाहिए)।

जब एक उपयोगकर्ता उपयोगकर्ता पूल में प्रमाणित होता है (`aws cognito-idp initiate-auth...`), तो **IdToken में निर्दिष्ट IAM भूमिका** प्राप्त करने के लिए एक और आवश्यकता है कि **पहचान प्रदाता प्रमाणीकरण प्रदाता** को यह संकेत देना चाहिए कि **भूमिका को टोकन से चुना जाना चाहिए।**

<figure><img src="../../../../images/image (250).png" alt=""><figcaption></figcaption></figure>

एक उपयोगकर्ता के पास पहुँच के लिए **भूमिकाएँ** **`IdToken` के अंदर** होती हैं, और एक उपयोगकर्ता **`--custom-role-arn`** के साथ **क्रेडेंशियल्स के लिए वह भूमिका चुन सकता है** `aws cognito-identity get-credentials-for-identity` से।\
हालांकि, यदि **डिफ़ॉल्ट विकल्प** वह है जो **कॉन्फ़िगर किया गया है** (`डिफ़ॉल्ट भूमिका का उपयोग करें`), और आप IdToken से एक भूमिका तक पहुँचने का प्रयास करते हैं, तो आपको **त्रुटि** मिलेगी (इसलिए पिछले कॉन्फ़िगरेशन की आवश्यकता है):
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
> [!WARNING]
> ध्यान दें कि **यूजर पूल ग्रुप** को सौंपा गया भूमिका उस **पहचान प्रदाता द्वारा सुलभ होना चाहिए** जो **यूजर पूल पर भरोसा करता है** (क्योंकि IAM भूमिका **सत्र क्रेडेंशियल्स इसे से प्राप्त किए जाने वाले हैं**)।
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{{#include ../../../../banners/hacktricks-training.md}}
