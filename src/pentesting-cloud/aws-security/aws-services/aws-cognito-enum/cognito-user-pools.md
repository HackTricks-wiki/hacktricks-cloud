# Cognito User Pools

{{#include ../../../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bir kullanıcı havuzu, Amazon Cognito'daki bir kullanıcı dizinidir. Bir kullanıcı havuzu ile kullanıcılarınız **Amazon Cognito üzerinden web veya mobil uygulamanıza giriş yapabilir** veya **üçüncü taraf** bir kimlik sağlayıcısı (IdP) aracılığıyla **federasyon** yapabilir. Kullanıcılarınız doğrudan veya bir üçüncü taraf aracılığıyla giriş yapsa da, kullanıcı havuzunun tüm üyeleri, bir SDK aracılığıyla erişebileceğiniz bir dizin profiline sahiptir.

Kullanıcı havuzları şunları sağlar:

- Kayıt ve giriş hizmetleri.
- Kullanıcıları giriş yaptırmak için yerleşik, özelleştirilebilir bir web UI.
- Facebook, Google, Amazon ile Giriş ve Apple ile Giriş gibi sosyal girişler ve kullanıcı havuzunuzdan SAML ve OIDC kimlik sağlayıcıları aracılığıyla.
- Kullanıcı dizini yönetimi ve kullanıcı profilleri.
- Çok faktörlü kimlik doğrulama (MFA), ele geçirilmiş kimlik bilgileri için kontroller, hesap ele geçirme koruması ve telefon ve e-posta doğrulaması gibi güvenlik özellikleri.
- AWS Lambda tetikleyicileri aracılığıyla özelleştirilmiş iş akışları ve kullanıcı göçü.

Uygulamaların **kaynak kodu** genellikle **kullanıcı havuzu ID'si** ve **istemci uygulama ID'si** (ve bazen **uygulama sırrı**?) içerir; bunlar bir kullanıcının Cognito Kullanıcı Havuzuna **giriş yapması** için gereklidir.

### Potansiyel saldırılar

- **Kayıt**: Varsayılan olarak bir kullanıcı kendini kaydedebilir, bu nedenle kendisi için bir kullanıcı oluşturabilir.
- **Kullanıcı numaralandırma**: Kayıt işlevselliği, zaten mevcut olan kullanıcı adlarını bulmak için kullanılabilir. Bu bilgi, kaba kuvvet saldırısı için yararlı olabilir.
- **Giriş kaba kuvvet**: [**Kimlik Doğrulama**](cognito-user-pools.md#authentication) bölümünde bir kullanıcının **giriş yapması** için tüm **yöntemleri** bulabilirsiniz, bunları **geçerli kimlik bilgilerini bulmak için** kaba kuvvetle denemek isteyebilirsiniz.

### Pentesting için araçlar

- [Pacu](https://github.com/RhinoSecurityLabs/pacu), artık bir hesapta tüm Cognito varlıklarının numaralandırılmasını otomatikleştiren ve zayıf yapılandırmaları, erişim kontrolü için kullanılan kullanıcı özniteliklerini vb. işaret eden `cognito__enum` ve `cognito__attack` modüllerini içeriyor ve ayrıca kullanıcı oluşturmayı (MFA desteği dahil) ve değiştirilebilir özel özniteliklere, kullanılabilir kimlik havuzu kimlik bilgilerine, id token'larındaki üstlenilebilir rollere dayalı ayrıcalık yükseltmeyi otomatikleştiriyor.\
Modüllerin işlevlerinin açıklaması için [blog yazısının](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2) 2. kısmına bakın. Kurulum talimatları için ana [Pacu](https://github.com/RhinoSecurityLabs/pacu) sayfasına bakın.
```bash
# Run cognito__enum usage to gather all user pools, user pool clients, identity pools, users, etc. visible in the current AWS account
Pacu (new:test) > run cognito__enum

# cognito__attack usage to attempt user creation and all privesc vectors against a given identity pool and user pool client:
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
- [Cognito Scanner](https://github.com/padok-team/cognito-scanner), istenmeyen hesap oluşturma ve hesap oracle'ı da dahil olmak üzere Cognito'ya farklı saldırılar uygulayan bir Python CLI aracıdır. Daha fazla bilgi için [bu bağlantıya](https://github.com/padok-team/cognito-scanner) bakın.
```bash
# Install
pip install cognito-scanner
# Run
cognito-scanner --help
```
- [CognitoAttributeEnum](https://github.com/punishell/CognitoAttributeEnum): Bu script, kullanıcılar için geçerli nitelikleri listelemeye olanak tanır.
```bash
python cognito-attribute-enu.py -client_id 16f1g98bfuj9i0g3f8be36kkrl
```
## Kayıt

User Pools varsayılan olarak **yeni kullanıcıların kaydolmasına** izin verir.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Eğer herkes kayıt olabiliyorsa

Kullanıcı hakkında **daha fazla ayrıntı sağlamanız gerektiğini** belirten bir hata bulabilirsiniz:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Gerekli bilgileri aşağıdaki gibi bir JSON ile sağlayabilirsiniz:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Bu işlevselliği **mevcut kullanıcıları listelemek** için de kullanabilirsiniz. O isimle zaten mevcut bir kullanıcı olduğunda hata mesajı:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
> [!NOTE]
> Önceki komutta **özel niteliklerin "custom:" ile başladığını** not edin.\
> Ayrıca, kayıt sırasında **kullanıcı için yeni özel nitelikler oluşturamayacağınızı** bilin. Sadece **varsayılan niteliklere** (gerekli olmasalar bile) ve **belirtilen özel niteliklere** değer verebilirsiniz.

Ya da sadece bir istemci kimliğinin var olup olmadığını test etmek için. İstemci kimliği yoksa bu hata alınır:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Eğer yalnızca admin kullanıcıları kaydedebiliyorsa

Bu hatayı bulacaksınız ve kullanıcıları kaydedemeyecek veya listeleyemeyeceksiniz:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Kayıt Doğrulama

Cognito, **yeni bir kullanıcıyı e-posta veya telefon numarasını doğrulayarak doğrulamaya** olanak tanır. Bu nedenle, bir kullanıcı oluştururken genellikle en az kullanıcı adı ve şifre ile birlikte **e-posta ve/veya telefon numarası** istenecektir. Sadece **kontrol ettiğiniz** birini ayarlayın, böylece **yeni oluşturduğunuz kullanıcı** **hesabınızı** doğrulamak için kodu alacaksınız:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
> [!WARNING]
> Aynı e-posta ve telefon numarasını kullanabileceğiniz gibi görünse de, oluşturulan kullanıcıyı doğrulamak istediğinizde Cognito aynı bilgilerin kullanıldığına dair şikayet edecek ve **hesabı doğrulamanıza izin vermeyecektir**.

### Yetki Yükseltme / Nitelikleri Güncelleme

Varsayılan olarak bir kullanıcı **niteliklerinin değerini değiştirebilir** gibi bir şeyle:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Özel nitelik privesc

> [!CAUTION]
> **Özel nitelikler** (örneğin `isAdmin`) kullanıldığını görebilirsiniz, çünkü varsayılan olarak **kendi niteliklerinizin değerlerini değiştirebilirsiniz**, bu da **yetki yükseltme** yapmanıza olanak tanıyabilir!

#### E-posta/kullanıcı adı değiştirme privesc

Bir kullanıcının **e-posta ve telefon numarasını değiştirmek** için bunu kullanabilirsiniz, ancak o zaman, hesap doğrulanmış kalsa bile, bu nitelikler **doğrulanmamış durumda ayarlanır** (tekrar doğrulamanız gerekir).

> [!WARNING]
> **E-posta veya telefon numarası ile giriş yapamayacaksınız** ta ki onları doğrulayana kadar, ancak **kullanıcı adı ile giriş yapabileceksiniz**.\
> E-posta değiştirilmiş ve doğrulanmamış olsa bile, **`email`** **alanında** ID Token içinde görünecektir ve **`email_verified`** alanı **false** olacaktır, ancak uygulama **bunu kontrol etmiyorsa diğer kullanıcıları taklit edebilirsiniz**.

> Ayrıca, **`name`** alanına sadece **name niteliğini** değiştirerek istediğiniz her şeyi koyabileceğinizi unutmayın. Eğer bir uygulama **o alanı** bir nedenle **`email`** (veya başka bir nitelik) yerine **kontrol ediyorsa**, diğer kullanıcıları **taklit edebilirsiniz**.

Her neyse, e-posta adresinizi örneğin erişebileceğiniz yeni bir e-posta ile değiştirdiyseniz, o e-posta adresine aldığınız kod ile **e-postayı onaylayabilirsiniz**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
**`telefon_numarası`** yerine **`email`** kullanarak **yeni bir telefon numarasını** değiştire/doğrulayın.

> [!NOTE]
> Yönetici, **kullanıcının tercih ettiği kullanıcı adıyla giriş yapma** seçeneğini de etkinleştirebilir. Bu değeri, **farklı bir kullanıcıyı taklit etmek için zaten kullanılan herhangi bir kullanıcı adı veya tercih edilen kullanıcı adı** olarak değiştiremeyeceğinizi unutmayın.

### Şifreyi Kurtarma/Değiştirme

Bir şifreyi kurtarmak, sadece **kullanıcı adını** (veya email veya telefon kabul edilir) bilmek ve oraya bir kod gönderileceği için buna erişim sağlamak mümkündür:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
> [!NOTE]
> Sunucunun yanıtı her zaman olumlu olacak, sanki kullanıcı adı varmış gibi. Bu yöntemi kullanıcıları listelemek için kullanamazsınız.

Şifreyi şu kodla değiştirebilirsiniz:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Şifreyi değiştirmek için **önceki şifreyi bilmeniz gerekir**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Kimlik Doğrulama

Bir kullanıcı havuzu **farklı kimlik doğrulama yöntemlerini** destekler. Eğer bir **kullanıcı adı ve şifre** varsa, giriş yapmak için de **farklı yöntemler** desteklenir.\
Ayrıca, bir kullanıcı Havuzda **3 tür token verilir**: **ID Token**, **Erişim token'ı** ve **Yenileme token'ı**.

- [**ID Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Bu, **kimliği doğrulanmış kullanıcının** `name`, `email` ve `phone_number` gibi iddialarını içerir. ID token'ı ayrıca **kullanıcıları kaynak sunucularınıza veya sunucu uygulamalarınıza kimlik doğrulamak için** de kullanılabilir. Dış uygulamalarda kullanıyorsanız, ID token içindeki herhangi bir iddiayı güvenilir kılmadan önce **imzayı doğrulamalısınız**.
- ID Token, **kullanıcının özellik değerlerini** içeren token'dır, hatta özel olanları bile.
- [**Erişim Token'ı**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Bu, kimliği doğrulanmış kullanıcı hakkında iddialar, **kullanıcının gruplarının listesi** ve **kapsamların listesi** içerir. Erişim token'ının amacı, kullanıcı havuzundaki kullanıcı bağlamında **API işlemlerini yetkilendirmektir**. Örneğin, erişim token'ını kullanarak **kullanıcınıza kullanıcı özelliklerini ekleme, değiştirme veya silme** izni verebilirsiniz.
- [**Yenileme Token'ı**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Yenileme token'ları ile kullanıcı için **yeni ID Token'ları ve Erişim Token'ları** alabilirsiniz, ta ki **yenileme token'ı geçersiz olana kadar**. **Varsayılan olarak**, yenileme token'ı, uygulama kullanıcınız kullanıcı havuzunuza giriş yaptığında **30 gün sonra süresi dolmaktadır**. Kullanıcı havuzunuz için bir uygulama oluşturduğunuzda, uygulamanın yenileme token'ı süresini **60 dakika ile 10 yıl arasında herhangi bir değere** ayarlayabilirsiniz.

### ADMIN_NO_SRP_AUTH & ADMIN_USER_PASSWORD_AUTH

Bu, sunucu tarafı kimlik doğrulama akışıdır:

- Sunucu tarafı uygulama, **`AdminInitiateAuth` API işlemini** çağırır ( `InitiateAuth` yerine). Bu işlem, **`cognito-idp:AdminInitiateAuth`** ve **`cognito-idp:AdminRespondToAuthChallenge`** izinlerini içeren AWS kimlik bilgileri gerektirir. İşlem, gerekli kimlik doğrulama parametrelerini döndürür.
- Sunucu tarafı uygulama **kimlik doğrulama parametrelerine** sahip olduktan sonra, **`AdminRespondToAuthChallenge` API işlemini** çağırır. `AdminRespondToAuthChallenge` API işlemi yalnızca AWS kimlik bilgilerini sağladığınızda başarılı olur.

Bu **yöntem varsayılan olarak etkin değildir**.

**Giriş yapmak için** şunları **bilmeniz gerekir**:

- kullanıcı havuzu kimliği
- istemci kimliği
- kullanıcı adı
- şifre
- istemci sırrı (sadece uygulama bir sır kullanacak şekilde yapılandırılmışsa)

> [!NOTE]
> Bu yöntemle **giriş yapabilmek için** uygulamanın `ALLOW_ADMIN_USER_PASSWORD_AUTH` ile giriş yapmaya izin vermesi gerekir.\
> Ayrıca, bu işlemi gerçekleştirmek için **`cognito-idp:AdminInitiateAuth`** ve **`cognito-idp:AdminRespondToAuthChallenge`** izinlerine sahip kimlik bilgilerine ihtiyacınız vardır.
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Giriş Kodu</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_PASSWORD_AUTH

Bu yöntem, başka bir basit ve **geleneksel kullanıcı ve şifre kimlik doğrulama** akışıdır. **Geleneksel** bir kimlik doğrulama yönteminin **Cognito'ya** **geçirilmesi** ve ardından **devre dışı bırakılması** ve bunun yerine **ALLOW_USER_SRP_AUTH** yönteminin **kullanılması** önerilir (çünkü bu yöntem şifreyi ağ üzerinden asla göndermez).\
Bu **yöntem varsayılan olarak ETKİN değildir**.

Kod içindeki **önceki kimlik doğrulama yöntemi** ile ana **fark**, **kullanıcı havuzunun kimliğini bilmenize gerek olmamasıdır** ve **Cognito Kullanıcı Havuzunda ek izinlere** ihtiyacınız yoktur.

**Giriş yapmak için** bilmeniz **gerekir**:

- istemci kimliği
- kullanıcı adı
- şifre
- istemci sırrı (sadece uygulama bir sır kullanacak şekilde yapılandırılmışsa)

> [!NOTE]
> Bu yöntemle **giriş yapabilmek için**, o uygulamanın ALLOW_USER_PASSWORD_AUTH ile giriş yapmasına izin vermesi gerekir.
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Giriş yapmak için Python kodu</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER_SRP_AUTH

Bu senaryo, önceki senaryoya benzer ancak **şifreyi göndermek yerine** bir **challenge authentication gerçekleştirilir** (yani şifre, şifreli bile olsa ağ üzerinden geçmez).\
Bu **yöntem varsayılan olarak etkindir**.

Giriş yapmak için **şunları bilmeniz gerekir**:

- kullanıcı havuzu kimliği
- istemci kimliği
- kullanıcı adı
- şifre
- istemci sırrı (sadece uygulama bir sır kullanacak şekilde yapılandırılmışsa)

<details>

<summary>Giriş yapmak için kod</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH_TOKEN_AUTH & REFRESH_TOKEN

Bu **yöntem her zaman geçerli olacak** (devre dışı bırakılamaz) ancak geçerli bir refresh token'a sahip olmanız gerekir.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Yenileme Kodu</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM_AUTH

Bu durumda **kimlik doğrulama**, **bir lambda fonksiyonunun yürütülmesi** aracılığıyla gerçekleştirilecektir.

## Ek Güvenlik

### Gelişmiş Güvenlik

Varsayılan olarak devre dışıdır, ancak etkinleştirildiğinde, Cognito **hesap ele geçirmelerini bulma** yeteneğine sahip olabilir. Olasılığı en aza indirmek için **aynı şehirdeki bir ağdan, aynı kullanıcı aracını kullanarak** (ve mümkünse IP ile) giriş yapmalısınız.

### **MFA Hatırlama cihazı**

Kullanıcı aynı cihazdan giriş yaparsa, MFA atlanabilir, bu nedenle MFA korumasını atlatmak için aynı tarayıcıdan aynı meta verilerle (IP?) giriş yapmayı deneyin.

## Kullanıcı Havuzu Grupları IAM Rolleri

**Kullanıcıları Kullanıcı Havuzu** gruplarına eklemek mümkündür ve bu gruplar bir **IAM rolü** ile ilişkilidir.\
Ayrıca, **kullanıcılar** farklı IAM rolleri eklenmiş **1'den fazla gruba atanabilir**.

Bir grubun, ekli bir IAM rolü olan bir grubun içinde olsa bile, o grubun IAM kimlik bilgilerine erişebilmesi için **Kullanıcı Havuzunun bir Kimlik Havuzu tarafından güvenilir olması** gerektiğini unutmayın (ve o Kimlik Havuzunun ayrıntılarını bilmek).

Kullanıcı, Kullanıcı Havuzunda (`aws cognito-idp initiate-auth...`) kimlik doğrulandığında **IdToken'da belirtilen IAM rolünü** almak için bir diğer gereklilik, **Kimlik Sağlayıcı Kimlik doğrulama sağlayıcısının** **rolün token'dan seçilmesi gerektiğini** belirtmesidir.

<figure><img src="../../../../images/image (250).png" alt=""><figcaption></figcaption></figure>

Bir kullanıcının erişebileceği **roller**, **`IdToken`** içindedir ve bir kullanıcı, **`aws cognito-identity get-credentials-for-identity`** ile **`--custom-role-arn`** kullanarak hangi rol için kimlik bilgileri almak istediğini **seçebilir**.\
Ancak, eğer **varsayılan seçenek** **yapılandırılmış olan** (`varsayılan rolü kullan`) ise ve IdToken'dan bir role erişmeye çalışırsanız, **hata** alırsınız (bu nedenle önceki yapılandırma gereklidir):
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
> [!WARNING]
> **Kullanıcı Havuzu Grubu**'na atanan rolün, **Kullanıcı Havuzuna güvenen Kimlik Sağlayıcı** tarafından **erişilebilir** olması gerektiğini unutmayın (çünkü IAM rolü **oturum kimlik bilgileri buradan alınacaktır**).
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{{#include ../../../../banners/hacktricks-training.md}}
