# AWS - Nitro Enum

{{#include ../../../../banners/hacktricks-training.md}}

## 基本信息

AWS Nitro 是一套 **创新技术**，构成了 AWS EC2 实例的基础平台。由亚马逊推出，以 **增强安全性、性能和可靠性**，Nitro 利用定制的 **硬件组件和轻量级虚拟机监控器**。它将传统虚拟化功能抽象到专用硬件和软件上，**最小化攻击面**并提高资源效率。通过卸载虚拟化功能，Nitro 使 EC2 实例能够提供 **接近裸金属的性能**，这对资源密集型应用特别有利。此外，Nitro 安全芯片专门确保 **硬件和固件的安全性**，进一步巩固其强大的架构。

### Nitro Enclaves

**AWS Nitro Enclaves** 提供一个安全的 **隔离计算环境，位于 Amazon EC2 实例内**，专门设计用于处理高度敏感的数据。利用 AWS Nitro 系统，这些隔离区确保强大的 **隔离和安全性**，非常适合 **处理机密信息**，如个人身份信息或财务记录。它们具有极简的环境，显著降低数据暴露的风险。此外，Nitro Enclaves 支持加密证明，允许用户验证只有授权代码在运行，这对维护严格的合规性和数据保护标准至关重要。

> [!CAUTION]
> Nitro Enclave 镜像是 **从 EC2 实例内部运行的**，您无法从 AWS 网络控制台查看 EC2 实例是否在运行 Nitro Enclave 镜像。

## Nitro Enclave CLI 安装

请遵循所有说明 [**来自文档**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)。然而，以下是最重要的几点：
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

您可以在 Nitro Enclave 中运行的镜像基于 docker 镜像，因此您可以从 docker 镜像创建您的 Nitro Enclave 镜像，例如：
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
如您所见，Nitro Enclave 镜像使用扩展名 **`eif`** (Enclave Image File)。

输出将类似于：
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### 运行映像

根据 [**文档**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)，要运行一个 enclave 映像，您需要分配 **至少是 `eif` 文件大小的 4 倍** 的内存。可以在文件中配置要分配给它的默认资源。
```shell
/etc/nitro_enclaves/allocator.yaml
```
> [!CAUTION]
> 始终记住，您还需要为**父 EC2** 实例**保留一些资源**！

在知道要分配给映像的资源并且甚至修改了配置文件后，可以使用以下命令运行一个 enclave 映像：
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
### 枚举区块

如果您攻陷了一个 EC2 主机，可以使用以下命令获取正在运行的区块映像列表：
```bash
nitro-cli describe-enclaves
```
无法在运行的 enclave 镜像内获取 shell，因为这正是 enclave 的主要目的。然而，如果您使用参数 **`--debug-mode`**，则可以通过以下方式获取其 **stdout**：
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### 终止隔离区

如果攻击者通过默认方式攻陷了一个 EC2 实例，他将无法在其中获得 shell，但他将能够通过以下方式**终止它们**：
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

与运行图像的 **enclave** 进行通信的唯一方式是使用 **vsocks**。

**虚拟套接字 (vsock)** 是 Linux 中的一种套接字系列，专门设计用于促进虚拟机 (**VMs**) 与其 **hypervisors** 之间，或虚拟机 **之间** 的 **通信**。Vsock 使得高效的 **双向通信** 成为可能，而无需依赖主机的网络堆栈。这使得虚拟机即使在没有网络配置的情况下也能进行通信，**使用 32 位上下文 ID (CID) 和端口号** 来识别和管理连接。vsock API 支持流和数据报套接字类型，类似于 TCP 和 UDP，为虚拟环境中的用户级应用程序提供了一个多功能工具。

> [!TIP]
> 因此，vsock 地址看起来像这样：`<CID>:<Port>`

要找到运行图像的 **CIDs**，您可以执行以下命令并获取 **`EnclaveCID`**：

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

> [!WARNING]
> 请注意，从主机上无法知道 CID 是否暴露任何端口！除非使用一些 **vsock 端口扫描器，如** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner)。

### Vsock 服务器/监听器

这里有几个示例：

- [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>简单的 Python 监听器</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock 客户端

示例：

- [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>简单的 Python 客户端</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

工具 vsock-proxy 允许使用另一个地址代理 vsock 代理，例如：
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
这将把 **vsock 中的本地端口 8001** 转发到 `ip-ranges.amazonaws.com:443`，文件 **`your-vsock-proxy.yaml`** 可能包含以下内容，以允许访问 `ip-ranges.amazonaws.com:443`：
```yaml
allowlist:
- { address: ip-ranges.amazonaws.com, port: 443 }
```
可以使用以下方式查看 EC2 主机使用的 vsock 地址 (**`<CID>:<Port>`**)（注意 `3:8001`，3 是 CID，8001 是端口）：
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
## Nitro Enclave Atestation & KMS

Nitro Enclaves SDK 允许一个 enclave 从 Nitro **Hypervisor** 请求一个 **加密签名的证明文件**，该文件包含特定于该 enclave 的 **唯一测量值**。这些测量值，包括 **哈希和平台配置寄存器 (PCRs)**，在证明过程中用于 **证明 enclave 的身份** 和 **与外部服务建立信任**。证明文件通常包含像 PCR0、PCR1 和 PCR2 这样的值，这些值在构建和保存 enclave EIF 时你已经遇到过。

根据 [**docs**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves)，这些是 PCR 值：

<table><thead><tr><th width="97">PCR</th><th width="221">Hash of ...</th><th>Description</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave image file</td><td>图像文件内容的连续测量，不包括部分数据。</td></tr><tr><td>PCR1</td><td>Linux kernel and bootstrap</td><td>内核和引导 ramfs 数据的连续测量。</td></tr><tr><td>PCR2</td><td>Application</td><td>用户应用程序的连续、按顺序测量，不包括引导 ramfs。</td></tr><tr><td>PCR3</td><td>IAM role assigned to the parent instance</td><td>分配给父实例的 IAM 角色的连续测量。确保只有在父实例具有正确的 IAM 角色时，证明过程才会成功。</td></tr><tr><td>PCR4</td><td>Instance ID of the parent instance</td><td>父实例 ID 的连续测量。确保只有在父实例具有特定实例 ID 时，证明过程才会成功。</td></tr><tr><td>PCR8</td><td>Enclave image file signing certificate</td><td>为 enclave 图像文件指定的签名证书的测量。确保只有在 enclave 从由特定证书签名的 enclave 图像文件引导时，证明过程才会成功。</td></tr></tbody></table>

你可以将 **加密证明** 集成到你的应用程序中，并利用与 **AWS KMS** 等服务的预构建集成。AWS KMS 可以 **验证 enclave 证明**，并在其密钥策略中提供基于证明的条件密钥 (`kms:RecipientAttestation:ImageSha384` 和 `kms:RecipientAttestation:PCR`)。这些策略确保 AWS KMS 仅在 enclave 的证明文件有效且满足 **指定条件** 时，才允许使用 KMS 密钥进行操作。

> [!TIP]
> 请注意，调试模式下的 Enclaves (--debug) 生成的证明文件的 PCR 由零组成 (`000000000000000000000000000000000000000000000000`)。因此，检查这些值的 KMS 策略将失败。

### PCR Bypass

从攻击者的角度来看，注意到某些 PCR 允许修改 enclave 图像的某些部分或全部，并且仍然有效（例如，PCR4 仅检查父实例的 ID，因此在该 EC2 中运行任何 enclave 图像将满足此潜在 PCR 要求）。

因此，攻击者如果攻陷 EC2 实例，可能能够运行其他 enclave 图像以绕过这些保护。

关于如何修改/创建新图像以绕过每个保护（特别是那些不那么明显的保护）的研究仍然待完成。

## References

- [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
- AWS Nitro 教程的所有部分: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{{#include ../../../../banners/hacktricks-training.md}}
