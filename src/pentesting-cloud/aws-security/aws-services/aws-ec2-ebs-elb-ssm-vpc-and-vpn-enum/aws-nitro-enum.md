# AWS - Nitro Enum

{{#include ../../../../banners/hacktricks-training.md}}

## 기본 정보

AWS Nitro는 AWS EC2 인스턴스의 기본 플랫폼을 형성하는 **혁신적인 기술** 모음입니다. Amazon에 의해 **보안, 성능 및 신뢰성**을 향상시키기 위해 도입된 Nitro는 맞춤형 **하드웨어 구성 요소와 경량 하이퍼바이저**를 활용합니다. 전통적인 가상화 기능의 많은 부분을 전용 하드웨어와 소프트웨어로 추상화하여 **공격 표면을 최소화**하고 자원 효율성을 개선합니다. 가상화 기능을 오프로드함으로써 Nitro는 EC2 인스턴스가 **거의 베어 메탈 성능**을 제공할 수 있게 하여, 자원 집약적인 애플리케이션에 특히 유리합니다. 또한, Nitro 보안 칩은 **하드웨어와 펌웨어의 보안**을 보장하여 강력한 아키텍처를 더욱 강화합니다.

### Nitro Enclaves

**AWS Nitro Enclaves**는 Amazon EC2 인스턴스 내에서 **고도로 민감한 데이터**를 처리하기 위해 특별히 설계된 안전하고 **격리된 컴퓨팅 환경**을 제공합니다. AWS Nitro 시스템을 활용하여 이러한 인클레이브는 강력한 **격리 및 보안**을 보장하며, PII 또는 재무 기록과 같은 **기밀 정보**를 처리하는 데 이상적입니다. 이들은 미니멀한 환경을 특징으로 하여 데이터 노출 위험을 크게 줄입니다. 또한, Nitro Enclaves는 암호화된 증명을 지원하여 사용자가 오직 승인된 코드만 실행되고 있음을 확인할 수 있게 하여, 엄격한 준수 및 데이터 보호 기준을 유지하는 데 중요합니다.

> [!CAUTION]
> Nitro Enclave 이미지는 **EC2 인스턴스 내부에서 실행**되며, AWS 웹 콘솔에서 EC2 인스턴스가 Nitro Enclave에서 이미지를 실행 중인지 여부를 확인할 수 없습니다.

## Nitro Enclave CLI 설치

모든 지침을 [**문서에서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave) 따르십시오. 그러나 가장 중요한 지침은 다음과 같습니다:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

Nitro Enclave에서 실행할 수 있는 이미지는 docker 이미지 기반이므로, 다음과 같은 docker 이미지에서 Nitro Enclave 이미지를 생성할 수 있습니다:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Nitro Enclave 이미지에는 **`eif`** (Enclave Image File) 확장자가 사용됩니다.

출력은 다음과 유사하게 보일 것입니다:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### 이미지를 실행하기

[**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)에 따르면, enclave 이미지를 실행하려면 **`eif` 파일 크기의 최소 4배에 해당하는 메모리를 할당해야** 합니다. 파일에서 기본 리소스를 구성하여 할당할 수 있습니다.
```shell
/etc/nitro_enclaves/allocator.yaml
```
> [!CAUTION]
> 항상 **부모 EC2** 인스턴스를 위해 일부 리소스를 **예약해야 한다는 것을 기억하세요!**

이미지에 제공할 리소스를 알고 구성 파일을 수정한 후에도 다음을 사용하여 인클레이브 이미지를 실행할 수 있습니다:
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
### Enclaves 열거

EC2 호스트를 손상시키면 다음을 사용하여 실행 중인 enclave 이미지 목록을 얻을 수 있습니다:
```bash
nitro-cli describe-enclaves
```
실행 중인 enclave 이미지 내부에서 **쉘을 얻는 것은 불가능**합니다. 이는 enclave의 주요 목적이기 때문입니다. 그러나 **`--debug-mode`** 매개변수를 사용하면 다음과 같이 **stdout**을 얻을 수 있습니다:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Enclaves 종료

공격자가 EC2 인스턴스를 손상시키면 기본적으로 그 안에 셸을 얻을 수는 없지만, 다음을 사용하여 **종료할 수** 있습니다:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

**enclave**에서 실행 중인 이미지를 통신하는 유일한 방법은 **vsocks**를 사용하는 것입니다.

**Virtual Socket (vsock)**은 Linux에서 가상 머신(**VMs**)과 그 **hypervisors** 간, 또는 VMs **자체** 간의 **communication**을 촉진하기 위해 특별히 설계된 소켓 패밀리입니다. Vsock은 호스트의 네트워킹 스택에 의존하지 않고 효율적인 **bi-directional communication**을 가능하게 합니다. 이를 통해 VMs는 네트워크 구성 없이도 **32-bit Context ID (CID) 및 포트 번호**를 사용하여 연결을 식별하고 관리할 수 있습니다. vsock API는 TCP 및 UDP와 유사한 스트림 및 데이터그램 소켓 유형을 모두 지원하여 가상 환경에서 사용자 수준 애플리케이션을 위한 다목적 도구를 제공합니다.

> [!TIP]
> 따라서, vsock 주소는 다음과 같이 보입니다: `<CID>:<Port>`

**CIDs**를 찾기 위해 enclave에서 실행 중인 이미지를 찾으려면 다음 cmd를 실행하여 **`EnclaveCID`**를 얻을 수 있습니다:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

> [!WARNING]
> 호스트에서 CID가 어떤 포트를 노출하고 있는지 알 수 있는 방법이 없다는 점에 유의하세요! **vsock 포트 스캐너**인 [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner)를 사용하지 않는 한.

### Vsock Server/Listener

여기 몇 가지 예가 있습니다:

- [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Simple Python Listener</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock 클라이언트

예시:

- [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>간단한 Python 클라이언트</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

도구 vsock-proxy는 다른 주소로 vsock 프록시를 프록시할 수 있게 해줍니다. 예를 들어:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
이것은 **vsock의 로컬 포트 8001**을 `ip-ranges.amazonaws.com:443`으로 포워딩하며, 파일 **`your-vsock-proxy.yaml`**은 `ip-ranges.amazonaws.com:443`에 접근할 수 있도록 다음과 같은 내용을 가질 수 있습니다:
```yaml
allowlist:
- { address: ip-ranges.amazonaws.com, port: 443 }
```
EC2 호스트에서 사용되는 vsock 주소 (**`<CID>:<Port>`**)를 볼 수 있습니다 (여기서 `3:8001`에서 3은 CID이고 8001은 포트입니다):
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
## Nitro Enclave Atestation & KMS

Nitro Enclaves SDK는 enclave가 Nitro **Hypervisor**로부터 **암호학적으로 서명된 증명 문서**를 요청할 수 있게 해주며, 이 문서에는 해당 enclave에 특정한 **고유 측정값**이 포함됩니다. 이러한 측정값은 **해시 및 플랫폼 구성 레지스터(PCR)**를 포함하며, 증명 과정에서 **enclave의 신원을 증명하고 외부 서비스와의 신뢰를 구축하는 데** 사용됩니다. 증명 문서에는 일반적으로 PCR0, PCR1 및 PCR2와 같은 값이 포함되어 있으며, 이는 enclave EIF를 구축하고 저장할 때 이전에 접한 적이 있습니다.

[**docs**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves)에서, 다음은 PCR 값입니다:

<table><thead><tr><th width="97">PCR</th><th width="221">해시 ...</th><th>설명</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave 이미지 파일</td><td>섹션 데이터 없이 이미지 파일의 내용에 대한 연속적인 측정값입니다.</td></tr><tr><td>PCR1</td><td>Linux 커널 및 부트스트랩</td><td>커널 및 부트 ramfs 데이터에 대한 연속적인 측정값입니다.</td></tr><tr><td>PCR2</td><td>애플리케이션</td><td>부트 ramfs 없이 사용자 애플리케이션에 대한 연속적이고 순서가 있는 측정값입니다.</td></tr><tr><td>PCR3</td><td>부모 인스턴스에 할당된 IAM 역할</td><td>부모 인스턴스에 할당된 IAM 역할에 대한 연속적인 측정값입니다. 부모 인스턴스가 올바른 IAM 역할을 가질 때만 증명 과정이 성공하도록 보장합니다.</td></tr><tr><td>PCR4</td><td>부모 인스턴스의 인스턴스 ID</td><td>부모 인스턴스의 ID에 대한 연속적인 측정값입니다. 부모 인스턴스가 특정 인스턴스 ID를 가질 때만 증명 과정이 성공하도록 보장합니다.</td></tr><tr><td>PCR8</td><td>Enclave 이미지 파일 서명 인증서</td><td>enclave 이미지 파일에 대해 지정된 서명 인증서의 측정값입니다. 특정 인증서로 서명된 enclave 이미지 파일에서 부팅된 경우에만 증명 과정이 성공하도록 보장합니다.</td></tr></tbody></table>

**암호학적 증명**을 애플리케이션에 통합하고 **AWS KMS**와 같은 서비스와의 사전 구축된 통합을 활용할 수 있습니다. AWS KMS는 **enclave 증명**을 **검증**할 수 있으며, 키 정책에서 증명 기반 조건 키(`kms:RecipientAttestation:ImageSha384` 및 `kms:RecipientAttestation:PCR`)를 제공합니다. 이러한 정책은 AWS KMS가 KMS 키를 사용한 작업을 **enclave의 증명 문서가 유효하고 지정된 조건을 충족할 때만** 허용하도록 보장합니다.

> [!TIP]
> 디버그(--debug) 모드에서 Enclaves는 제로(`000000000000000000000000000000000000000000000000`)로 구성된 PCR을 가진 증명 문서를 생성합니다. 따라서 이러한 값을 확인하는 KMS 정책은 실패할 것입니다.

### PCR 우회

공격자의 관점에서, 일부 PCR이 enclave 이미지의 일부 또는 전체를 수정할 수 있도록 허용하고 여전히 유효할 수 있음을 주목하십시오(예: PCR4는 부모 인스턴스의 ID만 확인하므로 해당 EC2에서 어떤 enclave 이미지든 실행하면 이 잠재적인 PCR 요구 사항을 충족할 수 있습니다).

따라서 EC2 인스턴스를 손상시킨 공격자는 이러한 보호를 우회하기 위해 다른 enclave 이미지를 실행할 수 있을 것입니다.

각 보호를 우회하기 위해 새로운 이미지를 수정/생성하는 방법에 대한 연구(특히 그리 명백하지 않은 것들)는 여전히 TODO입니다.

## References

- [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
- AWS의 Nitro 튜토리얼 모든 부분: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{{#include ../../../../banners/hacktricks-training.md}}
