# AWS - S3、Athena 与 Glacier 枚举

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 是一项服务，允许你 **存储大量数据**。

Amazon S3 提供多种选项以实现静态数据（data at REST）的 **保护**。这些选项包括 **Permission**（Policy）、**Encryption**（客户端和服务端）、**Bucket Versioning** 以及 **MFA** **based delete**。**用户可以启用** 这些选项中的任意一项来实现数据保护。**Data replication** 是 AWS 的一项内部功能，**S3 自动在所有 Availability Zones 之间复制每个对象**，在这种情况下组织无需手动启用它。

使用基于资源的权限，可以为 bucket 的子目录单独定义权限。

### Bucket Versioning and MFA based delete

当 bucket versioning 被启用时，任何尝试修改桶内文件的操作都会生成该文件的新版本，同时保留先前的内容。因此，不会覆盖原有内容。

此外，MFA based delete 会阻止 S3 bucket 中的文件版本被删除，并阻止 Bucket Versioning 被禁用，因此攻击者无法更改这些文件。

### S3 Access logs

可以 **启用 S3 access logging**（默认情况下关闭）到某个 bucket，并将日志保存到另一个 bucket，以便知道谁在访问该 bucket（两个 bucket 必须位于相同区域）。

### S3 Presigned URLs

可以生成 presigned URL，通常可用于 **访问 bucket 中指定的文件**。一个 **presigned URL 看起来像这样**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
presigned URL 可以 **从 cli 使用具有对该 object 访问权限的 principal 的 credentials 创建**（如果你使用的 account 没有访问权限，会创建一个更短的 presigned URL，但它将无用）
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> 生成 presigned URL 所需的唯一权限就是被授予的权限，所以在前面的命令中，主体唯一需要的权限是 `s3:GetObject`

也可以使用 **其他权限** 创建 presigned URLs：
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 Encryption Mechanisms

**DEK 表示 Data Encryption Key（数据加密密钥）**，是始终生成并用于加密数据的密钥。

<details>

<summary><strong>使用 S3 管理密钥的服务器端加密，SSE-S3</strong></summary>

此选项仅需最少配置，使用的加密密钥的所有管理由 AWS 负责。你只需 **上传你的数据，S3 会处理其他所有方面**。每个 S3 账户中的 bucket 都分配有一个 bucket key。

- 加密：
- Object Data + 创建的明文 DEK --> 加密数据（存储在 S3 内）
- 创建的明文 DEK + S3 Master Key --> 加密的 DEK（存储在 S3 内），明文从内存中删除
- 解密：
- 加密的 DEK + S3 Master Key --> 明文 DEK
- 明文 DEK + 加密数据 --> 对象数据

请注意，在此情况下 **密钥由 AWS 管理**（仅每 3 年轮换一次）。如果你使用自己的密钥，你将能够轮换、禁用并应用访问控制。

</details>

<details>

<summary><strong>使用 KMS 管理密钥的服务器端加密，SSE-KMS</strong></summary>

此方法允许 S3 使用 KMS 来生成你的数据加密密钥。KMS 在密钥管理方面提供更大的灵活性。例如，你可以禁用、轮换并对 CMK 应用访问控制，并使用 AWS CloudTrail 对其使用情况进行审计。

- 加密：
- S3 向 KMS 的 CMK 请求数据密钥
- KMS 使用 CMK 生成 DEK 明文和加密的 DEK 对，并将它们发送到 S3
- S3 使用明文密钥加密数据，存储加密的数据和加密的密钥，并从内存中删除明文密钥
- 解密：
- S3 请求 KMS 解密该对象的加密数据密钥
- KMS 使用 CMK 解密数据密钥并将其返回给 S3
- S3 解密对象数据

</details>

<details>

<summary><strong>使用客户提供密钥的服务器端加密，SSE-C</strong></summary>

此选项允许你提供在 AWS 之外可能已经使用的主密钥。客户提供的密钥会随数据一起发送到 S3，由 S3 为你执行加密。

- 加密：
- 用户将对象数据 + 客户密钥发送到 S3
- 使用客户密钥对数据进行加密，并存储加密后的数据
- 还会存储客户密钥的带盐 HMAC 值以便将来验证密钥
- 客户密钥从内存中删除
- 解密：
- 用户发送客户密钥
- 密钥与存储的 HMAC 值进行验证
- 然后使用客户提供的密钥来解密数据

</details>

<details>

<summary><strong>使用 KMS 的客户端加密，CSE-KMS</strong></summary>

与 SSE-KMS 类似，此方式也使用 KMS 来生成你的数据加密密钥。但这次是通过客户端调用 KMS，而不是 S3。加密在客户端进行，然后将加密后的数据发送到 S3 存储。

- 加密：
- 客户端向 KMS 请求数据密钥
- KMS 返回明文 DEK 和使用 CMK 加密的 DEK
- 两个密钥都会返回给客户端
- 客户端使用明文 DEK 对数据进行加密，然后将加密的数据 + 加密的 DEK 发送到 S3（该加密的 DEK 作为加密数据的元数据保存在 S3 中）
- 解密：
- 带有加密 DEK 的加密数据被发送到客户端
- 客户端请求 KMS 使用 CMK 解密该加密密钥，KMS 将明文 DEK 返回
- 客户端现在可以解密加密数据

</details>

<details>

<summary><strong>使用客户提供密钥的客户端加密，CSE-C</strong></summary>

使用此机制，你可以使用自己的密钥并通过 AWS-SDK 客户端在将数据发送到 S3 存储之前对其进行加密。

- 加密：
- 客户端生成 DEK 并加密明文数据
- 然后使用其自己的自定义 CMK 对 DEK 进行加密
- 将加密的数据 + 加密的 DEK 提交到 S3 并存储
- 解密：
- S3 发送加密的数据和 DEK
- 由于客户端已经拥有用于加密 DEK 的 CMK，它解密 DEK，然后使用明文 DEK 解密数据

</details>

### **枚举**

渗透 AWS 组织的传统主要方式之一是入侵公开可访问的 buckets。 **你可以在此页面找到** [**public buckets enumerators in this page**](../aws-unauthenticated-enum-access/index.html#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

你可以通过 dual-stack 终端节点访问 S3 bucket，方法是使用 virtual hosted-style 或 path-style 的 endpoint 名称。这些对于通过 IPv6 访问 S3 很有用。

Dual-stack endpoints 使用以下语法：

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

在下面的页面中你可以查看如何 **abuse S3 permissions to escalate privileges**：

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc/README.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum/README.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation/README.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence/README.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**According to this research**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) 可以将任意 bucket 的响应缓存为好像属于另一个 bucket。这可以被滥用来修改例如 javascript 文件的响应，从而破坏使用 S3 存储静态代码的任意页面。

## Amazon Athena

Amazon Athena 是一个交互式查询服务，使得可以使用标准 **SQL** 直接在 Amazon Simple Storage Service (Amazon **S3**) 中 **使用** **分析数据**。

你需要**准备一个关系型 DB 表**，该表的格式应与将出现在被监控 S3 buckets 中的内容相匹配。然后，Amazon Athena 将能够从日志中填充该 DB，以便你进行查询。

Amazon Athena 支持**查询已加密的 S3 数据**的能力，并且如果配置为这样，**Athena 也可以加密查询结果，然后将其存储到 S3 中**。

**查询结果的加密独立于被查询的底层 S3 数据**，这意味着即使 S3 数据未加密，查询结果也可以被加密。需要注意的是，Amazon Athena 仅支持使用**以下 S3 加密方法**进行**加密**的数据：**SSE-S3、SSE-KMS 和 CSE-KMS**。

SSE-C 和 CSE-C 不受支持。此外，需要理解的是 Amazon Athena 只会对**已加密且位于与查询本身相同 region 的对象**运行查询。如果你需要查询使用 KMS 加密的 S3 数据，则 Athena 用户需要特定权限才能执行该查询。

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## 参考资料

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
