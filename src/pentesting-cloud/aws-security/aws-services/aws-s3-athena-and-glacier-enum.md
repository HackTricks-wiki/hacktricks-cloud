# AWS - S3, Athena & Glacier Enum

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 - це сервіс, який дозволяє вам **зберігати великі обсяги даних**.

Amazon S3 надає кілька варіантів для досягнення **захисту** даних у спокої. Варіанти включають **Дозволи** (Політика), **Шифрування** (Клієнтське та Серверне), **Версійність бакетів** та **MFA** **на основі видалення**. **Користувач може увімкнути** будь-який з цих варіантів для досягнення захисту даних. **Реплікація даних** - це внутрішня функція AWS, де **S3 автоматично реплікує кожен об'єкт по всіх зонах доступності**, і організації не потрібно її вмикати в цьому випадку.

З дозволами на основі ресурсів ви можете визначити дозволи для підкаталогів вашого бакету окремо.

### Версійність бакетів та видалення на основі MFA

Коли версійність бакетів увімкнена, будь-яка дія, яка намагається змінити файл всередині файлу, створить нову версію файлу, зберігаючи також попередній вміст того ж файлу. Тому, він не перезапише свій вміст.

Більше того, видалення на основі MFA запобігатиме видаленню версій файлів у бакеті S3, а також відключенню версійності бакетів, тому зловмисник не зможе змінити ці файли.

### Журнали доступу S3

Можливо **увімкнути журнали доступу S3** (які за замовчуванням вимкнені) для деякого бакету та зберігати журнали в іншому бакеті, щоб дізнатися, хто отримує доступ до бакету (обидва бакети повинні бути в одному регіоні).

### Пресигновані URL-адреси S3

Можливо згенерувати пресигновану URL-адресу, яка зазвичай може бути використана для **доступу до вказаного файлу** в бакеті. **Пресигнована URL-адреса виглядає так**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
URL з попереднім підписом може бути **створено з cli, використовуючи облікові дані суб'єкта, який має доступ до об'єкта** (якщо обліковий запис, який ви використовуєте, не має доступу, буде створено коротший URL з попереднім підписом, але він буде марним)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> Єдине необхідне дозволення для генерації попередньо підписаного URL - це надане дозволення, тому для попередньої команди єдине дозволення, яке потрібно суб'єкту, - це `s3:GetObject`

Також можливо створювати попередньо підписані URL з **іншими дозволеннями**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 Encryption Mechanisms

**DEK означає Ключ Шифрування Даних** і є ключем, який завжди генерується та використовується для шифрування даних.

<details>

<summary><strong>Шифрування на стороні сервера з ключами, керованими S3, SSE-S3</strong></summary>

Цей варіант вимагає мінімальної конфігурації, і все управління ключами шифрування здійснюється AWS. Все, що вам потрібно зробити, це **завантажити свої дані, і S3 впорається з усіма іншими аспектами**. Кожному бакету в обліковому записі S3 призначається ключ бакету.

- Шифрування:
- Дані об'єкта + створений відкритий DEK --> Зашифровані дані (зберігаються в S3)
- Створений відкритий DEK + Майстер-ключ S3 --> Зашифрований DEK (зберігається в S3) і відкритий текст видаляється з пам'яті
- Розшифрування:
- Зашифрований DEK + Майстер-ключ S3 --> Відкритий DEK
- Відкритий DEK + Зашифровані дані --> Дані об'єкта

Зверніть увагу, що в цьому випадку **ключ управляється AWS** (обертання лише кожні 3 роки). Якщо ви використовуєте свій власний ключ, ви зможете обертати, відключати та застосовувати контроль доступу.

</details>

<details>

<summary><strong>Шифрування на стороні сервера з ключами, керованими KMS, SSE-KMS</strong></summary>

Цей метод дозволяє S3 використовувати службу управління ключами для генерації ваших ключів шифрування даних. KMS надає вам значно більшу гнучкість у тому, як управляються ваші ключі. Наприклад, ви можете відключати, обертати та застосовувати контроль доступу до CMK, а також контролювати їх використання за допомогою AWS Cloud Trail.

- Шифрування:
- S3 запитує ключі даних у KMS CMK
- KMS використовує CMK для генерації пари відкритого DEK і зашифрованого DEK та надсилає їх до S3
- S3 використовує відкритий ключ для шифрування даних, зберігає зашифровані дані та зашифрований ключ і видаляє з пам'яті відкритий ключ
- Розшифрування:
- S3 запитує KMS для розшифрування зашифрованого ключа даних об'єкта
- KMS розшифровує ключ даних за допомогою CMK і надсилає його назад до S3
- S3 розшифровує дані об'єкта

</details>

<details>

<summary><strong>Шифрування на стороні сервера з ключами, наданими клієнтом, SSE-C</strong></summary>

Цей варіант дає вам можливість надати свій власний майстер-ключ, який ви, можливо, вже використовуєте поза AWS. Ваш ключ, наданий клієнтом, буде надіслано разом з вашими даними до S3, де S3 виконає шифрування для вас.

- Шифрування:
- Користувач надсилає дані об'єкта + Ключ клієнта до S3
- Ключ клієнта використовується для шифрування даних, і зашифровані дані зберігаються
- також зберігається значення HMAC з сіллю ключа клієнта для майбутньої валідації ключа
- ключ клієнта видаляється з пам'яті
- Розшифрування:
- Користувач надсилає ключ клієнта
- Ключ перевіряється на відповідність збереженому значенню HMAC
- Ключ, наданий клієнтом, потім використовується для розшифрування даних

</details>

<details>

<summary><strong>Шифрування на стороні клієнта з KMS, CSE-KMS</strong></summary>

Аналогічно до SSE-KMS, цей метод також використовує службу управління ключами для генерації ваших ключів шифрування даних. Однак цього разу KMS викликається через клієнта, а не S3. Шифрування відбувається на стороні клієнта, а зашифровані дані надсилаються до S3 для зберігання.

- Шифрування:
- Клієнт запитує ключ даних у KMS
- KMS повертає відкритий DEK і зашифрований DEK з CMK
- Обидва ключі надсилаються назад
- Клієнт шифрує дані за допомогою відкритого DEK і надсилає до S3 зашифровані дані + зашифрований DEK (який зберігається як метадані зашифрованих даних у S3)
- Розшифрування:
- Зашифровані дані з зашифрованим DEK надсилаються клієнту
- Клієнт запитує KMS для розшифрування зашифрованого ключа за допомогою CMK, і KMS надсилає назад відкритий DEK
- Тепер клієнт може розшифрувати зашифровані дані

</details>

<details>

<summary><strong>Шифрування на стороні клієнта з ключами, наданими клієнтом, CSE-C</strong></summary>

Використовуючи цей механізм, ви можете використовувати свої власні надані ключі та використовувати клієнт AWS-SDK для шифрування ваших даних перед їх надсиланням до S3 для зберігання.

- Шифрування:
- Клієнт генерує DEK і шифрує відкриті дані
- Потім, використовуючи свій власний кастомний CMK, він шифрує DEK
- надсилає зашифровані дані + зашифрований DEK до S3, де вони зберігаються
- Розшифрування:
- S3 надсилає зашифровані дані та DEK
- Оскільки клієнт вже має CMK, використаний для шифрування DEK, він розшифровує DEK, а потім використовує відкритий DEK для розшифрування даних

</details>

### **Перерахування**

Один з традиційних основних способів компрометації організацій AWS починається з компрометації бакетів, які є публічно доступними. **Ви можете знайти** [**перерахувачі публічних бакетів на цій сторінці**](../aws-unauthenticated-enum-access/#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

Ви можете отримати доступ до S3 бакету через двосторонній кінцевий пункт, використовуючи віртуальне ім'я кінцевого пункту в стилі хостингу або в стилі шляху. Це корисно для доступу до S3 через IPv6.

Двосторонні кінцеві пункти використовують наступний синтаксис:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

На наступній сторінці ви можете перевірити, як **зловживати дозволами S3 для ескалації привілеїв**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**Згідно з цим дослідженням**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) було можливим кешувати відповідь довільного бакету так, ніби вона належала іншому. Це могло бути зловжито для зміни, наприклад, відповідей файлів javascript і компрометації довільних сторінок, що використовують S3 для зберігання статичного коду.

## Amazon Athena

Amazon Athena — це інтерактивний сервіс запитів, який спрощує **аналіз даних** безпосередньо в Amazon Simple Storage Service (Amazon **S3**) **використовуючи** стандартний **SQL**.

Вам потрібно **підготувати реляційну таблицю БД** з форматом вмісту, який з'явиться в моніторингових S3 бакетах. А потім Amazon Athena зможе заповнити БД з журналів, щоб ви могли запитувати її.

Amazon Athena підтримує **можливість запитувати дані S3, які вже зашифровані**, і якщо це налаштовано, **Athena також може зашифровувати результати запиту, які потім можуть бути збережені в S3**.

**Ця шифрація результатів незалежна від основних запитуваних даних S3**, що означає, що навіть якщо дані S3 не зашифровані, запитувані результати можуть бути зашифровані. Кілька моментів, про які слід пам'ятати, це те, що Amazon Athena підтримує лише дані, які були **зашифровані** за допомогою **наступних методів шифрування S3**, **SSE-S3, SSE-KMS та CSE-KMS**.

SSE-C та CSE-E не підтримуються. Крім того, важливо розуміти, що Amazon Athena буде виконувати запити лише проти **зашифрованих об'єктів, які знаходяться в тому ж регіоні, що й сам запит**. Якщо вам потрібно запитати дані S3, які були зашифровані за допомогою KMS, тоді користувачу Athena потрібні специфічні дозволи, щоб дозволити їм виконати запит.

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## Посилання

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
