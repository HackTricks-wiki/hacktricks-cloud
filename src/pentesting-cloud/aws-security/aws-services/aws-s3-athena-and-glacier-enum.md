# AWS - S3, Athena & Glacier Enum

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 एक सेवा है जो आपको **बड़े मात्रा में डेटा** **स्टोर** करने की अनुमति देती है।

Amazon S3 डेटा को REST में **सुरक्षित** करने के लिए कई विकल्प प्रदान करता है। विकल्पों में **अनुमति** (नीति), **एन्क्रिप्शन** (क्लाइंट और सर्वर साइड), **बकेट संस्करणन** और **MFA** **आधारित हटाना** शामिल हैं। **उपयोगकर्ता इन विकल्पों में से किसी को भी सक्षम कर सकता है** ताकि डेटा सुरक्षा प्राप्त की जा सके। **डेटा प्रतिकृति** AWS द्वारा एक आंतरिक सुविधा है जहां **S3 स्वचालित रूप से प्रत्येक वस्तु को सभी उपलब्धता क्षेत्रों में प्रतिकृत करता है** और इस मामले में संगठन को इसे सक्षम करने की आवश्यकता नहीं है।

संसाधन-आधारित अनुमतियों के साथ, आप अपने बकेट के उप-निर्देशिकाओं के लिए अनुमतियों को अलग से परिभाषित कर सकते हैं।

### बकेट संस्करणन और MFA आधारित हटाना

जब बकेट संस्करणन सक्षम होता है, तो कोई भी क्रिया जो एक फ़ाइल के अंदर एक फ़ाइल को बदलने की कोशिश करती है, फ़ाइल का एक नया संस्करण उत्पन्न करेगी, साथ ही उसी की पिछली सामग्री को भी बनाए रखेगी। इसलिए, यह इसकी सामग्री को अधिलेखित नहीं करेगा।

इसके अलावा, MFA आधारित हटाना S3 बकेट में फ़ाइल के संस्करणों को हटाने से रोकेगा और बकेट संस्करणन को अक्षम करने से भी रोकेगा, इसलिए एक हमलावर इन फ़ाइलों को बदल नहीं सकेगा।

### S3 एक्सेस लॉग

यह संभव है कि आप कुछ बकेट के लिए **S3 एक्सेस लॉगिन** (जो डिफ़ॉल्ट रूप से अक्षम है) को **सक्षम** करें और लॉग को एक अलग बकेट में सहेजें ताकि यह पता चल सके कि कौन बकेट का उपयोग कर रहा है (दोनों बकेट को एक ही क्षेत्र में होना चाहिए)।

### S3 प्रीसाइनड URLs

यह संभव है कि आप एक प्रीसाइनड URL उत्पन्न करें जिसे आमतौर पर बकेट में **निर्धारित फ़ाइल** तक पहुँचने के लिए उपयोग किया जा सकता है। एक **प्रीसाइनड URL इस तरह दिखता है**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
एक प्री-साइन किया गया URL **CLI से उस प्रिंसिपल के क्रेडेंशियल्स का उपयोग करके बनाया जा सकता है जिसके पास ऑब्जेक्ट तक पहुंच है** (यदि आप जिस खाते का उपयोग करते हैं, उसके पास पहुंच नहीं है, तो एक छोटा प्री-साइन किया गया URL बनाया जाएगा लेकिन यह बेकार होगा)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> एक प्रीसाइन किए गए URL को उत्पन्न करने के लिए केवल आवश्यक अनुमति वह अनुमति है जो दी जा रही है, इसलिए पिछले कमांड के लिए मुख्य व्यक्ति को केवल `s3:GetObject` की अनुमति की आवश्यकता है।

यह **अन्य अनुमतियों** के साथ प्रीसाइन किए गए URLs बनाने के लिए भी संभव है:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 एन्क्रिप्शन तंत्र

**DEK का मतलब डेटा एन्क्रिप्शन कुंजी** है और यह कुंजी है जो हमेशा उत्पन्न होती है और डेटा को एन्क्रिप्ट करने के लिए उपयोग की जाती है।

<details>

<summary><strong>सर्वर-साइड एन्क्रिप्शन S3 प्रबंधित कुंजियों के साथ, SSE-S3</strong></summary>

यह विकल्प न्यूनतम कॉन्फ़िगरेशन की आवश्यकता है और उपयोग की जाने वाली एन्क्रिप्शन कुंजियों का सभी प्रबंधन AWS द्वारा प्रबंधित किया जाता है। आपको केवल **अपने डेटा को अपलोड करना है और S3 सभी अन्य पहलुओं को संभालेगा**। S3 खाते में प्रत्येक बाल्टी को एक बाल्टी कुंजी सौंपा जाता है।

- एन्क्रिप्शन:
- ऑब्जेक्ट डेटा + उत्पन्न प्लेनटेक्स्ट DEK --> एन्क्रिप्टेड डेटा (S3 के अंदर संग्रहीत)
- उत्पन्न प्लेनटेक्स्ट DEK + S3 मास्टर कुंजी --> एन्क्रिप्टेड DEK (S3 के अंदर संग्रहीत) और प्लेन टेक्स्ट मेमोरी से हटा दिया जाता है
- डिक्रिप्शन:
- एन्क्रिप्टेड DEK + S3 मास्टर कुंजी --> प्लेनटेक्स्ट DEK
- प्लेनटेक्स्ट DEK + एन्क्रिप्टेड डेटा --> ऑब्जेक्ट डेटा

कृपया ध्यान दें कि इस मामले में **कुंजी AWS द्वारा प्रबंधित की जाती है** (रोटेशन केवल हर 3 वर्ष में)। यदि आप अपनी कुंजी का उपयोग करते हैं, तो आप रोटेट, अक्षम और एक्सेस नियंत्रण लागू कर सकेंगे।

</details>

<details>

<summary><strong>सर्वर-साइड एन्क्रिप्शन KMS प्रबंधित कुंजियों के साथ, SSE-KMS</strong></summary>

यह विधि S3 को कुंजी प्रबंधन सेवा का उपयोग करके आपकी डेटा एन्क्रिप्शन कुंजियों को उत्पन्न करने की अनुमति देती है। KMS आपको अपनी कुंजियों के प्रबंधन के लिए बहुत अधिक लचीलापन देता है। उदाहरण के लिए, आप CMK को अक्षम, रोटेट और एक्सेस नियंत्रण लागू कर सकते हैं, और AWS क्लाउड ट्रेल का उपयोग करके उनके उपयोग के खिलाफ आदेश दे सकते हैं।

- एन्क्रिप्शन:
- S3 KMS CMK से डेटा कुंजी का अनुरोध करता है
- KMS एक CMK का उपयोग करके DEK प्लेनटेक्स्ट और DEK एन्क्रिप्टेड जोड़ी उत्पन्न करता है और उन्हें S3 को भेजता है
- S3 प्लेनटेक्स्ट कुंजी का उपयोग करके डेटा को एन्क्रिप्ट करता है, एन्क्रिप्टेड डेटा और एन्क्रिप्टेड कुंजी को संग्रहीत करता है और मेमोरी से प्लेनटेक्स्ट कुंजी को हटा देता है
- डिक्रिप्शन:
- S3 KMS से ऑब्जेक्ट के एन्क्रिप्टेड डेटा कुंजी को डिक्रिप्ट करने के लिए पूछता है
- KMS CMK के साथ डेटा कुंजी को डिक्रिप्ट करता है और इसे S3 को वापस भेजता है
- S3 ऑब्जेक्ट डेटा को डिक्रिप्ट करता है

</details>

<details>

<summary><strong>सर्वर-साइड एन्क्रिप्शन ग्राहक द्वारा प्रदान की गई कुंजियों के साथ, SSE-C</strong></summary>

यह विकल्प आपको अपनी मास्टर कुंजी प्रदान करने का अवसर देता है जिसे आप पहले से AWS के बाहर उपयोग कर रहे होंगे। आपकी ग्राहक द्वारा प्रदान की गई कुंजी फिर आपके डेटा के साथ S3 को भेजी जाएगी, जहां S3 आपके लिए एन्क्रिप्शन करेगा।

- एन्क्रिप्शन:
- उपयोगकर्ता ऑब्जेक्ट डेटा + ग्राहक कुंजी को S3 को भेजता है
- ग्राहक कुंजी का उपयोग डेटा को एन्क्रिप्ट करने के लिए किया जाता है और एन्क्रिप्टेड डेटा संग्रहीत किया जाता है
- भविष्य की कुंजी मान्यता के लिए ग्राहक कुंजी का एक सॉल्टेड HMAC मान भी संग्रहीत किया जाता है
- ग्राहक कुंजी को मेमोरी से हटा दिया जाता है
- डिक्रिप्शन:
- उपयोगकर्ता ग्राहक कुंजी भेजता है
- कुंजी को संग्रहीत HMAC मान के खिलाफ मान्य किया जाता है
- ग्राहक द्वारा प्रदान की गई कुंजी का उपयोग डेटा को डिक्रिप्ट करने के लिए किया जाता है

</details>

<details>

<summary><strong>क्लाइंट-साइड एन्क्रिप्शन KMS के साथ, CSE-KMS</strong></summary>

SSE-KMS के समान, यह भी आपकी डेटा एन्क्रिप्शन कुंजियों को उत्पन्न करने के लिए कुंजी प्रबंधन सेवा का उपयोग करता है। हालाँकि, इस बार KMS को क्लाइंट के माध्यम से बुलाया जाता है न कि S3 के माध्यम से। एन्क्रिप्शन फिर क्लाइंट-साइड होता है और एन्क्रिप्टेड डेटा को S3 को संग्रहीत करने के लिए भेजा जाता है।

- एन्क्रिप्शन:
- क्लाइंट KMS से डेटा कुंजी का अनुरोध करता है
- KMS प्लेनटेक्स्ट DEK और CMK के साथ एन्क्रिप्टेड DEK लौटाता है
- दोनों कुंजियाँ वापस भेजी जाती हैं
- क्लाइंट फिर प्लेनटेक्स्ट DEK के साथ डेटा को एन्क्रिप्ट करता है और S3 को एन्क्रिप्टेड डेटा + एन्क्रिप्टेड DEK (जो S3 के अंदर एन्क्रिप्टेड डेटा के मेटाडेटा के रूप में सहेजा जाता है) भेजता है
- डिक्रिप्शन:
- एन्क्रिप्टेड डेटा और एन्क्रिप्टेड DEK क्लाइंट को भेजा जाता है
- क्लाइंट KMS से CMK का उपयोग करके एन्क्रिप्टेड कुंजी को डिक्रिप्ट करने के लिए पूछता है और KMS प्लेनटेक्स्ट DEK वापस भेजता है
- क्लाइंट अब एन्क्रिप्टेड डेटा को डिक्रिप्ट कर सकता है

</details>

<details>

<summary><strong>क्लाइंट-साइड एन्क्रिप्शन ग्राहक द्वारा प्रदान की गई कुंजियों के साथ, CSE-C</strong></summary>

इस तंत्र का उपयोग करते हुए, आप अपनी प्रदान की गई कुंजियों का उपयोग कर सकते हैं और S3 के लिए डेटा भेजने से पहले अपने डेटा को एन्क्रिप्ट करने के लिए AWS-SDK क्लाइंट का उपयोग कर सकते हैं।

- एन्क्रिप्शन:
- क्लाइंट एक DEK उत्पन्न करता है और प्लेनटेक्स्ट डेटा को एन्क्रिप्ट करता है
- फिर, अपनी कस्टम CMK का उपयोग करके DEK को एन्क्रिप्ट करता है
- एन्क्रिप्टेड डेटा + एन्क्रिप्टेड DEK को S3 में जमा करता है जहां इसे संग्रहीत किया जाता है
- डिक्रिप्शन:
- S3 एन्क्रिप्टेड डेटा और DEK भेजता है
- चूंकि क्लाइंट के पास पहले से DEK को एन्क्रिप्ट करने के लिए उपयोग की गई CMK है, यह DEK को डिक्रिप्ट करता है और फिर प्लेनटेक्स्ट DEK का उपयोग करके डेटा को डिक्रिप्ट करता है

</details>

### **गणना**

AWS संगठनों से समझौता करने के पारंपरिक मुख्य तरीकों में से एक सार्वजनिक रूप से सुलभ बाल्टियों से समझौता करना शुरू होता है। **आप पा सकते हैं** [**सार्वजनिक बाल्टी गणक इस पृष्ठ पर**](../aws-unauthenticated-enum-access/#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

आप एक S3 बकेट को डुअल-स्टैक एंडपॉइंट के माध्यम से वर्चुअल होस्टेड-स्टाइल या पाथ-स्टाइल एंडपॉइंट नाम का उपयोग करके एक्सेस कर सकते हैं। ये IPv6 के माध्यम से S3 तक पहुँचने के लिए उपयोगी हैं।

डुअल-स्टैक एंडपॉइंट निम्नलिखित सिंटैक्स का उपयोग करते हैं:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

अगली पृष्ठ में आप **S3 अनुमतियों का दुरुपयोग करके विशेषाधिकार बढ़ाने** के तरीके की जांच कर सकते हैं:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**इस शोध के अनुसार**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) यह संभव था कि किसी मनमाने बकेट के उत्तर को इस तरह कैश किया जाए जैसे कि यह किसी अन्य का हो। इसका दुरुपयोग करके उदाहरण के लिए जावास्क्रिप्ट फ़ाइल के उत्तरों को बदलना और S3 का उपयोग करके स्थिर कोड को स्टोर करने वाले मनमाने पृष्ठों को समझौता करना संभव था।

## Amazon Athena

Amazon Athena एक इंटरएक्टिव क्वेरी सेवा है जो **डेटा का विश्लेषण** करना आसान बनाती है सीधे Amazon Simple Storage Service (Amazon **S3**) **का उपयोग करके** मानक **SQL**।

आपको **एक रिलेशनल DB टेबल तैयार करने** की आवश्यकता है जिसमें उस सामग्री का प्रारूप हो जो निगरानी किए गए S3 बकेट में दिखाई देने वाली है। और फिर, Amazon Athena लॉग से DB को भरने में सक्षम होगी, ताकि आप इसे क्वेरी कर सकें।

Amazon Athena **पहले से एन्क्रिप्टेड S3 डेटा को क्वेरी करने की क्षमता का समर्थन करती है** और यदि इसे इस तरह से कॉन्फ़िगर किया गया है, तो **Athena क्वेरी के परिणामों को भी एन्क्रिप्ट कर सकती है जिन्हें फिर S3 में स्टोर किया जा सकता है**।

**परिणामों का यह एन्क्रिप्शन आधारभूत क्वेरी किए गए S3 डेटा से स्वतंत्र है**, जिसका अर्थ है कि भले ही S3 डेटा एन्क्रिप्ट न हो, क्वेरी किए गए परिणाम एन्क्रिप्ट किए जा सकते हैं। कुछ बिंदुओं पर ध्यान देने की आवश्यकता है कि Amazon Athena केवल उन डेटा का समर्थन करती है जो **निम्नलिखित S3 एन्क्रिप्शन विधियों** के साथ **एन्क्रिप्टेड** हैं, **SSE-S3, SSE-KMS, और CSE-KMS**।

SSE-C और CSE-E का समर्थन नहीं किया जाता है। इसके अलावा, यह समझना महत्वपूर्ण है कि Amazon Athena केवल **एन्क्रिप्टेड ऑब्जेक्ट्स पर क्वेरी चलाएगी जो क्वेरी के स्वयं के क्षेत्र में हैं**। यदि आपको KMS का उपयोग करके एन्क्रिप्टेड S3 डेटा को क्वेरी करने की आवश्यकता है, तो क्वेरी करने के लिए Athena उपयोगकर्ता द्वारा विशिष्ट अनुमतियों की आवश्यकता होती है।

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## संदर्भ

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
