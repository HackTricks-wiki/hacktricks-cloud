# AWS - S3, Athena & Glacier Enum

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 to usługa, która pozwala **przechowywać duże ilości danych**.

Amazon S3 oferuje wiele opcji, aby osiągnąć **ochronę** danych w spoczynku. Opcje te obejmują **Uprawnienia** (Polityka), **Szyfrowanie** (po stronie klienta i serwera), **Wersjonowanie kubełków** oraz **usuwanie** oparte na **MFA**. **Użytkownik może włączyć** dowolną z tych opcji, aby osiągnąć ochronę danych. **Replikacja danych** to wewnętrzna funkcja AWS, w której **S3 automatycznie replikuje każdy obiekt we wszystkich Strefach Dostępności**, a organizacja nie musi jej włączać w tym przypadku.

Dzięki uprawnieniom opartym na zasobach możesz definiować uprawnienia dla podkatalogów swojego kubełka osobno.

### Wersjonowanie kubełków i usuwanie oparte na MFA

Gdy wersjonowanie kubełków jest włączone, każda akcja, która próbuje zmienić plik wewnątrz pliku, wygeneruje nową wersję pliku, zachowując również poprzednią zawartość tego samego. Dlatego nie nadpisze jego zawartości.

Ponadto, usuwanie oparte na MFA zapobiegnie usunięciu wersji pliku w kubełku S3 oraz wyłączeniu wersjonowania kubełków, więc atakujący nie będzie mógł zmienić tych plików.

### Dzienniki dostępu S3

Możliwe jest **włączenie logowania dostępu S3** (które domyślnie jest wyłączone) dla niektórego kubełka i zapisanie logów w innym kubełku, aby wiedzieć, kto uzyskuje dostęp do kubełka (oba kubełki muszą znajdować się w tym samym regionie).

### Pre-signed URLs S3

Możliwe jest wygenerowanie pre-signed URL, który zazwyczaj może być używany do **uzyskania dostępu do określonego pliku** w kubełku. **Pre-signed URL wygląda tak**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
URL z wcześniejszym podpisem może być **stworzony z cli przy użyciu poświadczeń podmiotu mającego dostęp do obiektu** (jeśli konto, którego używasz, nie ma dostępu, zostanie utworzony krótszy URL z wcześniejszym podpisem, ale będzie bezużyteczny)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> Jedynym wymaganym uprawnieniem do wygenerowania presigned URL jest przyznane uprawnienie, więc dla poprzedniego polecenia jedynym wymaganym uprawnieniem przez podmiot jest `s3:GetObject`

Możliwe jest również tworzenie presigned URLs z **innymi uprawnieniami**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### Mechanizmy szyfrowania S3

**DEK oznacza Klucz Szyfrowania Danych** i jest kluczem, który zawsze jest generowany i używany do szyfrowania danych.

<details>

<summary><strong>Szyfrowanie po stronie serwera z użyciem kluczy zarządzanych przez S3, SSE-S3</strong></summary>

Ta opcja wymaga minimalnej konfiguracji, a zarządzanie kluczami szyfrowania jest realizowane przez AWS. Wszystko, co musisz zrobić, to **przesłać swoje dane, a S3 zajmie się wszystkimi innymi aspektami**. Każdemu koszykowi w koncie S3 przypisany jest klucz koszyka.

- Szyfrowanie:
- Dane obiektu + utworzony jawny DEK --> Szyfrowane dane (przechowywane w S3)
- Utworzony jawny DEK + Klucz Główny S3 --> Szyfrowany DEK (przechowywany w S3) i jawny tekst jest usuwany z pamięci
- Deszyfrowanie:
- Szyfrowany DEK + Klucz Główny S3 --> Jawny DEK
- Jawny DEK + Szyfrowane dane --> Dane obiektu

Proszę zauważyć, że w tym przypadku **klucz jest zarządzany przez AWS** (rotacja tylko co 3 lata). Jeśli użyjesz własnego klucza, będziesz mógł rotować, dezaktywować i stosować kontrolę dostępu.

</details>

<details>

<summary><strong>Szyfrowanie po stronie serwera z użyciem kluczy zarządzanych przez KMS, SSE-KMS</strong></summary>

Ta metoda pozwala S3 korzystać z usługi zarządzania kluczami do generowania kluczy szyfrowania danych. KMS daje znacznie większą elastyczność w zarządzaniu kluczami. Na przykład, możesz dezaktywować, rotować i stosować kontrole dostępu do CMK oraz monitorować ich użycie za pomocą AWS Cloud Trail.

- Szyfrowanie:
- S3 żąda kluczy danych od KMS CMK
- KMS używa CMK do generowania pary DEK jawnego i DEK szyfrowanego i wysyła je do S3
- S3 używa jawnego klucza do szyfrowania danych, przechowuje szyfrowane dane i szyfrowany klucz oraz usuwa z pamięci jawny klucz
- Deszyfrowanie:
- S3 prosi KMS o deszyfrowanie szyfrowanego klucza danych obiektu
- KMS deszyfruje klucz danych za pomocą CMK i wysyła go z powrotem do S3
- S3 deszyfruje dane obiektu

</details>

<details>

<summary><strong>Szyfrowanie po stronie serwera z użyciem kluczy dostarczonych przez klienta, SSE-C</strong></summary>

Ta opcja daje Ci możliwość dostarczenia własnego klucza głównego, którego możesz już używać poza AWS. Twój klucz dostarczony przez klienta zostanie następnie wysłany z danymi do S3, gdzie S3 wykona szyfrowanie za Ciebie.

- Szyfrowanie:
- Użytkownik wysyła dane obiektu + Klucz Klienta do S3
- Klucz klienta jest używany do szyfrowania danych, a szyfrowane dane są przechowywane
- również przechowywana jest sól HMAC klucza klienta dla przyszłej walidacji klucza
- klucz klienta jest usuwany z pamięci
- Deszyfrowanie:
- Użytkownik wysyła klucz klienta
- Klucz jest walidowany w stosunku do przechowywanej wartości HMAC
- Klucz dostarczony przez klienta jest następnie używany do deszyfrowania danych

</details>

<details>

<summary><strong>Szyfrowanie po stronie klienta z użyciem KMS, CSE-KMS</strong></summary>

Podobnie jak w przypadku SSE-KMS, ta metoda również wykorzystuje usługę zarządzania kluczami do generowania kluczy szyfrowania danych. Jednak tym razem KMS jest wywoływane przez klienta, a nie przez S3. Szyfrowanie odbywa się po stronie klienta, a szyfrowane dane są następnie wysyłane do S3 w celu przechowania.

- Szyfrowanie:
- Klient żąda klucza danych od KMS
- KMS zwraca jawny DEK i szyfrowany DEK z CMK
- Oba klucze są wysyłane z powrotem
- Klient szyfruje dane za pomocą jawnego DEK i wysyła do S3 szyfrowane dane + szyfrowany DEK (który jest zapisywany jako metadane szyfrowanych danych w S3)
- Deszyfrowanie:
- Szyfrowane dane z szyfrowanym DEK są wysyłane do klienta
- Klient prosi KMS o deszyfrowanie szyfrowanego klucza za pomocą CMK, a KMS wysyła z powrotem jawny DEK
- Klient może teraz deszyfrować szyfrowane dane

</details>

<details>

<summary><strong>Szyfrowanie po stronie klienta z użyciem kluczy dostarczonych przez klienta, CSE-C</strong></summary>

Korzystając z tego mechanizmu, możesz wykorzystać własne dostarczone klucze i użyć klienta AWS-SDK do szyfrowania danych przed wysłaniem ich do S3 w celu przechowania.

- Szyfrowanie:
- Klient generuje DEK i szyfruje jawne dane
- Następnie, używając własnego niestandardowego CMK, szyfruje DEK
- przesyła szyfrowane dane + szyfrowany DEK do S3, gdzie są przechowywane
- Deszyfrowanie:
- S3 wysyła szyfrowane dane i DEK
- Ponieważ klient już ma CMK użyty do szyfrowania DEK, deszyfruje DEK, a następnie używa jawnego DEK do deszyfrowania danych

</details>

### **Enumeracja**

Jednym z tradycyjnych głównych sposobów kompromitacji organizacji AWS jest kompromitacja koszyków publicznie dostępnych. **Możesz znaleźć** [**enumeratory publicznych koszyków na tej stronie**](../aws-unauthenticated-enum-access/#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

Możesz uzyskać dostęp do koszyka S3 przez punkt końcowy dual-stack, używając nazwy punktu końcowego w stylu hostowanym wirtualnie lub w stylu ścieżki. Są one przydatne do uzyskiwania dostępu do S3 przez IPv6.

Punkty końcowe dual-stack używają następującej składni:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

Na następnej stronie możesz sprawdzić, jak **nadużywać uprawnień S3, aby eskalować uprawnienia**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**Zgodnie z tym badaniem**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) możliwe było buforowanie odpowiedzi z dowolnego koszyka, tak jakby należała do innego. Mogło to być nadużywane do zmiany na przykład odpowiedzi plików javascript i kompromitacji dowolnych stron korzystających z S3 do przechowywania statycznego kodu.

## Amazon Athena

Amazon Athena to interaktywny serwis zapytań, który ułatwia **analizowanie danych** bezpośrednio w Amazon Simple Storage Service (Amazon **S3**) **przy użyciu** standardowego **SQL**.

Musisz **przygotować tabelę DB relacyjną** w formacie treści, która ma się pojawić w monitorowanych koszykach S3. Następnie Amazon Athena będzie mogła zapełnić DB z logów, abyś mógł je zapytać.

Amazon Athena obsługuje **możliwość zapytania danych S3, które są już zaszyfrowane**, a jeśli jest to skonfigurowane, **Athena może również zaszyfrować wyniki zapytania, które mogą być następnie przechowywane w S3**.

**To szyfrowanie wyników jest niezależne od podstawowych danych S3**, co oznacza, że nawet jeśli dane S3 nie są zaszyfrowane, wyniki zapytania mogą być zaszyfrowane. Kilka punktów, o których warto pamiętać, to to, że Amazon Athena obsługuje tylko dane, które zostały **zaszyfrowane** przy użyciu **następujących metod szyfrowania S3**, **SSE-S3, SSE-KMS i CSE-KMS**.

SSE-C i CSE-E nie są obsługiwane. Oprócz tego ważne jest, aby zrozumieć, że Amazon Athena będzie wykonywać zapytania tylko przeciwko **zaszyfrowanym obiektom, które znajdują się w tym samym regionie co samo zapytanie**. Jeśli musisz zapytać dane S3, które zostały zaszyfrowane przy użyciu KMS, to użytkownik Athena potrzebuje określonych uprawnień, aby umożliwić mu wykonanie zapytania.

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## Odniesienia

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
