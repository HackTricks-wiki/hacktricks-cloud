# AWS - S3, Athena & Glacier Enum

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 is 'n diens wat jou toelaat om **groot hoeveelhede data te stoor**.

Amazon S3 bied verskeie opsies om die **beskerming** van data at REST te bewerkstellig. Die opsies sluit in **Permission** (Policy), **Encryption** (Client and Server Side), **Bucket Versioning** en **MFA based delete**. Die **gebruiker kan aktiveer** enige van hierdie opsies om databeskerming te bereik. **Data replication** is 'n interne fasiliteit deur AWS waar **S3 automatically replicates each object across all the Availability Zones** en die organisasie dit nie hoef te aktiveer nie.

Met resource-based permissions kan jy toestemmings vir sub-gidse van jou bucket afsonderlik definieer.

### Bucket Versioning and MFA based delete

Wanneer bucket versioning aangeskakel is, sal enige aksie wat probeer om 'n lêer in die bucket te wysig 'n nuwe weergawe van daardie lêer skep en ook die vorige inhoud behou. Daarom sal dit nie die bestaande inhoud oor-skryf nie.

Boonop sal MFA based delete verhoed dat weergawes van lêers in die S3 bucket uitgevee word en ook verhoed dat Bucket Versioning gedeaktiveer word, sodat 'n aanvaller nie hierdie lêers kan verander nie.

### S3 Access logs

Dit is moontlik om **enable S3 access login** (wat standaard gedeaktiveer is) op 'n bucket aan te skakel en die logs in 'n ander bucket te stoor om te bepaal wie toegang tot die bucket het (albei buckets moet in dieselfde streek wees).

### S3 Presigned URLs

Dit is moontlik om 'n presigned URL te genereer wat gewoonlik gebruik kan word om die gespesifiseerde lêer in die bucket te bereik. A **presigned URL looks like this**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
'n presigned URL kan **geskep word vanaf die cli met credentials van 'n principal wat toegang tot die object het** (indien die account wat jy gebruik nie toegang het nie, sal 'n korter presigned URL geskep word, maar dit sal nutteloos wees)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> Die enigste vereiste permissie om 'n presigned URL te genereer is die permissie wat gegee word, so vir die vorige opdrag is die enigste permissie wat deur die prinsipaal benodig word `s3:GetObject`
>
> Dit is ook moontlik om presigned URLs te skep met **ander permissies**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 Enkripsie-meganismes

**DEK beteken Data Encryption Key** en is die sleutel wat altyd gegenereer word en gebruik word om data te enkripteer.

<details>

<summary><strong>Server-side encryption with S3 managed keys, SSE-S3</strong></summary>

Hierdie opsie vereis minimale konfigurasie en alle bestuur van die enkripsiesleutels word deur AWS hanteer. Alles wat jy hoef te doen is om jou data op te laai en S3 sal al die ander aspekte hanteer. Elke bucket in 'n S3 rekening kry 'n bucket key.

- Enkripsie:
- Object Data + created plaintext DEK --> Encrypted data (gestoor binne S3)
- Created plaintext DEK + S3 Master Key --> Encrypted DEK (gestoor binne S3) en die plain text word uit geheue verwyder
- Dekripsie:
- Encrypted DEK + S3 Master Key --> Plaintext DEK
- Plaintext DEK + Encrypted data --> Object Data

Let asseblief daarop dat in hierdie geval **die sleutel deur AWS bestuur word** (rotasie slegs elke 3 jaar). As jy jou eie sleutel gebruik, sal jy in staat wees om te roteer, te deaktiveer en toegangskontrole toe te pas.

</details>

<details>

<summary><strong>Server-side encryption with KMS managed keys, SSE-KMS</strong></summary>

Hierdie metode laat S3 toe om die Key Management Service te gebruik om jou data-enkripsiesleutels te genereer. KMS gee jou baie meer buigsaamheid oor hoe jou sleutels bestuur word. Byvoorbeeld, jy kan die CMK deaktiveer, roteer en toegangskontroles toepas, en hul gebruik nagaan met AWS Cloud Trail.

- Enkripsie:
- S3 versoek data keys van KMS CMK
- KMS gebruik 'n CMK om die paar plaintext DEK en encrypted DEK te genereer en stuur hulle terug na S3
- S3 gebruik die plaintext sleutel om die data te enkripteer, stoor die encrypted data en die encrypted sleutel, en verwyder die plain text sleutel uit geheue
- Dekripsie:
- S3 vra KMS om die encrypted data key van die object te dekripteer
- KMS dekripteer die data key met die CMK en stuur dit terug aan S3
- S3 dekripteer die object data

</details>

<details>

<summary><strong>Server-side encryption with customer provided keys, SSE-C</strong></summary>

Hierdie opsie gee jou die geleentheid om jou eie master sleutel te verskaf wat jy dalk reeds buite AWS gebruik. Jou customer-provided key word saam met jou data na S3 gestuur, waar S3 dan die enkripsie vir jou sal uitvoer.

- Enkripsie:
- Die gebruiker stuur die object data + Customer key na S3
- Die customer key word gebruik om die data te enkripteer en die geënkripteerde data word gestoor
- 'n gesoute HMAC waarde van die customer key word ook gestoor vir toekomstige sleutelverifikasie
- Die customer key word uit geheue verwyder
- Dekripsie:
- Die gebruiker stuur die customer key
- Die sleutel word geverifieer teen die gestoor HMAC waarde
- Die customer-provided key word dan gebruik om die data te dekripteer

</details>

<details>

<summary><strong>Client-side encryption with KMS, CSE-KMS</strong></summary>

Soos met SSE-KMS, gebruik dit ook die Key Management Service om jou data-enkripsiesleutels te genereer. Hierdie keer word KMS egter deur die client aangespreek en nie deur S3 nie. Die enkripsie vind kliënt-kant plaas en die geënkripteerde data word dan na S3 gestuur vir stoor.

- Enkripsie:
- Client versoek 'n data key van KMS
- KMS stuur die plaintext DEK en die encrypted DEK met die CMK terug
- Beide sleutels word teruggestuur aan die client
- Die client enkripteer dan die data met die plaintext DEK en stuur na S3 die encrypted data + die encrypted DEK (wat as metadata van die geënkripteerde data in S3 gestoor word)
- Dekripsie:
- Die geënkripteerde data met die encrypted DEK word aan die client gestuur
- Die client vra KMS om die encrypted sleutel te dekripteer met die CMK en KMS stuur die plaintext DEK terug
- Die client kan nou die geënkripteerde data dekripteer

</details>

<details>

<summary><strong>Client-side encryption with customer provided keys, CSE-C</strong></summary>

Met hierdie meganisme kan jy jou eie verskafde sleutels gebruik en 'n AWS-SDK client gebruik om jou data te enkripteer voordat jy dit na S3 stuur vir stoor.

- Enkripsie:
- Die client genereer 'n DEK en enkripteer die plaintext data
- Daarna enkripteer dit die DEK met sy eie custom CMK
- Dien die encrypted data + encrypted DEK in by S3 waar dit gestoor word
- Dekripsie:
- S3 stuur die encrypted data en DEK
- Aangesien die client reeds die CMK het wat gebruik is om die DEK te enkripteer, dekripteer dit die DEK en gebruik dan die plaintext DEK om die data te dekripteer

</details>

### **Enumeration**

Een van die tradisionele hoofmanieres om AWS-orgs te kompromitteer begin deur publiek toeganklike buckets te kompromitteer. **You can find** [**public buckets enumerators in this page**](../aws-unauthenticated-enum-access/index.html#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

Jy kan toegang tot 'n S3-bucket kry via 'n dual-stack-eindpunt deur 'n virtual hosted-style of path-style eindpuntnaam te gebruik. Dit is nuttig om S3 via IPv6 te bereik.

Dual-stack-eindpunte gebruik die volgende sintaksis:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

Op die volgende bladsy kan jy sien hoe om **abuse S3 permissions to escalate privileges**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc/README.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum/README.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation/README.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence/README.md
{{#endref}}

## Ander S3 kwesbaarhede

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**According to this research**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) was dit moontlik om die respons van 'n ewekansige bucket in die kas te stoor asof dit aan 'n ander behoort het. Dit kon misbruik word om byvoorbeeld JavaScript-lêerresponsies te verander en ewekansige bladsye te kompromitteer wat S3 gebruik om statiese kode te stoor.

## Amazon Athena

Amazon Athena is 'n interaktiewe query-diens wat dit maklik maak om data direk te ontleed in Amazon Simple Storage Service (Amazon **S3**) met behulp van standaard **SQL**.

Jy moet **'n relationele DB-tabel voorberei** met die formaat van die inhoud wat in die gemonitorde S3-buckets gaan verskyn. Daarna sal Amazon Athena in staat wees om die DB vanaf die logs te vul, sodat jy dit kan query.

Amazon Athena ondersteun die **vermoë om S3-data te query wat reeds versleuteld is** en as dit so gekonfigureer is, kan **Athena ook die resultate van die query versleutel wat dan in S3 gestoor kan word**.

**Hierdie enkripsie van resultate is onafhanklik van die onderliggende ge-queryde S3-data**, wat beteken dat selfs as die S3-data nie versleuteld is nie, die ge-queryde resultate versleuteld kan wees. 'n Paar punte om te onthou is dat Amazon Athena slegs data ondersteun wat **versleuteld** is met die **volgende S3-enkripsiemetodes**, **SSE-S3, SSE-KMS, and CSE-KMS**.

SSE-C and CSE-C are not supported. Daarbenewens is dit belangrik om te verstaan dat Amazon Athena slegs query's teen **versleutelde objecte wat in dieselfde streek as die query self is** sal uitvoer. As jy S3-data moet query wat met KMS versleuteld is, is spesifieke permissies benodig deur die Athena-gebruiker om hulle toe te laat om die query uit te voer.

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## Verwysings

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
