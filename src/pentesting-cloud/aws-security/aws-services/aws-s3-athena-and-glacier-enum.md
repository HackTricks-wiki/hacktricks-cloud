# AWS - S3, Athena & Glacier Enumeração

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 é um serviço que permite que você **armazene grandes quantidades de dados**.

Amazon S3 oferece múltiplas opções para alcançar a **proteção** de dados em repouso. As opções incluem **Permissão** (Policy), **Criptografia** (Client and Server Side), **Bucket Versioning** e **MFA based delete**. O **usuário pode ativar** qualquer uma dessas opções para obter proteção dos dados. **Data replication** é uma funcionalidade interna da AWS onde **S3 automaticamente replica cada objeto através de todas as Availability Zones** e a organização não precisa habilitá-la nesse caso.

Com permissões baseadas em recursos, você pode definir permissões para sub-diretórios do seu bucket separadamente.

### Bucket Versioning and MFA based delete

Quando o Bucket Versioning está habilitado, qualquer ação que tente alterar um arquivo no bucket gerará uma nova versão do arquivo, mantendo também o conteúdo anterior. Portanto, não sobrescreverá o conteúdo.

Além disso, o MFA based delete impedirá que versões de arquivos no bucket S3 sejam excluídas e também que o Bucket Versioning seja desabilitado, então um atacante não conseguirá alterar esses arquivos.

### S3 Access logs

É possível **ativar S3 access logging** (que por padrão está desabilitado) em um bucket e salvar os logs em um bucket diferente para saber quem está acessando o bucket (ambos os buckets devem estar na mesma região).

### S3 Presigned URLs

É possível gerar um presigned URL que normalmente pode ser usado para **acessar o arquivo especificado** no bucket. Um **presigned URL se parece com isto**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
Uma presigned URL pode ser **criada a partir do cli usando credentials de um principal com acesso ao object** (se a account que você usar não tiver acesso, uma presigned URL mais curta será criada, mas será inútil)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> A única permissão necessária para gerar uma URL pré-assinada é a permissão que está sendo concedida, então para o comando anterior a única permissão necessária pelo principal é `s3:GetObject`

Também é possível criar URLs pré-assinadas com **outras permissões**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### Mecanismos de criptografia do S3

**DEK means Data Encryption Key** e é a chave que é sempre gerada e usada para criptografar dados.

<details>

<summary><strong>Server-side encryption with S3 managed keys, SSE-S3</strong></summary>

Esta opção requer configuração mínima e todo o gerenciamento das chaves de criptografia é feito pela AWS. Tudo o que você precisa fazer é **enviar seus dados e o S3 cuidará de todos os outros aspectos**. Cada bucket em uma conta S3 recebe uma bucket key.

- Encryption:
- Object Data + created plaintext DEK --> Encrypted data (stored inside S3)
- Created plaintext DEK + S3 Master Key --> Encrypted DEK (stored inside S3) and plain text is deleted from memory
- Decryption:
- Encrypted DEK + S3 Master Key --> Plaintext DEK
- Plaintext DEK + Encrypted data --> Object Data

Por favor, note que neste caso **a chave é gerenciada pela AWS** (rotacionamento apenas a cada 3 anos). Se você usar sua própria chave você poderá rotacionar, desabilitar e aplicar controle de acesso.

</details>

<details>

<summary><strong>Server-side encryption with KMS managed keys, SSE-KMS</strong></summary>

Este método permite que o S3 utilize o Key Management Service para gerar suas data encryption keys. KMS oferece muito mais flexibilidade sobre como suas chaves são gerenciadas. Por exemplo, você pode desabilitar, rotacionar e aplicar controles de acesso ao CMK, e auditar seu uso usando AWS Cloud Trail.

- Encryption:
- S3 request data keys from KMS CMK
- KMS uses a CMK to generate the pair DEK plaintext and DEK encrypted and send them to S£
- S3 uses the paintext key to encrypt the data, store the encrypted data and the encrypted key and deletes from memory the plain text key
- Decryption:
- S3 ask to KMS to decrypt the encrypted data key of the object
- KMS decrypt the data key with the CMK and send it back to S3
- S3 decrypts the object data

</details>

<details>

<summary><strong>Server-side encryption with customer provided keys, SSE-C</strong></summary>

Esta opção permite que você forneça sua própria master key que talvez já utilize fora da AWS. Sua chave fornecida pelo cliente seria então enviada junto com seus dados para o S3, onde o S3 executaria a criptografia para você.

- Encryption:
- The user sends the object data + Customer key to S3
- The customer key is used to encrypt the data and the encrypted data is stored
- a salted HMAC value of the customer key is stored also for future key validation
- the customer key is deleted from memory
- Decryption:
- The user send the customer key
- The key is validated against the HMAC value stored
- The customer provided key is then used to decrypt the data

</details>

<details>

<summary><strong>Client-side encryption with KMS, CSE-KMS</strong></summary>

Similar ao SSE-KMS, este também usa o Key Management Service para gerar suas data encryption keys. Porém, desta vez o KMS é chamado pelo cliente, não pelo S3. A criptografia então ocorre no lado do cliente e os dados criptografados são enviados ao S3 para armazenamento.

- Encryption:
- Client request for a data key to KMS
- KMS returns the plaintext DEK and the encrypted DEK with the CMK
- Both keys are sent back
- The client then encrypts the data with the plaintext DEK and send to S3 the encrypted data + the encrypted DEK (which is saved as metadata of the encrypted data inside S3)
- Decryption:
- The encrypted data with the encrypted DEK is sent to the client
- The client asks KMS to decrypt the encrypted key using the CMK and KMS sends back the plaintext DEK
- The client can now decrypt the encrypted data

</details>

<details>

<summary><strong>Client-side encryption with customer provided keys, CSE-C</strong></summary>

Usando este mecanismo, você pode utilizar suas próprias chaves fornecidas e usar um cliente AWS-SDK para criptografar seus dados antes de enviá-los ao S3 para armazenamento.

- Encryption:
- The client generates a DEK and encrypts the plaintext data
- Then, using it's own custom CMK it encrypts the DEK
- submit the encrypted data + encrypted DEK to S3 where it's stored
- Decryption:
- S3 sends the encrypted data and DEK
- As the client already has the CMK used to encrypt the DEK, it decrypts the DEK and then uses the plaintext DEK to decrypt the data

</details>

### **Enumeração**

Uma das maneiras tradicionais principais de comprometer organizações AWS começa por comprometer buckets publicamente acessíveis. **Você pode encontrar** [**public buckets enumerators in this page**](../aws-unauthenticated-enum-access/index.html#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

Você pode acessar um bucket S3 através de um endpoint dual-stack usando um nome de endpoint no formato virtual hosted-style ou path-style. Esses são úteis para acessar o S3 via IPv6.

Dual-stack endpoints usam a seguinte sintaxe:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

In the following page you can check how to **abuse S3 permissions to escalate privileges**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc/README.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum/README.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation/README.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence/README.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**According to this research**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) era possível armazenar em cache a resposta de um bucket arbitrário como se pertencesse a outro diferente. Isso poderia ter sido abusado para alterar, por exemplo, respostas de arquivos javascript e comprometer páginas arbitrárias que usam o S3 para armazenar código estático.

## Amazon Athena

Amazon Athena é um serviço de consultas interativo que facilita a análise de dados diretamente no Amazon Simple Storage Service (Amazon **S3**) usando SQL padrão.

Você precisa **preparar uma tabela relacional DB** com o formato do conteúdo que vai aparecer nos buckets S3 monitorados. Em seguida, o Amazon Athena poderá popular o DB a partir dos logs, permitindo que você o consulte.

O Amazon Athena suporta a **capacidade de consultar dados S3 que já estão criptografados** e, se configurado para tal, **o Athena também pode criptografar os resultados da consulta, que então podem ser armazenados no S3**.

**Essa criptografia dos resultados é independente dos dados S3 subjacentes consultados**, o que significa que mesmo que os dados S3 não estejam criptografados, os resultados consultados podem ser criptografados. Alguns pontos a observar: o Amazon Athena só suporta dados que foram **criptografados** com os **seguintes métodos de criptografia S3**, **SSE-S3, SSE-KMS, and CSE-KMS**.

SSE-C and CSE-C não são suportados. Além disso, é importante entender que o Amazon Athena executará consultas apenas contra **objetos criptografados que estejam na mesma região da própria consulta**. Se você precisa consultar dados S3 que foram criptografados usando KMS, permissões específicas são exigidas para o usuário do Athena permitir que ele execute a consulta.

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## Referências

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
