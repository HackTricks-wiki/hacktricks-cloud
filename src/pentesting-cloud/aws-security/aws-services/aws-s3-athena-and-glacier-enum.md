# AWS - S3, Athena & Glacier Enum

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 एक ऐसी सेवा है जो आपको **बड़े पैमाने पर डेटा स्टोर करने की अनुमति देती है**।

Amazon S3 डेटा के REST पर **सुरक्षा** हासिल करने के लिए कई विकल्प प्रदान करता है। विकल्पों में **Permission** (Policy), **Encryption** (Client and Server Side), **Bucket Versioning** और **MFA** **based delete** शामिल हैं। कोई भी **user इन विकल्पों को सक्षम कर सकता है** ताकि डेटा सुरक्षा प्राप्त की जा सके। **Data replication** AWS की एक आंतरिक सुविधा है जहाँ **S3 अपने प्रत्येक object को सभी Availability Zones में स्वचालित रूप से replicate करता है** और इस मामले में संगठन को इसे सक्षम करने की आवश्यकता नहीं होती।

With resource-based permissions, you can define permissions for sub-directories of your bucket separately.

### Bucket Versioning and MFA based delete

जब Bucket Versioning सक्षम होता है, तो किसी भी कार्रवाई जो किसी फ़ाइल को बदलने की कोशिश करती है, फ़ाइल का नया version जनरेट कर देगी और साथ ही उसकी पिछली सामग्री भी रखेगी। इसलिए यह उसकी सामग्री को overwrite नहीं करेगा।

Moreover, MFA based delete S3 bucket में फ़ाइलों के versions को हटने से रोकेगा और साथ ही Bucket Versioning को disabled होने से भी रोकेगा, इसलिए कोई attacker इन फ़ाइलों को बदल नहीं पाएगा।

### S3 Access logs

किसी bucket पर **S3 access login** सक्षम करना (जो डिफ़ॉल्ट रूप से disabled होता है) और logs को किसी अलग bucket में save करना संभव है ताकि यह पता चल सके कि कौन bucket को access कर रहा है (दोनों buckets एक ही region में होने चाहिए)।

### S3 Presigned URLs

यह संभव है कि आप एक presigned URL जनरेट करें जिसे आमतौर पर bucket में निर्दिष्ट फ़ाइल को **access** करने के लिए उपयोग किया जा सकता है। एक **presigned URL इस तरह दिखता है**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
A presigned URL को **cli से उस principal के credentials का उपयोग करके बनाया जा सकता है जिसे object तक access है** (यदि जिस account का आप उपयोग कर रहे हैं उसके पास access नहीं है, तो एक छोटा presigned URL बनाया जाएगा लेकिन वह बेकार होगा)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> presigned URL बनाने के लिए केवल आवश्यक permission वही permission है जो दी जा रही है, इसलिए पिछले कमांड के लिए principal को केवल `s3:GetObject` permission की ही ज़रूरत है
>
It's also possible to create presigned URLs with **other permissions**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 एन्क्रिप्शन मैकेनिज़्म

**DEK means Data Encryption Key** और यह वह key है जो हमेशा जेनरेट की जाती है और डेटा को एन्क्रिप्ट करने के लिए उपयोग होती है।

<details>

<summary><strong>Server-side encryption with S3 managed keys, SSE-S3</strong></summary>

यह विकल्प न्यूनतम कॉन्फ़िगरेशन मांगता है और encryption keys का पूरा प्रबंधन AWS द्वारा किया जाता है। आपको बस अपना डेटा अपलोड करना है और S3 बाकी सब संभाल लेगा। प्रत्येक bucket को S3 account में एक bucket key असाइन की जाती है।

- एन्क्रिप्शन:
- ऑब्जेक्ट डेटा + created plaintext DEK --> Encrypted data (stored inside S3)
- Created plaintext DEK + S3 Master Key --> Encrypted DEK (stored inside S3) और plain text मेमोरी से डिलीट कर दिया जाता है
- डीक्रिप्शन:
- Encrypted DEK + S3 Master Key --> Plaintext DEK
- Plaintext DEK + Encrypted data --> Object Data

कृपया ध्यान दें कि इस केस में **key AWS द्वारा मैनेज की जाती है** (rotation केवल हर 3 साल)। अगर आप अपनी खुद की key इस्तेमाल करेंगे तो आप उसे rotate, disable और access control लागू कर सकेंगे।

</details>

<details>

<summary><strong>Server-side encryption with KMS managed keys, SSE-KMS</strong></summary>

यह मेथड S3 को key management service का उपयोग करके आपके data encryption keys जेनरेट करने की अनुमति देती है। KMS आपको keys के प्रबंधन में काफी अधिक लचीलापन देता है। उदाहरण के लिए, आप CMK को disable, rotate और उस पर access controls लागू कर सकते हैं, तथा उनके उपयोग के खिलाफ ऑर्डर करने के लिए AWS Cloud Trail का उपयोग कर सकते हैं।

- एन्क्रिप्शन:
- S3 KMS CMK से data keys रिक्वेस्ट करता है
- KMS एक CMK का उपयोग करके DEK plaintext और DEK encrypted का पेयर जनरेट करता है और उन्हें S£ को भेजता है
- S3 plaintext key का उपयोग करके डेटा को एन्क्रिप्ट करता है, एन्क्रिप्टेड डेटा और encrypted key स्टोर करता है और plaintext key को मेमोरी से डिलीट कर देता है
- डीक्रिप्शन:
- S3 ऑब्जेक्ट के encrypted data key को decrypt करने के लिए KMS से अनुरोध करता है
- KMS CMK के साथ data key को decrypt करता है और उसे S3 को भेजता है
- S3 ऑब्जेक्ट डेटा को decrypt करता है

</details>

<details>

<summary><strong>Server-side encryption with customer provided keys, SSE-C</strong></summary>

यह विकल्प आपको अपनी खुद की master key प्रदान करने का मौका देता है जिसे आप AWS के बाहर उपयोग कर रहे होंगे। आपकी customer-provided key तब आपके डेटा के साथ S3 को भेजी जाएगी, जहाँ S3 आपके लिए एन्क्रिप्शन कर देगा।

- एन्क्रिप्शन:
- उपयोगकर्ता ऑब्जेक्ट डेटा + Customer key को S3 पर भेजता है
- Customer key का उपयोग डेटा को एन्क्रिप्ट करने के लिए किया जाता है और एन्क्रिप्टेड डेटा स्टोर किया जाता है
- customer key का एक salted HMAC value भी भविष्य के key validation के लिए स्टोर किया जाता है
- customer key मेमोरी से डिलीट कर दी जाती है
- डीक्रिप्शन:
- उपयोगकर्ता customer key भेजता है
- key को स्टोर किए गए HMAC value के खिलाफ validate किया जाता है
- उसके बाद customer provided key का उपयोग डेटा को decrypt करने के लिए किया जाता है

</details>

<details>

<summary><strong>Client-side encryption with KMS, CSE-KMS</strong></summary>

SSE-KMS की तरह ही, यह भी key management service का उपयोग करके आपके data encryption keys जेनरेट करता है। हालाँकि इस बार KMS को client द्वारा कॉल किया जाता है, न कि S3 द्वारा। एन्क्रिप्शन क्लाइंट-साइड होता है और एन्क्रिप्टेड डेटा को स्टोर करने के लिए S3 पर भेज दिया जाता है।

- एन्क्रिप्शन:
- Client KMS से data key के लिए request करता है
- KMS plaintext DEK और CMK के साथ encrypted DEK रिटर्न करता है
- दोनों keys वापस भेजे जाते हैं
- क्लाइंट फिर plaintext DEK से डेटा को एन्क्रिप्ट करता है और S3 को encrypted data + encrypted DEK भेजता है (जो कि S3 के अंदर encrypted डेटा के metadata के रूप में सेव होता है)
- डीक्रिप्शन:
- encrypted data के साथ encrypted DEK क्लाइंट को भेजा जाता है
- क्लाइंट KMS से CMK का उपयोग करके encrypted key को decrypt करने के लिए कहता है और KMS plaintext DEK वापस भेजता है
- क्लाइंट अब encrypted डेटा को decrypt कर सकता है

</details>

<details>

<summary><strong>Client-side encryption with customer provided keys, CSE-C</strong></summary>

इस मेकेनिज़्म का उपयोग करके आप अपनी स्वयं की प्रदान की हुई keys का उपयोग कर सकते हैं और AWS-SDK client का उपयोग करके डेटा भेजने से पहले उसे encrypt कर सकते हैं।

- एन्क्रिप्शन:
- क्लाइंट एक DEK जेनरेट करता है और plaintext डेटा को एन्क्रिप्ट करता है
- फिर, अपनी custom CMK का उपयोग करके वह DEK को एन्क्रिप्ट करता है
- encrypted data + encrypted DEK को S3 पर सबमिट करता है जहाँ यह स्टोर होता है
- डीक्रिप्शन:
- S3 encrypted data और DEK भेजता है
- चूँकि क्लाइंट के पास वह CMK पहले से मौजूद है जिसका उपयोग DEK को एन्क्रिप्ट करने के लिए हुआ था, वह DEK को decrypt करता है और फिर plaintext DEK से डेटा को decrypt करता है

</details>

### **Enumeration**

AWS orgs को compromise करने के पारंपरिक प्रमुख तरीकों में से एक सार्वजनिक रूप से accessible buckets को compromise करना है। **You can find** [**public buckets enumerators in this page**](../aws-unauthenticated-enum-access/index.html#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

आप virtual hosted-style या path-style endpoint नाम का उपयोग करके dual-stack endpoint के माध्यम से किसी S3 bucket तक पहुँच सकते हैं। ये S3 को IPv6 के माध्यम से एक्सेस करने के लिए उपयोगी हैं।

Dual-stack endpoints निम्नलिखित सिंटैक्स का उपयोग करते हैं:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

नीचे दिए पृष्ठ में आप देख सकते हैं कि कैसे **abuse S3 permissions to escalate privileges**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc/README.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum/README.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation/README.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence/README.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**इस रिसर्च के अनुसार**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) यह संभव था कि किसी भी bucket की response को cache किया जाए मानो वह किसी अन्य bucket की हो। इसका दुरुपयोग करके, उदाहरण के लिए javascript file responses को बदलकर और S3 का उपयोग करके static code स्टोर करने वाले किसी भी पृष्ठ को compromise किया जा सकता था।

## Amazon Athena

Amazon Athena एक interactive query service है जो Amazon Simple Storage Service (Amazon **S3**) में सीधे standard **SQL** का उपयोग करके **डेटा का विश्लेषण** करना आसान बनाती है।

आपको उन monitored S3 buckets में आने वाली सामग्री के फ़ॉर्मेट के साथ एक **relational DB table तैयार करना** होगा। और फिर, Amazon Athena logs से DB को populate कर सकेगा, ताकि आप उस पर query चला सकें।

Amazon Athena पहले से encrypted S3 data को query करने की क्षमता का समर्थन करता है और यदि इसे configure किया गया है, तो **Athena queried results को encrypt भी कर सकता है जिन्हें बाद में S3 में store किया जा सकता है**।

**परिणामों का यह एन्क्रिप्शन underlying queried S3 डेटा से स्वतंत्र है**, अर्थात् भले ही S3 डेटा encrypted न हो, queried results को encrypt किया जा सकता है। ध्यान रखने योग्य कुछ बातें हैं: Amazon Athena केवल उन डेटा का समर्थन करता है जो निम्नलिखित S3 encryption methods के साथ **encrypted** किए गए हैं, **SSE-S3, SSE-KMS, and CSE-KMS**।

SSE-C और CSE-C समर्थित नहीं हैं। इसके अतिरिक्त, यह समझना महत्वपूर्ण है कि Amazon Athena केवल उन **encrypted objects पर ही queries चलाएगा जो query के समान region में हैं**। यदि आपको KMS का उपयोग करके encrypted S3 data को query करने की आवश्यकता है, तो Athena user को query करने में सक्षम बनाने के लिए विशिष्ट permissions की आवश्यकता होगी।

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## संदर्भ

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
