# AWS - S3, Athena & Glacier Перелічення

{{#include ../../../banners/hacktricks-training.md}}

## S3

Amazon S3 — це сервіс, який дозволяє вам **зберігати великі обсяги даних**.

Amazon S3 надає кілька опцій для досягнення **захисту** даних у стані спокою. Опції включають **Permission** (Policy), **Encryption** (Client and Server Side), **Bucket Versioning** та **MFA based delete**. Користувач може **увімкнути** будь-яку з цих опцій для забезпечення захисту даних. **Data replication** — це внутрішня можливість від AWS, за якої **S3 автоматично реплікує кожний об’єкт по всіх Availability Zones**, і організації не потрібно додатково її вмикати.

With resource-based permissions, you can define permissions for sub-directories of your bucket separately.

### Bucket Versioning and MFA based delete

When bucket versioning is enabled, any action that tries to alter a file inside a file will generate a new version of the file, keeping also the previous content of the same. Therefore, it won't overwrite its content.

Moreover, MFA based delete will prevent versions of file in the S3 bucket from being deleted and also Bucket Versioning from being disabled, so an attacker won't be able to alter these files.

### S3 Access logs

It's possible to **enable S3 access login** (which by default is disabled) to some bucket and save the logs in a different bucket to know who is accessing the bucket (both buckets must be in the same region).

### S3 Presigned URLs

It's possible to generate a presigned URL that can usually be used to **access the specified file** in the bucket. A **presigned URL looks like this**:
```
https://<bucket-name>.s3.us-east-1.amazonaws.com/asd.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAUUE8GZC4S5L3TY3P%2F20230227%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230227T142551Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIBhQpdETJO3HKKDk2hjNIrPWwBE8gZaQccZFV3kCpPCWAiEAid3ueDtFFU%2FOQfUpvxYTGO%2BHoS4SWDMUrQAE0pIaB40qggMIYBAAGgwzMTgxNDIxMzg1NTMiDJLI5t7gr2EGxG1Y5CrfAioW0foHIQ074y4gvk0c%2B%2Fmqc7cNWb1njQslQkeePHkseJ3owzc%2FCwkgE0EuZTd4mw0aJciA2XIbJRCLPWTb%2FCBKPnIMJ5aBzIiA2ltsiUNQTTUxYmEgXZoJ6rFYgcodnmWW0Et4Xw59UlHnCDB2bLImxPprriyCzDDCD6nLyp3J8pFF1S8h3ZTJE7XguA8joMs4%2B2B1%2FeOZfuxXKyXPYSKQOOSbQiHUQc%2BFnOfwxleRL16prWk1t7TamvHR%2Bt3UgMn5QWzB3p8FgWwpJ6GjHLkYMJZ379tkimL1tJ7o%2BIod%2FMYrS7LDCifP9d%2FuYOhKWGhaakPuJKJh9fl%2B0vGl7kmApXigROxEWon6ms75laXebltsWwKcKuYca%2BUWu4jVJx%2BWUfI4ofoaGiCSaKALTqwu4QNBRT%2BMoK6h%2BQa7gN7JFGg322lkxRY53x27WMbUE4unn5EmI54T4dWt1%2Bg8ljDS%2BvKfBjqmAWRwuqyfwXa5YC3xxttOr3YVvR6%2BaXpzWtvNJQNnb6v0uI3%2BTtTexZkJpLQYqFcgZLQSxsXWSnf988qvASCIUhAzp2UnS1uqy7QjtD5T73zksYN2aesll7rvB80qIuujG6NOdHnRJ2M5%2FKXXNo1Yd15MtzPuSjRoSB9RSMon5jFu31OrQnA9eCUoawxbB0nHqwK8a43CKBZHhA8RoUAJW%2B48EuFsp3U%3D&X-Amz-Signature=3436e4139e84dbcf5e2e6086c0ebc92f4e1e9332b6fda24697bc339acbf2cdfa
```
Presigned URL можна **created from the cli using credentials of a principal with access to the object** (якщо акаунт, який ви використовуєте, не має доступу, буде створено коротший presigned URL, але він буде марним)
```bash
aws s3 presign --region <bucket-region> 's3://<bucket-name>/<file-name>'
```
> [!NOTE]
> Єдиний необхідний дозвіл для генерації presigned URL — це дозвіл, що надається; отже для попередньої команди єдиний дозвіл, потрібний principal, — `s3:GetObject`

Також можливо створювати presigned URLs з **іншими дозволами**:
```python
import boto3
url = boto3.client('s3').generate_presigned_url(
ClientMethod='put_object',
Params={'Bucket': 'BUCKET_NAME', 'Key': 'OBJECT_KEY'},
ExpiresIn=3600
)
```
### S3 Механізми шифрування

**DEK означає Data Encryption Key** і це ключ, який завжди генерується та використовується для шифрування даних.

<details>

<summary><strong>Server-side encryption with S3 managed keys, SSE-S3</strong></summary>

Цей варіант вимагає мінімальної конфігурації — управління ключами шифрування повністю здійснюється AWS. Все, що потрібно зробити, — це завантажити дані, і S3 обробить усі інші аспекти. Кожному bucket у акаунті S3 призначається bucket key.

- Шифрування:
- Object Data + created plaintext DEK --> Encrypted data (stored inside S3)
- Created plaintext DEK + S3 Master Key --> Encrypted DEK (stored inside S3) and plain text is deleted from memory
- Розшифрування:
- Encrypted DEK + S3 Master Key --> Plaintext DEK
- Plaintext DEK + Encrypted data --> Object Data

Зверніть увагу, що в цьому випадку **ключ керується AWS** (ротація лише кожні 3 роки). Якщо ви використовуєте власний ключ, ви зможете виконувати його ротацію, відключати та застосовувати контроль доступу.

</details>

<details>

<summary><strong>Server-side encryption with KMS managed keys, SSE-KMS</strong></summary>

Цей метод дозволяє S3 використовувати Key Management Service для генерації ваших data encryption keys. KMS дає набагато більшу гнучкість у тому, як керувати ключами. Наприклад, ви можете відключати, обертати та застосовувати контроль доступу до CMK, а також контролювати їх використання за допомогою AWS Cloud Trail.

- Шифрування:
- S3 request data keys from KMS CMK
- KMS uses a CMK to generate the pair DEK plaintext and DEK encrypted and send them to S£
- S3 uses the paintext key to encrypt the data, store the encrypted data and the encrypted key and deletes from memory the plain text key
- Розшифрування:
- S3 ask to KMS to decrypt the encrypted data key of the object
- KMS decrypt the data key with the CMK and send it back to S3
- S3 decrypts the object data

</details>

<details>

<summary><strong>Server-side encryption with customer provided keys, SSE-C</strong></summary>

Ця опція дає можливість надати власний master key, який ви вже можете використовувати поза AWS. Ваш customer-provided key надсилається разом з даними до S3, де S3 виконує шифрування за вас.

- Шифрування:
- The user sends the object data + Customer key to S3
- The customer key is used to encrypt the data and the encrypted data is stored
- a salted HMAC value of the customer key is stored also for future key validation
- the customer key is deleted from memory
- Розшифрування:
- The user send the customer key
- The key is validated against the HMAC value stored
- The customer provided key is then used to decrypt the data

</details>

<details>

<summary><strong>Client-side encryption with KMS, CSE-KMS</strong></summary>

Подібно до SSE-KMS, цей варіант також використовує KMS для генерації data encryption keys. Але цього разу виклик до KMS робить клієнт, а не S3. Шифрування відбувається на боці клієнта, після чого зашифровані дані відправляються до S3 для зберігання.

- Шифрування:
- Client request for a data key to KMS
- KMS returns the plaintext DEK and the encrypted DEK with the CMK
- Both keys are sent back
- The client then encrypts the data with the plaintext DEK and send to S3 the encrypted data + the encrypted DEK (which is saved as metadata of the encrypted data inside S3)
- Розшифрування:
- The encrypted data with the encrypted DEK is sent to the client
- The client asks KMS to decrypt the encrypted key using the CMK and KMS sends back the plaintext DEK
- The client can now decrypt the encrypted data

</details>

<details>

<summary><strong>Client-side encryption with customer provided keys, CSE-C</strong></summary>

За допомогою цього механізму ви можете використовувати власні ключі та AWS-SDK клієнт, щоб зашифрувати дані перед відправкою до S3 для зберігання.

- Шифрування:
- The client generates a DEK and encrypts the plaintext data
- Then, using it's own custom CMK it encrypts the DEK
- submit the encrypted data + encrypted DEK to S3 where it's stored
- Розшифрування:
- S3 sends the encrypted data and DEK
- As the client already has the CMK used to encrypt the DEK, it decrypts the DEK and then uses the plaintext DEK to decrypt the data

</details>

### **Enumeration**

Один із традиційних основних шляхів компрометації організацій AWS починається з компрометації публічно доступних buckets. **Ви можете знайти** [**public buckets enumerators in this page**](../aws-unauthenticated-enum-access/index.html#s3-buckets)**.**
```bash
# Get buckets ACLs
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api get-object-acl --bucket <bucket-name> --key flag

# Get policy
aws s3api get-bucket-policy --bucket <bucket-name>
aws s3api get-bucket-policy-status --bucket <bucket-name> #if it's public

# list S3 buckets associated with a profile
aws s3 ls
aws s3api list-buckets

# list content of bucket (no creds)
aws s3 ls s3://bucket-name --no-sign-request
aws s3 ls s3://bucket-name --recursive

# list content of bucket (with creds)
aws s3 ls s3://bucket-name
aws s3api list-objects-v2 --bucket <bucket-name>
aws s3api list-objects --bucket <bucket-name>
aws s3api list-object-versions --bucket <bucket-name>

# copy local folder to S3
aws s3 cp MyFolder s3://bucket-name --recursive

# delete
aws s3 rb s3://bucket-name –-force

# download a whole S3 bucket
aws s3 sync s3://<bucket>/ .

# move S3 bucket to different location
aws s3 sync s3://oldbucket s3://newbucket --source-region us-west-1

# list the sizes of an S3 bucket and its contents
aws s3api list-objects --bucket BUCKETNAME --output json --query "[sum(Contents[].Size), length(Contents[])]"

# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>
##JSON policy example
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}

# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name> # Way 1 to get the ACL
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

aws s3api get-object-acl --bucket <bucket-name> --key flag #Way 2 to get the ACL
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### dual-stack <a href="#dual-stack-endpoints-description" id="dual-stack-endpoints-description"></a>

Ви можете отримати доступ до S3 bucket через dual-stack endpoint, використовуючи virtual hosted-style або path-style endpoint name. Це корисно для доступу до S3 через IPv6.

Dual-stack endpoints використовують наступний синтаксис:

- `bucketname.s3.dualstack.aws-region.amazonaws.com`
- `s3.dualstack.aws-region.amazonaws.com/bucketname`

### Privesc

На наступній сторінці ви можете переглянути, як **abuse S3 permissions to escalate privileges**:

{{#ref}}
../aws-privilege-escalation/aws-s3-privesc/README.md
{{#endref}}

### Unauthenticated Access

{{#ref}}
../aws-unauthenticated-enum-access/aws-s3-unauthenticated-enum/README.md
{{#endref}}

### S3 Post Exploitation

{{#ref}}
../aws-post-exploitation/aws-s3-post-exploitation/README.md
{{#endref}}

### Persistence

{{#ref}}
../aws-persistence/aws-s3-persistence/README.md
{{#endref}}

## Other S3 vulns

### S3 HTTP Cache Poisoning Issue <a href="#heading-s3-http-desync-cache-poisoning-issue" id="heading-s3-http-desync-cache-poisoning-issue"></a>

[**According to this research**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue) було можливо кешувати відповідь довільного bucket так, ніби вона належала іншому. Це могло бути використано, наприклад, для зміни відповіді javascript файлів і компрометації довільних сторінок, які використовують S3 для зберігання статичного коду.

## Amazon Athena

Amazon Athena — це інтерактивний сервіс запитів, який полегшує аналіз даних безпосередньо в Amazon Simple Storage Service (Amazon **S3**) **using** standard **SQL**.

Потрібно **підготувати relational DB table** з форматом вмісту, який буде з’являтися в monitored S3 buckets. Після цього Amazon Athena зможе заповнити DB з логів, щоб ви могли виконувати запити.

Amazon Athena підтримує **можливість запитувати S3 дані, які вже зашифровані**, і, якщо налаштовано відповідним чином, **Athena також може шифрувати результати запиту, які потім можуть зберігатися в S3**.

Це шифрування результатів є незалежним від базових запитуваних S3 даних, тобто навіть якщо S3 дані не зашифровані, результати запиту можуть бути зашифровані. Варто пам’ятати, що Amazon Athena підтримує дані, зашифровані лише наступними методами шифрування S3: SSE-S3, SSE-KMS та CSE-KMS.

SSE-C та CSE-C не підтримуються. Крім того, важливо розуміти, що Amazon Athena виконуватиме запити лише до зашифрованих об’єктів, що знаходяться в тому ж регіоні, що й сам запит. Якщо вам потрібно виконувати запити до S3 даних, зашифрованих за допомогою KMS, користувачеві Athena потрібні відповідні дозволи для виконання такого запиту.

### Enumeration
```bash
# Get catalogs
aws athena list-data-catalogs

# Get databases inside catalog
aws athena list-databases --catalog-name <catalog-name>
aws athena list-table-metadata --catalog-name <catalog-name> --database-name <db-name>

# Get query executions, queries and results
aws athena list-query-executions
aws athena get-query-execution --query-execution-id <id> # Get query and meta of results
aws athena get-query-results --query-execution-id <id> # This will rerun the query and get the results

# Get workgroups & Prepared statements
aws athena list-work-groups
aws athena list-prepared-statements --work-group <wg-name>
aws athena get-prepared-statement --statement-name <name> --work-group <wg-name>

# Run query
aws athena start-query-execution --query-string <query>
```
## Посилання

- [https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3](https://cloudsecdocs.com/aws/defensive/tooling/cli/#s3)
- [https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/dual-stack-endpoints.html)

{{#include ../../../banners/hacktricks-training.md}}
