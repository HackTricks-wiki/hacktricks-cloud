# AWS - IAM Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## IAM

For more information about IAM access:

{{#ref}}
../aws-services/aws-iam-enum.md
{{#endref}}

## Confused Deputy Problem

यदि आप किसी **external account (A)** को अपने account में किसी **role** तक access करने की अनुमति देते हैं, तो आपके पास शायद यह देखने के लिए **0 visibility** होगी कि वास्तव में कौन उस external account को access कर सकता है। यह समस्या इसीलिए है क्योंकि अगर कोई अन्य external account (B) external account (A) को access कर सकता है तो सम्भव है कि **B भी आपके account को access कर सके**।

इसलिए, जब आप किसी external account को अपने account में किसी role तक access देने देते हैं तो आप एक `ExternalId` निर्दिष्ट कर सकते हैं। यह एक "secret" string है जिसे external account (A) को आपके संगठन में **assume the role in your organization** करने के लिए **need to specify** करना होता है। चूँकि **external account B won't know this string**, भले ही उसके पास A पर access हो, वह तब भी **won't be able to access your role**।

<figure><img src="../../../images/image (95).png" alt=""><figcaption></figcaption></figure>

हालाँकि, ध्यान दें कि यह `ExternalId` "secret" **not a secret** है — जो भी व्यक्ति **read the IAM assume role policy will be able to see it** वह इसे देख सकेगा। लेकिन जब तक external account A इसे जानता है और external account **B doesn't know it**, तब तक यह **prevents B abusing A to access your role**।

Example:
```json
{
"Version": "2012-10-17",
"Statement": {
"Effect": "Allow",
"Principal": {
"AWS": "Example Corp's AWS Account ID"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "12345"
}
}
}
}
```
> [!WARNING]
> किसी attacker के लिए confused deputy का फायदा उठाने हेतु उसे किसी तरह यह पता लगाना होगा कि current account के principals other accounts में roles की impersonate कर सकते हैं या नहीं।

### अनपेक्षित Trusts

#### Wildcard को principal के रूप में
```json
{
"Action": "sts:AssumeRole",
"Effect": "Allow",
"Principal": { "AWS": "*" }
}
```
यह पॉलिसी **सभी AWS को अनुमति देती है** कि वे भूमिका ग्रहण कर सकें।

#### प्रिंसिपल के रूप में सेवा
```json
{
"Action": "lambda:InvokeFunction",
"Effect": "Allow",
"Principal": { "Service": "apigateway.amazonaws.com" },
"Resource": "arn:aws:lambda:000000000000:function:foo"
}
```
यह नीति **किसी भी खाते** को उनके apigateway को इस Lambda को कॉल करने के लिए कॉन्फ़िगर करने की अनुमति देती है।

#### S3 को प्रिंसिपल के रूप में
```json
"Condition": {
"ArnLike": { "aws:SourceArn": "arn:aws:s3:::source-bucket" },
"StringEquals": {
"aws:SourceAccount": "123456789012"
}
}
```
यदि किसी S3 bucket को principal के रूप में दिया गया है, क्योंकि S3 buckets का Account ID नहीं होता, तो यदि आपने **deleted your bucket and the attacker created** it in their own account, तो वे इसका दुरुपयोग कर सकते हैं।

#### समर्थित नहीं
```json
{
"Effect": "Allow",
"Principal": { "Service": "cloudtrail.amazonaws.com" },
"Action": "s3:PutObject",
"Resource": "arn:aws:s3:::myBucketName/AWSLogs/MY_ACCOUNT_ID/*"
}
```
A common way to avoid Confused Deputy problems is the use of a condition with `AWS:SourceArn` to check the origin ARN. However, **कुछ सेवाएँ इसका समर्थन नहीं कर सकतीं** (कुछ स्रोतों के अनुसार जैसे CloudTrail)।

### क्रेडेंशियल हटाना
With any of the following permissions — `iam:DeleteAccessKey`, `iam:DeleteLoginProfile`, `iam:DeleteSSHPublicKey`, `iam:DeleteServiceSpecificCredential`, `iam:DeleteInstanceProfile`, `iam:DeleteServerCertificate`, `iam:DeleteCloudFrontPublicKey`, `iam:RemoveRoleFromInstanceProfile` — एक व्यक्ति access keys, login profiles, SSH keys, service-specific credentials, instance profiles, certificates या CloudFront public keys को हटाकर या instance profiles से roles को disassociate करके प्रभाव डाल सकता है। ऐसे कार्य तुरंत वैध उपयोगकर्ताओं और एप्लिकेशनों को ब्लॉक कर सकते हैं और उन प्रणालियों के लिए denial-of-service या पहुँच खोने का कारण बन सकते हैं जो उन क्रेडेंशियल पर निर्भर हैं, इसलिए इन IAM permissions को कड़ाई से सीमित और मॉनिटर किया जाना चाहिए।
```bash
# Remove Access Key of a user
aws iam delete-access-key \
--user-name <Username> \
--access-key-id AKIAIOSFODNN7EXAMPLE

## Remove ssh key of a user
aws iam delete-ssh-public-key \
--user-name <Username> \
--ssh-public-key-id APKAEIBAERJR2EXAMPLE
```
### पहचान हटाना
जैसे `iam:DeleteUser`, `iam:DeleteGroup`, `iam:DeleteRole`, या `iam:RemoveUserFromGroup` जैसी अनुमतियों के साथ, कोई कर्ता उपयोगकर्ताओं, रोल्स, या समूहों को हटा सकता है—या समूह सदस्यता बदल सकता है—जिससे पहचानें और संबंधित प्रमाण हट जाते हैं। इससे उन लोगों और सेवाओं के लिए तुरंत पहुँच टूट सकती है जो उन पहचानों पर निर्भर हैं, जिससे denial-of-service या पहुँच खोने की स्थिति हो सकती है, इसलिए इन IAM क्रियाओं को कड़ाई से सीमित और मॉनिटर किया जाना चाहिए।
```bash
# Delete a user
aws iam delete-user \
--user-name <Username>

# Delete a group
aws iam delete-group \
--group-name <Username>

# Delete a role
aws iam delete-role \
--role-name <Role>
```
###
निम्नलिखित अनुमतियों में से किसी एक — `iam:DeleteGroupPolicy`, `iam:DeleteRolePolicy`, `iam:DeleteUserPolicy`, `iam:DeletePolicy`, `iam:DeletePolicyVersion`, `iam:DeleteRolePermissionsBoundary`, `iam:DeleteUserPermissionsBoundary`, `iam:DetachGroupPolicy`, `iam:DetachRolePolicy`, `iam:DetachUserPolicy` — के साथ कोई भी कर्ता managed/inline policies को delete या detach कर सकता है, policy versions या permissions boundaries को हटा सकता है, और users, groups, या roles से policies को unlink कर सकता है। यह authorizations को नष्ट कर देता है और permissions model को बदल सकता है, जिससे उन principals के लिए जिन्हें उन policies पर निर्भरता थी तुरंत access खोना या denial-of-service हो सकता है, इसलिए इन IAM actions को कड़ाई से सीमित और मॉनिटर किया जाना चाहिए।
```bash
# Delete a group policy
aws iam delete-group-policy \
--group-name <GroupName> \
--policy-name <PolicyName>

# Delete a role policy
aws iam delete-role-policy \
--role-name <RoleName> \
--policy-name <PolicyName>
```
### फेडरेटेड पहचान हटाना
`iam:DeleteOpenIDConnectProvider`, `iam:DeleteSAMLProvider`, और `iam:RemoveClientIDFromOpenIDConnectProvider` के साथ, कोई व्यक्ति OIDC/SAML पहचान प्रदाताओं को हटा सकता है या क्लाइंट IDs निकाल सकता है। यह फेडरेटेड प्रमाणीकरण को बाधित कर देता है, टोकन सत्यापन को रोकता है और SSO पर निर्भर उपयोगकर्ताओं और सेवाओं की पहुँच को तुरंत नकार देता है जब तक कि IdP या कॉन्फ़िगरेशन पुनर्स्थापित नहीं किए जाते।
```bash
# Delete OIDCP provider
aws iam delete-open-id-connect-provider \
--open-id-connect-provider-arn arn:aws:iam::111122223333:oidc-provider/accounts.google.com

# Delete SAML provider
aws iam delete-saml-provider \
--saml-provider-arn arn:aws:iam::111122223333:saml-provider/CorporateADFS
```
### अनधिकृत MFA सक्रियकरण
With `iam:EnableMFADevice`, कोई हमलावर किसी उपयोगकर्ता की पहचान पर एक MFA device पंजीकृत कर सकता है, जिससे वैध उपयोगकर्ता साइन-इन नहीं कर पाएगा। एक बार अनधिकृत MFA सक्षम हो जाने पर उपयोगकर्ता तब तक लॉक आउट हो सकता है जब तक वह MFA device हटाया या रीसेट न किया जाए (नोट: यदि कई MFA devices पंजीकृत हैं, तो साइन-इन के लिए केवल एक पर्याप्त होता है, इसलिए यह हमला पहुँच रोकने पर प्रभावी नहीं होगा)।
```bash
aws iam enable-mfa-device \
--user-name <Username> \
--serial-number arn:aws:iam::111122223333:mfa/alice \
--authentication-code1 123456 \
--authentication-code2 789012
```
### Certificate/Key Metadata Tampering
`iam:UpdateSSHPublicKey`, `iam:UpdateCloudFrontPublicKey`, `iam:UpdateSigningCertificate`, `iam:UpdateServerCertificate` के साथ, एक हमलावर सार्वजनिक कुंजियों और प्रमाणपत्रों की स्थिति या मेटाडेटा बदल सकता है। कुंजियों/प्रमाणपत्रों को निष्क्रिय चिह्नित करके या संदर्भों में परिवर्तन करके वे SSH authentication तोड़ सकते हैं, X.509/TLS validations अमान्य कर सकते हैं, और उन सेवाओं को तुरंत बाधित कर सकते हैं जो उन क्रेडेंशियल्स पर निर्भर हैं, जिससे पहुंच या उपलब्धता खो सकती है।
```bash
aws iam update-ssh-public-key \
--user-name <Username> \
--ssh-public-key-id APKAEIBAERJR2EXAMPLE \
--status Inactive

aws iam update-server-certificate \
--server-certificate-name <Certificate_Name> \
--new-path /prod/
```
## संदर्भ

- [https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html)

{{#include ../../../banners/hacktricks-training.md}}
