# AWS - IAM Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

For more information about IAM access:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

## Confused Deputy समस्या

यदि आप **एक external account (A)** को अपने अकाउंट में किसी **role** तक पहुँच देने की अनुमति देते हैं, तो आपके पास संभवतः यह देखने की **कोई visibility नहीं** होगी कि **ठीक कौन उस external account तक पहुँच सकता है**। यह एक समस्या है, क्योंकि यदि किसी अन्य external account (B) को external account (A) तक पहुँच है तो सम्भव है कि **B भी आपके अकाउंट तक पहुँच सके**।

इसलिए, जब आप किसी external account को अपने अकाउंट में किसी role तक पहुँच देते हैं तो आप एक `ExternalId` निर्दिष्ट कर सकते हैं। यह एक "secret" string है जिसे external account (A) को आपकी संस्था में `assume the role` करने के लिए **specify करना ज़रूरी** होता है। चूँकि **external account B इस string को नहीं जानता होगा**, भले ही उसके पास A तक पहुँच हो, वह **आपके role तक पहुँचने में सक्षम नहीं होगा**।

<figure><img src="../../../images/image (95).png" alt=""><figcaption></figcaption></figure>

हालाँकि, ध्यान दें कि यह `ExternalId` "secret" **एक secret नहीं है**, कोई भी जो **IAM assume role policy पढ़ सकता है** वह इसे देख पाएगा। लेकिन जब तक external account A इसे जानता है और external account **B इसे नहीं जानता**, यह **B द्वारा A का दुरुपयोग कर आपके role तक पहुँचने को रोकता है**।

Example:
```json
{
"Version": "2012-10-17",
"Statement": {
"Effect": "Allow",
"Principal": {
"AWS": "Example Corp's AWS Account ID"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "12345"
}
}
}
}
```
> [!WARNING]
> किसी attacker को confused deputy का फायदा उठाने के लिए किसी तरह यह पता लगाना होगा कि क्या current account के principals अन्य accounts में roles impersonate कर सकते हैं।

### अनपेक्षित ट्रस्ट्स

#### Wildcard को principal के रूप में
```json
{
"Action": "sts:AssumeRole",
"Effect": "Allow",
"Principal": { "AWS": "*" }
}
```
यह नीति **सभी AWS** को भूमिका ग्रहण करने की अनुमति देती है।

#### Service को principal के रूप में
```json
{
"Action": "lambda:InvokeFunction",
"Effect": "Allow",
"Principal": { "Service": "apigateway.amazonaws.com" },
"Resource": "arn:aws:lambda:000000000000:function:foo"
}
```
यह नीति **किसी भी खाते** को उनके apigateway को इस Lambda को कॉल करने के लिए कॉन्फ़िगर करने की अनुमति देती है।

#### S3 को प्रिंसिपल के रूप में
```json
"Condition": {
"ArnLike": { "aws:SourceArn": "arn:aws:s3:::source-bucket" },
"StringEquals": {
"aws:SourceAccount": "123456789012"
}
}
```
यदि किसी principal के रूप में S3 bucket दिया गया है—क्योंकि S3 buckets का कोई Account ID नहीं होता—तो यदि आपने **अपना bucket हटा दिया और attacker ने** उसे अपने ही account में बना लिया, तो वे इसका दुरुपयोग कर सकते हैं।

#### समर्थित नहीं
```json
{
"Effect": "Allow",
"Principal": { "Service": "cloudtrail.amazonaws.com" },
"Action": "s3:PutObject",
"Resource": "arn:aws:s3:::myBucketName/AWSLogs/MY_ACCOUNT_ID/*"
}
```
A common way to avoid Confused Deputy problems is the use of a condition with `AWS:SourceArn` to check the origin ARN. However, **कुछ सेवाएँ यह समर्थन नहीं कर सकतीं** (कुछ स्रोतों के अनुसार जैसे CloudTrail)।

### क्रेडेंशियल हटाना
निम्नलिखित permissions में से किसी के साथ — `iam:DeleteAccessKey`, `iam:DeleteLoginProfile`, `iam:DeleteSSHPublicKey`, `iam:DeleteServiceSpecificCredential`, `iam:DeleteInstanceProfile`, `iam:DeleteServerCertificate`, `iam:DeleteCloudFrontPublicKey`, `iam:RemoveRoleFromInstanceProfile` — कोई अभिकर्ता access keys, login profiles, SSH keys, service-specific credentials, instance profiles, certificates या CloudFront public keys हटा सकता है, या instance profiles से roles को disassociate कर सकता है। ऐसी क्रियाएँ तुरंत वैध उपयोगकर्ताओं और एप्लिकेशन की पहुँच रोक सकती हैं और उन प्रणालियों के लिए जो उन credentials पर निर्भर हैं, denial-of-service या पहुँच खोने का कारण बन सकती हैं, इसलिए इन IAM permissions को कड़ाई से सीमित और मॉनिटर किया जाना चाहिए।
```bash
# Remove Access Key of a user
aws iam delete-access-key \
--user-name <Username> \
--access-key-id AKIAIOSFODNN7EXAMPLE

## Remove ssh key of a user
aws iam delete-ssh-public-key \
--user-name <Username> \
--ssh-public-key-id APKAEIBAERJR2EXAMPLE
```
### पहचान हटाना
जैसे अनुमतियाँ `iam:DeleteUser`, `iam:DeleteGroup`, `iam:DeleteRole`, या `iam:RemoveUserFromGroup` होने पर, कोई व्यक्ति users, roles, या groups को हटा सकता है—या समूह सदस्यता बदल सकता है—जिससे पहचान और संबंधित निशान हट जाते हैं। यह उन लोगों और सेवाओं के लिए तुरंत पहुँच तोड़ सकता है जो उन पहचान पर निर्भर हैं, जिससे denial-of-service या पहुँच खोने की स्थिति हो सकती है, इसलिए इन IAM कार्रवाइयों को कड़ाई से प्रतिबंधित और मॉनिटर किया जाना चाहिए।
```bash
# Delete a user
aws iam delete-user \
--user-name <Username>

# Delete a group
aws iam delete-group \
--group-name <Username>

# Delete a role
aws iam delete-role \
--role-name <Role>
```
###
इनमें से किसी भी अनुमति — `iam:DeleteGroupPolicy`, `iam:DeleteRolePolicy`, `iam:DeleteUserPolicy`, `iam:DeletePolicy`, `iam:DeletePolicyVersion`, `iam:DeleteRolePermissionsBoundary`, `iam:DeleteUserPermissionsBoundary`, `iam:DetachGroupPolicy`, `iam:DetachRolePolicy`, `iam:DetachUserPolicy` — के साथ कोई actor managed/inline policies को delete या detach कर सकता है, policy versions या permissions boundaries हटा सकता है, और users, groups, या roles से policies unlink कर सकता है। यह authorizations को नष्ट कर देता है और permissions मॉडल को बदल सकता है, जिससे उन प्रिंसिपल्स के लिए जो इन पॉलिसियों पर निर्भर थे तुरंत access की हानि या denial-of-service हो सकती है, इसलिए इन IAM actions को कड़ाई से सीमित और मॉनिटर किया जाना चाहिए।
```bash
# Delete a group policy
aws iam delete-group-policy \
--group-name <GroupName> \
--policy-name <PolicyName>

# Delete a role policy
aws iam delete-role-policy \
--role-name <RoleName> \
--policy-name <PolicyName>
```
### फेडरेटेड पहचान हटाना
`iam:DeleteOpenIDConnectProvider`, `iam:DeleteSAMLProvider`, और `iam:RemoveClientIDFromOpenIDConnectProvider` के साथ, एक actor OIDC/SAML identity providers को हटा सकता है या client IDs को निकाल सकता है। यह फेडरेटेड प्रमाणीकरण को बाधित कर देता है, token validation को रोकता है और उन उपयोगकर्ताओं और सेवाओं का तुरंत access अस्वीकार कर देता है जो SSO पर निर्भर हैं, जब तक कि IdP या कॉन्फ़िगरेशन पुनर्स्थापित न हो जाएँ।
```bash
# Delete OIDCP provider
aws iam delete-open-id-connect-provider \
--open-id-connect-provider-arn arn:aws:iam::111122223333:oidc-provider/accounts.google.com

# Delete SAML provider
aws iam delete-saml-provider \
--saml-provider-arn arn:aws:iam::111122223333:saml-provider/CorporateADFS
```
### अनधिकृत MFA सक्रियकरण
`iam:EnableMFADevice` के साथ, एक हमलावर किसी उपयोगकर्ता की पहचान पर एक MFA डिवाइस रजिस्टर कर सकता है, जिससे वैध उपयोगकर्ता का साइन-इन रोका जा सकता है। एक बार अनधिकृत MFA सक्षम हो जाने पर उपयोगकर्ता तब तक लॉक आउट हो सकता है जब तक डिवाइस को हटाया या रीसेट न किया जाए (नोट: यदि कई MFA डिवाइस रजिस्टर हैं, तो साइन-इन के लिए केवल एक की आवश्यकता होती है, इसलिए यह हमला एक्सेस को रोकने पर कोई प्रभाव नहीं डालेगा)।
```bash
aws iam enable-mfa-device \
--user-name <Username> \
--serial-number arn:aws:iam::111122223333:mfa/alice \
--authentication-code1 123456 \
--authentication-code2 789012
```
### प्रमाणपत्र/कुंजी मेटाडेटा छेड़छाड़
`iam:UpdateSSHPublicKey`, `iam:UpdateCloudFrontPublicKey`, `iam:UpdateSigningCertificate`, `iam:UpdateServerCertificate` के साथ, एक हमलावर सार्वजनिक कुंजियों और प्रमाणपत्रों की स्थिति या मेटाडेटा बदल सकता है। कुंजियों/प्रमाणपत्रों को निष्क्रिय चिह्नित करके या संदर्भ बदलकर, वे SSH authentication को तोड़ सकते हैं, X.509/TLS validations को अमान्य कर सकते हैं, और उन सेवाओं को तुरंत बाधित कर सकते हैं जो उन credentials पर निर्भर करती हैं, जिससे पहुँच या उपलब्धता का नुकसान हो सकता है।
```bash
aws iam update-ssh-public-key \
--user-name <Username> \
--ssh-public-key-id APKAEIBAERJR2EXAMPLE \
--status Inactive

aws iam update-server-certificate \
--server-certificate-name <Certificate_Name> \
--new-path /prod/
```
## संदर्भ

- [https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html)

{{#include ../../../../banners/hacktricks-training.md}}
