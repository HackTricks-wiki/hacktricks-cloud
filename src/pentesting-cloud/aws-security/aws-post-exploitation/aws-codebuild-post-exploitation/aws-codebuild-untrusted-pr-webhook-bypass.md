# AWS CodeBuild - Untrusted PR Webhook Bypass (CodeBreach-style)

{{#include ../../../../banners/hacktricks-training.md}}

Αυτό το διάνυσμα επίθεσης εμφανίζεται όταν μια δημόσια PR workflow είναι συνδεδεμένη με ένα προνομιούχο CodeBuild project με αδύναμους ελέγχους webhook.

Αν ένας εξωτερικός επιτιθέμενος μπορεί να κάνει το CodeBuild να εκτελέσει το pull request του, συνήθως μπορεί να αποκτήσει **αυθαίρετη εκτέλεση κώδικα μέσα στο build** (build scripts, dependency hooks, test scripts, κ.λπ.), και στη συνέχεια να μεταβεί σε μυστικά, IAM credentials, ή διαπιστευτήρια παρόχου πηγής.

## Why this is dangerous

Οι φίλτροι webhook του CodeBuild αξιολογούνται με μοτίβα regex (για φίλτρα εκτός `EVENT`). Στο φίλτρο `ACTOR_ACCOUNT_ID`, αυτό σημαίνει ότι ένα αδύναμο μοτίβο μπορεί να ταιριάξει περισσότερους χρήστες από όσους προβλεπόταν.
Αν μη αξιόπιστα PRs χτίζονται σε ένα project που έχει προνομιούχες AWS role άδειες ή GitHub credentials, αυτό μπορεί να μετατραπεί σε πλήρη συμβιβασμό της supply-chain.

Η Wiz έδειξε ένα πρακτικό σενάριο όπου:

1. Μια allowlist actor του webhook χρησιμοποίησε ένα **μη-αγκυρωμένο regex**.
2. Ένας επιτιθέμενος εγγράφηκε με ένα GitHub ID που ταίριαζε ως **superstring** ενός αξιόπιστου ID.
3. Ένα κακόβουλο PR προκάλεσε το CodeBuild.
4. Η εκτέλεση κώδικα στο build χρησιμοποιήθηκε για dump μνήμης και ανάκτηση source-provider διαπιστευτηρίων/tokens.

## Misconfigurations that allow external PR code execution

Τα ακόλουθα είναι λάθη υψηλού κινδύνου και πώς οι επιτιθέμενοι τα εκμεταλλεύονται:

1. **`EVENT` filters allow untrusted triggers**
- Κοινά επικίνδυνα events: `PULL_REQUEST_CREATED`, `PULL_REQUEST_UPDATED`, `PULL_REQUEST_REOPENED`.
- Άλλα events που μπορούν επίσης να γίνουν επικίνδυνα αν συνδεθούν με προνομιούχα builds: `PUSH`, `PULL_REQUEST_CLOSED`, `PULL_REQUEST_MERGED`, `RELEASED`, `PRERELEASED`, `WORKFLOW_JOB_QUEUED`.
- Bad: `EVENT="PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED"` σε ένα privileged project.
- Better: χρησιμοποιήστε έγκριση σχολίου PR και ελαχιστοποιήστε τα trigger events για προνομιούχα projects.
- Abuse: ο επιτιθέμενος ανοίγει/ενημερώνει PR ή κάνει push σε ένα branch που ελέγχει, και ο κώδικάς του εκτελείται στο CodeBuild.

2. **`ACTOR_ACCOUNT_ID` regex is weak**
- Bad: μη-αγκυρωμένα μοτίβα όπως `123456|7890123`.
- Better: ακριβής αντιστοίχιση με αγκύρωση `^(123456|7890123)$`.
- Abuse: το υπερ-ταίριασμα regex επιτρέπει σε μη εξουσιοδοτημένα GitHub IDs να περάσουν τις allowlists.

3. **Other regex filters are weak or missing**
- `HEAD_REF`
  - Bad: `refs/heads/.*`
  - Better: `^refs/heads/main$` (ή ρητή λίστα αξιόπιστων)
- `BASE_REF`
  - Bad: `.*`
  - Better: `^refs/heads/main$`
- `FILE_PATH`
  - Bad: έλλειψη περιορισμών διαδρομών
  - Better: αποκλείστε επικίνδυνα αρχεία όπως `^buildspec\\.yml$`, `^\\.github/workflows/.*`, `(^|/)package(-lock)?\\.json$`
- `COMMIT_MESSAGE`
  - Bad: εμπιστοσύνη σε δείκτη με χαλαρό ταίριασμα όπως `trusted`
  - Better: μη χρησιμοποιείτε το commit message ως όριο εμπιστοσύνης για την εκτέλεση PR
- `REPOSITORY_NAME` / `ORGANIZATION_NAME`
  - Bad: `.*` σε org/global webhooks
  - Better: μόνο ακριβείς matches για repo/org
- `WORKFLOW_NAME`
  - Bad: `.*`
  - Better: μόνο ακριβή matches ονόματος workflow (ή αποφύγετε αυτό ως έλεγχο εμπιστοσύνης)
- Abuse: ο επιτιθέμενος διαμορφώνει ref/path/message/repo context ώστε να ικανοποιήσει το επιτρεπτικό regex και να ενεργοποιήσει builds.

4. **`excludeMatchedPattern` is misused**
- Η λανθασμένη ρύθμιση αυτής της σημαίας μπορεί να αντιστρέψει την επιδιωκόμενη λογική.
- Bad: `FILE_PATH '^buildspec\\.yml$'` με `excludeMatchedPattern=false` όταν η πρόθεση ήταν να μπλοκαριστούν αλλαγές στο buildspec.
- Better: ίδιο μοτίβο με `excludeMatchedPattern=true` για να απορριφθούν τα builds που αγγίζουν το `buildspec.yml`.
- Abuse: οι υπεύθυνοι πιστεύουν ότι απορρίπτουν επικίνδυνα events/paths/actors, αλλά στην πραγματικότητα τα επιτρέπουν.

5. **Multiple `filterGroups` create accidental bypasses**
- Το CodeBuild αξιολογεί ομάδες ως OR (ένα περασμένο group είναι αρκετό).
- Bad: μια αυστηρή ομάδα + μια επιεικής fallback ομάδα (π.χ., μόνο `EVENT=PULL_REQUEST_UPDATED`).
- Better: αφαιρέστε fallback groups που δεν επιβάλλουν περιορισμούς actor/ref/path.
- Abuse: ο επιτιθέμενος χρειάζεται μόνο να ικανοποιήσει την ασθενέστερη ομάδα.

6. **Comment approval gate disabled or too permissive**
- `pullRequestBuildPolicy.requiresCommentApproval=DISABLED` είναι η λιγότερο ασφαλής επιλογή.
- Πολύ ευρείς ρόλοι εγκρίνοντων μειώνουν τον έλεγχο.
- Bad: `requiresCommentApproval=DISABLED`.
- Better: `ALL_PULL_REQUESTS` ή `FORK_PULL_REQUESTS` με ελάχιστους ρόλους εγκρίνοντων.
- Abuse: fork/drive-by PRs τρέχουν αυτόματα χωρίς έγκριση αξιόπιστου maintainer.

7. **No restrictive branch/path strategy for PR builds**
- Έλλειψη defense-in-depth με `HEAD_REF` + `BASE_REF` + `FILE_PATH`.
- Bad: μόνο `EVENT` + `ACTOR_ACCOUNT_ID`, χωρίς έλεγχο ref/path.
- Better: συνδυάστε ακριβείς `ACTOR_ACCOUNT_ID` + `BASE_REF` + `HEAD_REF` + `FILE_PATH` περιορισμούς.
- Abuse: ο επιτιθέμενος τροποποιεί εισόδους build (buildspec/CI/dependencies) και αποκτά αυθαίρετη εκτέλεση εντολών.

8. **Public visibility + status URL exposure**
- Δημόσια URLs build/check βελτιώνουν την αναγνώριση και τη διαδοχική δοκιμή από τον επιτιθέμενο.
- Bad: `projectVisibility=PUBLIC_READ` με ευαίσθητα logs/config σε δημόσια builds.
- Better: κρατήστε τα projects ιδιωτικά εκτός αν υπάρχει ισχυρός επιχειρηματικός λόγος, και κάντε sanitize logs/artifacts.
- Abuse: ο επιτιθέμενος ανακαλύπτει μοτίβα/συμπεριφορές project και στη συνέχεια βελτιώνει payloads και προσπάθειες bypass.

## Token leakage from memory

Το write-up της Wiz εξηγεί ότι τα διαπιστευτήρια παρόχου πηγής υπάρχουν στο runtime context του build και μπορούν να κλαπούν μετά από συμβιβασμό του build (π.χ. μέσω memory dumping), επιτρέποντας takeover του αποθετηρίου αν τα scopes είναι ευρεία.

Η AWS εισήγαγε hardening μετά την αποκάλυψη, αλλά το βασικό μάθημα παραμένει: **ποτέ μην εκτελείτε μη αξιόπιστο κώδικα PR σε προνομιούχα build contexts** και θεωρήστε ότι ο κώδικας που ελέγχεται από επιτιθέμενο θα προσπαθήσει να κλέψει διαπιστευτήρια.

Για πρόσθετες τεχνικές κλοπής διαπιστευτηρίων στο CodeBuild, δείτε επίσης:

{{#ref}}
aws-codebuild-token-leakage.md
{{#endref}}

## Finding CodeBuild URLs in GitHub PRs

Αν το CodeBuild αναφέρει το status ενός commit πίσω στο GitHub, το CodeBuild build URL συνήθως εμφανίζεται σε:

1. **PR page** -> **Checks** tab (ή η γραμμή κατάστασης στην Conversation/Commits).
2. **Commit page** -> status/checks section -> **Details** link.
3. **PR commits list** -> κάντε κλικ στο check context που είναι επισυναπτόμενο σε ένα commit.

Για δημόσια projects, αυτό το link μπορεί να αποκαλύψει μεταδεδομένα/διαμόρφωση του build σε μη αυθεντικοποιημένους χρήστες.

<details>
<summary>Script: detect CodeBuild URLs in a PR and test if they look public</summary>
```bash
#!/usr/bin/env bash
set -euo pipefail

# Usage:
#   ./check_pr_codebuild_urls.sh <owner> <repo> <pr_number>
#
# Requirements: gh, jq, curl

OWNER="${1:?owner}"
REPO="${2:?repo}"
PR="${3:?pr_number}"

for bin in gh jq curl timeout; do
command -v "$bin" >/dev/null || { echo "[!] Missing dependency: $bin" >&2; exit 1; }
done

tmp_commits="$(mktemp)"
tmp_urls="$(mktemp)"
trap 'rm -f "$tmp_commits" "$tmp_urls"' EXIT

gh_api() {
timeout 20s gh api "$@" 2>/dev/null || true
}

# Get all commit SHAs in the PR (bounded call to avoid hangs)
gh_api "repos/${OWNER}/${REPO}/pulls/${PR}/commits" --paginate --jq '.[].sha' > "$tmp_commits"
if [ ! -s "$tmp_commits" ]; then
echo "[!] No commits found (or API call timed out/failed)." >&2
exit 1
fi

echo "[*] PR commits:"
cat "$tmp_commits"
echo

echo "[*] Searching commit statuses/check-runs for CodeBuild URLs..."

while IFS= read -r sha; do
[ -z "$sha" ] && continue

# Classic commit statuses (target_url)
gh_api "repos/${OWNER}/${REPO}/commits/${sha}/status" \
--jq '.statuses[]? | .target_url // empty' 2>/dev/null || true

# GitHub Checks API (details_url)
gh_api "repos/${OWNER}/${REPO}/commits/${sha}/check-runs" \
--jq '.check_runs[]? | .details_url // empty' 2>/dev/null || true
done < "$tmp_commits" | sort -u > "$tmp_urls"

grep -Ei 'codebuild|codebuild\.aws\.amazon\.com|console\.aws\.amazon\.com/.*/codebuild' "$tmp_urls" || true

echo
echo "[*] Public-access heuristic:"
echo "    - If URL redirects to signin.aws.amazon.com -> likely not public"
echo "    - If URL is directly reachable (HTTP 200) without auth redirect -> potentially public"
echo

cb_urls="$(grep -Ei 'codebuild|codebuild\.aws\.amazon\.com|console\.aws\.amazon\.com/.*/codebuild' "$tmp_urls" || true)"
if [ -z "$cb_urls" ]; then
echo "[*] No CodeBuild URLs found in PR statuses/check-runs."
exit 0
fi

while IFS= read -r url; do
[ -z "$url" ] && continue
final_url="$(timeout 20s curl -4 -sS -L --connect-timeout 5 --max-time 20 -o /dev/null -w '%{url_effective}' "$url" || true)"
code="$(timeout 20s curl -4 -sS -L --connect-timeout 5 --max-time 20 -o /dev/null -w '%{http_code}' "$url" || true)"

if echo "$final_url" | grep -qi 'signin\.aws\.amazon\.com'; then
verdict="NOT_PUBLIC_OR_AUTH_REQUIRED"
elif [ "$code" = "200" ]; then
verdict="POTENTIALLY_PUBLIC"
else
verdict="UNKNOWN_CHECK_MANUALLY"
fi

printf '%s\t%s\t%s\n' "$verdict" "$code" "$url"
done <<< "$cb_urls"
```
Δοκιμάστηκε και λειτουργεί με:
```bash
bash /tmp/check_pr_codebuild_urls.sh carlospolop codebuild-codebreach-ctf-lab 1
```
</details>

## Σύντομη λίστα ελέγχου
```bash
# Enumerate projects
aws codebuild list-projects

# Inspect source/webhook configuration
aws codebuild batch-get-projects --names <project-name>

# Inspect global source credentials configured in account
aws codebuild list-source-credentials
```
Ελέγξτε κάθε έργο για:

- `webhook.filterGroups` που περιέχουν PR events.
- `ACTOR_ACCOUNT_ID` πρότυπα που δεν είναι αγκυρωμένα με `^...$`.
- `pullRequestBuildPolicy.requiresCommentApproval` με τιμή `DISABLED`.
- Έλλειψη περιορισμών branch/path.
- `serviceRole` υψηλών προνομίων.
- Επικίνδυνη εμβέλεια και επαναχρησιμοποίηση των source credentials.

## Οδηγίες θωράκισης

1. Απαιτήστε έγκριση σχολίου για PR builds (`ALL_PULL_REQUESTS` ή `FORK_PULL_REQUESTS`).
2. Εάν χρησιμοποιείτε allowlists για actors, αγκυρώστε τα regex και κρατήστε τα ακριβή.
3. Προσθέστε περιορισμούς `FILE_PATH` για να αποφύγετε μη αξιόπιστες τροποποιήσεις του `buildspec.yml` και των CI scripts.
4. Διαχωρίστε τα αξιόπιστα release builds από τα μη αξιόπιστα PR builds σε ξεχωριστά projects/roles.
5. Χρησιμοποιήστε λεπτομερή, με ελάχιστα προνόμια source-provider tokens (προτιμήστε αφιερωμένες low-privilege ταυτότητες).
6. Επιθεωρείτε συνεχώς τα webhook filters και τη χρήση των source credentials.

## Αναφορές

- [Wiz: CodeBreach - AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)
- [AWS CodeBuild API - WebhookFilter](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_WebhookFilter.html)
- [AWS CLI - codebuild create-webhook](https://docs.aws.amazon.com/cli/latest/reference/codebuild/create-webhook.html)
- [AWS CodeBuild User Guide - Best practices for webhooks](https://docs.aws.amazon.com/codebuild/latest/userguide/webhooks.html)

{{#include ../../../../banners/hacktricks-training.md}}
