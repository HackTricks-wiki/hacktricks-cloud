# AWS CodeBuild - Untrusted PR Webhook Bypass (CodeBreach-style)

{{#include ../../../../banners/hacktricks-training.md}}

Bu saldırı vektörü, bir **public-facing PR workflow**'un zayıf webhook kontrolleriyle bir **privileged CodeBuild project**'e bağlı olduğu durumlarda ortaya çıkar.

Eğer dış bir saldırgan CodeBuild'in kendi pull request'ini çalıştırmasını sağlayabilirse, genellikle **build içinde keyfi kod çalıştırma** elde eder (build script'leri, dependency hook'ları, test script'leri vb.) ve ardından secret'lara, IAM kimlik bilgilerine veya source-provider kimlik bilgilerine pivot yapar.

## Why this is dangerous

CodeBuild webhook filtreleri (non-`EVENT` filtreleri için) regex pattern'leri ile değerlendirilir. `ACTOR_ACCOUNT_ID` filtresinde, zayıf bir pattern hedeflenen kullanıcıdan daha fazlasıyla eşleşebilir.
Eğer untrusted PR'ler privileged AWS role izinlerine veya GitHub kimlik bilgilerine sahip bir projede build ediliyorsa, bu tam bir supply-chain compromise'a dönüşebilir.

Wiz pratik bir zinciri şu şekilde gösterdi:

1. Webhook actor allowlist bir **unanchored regex** kullandı.
2. Saldırgan, trusted ID'nin **superstring**i olarak eşleşen bir GitHub ID'si kaydetti.
3. Kötü amaçlı bir PR CodeBuild'i tetikledi.
4. Build içinde kod çalıştırılarak bellek dökümü yapıldı ve source-provider kimlik bilgileri/token'ları ele geçirildi.

## Misconfigurations that allow external PR code execution

Aşağıdakiler yüksek riskli hatalar ve saldırganların her birini nasıl suistimal ettiği:

1. **`EVENT` filters allow untrusted triggers**
- Yaygın riskli event'ler: `PULL_REQUEST_CREATED`, `PULL_REQUEST_UPDATED`, `PULL_REQUEST_REOPENED`.
- Ayrıcalıklı build'lere bağlandığında tehlikeli olabilecek diğer event'ler: `PUSH`, `PULL_REQUEST_CLOSED`, `PULL_REQUEST_MERGED`, `RELEASED`, `PRERELEASED`, `WORKFLOW_JOB_QUEUED`.
- Kötü: privileged bir projede `EVENT="PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED"`.
- Daha iyi: privileged projeler için PR comment approval kullanın ve tetiklenen event sayısını en aza indirin.
- Suistimal: saldırgan kendi kontrolündeki bir branch'e PR açar/günceller veya push yapar ve kodu CodeBuild içinde çalışır.

2. **`ACTOR_ACCOUNT_ID` regex is weak**
- Kötü: `123456|7890123` gibi unanchored pattern'ler.
- Daha iyi: tam eşleşme anchoring `^(123456|7890123)$`.
- Suistimal: regex over-match, yetkisiz GitHub ID'lerinin allowlist'ten geçmesine izin verir.

3. **Other regex filters are weak or missing**
- `HEAD_REF`
  - Kötü: `refs/heads/.*`
  - Daha iyi: `^refs/heads/main$` (veya açıkça belirtilmiş trusted liste)
- `BASE_REF`
  - Kötü: `.*`
  - Daha iyi: `^refs/heads/main$`
- `FILE_PATH`
  - Kötü: path kısıtlaması yok
  - Daha iyi: `^buildspec\\.yml$`, `^\\.github/workflows/.*`, `(^|/)package(-lock)?\\.json$` gibi riskli dosyaları hariç tutun
- `COMMIT_MESSAGE`
  - Kötü: `trusted` gibi gevşek bir eşleşmeyle güven işareti kabul etmek
  - Daha iyi: commit mesajını PR execution için bir trust boundary olarak kullanmayın
- `REPOSITORY_NAME` / `ORGANIZATION_NAME`
  - Kötü: org/global webhook'larda `.*`
  - Daha iyi: sadece tam repo/org eşleşmeleri
- `WORKFLOW_NAME`
  - Kötü: `.*`
  - Daha iyi: sadece tam workflow adı eşleşmeleri (veya bunu trust kontrolü olarak kullanmaktan kaçının)
- Suistimal: saldırgan permissive regex'i sağlamak için ref/path/message/repo bağlamını uydurur ve build'leri tetikler.

4. **`excludeMatchedPattern` is misused**
- Bu flag yanlış ayarlandığında niyet edilen mantığı tersine çevirebilir.
- Kötü: buildspec değişikliklerini engellemek niyetiyle `FILE_PATH '^buildspec\\.yml$'` ile `excludeMatchedPattern=false`.
- Daha iyi: `buildspec.yml`'i engellemek için aynı pattern ile `excludeMatchedPattern=true`.
- Suistimal: savunucular riskli event/path/actor'ları engellediklerini sanırken aslında izin veriyor olabilirler.

5. **Multiple `filterGroups` create accidental bypasses**
- CodeBuild, grupları OR olarak değerlendirir (bir passing group yeterlidir).
- Kötü: bir sıkı grup + bir izin verici fallback grup (örn. sadece `EVENT=PULL_REQUEST_UPDATED`).
- Daha iyi: actor/ref/path kısıtlamalarını uygulamayan fallback gruplarını kaldırın.
- Suistimal: saldırgan en zayıf grubu sağlamak zorundadır.

6. **Comment approval gate disabled or too permissive**
- `pullRequestBuildPolicy.requiresCommentApproval=DISABLED` en güvensiz olandır.
- Çok geniş approver rolleri kontrolü azaltır.
- Kötü: `requiresCommentApproval=DISABLED`.
- Daha iyi: minimal approver rolleri ile `ALL_PULL_REQUESTS` veya `FORK_PULL_REQUESTS`.
- Suistimal: fork/drive-by PR'ler trusted maintainer onayı olmadan otomatik çalışır.

7. **No restrictive branch/path strategy for PR builds**
- `HEAD_REF` + `BASE_REF` + `FILE_PATH` ile defense-in-depth eksikliği.
- Kötü: sadece `EVENT` + `ACTOR_ACCOUNT_ID`, ref/path kontrolleri yok.
- Daha iyi: tam `ACTOR_ACCOUNT_ID` + `BASE_REF` + `HEAD_REF` + `FILE_PATH` kısıtlamalarını kombine edin.
- Suistimal: saldırgan build girdilerini (buildspec/CI/dependencies) değiştirir ve keyfi komut çalıştırma elde eder.

8. **Public visibility + status URL exposure**
- Public build/check URL'leri saldırganın reconnaissance ve iteratif test yapmasını kolaylaştırır.
- Kötü: hassas log/config içeren public build'lerde `projectVisibility=PUBLIC_READ`.
- Daha iyi: güçlü bir iş ihtiyacı yoksa projeleri private tutun ve log/artifact'leri sanitize edin.
- Suistimal: saldırgan proje pattern'lerini/behaviour'larını keşfeder, payload ve bypass denemelerini ayarlar.

## Token leakage from memory

Wiz'in raporu, source-provider kimlik bilgilerinin build runtime context'inde bulunduğunu ve build compromise sonrası (ör. bellek dökümü yoluyla) çalınabileceğini, geniş scope'luysa repository takeover'a izin verebileceğini açıklıyor.

AWS ifşadan sonra hardening uyguladı, ancak temel ders değişmedi: **privileged build context'lerinde asla untrusted PR kodu çalıştırmayın** ve attacker kontrollü build kodunun kimlik bilgisi hırsızlığı deneyeceğini varsayın.

CodeBuild'de ek credential theft teknikleri için ayrıca bakın:

{{#ref}}
aws-codebuild-token-leakage.md
{{#endref}}

## Finding CodeBuild URLs in GitHub PRs

Eğer CodeBuild commit status'u GitHub'a raporluyorsa, CodeBuild build URL'si genellikle şu yerlerde görünür:

1. **PR page** -> **Checks** sekmesi (veya Conversation/Commits içindeki status satırı).
2. **Commit page** -> status/checks bölümü -> **Details** linki.
3. **PR commits list** -> bir commite bağlı check context'e tıklayın.

Public projeler için bu link, kimliği doğrulanmamış kullanıcılara build meta/veri/config açıklayabilir.

<details>
<summary>Script: detect CodeBuild URLs in a PR and test if they look public</summary>
```bash
#!/usr/bin/env bash
set -euo pipefail

# Usage:
#   ./check_pr_codebuild_urls.sh <owner> <repo> <pr_number>
#
# Requirements: gh, jq, curl

OWNER="${1:?owner}"
REPO="${2:?repo}"
PR="${3:?pr_number}"

for bin in gh jq curl timeout; do
command -v "$bin" >/dev/null || { echo "[!] Missing dependency: $bin" >&2; exit 1; }
done

tmp_commits="$(mktemp)"
tmp_urls="$(mktemp)"
trap 'rm -f "$tmp_commits" "$tmp_urls"' EXIT

gh_api() {
timeout 20s gh api "$@" 2>/dev/null || true
}

# Get all commit SHAs in the PR (bounded call to avoid hangs)
gh_api "repos/${OWNER}/${REPO}/pulls/${PR}/commits" --paginate --jq '.[].sha' > "$tmp_commits"
if [ ! -s "$tmp_commits" ]; then
echo "[!] No commits found (or API call timed out/failed)." >&2
exit 1
fi

echo "[*] PR commits:"
cat "$tmp_commits"
echo

echo "[*] Searching commit statuses/check-runs for CodeBuild URLs..."

while IFS= read -r sha; do
[ -z "$sha" ] && continue

# Classic commit statuses (target_url)
gh_api "repos/${OWNER}/${REPO}/commits/${sha}/status" \
--jq '.statuses[]? | .target_url // empty' 2>/dev/null || true

# GitHub Checks API (details_url)
gh_api "repos/${OWNER}/${REPO}/commits/${sha}/check-runs" \
--jq '.check_runs[]? | .details_url // empty' 2>/dev/null || true
done < "$tmp_commits" | sort -u > "$tmp_urls"

grep -Ei 'codebuild|codebuild\.aws\.amazon\.com|console\.aws\.amazon\.com/.*/codebuild' "$tmp_urls" || true

echo
echo "[*] Public-access heuristic:"
echo "    - If URL redirects to signin.aws.amazon.com -> likely not public"
echo "    - If URL is directly reachable (HTTP 200) without auth redirect -> potentially public"
echo

cb_urls="$(grep -Ei 'codebuild|codebuild\.aws\.amazon\.com|console\.aws\.amazon\.com/.*/codebuild' "$tmp_urls" || true)"
if [ -z "$cb_urls" ]; then
echo "[*] No CodeBuild URLs found in PR statuses/check-runs."
exit 0
fi

while IFS= read -r url; do
[ -z "$url" ] && continue
final_url="$(timeout 20s curl -4 -sS -L --connect-timeout 5 --max-time 20 -o /dev/null -w '%{url_effective}' "$url" || true)"
code="$(timeout 20s curl -4 -sS -L --connect-timeout 5 --max-time 20 -o /dev/null -w '%{http_code}' "$url" || true)"

if echo "$final_url" | grep -qi 'signin\.aws\.amazon\.com'; then
verdict="NOT_PUBLIC_OR_AUTH_REQUIRED"
elif [ "$code" = "200" ]; then
verdict="POTENTIALLY_PUBLIC"
else
verdict="UNKNOWN_CHECK_MANUALLY"
fi

printf '%s\t%s\t%s\n' "$verdict" "$code" "$url"
done <<< "$cb_urls"
```
Aşağıdaki ile test edildi:
```bash
bash /tmp/check_pr_codebuild_urls.sh carlospolop codebuild-codebreach-ctf-lab 1
```
</details>

## Hızlı denetim kontrol listesi
```bash
# Enumerate projects
aws codebuild list-projects

# Inspect source/webhook configuration
aws codebuild batch-get-projects --names <project-name>

# Inspect global source credentials configured in account
aws codebuild list-source-credentials
```
Her projeyi şu konular açısından inceleyin:

- `webhook.filterGroups` içinde PR olayları olması.
- `ACTOR_ACCOUNT_ID` desenlerinin `^...$` ile anchorlanmamış olması.
- `pullRequestBuildPolicy.requiresCommentApproval` değerinin `DISABLED` olması.
- Eksik branch/path kısıtlamaları.
- Yüksek ayrıcalıklı `serviceRole`.
- Riskli kaynak kimlik bilgileri kapsamı ve yeniden kullanımı.

## Sertleştirme önerileri

1. PR build'ları için yorum onayı gerektirin (`ALL_PULL_REQUESTS` veya `FORK_PULL_REQUESTS`).
2. Actor allowlist kullanıyorsanız, regex'leri ^...$ ile sınırlandırın ve tam eşleşme sağlayın.
3. Güvenilmeyen düzenlemelerin `buildspec.yml` ve CI scriptlerine erişmesini önlemek için `FILE_PATH` kısıtlamaları ekleyin.
4. Güvenilir release build'lerini güvenilmeyen PR build'lerinden ayrı projelere/rollere ayırın.
5. Kaynak sağlayıcı token'ları için en az ayrıcalıklı, ince taneli izinler kullanın (tercihen adanmış düşük ayrıcalıklı kimlikleri tercih edin).
6. Webhook filtrelerini ve kaynak kimlik bilgisi kullanımını sürekli denetleyin.

## Referanslar

- [Wiz: CodeBreach - AWS CodeBuild ACTOR_ID regex bypass and token theft](https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild)
- [AWS CodeBuild API - WebhookFilter](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_WebhookFilter.html)
- [AWS CLI - codebuild create-webhook](https://docs.aws.amazon.com/cli/latest/reference/codebuild/create-webhook.html)
- [AWS CodeBuild User Guide - Best practices for webhooks](https://docs.aws.amazon.com/codebuild/latest/userguide/webhooks.html)

{{#include ../../../../banners/hacktricks-training.md}}
