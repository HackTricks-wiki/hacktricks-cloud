# AWS - S3 Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## S3

For more information check:

{{#ref}}
../../aws-services/aws-s3-athena-and-glacier-enum.md
{{#endref}}

### 민감한 정보

때때로 버킷에서 읽을 수 있는 형태로 민감한 정보를 찾을 수 있습니다. 예: terraform state secrets.

### Pivoting

다른 플랫폼들이 민감한 자산을 저장하기 위해 S3를 사용할 수 있습니다. 예를 들어, **airflow**는 그곳에 **DAGs** **code**를 저장할 수 있고, **web pages**는 S3에서 직접 제공될 수 있습니다. 쓰기 권한을 가진 공격자는 버킷의 **code**를 **modify the code**하여 다른 플랫폼으로 **pivot**하거나, JS 파일을 수정해 **takeover accounts**할 수 있습니다.

### S3 Ransomware

이 시나리오에서, **공격자는 자신의 AWS 계정** 또는 다른 침해된 계정에 KMS (Key Management Service) 키를 생성합니다. 그 후 이 **키를 전 세계 누구나 접근 가능하게** 만들어, 어떤 AWS 사용자, 역할, 계정도 이 키로 객체를 암호화할 수 있게 합니다. 그러나 해당 객체는 복호화할 수 없습니다.

공격자는 여러 방법으로 대상 **S3 bucket**을 식별하고 그에 대한 쓰기 권한을 획득합니다. 이는 버킷 설정이 부적절해 공개되어 있거나 공격자가 AWS 환경 자체에 접근했기 때문일 수 있습니다. 공격자는 일반적으로 PII, PHI, 로그, 백업 등 민감한 정보를 담고 있는 버킷을 표적으로 삼습니다.

버킷이 ransomware의 대상이 될 수 있는지 판단하기 위해 공격자는 구성 설정을 확인합니다. 여기에는 **S3 Object Versioning**이 활성화되었는지, **multi-factor authentication delete (MFA delete)**가 활성화되었는지를 확인하는 것이 포함됩니다. Object Versioning이 활성화되어 있지 않다면 공격자는 진행할 수 있습니다. Object Versioning이 활성화되어 있지만 MFA delete가 비활성화되어 있으면 공격자는 **Object Versioning을 비활성화(disable Object Versioning)**할 수 있습니다. Object Versioning과 MFA delete가 모두 활성화되어 있다면 해당 버킷을 ransomware 대상으로 만드는 것이 더 어려워집니다.

공격자는 AWS API를 사용해 버킷의 각 객체를 자신의 KMS 키로 암호화된 복사본으로 교체합니다(예: **replaces each object in the bucket with an encrypted copy using their KMS key**). 이렇게 하면 버킷의 데이터가 사실상 암호화되어 키 없이는 접근할 수 없게 됩니다.

추가 압박을 위해 공격자는 공격에 사용한 KMS 키의 삭제를 예약할 수 있습니다. 이렇게 하면 키가 삭제되어 데이터가 영구적으로 손실되기 전, 대상은 데이터를 복구할 수 있는 7일의 기한을 갖게 됩니다.

마지막으로 공격자는 보통 "ransom-note.txt"라는 이름의 최종 파일을 업로드해, 대상이 파일을 복구하는 방법에 대한 지침을 제공합니다. 이 파일은 암호화 없이 업로드되어 대상의 주의를 끌고 랜섬웨어 공격 사실을 알리기 위함입니다.

#### SSE-C (Customer-Provided Key) Ransomware (Codefinger-like)

또 다른 변형으로는 **SSE-C**(S3 server-side encryption with **customer-provided keys**)를 악용하는 방법이 있습니다. SSE-C의 경우 **클라이언트가 모든 요청에 암호화 키를 제공**하며 **AWS는 키를 저장하지 않습니다**. 따라서 공격자가 **자신의 SSE-C 키**로 객체를 다시 작성하면, 피해자는 공격자가 제어하는 키를 제공하지 않는 한 데이터에 접근하거나 읽을 수 없습니다.

- **전제조건(Preconditions):** AWS 자격증명 탈취(또는 적절한 권한을 가진 어떤 principal) 및 객체를 **rewrite objects**할 수 있는 능력(예: 대상 키/프리픽스에서의 `s3:PutObject`). 이는 종종 파괴적인 lifecycle 정책을 설정할 수 있는 권한(아래 참조)과 결합됩니다(예: `s3:PutLifecycleConfiguration`).
- **공격 체인(Attack chain):**
1. 공격자가 무작위 256비트 키(AES-256)를 생성하고 보관합니다.
2. 공격자가 SSE-C 헤더를 사용해 기존 객체(동일한 객체 키)를 **rewrites**하여 저장된 객체가 공격자 키로 암호화되도록 합니다.
3. 피해자는 SSE-C 키를 제공하지 않으면 다운로드/복호화할 수 없습니다(설령 IAM 권한이 충분하더라도).
4. 공격자는 키를 삭제하거나(또는 단순히 제공하지 않음) 데이터 복구를 불가능하게 만들 수 있습니다.

Example (conceptual) CLI usage:
```bash
# Upload/overwrite an object encrypted with attacker-provided SSE-C key
aws s3 cp ./file s3://<BUCKET>/<KEY> \
--sse-c AES256 \
--sse-c-key <BASE64_32_BYTES>

# Download requires providing the same key again
aws s3 cp s3://<BUCKET>/<KEY> ./file \
--sse-c AES256 \
--sse-c-key <BASE64_32_BYTES>
```
##### 압박 가하기: 수명 주기 "타이머" 남용

복구 옵션(예: 이전 버전)을 제거하기 위해, 공격자는 SSE-C 재작성과 **수명 주기 규칙(lifecycle rules)**를 결합해 객체를 만료시키거나 일정 기간 후 비현재(noncurrent) 버전을 삭제할 수 있습니다:

- 버킷에 대한 `s3:PutLifecycleConfiguration` 권한은 공격자가 각 객체/버전에 대해 명시적 삭제 작업을 수행하지 않고도 삭제를 예약할 수 있게 합니다.
- 이는 **versioning이 활성화된** 경우에 특히 큰 영향을 미치는데, 그렇지 않으면 복구를 허용했을 "이전의 정상 버전"을 제거할 수 있기 때문입니다.

##### 감지 및 완화

- 특별한 운영상의 이유가 없다면 SSE-C보다 **SSE-KMS**(또는 SSE-S3)를 선호하세요.
- SSE-C 헤더를 사용하는 `PutObject` 요청을 모니터링/경보하세요 (S3에 대한 CloudTrail 데이터 이벤트).
- 예상치 못한 `PutBucketLifecycleConfiguration`(수명 주기 변경)을 모니터링/경보하세요.
- 덮어쓰기 활동의 급증(같은 키가 빠르게 업데이트됨) 및 delete-marker/버전 삭제를 모니터링/경보하세요.
- 고위험 권한 제한: `s3:PutObject`을 필요한 접두사로 제한하세요; `s3:PutLifecycleConfiguration` 및 `s3:PutBucketVersioning`은 엄격히 제한하세요; 민감한 관리자 작업에 대해 MFA를 요구(적용 가능한 경우)하고 승인 절차가 있는 별도 관리자 역할을 사용 고려하세요.
- 복구 태세: **versioning**, **backups**, 불변(immutable)/오프라인 복사본 사용(보호된 계정으로의 S3 복제, 백업 볼트 등); 비현재(noncurrent) 버전을 과도한 삭제로부터 보호하고 SCPs / 가드레일로 수명 주기 변경을 차단하세요.

### `s3:RestoreObject`

`s3:RestoreObject` 권한을 가진 공격자는 Glacier 또는 Deep Archive에 보관된 객체를 재활성화하여 일시적으로 접근 가능하게 만들 수 있습니다. 이는 보통 접근 불가능한 과거 아카이브된 데이터(백업, 스냅샷, 로그, 증명서, 오래된 비밀 등)의 복구 및 exfiltration을 가능하게 합니다. 공격자가 이 권한을 s3:GetObject와 같은 읽기 권한과 결합하면 민감한 데이터의 전체 복사본을 획득할 수 있습니다.
```bash
aws s3api restore-object \
--bucket <BUCKET_NAME> \
--key <OBJECT_KEY> \
--restore-request '{
"Days": <NUMBER_OF_DAYS>,
"GlacierJobParameters": { "Tier": "Standard" }
}'
```
### `s3:Delete*`

해당 s3:Delete* 권한을 가진 공격자는 객체, 버전, 전체 버킷을 삭제하고 백업을 중단시켜 즉각적이고 되돌릴 수 없는 데이터 손실, 증거 파기, 그리고 백업 또는 복구 아티팩트의 손상을 초래할 수 있습니다.
```bash
# Delete an object from a bucket
aws s3api delete-object \
--bucket <BUCKET_NAME> \
--key <OBJECT_KEY>

# Delete a specific version
aws s3api delete-object \
--bucket <BUCKET_NAME> \
--key <OBJECT_KEY> \
--version-id <VERSION_ID>

# Delete a bucket
aws s3api delete-bucket \
--bucket <BUCKET_NAME>
```
**자세한 정보** [**원본 연구를 확인하세요**](https://rhinosecuritylabs.com/aws/s3-ransomware-part-1-attack-vector/)**.**

{{#include ../../../../banners/hacktricks-training.md}}
