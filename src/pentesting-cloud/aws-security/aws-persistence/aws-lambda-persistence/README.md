# AWS - Lambda 지속성

{{#include ../../../../banners/hacktricks-training.md}}

## Lambda

자세한 내용은 다음을 확인하세요:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### Lambda Layer 지속성

Lambda가 실행될 때 은밀하게 임의 코드를 실행하기 위해 **layer를 도입/백도어화**할 수 있습니다:

{{#ref}}
aws-lambda-layers-persistence.md
{{#endref}}

### Lambda Extension 지속성

Lambda Layers를 악용하면 extensions를 악용해 Lambda 내부에 지속성을 확보하고 요청을 탈취·변조할 수도 있습니다.

{{#ref}}
aws-abusing-lambda-extensions.md
{{#endref}}

### 리소스 정책을 통한 방법

외부 계정에 invoke나 update code와 같은 다양한 Lambda 액션에 대한 접근 권한을 부여할 수 있습니다:

<figure><img src="../../../../images/image (255).png" alt=""><figcaption></figcaption></figure>

### 버전, 별칭 및 가중치

Lambda는 각각 다른 코드가 포함된 **여러 버전**을 가질 수 있습니다.  
그런 다음, Lambda의 서로 다른 버전마다 **서로 다른 aliases를 생성**하고 각 alias에 서로 다른 가중치를 설정할 수 있습니다.  
이렇게 하면 공격자는 **백도어가 심어진 버전 1**과 **정상 코드만 있는 버전 2**를 만들고, 은밀하게 유지하기 위해 요청의 **1%에서만 버전 1을 실행**하도록 설정할 수 있습니다.

<figure><img src="../../../../images/image (120).png" alt=""><figcaption></figcaption></figure>

### Version Backdoor + API Gateway

1. Lambda의 원본 코드를 복사합니다.
2. **원본 코드에 백도어를 심은 새 버전(또는 악성 코드만 포함된 버전)**을 생성합니다. 퍼블리시하고 그 **버전을 $LATEST에 배포**합니다.
1. Lambda와 연결된 API Gateway를 호출해 코드를 실행합니다.
3. **원본 코드로 새 버전을 생성**, 퍼블리시하고 그 **버전을 $LATEST에 배포**합니다.
1. 이렇게 하면 백도어가 심긴 코드는 이전 버전에 숨겨집니다.
4. API Gateway로 가서 백도어된 버전의 Lambda를 호출할 **새 POST 메서드 생성**(또는 다른 메서드 선택): `arn:aws:lambda:us-east-1:<acc_id>:function:<func_name>:1`
1. ARN의 마지막 :1은 **함수의 버전을 나타냅니다**(이 시나리오에서 버전 1이 백도어가 심긴 버전입니다).
5. 생성한 POST 메서드를 선택하고 Actions에서 **`Deploy API`**를 선택합니다.
6. 이제 POST로 함수를 호출하면 **백도어가 실행**됩니다.

### Cron/Event 작동기

무언가 발생했을 때 또는 일정 시간이 지났을 때 **Lambda 함수를 실행할 수 있다는 사실**은 Lambda가 지속성을 확보하고 탐지를 회피하기 위한 흔하고 편리한 수단이 되게 합니다.  
다음은 Lambda를 생성해 AWS 내에서의 **존재를 보다 은밀하게 유지**할 수 있는 몇 가지 아이디어입니다.

- 새로운 사용자가 생성될 때마다 Lambda가 새로운 사용자 키를 생성해서 공격자에게 전송합니다.
- 새로운 역할이 생성될 때마다 Lambda가 손상된 사용자들에게 assume role 권한을 부여합니다.
- 새로운 CloudTrail 로그가 생성될 때마다 해당 로그를 삭제/변경합니다

### RCE abusing AWS_LAMBDA_EXEC_WRAPPER + Lambda Layers

`AWS_LAMBDA_EXEC_WRAPPER` 환경 변수를 악용해 runtime/handler가 시작되기 전에 공격자가 제어하는 래퍼 스크립트를 실행합니다. 래퍼를 Lambda Layer로 `/opt/bin/htwrap`에 전달하고 `AWS_LAMBDA_EXEC_WRAPPER=/opt/bin/htwrap`로 설정한 뒤 함수를 호출합니다. 래퍼는 함수 런타임 프로세스 내에서 실행되고 함수 실행 역할을 상속하며, 마지막에 실제 런타임을 `exec`하여 원래 핸들러가 정상적으로 실행되도록 합니다.

{{#ref}}
aws-lambda-exec-wrapper-persistence.md
{{#endref}}

### AWS - Lambda Function URL 공개 노출

Lambda 비동기 destinations와 Recursion 구성을 함께 악용하여 외부 스케줄러(EventBridge, cron 등) 없이 함수가 스스로 지속적으로 재호출되도록 만들 수 있습니다. 기본적으로 Lambda는 재귀 루프를 종료하지만 recursion 구성을 Allow로 설정하면 이를 다시 활성화합니다. Destinations는 비동기 호출에 대해 서비스 측에서 전달되므로, 단 한 번의 시드 호출로 코드 없는 은밀한 하트비트/백도어 채널을 만들 수 있습니다. 선택적으로 reserved concurrency로 소음을 낮출 수 있습니다.

{{#ref}}
aws-lambda-async-self-loop-persistence.md
{{#endref}}

### AWS - Lambda Alias-Scoped Resource Policy Backdoor

공격자 로직을 담은 숨겨진 Lambda 버전을 생성하고 `lambda add-permission`의 `--qualifier` 파라미터를 사용해 리소스 기반 정책을 그 특정 버전(또는 alias)에 범위 지정합니다. 공격자 주체에게는 `arn:aws:lambda:REGION:ACCT:function:FN:VERSION`에 대해 `lambda:InvokeFunction`만 부여합니다. 함수 이름이나 기본 alias를 통한 정상 호출은 영향을 받지 않는 반면, 공격자는 백도어가 심긴 버전의 ARN을 직접 호출할 수 있습니다.

이는 Function URL을 노출하는 것보다 더 은밀하며 기본 트래픽 alias를 변경하지도 않습니다.

{{#ref}}
aws-lambda-alias-version-policy-backdoor.md
{{#endref}}

### AWS Lambda 런타임 고정

`lambda:InvokeFunction`, `logs:FilterLogEvents`, `lambda:PutRuntimeManagementConfig`, `lambda:GetRuntimeManagementConfig` 권한을 가진 공격자는 함수의 런타임 관리 구성을 수정할 수 있습니다. 이 공격은 Lambda 함수를 취약한 런타임 버전에 고정해 두거나 최신 런타임과 호환되지 않을 수 있는 악성 layer와의 호환성을 유지하려는 경우에 특히 효과적입니다.

공격자는 런타임 관리 구성을 수정해 런타임 버전을 고정합니다:
```bash
# Invoke the function to generate runtime logs
aws lambda invoke \
--function-name $TARGET_FN \
--payload '{}' \
--region us-east-1 /tmp/ping.json

sleep 5

# Freeze automatic runtime updates on function update
aws lambda put-runtime-management-config \
--function-name $TARGET_FN \
--update-runtime-on FunctionUpdate \
--region us-east-1
```
적용된 구성 확인:
```bash
aws lambda get-runtime-management-config \
--function-name $TARGET_FN \
--region us-east-1
```
선택 사항: 특정 런타임 버전으로 고정
```bash
# Extract Runtime Version ARN from INIT_START logs
RUNTIME_ARN=$(aws logs filter-log-events \
--log-group-name /aws/lambda/$TARGET_FN \
--filter-pattern "INIT_START" \
--query 'events[0].message' \
--output text | grep -o 'Runtime Version ARN: [^,]*' | cut -d' ' -f4)
```
특정 런타임 버전으로 고정:
```bash
aws lambda put-runtime-management-config \
--function-name $TARGET_FN \
--update-runtime-on Manual \
--runtime-version-arn $RUNTIME_ARN \
--region us-east-1
```
{{#include ../../../../banners/hacktricks-training.md}}
