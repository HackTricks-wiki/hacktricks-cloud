# AWS - Lambda Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Lambda

更多信息请参见：

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### Lambda Layer Persistence

可以在 Lambda 执行时以隐蔽方式 **引入/backdoor 一个 layer 来执行任意代码**：

{{#ref}}
aws-lambda-layers-persistence.md
{{#endref}}

### Lambda Extension Persistence

滥用 Lambda Layers 还可以滥用 extensions，实现 Lambda 内的持久化，并窃取或修改请求。

{{#ref}}
aws-abusing-lambda-extensions.md
{{#endref}}

### Via resource policies

可以将对不同 Lambda 操作（例如 invoke 或 update code）的访问权限授予外部账号：

<figure><img src="../../../../images/image (255).png" alt=""><figcaption></figcaption></figure>

### 版本、别名与权重

A Lambda can have **different versions** (with different code each version).\
然后，你可以创建 **不同别名对应不同版本** 的 Lambda，并为每个别名设置不同的权重。\
这样攻击者可以创建一个 **backdoored version 1** 和一个 **只包含合法代码的 version 2**，并仅在 1% 的请求中执行 version 1 以保持隐蔽。

<figure><img src="../../../../images/image (120).png" alt=""><figcaption></figcaption></figure>

### Version Backdoor + API Gateway

1. 复制 Lambda 的原始代码
2. **Create a new version backdooring** the original code (or just with malicious code). Publish and **deploy that version** to $LATEST
1. 调用与该 Lambda 关联的 API Gateway 来执行代码
3. **Create a new version with the original code**, Publish and deploy that **version** to $LATEST.
1. 这会将 backdoored 的代码隐藏在之前的版本中
4. 转到 API Gateway 并 **create a new POST method**（或选择其他方法），用于执行该 backdoored 的 Lambda 版本：`arn:aws:lambda:us-east-1:<acc_id>:function:<func_name>:1`
1. 注意 arn 最后的 :1 **indicating the version of the function**（在此情形中 version 1 将是 backdoored 的版本）。
5. 选择已创建的 POST 方法，在 Actions 中选择 **`Deploy API`**
6. 现在，当你通过 POST 调用该函数时，**你的 Backdoor** 将被触发

### Cron/Event actuator

你可以让 **lambda functions 在事件发生或经过一段时间时运行**，这使得 Lambda 成为获得持久化并规避检测的常见手段。\
以下是一些通过创建 lambdas 让你在 AWS 中更隐蔽存在的想法。

- 每当创建新用户时，lambda 生成一个新的用户密钥并将其发送给 attacker。
- 每当创建新角色时，lambda 会为被攻陷的用户授予 assume role 权限。
- 每当产生新的 cloudtrail 日志时，删除/篡改它们

### RCE abusing AWS_LAMBDA_EXEC_WRAPPER + Lambda Layers

利用环境变量 `AWS_LAMBDA_EXEC_WRAPPER` 来在 runtime/handler 启动前执行攻击者控制的 wrapper 脚本。通过 Lambda Layer 将 wrapper 放到 `/opt/bin/htwrap`，设置 `AWS_LAMBDA_EXEC_WRAPPER=/opt/bin/htwrap`，然后调用函数。该 wrapper 在函数运行时进程内执行，继承函数执行角色，最终 `exec` 真正的 runtime，从而使原始 handler 仍然正常执行。

{{#ref}}
aws-lambda-exec-wrapper-persistence.md
{{#endref}}

### AWS - Lambda Function URL Public Exposure

滥用 Lambda 的 asynchronous destinations 与 Recursion 配置，可以让函数持续自我重入而无需外部调度器（无需 EventBridge、cron 等）。默认情况下，Lambda 会终止递归循环，但将 recursion 配置设置为 Allow 会重新启用它们。Destinations 在服务端为异步调用负责投递，因此一次种子调用即可创建一个隐蔽、无需上传代码的 心跳/backdoor 通道。可选择使用 reserved concurrency 限流以降低噪声。

{{#ref}}
aws-lambda-async-self-loop-persistence.md
{{#endref}}

### AWS - Lambda Alias-Scoped Resource Policy Backdoor

创建一个包含攻击者逻辑的隐藏 Lambda 版本，并使用 `lambda add-permission` 的 `--qualifier` 参数将基于资源的策略作用于该特定版本（或别名）。仅向攻击者主体授予对 `arn:aws:lambda:REGION:ACCT:function:FN:VERSION` 的 `lambda:InvokeFunction` 权限。通过函数名或主别名的正常调用不会受影响，而攻击者可以直接调用该带后门的版本 ARN。

这比暴露 Function URL 更隐蔽，且不会更改主流量别名。

{{#ref}}
aws-lambda-alias-version-policy-backdoor.md
{{#endref}}


{{#include ../../../../banners/hacktricks-training.md}}
