# AWS - Lambda Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Lambda

For more information check:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### Lambda Layer Persistence

It's possible to **在 Layer 中引入/植入后门以执行任意代码** when the lambda is executed in a stealthy way:

{{#ref}}
aws-lambda-layers-persistence.md
{{#endref}}

### Lambda Extension Persistence

Abusing Lambda Layers it's also possible to abuse extensions and persist in the lambda but also steal and modify requests.

{{#ref}}
aws-abusing-lambda-extensions.md
{{#endref}}

### Via resource policies

可以向外部账号授予对不同 lambda 操作（例如 invoke 或 update code）的访问权限：

<figure><img src="../../../../images/image (255).png" alt=""><figcaption></figcaption></figure>

### Versions, Aliases & Weights

A Lambda can have **different versions** (with different code each version).\
Then, you can create **different aliases with different versions** of the lambda and set different weights to each.\
This way an attacker could create a **后门版本 1** and a **版本 2 仅含合法代码** 并且 **仅在 1% 的请求中执行版本 1** 来保持隐蔽。

<figure><img src="../../../../images/image (120).png" alt=""><figcaption></figcaption></figure>

### Version Backdoor + API Gateway

1. 复制 Lambda 的原始代码
2. **创建一个新版本并植入后门**（或仅包含恶意代码）。发布并 **将该版本部署到 $LATEST**
1. 调用与该 Lambda 关联的 API Gateway 以执行代码
3. **使用原始代码创建一个新版本**，发布并将该**版本**部署到 $LATEST。
1. 这会把带后门的代码隐藏在先前的版本中
4. 进入 API Gateway 并 **创建一个新的 POST 方法**（或选择其他方法），用于执行带后门的 Lambda 版本： `arn:aws:lambda:us-east-1:<acc_id>:function:<func_name>:1`
1. 注意 arn 末尾的 :1 **表示函数的版本**（在此场景中版本 1 将是被植入后门的版本）。
5. 选择刚创建的 POST 方法，在 Actions 中选择 **`Deploy API`**
6. 现在，当你通过 POST 调用该函数时，**后门** 将被触发

### Cron/Event actuator

你可以让 **Lambda 函数在某些事件发生或经过一段时间后运行**，这使得 Lambda 成为实现持久化并规避检测的常见手段。\
下面是一些利用 Lambda 让你在 AWS 中更加隐蔽地保持存在的思路。

- 每当创建新用户时，Lambda 生成新用户密钥并将其发送给攻击者。
- 每当创建新角色时，Lambda 授予被攻陷的用户 assume role 权限。
- 每当生成新的 CloudTrail 日志时，删除/篡改它们

### RCE abusing AWS_LAMBDA_EXEC_WRAPPER + Lambda Layers

滥用环境变量 `AWS_LAMBDA_EXEC_WRAPPER`，在 runtime/handler 启动前执行由攻击者控制的包装脚本。通过 Lambda Layer 将包装脚本放在 `/opt/bin/htwrap`，设置 `AWS_LAMBDA_EXEC_WRAPPER=/opt/bin/htwrap`，然后调用函数。该包装脚本在函数运行时进程内运行，继承函数执行角色，并最终通过 `exec` 启动真实的 runtime，因此原始 handler 仍然正常执行。

{{#ref}}
aws-lambda-exec-wrapper-persistence.md
{{#endref}}

### AWS - Lambda Function URL Public Exposure

滥用 Lambda 的异步 destinations 并结合 Recursion 配置，可以让函数在没有外部调度器（如 EventBridge、cron 等）的情况下持续地自我重入。默认情况下，Lambda 会终止递归循环，但将 recursion 配置设置为 Allow 可以重新启用它们。destinations 在服务端处理异步调用的投递，所以一次种子调用就能创建一个隐蔽的、无需代码的心跳/后门通道。可选地使用 reserved concurrency 节流以降低噪音。

{{#ref}}
aws-lambda-async-self-loop-persistence.md
{{#endref}}

### AWS - Lambda Alias-Scoped Resource Policy Backdoor

创建一个带有攻击者逻辑的隐藏 Lambda 版本，并在 `lambda add-permission` 中使用 `--qualifier` 参数将基于资源的策略限定到该特定版本（或别名）。仅授予攻击者主体对 `arn:aws:lambda:REGION:ACCT:function:FN:VERSION` 的 `lambda:InvokeFunction` 权限。通过函数名或主别名的正常调用不受影响，而攻击者可以直接调用被植入后门的版本 ARN。

这比暴露 Function URL 更隐蔽，并且不会改变主流量别名。

{{#ref}}
aws-lambda-alias-version-policy-backdoor.md
{{#endref}}

### Freezing AWS Lambda Runtimes

拥有 lambda:InvokeFunction、logs:FilterLogEvents、lambda:PutRuntimeManagementConfig 和 lambda:GetRuntimeManagementConfig 权限的攻击者可以修改函数的 runtime management 配置。当目标是将 Lambda 函数锁定在一个易受攻击的 runtime 版本，或保持与可能与较新 runtime 不兼容的恶意 layer 的兼容性时，此攻击尤其有效。

攻击者会修改 runtime management 配置以固定 runtime 版本：
```bash
# Invoke the function to generate runtime logs
aws lambda invoke \
--function-name $TARGET_FN \
--payload '{}' \
--region us-east-1 /tmp/ping.json

sleep 5

# Freeze automatic runtime updates on function update
aws lambda put-runtime-management-config \
--function-name $TARGET_FN \
--update-runtime-on FunctionUpdate \
--region us-east-1
```
验证已应用的配置:
```bash
aws lambda get-runtime-management-config \
--function-name $TARGET_FN \
--region us-east-1
```
可选：将运行时版本固定到特定版本
```bash
# Extract Runtime Version ARN from INIT_START logs
RUNTIME_ARN=$(aws logs filter-log-events \
--log-group-name /aws/lambda/$TARGET_FN \
--filter-pattern "INIT_START" \
--query 'events[0].message' \
--output text | grep -o 'Runtime Version ARN: [^,]*' | cut -d' ' -f4)
```
将 runtime 固定为特定版本：
```bash
aws lambda put-runtime-management-config \
--function-name $TARGET_FN \
--update-runtime-on Manual \
--runtime-version-arn $RUNTIME_ARN \
--region us-east-1
```
{{#include ../../../../banners/hacktricks-training.md}}
