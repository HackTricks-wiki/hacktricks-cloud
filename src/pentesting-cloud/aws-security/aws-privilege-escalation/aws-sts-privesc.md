# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

每个 role 都会创建一个 **role trust policy**，该策略指明 **谁可以 assume 所创建的 role**。如果一个来自 **same account** 的 role 指定某个 account 可以 assume 它，意味着该 account 将能够访问该 role（并可能进行 **privesc**）。

例如，下面的 role trust policy 表明任何人都可以 assume 它，因此 **any user will be able to privesc** 到与该 role 关联的权限。
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
您可以模拟正在运行的角色：
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Potential Impact:** Privesc 到该角色。

> [!CAUTION]
> 注意在这种情况下，权限 `sts:AssumeRole` 需要在**要滥用的角色中被指明**，而不是在属于攻击者的策略中。\
> 除非有一个例外，为了**假设来自不同账户的角色**，攻击者账户**还需要**对该角色拥有 **`sts:AssumeRole`** 权限。


### `sts:AssumeRoleWithSAML`

具有此角色的信任策略会授予**通过 SAML 验证的用户冒充该角色的访问权限。**

具有此权限的信任策略示例如下：
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
要生成用于模拟该角色的凭证，通常可以使用类似如下的命令：
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
但 **提供商** 可能有他们 **自己的工具** 来使这更容易，比如 [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**潜在影响：** Privesc 到该 role。

### `sts:AssumeRoleWithWebIdentity`

此权限允许通过 web identity provider 为在 **移动设备、web 应用、EKS... 中已完成认证的用户** 获取一组临时安全凭证。 [Learn more here.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

例如，如果一个 **EKS service account** 应该能够 **impersonate an IAM role**，它会在 **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** 中有一个令牌，并且可以通过类似如下的方式 **assume the role and get credentials**：
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### 联合身份滥用

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere 允许位于 AWS 之外的工作负载使用 X.509 证书来 assume IAM roles。但当 trust policies 未被正确限定时，它们可能被滥用以实现 privilege escalation。

该 policy 缺乏对允许的 trust anchor 或 certificate attributes 的限制。因此，任何绑定到账户中任意 trust anchor 的证书都可以用来 assume this role。
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
要进行 privesc，需要从 https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html 获取 `aws_signing_helper`

然后，使用有效的证书，attacker 可以 pivot 到更高权限的角色。
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
信任锚验证客户端证书 `readonly.pem` 是否来自其授权的 CA，在创建信任锚时包含了该 CA 的公钥证书（现在用于验证 `readonly.pem`）。`readonly.pem` 内包含公钥，AWS 使用它来验证签名是否由对应的私钥 `readonly.key` 所生成。

该证书还证明了身份，并提供属性（例如 CN 或 OU），`default` 配置文件将这些属性转换为标签（tags），角色的信任策略可以使用这些标签来决定是否授权访问；如果信任策略中没有条件，则这些标签会被忽略，任何拥有有效证书的人都将被允许通过。

要使此攻击成为可能，信任锚和 `default` 配置文件都必须处于启用状态。

### 参考资料

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
