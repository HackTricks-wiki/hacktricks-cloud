# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

모든 역할은 **역할 신뢰 정책**과 함께 생성됩니다. 이 정책은 **누가 생성된 역할을 assume할 수 있는지**를 나타냅니다. 같은 계정(**same account**)의 역할이 특정 계정이 자신을 assume할 수 있도록 허용하면, 그 계정은 해당 역할에 접근할 수 있게 되고(잠재적으로 **privesc**) 합니다.

예를 들어, 다음 역할 신뢰 정책은 누구나 해당 역할을 assume할 수 있음을 나타내며, 따라서 **어떤 사용자든 해당 역할에 연결된 권한으로 privesc할 수 있다**.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
다음 명령을 실행하는 역할을 가장할 수 있습니다:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Potential Impact:** 역할에 대한 Privesc.

> [!CAUTION]
> 이 경우 권한 `sts:AssumeRole` 는 **남용하려는 역할에 표시되어 있어야** 하며 공격자에게 속한 정책에 있어서는 안 된다는 점에 유의하라.\
> 예외가 하나 있는데, **다른 계정의 역할을 assume하려면** 공격자 계정도 해당 역할에 대해 **`sts:AssumeRole`** 권한을 **보유해야** 한다.


### `sts:AssumeRoleWithSAML`

이 역할을 가진 신뢰 정책은 **SAML로 인증된 사용자에게 해당 역할을 가장할 수 있는 액세스 권한을 부여한다.**

이 권한을 가진 신뢰 정책의 예는:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
일반적으로 역할을 사칭하기 위한 자격 증명을 생성하려면 다음과 같은 것을 사용할 수 있습니다:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
하지만 **공급자들은** 이를 더 쉽게 하기 위해 **자체 도구**를 제공할 수 있습니다. 예: [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Potential Impact:** 역할에 대한 Privesc.

### `sts:AssumeRoleWithWebIdentity`

이 권한은 웹 아이덴티티 공급자와 함께 모바일, 웹 애플리케이션, EKS... 등에서 인증된 **사용자들**이 임시 보안 자격증명 세트를 얻을 수 있도록 허용합니다. [자세히 보기.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

예를 들어, **EKS service account**가 **IAM role을 impersonate**할 수 있어야 한다면, **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`**에 토큰이 존재하고 다음과 같이 **역할을 assume하고 자격증명을 얻을 수 있습니다**:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere는 AWS 외부의 워크로드가 X.509 certificates를 사용해 IAM roles를 assume할 수 있도록 합니다. 그러나 trust policies가 적절히 범위 지정되지 않으면 privilege escalation에 악용될 수 있습니다.

이 공격을 이해하려면 trust anchor가 무엇인지 설명해야 합니다. AWS IAM Roles Anywhere의 trust anchor는 신뢰의 루트 엔터티로, 계정에 등록된 Certificate Authority (CA)의 공개 인증서를 포함하여 AWS가 제시된 X.509 certificates를 검증할 수 있도록 합니다. 따라서 client certificate가 해당 CA에서 발급되었고 trust anchor가 활성화되어 있으면 AWS는 이를 유효한 것으로 인식합니다.

또한 profile은 X.509 certificate의 어떤 속성(CN, OU, or SAN 등)이 session tags로 변환될지를 정의하는 구성이며, 이 태그들은 이후 trust policy의 조건과 비교됩니다.

이 정책은 어떤 trust anchor나 certificate attributes가 허용되는지에 대한 제한이 없습니다. 결과적으로 계정 내의 어떤 trust anchor에 묶여 있는 어떤 certificate라도 이 role을 assume하는 데 사용할 수 있습니다.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
privesc하려면 `aws_signing_helper`는 https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html 에서 필요합니다.

그런 다음 유효한 인증서를 사용하면 attacker가 더 높은 권한의 역할로 피벗할 수 있습니다.
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
trust anchor는 클라이언트의 `readonly.pem` 인증서가 권한 있는 CA에서 발급되었는지 검증하며, 이 `readonly.pem` 인증서 안에는 AWS가 서명이 대응하는 개인키 `readonly.key`로 만들어졌는지를 검증하는 데 사용하는 공개키가 포함되어 있다.

인증서는 CN 또는 OU와 같은 속성도 제공하는데, `default` 프로파일이 이를 태그로 변환하며 역할의 trust policy는 이 태그들로 접근 허가 여부를 결정할 수 있다. trust policy에 조건이 없다면, 그 태그들은 아무 쓸모가 없고 유효한 인증서를 가진 누구에게나 접근이 허용된다.

이 공격이 가능하려면 trust anchor와 `default` 프로파일 둘 다 활성 상태여야 한다.

### 참고자료

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
