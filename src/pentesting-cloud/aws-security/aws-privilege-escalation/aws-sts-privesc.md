# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Jede Rolle wird mit einer **Rollen-Trust-Policy** erstellt; diese Richtlinie gibt an, **wer die erstellte Rolle übernehmen kann**. Wenn eine Rolle aus demselben **Account** angibt, dass ein Account sie übernehmen kann, bedeutet das, dass dieser Account auf die Rolle zugreifen kann (und potenziell **privesc**).

Zum Beispiel zeigt die folgende Rollen-Trust-Policy, dass jeder sie übernehmen kann; daher **kann jeder Benutzer privesc** auf die mit dieser Rolle verbundenen Berechtigungen.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Sie können eine Rolle übernehmen, indem Sie Folgendes ausführen:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Mögliche Auswirkung:** Privesc auf die Rolle.

> [!CAUTION]
> Beachte, dass in diesem Fall die Berechtigung `sts:AssumeRole` **in der Rolle, die missbraucht werden soll, angegeben sein muss** und nicht in einer Policy, die dem Angreifer gehört.\
> Mit einer Ausnahme: um **eine Rolle aus einem anderen Account anzunehmen** benötigt das Angreiferkonto **ebenfalls** die **`sts:AssumeRole`** für diese Rolle.


### `sts:AssumeRoleWithSAML`

Eine Trust-Policy mit dieser Rolle gewährt **Benutzern, die via SAML authentifiziert sind, Zugriff, sich als diese Rolle auszugeben.**

Ein Beispiel für eine Trust-Policy mit dieser Berechtigung ist:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Um credentials zu generieren, um eine role zu impersonate, könntest du im Allgemeinen so etwas verwenden:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Aber **Anbieter** könnten ihre **eigenen Tools** haben, um dies zu erleichtern, wie [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Mögliche Auswirkung:** Privesc auf die Rolle.

### `sts:AssumeRoleWithWebIdentity`

Diese Berechtigung erlaubt es, ein Set temporärer Sicherheitsanmeldeinformationen für **Benutzer, die in einer mobilen App, einer Webanwendung, EKS ... authentifiziert wurden** mit einem Web-Identity-Provider zu erhalten. [Learn more here.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Zum Beispiel, wenn ein **EKS service account** in der Lage sein sollte, sich als **IAM role** auszugeben, hat er ein Token in **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** und kann die **Rolle übernehmen und Anmeldeinformationen erhalten**, indem er etwa Folgendes ausführt:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere ermöglicht Workloads außerhalb von AWS, IAM roles mit X.509 certificates zu übernehmen. Wenn trust policies jedoch nicht richtig eingeschränkt sind, können sie für privilege escalation missbraucht werden.

Diese Policy enthält keine Beschränkungen, welche trust anchor oder certificate attributes erlaubt sind. Infolgedessen kann jedes Zertifikat, das an einen beliebigen trust anchor im Account gebunden ist, verwendet werden, um diese Rolle zu assume.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Um privesc zu erreichen, wird der `aws_signing_helper` von https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html benötigt.

Anschließend kann der Angreifer mit einem gültigen Zertifikat in die höher privilegierte Rolle pivot.
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
Der trust anchor validiert, dass das Client-Zertifikat `readonly.pem` von seiner autorisierten CA stammt. Als der trust anchor erstellt wurde, wurde das öffentliche Zertifikat der CA eingeschlossen (und wird jetzt zur Validierung von `readonly.pem` verwendet). Im Inneren von `readonly.pem` befindet sich der öffentliche Schlüssel, den AWS verwendet, um zu überprüfen, dass die Signatur mit dem korrespondierenden privaten Schlüssel `readonly.key` erzeugt wurde.

Das Zertifikat beweist außerdem die Identität und liefert Attribute (wie CN oder OU), die das `default`-Profil in Tags umwandelt. Die Trust-Policy der Rolle kann diese Tags verwenden, um zu entscheiden, ob Zugriff autorisiert wird. Gibt es keine Bedingungen in der Trust-Policy, werden diese Tags ignoriert und jeder mit einem gültigen Zertifikat erhält Zugang.

Damit dieser Angriff möglich ist, müssen sowohl der trust anchor als auch das `default`-Profil aktiv sein.

### References

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
