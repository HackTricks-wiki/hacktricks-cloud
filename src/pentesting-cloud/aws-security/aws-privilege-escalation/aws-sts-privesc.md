# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Ogni ruolo viene creato con una **role trust policy**, questa policy indica **chi può assumere il ruolo creato**. Se un ruolo dello **stesso account** dichiara che un account può assumerlo, significa che l'account sarà in grado di accedere al ruolo (e potenzialmente **privesc**).

Per esempio, la seguente role trust policy indica che chiunque può assumerla, quindi **qualsiasi utente sarà in grado di privesc** alle autorizzazioni associate a quel ruolo.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Puoi impersonare un ruolo eseguendo:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Impatto potenziale:** Privesc al ruolo.

> [!CAUTION]
> Nota che in questo caso il permesso `sts:AssumeRole` deve essere **indicato nel ruolo da abusare** e non in una policy appartenente all'attaccante.\
> Con un'eccezione, per **assumere un ruolo da un account diverso** l'account dell'attaccante **deve anche** avere la **`sts:AssumeRole`** sul ruolo.


### `sts:AssumeRoleWithSAML`

Una trust policy con questo ruolo concede **agli utenti autenticati via SAML l'accesso per impersonare il ruolo.**

Un esempio di trust policy con questo permesso è:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Per generare credenziali per impersonare il ruolo, in generale potresti usare qualcosa del genere:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Ma **i fornitori** potrebbero avere i **propri strumenti** per rendere questo più semplice, come [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Impatto potenziale:** Privesc to the role.

### `sts:AssumeRoleWithWebIdentity`

Questa autorizzazione permette di ottenere un set di credenziali di sicurezza temporanee per **utenti che sono stati autenticati in un'app mobile, un'applicazione web, EKS...** tramite un provider di identità web. [Ulteriori informazioni qui.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Ad esempio, se un **account di servizio EKS** dovrebbe essere in grado di **impersonare un ruolo IAM**, avrà un token in **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** e può **assumere il ruolo e ottenere credenziali** facendo qualcosa del genere:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere permette a workload esterni ad AWS di assumere IAM roles tramite certificati X.509. Tuttavia, quando le trust policies non sono correttamente limitate, possono essere abusate per privilege escalation.

Questa policy non contiene restrizioni su quale trust anchor o quali attributi del certificato sono consentiti. Di conseguenza, qualsiasi certificato legato a qualsiasi trust anchor nell'account può essere utilizzato per assumere questo ruolo.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Per privesc è richiesto `aws_signing_helper` da https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Quindi, usando un certificato valido, l'attaccante può pivotare in un ruolo con privilegi più elevati
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
La trust anchor valida che il certificato client `readonly.pem` provenga dalla sua CA autorizzata; quando la trust anchor è stata creata è stato incluso il certificato pubblico della CA (ora usato per validare `readonly.pem`).

All'interno di `readonly.pem` c'è la chiave pubblica, che AWS usa per verificare che la firma sia stata generata con la corrispondente chiave privata `readonly.key`.

Il certificato dimostra anche l'identità e fornisce attributi (come CN o OU) che il profilo `default` trasforma in tag; la trust policy del ruolo può usare questi tag per decidere se autorizzare l'accesso. Se non ci sono condizioni nella trust policy, quei tag vengono ignorati e chiunque possieda un certificato valido è autorizzato.

Perché questo attacco sia possibile, sia la trust anchor sia il profilo `default` devono essere attivi.

### Riferimenti

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
