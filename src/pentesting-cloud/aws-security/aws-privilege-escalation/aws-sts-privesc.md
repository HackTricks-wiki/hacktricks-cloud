# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Cada função é criada com uma **política de confiança da função**, essa política indica **quem pode assumir a função criada**. Se uma função da **mesma conta** declara que uma conta pode assumi-la, isso significa que a conta poderá acessar a função (e potencialmente **privesc**).

Por exemplo, a seguinte política de confiança da função indica que qualquer um pode assumi-la, portanto **qualquer usuário poderá privesc** às permissões associadas a essa função.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Você pode assumir uma role executando:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Impacto Potencial:** Privesc para a role.

> [!CAUTION]
> Note that in this case the permission `sts:AssumeRole` needs to be **indicated in the role to abuse** and not in a policy belonging to the attacker.\
> With one exception, in order to **assume a role from a different account** the attacker account **also needs** to have the **`sts:AssumeRole`** over the role.


### `sts:AssumeRoleWithSAML`

Uma trust policy com essa role concede **a usuários autenticados via SAML o acesso para assumir a role.**

Um exemplo de uma trust policy com essa permissão é:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Para gerar credenciais para se passar pelo role, em geral você pode usar algo como:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Mas **provedores** podem ter suas **próprias ferramentas** para tornar isso mais fácil, como [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Impacto Potencial:** Privesc para a role.

### `sts:AssumeRoleWithWebIdentity`

Essa permissão permite obter um conjunto de credenciais de segurança temporárias para **usuários que foram autenticados em um aplicativo móvel, web, EKS...** com um provedor de identidade web. [Saiba mais aqui.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Por exemplo, se uma **EKS service account** deveria poder **impersonar um IAM role**, ela terá um token em **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** e pode **assumir o role e obter credenciais** fazendo algo como:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

O AWS IAM Roles Anywhere permite que workloads fora da AWS assumam IAM roles usando certificados X.509. Mas quando as trust policies não estão devidamente limitadas, elas podem ser abusadas para escalonamento de privilégios.

Para entender este ataque, é necessário explicar o que é um trust anchor. Um trust anchor no AWS IAM Roles Anywhere é a entidade raiz de confiança; ele contém o certificado público de uma Certificate Authority (CA) registrada na conta para que a AWS possa validar os certificados X.509 apresentados. Dessa forma, se o certificado do cliente foi emitido por essa CA e o trust anchor estiver ativo, a AWS o reconhece como válido.

Além disso, um profile é a configuração que define quais atributos do certificado X.509 (como CN, OU ou SAN) serão transformados em session tags, e essas tags serão comparadas posteriormente com as condições da trust policy.

Essa policy não possui restrições sobre quais trust anchor ou atributos do certificado são permitidos. Como resultado, qualquer certificado vinculado a qualquer trust anchor na conta pode ser usado para assumir esse role.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Para privesc, o `aws_signing_helper` é necessário a partir de https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Então, usando um certificado válido, o atacante pode pivotar para o role de maior privilégio.
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
A âncora de confiança valida que o certificado `readonly.pem` do cliente vem da sua CA autorizada, e dentro desse certificado `readonly.pem` está a chave pública que a AWS usa para verificar que a assinatura foi feita com a sua chave privada correspondente `readonly.key`.

O certificado também fornece atributos (como CN ou OU) que o perfil `default` transforma em tags, que a política de confiança da role pode usar para decidir se autoriza o acesso. Se não houver condições na política de confiança, essas tags não têm utilidade, e o acesso é concedido a qualquer pessoa com um certificado válido.

Para que este ataque seja possível, tanto a âncora de confiança quanto o perfil `default` devem estar ativos.

### Referências

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
