# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Chaque rôle est créé avec une **politique de confiance du rôle**, cette politique indique **qui peut assumer le rôle créé**. Si un rôle du **même compte** indique qu'un compte peut l'assumer, cela signifie que le compte pourra accéder au rôle (et potentiellement effectuer un **privesc**).

Par exemple, la politique de confiance suivante indique que n'importe qui peut l'assumer, donc **tout utilisateur pourra effectuer un privesc** sur les permissions associées à ce rôle.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Vous pouvez usurper un rôle en exécutant :
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Impact potentiel :** Privesc vers le rôle.

> [!CAUTION]
> Notez que dans ce cas la permission `sts:AssumeRole` doit être **indiquée dans le rôle à abuser** et non dans une policy appartenant à l'attaquant.\
> À une exception près, pour **assumer un rôle depuis un compte différent** le compte attaquant **doit aussi** avoir la **`sts:AssumeRole`** sur le rôle.


### `sts:AssumeRoleWithSAML`

Une trust policy pour ce rôle permet **aux utilisateurs authentifiés via SAML de se faire passer pour le rôle.**

Un exemple de trust policy avec cette permission est:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Pour générer des credentials pour impersonate le role, vous pouvez généralement utiliser quelque chose comme :
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Mais les **fournisseurs** peuvent avoir leurs **propres outils** pour faciliter cela, comme [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Impact potentiel:** Privesc to the role.

### `sts:AssumeRoleWithWebIdentity`

Cette permission permet d'obtenir un ensemble d'identifiants temporaires de sécurité pour **les utilisateurs qui ont été authentifiés dans une application mobile, une application web, EKS...** via un fournisseur d'identité web. [Learn more here.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Par exemple, si un **EKS service account** doit pouvoir **impersonate an IAM role**, il aura un token dans **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** et pourra **assume the role and get credentials** en faisant quelque chose comme :
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere permet à des workloads externes à AWS d'assumer des rôles IAM en utilisant des certificats X.509. Mais lorsque les trust policies ne sont pas correctement restreintes, elles peuvent être abusées pour privilege escalation.

Cette policy n'impose pas de restrictions sur quel trust anchor ou quels attributs de certificat sont autorisés. En conséquence, tout certificat lié à n'importe quel trust anchor du compte peut être utilisé pour assumer ce rôle.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Pour privesc, l'`aws_signing_helper` est requis depuis https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Ensuite, en utilisant un certificat valide, l'attaquant peut pivoter vers un rôle à privilèges supérieurs
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
L'ancre de confiance valide que le certificat client `readonly.pem` provient de sa CA autorisée ; lorsque l'ancre de confiance a été créée, le certificat public de la CA a été inclus (et est maintenant utilisé pour valider `readonly.pem`). À l'intérieur de `readonly.pem` se trouve la clé publique, qu'AWS utilise pour vérifier que la signature a été réalisée avec sa clé privée correspondante `readonly.key`.

Le certificat prouve également l'identité et fournit des attributs (tels que CN ou OU) que le profil `default` transforme en tags, que la trust policy du rôle peut utiliser pour décider d'autoriser l'accès ; s'il n'y a pas de conditions dans la trust policy, ces tags sont ignorés et toute personne disposant d'un certificat valide est autorisée.

Pour que cette attaque soit possible, l'ancre de confiance et le profil `default` doivent tous deux être actifs.

### Références

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
