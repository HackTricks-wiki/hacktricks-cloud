# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Elke rol word geskep met 'n **rol se vertrouensbeleid**, hierdie beleid dui aan **wie die geskepte rol kan aanneem**. As 'n rol van die **dieselfde rekening** sê dat 'n rekening dit kan aanneem, beteken dit dat daardie rekening toegang tot die rol sal hê (en moontlik **privesc**).

Byvoorbeeld, die volgende rol se vertrouensbeleid dui aan dat enigiemand dit kan aanneem, daarom sal **enige gebruiker sal in staat wees om te privesc** tot die toestemmings wat aan daardie rol gekoppel is.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Jy kan 'n rol naboots wat loop:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Potensiële impak:** Privesc na die role.

> [!CAUTION]
> Let wel dat in hierdie geval die toestemming `sts:AssumeRole` **indicated in the role to abuse** moet wees en nie in 'n beleid wat aan die attacker behoort nie.\
> Met een uitsondering: om **assume a role from a different account** te kan doen, moet die attacker account **ook** die **`sts:AssumeRole`** oor die role hê.


### `sts:AssumeRoleWithSAML`

'n trust policy met hierdie role verleen **users authenticated via SAML access to impersonate the role.**

'n voorbeeld van 'n trust policy met hierdie toestemming is:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Om credentials te genereer om die rol te imiteer, kan jy gewoonlik iets soos die volgende gebruik:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Maar **verskaffers** mag hul **eie gereedskap** hê om dit makliker te maak, soos [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Potensiële impak:** Privesc to the role.

### `sts:AssumeRoleWithWebIdentity`

Hierdie toestemming laat toe om 'n stel tydelike sekuriteitsbewyse te kry vir **gebruikers wat geverifieer is in 'n mobiele of webtoepassing, EKS...** by 'n web-identity-verskaffer. [Lees meer hier.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Byvoorbeeld, as 'n **EKS service account** in staat moet wees om **impersonate an IAM role**, sal dit 'n token hê in **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** en kan dit **die role aanvaar en inlogbewyse kry** deur iets soos:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere allows workloads outside AWS to assume IAM roles using X.509 certificates. But when trust policies aren't properly scoped, they can be abused for privilege escalation.

Om hierdie aanval te verstaan, is dit nodig om te verduidelik wat 'n trust anchor is. 'n trust anchor in AWS IAM RolesAnywhere is die wortel-entiteit van vertroue; dit bevat die publieke sertifikaat van 'n Certificate Authority (CA) wat in die rekening geregistreer is sodat AWS die gepresenteerde X.509-sertifikate kan valideer. Op hierdie manier, as die kliëntsertifikaat deur daardie CA uitgereik is en die trust anchor aktief is, erken AWS dit as geldig.

Verder is 'n profile die konfigurasie wat bepaal watter kenmerke van die X.509-sertifikaat (soos CN, OU, or SAN) in session tags omskakel sal word, en hierdie tags sal later vergelyk word teen die voorwaardes van die trust policy.

Hierdie policy het nie beperkings op watter trust anchor of sertifikaatkenmerke toegelaat word nie. Gevolglik kan enige sertifikaat wat aan enige trust anchor in die rekening gekoppel is, gebruik word om hierdie rol aan te neem.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Vir privesc is die `aws_signing_helper` benodig vanaf https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Deur 'n geldige sertifikaat te gebruik, kan die attacker na 'n rol met hoër voorregte pivot.
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
Die trust anchor verifieer dat die kliënt se `readonly.pem`-sertifikaat van sy gemagtigde CA afkomstig is, en binne hierdie `readonly.pem`-sertifikaat is die publieke sleutel wat AWS gebruik om te verifieer dat die handtekening met die ooreenstemmende private sleutel `readonly.key` gemaak is.

Die sertifikaat verskaf ook attribuutte (soos CN of OU) wat die `default` profiel in tags omskakel, wat die rol se trust policy kan gebruik om te besluit of toegang gemagtig word. As daar geen toestande in die trust policy is nie, het daardie tags geen nut nie, en word toegang toegestaan aan enigiemand met 'n geldige sertifikaat.

Vir hierdie aanval om moontlik te wees, moet beide die trust anchor en die `default` profiel aktief wees.

### Verwysings

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
