# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Кожна роль створюється з **політикою довіри ролі**, ця політика вказує **хто може прийняти створену роль**. Якщо роль з **того самого акаунту** вказує, що акаунт може її приймати, це означає, що цей акаунт зможе отримати доступ до ролі (і потенційно **privesc**).

Наприклад, наступна політика довіри ролі вказує, що будь-хто може її прийняти, отже **будь-який користувач зможе здійснити privesc** до дозволів, пов'язаних з цією роллю.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Ви можете видаватися за роль, запустивши:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Потенційний вплив:** Privesc до ролі.

> [!CAUTION]
> Зауважте, що в цьому випадку дозвіл `sts:AssumeRole` має бути **вказаний у ролі, яку збираються зловживати**, а не в політиці, що належить зловмиснику.\
> За одним винятком, щоб **прийняти роль з іншого облікового запису** обліковий запис зловмисника **також повинен** мати **`sts:AssumeRole`** щодо цієї ролі.


### `sts:AssumeRoleWithSAML`

Політика довіри для цієї ролі надає **користувачам, автентифікованим через SAML, можливість діяти від імені ролі.**

Приклад політики довіри з цим дозволом:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Щоб згенерувати облікові дані для імітації ролі, можна використати щось на кшталт:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Але **провайдери** можуть мати **власні інструменти**, щоб полегшити це, наприклад [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Потенційний вплив:** Privesc to the role.

### `sts:AssumeRoleWithWebIdentity`

Цей дозвіл дає можливість отримати набір тимчасових облікових даних безпеки для **користувачів, які були автентифіковані у мобільному, веб-застосунку, EKS...** з використанням провайдера web identity. [Learn more here.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Наприклад, якщо **EKS service account** має мати можливість **impersonate an IAM role**, він матиме токен у **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** і може **assume the role and get credentials**, виконавши щось на кшталт:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere дозволяє робочим навантаженням поза AWS assume IAM roles за допомогою X.509 certificates. Але коли trust policies не належним чином обмежені, їх можна зловживати для privilege escalation.

Ця policy не містить обмежень щодо того, який trust anchor або які certificate attributes дозволені. В результаті будь-який certificate, пов'язаний з будь-яким trust anchor в акаунті, може бути використаний, щоб assume this role.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Щоб виконати privesc, `aws_signing_helper` потрібен з https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Потім, використовуючи дійсний сертифікат, зловмисник може pivot у role з вищими привілеями
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
Точка довіри перевіряє, що клієнтський сертифікат `readonly.pem` походить від його авторизованого CA; коли точку довіри створювали, був включений публічний сертифікат CA (який тепер використовується для валідації `readonly.pem`). Усередині `readonly.pem` міститься відкритий ключ, який AWS використовує для перевірки того, що підпис було зроблено відповідним приватним ключем `readonly.key`.

Сертифікат також підтверджує ідентичність і надає атрибути (наприклад CN або OU), які профіль `default` перетворює на теги — політика довіри ролі може використовувати ці теги, щоб вирішити, чи надавати доступ; якщо в політиці довіри немає умов, ці теги ігноруються і будь-хто з дійсним сертифікатом допускається.

Щоб ця атака була можливою, і точка довіри, і профіль `default` повинні бути активними.

### References

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
