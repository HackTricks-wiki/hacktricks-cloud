# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Elke role word geskep met 'n **role trust policy**, hierdie policy dui aan **wie die geskepte role kan assume**. As 'n role van die **same account** sê dat 'n account dit kan assume, beteken dit dat daardie account toegang tot die role sal hê (en moontlik **privesc**).

Byvoorbeeld dui die volgende **role trust policy** aan dat enigiemand dit kan assume, daarom sal **any user** in staat wees om te **privesc** na die permissions geassosieer met daardie role.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Jy kan 'n rol naboots deur die volgende uit te voer:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Potensiële impak:** Privesc na die rol.

> [!CAUTION]
> Neem kennis dat in hierdie geval die toestemming `sts:AssumeRole` **in die rol wat misbruik word aangedui moet wees** en nie in 'n beleid wat aan die aanvaller behoort nie.\
> Met een uitsondering, om **'n rol van 'n ander rekening aan te neem** moet die aanvallerrekening **ook** die **`sts:AssumeRole`** oor die rol hê.


### `sts:AssumeRoleWithSAML`

'n trust policy met hierdie rol verleen **gebruikers wat via SAML geverifieer is toegang om die rol te verpersoonlik.**

'n Voorbeeld van 'n trust policy met hierdie toestemming is:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Om credentials te genereer om die rol te impersonate, kan jy gewoonlik iets soos die volgende gebruik:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Maar **verskaffers** mag hul **eie gereedskap** hê om dit makliker te maak, soos [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Potensiële impak:** Privesc to the role.

### `sts:AssumeRoleWithWebIdentity`

Hierdie toestemming maak dit moontlik om 'n stel tydelike sekuriteitsgeloofsbriewe te bekom vir **gebruikers who have been authenticated in a mobile, web application, EKS...** met 'n web identity provider. [Lees meer hier.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Byvoorbeeld, as 'n **EKS service account** in staat moet wees om **impersonate an IAM role**, sal dit 'n token in **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** hê en kan dit **assume the role and get credentials** deur iets soos:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere laat workloads buite AWS toe om IAM roles aan te neem met X.509 certificates. Maar wanneer trust policies nie behoorlik afgebaken is nie, kan dit misbruik word vir privilege escalation.

Hierdie policy het geen beperkings op watter trust anchor of certificate attributes toegelaat word nie. As gevolg hiervan kan enige certificate wat aan enige trust anchor in die account gekoppel is, gebruik word om hierdie rol te assume.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Om privesc te bereik, is die `aws_signing_helper` benodig vanaf https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Dan, deur 'n geldige sertifikaat te gebruik, kan die attacker pivot in die rol met hoër voorregte
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
Die vertrouensanker valideer dat die kliëntsertifikaat `readonly.pem` van sy gemagtigde CA kom. Toe die vertrouensanker geskep is, is die CA se publieke sertifikaat ingesluit (en word nou gebruik om `readonly.pem` te valideer). Binne-in `readonly.pem` is die publieke sleutel, wat AWS gebruik om te verifieer dat die handtekening met die ooreenstemmende private sleutel `readonly.key` gemaak is.

Die sertifikaat bewys ook identiteit en verskaf attribuutte (soos CN of OU) wat die `default` profiel omskakel in etikette (tags), wat die rol se vertrouensbeleid kan gebruik om te besluit of toegang gemagtig moet word. As daar geen voorwaardes in die vertrouensbeleid is nie, word daardie etikette geïgnoreer en word enigiemand met 'n geldige sertifikaat toegelaat.

Vir hierdie aanval om moontlik te wees, moet beide die vertrouensanker en die `default` profiel aktief wees.

### Verwysings

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
