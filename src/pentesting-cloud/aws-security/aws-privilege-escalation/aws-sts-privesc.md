# AWS - STS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## STS

### `sts:AssumeRole`

Cada rol se crea con una **política de confianza del rol**, esta política indica **quién puede asumir el rol creado**. Si un rol de la **misma cuenta** indica que una cuenta puede asumirlo, significa que la cuenta podrá acceder al rol (y potencialmente **privesc**).

Por ejemplo, la siguiente política de confianza del rol indica que cualquiera puede asumirlo, por lo tanto **cualquier usuario podrá privesc** a los permisos asociados con ese rol.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": "sts:AssumeRole"
}
]
}
```
Puedes suplantar un rol ejecutando:
```bash
aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname
```
**Impacto potencial:** Privesc al rol.

> [!CAUTION]
> Ten en cuenta que en este caso el permiso `sts:AssumeRole` debe estar **indicado en el rol que se va a abusar** y no en una política perteneciente al atacante.\
> Con una excepción, para **asumir un rol desde otra cuenta** la cuenta atacante **también necesita** tener el **`sts:AssumeRole`** sobre el rol.


### `sts:AssumeRoleWithSAML`

Una política de confianza para este rol concede **a los usuarios autenticados vía SAML acceso para suplantar el rol.**

Un ejemplo de una política de confianza con este permiso es:
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "OneLogin",
"Effect": "Allow",
"Principal": {
"Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
},
"Action": "sts:AssumeRoleWithSAML",
"Condition": {
"StringEquals": {
"SAML:aud": "https://signin.aws.amazon.com/saml"
}
}
}
]
}
```
Para generar credenciales para suplantar el rol, en general podrías usar algo como:
```bash
aws sts  assume-role-with-saml --role-arn <value> --principal-arn <value>
```
Pero **proveedores** podrían tener sus **propias herramientas** para facilitar esto, como [onelogin-aws-assume-role](https://github.com/onelogin/onelogin-python-aws-assume-role):
```bash
onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600
```
**Impacto potencial:** Privesc al rol.

### `sts:AssumeRoleWithWebIdentity`

Este permiso permite obtener un conjunto de credenciales de seguridad temporales para **usuarios que han sido autenticados en una aplicación móvil, web, EKS...** con un proveedor de identidad web. [Learn more here.](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)

Por ejemplo, si una **cuenta de servicio de EKS** debería poder **suplantar a un rol de IAM**, tendrá un token en **`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`** y podrá **asumir el rol y obtener credenciales** haciendo algo como:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
# The role name can be found in the metadata of the configuration of the pod
```
### Federation Abuse

{{#ref}}
../aws-basic-information/aws-federation-abuse.md
{{#endref}}

### IAM Roles Anywhere Privesc

AWS IAM RolesAnywhere permite que cargas de trabajo fuera de AWS asuman roles de IAM usando certificados X.509. Pero cuando las políticas de confianza no están correctamente acotadas, pueden ser abusadas para escalada de privilegios.

Esta política no tiene restricciones sobre qué trust anchor o atributos del certificado están permitidos. Como resultado, cualquier certificado vinculado a cualquier trust anchor en la cuenta puede usarse para asumir este rol.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Service": "rolesanywhere.amazonaws.com"
},
"Action": [
"sts:AssumeRole",
"sts:SetSourceIdentity",
"sts:TagSession"
]
}
]
}

```
Para privesc, se requiere el `aws_signing_helper` desde https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html

Luego, usando un certificado válido, el atacante puede pivot hacia el role de mayor privilegio
```bash
aws_signing_helper credential-process \
--certificate readonly.pem \
--private-key readonly.key \
--trust-anchor-arn arn:aws:rolesanywhere:us-east-1:123456789012:trust-anchor/ta-id \
--profile-arn arn:aws:rolesanywhere:us-east-1:123456789012:profile/default \
--role-arn arn:aws:iam::123456789012:role/Admin
```
El trust anchor valida que el certificado de cliente `readonly.pem` proviene de su CA autorizada; cuando se creó el trust anchor se incluyó el certificado público de la CA (y ahora se usa para validar `readonly.pem`). Dentro de `readonly.pem` está la clave pública, que AWS usa para verificar que la firma fue hecha con su clave privada correspondiente `readonly.key`.

El certificado también prueba la identidad y proporciona atributos (como CN u OU) que el perfil `default` transforma en tags, los cuales la trust policy del role puede usar para decidir si autorizar el acceso. Si no hay condiciones en la trust policy, esas tags se ignoran y cualquiera con un certificado válido puede acceder.

Para que este ataque sea posible, tanto el trust anchor como el perfil `default` deben estar activos.

### References

- [https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation](https://www.ruse.tech/blogs/aws-roles-anywhere-privilege-escalation)

{{#include ../../../banners/hacktricks-training.md}}
