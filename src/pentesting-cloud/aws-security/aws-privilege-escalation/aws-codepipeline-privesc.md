# AWS - Codepipeline Privesc

{{#include ../../../banners/hacktricks-training.md}}

## codepipeline

Для отримання додаткової інформації про codepipeline перегляньте:

{{#ref}}
../aws-services/aws-datapipeline-codepipeline-codebuild-and-codecommit.md
{{#endref}}

### `iam:PassRole`, `codepipeline:CreatePipeline`, `codebuild:CreateProject, codepipeline:StartPipelineExecution`

При створенні code pipeline ви можете вказати **IAM роль codepipeline для виконання**, тому ви могли б їх скомпрометувати.

Окрім попередніх дозволів, вам знадобиться **доступ до місця, де зберігається код** (S3, ECR, github, bitbucket...)

Я протестував це, виконуючи процес на веб-сторінці, дозволи, зазначені раніше, не є List/Get, які потрібні для створення codepipeline, але для його створення в вебі вам також знадобляться: `codebuild:ListCuratedEnvironmentImages, codebuild:ListProjects, codebuild:ListRepositories, codecommit:ListRepositories, events:PutTargets, codepipeline:ListPipelines, events:PutRule, codepipeline:ListActionTypes, cloudtrail:<several>`

Під час **створення проекту збірки** ви можете вказати **команду для виконання** (rev shell?) і виконати фазу збірки як **привілейований користувач**, це конфігурація, яку атакуючий потребує для компрометації:

![](<../../../images/image (276).png>)

![](<../../../images/image (181).png>)

### ?`codebuild:UpdateProject, codepipeline:UpdatePipeline, codepipeline:StartPipelineExecution`

Можливо, можна змінити роль, що використовується, і команду, що виконується на codepipeline, з попередніми дозволами.

### `codepipeline:pollforjobs`

[AWS згадує](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_PollForJobs.html):

> Коли цей API викликається, CodePipeline **повертає тимчасові облікові дані для S3 бакету**, що використовується для зберігання артефактів для конвеєра, якщо дія вимагає доступу до цього S3 бакету для вхідних або вихідних артефактів. Цей API також **повертає будь-які секретні значення, визначені для дії**.

{{#include ../../../banners/hacktricks-training.md}}
