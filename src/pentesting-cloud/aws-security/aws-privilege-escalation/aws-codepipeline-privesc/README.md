# AWS - Codepipeline Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## codepipeline

For more info about codepipeline check:

{{#ref}}
../../aws-services/aws-datapipeline-codepipeline-codebuild-and-codecommit.md
{{#endref}}

### `iam:PassRole`, `codepipeline:CreatePipeline`, `codebuild:CreateProject, codepipeline:StartPipelineExecution`

При створенні code pipeline ви можете вказати **codepipeline IAM Role to run**, отже їх можна скомпрометувати.

Окрім попередніх дозволів вам потрібен також **доступ до місця, де зберігається код** (S3, ECR, github, bitbucket...)

Я перевіряв це, виконуючи процес у веб-інтерфейсі — дозволи, вказані раніше, це не ті List/Get дозволи, які потрібні для створення codepipeline, але для створення через веб вам також знадобляться: `codebuild:ListCuratedEnvironmentImages, codebuild:ListProjects, codebuild:ListRepositories, codecommit:ListRepositories, events:PutTargets, codepipeline:ListPipelines, events:PutRule, codepipeline:ListActionTypes, cloudtrail:<several>`

Під час **створення проєкту build** можна вказати **команду для виконання** (rev shell?) і виконувати фазу збірки як **привілейований користувач** — це та конфігурація, яку атакуючий має скомпрометувати:

![](<../../../images/image (276).png>)

![](<../../../images/image (181).png>)

### ?`codebuild:UpdateProject, codepipeline:UpdatePipeline, codepipeline:StartPipelineExecution`

Може бути можливо змінити роль, що використовується, та команду, яка виконується в codepipeline з попередніми дозволами.

### `codepipeline:pollforjobs`

[AWS mentions](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_PollForJobs.html):

> Коли цей API викликається, CodePipeline **повертає тимчасові облікові дані для S3 bucket**, що використовується для зберігання артефактів для pipeline, якщо дія вимагає доступу до цього S3 bucket для вхідних або вихідних артефактів. Цей API також **повертає будь-які секретні значення, визначені для дії**.

{{#include ../../../../banners/hacktricks-training.md}}
