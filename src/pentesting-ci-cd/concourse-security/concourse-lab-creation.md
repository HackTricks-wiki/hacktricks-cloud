# Création de laboratoire Concourse

{{#include ../../banners/hacktricks-training.md}}

## Environnement de test

### Exécution de Concourse

#### Avec Docker-Compose

Ce fichier docker-compose simplifie l'installation pour effectuer des tests avec concourse :
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
Vous pouvez télécharger la ligne de commande `fly` pour votre système d'exploitation depuis le web à `127.0.0.1:8080`

#### Avec Kubernetes (Recommandé)

Vous pouvez facilement déployer concourse dans **Kubernetes** (dans **minikube** par exemple) en utilisant le helm-chart : [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
Après avoir généré l'environnement concourse, vous pouvez générer un secret et donner un accès au SA exécuté dans concourse web pour accéder aux secrets K8s :
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### Créer un Pipeline

Un pipeline est composé d'une liste de [Jobs](https://concourse-ci.org/jobs.html) qui contient une liste ordonnée de [Steps](https://concourse-ci.org/steps.html).

### Steps

Plusieurs types de steps différents peuvent être utilisés :

- **le** [**`task` step**](https://concourse-ci.org/task-step.html) **exécute une** [**task**](https://concourse-ci.org/tasks.html)
- le [`get` step](https://concourse-ci.org/get-step.html) récupère une [resource](https://concourse-ci.org/resources.html)
- le [`put` step](https://concourse-ci.org/put-step.html) met à jour une [resource](https://concourse-ci.org/resources.html)
- le [`set_pipeline` step](https://concourse-ci.org/set-pipeline-step.html) configure un [pipeline](https://concourse-ci.org/pipelines.html)
- le [`load_var` step](https://concourse-ci.org/load-var-step.html) charge une valeur dans une [local var](https://concourse-ci.org/vars.html#local-vars)
- le [`in_parallel` step](https://concourse-ci.org/in-parallel-step.html) exécute des steps en parallèle
- le [`do` step](https://concourse-ci.org/do-step.html) exécute des steps en séquence
- le [`across` step modifier](https://concourse-ci.org/across-step.html#schema.across) exécute un step plusieurs fois ; une fois pour chaque combinaison de valeurs de variables
- le [`try` step](https://concourse-ci.org/try-step.html) tente d'exécuter un step et réussit même si le step échoue

Chaque [step](https://concourse-ci.org/steps.html) dans un [job plan](https://concourse-ci.org/jobs.html#schema.job.plan) s'exécute dans son **propre conteneur**. Vous pouvez exécuter tout ce que vous voulez à l'intérieur du conteneur _(c'est-à-dire exécuter mes tests, exécuter ce script bash, construire cette image, etc.)_. Donc, si vous avez un job avec cinq steps, Concourse créera cinq conteneurs, un pour chaque step.

Par conséquent, il est possible d'indiquer le type de conteneur dans lequel chaque step doit être exécuté.

### Exemple de Pipeline Simple
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
Vérifiez **127.0.0.1:8080** pour voir le flux de pipeline.

### Script Bash avec pipeline de sortie/entrée

Il est possible de **sauvegarder les résultats d'une tâche dans un fichier** et d'indiquer que c'est une sortie, puis d'indiquer l'entrée de la tâche suivante comme la sortie de la tâche précédente. Ce que concourse fait, c'est **monter le répertoire de la tâche précédente dans la nouvelle tâche où vous pouvez accéder aux fichiers créés par la tâche précédente**.

### Déclencheurs

Vous n'avez pas besoin de déclencher les travaux manuellement chaque fois que vous devez les exécuter, vous pouvez également les programmer pour qu'ils s'exécutent à chaque fois :

- Un certain temps passe : [Time resource](https://github.com/concourse/time-resource/)
- Sur de nouveaux commits dans la branche principale : [Git resource](https://github.com/concourse/git-resource)
- Nouveaux PR : [Github-PR resource](https://github.com/telia-oss/github-pr-resource)
- Récupérer ou pousser la dernière image de votre application : [Registry-image resource](https://github.com/concourse/registry-image-resource/)

Vérifiez un exemple de pipeline YAML qui se déclenche sur de nouveaux commits dans master à [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)

{{#include ../../banners/hacktricks-training.md}}
