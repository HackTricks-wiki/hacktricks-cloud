# Creación del Laboratorio Concourse

{{#include ../../banners/hacktricks-training.md}}

## Entorno de Pruebas

### Ejecutando Concourse

#### Con Docker-Compose

Este archivo docker-compose simplifica la instalación para realizar algunas pruebas con concourse:
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
Puedes descargar la línea de comandos `fly` para tu sistema operativo desde la web en `127.0.0.1:8080`

#### Con Kubernetes (Recomendado)

Puedes desplegar concourse fácilmente en **Kubernetes** (en **minikube** por ejemplo) usando el helm-chart: [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
Después de generar el entorno de concourse, podrías generar un secreto y dar acceso al SA que se ejecuta en concourse web para acceder a los secretos de K8s:
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### Crear Pipeline

Un pipeline está compuesto por una lista de [Jobs](https://concourse-ci.org/jobs.html) que contiene una lista ordenada de [Steps](https://concourse-ci.org/steps.html).

### Steps

Se pueden utilizar varios tipos diferentes de pasos:

- **el** [**paso `task`**](https://concourse-ci.org/task-step.html) **ejecuta una** [**tarea**](https://concourse-ci.org/tasks.html)
- el [`get` step](https://concourse-ci.org/get-step.html) obtiene un [recurso](https://concourse-ci.org/resources.html)
- el [`put` step](https://concourse-ci.org/put-step.html) actualiza un [recurso](https://concourse-ci.org/resources.html)
- el [`set_pipeline` step](https://concourse-ci.org/set-pipeline-step.html) configura un [pipeline](https://concourse-ci.org/pipelines.html)
- el [`load_var` step](https://concourse-ci.org/load-var-step.html) carga un valor en una [var local](https://concourse-ci.org/vars.html#local-vars)
- el [`in_parallel` step](https://concourse-ci.org/in-parallel-step.html) ejecuta pasos en paralelo
- el [`do` step](https://concourse-ci.org/do-step.html) ejecuta pasos en secuencia
- el modificador de paso [`across`](https://concourse-ci.org/across-step.html#schema.across) ejecuta un paso múltiples veces; una vez por cada combinación de valores de variable
- el [`try` step](https://concourse-ci.org/try-step.html) intenta ejecutar un paso y tiene éxito incluso si el paso falla

Cada [step](https://concourse-ci.org/steps.html) en un [plan de trabajo](https://concourse-ci.org/jobs.html#schema.job.plan) se ejecuta en su **propio contenedor**. Puedes ejecutar lo que desees dentro del contenedor _(es decir, ejecutar mis pruebas, ejecutar este script bash, construir esta imagen, etc.)_. Así que si tienes un trabajo con cinco pasos, Concourse creará cinco contenedores, uno para cada paso.

Por lo tanto, es posible indicar el tipo de contenedor en el que cada paso necesita ser ejecutado.

### Ejemplo de Pipeline Simple
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
Verifica **127.0.0.1:8080** para ver el flujo de la tubería.

### Script de Bash con tubería de salida/entrada

Es posible **guardar los resultados de una tarea en un archivo** e indicar que es una salida y luego indicar la entrada de la siguiente tarea como la salida de la tarea anterior. Lo que hace concourse es **montar el directorio de la tarea anterior en la nueva tarea donde puedes acceder a los archivos creados por la tarea anterior**.

### Disparadores

No necesitas activar los trabajos manualmente cada vez que necesites ejecutarlos, también puedes programarlos para que se ejecuten cada vez:

- Pasa un tiempo: [Time resource](https://github.com/concourse/time-resource/)
- En nuevos commits a la rama principal: [Git resource](https://github.com/concourse/git-resource)
- Nuevas PR's: [Github-PR resource](https://github.com/telia-oss/github-pr-resource)
- Obtener o enviar la última imagen de tu aplicación: [Registry-image resource](https://github.com/concourse/registry-image-resource/)

Consulta un ejemplo de tubería YAML que se activa con nuevos commits a master en [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)

{{#include ../../banners/hacktricks-training.md}}
