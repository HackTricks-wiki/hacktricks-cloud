# Concourse Lab Creation

{{#include ../../banners/hacktricks-training.md}}

## Testing Environment

### Running Concourse

#### With Docker-Compose

यह docker-compose फ़ाइल concourse के साथ कुछ परीक्षण करने के लिए स्थापना को सरल बनाती है:
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
आप अपने OS के लिए कमांड लाइन `fly` को वेब से `127.0.0.1:8080` पर डाउनलोड कर सकते हैं।

#### Kubernetes के साथ (अनुशंसित)

आप आसानी से **Kubernetes** (उदाहरण के लिए **minikube** में) को हेल्म-चार्ट का उपयोग करके तैनात कर सकते हैं: [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
कॉनकोर्स वातावरण बनाने के बाद, आप एक गुप्त कुंजी उत्पन्न कर सकते हैं और कॉनकोर्स वेब में चल रहे SA को K8s गुप्त कुंजियों तक पहुँच प्रदान कर सकते हैं:
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### पाइपलाइन बनाएं

एक पाइपलाइन [जॉब्स](https://concourse-ci.org/jobs.html) की एक सूची से बनी होती है जिसमें [स्टेप्स](https://concourse-ci.org/steps.html) की एक क्रमबद्ध सूची होती है।

### स्टेप्स

कई विभिन्न प्रकार के स्टेप्स का उपयोग किया जा सकता है:

- **the** [**`task` step**](https://concourse-ci.org/task-step.html) **एक** [**task**](https://concourse-ci.org/tasks.html) **चलाता है**
- [`get` step](https://concourse-ci.org/get-step.html) एक [resource](https://concourse-ci.org/resources.html) लाता है
- [`put` step](https://concourse-ci.org/put-step.html) एक [resource](https://concourse-ci.org/resources.html) को अपडेट करता है
- [`set_pipeline` step](https://concourse-ci.org/set-pipeline-step.html) एक [pipeline](https://concourse-ci.org/pipelines.html) को कॉन्फ़िगर करता है
- [`load_var` step](https://concourse-ci.org/load-var-step.html) एक मान को [local var](https://concourse-ci.org/vars.html#local-vars) में लोड करता है
- [`in_parallel` step](https://concourse-ci.org/in-parallel-step.html) स्टेप्स को समानांतर में चलाता है
- [`do` step](https://concourse-ci.org/do-step.html) स्टेप्स को अनुक्रम में चलाता है
- [`across` step modifier](https://concourse-ci.org/across-step.html#schema.across) एक स्टेप को कई बार चलाता है; प्रत्येक संयोजन के लिए एक बार वैरिएबल मानों का
- [`try` step](https://concourse-ci.org/try-step.html) एक स्टेप को चलाने का प्रयास करता है और सफल होता है भले ही स्टेप विफल हो जाए

हर [स्टेप](https://concourse-ci.org/steps.html) एक [जॉब प्लान](https://concourse-ci.org/jobs.html#schema.job.plan) में अपने **अपने कंटेनर** में चलता है। आप कंटेनर के अंदर कुछ भी चलाने के लिए स्वतंत्र हैं _(यानी, मेरे परीक्षण चलाएं, यह बैश स्क्रिप्ट चलाएं, यह छवि बनाएं, आदि)_। इसलिए यदि आपके पास पांच स्टेप्स वाला एक जॉब है, तो Concourse पांच कंटेनर बनाएगा, प्रत्येक स्टेप के लिए एक।

इसलिए, यह संकेत देना संभव है कि प्रत्येक स्टेप को किस प्रकार के कंटेनर में चलाने की आवश्यकता है।

### सरल पाइपलाइन उदाहरण
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
Check **127.0.0.1:8080** to see the pipeline flow.

### Bash script with output/input pipeline

यह संभव है कि **एक कार्य के परिणामों को एक फ़ाइल में सहेजें** और यह संकेत दें कि यह एक आउटपुट है और फिर अगले कार्य के इनपुट को पिछले कार्य के आउटपुट के रूप में संकेत दें। जो concourse करता है वह है **पिछले कार्य के निर्देशिका को नए कार्य में माउंट करना जहाँ आप पिछले कार्य द्वारा बनाए गए फ़ाइलों तक पहुँच सकते हैं**।

### Triggers

आपको हर बार उन्हें चलाने के लिए मैन्युअल रूप से नौकरियों को ट्रिगर करने की आवश्यकता नहीं है, आप उन्हें हर बार चलाने के लिए प्रोग्राम भी कर सकते हैं:

- कुछ समय बीतता है: [Time resource](https://github.com/concourse/time-resource/)
- मुख्य शाखा में नए कमिट पर: [Git resource](https://github.com/concourse/git-resource)
- नए PR's: [Github-PR resource](https://github.com/telia-oss/github-pr-resource)
- अपने ऐप की नवीनतम छवि को लाना या पुश करना: [Registry-image resource](https://github.com/concourse/registry-image-resource/)

एक YAML पाइपलाइन उदाहरण देखें जो मास्टर में नए कमिट पर ट्रिगर होता है [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)

{{#include ../../banners/hacktricks-training.md}}
