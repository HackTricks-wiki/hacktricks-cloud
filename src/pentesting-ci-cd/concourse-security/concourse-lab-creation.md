# Concourse Lab Creation

{{#include ../../banners/hacktricks-training.md}}

## Testumgebung

### Concourse ausführen

#### Mit Docker-Compose

Diese docker-compose-Datei vereinfacht die Installation, um einige Tests mit Concourse durchzuführen:
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
Sie können die Befehlszeile `fly` für Ihr Betriebssystem von der Website unter `127.0.0.1:8080` herunterladen.

#### Mit Kubernetes (Empfohlen)

Sie können concourse einfach in **Kubernetes** (zum Beispiel in **minikube**) mit dem helm-chart bereitstellen: [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
Nachdem Sie die Concourse-Umgebung erstellt haben, können Sie ein Geheimnis generieren und dem SA, der in Concourse Web läuft, Zugriff auf K8s-Geheimnisse gewähren:
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### Pipeline erstellen

Eine Pipeline besteht aus einer Liste von [Jobs](https://concourse-ci.org/jobs.html), die eine geordnete Liste von [Steps](https://concourse-ci.org/steps.html) enthält.

### Schritte

Es können mehrere verschiedene Arten von Schritten verwendet werden:

- **der** [**`task` Schritt**](https://concourse-ci.org/task-step.html) **führt eine** [**Aufgabe**](https://concourse-ci.org/tasks.html) **aus**
- der [`get` Schritt](https://concourse-ci.org/get-step.html) ruft eine [Ressource](https://concourse-ci.org/resources.html) ab
- der [`put` Schritt](https://concourse-ci.org/put-step.html) aktualisiert eine [Ressource](https://concourse-ci.org/resources.html)
- der [`set_pipeline` Schritt](https://concourse-ci.org/set-pipeline-step.html) konfiguriert eine [Pipeline](https://concourse-ci.org/pipelines.html)
- der [`load_var` Schritt](https://concourse-ci.org/load-var-step.html) lädt einen Wert in eine [lokale Variable](https://concourse-ci.org/vars.html#local-vars)
- der [`in_parallel` Schritt](https://concourse-ci.org/in-parallel-step.html) führt Schritte parallel aus
- der [`do` Schritt](https://concourse-ci.org/do-step.html) führt Schritte sequenziell aus
- der [`across` Schrittmodifikator](https://concourse-ci.org/across-step.html#schema.across) führt einen Schritt mehrfach aus; einmal für jede Kombination von Variablenwerten
- der [`try` Schritt](https://concourse-ci.org/try-step.html) versucht, einen Schritt auszuführen und hat Erfolg, selbst wenn der Schritt fehlschlägt

Jeder [Schritt](https://concourse-ci.org/steps.html) in einem [Job-Plan](https://concourse-ci.org/jobs.html#schema.job.plan) läuft in seinem **eigenen Container**. Sie können alles, was Sie möchten, im Container ausführen _(d.h. meine Tests ausführen, dieses Bash-Skript ausführen, dieses Bild erstellen usw.)_. Wenn Sie also einen Job mit fünf Schritten haben, erstellt Concourse fünf Container, einen für jeden Schritt.

Daher ist es möglich, den Typ des Containers anzugeben, in dem jeder Schritt ausgeführt werden muss.

### Einfaches Pipeline-Beispiel
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
Überprüfen Sie **127.0.0.1:8080**, um den Pipeline-Fluss zu sehen.

### Bash-Skript mit Ausgabe/Eingabe-Pipeline

Es ist möglich, **die Ergebnisse einer Aufgabe in einer Datei zu speichern** und anzugeben, dass es sich um eine Ausgabe handelt, und dann die Eingabe der nächsten Aufgabe als Ausgabe der vorherigen Aufgabe anzugeben. Was Concourse tut, ist, **das Verzeichnis der vorherigen Aufgabe in der neuen Aufgabe zu mounten, wo Sie auf die von der vorherigen Aufgabe erstellten Dateien zugreifen können**.

### Trigger

Sie müssen die Jobs nicht jedes Mal manuell auslösen, wenn Sie sie ausführen möchten, Sie können sie auch so programmieren, dass sie jedes Mal ausgeführt werden:

- Es vergeht etwas Zeit: [Time resource](https://github.com/concourse/time-resource/)
- Bei neuen Commits zum Hauptbranch: [Git resource](https://github.com/concourse/git-resource)
- Neue PRs: [Github-PR resource](https://github.com/telia-oss/github-pr-resource)
- Holen Sie sich das neueste Bild Ihrer App oder pushen Sie es: [Registry-image resource](https://github.com/concourse/registry-image-resource/)

Überprüfen Sie ein YAML-Pipeline-Beispiel, das bei neuen Commits auf master ausgelöst wird, in [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)

{{#include ../../banners/hacktricks-training.md}}
