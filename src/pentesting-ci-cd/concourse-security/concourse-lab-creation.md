# Concourse Lab Creation

{{#include ../../banners/hacktricks-training.md}}

## Testing Environment

### Running Concourse

#### With Docker-Compose

यह docker-compose फ़ाइल concourse के साथ कुछ परीक्षण करने के लिए स्थापना को सरल बनाती है:
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
आप अपने OS के लिए कमांड लाइन `fly` को वेब से `127.0.0.1:8080` पर डाउनलोड कर सकते हैं।

#### Kubernetes के साथ (सिफारिश की गई)

आप आसानी से **Kubernetes** (उदाहरण के लिए **minikube** में) को helm-chart का उपयोग करके तैनात कर सकते हैं: [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
concourse env बनाने के बाद, आप एक गुप्त को उत्पन्न कर सकते हैं और concourse वेब में चल रहे SA को K8s गुप्तों तक पहुँचने की अनुमति दे सकते हैं:
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### पाइपलाइन बनाएं

एक पाइपलाइन [Jobs](https://concourse-ci.org/jobs.html) की एक सूची से बनी होती है जिसमें [Steps](https://concourse-ci.org/steps.html) की एक क्रमबद्ध सूची होती है।

### Steps

कई विभिन्न प्रकार के स्टेप्स का उपयोग किया जा सकता है:

- **the** [**`task` step**](https://concourse-ci.org/task-step.html) **runs a** [**task**](https://concourse-ci.org/tasks.html)
- the [`get` step](https://concourse-ci.org/get-step.html) fetches a [resource](https://concourse-ci.org/resources.html)
- the [`put` step](https://concourse-ci.org/put-step.html) updates a [resource](https://concourse-ci.org/resources.html)
- the [`set_pipeline` step](https://concourse-ci.org/set-pipeline-step.html) configures a [pipeline](https://concourse-ci.org/pipelines.html)
- the [`load_var` step](https://concourse-ci.org/load-var-step.html) loads a value into a [local var](https://concourse-ci.org/vars.html#local-vars)
- the [`in_parallel` step](https://concourse-ci.org/in-parallel-step.html) runs steps in parallel
- the [`do` step](https://concourse-ci.org/do-step.html) runs steps in sequence
- the [`across` step modifier](https://concourse-ci.org/across-step.html#schema.across) runs a step multiple times; once for each combination of variable values
- the [`try` step](https://concourse-ci.org/try-step.html) attempts to run a step and succeeds even if the step fails

प्रत्येक [step](https://concourse-ci.org/steps.html) एक [job plan](https://concourse-ci.org/jobs.html#schema.job.plan) में अपने **अपने कंटेनर** में चलता है। आप कंटेनर के अंदर कुछ भी चलाने के लिए स्वतंत्र हैं _(i.e. run my tests, run this bash script, build this image, etc.)_। इसलिए यदि आपके पास पांच स्टेप्स के साथ एक जॉब है, तो Concourse पांच कंटेनर बनाएगा, प्रत्येक स्टेप के लिए एक।

इसलिए, यह संकेत देना संभव है कि प्रत्येक स्टेप को किस प्रकार के कंटेनर में चलाने की आवश्यकता है।

### सरल पाइपलाइन उदाहरण
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
**127.0.0.1:8080** पर पाइपलाइन प्रवाह देखें।

### आउटपुट/इनपुट पाइपलाइन के साथ बैश स्क्रिप्ट

यह संभव है कि **एक कार्य के परिणामों को एक फ़ाइल में सहेजें** और यह संकेत दें कि यह एक आउटपुट है और फिर अगले कार्य के इनपुट को पिछले कार्य के आउटपुट के रूप में संकेत दें। जो concourse करता है वह है **पिछले कार्य के निर्देशिका को नए कार्य में माउंट करना जहां आप पिछले कार्य द्वारा बनाए गए फ़ाइलों तक पहुँच सकते हैं**।

### ट्रिगर्स

आपको हर बार उन्हें चलाने के लिए मैन्युअल रूप से नौकरियों को ट्रिगर करने की आवश्यकता नहीं है, आप उन्हें हर बार चलाने के लिए प्रोग्राम भी कर सकते हैं:

- कुछ समय बीतता है: [Time resource](https://github.com/concourse/time-resource/)
- मुख्य शाखा में नए कमिट पर: [Git resource](https://github.com/concourse/git-resource)
- नए PR's: [Github-PR resource](https://github.com/telia-oss/github-pr-resource)
- अपने ऐप की नवीनतम छवि लाना या पुश करना: [Registry-image resource](https://github.com/concourse/registry-image-resource/)

एक YAML पाइपलाइन उदाहरण देखें जो मास्टर में नए कमिट पर ट्रिगर होता है [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)

{{#include ../../banners/hacktricks-training.md}}
