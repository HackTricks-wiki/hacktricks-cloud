# Metodologia di Pentesting CI/CD

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS sta per **Version Control System**, questo sistema permette agli sviluppatori di **manage their source code**. Quello più comune è **git** e di solito troverai le aziende che lo usano su una delle seguenti **piattaforme**:

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Cloud providers (they offer their own VCS platforms)


## CI/CD Pipelines

CI/CD pipelines consentono agli sviluppatori di **automate the execution of code** per vari scopi, inclusi build, test e deployment delle applicazioni. Questi workflow automatici vengono **triggered by specific actions**, come push di codice, pull request o attività pianificate. Sono utili per snellire il processo dallo sviluppo alla produzione.

Tuttavia, questi sistemi devono essere **eseguiti da qualche parte** e di solito con **privileged credentials to deploy code or access sensitive information**.

## VCS Pentesting Methodology

> [!NOTE]
> Anche se alcune piattaforme VCS permettono di creare pipelines, in questa sezione analizzeremo solo attacchi potenziali al controllo del source code.

Le piattaforme che contengono il source code del tuo progetto custodiscono informazioni sensibili e bisogna essere molto cauti con i permessi concessi all'interno di queste piattaforme. Ecco alcuni problemi comuni nelle piattaforme VCS che un attacker potrebbe abusare:

- **Leaks**: Se il tuo code contiene leaks nei commit e l'attacker può accedere al repo (perché è pubblico o perché ha accesso), potrebbe scoprire i leaks.
- **Access**: Se un attacker riesce ad avere accesso a un account dentro la VCS platform potrebbe ottenere **più visibilità e permessi**.
- **Register**: Alcune piattaforme permettono semplicemente a utenti esterni di creare un account.
- **SSO**: Alcune piattaforme non consentono la registrazione locale, ma permettono a chiunque di entrare con un SSO valido (quindi un attacker potrebbe usare ad esempio il suo account github per accedere).
- **Credentials**: Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... ci sono diversi tipi di token che un utente potrebbe rubare per accedere in qualche modo a un repo.
- **Webhooks**: Le piattaforme VCS permettono di generare webhooks. Se non sono **protetti** con segreti non visibili un **attacker potrebbe abusarne**.
- Se non è presente nessun segreto, l'attacker potrebbe abusare del webhook della piattaforma di terze parti
- Se il segreto è nell'URL, succede la stessa cosa e l'attacker ha anche il segreto
- **Code compromise:** Se un attore maligno ha qualche tipo di **write** access sui repo, potrebbe provare a **inject malicious code**. Per avere successo potrebbe essere necessario **bypassare branch protections**. Queste azioni possono essere effettuate con diversi obiettivi:
  - Compromettere il main branch per **compromise production**.
  - Compromettere il main (o altri branch) per **compromise developers machines** (dato che solitamente eseguono test, terraform o altre cose presenti nel repo sulle loro macchine).
- **Compromise the pipeline** (vedi sezione successiva)

## Pipelines Pentesting Methodology

Il modo più comune per definire una pipeline è usando un **CI configuration file hosted in the repository** che la pipeline costruisce. Questo file descrive l'ordine dei job eseguiti, le condizioni che influenzano il flusso e le impostazioni dell'ambiente di build.\
Questi file tipicamente hanno un nome e un formato coerente, per esempio — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI), e i file YAML di GitHub Actions sotto .github/workflows. Quando viene triggerata, la pipeline job **pulls the code** dalla source selezionata (es. commit / branch), e **runs the commands specified in the CI configuration file** contro quel code.

Quindi l'obiettivo finale dell'attacker è in qualche modo **compromise those configuration files** o i **commands they execute**.

### PPE - Poisoned Pipeline Execution

The Poisoned Pipeline Execution (PPE) path sfrutta i permessi in un repository SCM per manipolare una CI pipeline ed eseguire comandi dannosi. Utenti con i permessi necessari possono modificare il CI configuration file o altri file usati dal job della pipeline per includere comandi malevoli. Questo "poisons" la CI pipeline, portando all'esecuzione di questi comandi malevoli.

Perché un attore maligno abbia successo in un attacco PPE deve poter:

- Avere **write access to the VCS platform**, dato che di solito le pipeline vengono triggerate quando viene eseguito un push o una pull request. (Vedi la VCS pentesting methodology per un riassunto dei modi per ottenere accesso).
- Nota che a volte una **external PR** conta come "write access".
- Anche avendo permessi di write, deve assicurarsi di poter **modify the CI config file or other files the config is relying on**.
- Per fare ciò potrebbe essere necessario **bypass branch protections**.

Ci sono 3 varianti di PPE:

- **D-PPE**: Un attacco **Direct PPE** avviene quando l'attore **modifica il CI config** file che verrà eseguito.
- **I-DDE**: Un attacco **Indirect PPE** avviene quando l'attore **modifica** un **file** su cui il CI config file che verrà eseguito **relies on** (come un make file o una terraform config).
- **Public PPE or 3PE**: In alcuni casi le pipeline possono essere **triggered by users that doesn't have write access in the repo** (e che magari non fanno parte dell'org) perché possono inviare una PR.
- **3PE Command Injection**: Di solito, le CI/CD pipelines impostano environment variables con **information about the PR**. Se quel valore può essere controllato da un attacker (ad esempio il title della PR) e viene **used** in un punto **dangerous** (come l'esecuzione di **sh commands**), un attacker potrebbe **inject commands in there**.

### Exploitation Benefits

Conoscendo le 3 varianti per poisonare una pipeline, vediamo cosa potrebbe ottenere un attacker dopo un exploitation di successo:

- **Secrets**: Come accennato prima, le pipeline richiedono **privileges** per i loro job (recuperare il code, buildarlo, deployarlo...) e questi privilegi sono di solito **granted in secrets**. Questi secrets sono generalmente accessibili tramite **env variables or files inside the system**. Pertanto un attacker cercherà sempre di esfiltrare quanti più secrets possibile.
- A seconda della pipeline platform l'attacker **might need to specify the secrets in the config**. Questo significa che se l'attacker non può modificare la CI configuration pipeline (**I-PPE** per esempio), potrebbe **only exfiltrate the secrets that pipeline has**.
- **Computation**: Il code viene eseguito da qualche parte; a seconda di dove viene eseguito un attacker potrebbe essere in grado di pivotare ulteriormente.
- **On-Premises**: Se le pipeline vengono eseguite on premises, un attacker potrebbe trovarsi in una **internal network con accesso a più risorse**.
- **Cloud**: L'attacker potrebbe accedere **ad altre macchine in cloud** ma anche **exfiltrate** IAM roles/service accounts **tokens** per ottenere **ulteriore accesso** dentro il cloud.
- **Platforms machine**: A volte i job vengono eseguiti nelle **pipelines platform machines**, che di solito sono su cloud con **no more access**.
- **Select it:** Talvolta la **pipelines platform** avrà configurato più macchine e se puoi **modify the CI configuration file** puoi **indicare dove vuoi che giri il codice malevolo**. In questa situazione, un attacker probabilmente eseguirà una reverse shell su ciascuna macchina possibile per provare a sfruttarla ulteriormente.
- **Compromise production**: Se sei dentro la pipeline e la versione finale viene buildata e deployata da essa, potresti **compromise the code that is going to end running in production**.

## More relevant info

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) è uno strumento open-source per auditare la tua software supply chain stack in termini di compliance di sicurezza basato su un nuovo [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf). L'audit si concentra sull'intero processo SDLC, dove può rivelare rischi dal code time al deploy time.

### Top 10 CI/CD Security Risk

Consulta questo articolo interessante sui top 10 CI/CD risks secondo Cider: [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Labs

- Per ogni piattaforma che puoi eseguire localmente troverai come lanciarla localmente così puoi configurarla come vuoi per fare i test
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Automatic Tools

- [**Checkov**](https://github.com/bridgecrewio/checkov): **Checkov** è uno static code analysis tool per infrastructure-as-code.

## References

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
