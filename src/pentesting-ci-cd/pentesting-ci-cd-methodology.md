# Pentesting CI/CD Methodology

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS sta per **Sistema di Controllo delle Versioni**, questo sistema permette agli sviluppatori di **gestire il loro codice sorgente**. Il più comune è **git** e solitamente le aziende lo utilizzano in una delle seguenti **piattaforme**:

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Cloud providers (offrono le proprie piattaforme VCS)


## CI/CD Pipelines

Le CI/CD pipelines permettono agli sviluppatori di **automatizzare l’esecuzione del codice** per vari scopi, inclusi build, test e deploy delle applicazioni. Questi workflow automatizzati sono **innescati da azioni specifiche**, come push di codice, pull request o task pianificati. Sono utili per snellire il processo dallo sviluppo alla produzione.

Tuttavia, questi sistemi devono essere **eseguiti da qualche parte** e solitamente con **credenziali privilegiate per deployare codice o accedere a informazioni sensibili**.

## VCS Pentesting Methodology

> [!NOTE]
> Anche se alcune piattaforme VCS permettono di creare pipelines, in questa sezione analizzeremo solo potenziali attacchi al controllo del codice sorgente.

Le piattaforme che contengono il codice sorgente del tuo progetto custodiscono informazioni sensibili e le persone devono essere molto attente alle autorizzazioni concesse all'interno di queste piattaforme. Questi sono alcuni problemi comuni nelle piattaforme VCS che un attacker potrebbe sfruttare:

- **Leaks**: Se il tuo codice contiene leak nei commit e l'attacker può accedere al repo (perché è pubblico o perché ha accesso), potrebbe scoprire i leak.
- **Access**: Se un attacker può **accedere ad un account all'interno della piattaforma VCS** potrebbe ottenere **maggiore visibilità e permessi**.
- **Register**: Alcune piattaforme permettono semplicemente a utenti esterni di creare un account.
- **SSO**: Alcune piattaforme non permettono registrazioni dirette, ma consentono a chiunque con un SSO valido di accedere (ad esempio un attacker potrebbe usare il suo account github per entrare).
- **Credentials**: Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... ci sono diversi tipi di token che un utente potrebbe rubare per accedere in qualche modo a un repo.
- **Webhooks**: VCS platforms allow to generate webhooks. If they are **not protected** with non visible secrets an **attacker could abuse them**.
- If no secret is in place, the attacker could abuse the webhook of the third party platform
- If the secret is in the URL, the same happens and the attacker also have the secret
- **Code compromise:** Se un attore malevolo ha qualche tipo di **write** su un repo, potrebbe provare a **iniettare codice malevolo**. Per avere successo potrebbe essere necessario **bypassare le branch protections**. Queste azioni possono essere eseguite con diversi obiettivi:
  - Compromettere il main branch per **compromettere la produzione**.
  - Compromettere il main (o altri branch) per **compromettere le macchine degli sviluppatori** (poiché solitamente eseguono test, terraform o altre operazioni locali sui repo).
- **Compromise the pipeline** (vedi sezione successiva)

## Pipelines Pentesting Methodology

Il modo più comune per definire una pipeline è tramite un **file di configurazione CI ospitato nel repository** che la pipeline builda. Questo file descrive l'ordine dei job eseguiti, le condizioni che influenzano il flusso e le impostazioni dell'ambiente di build.\
Questi file tipicamente hanno nomi e formati coerenti, per esempio — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI) e i file YAML di GitHub Actions sotto .github/workflows. Quando viene triggerata, la pipeline job **pulls the code** dalla sorgente selezionata (es. commit / branch), e **esegue i comandi specificati nel CI configuration file** su quel codice.

Quindi l'obiettivo ultimo dell'attacker è in qualche modo **compromettere quei file di configurazione** o i **comandi che essi eseguono**.

> [!TIP]
> Alcuni hosted builders permettono ai contributor di scegliere il Docker build context e il Dockerfile path. Se il context è controllato dall'attacker, potresti impostarlo fuori dal repo (es. "..") per ingerire file dell'host durante il build ed esfiltrare secrets. Vedi:
>
>{{#ref}}
>docker-build-context-abuse.md
>{{#endref}}

### PPE - Poisoned Pipeline Execution

The Poisoned Pipeline Execution (PPE) path sfrutta i permessi in un repository SCM per manipolare una CI pipeline ed eseguire comandi dannosi. Utenti con i permessi necessari possono modificare i file di configurazione CI o altri file usati dal job della pipeline per includere comandi malevoli. Questo "avvelena" la pipeline CI, portando all'esecuzione di tali comandi dannosi.

Perché un attore malevolo abbia successo in un attacco PPE deve essere in grado di:

- Avere **write access alla piattaforma VCS**, poiché solitamente le pipeline sono triggerate quando viene fatto un push o una pull request. (Vedi la VCS pentesting methodology per un riepilogo dei modi per ottenere accesso).
- Nota che a volte una **PR esterna conta come "write access"**.
- Anche se ha permessi di scrittura, deve essere sicuro di poter **modificare il file di config CI o altri file su cui la config si basa**.
- Per fare ciò potrebbe dover essere in grado di **bypassare branch protections**.

Ci sono 3 varianti di PPE:

- **D-PPE**: Un attacco **Direct PPE** si verifica quando l'attore **modifica il file di config CI** che verrà eseguito.
- **I-DDE**: Un attacco **Indirect PPE** si verifica quando l'attore **modifica** un **file** su cui il file di config CI fa **relay** (come un Makefile o una configurazione terraform).
- **Public PPE or 3PE**: In alcuni casi le pipelines possono essere **triggerate da utenti che non hanno write access al repo** (e che potrebbero non far parte dell'org) perché possono inviare una PR.
- **3PE Command Injection**: Di solito, CI/CD pipelines imposteranno environment variables con informazioni sulla PR. Se quel valore può essere controllato da un attacker (come il titolo della PR) e viene **usato** in un punto **pericoloso** (ad es. per eseguire comandi sh), un attacker potrebbe **iniettare comandi lì dentro**.

### Exploitation Benefits

Conoscendo le 3 varianti per avvelenare una pipeline, vediamo cosa un attacker potrebbe ottenere dopo un exploit riuscito:

- **Secrets**: Come già menzionato, le pipeline richiedono **privilegi** per i loro job (recuperare il codice, buildarlo, deployarlo...) e questi privilegi sono solitamente **conservati in secrets**. Questi secrets sono spesso accessibili tramite **env variables o file all'interno del sistema**. Pertanto un attacker cercherà sempre di esfiltrare quanti più secrets possibile.
- A seconda della piattaforma pipeline, l'attacker **potrebbe dover specificare i secrets nella config**. Questo significa che se l'attacker non può modificare la configurazione CI (es. I-PPE), potrebbe **esfiltrare solo i secrets che quella pipeline possiede**.
- **Computational resources**: Il codice viene eseguito da qualche parte; a seconda di dove viene eseguito un attacker potrebbe essere in grado di pivotare ulteriormente.
- **On-Premises**: Se le pipeline sono eseguite on-premises, un attacker potrebbe ritrovarsi in una **rete interna con accesso ad altre risorse**.
- **Cloud**: L'attacker potrebbe accedere **ad altre macchine nel cloud** ma anche **esfiltrare** IAM roles/service accounts **tokens** da esso per ottenere **ulteriore accesso nel cloud**.
- **Platforms machine**: A volte i job vengono eseguiti nelle **macchine della piattaforma pipeline**, che solitamente stanno in un cloud senza altri accessi.
- **Select it:** Talvolta la **piattaforma pipeline ha diverse macchine configurate** e se puoi **modificare il file di config CI** puoi **indicare dove vuoi eseguire il codice malevolo**. In questa situazione un attacker probabilmente aprirà una reverse shell su ciascuna macchina possibile per cercare di sfruttarla ulteriormente.
- **Compromise production**: Se sei all'interno della pipeline e la versione finale viene buildata e deployata da essa, potresti **compromettere il codice che finirà in produzione**.

## More relevant info

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) è uno strumento open-source per auditare la tua supply chain software per la compliance di sicurezza basata sul nuovo [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf). L'audit si concentra sull'intero processo SDLC, dove può rivelare rischi dal time of code fino al deploy.

### Top 10 CI/CD Security Risk

Leggi questo articolo interessante sui top 10 rischi CI/CD secondo Cider: [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Labs

- Per ogni piattaforma che puoi eseguire localmente troverai come avviarla localmente così puoi configurarla come vuoi per testarla
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Automatic Tools

- [**Checkov**](https://github.com/bridgecrewio/checkov): **Checkov** è uno strumento di analisi statica del codice per infrastructure-as-code.

## References

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
