# Metodologia de Pentesting CI/CD

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS significa **Sistema de Controle de Versão**, este sistema permite que desenvolvedores **gerenciem seu código-fonte**. O mais comum é **git** e você normalmente encontrará empresas usando-o em uma das seguintes **plataformas**:

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Provedores de nuvem (eles oferecem suas próprias plataformas VCS)


## CI/CD Pipelines

CI/CD pipelines permitem que desenvolvedores **automatem a execução de código** para diversos propósitos, incluindo build, testes e deploy de aplicações. Esses fluxos automatizados são **acionados por ações específicas**, como pushes de código, pull requests ou tarefas agendadas. Eles são úteis para agilizar o processo do desenvolvimento à produção.

No entanto, esses sistemas precisam ser **executados em algum lugar** e geralmente com **credenciais privilegiadas para deploy de código ou acesso a informações sensíveis**.

## Metodologia de VCS Pentesting

> [!NOTE]
> Mesmo que algumas plataformas VCS permitam criar pipelines, para esta seção vamos analisar apenas ataques potenciais ao controle do código-fonte.

Plataformas que contêm o código-fonte do seu projeto armazenam informações sensíveis e as pessoas precisam ter muito cuidado com as permissões concedidas dentro dessa plataforma. Estes são alguns problemas comuns em plataformas VCS que um atacante pode abusar:

- **Leaks**: Se seu código contiver leaks nos commits e o atacante puder acessar o repo (porque é público ou porque ele tem acesso), ele poderá descobrir os leaks.
- **Acesso**: Se um atacante conseguir **acessar uma conta dentro da plataforma VCS** ele poderia obter **mais visibilidade e permissões**.
- **Registro**: Algumas plataformas simplesmente permitem que usuários externos criem uma conta.
- **SSO**: Algumas plataformas não permitem registro, mas permitem que qualquer um acesse com um SSO válido (então um atacante poderia usar sua conta do github para entrar, por exemplo).
- **Credenciais**: Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... existem vários tipos de tokens que um usuário pode roubar para acessar de alguma forma um repo.
- **Webhooks**: Webhooks são permitidos nas plataformas VCS. Se não estiverem **protegidos** com segredos não visíveis, um **atacante pode abusar deles**.
- Se nenhum segredo estiver em vigor, o atacante poderia abusar do webhook da plataforma terceirizada
- Se o segredo estiver na URL, o mesmo acontece e o atacante também terá o segredo
- **Comprometimento do código:** Se um ator malicioso tiver algum tipo de **acesso de escrita** sobre os repos, ele poderia tentar **injetar código malicioso**. Para ter sucesso ele pode precisar **contornar proteções de branch**. Essas ações podem ser realizadas com diferentes objetivos:
- Comprometer a main branch para **comprometer a produção**.
- Comprometer a main (ou outras branches) para **comprometer máquinas dos desenvolvedores** (já que eles normalmente executam testes, terraform ou outras coisas do repo em suas máquinas).
- **Comprometer a pipeline** (veja a próxima seção)

## Metodologia de Pipelines Pentesting

A maneira mais comum de definir uma pipeline é usando um **arquivo de configuração de CI hospedado no repositório** que a pipeline builda. Esse arquivo descreve a ordem dos jobs executados, condições que afetam o fluxo e configurações do ambiente de build.\
Esses arquivos tipicamente têm um nome e formato consistentes, por exemplo — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI), e os arquivos YAML do GitHub Actions localizados em .github/workflows. Quando acionada, a job da pipeline **puxa o código** da fonte selecionada (ex.: commit / branch), e **executa os comandos especificados no arquivo de configuração do CI** contra esse código.

Portanto, o objetivo final do atacante é de alguma forma **comprometer esses arquivos de configuração** ou os **comandos que eles executam**.

> [!TIP]
> Alguns builders hospedados permitem que contribuidores escolham o contexto de build do Docker e o caminho do Dockerfile. Se o contexto for controlado pelo atacante, você pode defini-lo fora do repo (ex.: "..") para ingerir arquivos do host durante o build e exfiltrar segredos. Veja:
>
>{{#ref}}
>docker-build-context-abuse.md
>{{#endref}}

### PPE - Poisoned Pipeline Execution

O Poisoned Pipeline Execution (PPE) explora permissões em um repositório SCM para manipular uma pipeline CI e executar comandos maliciosos. Usuários com as permissões necessárias podem modificar arquivos de configuração do CI ou outros arquivos usados pela job da pipeline para incluir comandos maliciosos. Isso "envenena" a pipeline CI, levando à execução desses comandos maliciosos.

Para que um ator malicioso tenha sucesso realizando um ataque PPE ele precisa ser capaz de:

- Ter **acesso de escrita à plataforma VCS**, pois normalmente pipelines são acionadas quando um push ou um pull request é realizado. (Veja a metodologia de VCS para um resumo de formas de obter acesso).
- Note que às vezes um **PR externo conta como "acesso de escrita"**.
- Mesmo que ele tenha permissões de escrita, ele precisa ter certeza de que pode **modificar o arquivo de config do CI ou outros arquivos dos quais o config dependa**.
- Para isso, pode ser necessário **contornar as proteções de branch**.

Existem 3 variantes de PPE:

- **D-PPE**: Um **Direct PPE** ocorre quando o ator **modifica o arquivo de config do CI** que será executado.
- **I-DDE**: Um **Indirect PPE** ocorre quando o ator **modifica** um **arquivo** do qual o arquivo de config do CI depende (como um make file ou uma terraform config).
- **Public PPE or 3PE**: Em alguns casos as pipelines podem ser **acionadas por usuários que não têm acesso de escrita no repo** (e que podem nem mesmo fazer parte da org) porque podem enviar um PR.
- **3PE Command Injection**: Geralmente, CI/CD pipelines vão **definir environment variables** com **informações sobre o PR**. Se esse valor puder ser controlado por um atacante (como o título do PR) e for **usado** em um **local perigoso** (como na execução de comandos sh), um atacante pode **injetar comandos ali**.

### Benefícios da Exploração

Conhecendo as 3 variantes para envenenar uma pipeline, vejamos o que um atacante poderia obter após uma exploração bem-sucedida:

- **Segredos**: Como mencionado anteriormente, pipelines requerem **privilégios** para suas jobs (recuperar o código, build, deploy...) e esses privilégios geralmente são **concedidos em secrets**. Esses secrets geralmente são acessíveis via **env variables ou arquivos dentro do sistema**. Portanto um atacante sempre tentará exfiltrar o máximo de secrets possível.
- Dependendo da plataforma de pipeline o atacante **pode precisar especificar os secrets na config**. Isso significa que se o atacante não puder modificar a configuração da pipeline (**I-PPE** por exemplo), ele poderia **apenas exfiltrar os secrets que aquela pipeline possui**.
- **Computação**: O código é executado em algum lugar; dependendo de onde é executado, um atacante pode ser capaz de pivotar mais.
- **On-Premises**: Se as pipelines são executadas on-premises, um atacante pode chegar em uma **rede interna com acesso a mais recursos**.
- **Cloud**: O atacante pode acessar **outras máquinas na cloud** mas também pode **exfiltrar** tokens de roles IAM/service accounts para obter **acesso adicional dentro da cloud**.
- **Máquinas da plataforma**: Às vezes as jobs serão executadas dentro das **máquinas da plataforma de pipelines**, que normalmente estão em uma cloud sem **mais acessos**.
- **Selecione:** Às vezes a **plataforma de pipelines terá várias máquinas configuradas** e se você puder **modificar o arquivo de configuração do CI** você pode **indicar onde deseja executar o código malicioso**. Nessa situação, um atacante provavelmente rodará um reverse shell em cada máquina possível para tentar explorá-la mais a fundo.
- **Comprometer a produção**: Se você estiver dentro da pipeline e a versão final for buildada e deployada a partir dela, você pode **comprometer o código que vai rodar em produção**.

## Mais informações relevantes

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) é uma ferramenta open-source para auditar sua stack de software supply chain quanto à conformidade de segurança com base em um novo [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf). A auditoria foca em todo o processo SDLC, onde pode revelar riscos desde o tempo de código até o tempo de deploy.

### Top 10 CI/CD Security Risk

Confira este artigo interessante sobre os top 10 riscos de CI/CD segundo a Cider: [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Laboratórios

- Em cada plataforma que você puder rodar localmente você encontrará como iniciá-la localmente para que possa configurá-la como quiser para testar
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Ferramentas Automáticas

- [**Checkov**](https://github.com/bridgecrewio/checkov): **Checkov** é uma ferramenta de análise estática para infraestrutura como código.

## Referências

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
