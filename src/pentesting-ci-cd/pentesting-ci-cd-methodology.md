# Pentesting CI/CD पद्धति

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS का मतलब **Version Control System** है, यह सिस्टम डेवलपर्स को उनके **source code** को प्रबंधित करने की अनुमति देता है। सबसे सामान्य है **git** और आप आमतौर पर कंपनियों को निम्नलिखित **platforms** में से किसी एक का उपयोग करते हुए पाएँगे:

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Cloud providers (they offer their own VCS platforms)


## CI/CD Pipelines

CI/CD pipelines डेवलपर्स को विभिन्न कार्यों के लिए कोड के निष्पादन को **automate** करने में सक्षम बनाती हैं, जिनमें application का build, test और deploy शामिल है। ये automated workflows विशिष्ट क्रियाओं (जैसे code pushes, pull requests, या scheduled tasks) द्वारा **trigger** होते हैं। ये development से production तक के प्रोसेस को streamline करने में उपयोगी हैं।

हालाँकि, इन सिस्टम्स को कहीं **execute** करना होता है और सामान्यतः इन्हें **privileged credentials to deploy code or access sensitive information** की आवश्यकता होती है।

## VCS Pentesting Methodology

> [!NOTE]
> भले ही कुछ VCS platforms pipelines बनाने की अनुमति देते हों, इस सेक्शन के लिए हम केवल सोर्स कोड के नियंत्रण पर संभावित हमलों का विश्लेषण करने जा रहे हैं।

जो platforms आपके प्रोजेक्ट का source code रखते हैं उनमें संवेदनशील जानकारी होती है और लोगों को इस प्लेटफॉर्म के भीतर दिए गए permissions के साथ बहुत सतर्क रहना चाहिए। VCS platforms में कुछ सामान्य समस्याएँ जो attacker दुरुपयोग कर सकता है:

- **Leaks**: यदि आपका code commits में leaks रखता है और attacker repo तक पहुँच सकता है (क्योंकि वह public है या उसके पास access है), तो वह उन leaks का पता लगा सकता है।
- **Access**: यदि कोई attacker VCS platform के अंदर किसी account तक access कर लेता है तो वह और अधिक visibility और permissions प्राप्त कर सकता है।
- **Register**: कुछ platforms बाहरी users को सिर्फ account बनाने की अनुमति देते हैं।
- **SSO**: कुछ platforms users को register करने की अनुमति नहीं देते, लेकिन किसी valid SSO के साथ किसी को भी access करने की अनुमति दे सकते हैं (तो attacker उदाहरण के लिए अपने github account का उपयोग करके प्रवेश कर सकता है)।
- **Credentials**: Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... कई प्रकार के tokens होते हैं जिन्हें कोई user चुरा कर किसी repo तक किसी न किसी तरह से access प्राप्त कर सकता है।
- **Webhooks**: VCS platforms webhooks जनरेट करने की अनुमति देते हैं। अगर वे non visible secrets से **protect** नहीं किए गए हैं तो एक **attacker उन्हें abuse कर सकता है**।
- यदि कोई secret मौजूद नहीं है, attacker तीसरी पार्टी platform के webhook का दुरुपयोग कर सकता है
- यदि secret URL में है, तो भी वही बात होती है और attacker के पास secret भी होगा
- **Code compromise:** यदि कोई malicious actor के पास repos पर किसी प्रकार का **write** access है, तो वह malicious code inject करने की कोशिश कर सकता है। सफल होने के लिए उसे शायद **branch protections** बायपास करनी होंगी। ये क्रियाएँ विभिन्न उद्देश्यों के साथ की जा सकती हैं:
  - main branch को compromise करके **production** पर प्रभाव डालना।
  - main (या अन्य branches) को compromise करके developers machines को compromise करना (क्योंकि वे आमतौर पर repo के अंदर test, terraform या अन्य चीजें अपने machines पर execute करते हैं)।
- **Compromise the pipeline** (अगला सेक्शन देखें)

## Pipelines Pentesting Methodology

pipeline को परिभाषित करने का सबसे सामान्य तरीका है **CI configuration file hosted in the repository** जिसे pipeline build करता है। यह फाइल executed jobs के क्रम, flow को प्रभावित करने वाली conditions, और build environment settings का वर्णन करती है.\
ये फाइलें सामान्यतः एक सुसंगत नाम और फ़ॉर्मैट रखती हैं, उदाहरण के लिए — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI), और GitHub Actions YAML फाइलें जो .github/workflows के अंतर्गत होती हैं। जब trigger होता है, pipeline job चुने गए source (उदा. commit / branch) से **code को pull** करता है, और CI configuration file में specified commands को उस code के खिलाफ **run** करता है।

अतः attacker का अंतिम लक्ष्य किसी तरह से उन configuration files या वे commands जिन्हें वे execute करते हैं, को **compromise** करना होता है।

> [!TIP]
> कुछ hosted builders contributors को Docker build context और Dockerfile path चुनने देते हैं। यदि context attacker-controlled है, तो आप इसे repo के बाहर (उदा., "..") सेट कर सकते हैं ताकि build के दौरान host files ingest हों और secrets exfiltrate की जा सकें। देखें:
>
>{{#ref}}
>docker-build-context-abuse.md
>{{#endref}}

### PPE - Poisoned Pipeline Execution

Poisoned Pipeline Execution (PPE) पाथ SCM repository में permissions का उपयोग करते हुए CI pipeline को manipulate कर के हानिकारक commands execute कराता है। आवश्यक permissions वाले users CI configuration files या pipeline job द्वारा उपयोग की जाने वाली अन्य फाइलों को संशोधित कर सकते हैं ताकि malicious commands शामिल हो जाएँ। यह CI pipeline को "poison" कर देता है, जिससे ये malicious commands execute होते हैं।

एक malicious actor को PPE attack में सफल होने के लिए ये चीज़ें चाहिए होती हैं:

- VCS platform पर **write access** होना चाहिए, क्योंकि सामान्यतः pipelines तब trigger होते हैं जब push या pull request किया जाता है। (Access पाने के तरीकों के सारांश के लिए VCS pentesting methodology देखें).
- ध्यान दें कि कभी-कभी एक **external PR भी "write access"** माना जाता है।
- भले ही उसके पास write permissions हों, उसे यह सुनिश्चित करना होगा कि वह **CI config file या उन फाइलों को modify कर सके जिन पर config निर्भर करता है**।
- इसके लिए उसे संभवतः **branch protections** बायपास करने की आवश्यकता पड़ेगी।

PPE के 3 flavour हैं:

- **D-PPE**: A **Direct PPE** attack तब होता है जब actor उस CI config को सीधे **modify** करता है जिसे execute किया जाना है।
- **I-DDE**: An **Indirect PPE** attack तब होता है जब actor उस **file** को **modify** करता है जिस पर CI config जो execute होने वाली है **rely** करती है (जैसे make file या terraform config)।
- **Public PPE or 3PE**: कुछ मामलों में pipelines उन users द्वारा **trigger** किए जा सकते हैं जिनके पास repo में write access नहीं है (और जो org का हिस्सा भी नहीं हो सकते), क्योंकि वे PR भेज सकते हैं।
- **3PE Command Injection**: आमतौर पर, CI/CD pipelines **PR के बारे में जानकारी** वाले environment variables सेट करते हैं। यदि उस value को एक attacker द्वारा नियंत्रित किया जा सकता है (जैसे PR का title) और वह value किसी **dangerous जगह** (जैसे sh commands execute करना) में **use** होती है, तो attacker वहां **commands inject** कर सकता है।

### Exploitation Benefits

PPE के 3 flavours जानने के बाद, आइए देखें कि successful exploitation के बाद attacker क्या प्राप्त कर सकता है:

- **Secrets**: जैसा कि पहले बताया गया था, pipelines अपने jobs के लिए **privileges** की आवश्यकता रखते हैं (code retrieve करना, build करना, deploy करना...) और ये privileges आमतौर पर **secrets** में दिए जाते हैं। ये secrets आमतौर पर **env variables या system के अंदर files** के माध्यम से पहुँच योग्य होते हैं। इसलिए एक attacker हमेशा अधिक से अधिक secrets exfiltrate करने की कोशिश करेगा।
- pipeline platform पर निर्भर करते हुए attacker **शायद config में secrets specify करने की आवश्यकता** हो सकती है। इसका मतलब है कि यदि attacker CI configuration pipeline को modify नहीं कर सकता (उदा. **I-PPE**), तो वह केवल उन secrets को ही exfiltrate कर सकेगा जो उस pipeline के पास हैं।
- **Computation**: कोड कहीं execute होता है; जहाँ execute होता है वहां attacker आगे pivot कर सकता है।
- **On-Premises**: यदि pipelines on-premises execute होते हैं, तो attacker एक internal network में पहुँच सकता है जहाँ और भी resources उपलब्ध हों।
- **Cloud**: attacker cloud में अन्य machines तक पहुँच सकता है और साथ ही वहाँ से IAM roles/service accounts के tokens exfiltrate कर आगे के cloud access प्राप्त कर सकता है।
- **Platforms machine**: कभी-कभी jobs pipeline platform machines के अंदर execute होते हैं, जो आमतौर पर cloud में होते हैं और जिनके पास और access नहीं होता।
- **Select it:** कभी-कभी pipeline platform ने कई machines configure की होती हैं और यदि आप CI configuration file modify कर सकते हैं तो आप यह **indicate** कर सकते हैं कि आप malicious code कहाँ चलाना चाहते हैं। इस स्थिति में attacker सम्भवत: प्रत्येक संभव machine पर reverse shell चलाएगा ताकि आगे exploit करने की कोशिश कर सके।
- **Compromise production**: यदि आप pipeline के अंदर हैं और final version वहीं से build और deploy होती है, तो आप production में चलने वाले code को compromise कर सकते हैं।

## More relevant info

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) एक open-source tool है जो आपके software supply chain stack का security compliance के लिए audit करता है, जो एक नए [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf) पर आधारित है। auditing पूरे SDLC process पर ध्यान केंद्रित करता है, जहाँ यह code से deploy तक के जोखिमों को उजागर कर सकता है।

### Top 10 CI/CD Security Risk

Cider के अनुसार top 10 CI/CD risks पर यह रोचक article देखें: [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Labs

- प्रत्येक platform के लिए जिसे आप locally चला सकते हैं, वहां आपको इसे locally launch करने का तरीका मिलेगा ताकि आप इसे परीक्षण के लिए अपनी इच्छानुसार configure कर सकें
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Automatic Tools

- [**Checkov**](https://github.com/bridgecrewio/checkov): **Checkov** एक static code analysis tool है infrastructure-as-code के लिए।

## References

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
