# Metodología de Pentesting CI/CD

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS significa **Version Control System**, estos sistemas permiten a los desarrolladores **manage their source code**. El más común es **git** y normalmente encontrarás empresas usándolo en una de las siguientes **plataformas**:

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Cloud providers (they offer their own VCS platforms)


## Pipelines de CI/CD

Los pipelines de CI/CD permiten a los desarrolladores **automatizar la ejecución de code** para diversos fines, incluyendo building, testing y deploying de aplicaciones. Estos workflows automatizados se **disparan por acciones específicas**, como code pushes, pull requests o tareas programadas. Son útiles para agilizar el proceso desde el desarrollo hasta producción.

Sin embargo, estos sistemas necesitan **ejecutarse en algún lugar** y normalmente con **credenciales privilegiadas para deploy code o acceder a información sensible**.

## VCS Pentesting Methodology

> [!NOTE]
> Aunque algunas plataformas VCS permiten crear pipelines, en esta sección vamos a analizar únicamente ataques potenciales al control del source code.

Las plataformas que contienen el source code de tu proyecto contienen información sensible y hay que tener mucho cuidado con los permisos concedidos dentro de la plataforma. Estos son algunos problemas comunes en plataformas VCS que un atacante podría abusar:

- **Leaks**: Si tu code contiene leaks en los commits y el atacante puede acceder al repo (porque es público o porque tiene acceso), podría descubrir los leaks.
- **Access**: Si un atacante puede **access a una cuenta dentro de la plataforma VCS** podría obtener **más visibilidad y permisos**.
- **Register**: Algunas plataformas simplemente permiten a usuarios externos crear una cuenta.
- **SSO**: Algunas plataformas no permiten registro, pero permiten a cualquiera acceder con un SSO válido (así que un atacante podría usar su cuenta de github para entrar, por ejemplo).
- **Credentials**: Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... hay varios tipos de tokens que un usuario podría robar para acceder de alguna manera a un repo.
- **Webhooks**: Las plataformas VCS permiten generar webhooks. Si no están **protegidos** con secrets no visibles, un **attacker could abuse them**.
- If no secret is in place, the attacker could abuse the webhook of the third party platform
- If the secret is in the URL, the same happens and the attacker also have the secret
- **Code compromise:** Si un actor malicioso tiene algún tipo de **write** access sobre los repos, podría intentar **inject malicious code**. Para tener éxito puede necesitar **bypass branch protections**. Estas acciones pueden realizarse con diferentes objetivos en mente:
  - Comprometer la rama main para **compromise production**.
  - Comprometer la main (u otras branches) para **compromise developers machines** (ya que normalmente ejecutan tests, terraform u otras cosas dentro del repo en sus máquinas).
- **Compromise the pipeline** (check next section)

## Pipelines Pentesting Methodology

La forma más común de definir un pipeline es usando un **CI configuration file hosted in the repository** que el pipeline construye. Este archivo describe el orden de los jobs ejecutados, las condiciones que afectan el flujo y la configuración del entorno de build.\
Estos archivos típicamente tienen un nombre y formato consistente, por ejemplo — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI), y los archivos YAML de GitHub Actions ubicados en .github/workflows. Cuando se dispara, el job del pipeline **pulls the code** desde la fuente seleccionada (p. ej. commit / branch), y **ejecuta los comandos especificados en el CI configuration file** contra ese code.

Por tanto, el objetivo último del atacante es de alguna forma **comprometer esos archivos de configuración** o los **comandos que ejecutan**.

> [!TIP]
> Algunos hosted builders permiten a los contributors elegir el Docker build context y la ruta del Dockerfile. Si el context está controlado por el atacante, puedes situarlo fuera del repo (p. ej., "..") para ingerir archivos del host durante el build y exfiltrar secrets. See:
>
>{{#ref}}
>docker-build-context-abuse.md
>{{#endref}}

### PPE - Poisoned Pipeline Execution

La Poisoned Pipeline Execution (PPE) explota permisos en un SCM repository para manipular un CI pipeline y ejecutar comandos dañinos. Usuarios con los permisos necesarios pueden modificar CI configuration files u otros archivos usados por el job del pipeline para incluir comandos maliciosos. Esto "poisons" el CI pipeline, llevando a la ejecución de dichos comandos maliciosos.

Para que un actor malicioso tenga éxito realizando un ataque PPE necesita poder:

- Tener **write access to the VCS platform**, ya que usualmente los pipelines se disparan cuando se hace un push o se crea un pull request. (Revisa la VCS pentesting methodology para un resumen de formas de obtener acceso).
- Nota que a veces un **external PR** cuenta como "write access".
- Incluso si tiene permisos de escritura, necesita asegurarse de que puede **modify the CI config file or other files the config is relying on**.
- Para esto, puede necesitar **bypass branch protections**.

Hay 3 sabores de PPE:

- **D-PPE**: Un ataque **Direct PPE** ocurre cuando el actor **modifica el CI config** file que se va a ejecutar.
- **I-DDE**: Un ataque **Indirect PPE** ocurre cuando el actor **modifica** un **file** del que el CI config file que se va a ejecutar **depends** (como un Makefile o una terraform config).
- **Public PPE or 3PE**: En algunos casos los pipelines pueden ser **triggered by users that don't have write access in the repo** (y que puede que ni siquiera formen parte de la org) porque pueden enviar un PR.
- **3PE Command Injection**: Normalmente, los pipelines establecerán **environment variables** con **información sobre el PR**. Si ese valor puede ser controlado por un atacante (como el título del PR) y es **usado** en un **sitio peligroso** (por ejemplo ejecutando comandos sh), un atacante podría **inject commands into it**.

### Exploitation Benefits

Conociendo los 3 sabores para poison a pipeline, veamos qué podría obtener un atacante tras una explotación exitosa:

- **Secrets**: Como se mencionó anteriormente, los pipelines requieren **privilegios** para sus jobs (recuperar el code, build, deploy...) y estos privilegios suelen ser **almacenados en secrets**. Estos secrets suelen ser accesibles vía **env variables or files inside the system**. Por tanto un atacante siempre intentará exfiltrar tantos secrets como sea posible.
- Dependiendo de la plataforma del pipeline el atacante **podría necesitar especificar los secrets en la config**. Esto significa que si el atacante no puede modificar el CI configuration pipeline (**I-PPE** por ejemplo), solo podría **exfiltrar los secrets que ese pipeline tenga**.
- **Computation**: El code se ejecuta en algún lugar; dependiendo de dónde se ejecute, un atacante podría pivotar más.
- **On-Premises**: Si los pipelines se ejecutan on-premises, un atacante podría acabar en una **internal network con acceso a más recursos**.
- **Cloud**: El atacante podría acceder a **otras máquinas en la cloud** pero también podría **exfiltrar** tokens de IAM roles/service accounts para obtener **más acceso dentro del cloud**.
- **Platforms machine**: A veces los jobs se ejecutan dentro de las máquinas de la **pipelines platform**, que normalmente están en una cloud sin acceso adicional.
- **Select it:** A veces la **pipelines platform** tendrá configuradas varias máquinas y si puedes **modify the CI configuration file** puedes **indicar dónde quieres ejecutar el código malicioso**. En esta situación, un atacante probablemente ejecutará un reverse shell en cada máquina posible para intentar explotarla más.
- **Compromise production**: Si estás dentro del pipeline y la versión final se builda y se deploya desde él, podrías **comprometer el code que terminará ejecutándose en producción**.

## Más información relevante

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) es una herramienta de código abierto para auditar tu software supply chain stack en busca de cumplimiento de seguridad basada en un nuevo [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf). La auditoría se centra en todo el proceso SDLC, donde puede revelar riesgos desde el time of code hasta el deploy.

### Top 10 CI/CD Security Risk

Consulta este artículo interesante sobre los top 10 CI/CD risks según Cider: [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Labs

- En cada plataforma que puedas correr localmente encontrarás cómo lanzarla localmente para que puedas configurarla como quieras y probarla
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Automatic Tools

- [**Checkov**](https://github.com/bridgecrewio/checkov): **Checkov** es una herramienta de análisis estático para infrastructure-as-code.

## Referencias

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
