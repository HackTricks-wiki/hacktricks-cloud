# Méthodologie de Pentesting CI/CD

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/CLOUD-logo-letters.svg" alt=""><figcaption></figcaption></figure>

## VCS

VCS stands for **Version Control System**, ce système permet aux développeurs de **gérer leur source code**. Le plus courant est **git** et vous trouverez généralement des entreprises l'utilisant sur une des **platforms** suivantes :

- Github
- Gitlab
- Bitbucket
- Gitea
- Gitblit
- Cloud providers (they offer their own VCS platforms)


## CI/CD Pipelines

Les pipelines CI/CD permettent aux développeurs d'**automatiser l'exécution du code** pour différents objectifs, notamment la construction, les tests et le déploiement des applications. Ces workflows automatisés sont **déclenchés par des actions spécifiques**, comme des pushes de code, des pull requests ou des tâches planifiées. Ils servent à rationaliser le processus du développement vers la production.

Cependant, ces systèmes doivent être **exécutés quelque part** et généralement avec des **identifiants privilégiés pour déployer le code ou accéder à des informations sensibles**.

## VCS Pentesting Methodology

> [!NOTE]
> Même si certaines plateformes VCS permettent de créer des pipelines, pour cette section nous allons analyser uniquement les attaques potentielles visant le contrôle du source code.

Les platforms qui contiennent le source code de votre projet renferment des informations sensibles et il faut être très prudent avec les permissions accordées sur cette platform. Voici quelques problèmes courants sur les platforms VCS que des attaquants pourraient exploiter :

- **Leaks** : Si votre code contient des leaks dans les commits et que l'attaquant peut accéder au repo (parce qu'il est public ou parce qu'il a accès), il pourrait découvrir ces leaks.
- **Access** : Si un attaquant peut **accéder à un compte sur la platform VCS** il pourrait obtenir **plus de visibilité et de permissions**.
- **Register** : Certaines platforms permettent simplement à des utilisateurs externes de créer un compte.
- **SSO** : Certaines platforms n'autoriseront pas les enregistrements, mais permettront à quiconque d'accéder avec un SSO valide (donc un attaquant pourrait utiliser son compte github pour entrer par exemple).
- **Credentials** : Username+Pwd, personal tokens, ssh keys, Oauth tokens, cookies... il existe plusieurs types de tokens qu'un utilisateur pourrait voler pour accéder d'une manière ou d'une autre à un repo.
- **Webhooks** : Les platforms VCS permettent de générer des webhooks. S'ils ne sont **pas protégés** par des secrets non visibles, un **attaquant pourrait en abuser**.
- Si aucun secret n'est en place, l'attaquant pourrait abuser du webhook de la third party platform
- Si le secret est dans l'URL, il en va de même et l'attaquant possède aussi le secret
- **Compromission du code :** Si un acteur malveillant a un certain type d'**accès en écriture** sur les repos, il pourrait tenter **d'injecter du code malveillant**. Pour réussir, il pourrait devoir **bypasser les branch protections**. Ces actions peuvent être réalisées dans différents objectifs :
  - Compromettre la branche principale pour **compromettre la production**.
  - Compromettre la branche principale (ou d'autres branches) pour **compromettre les machines des développeurs** (car ils exécutent souvent des tests, terraform ou autres choses dans le repo sur leurs machines).
  - **Compromettre le pipeline** (voir section suivante)

## Pipelines Pentesting Methodology

La façon la plus courante de définir un pipeline est d'utiliser un **CI configuration file hébergé dans le repository** que le pipeline construit. Ce fichier décrit l'ordre des jobs exécutés, les conditions qui affectent le flux, et les paramètres de l'environnement de build.\
Ces fichiers ont typiquement un nom et un format constants, par exemple — Jenkinsfile (Jenkins), .gitlab-ci.yml (GitLab), .circleci/config.yml (CircleCI), et les fichiers YAML de GitHub Actions situés sous .github/workflows. Lorsqu'il est déclenché, le job du pipeline **récupère le code** depuis la source sélectionnée (p.ex. commit / branch), et **exécute les commandes spécifiées dans le CI configuration file** contre ce code.

Par conséquent, l'objectif ultime de l'attaquant est d'une manière ou d'une autre de **compromettre ces fichiers de configuration** ou les **commandes qu'ils exécutent**.

### PPE - Poisoned Pipeline Execution

Le chemin Poisoned Pipeline Execution (PPE) exploite les permissions dans un repository SCM pour manipuler un pipeline CI et exécuter des commandes malveillantes. Des utilisateurs disposant des permissions nécessaires peuvent modifier les CI configuration files ou d'autres fichiers utilisés par le job du pipeline pour inclure des commandes malveillantes. Cela "empoisonne" le pipeline CI, conduisant à l'exécution de ces commandes malveillantes.

Pour qu'un acteur malveillant réussisse une attaque PPE, il doit être capable de :

- Avoir **un accès en écriture sur la platform VCS**, car généralement les pipelines sont déclenchés lorsqu'un push ou une pull request est effectué. (Consultez la VCS pentesting methodology pour un résumé des façons d'obtenir cet accès).
- Notez que parfois un **PR externe compte comme un "accès en écriture"**.
- Même s'il a des permissions d'écriture, il doit s'assurer qu'il peut **modifier le CI config file ou d'autres fichiers dont le config dépend**.
- Pour cela, il pourrait devoir **contourner les branch protections**.

Il existe 3 variantes de PPE :

- **D-PPE** : Une attaque **Direct PPE** se produit lorsque l'acteur **modifie le CI config** file qui va être exécuté.
- **I-DDE** : Une attaque **Indirect PPE** se produit lorsque l'acteur **modifie** un **fichier** sur lequel le CI config file qui va être exécuté **s'appuie** (comme un make file ou une configuration terraform).
- **Public PPE or 3PE** : Dans certains cas, les pipelines peuvent être **déclenchés par des utilisateurs qui n'ont pas d'accès en écriture dans le repo** (et qui peuvent ne pas faire partie de l'organisation) parce qu'ils peuvent envoyer un PR.
- **3PE Command Injection** : D'habitude, les pipelines CI/CD vont **définir des variables d'environnement** avec **des informations sur le PR**. Si cette valeur peut être contrôlée par un attaquant (comme le titre du PR) et est **utilisée** dans un **endroit dangereux** (comme l'exécution de **sh commands**), un attaquant pourrait **y injecter des commandes**.

### Exploitation Benefits

Connaissant les 3 variantes pour empoisonner un pipeline, voyons ce qu'un attaquant pourrait obtenir après une exploitation réussie :

- **Secrets** : Comme mentionné précédemment, les pipelines requièrent des **privilèges** pour leurs jobs (récupérer le code, le builder, le déployer...) et ces privilèges sont généralement **fourni via des secrets**. Ces secrets sont habituellement accessibles via des **env variables ou des fichiers dans le système**. Par conséquent, un attaquant tentera toujours d'exfiltrer autant de secrets que possible.
- Selon la plateforme de pipeline, l'attaquant **pourrait devoir spécifier les secrets dans le config**. Cela signifie que si l'attaquant ne peut pas modifier la configuration du pipeline (**I-PPE** par exemple), il pourrait **seulement exfiltrer les secrets dont dispose ce pipeline**.
- **Capacité de calcul** : Le code est exécuté quelque part ; selon l'endroit d'exécution, un attaquant pourrait être capable de pivoter plus loin.
- **Sur site** : Si les pipelines sont exécutés sur site, un attaquant pourrait se retrouver dans un **réseau interne avec accès à plus de ressources**.
- **Cloud** : L'attaquant pourrait accéder **à d'autres machines dans le cloud** mais aussi pourrait **exfiltrer** des tokens d'IAM roles/service accounts **afin d'obtenir un accès additionnel dans le cloud**.
- **Machines de la plateforme** : Parfois les jobs seront exécutés à l'intérieur des machines de la platform pipelines, qui sont généralement dans un cloud sans accès additionnel.
- **Choisir la cible :** Parfois la **platform pipelines** aura configuré plusieurs machines et si vous pouvez **modifier le CI configuration file** vous pouvez **indiquer où vous voulez exécuter le code malveillant**. Dans cette situation, un attaquant exécutera probablement un reverse shell sur chaque machine possible pour tenter de l'exploiter davantage.
- **Compromettre la production** : Si vous êtes à l'intérieur du pipeline et que la version finale est buildée et déployée depuis celui-ci, vous pourriez **compromettre le code qui finira par tourner en production**.

## More relevant info

### Tools & CIS Benchmark

- [**Chain-bench**](https://github.com/aquasecurity/chain-bench) est un outil open-source pour auditer votre stack de software supply chain pour la conformité de sécurité basé sur un nouveau [**CIS Software Supply Chain benchmark**](https://github.com/aquasecurity/chain-bench/blob/main/docs/CIS-Software-Supply-Chain-Security-Guide-v1.0.pdf). L'audit se concentre sur l'ensemble du processus SDLC, où il peut révéler des risques depuis le temps du code jusqu'au temps du déploiement.

### Top 10 CI/CD Security Risk

Consultez cet article intéressant sur les top 10 risques CI/CD selon Cider : [**https://www.cidersecurity.io/top-10-cicd-security-risks/**](https://www.cidersecurity.io/top-10-cicd-security-risks/)

### Labs

- Sur chaque platform que vous pouvez exécuter localement vous trouverez comment le lancer localement afin de le configurer comme vous le souhaitez pour le tester
- Gitea + Jenkins lab: [https://github.com/cider-security-research/cicd-goat](https://github.com/cider-security-research/cicd-goat)

### Automatic Tools

- [**Checkov**](https://github.com/bridgecrewio/checkov) : **Checkov** est un outil d'analyse statique de code pour l'infrastructure-as-code.

## References

- [https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github\&utm_medium=github_page\&utm_campaign=ci%2fcd%20goat_060422](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422)


{{#include ../banners/hacktricks-training.md}}
