# Airflow 配置

{{#include ../../banners/hacktricks-training.md}}

## 配置文件

**Apache Airflow** 在所有 airflow 机器上生成一个名为 **`airflow.cfg`** 的 **配置文件**，该文件位于 airflow 用户的主目录中。此配置文件包含配置信息，并且 **可能包含有趣和敏感的信息。**

**访问此文件有两种方式：通过攻陷某个 airflow 机器，或访问 web 控制台。**

请注意，**配置文件中的值** **可能不是实际使用的值**，因为您可以通过设置环境变量如 `AIRFLOW__WEBSERVER__EXPOSE_CONFIG: 'true'` 来覆盖它们。

如果您可以访问 **web 服务器中的配置文件**，您可以在同一页面上检查 **实际运行的配置**。\
如果您可以访问 **airflow 环境中的某台机器**，请检查 **环境**。

在阅读配置文件时，一些有趣的值：

### \[api]

- **`access_control_allow_headers`**: 这表示 **CORS** 的 **允许** **头部**
- **`access_control_allow_methods`**: 这表示 **CORS** 的 **允许方法**
- **`access_control_allow_origins`**: 这表示 **CORS** 的 **允许来源**
- **`auth_backend`**: [**根据文档**](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html) 可以配置一些选项来控制谁可以访问 API：
- `airflow.api.auth.backend.deny_all`: **默认情况下没有人**可以访问 API
- `airflow.api.auth.backend.default`: **每个人都可以**在没有认证的情况下访问
- `airflow.api.auth.backend.kerberos_auth`: 配置 **kerberos 认证**
- `airflow.api.auth.backend.basic_auth`: 用于 **基本认证**
- `airflow.composer.api.backend.composer_auth`: 使用 composer 认证 (GCP) (来自 [**这里**](https://cloud.google.com/composer/docs/access-airflow-api))。
- `composer_auth_user_registration_role`: 这表示 **composer 用户** 在 **airflow** 中将获得的 **角色**（默认是 **Op**）。
- 您还可以使用 Python **创建您自己的认证** 方法。
- **`google_key_path`:** GCP 服务账户密钥的路径

### **\[atlas]**

- **`password`**: Atlas 密码
- **`username`**: Atlas 用户名

### \[celery]

- **`flower_basic_auth`** : 凭据 (_user1:password1,user2:password2_)
- **`result_backend`**: 可能包含 **凭据** 的 Postgres URL。
- **`ssl_cacert`**: cacert 的路径
- **`ssl_cert`**: 证书的路径
- **`ssl_key`**: 密钥的路径

### \[core]

- **`dag_discovery_safe_mode`**: 默认启用。在发现 DAG 时，忽略任何不包含字符串 `DAG` 和 `airflow` 的文件。
- **`fernet_key`**: 用于存储加密变量的密钥（对称）
- **`hide_sensitive_var_conn_fields`**: 默认启用，隐藏连接的敏感信息。
- **`security`**: 使用哪个安全模块（例如 kerberos）

### \[dask]

- **`tls_ca`**: ca 的路径
- **`tls_cert`**: 证书的路径
- **`tls_key`**: tls 密钥的路径

### \[kerberos]

- **`ccache`**: ccache 文件的路径
- **`forwardable`**: 默认启用

### \[logging]

- **`google_key_path`**: GCP JSON 凭据的路径。

### \[secrets]

- **`backend`**: 要启用的秘密后端的完整类名
- **`backend_kwargs`**: backend_kwargs 参数被加载到字典中并传递给秘密后端类的 **init**。

### \[smtp]

- **`smtp_password`**: SMTP 密码
- **`smtp_user`**: SMTP 用户

### \[webserver]

- **`cookie_samesite`**: 默认是 **Lax**，因此它已经是最弱的可能值
- **`cookie_secure`**: 在会话 cookie 上设置 **安全标志**
- **`expose_config`**: 默认是 False，如果为 true，**配置** 可以从 web **控制台** **读取**
- **`expose_stacktrace`**: 默认是 True，它将显示 **python 回溯**（对攻击者可能有用）
- **`secret_key`**: 这是 **flask 用于签名 cookie 的密钥**（如果您拥有此密钥，您可以 **冒充 Airflow 中的任何用户**）
- **`web_server_ssl_cert`**: **SSL** **证书** 的 **路径**
- **`web_server_ssl_key`**: **SSL** **密钥** 的 **路径**
- **`x_frame_enabled`**: 默认是 **True**，因此默认情况下不可能发生点击劫持

### Web 认证

默认情况下，**web 认证** 在文件 **`webserver_config.py`** 中指定并配置为
```bash
AUTH_TYPE = AUTH_DB
```
这意味着**身份验证是针对数据库进行检查的**。然而，还有其他配置是可能的，例如
```bash
AUTH_TYPE = AUTH_OAUTH
```
将**身份验证留给第三方服务**。

然而，还有一个选项可以**允许匿名用户访问**，将以下参数设置为**所需角色**：
```bash
AUTH_ROLE_PUBLIC = 'Admin'
```
{{#include ../../banners/hacktricks-training.md}}
