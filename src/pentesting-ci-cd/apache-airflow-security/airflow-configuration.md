# Airflow Configuration

{{#include ../../banners/hacktricks-training.md}}

## Configuration File

**Apache Airflow** सभी एयरफ्लो मशीनों में एक **config file** उत्पन्न करता है जिसे **`airflow.cfg`** कहा जाता है, जो एयरफ्लो उपयोगकर्ता के होम में होता है। यह config file कॉन्फ़िगरेशन जानकारी रखती है और **दिलचस्प और संवेदनशील जानकारी हो सकती है।**

**इस फ़ाइल तक पहुँचने के दो तरीके हैं: कुछ एयरफ्लो मशीन को समझौता करके, या वेब कंसोल तक पहुँचकर।**

ध्यान दें कि **config file के अंदर के मान** **वास्तव में उपयोग किए गए नहीं हो सकते**, क्योंकि आप उन्हें `AIRFLOW__WEBSERVER__EXPOSE_CONFIG: 'true'` जैसे env वेरिएबल सेट करके ओवरराइट कर सकते हैं।

यदि आपके पास **वेब सर्वर में config file तक पहुँच है**, तो आप उसी पृष्ठ पर **वास्तविक चल रही कॉन्फ़िगरेशन** की जांच कर सकते हैं जहाँ config प्रदर्शित होता है।\
यदि आपके पास **एयरफ्लो वातावरण के अंदर किसी मशीन तक पहुँच है**, तो **पर्यावरण** की जांच करें।

config file पढ़ते समय जांचने के लिए कुछ दिलचस्प मान:

### \[api]

- **`access_control_allow_headers`**: यह **CORS** के लिए **अनुमत** **हेडर** को इंगित करता है
- **`access_control_allow_methods`**: यह **CORS** के लिए **अनुमत विधियों** को इंगित करता है
- **`access_control_allow_origins`**: यह **CORS** के लिए **अनुमत मूल** को इंगित करता है
- **`auth_backend`**: [**दस्तावेज़ों के अनुसार**](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html) कुछ विकल्प हो सकते हैं यह निर्धारित करने के लिए कि कौन API तक पहुँच सकता है:
- `airflow.api.auth.backend.deny_all`: **डिफ़ॉल्ट रूप से कोई भी** API तक पहुँच नहीं सकता
- `airflow.api.auth.backend.default`: **सभी** बिना प्रमाणीकरण के इसे एक्सेस कर सकते हैं
- `airflow.api.auth.backend.kerberos_auth`: **केरबेरस प्रमाणीकरण** कॉन्फ़िगर करने के लिए
- `airflow.api.auth.backend.basic_auth`: **बुनियादी प्रमाणीकरण** के लिए
- `airflow.composer.api.backend.composer_auth`: कंपोज़र्स प्रमाणीकरण (GCP) का उपयोग करता है ( [**यहां**](https://cloud.google.com/composer/docs/access-airflow-api) से)।
- `composer_auth_user_registration_role`: यह **भूमिका** को इंगित करता है जो **कंपोज़र उपयोगकर्ता** को **एयरफ्लो** के अंदर मिलेगी (**Op** डिफ़ॉल्ट रूप से)।
- आप **पायथन** के साथ अपना खुद का प्रमाणीकरण विधि भी **बना सकते हैं**।
- **`google_key_path`:** **GCP सेवा खाता कुंजी** का पथ

### **\[atlas]**

- **`password`**: एटलस पासवर्ड
- **`username`**: एटलस उपयोगकर्ता नाम

### \[celery]

- **`flower_basic_auth`** : क्रेडेंशियल (_user1:password1,user2:password2_)
- **`result_backend`**: पोस्टग्रेस यूआरएल जिसमें **क्रेडेंशियल** हो सकते हैं।
- **`ssl_cacert`**: कैसर्ट का पथ
- **`ssl_cert`**: प्रमाणपत्र का पथ
- **`ssl_key`**: कुंजी का पथ

### \[core]

- **`dag_discovery_safe_mode`**: डिफ़ॉल्ट रूप से सक्षम। DAGs की खोज करते समय, किसी भी फ़ाइल को अनदेखा करें जिसमें `DAG` और `airflow` स्ट्रिंग्स नहीं हैं।
- **`fernet_key`**: एन्क्रिप्टेड वेरिएबल्स को स्टोर करने के लिए कुंजी (संपूर्ण)
- **`hide_sensitive_var_conn_fields`**: डिफ़ॉल्ट रूप से सक्षम, कनेक्शनों की संवेदनशील जानकारी छिपाएं।
- **`security`**: किस सुरक्षा मॉड्यूल का उपयोग करना है (उदाहरण के लिए केरबेरस)

### \[dask]

- **`tls_ca`**: ca का पथ
- **`tls_cert`**: प्रमाणपत्र का भाग
- **`tls_key`**: tls कुंजी का भाग

### \[kerberos]

- **`ccache`**: ccache फ़ाइल का पथ
- **`forwardable`**: डिफ़ॉल्ट रूप से सक्षम

### \[logging]

- **`google_key_path`**: GCP JSON क्रेड्स का पथ।

### \[secrets]

- **`backend`**: सक्रिय करने के लिए रहस्यों के बैकएंड का पूरा वर्ग नाम
- **`backend_kwargs`**: backend_kwargs पैरामीटर को एक शब्दकोश में लोड किया जाता है और रहस्यों के बैकएंड वर्ग के **init** में पास किया जाता है।

### \[smtp]

- **`smtp_password`**: SMTP पासवर्ड
- **`smtp_user`**: SMTP उपयोगकर्ता

### \[webserver]

- **`cookie_samesite`**: डिफ़ॉल्ट रूप से यह **Lax** है, इसलिए यह पहले से ही सबसे कमजोर संभव मान है
- **`cookie_secure`**: सत्र कुकी पर **सुरक्षित ध्वज** सेट करें
- **`expose_config`**: डिफ़ॉल्ट रूप से False है, यदि सत्य है, तो **config** को वेब **कंसोल** से **पढ़ा** जा सकता है
- **`expose_stacktrace`**: डिफ़ॉल्ट रूप से यह सत्य है, यह **पायथन ट्रेसबैक** दिखाएगा (संभावित रूप से हमलावर के लिए उपयोगी)
- **`secret_key`**: यह **कुंजी है जिसका उपयोग फ्लास्क कुकीज़ पर हस्ताक्षर करने के लिए किया जाता है** (यदि आपके पास यह है तो आप **एयरफ्लो में किसी भी उपयोगकर्ता का अनुकरण कर सकते हैं**)
- **`web_server_ssl_cert`**: **SSL** **प्रमाणपत्र** का **पथ**
- **`web_server_ssl_key`**: **SSL** **कुंजी** का **पथ**
- **`x_frame_enabled`**: डिफ़ॉल्ट **सत्य** है, इसलिए डिफ़ॉल्ट रूप से क्लिकजैकिंग संभव नहीं है

### Web Authentication

डिफ़ॉल्ट रूप से **वेब प्रमाणीकरण** फ़ाइल **`webserver_config.py`** में निर्दिष्ट है और इसे इस प्रकार कॉन्फ़िगर किया गया है
```bash
AUTH_TYPE = AUTH_DB
```
जिसका मतलब है कि **प्रमाणीकरण डेटाबेस के खिलाफ जांचा जाता है**। हालाँकि, अन्य कॉन्फ़िगरेशन संभव हैं जैसे
```bash
AUTH_TYPE = AUTH_OAUTH
```
**तीसरे पक्ष की सेवाओं** को **प्रमाणीकरण** छोड़ने के लिए।

हालांकि, **गुमनाम उपयोगकर्ताओं को पहुंच** की अनुमति देने का एक विकल्प भी है, निम्नलिखित पैरामीटर को **चाहे गए भूमिका** पर सेट करना:
```bash
AUTH_ROLE_PUBLIC = 'Admin'
```
{{#include ../../banners/hacktricks-training.md}}
