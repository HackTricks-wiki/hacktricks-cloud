# Налаштування Airflow

{{#include ../../banners/hacktricks-training.md}}

## Файл конфігурації

**Apache Airflow** генерує **файл конфігурації** на всіх машинах airflow, який називається **`airflow.cfg`** в домашньому каталозі користувача airflow. Цей файл конфігурації містить інформацію про налаштування і **може містити цікаву та чутливу інформацію.**

**Існує два способи доступу до цього файлу: шляхом компрометації деякої машини airflow або доступом до веб-консолі.**

Зверніть увагу, що **значення всередині файлу конфігурації** **можуть не бути тими, що використовуються**, оскільки ви можете перезаписати їх, встановивши змінні середовища, такі як `AIRFLOW__WEBSERVER__EXPOSE_CONFIG: 'true'`.

Якщо у вас є доступ до **файлу конфігурації на веб-сервері**, ви можете перевірити **реальну конфігурацію, що виконується**, на тій же сторінці, де відображається конфігурація.\
Якщо у вас є **доступ до якоїсь машини в середовищі airflow**, перевірте **середовище**.

Деякі цікаві значення для перевірки при читанні файлу конфігурації:

### \[api]

- **`access_control_allow_headers`**: Це вказує на **дозволені** **заголовки** для **CORS**
- **`access_control_allow_methods`**: Це вказує на **дозволені методи** для **CORS**
- **`access_control_allow_origins`**: Це вказує на **дозволені джерела** для **CORS**
- **`auth_backend`**: [**Згідно з документацією**](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html) кілька варіантів можуть бути використані для налаштування, хто може отримати доступ до API:
- `airflow.api.auth.backend.deny_all`: **За замовчуванням ніхто** не може отримати доступ до API
- `airflow.api.auth.backend.default`: **Усі можуть** отримати доступ без аутентифікації
- `airflow.api.auth.backend.kerberos_auth`: Для налаштування **аутентифікації kerberos**
- `airflow.api.auth.backend.basic_auth`: Для **базової аутентифікації**
- `airflow.composer.api.backend.composer_auth`: Використовує аутентифікацію композиторів (GCP) (з [**тут**](https://cloud.google.com/composer/docs/access-airflow-api)).
- `composer_auth_user_registration_role`: Це вказує на **роль**, яку **користувач композиторів** отримає в **airflow** (**Op** за замовчуванням).
- Ви також можете **створити свій власний метод аутентифікації** за допомогою python.
- **`google_key_path`:** Шлях до **ключа облікового запису служби GCP**

### **\[atlas]**

- **`password`**: Пароль Atlas
- **`username`**: Ім'я користувача Atlas

### \[celery]

- **`flower_basic_auth`** : Облікові дані (_user1:password1,user2:password2_)
- **`result_backend`**: URL Postgres, який може містити **облікові дані**.
- **`ssl_cacert`**: Шлях до cacert
- **`ssl_cert`**: Шлях до сертифіката
- **`ssl_key`**: Шлях до ключа

### \[core]

- **`dag_discovery_safe_mode`**: Увімкнено за замовчуванням. При виявленні DAG ігноруйте будь-які файли, які не містять рядків `DAG` та `airflow`.
- **`fernet_key`**: Ключ для зберігання зашифрованих змінних (симетричний)
- **`hide_sensitive_var_conn_fields`**: Увімкнено за замовчуванням, приховує чутливу інформацію про з'єднання.
- **`security`**: Який модуль безпеки використовувати (наприклад, kerberos)

### \[dask]

- **`tls_ca`**: Шлях до ca
- **`tls_cert`**: Шлях до сертифіката
- **`tls_key`**: Шлях до tls ключа

### \[kerberos]

- **`ccache`**: Шлях до файлу ccache
- **`forwardable`**: Увімкнено за замовчуванням

### \[logging]

- **`google_key_path`**: Шлях до GCP JSON облікових даних.

### \[secrets]

- **`backend`**: Повна назва класу бекенду секретів для активації
- **`backend_kwargs`**: Параметр backend_kwargs завантажується в словник і передається в **init** класу бекенду секретів.

### \[smtp]

- **`smtp_password`**: Пароль SMTP
- **`smtp_user`**: Користувач SMTP

### \[webserver]

- **`cookie_samesite`**: За замовчуванням це **Lax**, тому це вже найслабше можливе значення
- **`cookie_secure`**: Встановіть **прапор безпеки** на сесійне cookie
- **`expose_config`**: За замовчуванням False, якщо true, **конфігурацію** можна **читати** з веб **консолі**
- **`expose_stacktrace`**: За замовчуванням це True, це покаже **python tracebacks** (можливо, корисно для зловмисника)
- **`secret_key`**: Це **ключ, який використовується flask для підпису cookie** (якщо у вас є це, ви можете **видавати себе за будь-якого користувача в Airflow**)
- **`web_server_ssl_cert`**: **Шлях** до **SSL** **сертифіката**
- **`web_server_ssl_key`**: **Шлях** до **SSL** **ключа**
- **`x_frame_enabled`**: За замовчуванням **True**, тому за замовчуванням клікджекинг неможливий

### Веб-аутентифікація

За замовчуванням **веб-аутентифікація** вказується у файлі **`webserver_config.py`** і налаштовується як
```bash
AUTH_TYPE = AUTH_DB
```
Що означає, що **автентифікація перевіряється проти бази даних**. Однак можливі й інші конфігурації, такі як
```bash
AUTH_TYPE = AUTH_OAUTH
```
Щоб залишити **автентифікацію стороннім сервісам**.

Однак також є можливість **дозволити доступ анонімним користувачам**, встановивши наступний параметр на **бажану роль**:
```bash
AUTH_ROLE_PUBLIC = 'Admin'
```
{{#include ../../banners/hacktricks-training.md}}
