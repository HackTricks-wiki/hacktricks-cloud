# Konfiguracja Airflow

{{#include ../../banners/hacktricks-training.md}}

## Plik konfiguracyjny

**Apache Airflow** generuje **plik konfiguracyjny** na wszystkich maszynach airflow o nazwie **`airflow.cfg`** w katalogu domowym użytkownika airflow. Ten plik konfiguracyjny zawiera informacje konfiguracyjne i **może zawierać interesujące i wrażliwe informacje.**

**Są dwa sposoby na dostęp do tego pliku: Poprzez skompromitowanie maszyny airflow lub dostęp do konsoli internetowej.**

Zauważ, że **wartości w pliku konfiguracyjnym** **mogą nie być tymi używanymi**, ponieważ możesz je nadpisać, ustawiając zmienne środowiskowe, takie jak `AIRFLOW__WEBSERVER__EXPOSE_CONFIG: 'true'`.

Jeśli masz dostęp do **pliku konfiguracyjnego na serwerze internetowym**, możesz sprawdzić **rzeczywistą konfigurację uruchomioną** na tej samej stronie, na której wyświetlany jest plik konfiguracyjny.\
Jeśli masz **dostęp do jakiejś maszyny w środowisku airflow**, sprawdź **środowisko**.

Niektóre interesujące wartości do sprawdzenia podczas przeglądania pliku konfiguracyjnego:

### \[api]

- **`access_control_allow_headers`**: To wskazuje **dozwolone** **nagłówki** dla **CORS**
- **`access_control_allow_methods`**: To wskazuje **dozwolone metody** dla **CORS**
- **`access_control_allow_origins`**: To wskazuje **dozwolone źródła** dla **CORS**
- **`auth_backend`**: [**Zgodnie z dokumentacją**](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html) kilka opcji może być użytych do skonfigurowania, kto może uzyskać dostęp do API:
- `airflow.api.auth.backend.deny_all`: **Domyślnie nikt** nie może uzyskać dostępu do API
- `airflow.api.auth.backend.default`: **Każdy może** uzyskać do niego dostęp bez uwierzytelnienia
- `airflow.api.auth.backend.kerberos_auth`: Aby skonfigurować **uwierzytelnianie kerberos**
- `airflow.api.auth.backend.basic_auth`: Dla **podstawowego uwierzytelniania**
- `airflow.composer.api.backend.composer_auth`: Używa uwierzytelniania kompozytora (GCP) (z [**tutaj**](https://cloud.google.com/composer/docs/access-airflow-api)).
- `composer_auth_user_registration_role`: To wskazuje **rolę**, jaką **użytkownik kompozytora** otrzyma w **airflow** (**Op** domyślnie).
- Możesz również **stworzyć własną metodę uwierzytelniania** w pythonie.
- **`google_key_path`:** Ścieżka do **klucza konta usługi GCP**

### **\[atlas]**

- **`password`**: Hasło Atlas
- **`username`**: Nazwa użytkownika Atlas

### \[celery]

- **`flower_basic_auth`** : Poświadczenia (_user1:password1,user2:password2_)
- **`result_backend`**: URL Postgres, który może zawierać **poświadczenia**.
- **`ssl_cacert`**: Ścieżka do cacert
- **`ssl_cert`**: Ścieżka do certyfikatu
- **`ssl_key`**: Ścieżka do klucza

### \[core]

- **`dag_discovery_safe_mode`**: Włączone domyślnie. Podczas odkrywania DAG-ów, ignoruj wszelkie pliki, które nie zawierają ciągów `DAG` i `airflow`.
- **`fernet_key`**: Klucz do przechowywania zaszyfrowanych zmiennych (symetryczny)
- **`hide_sensitive_var_conn_fields`**: Włączone domyślnie, ukrywa wrażliwe informacje o połączeniach.
- **`security`**: Jaki moduł zabezpieczeń użyć (na przykład kerberos)

### \[dask]

- **`tls_ca`**: Ścieżka do ca
- **`tls_cert`**: Ścieżka do certyfikatu
- **`tls_key`**: Ścieżka do klucza tls

### \[kerberos]

- **`ccache`**: Ścieżka do pliku ccache
- **`forwardable`**: Włączone domyślnie

### \[logging]

- **`google_key_path`**: Ścieżka do poświadczeń JSON GCP.

### \[secrets]

- **`backend`**: Pełna nazwa klasy backendu sekretów do włączenia
- **`backend_kwargs`**: Parametr backend_kwargs jest ładowany do słownika i przekazywany do **init** klasy backendu sekretów.

### \[smtp]

- **`smtp_password`**: Hasło SMTP
- **`smtp_user`**: Użytkownik SMTP

### \[webserver]

- **`cookie_samesite`**: Domyślnie to **Lax**, więc to już najsłabsza możliwa wartość
- **`cookie_secure`**: Ustaw **flaga zabezpieczeń** na ciasteczku sesyjnym
- **`expose_config`**: Domyślnie jest False, jeśli prawda, **konfiguracja** może być **odczytana** z **konsoli** internetowej
- **`expose_stacktrace`**: Domyślnie jest True, wyświetli **ślad stosu Pythona** (potencjalnie przydatne dla atakującego)
- **`secret_key`**: To jest **klucz używany przez flask do podpisywania ciasteczek** (jeśli to masz, możesz **podszyć się pod dowolnego użytkownika w Airflow**)
- **`web_server_ssl_cert`**: **Ścieżka** do **certyfikatu** **SSL**
- **`web_server_ssl_key`**: **Ścieżka** do **klucza** **SSL**
- **`x_frame_enabled`**: Domyślnie jest **True**, więc domyślnie clickjacking nie jest możliwy

### Uwierzytelnianie w sieci

Domyślnie **uwierzytelnianie w sieci** jest określone w pliku **`webserver_config.py`** i jest skonfigurowane jako
```bash
AUTH_TYPE = AUTH_DB
```
Co oznacza, że **uwierzytelnienie jest sprawdzane w bazie danych**. Jednak możliwe są inne konfiguracje, takie jak
```bash
AUTH_TYPE = AUTH_OAUTH
```
Aby pozostawić **uwierzytelnianie usługom zewnętrznym**.

Jednak istnieje również opcja **zezwolenia na dostęp anonimowym użytkownikom**, ustawiając następujący parametr na **pożądaną rolę**:
```bash
AUTH_ROLE_PUBLIC = 'Admin'
```
{{#include ../../banners/hacktricks-training.md}}
