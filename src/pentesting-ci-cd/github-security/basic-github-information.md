# Grundlegende Github-Informationen

{{#include ../../banners/hacktricks-training.md}}

## Grundstruktur

Die grundlegende Github-Umgebungsstruktur eines großen **Unternehmens** ist, ein **Enterprise** zu besitzen, das **mehrere Organisationen** besitzt, und jede davon kann **mehrere Repositories** und **mehrere Teams** enthalten. Kleinere Unternehmen besitzen möglicherweise nur **eine Organisation und kein Enterprise**.

Aus Sicht eines Benutzers kann ein **User** **Mitglied** von **verschiedenen Enterprises und Organisationen** sein. Innerhalb dieser kann der Benutzer **verschiedene Enterprise-, Organisations- und Repository-Rollen** haben.

Außerdem kann ein Benutzer **Teil verschiedener Teams** mit unterschiedlichen Enterprise-, Organisations- oder Repository-Rollen sein.

Und schließlich **können Repositories spezielle Schutzmechanismen** haben.

## Privilegien

### Enterprise-Rollen

- **Enterprise owner**: Personen mit dieser Rolle können **Administratoren verwalten, Organisationen innerhalb des Enterprise verwalten, Enterprise-Einstellungen verwalten, Richtlinien über Organisationen hinweg durchsetzen**. Sie **können jedoch nicht auf Organisationseinstellungen oder -inhalte zugreifen**, es sei denn, sie werden zu Organization owners ernannt oder erhalten direkten Zugriff auf ein repository, das einer Organisation gehört.
- **Enterprise members**: Mitglieder von Organisationen, die von deinem Enterprise besessen werden, sind **automatisch ebenfalls Mitglieder des Enterprise**.

### Organisationsrollen

In einer Organisation können Benutzer verschiedene Rollen haben:

- **Organization owners**: Organization owners haben **vollständigen administrativen Zugriff auf deine Organisation**. Diese Rolle sollte begrenzt werden, jedoch nicht auf weniger als zwei Personen in deiner Organisation.
- **Organization members**: Die **Standard-**, nicht-administrative Rolle für **Personen in einer Organisation** ist das Organization member. Standardmäßig **haben Organization members eine Reihe von Berechtigungen**.
- **Billing managers**: Billing managers sind Benutzer, die **die Abrechnungseinstellungen deiner Organisation verwalten** können, z. B. Zahlungsinformationen.
- **Security Managers**: Es ist eine Rolle, die Organization owners einem beliebigen Team in einer Organisation zuweisen können. Wenn sie angewendet wird, erhalten alle Mitglieder des Teams Berechtigungen, **Security alerts und Einstellungen über deine Organisation hinweg zu verwalten sowie Lesezugriff auf alle Repositories** in der Organisation.
- Wenn deine Organisation ein Sicherheitsteam hat, kannst du die Security Manager-Rolle verwenden, um Mitgliedern des Teams den minimal erforderlichen Zugriff auf die Organisation zu gewähren.
- **Github App managers**: Um zusätzlichen Benutzern zu erlauben, **GitHub Apps zu verwalten, die einer Organisation gehören**, kann ein Owner ihnen Github App manager-Berechtigungen gewähren.
- **Outside collaborators**: Ein outside collaborator ist eine Person, die **Zugriff auf ein oder mehrere Organisation-Repositories hat, aber nicht explizit Mitglied der Organisation** ist.

Du kannst die **Berechtigungen** dieser Rollen in dieser Tabelle vergleichen: [https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization#permissions-for-organization-roles](https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization#permissions-for-organization-roles)

### Mitglieder-Berechtigungen

In _https://github.com/organizations/\<org_name>/settings/member_privileges_ kannst du die **Berechtigungen sehen, die Benutzer allein durch die Zugehörigkeit zur Organisation erhalten**.

Die hier konfigurierten Einstellungen geben folgende Rechte der Mitglieder der Organisation an:

- Admin-, Schreib-, Lese- oder keine Berechtigung für alle Repositories der Organisation.
- Ob Mitglieder private, interne oder öffentliche Repositories erstellen können.
- Ob Forking von Repositories möglich ist.
- Ob es möglich ist, outside collaborators einzuladen.
- Ob öffentliche oder private Sites veröffentlicht werden können.
- Die Berechtigungen, die Admins über die Repositories haben.
- Ob Mitglieder neue Teams erstellen können.

### Repository-Rollen

Standardmäßig sind folgende repository-Rollen vorhanden:

- **Read**: Empfohlen für **Nicht-Code-Beitragende**, die dein Projekt ansehen oder diskutieren möchten.
- **Triage**: Empfohlen für **Beitragende, die Issues und Pull Requests proaktiv verwalten müssen**, ohne Schreibzugriff.
- **Write**: Empfohlen für Beitragende, die **aktiv in dein Projekt pushen**.
- **Maintain**: Empfohlen für **Projektmanager, die das Repository verwalten müssen**, ohne Zugriff auf sensible oder zerstörerische Aktionen.
- **Admin**: Empfohlen für Personen, die **vollen Zugriff auf das Projekt benötigen**, einschließlich sensibler und zerstörerischer Aktionen wie Security-Management oder das Löschen eines Repositories.

Du kannst die **Berechtigungen** jeder Rolle in dieser Tabelle vergleichen: [https://docs.github.com/en/organizations/managing-access-to-your-organizations-repositories/repository-roles-for-an-organization#permissions-for-each-role](https://docs.github.com/en/organizations/managing-access-to-your-organizations-repositories/repository-roles-for-an-organization#permissions-for-each-role)

Du kannst auch **eigene Rollen erstellen** in _https://github.com/organizations/\<org_name>/settings/roles_

### Teams

Du kannst die in einer Organisation erstellten Teams unter _https://github.com/orgs/\<org_name>/teams_ **auflisten**. Beachte, dass du, um die Teams zu sehen, die Kinder anderer Teams sind, jedes übergeordnete Team aufrufen musst.

### Benutzer

Die Benutzer einer Organisation können unter _https://github.com/orgs/\<org_name>/people_ **aufgelistet** werden.

In den Informationen jedes Benutzers kannst du die **Teams, denen der Benutzer angehört**, und die **Repos, auf die der Benutzer Zugriff hat**, sehen.

## Github Authentication

Github bietet verschiedene Möglichkeiten, sich bei deinem Konto zu authentifizieren und Aktionen in deinem Auftrag auszuführen.

### Webzugang

Beim Zugriff auf **github.com** kannst du dich mit deinem **Benutzernamen und Passwort** (und ggf. einer **2FA**) anmelden.

### **SSH Keys**

Du kannst dein Konto mit einem oder mehreren Public Keys konfigurieren, die es dem zugehörigen **Private Key ermöglichen, Aktionen in deinem Auftrag auszuführen.** [https://github.com/settings/keys](https://github.com/settings/keys)

#### **GPG Keys**

Du **kannst den Benutzer mit diesen Keys nicht imitieren**, aber wenn du ihn nicht verwendest, könnte es möglich sein, dass du **entdeckt wirst, weil Commits ohne Signatur gesendet wurden**. Erfahre mehr über den [vigilant mode hier](https://docs.github.com/en/authentication/managing-commit-signature-verification/displaying-verification-statuses-for-all-of-your-commits#about-vigilant-mode).

### **Personal Access Tokens**

Du kannst Personal Access Tokens generieren, um **einer Anwendung Zugriff auf dein Konto zu geben**. Beim Erstellen eines Personal Access Tokens muss der **Benutzer** die **Berechtigungen** festlegen, die das **Token** erhalten soll. [https://github.com/settings/tokens](https://github.com/settings/tokens)

### Oauth Applications

Oauth-Anwendungen können dich um Berechtigungen bitten, **auf Teile deiner github-Informationen zuzugreifen oder dich zu impersonifizieren**, um bestimmte Aktionen auszuführen. Ein häufiges Beispiel dafür ist der **Login with GitHub-Button**, den du auf manchen Plattformen findest.

- Du kannst eigene **Oauth applications** erstellen unter [https://github.com/settings/developers](https://github.com/settings/developers)
- Du kannst alle **Oauth applications sehen, die Zugriff auf dein Konto haben** unter [https://github.com/settings/applications](https://github.com/settings/applications)
- Du kannst die **Scopes sehen, die Oauth Apps anfordern können** unter [https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps)
- Du kannst Third-Party-Zugriffe von Anwendungen in einer **Organisation** unter _https://github.com/organizations/\<org_name>/settings/oauth_application_policy_ ansehen

Einige **Sicherheitsempfehlungen**:

- Eine **OAuth App** sollte immer **als der authentifizierte GitHub-Benutzer über ganz GitHub handeln** (z. B. beim Bereitstellen von Benutzerbenachrichtigungen) und nur Zugriff auf die angegebenen Scopes haben.
- Eine OAuth App kann als Identitätsprovider verwendet werden, indem sie ein "Login with GitHub" für den authentifizierten Benutzer ermöglicht.
- **Baue keine OAuth App**, wenn deine Anwendung **nur für ein einzelnes Repository** handeln soll. Mit dem `repo` OAuth-Scope können OAuth Apps **auf _alle_ Repositories des authentifizierten Benutzers** zugreifen.
- **Baue keine OAuth App**, um als Anwendung für dein **Team oder Unternehmen** zu agieren. OAuth Apps authentifizieren als **einzelner Benutzer**. Wenn also eine Person eine OAuth App für das Unternehmen erstellt und das Unternehmen später verlässt, hat niemand sonst Zugriff darauf.
- **Mehr** dazu [hier](https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps#about-oauth-apps).

### Github Applications

Github-Anwendungen können Berechtigungen anfragen, um **auf deine github-Informationen zuzugreifen oder dich zu impersonifizieren**, um spezifische Aktionen auf bestimmten Ressourcen auszuführen. Bei Github Apps musst du die Repositories angeben, auf die die App Zugriff haben wird.

- Um eine GitHub App zu installieren, musst du **Organization owner sein oder Admin-Rechte** in einem Repository haben.
- Die GitHub App sollte **mit einem persönlichen Konto oder einer Organisation verbunden** sein.
- Du kannst deine eigene Github application erstellen unter [https://github.com/settings/apps](https://github.com/settings/apps)
- Du kannst alle **Github applications sehen, die Zugriff auf dein Konto haben** unter [https://github.com/settings/apps/authorizations](https://github.com/settings/apps/authorizations)
- Dies sind die **API-Endpunkte für Github Applications** [https://docs.github.com/en/rest/overview/endpoints-available-for-github-app](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps). Abhängig von den Berechtigungen der App kann sie einige dieser Endpunkte aufrufen.
- Du kannst installierte Apps in einer **Organisation** unter _https://github.com/organizations/\<org_name>/settings/installations_ sehen.

Einige Sicherheitsempfehlungen:

- Eine GitHub App sollte **handeln können, ohne von einem Benutzer abhängig zu sein** (es sei denn, die App verwendet ein [user-to-server](https://docs.github.com/en/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)-Token). Um user-to-server-Zugriffstokens sicherer zu machen, kannst du Zugriffstokens verwenden, die nach 8 Stunden ablaufen, und ein Refresh-Token, das gegen ein neues Zugriffstoken eingetauscht werden kann. Weitere Informationen siehe "[Refreshing user-to-server access tokens](https://docs.github.com/en/apps/building-github-apps/refreshing-user-to-server-access-tokens)."
- Stelle sicher, dass die GitHub App mit **spezifischen Repositories** integriert ist.
- Die GitHub App sollte **mit einem persönlichen Konto oder einer Organisation verbunden** sein.
- Erwarte nicht, dass die GitHub App alles kennt und tut, was ein Benutzer kann.
- **Verwende keine GitHub App**, wenn du nur einen "Login with GitHub"-Dienst brauchst. Eine GitHub App kann jedoch einen [user identification flow](https://docs.github.com/en/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps) verwenden, um Benutzer anzumelden _und_ andere Dinge zu tun.
- Baue keine GitHub App, wenn du _nur_ als ein GitHub-Benutzer agieren und alles tun möchtest, was dieser Benutzer kann.
- Wenn du deine App mit Github Actions verwendest und Workflow-Dateien ändern möchtest, musst du im Namen des Benutzers mit einem OAuth-Token authentifizieren, das den `workflow`-Scope enthält. Der Benutzer muss Admin- oder Schreibberechtigung für das Repository haben, das die Workflow-Datei enthält. Weitere Informationen siehe "[Understanding scopes for OAuth apps](https://docs.github.com/en/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/#available-scopes)."
- **Mehr** dazu [hier](https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps#about-github-apps).

### Github Actions

Dies **ist kein Authentifizierungsweg in github**, aber eine **malicious** Github Action könnte **unautorisierte Zugriffe auf github** erhalten und je nach den der Action gewährten **Privilegien** könnten verschiedene **Angriffe** möglich sein. Siehe unten für mehr Informationen.

## Git Actions

Git Actions ermöglichen die Automatisierung der **Ausführung von Code, wenn ein Event eintritt**. Üblicherweise bezieht sich der ausgeführte Code **auf den Code des Repositories** (z. B. zum Erstellen eines Docker-Containers oder um zu prüfen, dass ein PR keine Secrets enthält).

### Konfiguration

Unter _https://github.com/organizations/\<org_name>/settings/actions_ ist es möglich, die **Konfiguration der github actions** für die Organisation zu überprüfen.

Es ist möglich, die Nutzung von github actions komplett zu verbieten, **alle github actions zu erlauben** oder nur bestimmte Actions zuzulassen.

Es ist außerdem möglich zu konfigurieren, **wer die Ausführung einer Github Action genehmigen muss** und die **Berechtigungen des GITHUB_TOKEN**, wenn eine Github Action ausgeführt wird.

### Git Secrets

Github Actions benötigen normalerweise eine Art Secrets, um mit github oder Drittanbieter-Anwendungen zu interagieren. Um zu vermeiden, dass diese im Klartext im Repo stehen, erlaubt github, sie als **Secrets** zu speichern.

Diese Secrets können **für das Repo oder für die gesamte Organisation** konfiguriert werden. Damit die **Action auf das Secret zugreifen** kann, musst du es wie folgt deklarieren:
```yaml
steps:
- name: Hello world action
with: # Set the secret as an input
super_secret:${{ secrets.SuperSecret }}
env: # Or as an environment variable
super_secret:${{ secrets.SuperSecret }}
```
#### Beispiel: Bash verwenden <a href="#example-using-bash" id="example-using-bash"></a>
```yaml
steps:
- shell: bash
env: SUPER_SECRET:${{ secrets.SuperSecret }}
run: |
example-command "$SUPER_SECRET"
```
> [!WARNING]
> Secrets **können nur von den Github Actions** abgerufen werden, in denen sie deklariert sind.
>
> Sobald sie im repo oder in den organizations konfiguriert sind, **werden users of github nicht mehr in der Lage sein, darauf zuzugreifen**, sie können sie nur **ändern**.
>
> Daher ist der **einzige Weg, github secrets zu stehlen, Zugriff auf die Maschine zu bekommen, die die Github Action ausführt** (in diesem Szenario kannst du nur auf die secrets zugreifen, die für die Action deklariert sind).
>
> ### Git Environments
>
> Github erlaubt das Erstellen von **environments**, in denen du **secrets** speichern kannst. Dann kannst du der github action Zugriff auf die secrets innerhalb der environment geben, mit etwas wie:
```yaml
jobs:
deployment:
runs-on: ubuntu-latest
environment: env_name
```
Du kannst eine Environment so konfigurieren, dass sie von **allen Branches** (Standard), **nur geschützten** Branches oder **bestimmten** Branches zugänglich ist.\
Zusätzlich beinhalten Environment‑Schutzmaßnahmen:
- **Required reviewers**: halten Gate‑Jobs, die auf die Environment zielen, zurück, bis sie genehmigt sind. Aktiviere **Prevent self-review**, um das Vier‑Augen‑Prinzip auch bei der Genehmigung selbst durchzusetzen.
- **Deployment branches and tags**: beschränke, welche Branches/Tags in die Environment deployen dürfen. Wähle nach Möglichkeit spezifische Branches/Tags und stelle sicher, dass diese Branches geschützt sind. Hinweis: Die Option "Protected branches only" gilt für klassische Branch‑Protections und verhält sich unter Rulesets möglicherweise nicht wie erwartet.
- **Wait timer**: verzögere Deployments für einen konfigurierbaren Zeitraum.

Man kann außerdem eine **Anzahl erforderlicher Reviews** festlegen, bevor eine **Action** eine **Environment** verwendet oder eine **Wartezeit** konfigurieren, bevor Deployments zugelassen werden.
### Git Action Runner

Eine Github Action kann entweder **innerhalb der Github‑Environment** ausgeführt werden oder in einer **externen Infrastruktur** laufen, die vom Nutzer konfiguriert wurde.

Einige Organisationen erlauben es, Github Actions in einer **third party infrastructure** auszuführen, da dies oft **günstiger** ist.

Du kannst die self-hosted runners einer Organisation unter _https://github.com/organizations/\<org_name>/settings/actions/runners_ auflisten.

Um herauszufinden, welche **Github Actions in non-github infrastructure** ausgeführt werden, suche in den Github Action‑Konfigurations‑YAMLs nach `runs-on: self-hosted`.

Es ist **nicht möglich**, eine Github Action einer Organisation innerhalb einer self-hosted Box einer anderen Organisation laufen zu lassen, weil **ein eindeutiger Token für den Runner** generiert wird, wenn dieser konfiguriert wird, damit er weiß, zu welcher Organisation der Runner gehört.

Wenn der eigene **Github Runner auf einer Maschine in AWS oder GCP** konfiguriert ist, könnte die Action **Zugriff auf den metadata endpoint** haben und **das Token des service account** stehlen, unter dem die Maschine läuft.

### Git Action Compromise

Wenn alle Actions (oder eine bösartige Action) erlaubt sind, könnte ein Benutzer eine **bösartige Github Action** nutzen, die den **Container**, in dem sie ausgeführt wird, kompromittiert.

> [!CAUTION]
> Ein **bösartiger Github Action**‑Lauf könnte vom Angreifer dazu missbraucht werden:
>
> - **Alle Secrets stehlen**, auf die die Action Zugriff hat
> - **Lateral movement** betreiben, wenn die Action in einer **third party infrastructure** ausgeführt wird und das SA token der Maschine über den metadata service zugänglich ist
> - **Das Token missbrauchen**, das vom **workflow** verwendet wird, um **den Code des Repos** zu stehlen, in dem die Action läuft, oder ihn sogar **zu ändern**.

## Branch Protections

Branch‑Protections sind so konzipiert, dass sie den Nutzern **nicht die vollständige Kontrolle über ein Repository** geben. Ziel ist es, **mehrere Schutzmechanismen zu implementieren, bevor Code in einen Branch geschrieben werden kann**.

Die **Branch‑Protections eines Repos** findest du unter _https://github.com/\<orgname>/\<reponame>/settings/branches_.

> [!NOTE]
> Es ist **nicht möglich, eine Branch‑Protection auf Organisationsebene** zu setzen. Daher müssen sie in jedem Repo separat definiert werden.

Verschiedene Schutzmechanismen können auf einen Branch (z. B. master) angewendet werden:

- Du kannst **einen PR vor dem Merge verlangen** (d.h. du kannst nicht direkt in den Branch mergen). Wenn dies aktiviert ist, können weitere Schutzmechanismen gelten:
- **Eine Anzahl von Approvals verlangen.** Häufig verlangt man 1 oder 2 weitere Personen zur Genehmigung des PR, damit ein einzelner Nutzer nicht direkt mergen kann.
- **Approvals beim Push neuer Commits verwerfen.** Andernfalls könnte ein Nutzer legitimen Code genehmigen, danach schädlichen Code hinzufügen und mergen.
- **Approval für den neuesten reviewbaren Push verlangen.** Stellt sicher, dass neue Commits nach einer Genehmigung (einschließlich Pushes durch andere Kollaborateure) eine erneute Review auslösen, sodass ein Angreifer keine nachträglichen Änderungen nach der Genehmigung pushen und mergen kann.
- **Reviews von Code Owners verlangen.** Mindestens ein Code Owner des Repos muss den PR genehmigen (sodass „zufällige“ Nutzer nicht genehmigen können).
- **Einschränken, wer Pull‑Request‑Reviews verwerfen darf.** Du kannst Personen oder Teams angeben, die Pull‑Request‑Reviews verwerfen dürfen.
- **Bestimmten Akteuren erlauben, Pull‑Request‑Anforderungen zu umgehen.** Diese Nutzer können die vorherigen Einschränkungen umgehen.
- **Status Checks bestehen lassen, bevor gemerged wird.** Bestimmte Checks müssen bestanden werden, bevor der Commit gemerged werden kann (z. B. ein GitHub App‑Bericht mit SAST‑Ergebnissen). Tipp: binde erforderliche Checks an eine bestimmte GitHub App; ansonsten könnte jede App den Check über die Checks API fälschen, und viele Bots akzeptieren Skip‑Direktiven (z. B. „@bot-name skip“).
- **Konversationen vor dem Merge aufgelöst haben.** Alle Kommentare am Code müssen vor dem Merge des PR gelöst sein.
- **Signierte Commits verlangen.** Die Commits müssen signiert sein.
- **Linear history verlangen.** Verhindert, dass Merge‑Commits in passende Branches gepusht werden.
- **Administrators einschließen.** Wenn dies nicht gesetzt ist, können Admins die Einschränkungen umgehen.
- **Einschränken, wer in passende Branches pushen darf.** Beschränkt, wer einen PR senden darf.

> [!NOTE]
> Wie du siehst: Selbst wenn du Anmeldeinformationen eines Nutzers erlangst, können **Repos geschützt sein und verhindern, dass du z. B. Code direkt in master pushst**, um die CI/CD‑Pipeline zu kompromittieren.

## Tag Protections

Tags (z. B. latest, stable) sind standardmäßig veränderbar. Um ein Vier‑Augen‑Prinzip bei Tag‑Updates durchzusetzen, schütze Tags und verknüpfe Schutzmaßnahmen über Environments und Branches:

1) Aktiviere in der Tag‑Protection‑Regel **Require deployments to succeed** und fordere ein erfolgreiches Deployment in eine geschützte Environment (z. B. prod).
2) In der Ziel‑Environment beschränke **Deployment branches and tags** auf den Release‑Branch (z. B. main) und konfiguriere optional **Required reviewers** mit **Prevent self-review**.
3) Auf dem Release‑Branch konfiguriere Branch‑Protections so, dass sie **Require a pull request** verlangen, setze Approvals ≥ 1 und aktiviere sowohl **Dismiss approvals when new commits are pushed** als auch **Require approval of the most recent reviewable push**.

Diese Kette verhindert, dass ein einzelner Kollaborateur Releases neu taggt oder force‑published, indem er die workflow YAML bearbeitet, da Deployment‑Gates außerhalb der Workflows durchgesetzt werden.

## References

- [https://docs.github.com/en/organizations/managing-access-to-your-organizations-repositories/repository-roles-for-an-organization](https://docs.github.com/en/organizations/managing-access-to-your-organizations-repositories/repository-roles-for-an-organization)
- [https://docs.github.com/en/enterprise-server@3.3/admin/user-management/managing-users-in-your-enterprise/roles-in-an-enterprise](https://docs.github.com/en/enterprise-server@3.3/admin/user-management/managing-users-in-your-enterprise/roles-in-an-enterprise)[https://docs.github.com/en/enterprise-server](https://docs.github.com/en/enterprise-server@3.3/admin/user-management/managing-users-in-your-enterprise/roles-in-an-enterprise)
- [https://docs.github.com/en/get-started/learning-about-github/access-permissions-on-github](https://docs.github.com/en/get-started/learning-about-github/access-permissions-on-github)
- [https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-user-account/managing-user-account-settings/permission-levels-for-user-owned-project-boards](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-user-account/managing-user-account-settings/permission-levels-for-user-owned-project-boards)
- [https://docs.github.com/en/actions/security-guides/encrypted-secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets)
- [https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions)
- [https://securitylab.github.com/resources/github-actions-untrusted-input/](https://securitylab.github.com/resources/github-actions-untrusted-input/)
- [https://docs.github.com/en/rest/checks/runs](https://docs.github.com/en/rest/checks/runs)
- [https://docs.github.com/en/apps](https://docs.github.com/en/apps)
- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../banners/hacktricks-training.md}}
