# Gh Actions - Context Script Injections

{{#include ../../../banners/hacktricks-training.md}}

## Zrozumienie ryzyka

GitHub Actions renderuje wyrażenia ${{ ... }} przed wykonaniem kroku. Wartość po renderowaniu jest wklejana do programu kroku (dla kroków run:, skrypt shell). Jeśli interpolujesz niezaufane dane wejściowe bezpośrednio wewnątrz run:, atakujący kontroluje część programu shell i może wykonać dowolne polecenia.

Docs: https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions and contexts/functions: https://docs.github.com/en/actions/learn-github-actions/contexts

Kluczowe punkty:
- Renderowanie odbywa się przed wykonaniem. Skrypt run jest wygenerowany z wszystkimi rozwiązanymi wyrażeniami, a następnie uruchamiany przez shell.
- Wiele kontekstów zawiera pola kontrolowane przez użytkownika zależnie od zdarzenia wyzwalającego (issues, PRs, comments, discussions, forks, stars itp.). Zobacz untrusted input reference: https://securitylab.github.com/resources/github-actions-untrusted-input/
- Cytowanie w shell wewnątrz run: nie jest niezawodną obroną, ponieważ wstrzyknięcie zachodzi na etapie renderowania szablonu. Atakujący mogą przerwać cudzysłowy lub wstrzykiwać operatory poprzez spreparowane dane.

## Wrażliwy wzorzec → RCE na runnerze

Wrażliwy workflow (wyzwalany gdy ktoś otworzy nowe issue):
```yaml
name: New Issue Created
on:
issues:
types: [opened]
jobs:
deploy:
runs-on: ubuntu-latest
permissions:
issues: write
steps:
- name: New issue
run: |
echo "New issue ${{ github.event.issue.title }} created"
- name: Add "new" label to issue
uses: actions-ecosystem/action-add-labels@v1
with:
github_token: ${{ secrets.GITHUB_TOKEN }}
labels: new
```
Jeśli atakujący otworzy issue zatytułowane $(id), wyrenderowany krok stanie się:
```sh
echo "New issue $(id) created"
```
Substytucja polecenia uruchamia id na runnerze. Przykładowy wynik:
```
New issue uid=1001(runner) gid=118(docker) groups=118(docker),4(adm),100(users),999(systemd-journal) created
```
Dlaczego cytowanie nie wystarczy:
- Wyrażenia są najpierw renderowane, a następnie uruchamiany jest powstały skrypt. Jeśli nieufna wartość zawiera $(...), `;`, `"`/`'`, lub nowe linie, może zmienić strukturę programu mimo twojego cytowania.

## Safe pattern (shell variables via env)

Poprawne rozwiązanie: skopiuj nieufne dane wejściowe do environment variable, następnie użyj native shell expansion ($VAR) w run script. Nie osadzaj ponownie z ${{ ... }} w obrębie command.
```yaml
# safe
jobs:
deploy:
runs-on: ubuntu-latest
steps:
- name: New issue
env:
TITLE: ${{ github.event.issue.title }}
run: |
echo "New issue $TITLE created"
```
Notatki:
- Avoid using ${{ env.TITLE }} inside run:. That reintroduces template rendering back into the command and brings the same injection risk.
- Prefer passing untrusted inputs via env: mapping and reference them with $VAR in run:.

## Powierzchnie wyzwalane przez czytelników (traktuj jako niezaufane)

Konta mające tylko uprawnienia do odczytu w publicznych repozytoriach wciąż mogą wyzwalać wiele zdarzeń. Każde pole w kontekstach pochodzących z tych zdarzeń należy traktować jako kontrolowane przez atakującego, o ile nie udowodniono inaczej. Przykłady:
- issues, issue_comment
- discussion, discussion_comment (orgs mogą ograniczać discussions)
- pull_request, pull_request_review, pull_request_review_comment
- pull_request_target (niebezpieczne jeśli użyte niewłaściwie, uruchamia się w kontekście repozytorium bazowego)
- fork (każdy może forkować publiczne repozytoria)
- watch (starring a repo)
- Pośrednio przez workflow_run/workflow_call chains

Które konkretne pola są kontrolowane przez atakującego zależy od zdarzenia. Zapoznaj się z GitHub Security Lab’s untrusted input guide: https://securitylab.github.com/resources/github-actions-untrusted-input/

## Praktyczne wskazówki

- Minimalizuj użycie wyrażeń inside run:. Preferuj mapowanie env: + $VAR.
- Jeśli musisz transformować input, rób to w shellu używając bezpiecznych narzędzi (printf %q, jq -r, itd.), nadal zaczynając od zmiennej shellowej.
- Bądź wyjątkowo ostrożny przy interpolowaniu nazw gałęzi, tytułów PR, nazw użytkowników, etykiet, tytułów discussion oraz PR head refs do skryptów, flag wiersza poleceń lub ścieżek plików.
- Dla reusable workflows i composite actions zastosuj ten sam wzorzec: mapuj do env, a potem odwołuj się do $VAR.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)
- [GitHub workflow syntax](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions)
- [Contexts and expression syntax](https://docs.github.com/en/actions/learn-github-actions/contexts)
- [Untrusted input reference for GitHub Actions](https://securitylab.github.com/resources/github-actions-untrusted-input/)

{{#include ../../../banners/hacktricks-training.md}}
