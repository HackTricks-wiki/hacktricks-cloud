# Gh Actions - Context Script Injections

{{#include ../../../banners/hacktricks-training.md}}

## Comprendere il rischio

GitHub Actions rende le espressioni ${{ ... }} prima che lo step venga eseguito. Il valore renderizzato viene incollato nel programma dello step (per gli step run, uno script shell). Se si interpolano input non attendibili direttamente dentro run:, l'attaccante controlla parte del programma shell e può eseguire comandi arbitrari.

Docs: https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions and contexts/functions: https://docs.github.com/en/actions/learn-github-actions/contexts

Punti chiave:
- La valutazione avviene prima dell'esecuzione. Lo script definito in run: viene generato con tutte le espressioni risolte, poi eseguito dalla shell.
- Molti contexts contengono campi controllati dall'utente a seconda dell'evento che innesca il workflow (issues, PRs, commenti, discussions, forks, stars, ecc.). Vedi il riferimento sugli input non attendibili: https://securitylab.github.com/resources/github-actions-untrusted-input/
- Il quoting/escaping della shell all'interno di run: non è una difesa affidabile, perché l'iniezione avviene nella fase di rendering del template. Gli attaccanti possono uscire dalle virgolette o iniettare operatori tramite input appositamente costruiti.

## Pattern vulnerabile → RCE sul runner

Workflow vulnerabile (innescato quando qualcuno apre una nuova issue):
```yaml
name: New Issue Created
on:
issues:
types: [opened]
jobs:
deploy:
runs-on: ubuntu-latest
permissions:
issues: write
steps:
- name: New issue
run: |
echo "New issue ${{ github.event.issue.title }} created"
- name: Add "new" label to issue
uses: actions-ecosystem/action-add-labels@v1
with:
github_token: ${{ secrets.GITHUB_TOKEN }}
labels: new
```
Se un attacker apre un issue intitolato $(id), lo step renderizzato diventa:
```sh
echo "New issue $(id) created"
```
La command substitution esegue id sul runner. Esempio di output:
```
New issue uid=1001(runner) gid=118(docker) groups=118(docker),4(adm),100(users),999(systemd-journal) created
```
Perché il quoting non ti salva:
- Le espressioni vengono valutate prima, poi lo script risultante viene eseguito. Se il valore non attendibile contiene $(...), `;`, `"`/`'`, o newlines, può alterare la struttura del programma nonostante il tuo quoting.

## Safe pattern (shell variables via env)

Mitigazione corretta: copia l'input non attendibile in una variabile d'ambiente, poi usa l'espansione nativa della shell ($VAR) nello run script. Non reinserire con ${{ ... }} dentro il comando.
```yaml
# safe
jobs:
deploy:
runs-on: ubuntu-latest
steps:
- name: New issue
env:
TITLE: ${{ github.event.issue.title }}
run: |
echo "New issue $TITLE created"
```
Note:
- Evita di usare ${{ env.TITLE }} inside run:. Questo reintroduce il rendering del template nel comando e comporta lo stesso rischio di injection.
- Preferisci passare input non attendibili tramite la mappatura env: e riferirli con $VAR in run:.

## Superfici che possono essere attivate da utenti con sola lettura (trattare come non attendibili)

Account con solo permesso di read su repository pubblici possono comunque attivare molti eventi. Qualsiasi campo nei contesti derivati da questi eventi deve essere considerato controllato dall'attaccante a meno che non sia dimostrato il contrario. Esempi:
- issues, issue_comment
- discussion, discussion_comment (le org possono limitare le discussioni)
- pull_request, pull_request_review, pull_request_review_comment
- pull_request_target (dangerous if misused, runs in base repo context)
- fork (anyone can fork public repos)
- watch (starring a repo)
- Indirectly via workflow_run/workflow_call chains

Quali campi specifici sono controllati dall'attaccante dipende dall'evento. Consulta GitHub Security Lab’s untrusted input guide: https://securitylab.github.com/resources/github-actions-untrusted-input/

## Consigli pratici

- Minimizza l'uso di expressions inside run:. Preferisci la mappatura env: + $VAR.
- Se devi trasformare l'input, fallo nella shell usando strumenti sicuri (printf %q, jq -r, ecc.), sempre a partire da una variabile di shell.
- Presta particolare attenzione quando interpoli nomi di branch, titoli di PR, username, labels, titoli di discussion e PR head refs in script, flag della riga di comando o percorsi di file.
- Per reusable workflows e composite actions, applica lo stesso schema: mappa in env poi riferisciti a $VAR.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)
- [GitHub workflow syntax](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions)
- [Contexts and expression syntax](https://docs.github.com/en/actions/learn-github-actions/contexts)
- [Untrusted input reference for GitHub Actions](https://securitylab.github.com/resources/github-actions-untrusted-input/)

{{#include ../../../banners/hacktricks-training.md}}
