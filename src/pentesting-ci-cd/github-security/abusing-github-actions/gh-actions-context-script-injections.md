# Gh Actions - Context Script Injections

{{#include ../../../banners/hacktricks-training.md}}

## जोखिम को समझना

GitHub Actions ${{ ... }} expressions को step के execute होने से पहले render करता है। Render किया गया value step के program में paste हो जाता है (run steps के लिए, एक shell script)। यदि आप अविश्वसनीय इनपुट को सीधे run: के अंदर interpolate करते हैं, तो attacker shell program के एक हिस्से को नियंत्रित कर सकते हैं और arbitrary commands चला सकते हैं।

दस्तावेज़: https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions और contexts/functions: https://docs.github.com/en/actions/learn-github-actions/contexts

मुख्य बिंदु:
- Rendering execution से पहले होता है। Run script तब जनरेट होता है जब सभी expressions resolve हो जाते हैं, और फिर shell द्वारा execute किया जाता है।
- कई contexts में triggering event (issues, PRs, comments, discussions, forks, stars, आदि) पर निर्भर उपयोगकर्ता-नियंत्रित फ़ील्ड होते हैं। untrusted input reference देखें: https://securitylab.github.com/resources/github-actions-untrusted-input/
- run: के अंदर shell quoting एक भरोसेमंद रक्षा नहीं है, क्योंकि injection टेम्पलेट rendering स्टेज पर होता है। Attackers quotes तोड़ सकते हैं या crafted input के ज़रिये operators inject कर सकते हैं।

## कमजोर पैटर्न → RCE on runner

कमजोर workflow (जब कोई नया issue खोलता है तो ट्रिगर होता है):
```yaml
name: New Issue Created
on:
issues:
types: [opened]
jobs:
deploy:
runs-on: ubuntu-latest
permissions:
issues: write
steps:
- name: New issue
run: |
echo "New issue ${{ github.event.issue.title }} created"
- name: Add "new" label to issue
uses: actions-ecosystem/action-add-labels@v1
with:
github_token: ${{ secrets.GITHUB_TOKEN }}
labels: new
```
यदि attacker एक issue खोलता है जिसका शीर्षक $(id) है, तो रेंडर किया गया step बन जाता है:
```sh
echo "New issue $(id) created"
```
कमांड सब्स्टिट्यूशन रनर पर id चलाता है। उदाहरण आउटपुट:
```
New issue uid=1001(runner) gid=118(docker) groups=118(docker),4(adm),100(users),999(systemd-journal) created
```
क्यों quoting आपकी रक्षा नहीं करता:
- Expressions पहले render होते हैं, फिर जो स्क्रिप्ट बनती है वह चलती है। अगर अनट्रस्टेड value में $(...), `;`, `"`/`'`, या newlines हों, तो यह आपके quoting के बावजूद प्रोग्राम संरचना बदल सकता है।

## Safe pattern (shell variables via env)

सही उपाय: अनट्रस्टेड इनपुट को एक environment variable में कॉपी करें, फिर run स्क्रिप्ट में native shell expansion ($VAR) का उपयोग करें। कमांड के अंदर ${{ ... }} के साथ फिर से embed न करें।
```yaml
# safe
jobs:
deploy:
runs-on: ubuntu-latest
steps:
- name: New issue
env:
TITLE: ${{ github.event.issue.title }}
run: |
echo "New issue $TITLE created"
```
नोट्स:
- run: के अंदर ${{ env.TITLE }} का उपयोग करने से बचें। इससे कमांड में फिर से template rendering हो जाता है और वही इंजेक्शन जोखिम लौट आता है।
- untrusted inputs को env: mapping के माध्यम से पास करना बेहतर है और run: में उन्हें $VAR से संदर्भित करें।

## रीडर-ट्रिगर सतहें (untrusted मानें)

केवल read permission वाले खाते भी public repositories पर कई events ट्रिगर कर सकते हैं। इन events से निकले contexts के किसी भी field को attacker-controlled माना जाना चाहिए जब तक कि इसके विपरीत साबित न हो। उदाहरण:
- issues, issue_comment
- discussion, discussion_comment (orgs can restrict discussions)
- pull_request, pull_request_review, pull_request_review_comment
- pull_request_target (dangerous if misused, runs in base repo context)
- fork (anyone can fork public repos)
- watch (starring a repo)
- Indirectly via workflow_run/workflow_call chains

कौन से विशिष्ट फील्ड attacker-controlled हैं यह event-specific होता है। GitHub Security Lab की untrusted input guide देखें: https://securitylab.github.com/resources/github-actions-untrusted-input/

## व्यावहारिक सुझाव

- run: के अंदर expressions के उपयोग को न्यूनतम करें। env: mapping + $VAR को प्राथमिकता दें।
- यदि आपको इनपुट को transform करना ही हो, तो shell में सुरक्षित टूल्स का उपयोग करें (printf %q, jq -r, आदि), फिर भी shell variable से शुरू करें।
- जब branch names, PR titles, usernames, labels, discussion titles, और PR head refs को scripts, command-line flags, या file paths में interpolate करें तो विशेष सावधानी बरतें।
- reusable workflows और composite actions के लिए भी वही पैटर्न लागू करें: पहले env में map करें फिर $VAR से reference करें।

## संदर्भ

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)
- [GitHub workflow syntax](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions)
- [Contexts and expression syntax](https://docs.github.com/en/actions/learn-github-actions/contexts)
- [Untrusted input reference for GitHub Actions](https://securitylab.github.com/resources/github-actions-untrusted-input/)

{{#include ../../../banners/hacktricks-training.md}}
