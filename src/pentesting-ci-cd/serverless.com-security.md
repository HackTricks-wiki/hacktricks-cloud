# Serverless.com Security

{{#include ../banners/hacktricks-training.md}}

## Basic Information

### Organization

एक **Organization** Serverless Framework पारिस्थितिकी तंत्र के भीतर उच्चतम स्तर की इकाई है। यह एक **सामूहिक समूह** का प्रतिनिधित्व करता है, जैसे कि एक कंपनी, विभाग, या कोई बड़ी इकाई, जो कई परियोजनाओं, टीमों और अनुप्रयोगों को समाहित करता है।

### Team

**Team** वे उपयोगकर्ता हैं जिनके पास संगठन के भीतर पहुंच है। टीमें सदस्यों को भूमिकाओं के आधार पर व्यवस्थित करने में मदद करती हैं। **`Collaborators`** मौजूदा ऐप्स को देख और तैनात कर सकते हैं, जबकि **`Admins`** नए ऐप्स बना सकते हैं और संगठन की सेटिंग्स प्रबंधित कर सकते हैं।

### Application

एक **App** एक संगठन के भीतर संबंधित सेवाओं का तार्किक समूह है। यह कई सर्वरलेस सेवाओं से मिलकर बना एक पूर्ण अनुप्रयोग का प्रतिनिधित्व करता है जो एक साथ मिलकर एक समग्र कार्यक्षमता प्रदान करता है।

### **Services**

एक **Service** एक Serverless अनुप्रयोग का मुख्य घटक है। यह आपके पूरे सर्वरलेस प्रोजेक्ट का प्रतिनिधित्व करता है, जिसमें सभी कार्य, कॉन्फ़िगरेशन और आवश्यक संसाधन शामिल होते हैं। इसे आमतौर पर `serverless.yml` फ़ाइल में परिभाषित किया जाता है, एक सेवा में सेवा का नाम, प्रदाता कॉन्फ़िगरेशन, कार्य, घटनाएँ, संसाधन, प्लगइन्स, और कस्टम वेरिएबल्स जैसी मेटाडेटा शामिल होती है।
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Function</summary>

एक **Function** एकल सर्वरलेस फ़ंक्शन का प्रतिनिधित्व करता है, जैसे कि AWS Lambda फ़ंक्शन। इसमें वह कोड होता है जो घटनाओं के जवाब में निष्पादित होता है।

यह `serverless.yml` में `functions` अनुभाग के तहत परिभाषित किया गया है, जिसमें हैंडलर, रनटाइम, घटनाएँ, पर्यावरण चर, और अन्य सेटिंग्स निर्दिष्ट की गई हैं।
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>इवेंट</summary>

**इवेंट** आपके सर्वरलेस फ़ंक्शंस को सक्रिय करने वाले ट्रिगर्स हैं। वे यह परिभाषित करते हैं कि एक फ़ंक्शन को कब और कैसे निष्पादित किया जाना चाहिए।

सामान्य इवेंट प्रकारों में HTTP अनुरोध, अनुसूचित इवेंट (क्रॉन जॉब), डेटाबेस इवेंट, फ़ाइल अपलोड और अधिक शामिल हैं।
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>संसाधन</summary>

**संसाधन** आपको अतिरिक्त क्लाउड संसाधनों को परिभाषित करने की अनुमति देते हैं जिन पर आपकी सेवा निर्भर करती है, जैसे डेटाबेस, स्टोरेज बकेट, या IAM भूमिकाएँ।

इन्हें `resources` अनुभाग के तहत निर्दिष्ट किया जाता है, अक्सर AWS के लिए CloudFormation सिंटैक्स का उपयोग करते हुए।
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>प्रदाता</summary>

The **Provider** object specifies the cloud service provider (e.g., AWS, Azure, Google Cloud) and contains configuration settings relevant to that provider.

यह विवरण शामिल करता है जैसे कि रनटाइम, क्षेत्र, चरण, और क्रेडेंशियल्स।
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>स्टेज और क्षेत्र</summary>

स्टेज विभिन्न वातावरणों का प्रतिनिधित्व करता है (जैसे, विकास, स्टेजिंग, उत्पादन) जहाँ आपकी सेवा को तैनात किया जा सकता है। यह वातावरण-विशिष्ट कॉन्फ़िगरेशन और तैनाती की अनुमति देता है।
```yaml
provider:
stage: dev
```
क्षेत्र उस भौगोलिक क्षेत्र को निर्दिष्ट करता है जहाँ आपके संसाधन तैनात किए जाएंगे। यह विलंबता, अनुपालन और उपलब्धता के विचारों के लिए महत्वपूर्ण है।
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Plugins</summary>

**Plugins** सर्वरलेस फ्रेमवर्क की कार्यक्षमता को नए फीचर्स जोड़कर या अन्य उपकरणों और सेवाओं के साथ एकीकृत करके बढ़ाते हैं। इन्हें `plugins` अनुभाग के तहत परिभाषित किया गया है और npm के माध्यम से स्थापित किया जाता है।
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>परतें</summary>

**परतें** आपको साझा कोड या निर्भरताओं को आपके कार्यों से अलग पैकेज और प्रबंधित करने की अनुमति देती हैं। यह पुन: उपयोग को बढ़ावा देती है और तैनाती पैकेज के आकार को कम करती है। इन्हें `layers` अनुभाग के तहत परिभाषित किया जाता है और कार्यों द्वारा संदर्भित किया जाता है।
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>चर और कस्टम चर</summary>

**चर** गतिशील कॉन्फ़िगरेशन को सक्षम करते हैं, जिससे प्लेसहोल्डर का उपयोग किया जा सकता है जो तैनाती के समय हल होते हैं।

- **सिंटैक्स:** `${variable}` सिंटैक्स पर्यावरण चर, फ़ाइल सामग्री, या अन्य कॉन्फ़िगरेशन पैरामीटर को संदर्भित कर सकता है।

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **कस्टम चर:** `custom` अनुभाग का उपयोग उपयोगकर्ता-विशिष्ट चर और कॉन्फ़िगरेशन को परिभाषित करने के लिए किया जाता है जिन्हें `serverless.yml` में पुन: उपयोग किया जा सकता है।

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>आउटपुट</summary>

**आउटपुट** उन मानों को परिभाषित करते हैं जो एक सेवा के तैनात होने के बाद लौटाए जाते हैं, जैसे संसाधन ARN, एंडपॉइंट, या अन्य उपयोगी जानकारी। इन्हें `outputs` अनुभाग के तहत निर्दिष्ट किया जाता है और अक्सर अन्य सेवाओं के लिए जानकारी को उजागर करने या तैनाती के बाद आसान पहुंच के लिए उपयोग किया जाता है।
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAM भूमिकाएँ और अनुमतियाँ</summary>

**IAM भूमिकाएँ और अनुमतियाँ** आपके कार्यों और अन्य संसाधनों के लिए सुरक्षा क्रेडेंशियल और पहुँच अधिकारों को परिभाषित करती हैं। इन्हें आवश्यक अनुमतियों को निर्दिष्ट करने के लिए `provider` या व्यक्तिगत कार्य सेटिंग्स के तहत प्रबंधित किया जाता है।
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>पर्यावरण चर</summary>

**चर** आपको अपने कार्यों को कॉन्फ़िगरेशन सेटिंग्स और रहस्यों को बिना हार्डकोड किए पास करने की अनुमति देते हैं। इन्हें प्रदाता या व्यक्तिगत कार्यों के लिए `environment` अनुभाग के तहत परिभाषित किया जाता है।
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Dependencies</summary>

**Dependencies** आपके फ़ंक्शंस के लिए आवश्यक बाहरी पुस्तकालयों और मॉड्यूलों का प्रबंधन करते हैं। इन्हें आमतौर पर npm या pip जैसे पैकेज प्रबंधकों के माध्यम से संभाला जाता है, और `serverless-webpack` जैसे उपकरणों या प्लगइनों का उपयोग करके आपके डिप्लॉयमेंट पैकेज के साथ बंडल किया जाता है।
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>हुक</summary>

**हुक** आपको परिनियोजन जीवनचक्र के विशिष्ट बिंदुओं पर कस्टम स्क्रिप्ट या कमांड चलाने की अनुमति देते हैं। इन्हें प्लगइन्स का उपयोग करके या `serverless.yml` के भीतर परिभाषित किया जाता है ताकि परिनियोजन से पहले या बाद में क्रियाएँ की जा सकें।
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

यह आधिकारिक ट्यूटोरियल का सारांश है [**from the docs**](https://www.serverless.com/framework/docs/tutorial):

1. एक AWS खाता बनाएं (Serverless.com AWS अवसंरचना में शुरू होता है)
2. serverless.com में एक खाता बनाएं
3. एक ऐप बनाएं:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
यह एक **app** बनाना चाहिए था जिसका नाम `tutorialapp` है, जिसे आप [serverless.com](serverless.com-security.md) में देख सकते हैं और एक फ़ोल्डर बनाना चाहिए था जिसका नाम `Tutorial` है जिसमें फ़ाइल **`handler.js`** है जिसमें कुछ JS कोड है जिसमें `helloworld` कोड है और फ़ाइल **`serverless.yml`** है जो उस फ़ंक्शन की घोषणा करती है:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. एक AWS प्रदाता बनाएं, **डैशबोर्ड** में जाकर `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`।
1. `serverless.com` को AWS तक पहुंच देने के लिए यह इस कॉन्फ़िग फ़ाइल का उपयोग करके एक क्लाउडफॉर्मेशन स्टैक चलाने के लिए कहेगा (इस लेख के समय): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. यह टेम्पलेट **`SFRole-<ID>`** नामक एक भूमिका उत्पन्न करता है जिसमें **`arn:aws:iam::aws:policy/AdministratorAccess`** उस खाते पर है जिसमें एक ट्रस्ट आइडेंटिटी है जो `Serverless.com` AWS खाते को भूमिका तक पहुंचने की अनुमति देती है।

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>विश्वास संबंध</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. ट्यूटोरियल `createCustomer.js` फ़ाइल बनाने के लिए कहता है, जो मूल रूप से एक नया API एंडपॉइंट बनाएगा जिसे नए JS फ़ाइल द्वारा संभाला जाएगा और `serverless.yml` फ़ाइल को संशोधित करने के लिए कहता है ताकि यह एक **नया DynamoDB तालिका** उत्पन्न करे, एक **पर्यावरण चर** परिभाषित करे, और उस भूमिका को परिभाषित करे जो उत्पन्न लैंब्डा का उपयोग करेगी।

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. इसे चलाते हुए **`serverless deploy`** करें
1. तैनाती एक CloudFormation Stack के माध्यम से की जाएगी
2. ध्यान दें कि **lambdas API गेटवे के माध्यम से एक्सपोज़ किए गए हैं** और सीधे URLs के माध्यम से नहीं
7. **इसे परीक्षण करें**
1. पिछले चरण में **URLs** प्रिंट होंगे जहाँ आपके API एंडपॉइंट्स लैम्ब्डा फ़ंक्शंस तैनात किए गए हैं

## Serverless.com की सुरक्षा समीक्षा

### **गलत कॉन्फ़िगर किए गए IAM भूमिकाएँ और अनुमतियाँ**

अत्यधिक अनुमति देने वाली IAM भूमिकाएँ क्लाउड संसाधनों तक अनधिकृत पहुँच प्रदान कर सकती हैं, जिससे डेटा लीक या संसाधन हेरफेर हो सकता है।

जब किसी Lambda फ़ंक्शन के लिए कोई अनुमतियाँ निर्दिष्ट नहीं की जाती हैं, तो केवल लॉग उत्पन्न करने के लिए अनुमतियों के साथ एक भूमिका बनाई जाएगी, जैसे: 

<details>

<summary>न्यूनतम लैम्ब्डा अनुमतियाँ</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **निवारण रणनीतियाँ**

- **कम से कम विशेषाधिकार का सिद्धांत:** प्रत्येक फ़ंक्शन को केवल आवश्यक अनुमतियाँ सौंपें।

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **अलग-अलग भूमिकाएँ उपयोग करें:** फ़ंक्शन आवश्यकताओं के आधार पर भूमिकाओं में भिन्नता करें।

---

### **असुरक्षित रहस्य और कॉन्फ़िगरेशन प्रबंधन**

संवेदनशील जानकारी (जैसे, API कुंजी, डेटाबेस क्रेडेंशियल) को सीधे **`serverless.yml`** या कोड में स्टोर करना जोखिम भरा हो सकता है यदि रिपॉजिटरी से समझौता किया जाता है।

**`serverless.yml`** फ़ाइल में पर्यावरण चर को स्टोर करने का **सिफारिश की गई** विधि serverless.com से (इस लेख के समय) `ssm` या `s3` प्रदाताओं का उपयोग करना है, जो **तैनाती के समय इन स्रोतों से पर्यावरण मान प्राप्त करने** और **लैम्ब्डा** के पर्यावरण चर को **मानों के स्पष्ट पाठ के साथ कॉन्फ़िगर** करने की अनुमति देता है!

> [!CAUTION]
> इसलिए, AWS के अंदर लैम्ब्डा की कॉन्फ़िगरेशन पढ़ने के लिए अनुमतियाँ रखने वाला कोई भी व्यक्ति **इन सभी पर्यावरण चर को स्पष्ट पाठ में एक्सेस कर सकेगा!**

उदाहरण के लिए, निम्नलिखित उदाहरण SSM का उपयोग करके एक पर्यावरण चर प्राप्त करेगा:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
And even if this prevents hardcoding the environment variable value in the **`serverless.yml`** file, the value will be obtained at deployment time and will be **added in clear text inside the lambda environment variable**.

> [!TIP]
> The recommended way to store environment variables using serveless.com would be to **store it in a AWS secret** and just store the secret name in the environment variable and the **lambda code should gather it**.

#### **Mitigation Strategies**

- **Secrets Manager Integration:** Use services like **AWS Secrets Manager.**
- **Encrypted Variables:** Leverage Serverless Framework’s encryption features for sensitive data.
- **Access Controls:** Restrict access to secrets based on roles.

---

### **Vulnerable Code and Dependencies**

Outdated or insecure dependencies can introduce vulnerabilities, while improper input handling may lead to code injection attacks.

#### **Mitigation Strategies**

- **Dependency Management:** Regularly update dependencies and scan for vulnerabilities.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Input Validation:** Implement strict validation and sanitization of all inputs.
- **Code Reviews:** Conduct thorough reviews to identify security flaws.
- **Static Analysis:** Use tools to detect vulnerabilities in the codebase.

---

### **Inadequate Logging and Monitoring**

Without proper logging and monitoring, malicious activities may go undetected, delaying incident response.

#### **Mitigation Strategies**

- **Centralized Logging:** Aggregate logs using services like **AWS CloudWatch** or **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Enable Detailed Logging:** Capture essential information without exposing sensitive data.
- **Set Up Alerts:** Configure alerts for suspicious activities or anomalies.
- **Regular Monitoring:** Continuously monitor logs and metrics for potential security incidents.

---

### **Insecure API Gateway Configurations**

Open or improperly secured APIs can be exploited for unauthorized access, Denial of Service (DoS) attacks, or cross-site attacks.

#### **Mitigation Strategies**

- **Authentication and Authorization:** Implement robust mechanisms like OAuth, API keys, or JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Rate Limiting and Throttling:** Prevent abuse by limiting request rates.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Secure CORS Configuration:** Restrict allowed origins, methods, and headers.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Use Web Application Firewalls (WAF):** Filter and monitor HTTP requests for malicious patterns.

---

### **Insufficient Function Isolation**

Shared resources and inadequate isolation can lead to privilege escalations or unintended interactions between functions.

#### **Mitigation Strategies**

- **Isolate Functions:** Assign distinct resources and IAM roles to ensure independent operation.
- **Resource Partitioning:** Use separate databases or storage buckets for different functions.
- **Use VPCs:** Deploy functions within Virtual Private Clouds for enhanced network isolation.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
sub
