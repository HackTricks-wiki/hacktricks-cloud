# Serverless.com Security

{{#include ../banners/hacktricks-training.md}}

## 基本情報

### 組織

**Organization** は、Serverless Framework エコシステム内の最上位のエンティティです。これは、複数のプロジェクト、チーム、およびアプリケーションを包含する**集団**、例えば会社、部門、またはその他の大規模なエンティティを表します。

### チーム

**Team** は、組織内にアクセスを持つユーザーです。チームは、役割に基づいてメンバーを整理するのに役立ちます。**`Collaborators`** は既存のアプリを表示およびデプロイでき、**`Admins`** は新しいアプリを作成し、組織の設定を管理できます。

### アプリケーション

**App** は、組織内の関連サービスの論理的なグループ化です。これは、複数のサーバーレスサービスで構成され、協調して機能を提供する完全なアプリケーションを表します。

### **サービス**

**Service** は、サーバーレスアプリケーションのコアコンポーネントです。これは、すべての関数、設定、および必要なリソースをカプセル化した、あなたの全サーバーレスプロジェクトを表します。通常、`serverless.yml` ファイルで定義され、サービスにはサービス名、プロバイダー設定、関数、イベント、リソース、プラグイン、およびカスタム変数などのメタデータが含まれます。
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Function</summary>

**Function**は、AWS Lambda関数のような単一のサーバーレス関数を表します。これは、イベントに応じて実行されるコードを含んでいます。

これは、`serverless.yml`の`functions`セクションで定義され、ハンドラー、ランタイム、イベント、環境変数、およびその他の設定を指定します。
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>イベント</summary>

**イベント**は、サーバーレス関数を呼び出すトリガーです。これにより、関数がどのように、いつ実行されるべきかが定義されます。

一般的なイベントタイプには、HTTPリクエスト、スケジュールされたイベント（cronジョブ）、データベースイベント、ファイルアップロードなどがあります。
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>リソース</summary>

**リソース** は、データベース、ストレージバケット、またはIAMロールなど、サービスが依存する追加のクラウドリソースを定義することを可能にします。

それらは `resources` セクションの下に指定され、通常はAWSのCloudFormation構文を使用します。
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>プロバイダー</summary>

**プロバイダー**オブジェクトは、クラウドサービスプロバイダー（例：AWS、Azure、Google Cloud）を指定し、そのプロバイダーに関連する設定を含みます。

ランタイム、リージョン、ステージ、認証情報などの詳細が含まれています。
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>ステージとリージョン</summary>

ステージは、サービスがデプロイできる異なる環境（例：開発、ステージング、本番）を表します。これは、環境固有の設定とデプロイを可能にします。
```yaml
provider:
stage: dev
```
地域は、リソースが展開される地理的地域を指定します。これは、レイテンシ、コンプライアンス、および可用性の考慮にとって重要です。
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>プラグイン</summary>

**プラグイン** は、Serverless Frameworkの機能を拡張し、新しい機能を追加したり、他のツールやサービスと統合したりします。これらは `plugins` セクションの下で定義され、npmを介してインストールされます。
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>レイヤー</summary>

**レイヤー** は、共有コードや依存関係を関数とは別にパッケージ化して管理することを可能にします。これにより再利用性が促進され、デプロイメントパッケージのサイズが削減されます。レイヤーは `layers` セクションで定義され、関数によって参照されます。
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>変数とカスタム変数</summary>

**変数** は、デプロイ時に解決されるプレースホルダーを使用することで動的な構成を可能にします。

- **構文:** `${variable}` 構文は、環境変数、ファイルの内容、または他の構成パラメータを参照できます。

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **カスタム変数:** `custom` セクションは、`serverless.yml` 全体で再利用できるユーザー固有の変数と構成を定義するために使用されます。

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>出力</summary>

**出力** は、サービスがデプロイされた後に返される値を定義します。これにはリソースARN、エンドポイント、または他の有用な情報が含まれます。これらは `outputs` セクションの下に指定され、他のサービスに情報を公開したり、デプロイ後の簡単なアクセスのために使用されることがよくあります。
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAMロールと権限</summary>

**IAMロールと権限**は、あなたの関数やその他のリソースのためのセキュリティ資格情報とアクセス権を定義します。必要な権限を指定するために、`provider`または個々の関数設定の下で管理されます。
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>環境変数</summary>

**変数**は、設定や秘密を関数にハードコーディングせずに渡すことを可能にします。これらは、プロバイダーまたは個々の関数の`environment`セクションの下で定義されます。
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>依存関係</summary>

**依存関係** は、あなたの関数が必要とする外部ライブラリやモジュールを管理します。通常、npmやpipのようなパッケージマネージャーを介して処理され、`serverless-webpack`のようなツールやプラグインを使用してデプロイメントパッケージにバンドルされます。
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>フック</summary>

**フック** は、デプロイメントライフサイクルの特定のポイントでカスタムスクリプトやコマンドを実行することを可能にします。これらは、プラグインを使用するか、`serverless.yml`内で定義され、デプロイメントの前後にアクションを実行します。
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### チュートリアル

これは公式チュートリアルの要約です [**ドキュメントから**](https://www.serverless.com/framework/docs/tutorial):

1. AWSアカウントを作成する（Serverless.comはAWSインフラストラクチャで開始します）
2. serverless.comにアカウントを作成する
3. アプリを作成する:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
これは、[serverless.com](serverless.com-security.md) で確認できる **app** `tutorialapp` を作成し、`helloworld` コードを含む JS コードがある **`handler.js`** ファイルと、その関数を宣言する **`serverless.yml`** ファイルを含む `Tutorial` というフォルダーを作成するはずです。

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. AWSプロバイダーを作成します。`https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`の**ダッシュボード**に移動します。
1. `serverless.com`にAWSへのアクセスを許可するために、次の構成ファイルを使用してcloudformationスタックを実行するように求められます（この執筆時点でのもの）： [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. このテンプレートは、**`SFRole-<ID>`**というロールを生成し、**`arn:aws:iam::aws:policy/AdministratorAccess`**を持つアカウントに対して、`Serverless.com` AWSアカウントがロールにアクセスできるようにするTrust Identityを持っています。

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>信頼関係</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. チュートリアルでは、基本的に新しいAPIエンドポイントを新しいJSファイルで処理する`createCustomer.js`というファイルを作成するように求められ、**新しいDynamoDBテーブル**を生成し、**環境変数**を定義し、生成されたラムダを使用するロールを設定するために`serverless.yml`ファイルを修正するように求められています。

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. **`serverless deploy`**を実行してデプロイします
1. デプロイメントはCloudFormationスタックを介して行われます
2. **ラムダはAPIゲートウェイを介して公開されており**、直接のURLではありません
7. **テストします**
1. 前のステップでは、APIエンドポイントラムダ関数がデプロイされた**URL**が表示されます

## Serverless.comのセキュリティレビュー

### **誤設定されたIAMロールと権限**

過度に許可されたIAMロールは、クラウドリソースへの不正アクセスを許可し、データ漏洩やリソースの操作につながる可能性があります。

ラムダ関数に対して権限が指定されていない場合、ログを生成するための権限のみを持つロールが作成されます。例えば：

<details>

<summary>最小限のラムダ権限</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **緩和戦略**

- **最小権限の原則:** 各関数に必要な権限のみを割り当てる。

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **別々のロールを使用:** 関数の要件に基づいてロールを区別する。

---

### **安全でない秘密情報と構成管理**

敏感な情報（例：APIキー、データベースの資格情報）を**`serverless.yml`**やコードに直接保存すると、リポジトリが侵害された場合に露出する可能性があります。

**推奨される**方法は、serverless.comの**`serverless.yml`**ファイルに環境変数を保存するために、`ssm`または`s3`プロバイダーを使用することです。これにより、**デプロイ時にこれらのソースから環境値を取得し、**lambdas**の環境変数を**値のクリアテキストなしで**構成できます！

> [!CAUTION]
> したがって、AWS内のlambdas構成を読み取る権限を持つ人は、**これらの環境変数すべてにクリアテキストでアクセスできるようになります！**

例えば、以下の例ではSSMを使用して環境変数を取得します：
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
And even if this prevents hardcoding the environment variable value in the **`serverless.yml`** file, the value will be obtained at deployment time and will be **added in clear text inside the lambda environment variable**.

> [!TIP]
> The recommended way to store environment variables using serveless.com would be to **store it in a AWS secret** and just store the secret name in the environment variable and the **lambda code should gather it**.

#### **緩和戦略**

- **Secrets Manager Integration:** Use services like **AWS Secrets Manager.**
- **Encrypted Variables:** Leverage Serverless Framework’s encryption features for sensitive data.
- **Access Controls:** Restrict access to secrets based on roles.

---

### **脆弱なコードと依存関係**

Outdated or insecure dependencies can introduce vulnerabilities, while improper input handling may lead to code injection attacks.

#### **緩和戦略**

- **Dependency Management:** Regularly update dependencies and scan for vulnerabilities.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Input Validation:** Implement strict validation and sanitization of all inputs.
- **Code Reviews:** Conduct thorough reviews to identify security flaws.
- **Static Analysis:** Use tools to detect vulnerabilities in the codebase.

---

### **不十分なログ記録と監視**

Without proper logging and monitoring, malicious activities may go undetected, delaying incident response.

#### **緩和戦略**

- **Centralized Logging:** Aggregate logs using services like **AWS CloudWatch** or **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Enable Detailed Logging:** Capture essential information without exposing sensitive data.
- **Set Up Alerts:** Configure alerts for suspicious activities or anomalies.
- **Regular Monitoring:** Continuously monitor logs and metrics for potential security incidents.

---

### **不安全なAPIゲートウェイ設定**

Open or improperly secured APIs can be exploited for unauthorized access, Denial of Service (DoS) attacks, or cross-site attacks.

#### **緩和戦略**

- **Authentication and Authorization:** Implement robust mechanisms like OAuth, API keys, or JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Rate Limiting and Throttling:** Prevent abuse by limiting request rates.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Secure CORS Configuration:** Restrict allowed origins, methods, and headers.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Use Web Application Firewalls (WAF):** Filter and monitor HTTP requests for malicious patterns.

---

### **不十分な関数の分離**

Shared resources and inadequate isolation can lead to privilege escalations or unintended interactions between functions.

#### **緩和戦略**

- **Isolate Functions:** Assign distinct resources and IAM roles to ensure independent operation.
- **Resource Partitioning:** Use separate databases or storage buckets for different functions.
- **Use VPCs:** Deploy functions within Virtual Private Clouds for enhanced network isolation.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **Limit Function Permissions:** Ensure functions cannot access or interfere with each other’s resources unless explicitly required.

---

### **不十分なデータ保護**

Unencrypted data at rest or in transit can be exposed, leading to data breaches or tampering.

#### **緩和戦略**

- **Encrypt Data at Rest:** Utilize cloud service encryption features.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **Encrypt Data in Transit:** Use HTTPS/TLS for all data transmissions.
- **Secure API Communication:** Enforce encryption protocols and validate certificates.
- **Manage Encryption Keys Securely:** Use managed key services and rotate keys regularly.

---

### **適切なエラーハンドリングの欠如**

Detailed error messages can leak sensitive information about the infrastructure or codebase, while unhandled exceptions may lead to application crashes.

#### **緩和戦略**

- **Generic Error Messages:** Avoid exposing internal details in error responses.

```javascript
javascriptCopy code// Example in Node.js
exports.hello = async (event) => {
try {
// Function logic
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```

- **Centralized Error Handling:** Manage and sanitize errors consistently across all functions.
- **Monitor and Log Errors:** Track and analyze errors internally without exposing details to end-users.

---

### **不安全なデプロイメントプラクティス**

Exposed deployment configurations or unauthorized access to CI/CD pipelines can lead to malicious code deployments or misconfigurations.

#### **緩和戦略**

- **Secure CI/CD Pipelines:** Implement strict access controls, multi-factor authentication (MFA), and regular audits.
- **Store Configuration Securely:** Keep deployment files free from hardcoded secrets and sensitive data.
- **Use Infrastructure as Code (IaC) Security Tools:** Employ tools like **Checkov** or **Terraform Sentinel** to enforce security policies.
- **Immutable Deployments:** Prevent unauthorized changes post-deployment by adopting immutable infrastructure practices.

---

### **プラグインと拡張機能の脆弱性**

Using unvetted or malicious third-party plugins can introduce vulnerabilities into your serverless applications.

#### **緩和戦略**

- **Vet Plugins Thoroughly:** Assess the security of plugins before integration, favoring those from reputable sources.
- **Limit Plugin Usage:** Use only necessary plugins to minimize the attack surface.
- **Monitor Plugin Updates:** Keep plugins updated to benefit from security patches.
- **Isolate Plugin Environments:** Run plugins in isolated environments to contain potential compromises.

---

### **機密エンドポイントの露出**

Publicly accessible functions or unrestricted APIs can be exploited for unauthorized operations.

#### **緩和戦略**

- **Restrict Function Access:** Use VPCs, security groups, and firewall rules to limit access to trusted sources.
- **Implement Robust Authentication:** Ensure all exposed endpoints require proper authentication and authorization.
- **Use API Gateways Securely:** Configure API Gateways to enforce security policies, including input validation and rate limiting.
- **Disable Unused Endpoints:** Regularly review and disable any endpoints that are no longer in use.

---

### **チームメンバーと外部コラボレーターの過剰な権限**

Granting excessive permissions to team members and external collaborators can lead to unauthorized access, data breaches, and misuse of resources. This risk is heightened in environments where multiple individuals have varying levels of access, increasing the attack surface and potential for insider threats.

#### **緩和戦略**

- **Principle of Least Privilege:** Ensure that team members and collaborators have only the permissions necessary to perform their tasks.

---

### **アクセスキーとライセンスキーのセキュリティ**

**Access Keys** and **License Keys** are critical credentials used to authenticate and authorize interactions with the Serverless Framework CLI.

- **License Keys:** They are Unique identifiers required for authenticating access to Serverless Framework Version 4 which allows to login via CLI.
- **Access Keys:** Credentials that allow the Serverless Framework CLI to authenticate with the Serverless Framework Dashboard. When login with `serverless` cli an access key will be **generated and stored in the laptop**. You can also set it as an environment variable named `SERVERLESS_ACCESS_KEY`.

#### **セキュリティリスク**

1. **Exposure Through Code Repositories:**
- Hardcoding or accidentally committing Access Keys and License Keys to version control systems can lead to unauthorized access.
2. **Insecure Storage:**
- Storing keys in plaintext within environment variables or configuration files without proper encryption increases the likelihood of leakage.
3. **Improper Distribution:**
- Sharing keys through unsecured channels (e.g., email, chat) can result in interception by malicious actors.
4. **Lack of Rotation:**
- Not regularly rotating keys extends the exposure period if keys are compromised.
5. **Excessive Permissions:**
- Keys with broad permissions can be exploited to perform unauthorized actions across multiple resources.

{{#include ../banners/hacktricks-training.md}}
