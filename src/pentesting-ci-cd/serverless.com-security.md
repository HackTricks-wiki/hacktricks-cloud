# Serverless.com Sicherheit

{{#include ../banners/hacktricks-training.md}}

## Grundinformationen

### Organisation

Eine **Organisation** ist die höchste Ebene innerhalb des Serverless Framework-Ökosystems. Sie repräsentiert eine **kollektive Gruppe**, wie ein Unternehmen, eine Abteilung oder eine große Einheit, die mehrere Projekte, Teams und Anwendungen umfasst.

### Team

Das **Team** sind die Benutzer mit Zugang innerhalb der Organisation. Teams helfen dabei, Mitglieder basierend auf Rollen zu organisieren. **`Mitarbeiter`** können bestehende Apps anzeigen und bereitstellen, während **`Administratoren`** neue Apps erstellen und die Einstellungen der Organisation verwalten können.

### Anwendung

Eine **App** ist eine logische Gruppierung verwandter Dienste innerhalb einer Organisation. Sie repräsentiert eine vollständige Anwendung, die aus mehreren serverlosen Diensten besteht, die zusammenarbeiten, um eine kohärente Funktionalität bereitzustellen.

### **Dienste**

Ein **Dienst** ist die zentrale Komponente einer Serverless-Anwendung. Er repräsentiert Ihr gesamtes serverloses Projekt und umfasst alle Funktionen, Konfigurationen und Ressourcen, die benötigt werden. Er wird typischerweise in einer `serverless.yml`-Datei definiert, ein Dienst enthält Metadaten wie den Dienstnamen, Anbieter-Konfigurationen, Funktionen, Ereignisse, Ressourcen, Plugins und benutzerdefinierte Variablen.
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Funktion</summary>

Eine **Funktion** stellt eine einzelne serverlose Funktion dar, wie z.B. eine AWS Lambda-Funktion. Sie enthält den Code, der als Reaktion auf Ereignisse ausgeführt wird.

Sie wird im Abschnitt `functions` in `serverless.yml` definiert, wobei der Handler, die Laufzeit, Ereignisse, Umgebungsvariablen und andere Einstellungen angegeben werden.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>Event</summary>

**Ereignisse** sind Auslöser, die Ihre serverlosen Funktionen aufrufen. Sie definieren, wie und wann eine Funktion ausgeführt werden soll.

Zu den häufigsten Ereignistypen gehören HTTP-Anfragen, geplante Ereignisse (Cron-Jobs), Datenbankereignisse, Datei-Uploads und mehr.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>Ressource</summary>

**Ressourcen** ermöglichen es Ihnen, zusätzliche Cloud-Ressourcen zu definieren, von denen Ihr Dienst abhängt, wie Datenbanken, Speicher-Buckets oder IAM-Rollen.

Sie werden im Abschnitt `resources` angegeben, oft unter Verwendung der CloudFormation-Syntax für AWS.
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>Provider</summary>

Das **Provider**-Objekt gibt den Cloud-Dienstanbieter (z. B. AWS, Azure, Google Cloud) an und enthält Konfigurationseinstellungen, die für diesen Anbieter relevant sind.

Es enthält Details wie die Laufzeit, Region, Stage und Anmeldeinformationen.
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>Bühne und Region</summary>

Die Bühne repräsentiert verschiedene Umgebungen (z. B. Entwicklung, Staging, Produktion), in denen Ihr Dienst bereitgestellt werden kann. Sie ermöglicht umgebungsspezifische Konfigurationen und Bereitstellungen.
```yaml
provider:
stage: dev
```
Die Region gibt die geografische Region an, in der Ihre Ressourcen bereitgestellt werden. Sie ist wichtig für Latenz, Compliance und Verfügbarkeitsüberlegungen.
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Plugins</summary>

**Plugins** erweitern die Funktionalität des Serverless Frameworks, indem sie neue Funktionen hinzufügen oder mit anderen Tools und Diensten integriert werden. Sie sind im Abschnitt `plugins` definiert und werden über npm installiert.
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>Schichten</summary>

**Schichten** ermöglichen es Ihnen, gemeinsam genutzten Code oder Abhängigkeiten separat von Ihren Funktionen zu verpacken und zu verwalten. Dies fördert die Wiederverwendbarkeit und reduziert die Größen der Bereitstellungspakete. Sie werden im Abschnitt `layers` definiert und von Funktionen referenziert.
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>Variablen und benutzerdefinierte Variablen</summary>

**Variablen** ermöglichen eine dynamische Konfiguration, indem sie die Verwendung von Platzhaltern erlauben, die zur Zeit der Bereitstellung aufgelöst werden.

- **Syntax:** `${variable}`-Syntax kann auf Umgebungsvariablen, Dateiinhalte oder andere Konfigurationsparameter verweisen.

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **Benutzerdefinierte Variablen:** Der `custom`-Abschnitt wird verwendet, um benutzerspezifische Variablen und Konfigurationen zu definieren, die im gesamten `serverless.yml` wiederverwendet werden können.

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>Ausgaben</summary>

**Ausgaben** definieren die Werte, die nach der Bereitstellung eines Dienstes zurückgegeben werden, wie z.B. Ressourcen-ARNs, Endpunkte oder andere nützliche Informationen. Sie werden im Abschnitt `outputs` angegeben und häufig verwendet, um Informationen an andere Dienste weiterzugeben oder um einen einfachen Zugriff nach der Bereitstellung zu ermöglichen.
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAM-Rollen und Berechtigungen</summary>

**IAM-Rollen und Berechtigungen** definieren die Sicherheitsanmeldeinformationen und Zugriffsrechte für Ihre Funktionen und andere Ressourcen. Sie werden unter den `provider` oder den Einstellungen der einzelnen Funktionen verwaltet, um die erforderlichen Berechtigungen festzulegen.
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>Umgebungsvariablen</summary>

**Variablen** ermöglichen es Ihnen, Konfigurationseinstellungen und Geheimnisse an Ihre Funktionen zu übergeben, ohne sie fest einzugeben. Sie werden im Abschnitt `environment` für entweder den Anbieter oder einzelne Funktionen definiert.
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Abhängigkeiten</summary>

**Abhängigkeiten** verwalten die externen Bibliotheken und Module, die Ihre Funktionen benötigen. Sie werden typischerweise über Paketmanager wie npm oder pip verwaltet und mit Ihrem Bereitstellungspaket unter Verwendung von Tools oder Plugins wie `serverless-webpack` gebündelt.
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>Hooks</summary>

**Hooks** ermöglichen es Ihnen, benutzerdefinierte Skripte oder Befehle zu bestimmten Zeitpunkten im Bereitstellungslebenszyklus auszuführen. Sie werden mithilfe von Plugins oder innerhalb der `serverless.yml` definiert, um Aktionen vor oder nach Bereitstellungen auszuführen.
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

Dies ist eine Zusammenfassung des offiziellen Tutorials [**aus den Dokumenten**](https://www.serverless.com/framework/docs/tutorial):

1. Erstellen Sie ein AWS-Konto (Serverless.com startet in der AWS-Infrastruktur)
2. Erstellen Sie ein Konto bei serverless.com
3. Erstellen Sie eine App:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
Dies sollte eine **App** namens `tutorialapp` erstellt haben, die Sie in [serverless.com](serverless.com-security.md) überprüfen können, sowie einen Ordner namens `Tutorial` mit der Datei **`handler.js`**, die einige JS-Code mit einem `helloworld`-Code enthält, und der Datei **`serverless.yml`**, die diese Funktion deklariert:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. Erstellen Sie einen AWS-Anbieter, indem Sie im **Dashboard** zu `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws` gehen.
1. Um `serverless.com` Zugriff auf AWS zu gewähren, wird es aufgefordert, einen CloudFormation-Stack mit dieser Konfigurationsdatei auszuführen (zum Zeitpunkt des Schreibens): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. Diese Vorlage generiert eine Rolle mit dem Namen **`SFRole-<ID>`** mit **`arn:aws:iam::aws:policy/AdministratorAccess`** über das Konto mit einer Vertrauensidentität, die dem `Serverless.com` AWS-Konto den Zugriff auf die Rolle ermöglicht.

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>Vertrauensbeziehung</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. Das Tutorial fordert dazu auf, die Datei `createCustomer.js` zu erstellen, die im Grunde einen neuen API-Endpunkt erstellt, der von der neuen JS-Datei verarbeitet wird, und fordert dazu auf, die Datei `serverless.yml` zu ändern, um eine **neue DynamoDB-Tabelle** zu generieren, eine **Umgebungsvariable** zu definieren und die Rolle, die die generierten Lambdas verwenden wird.

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. Bereitstellung mit **`serverless deploy`**
1. Die Bereitstellung erfolgt über einen CloudFormation Stack
2. Beachten Sie, dass die **lambdas über API Gateway exponiert sind** und nicht über direkte URLs
7. **Testen Sie es**
1. Der vorherige Schritt gibt die **URLs** aus, unter denen Ihre API-Endpunkt-Lambda-Funktionen bereitgestellt wurden

## Sicherheitsüberprüfung von Serverless.com

### **Fehlkonfigurierte IAM-Rollen und Berechtigungen**

Übermäßig permissive IAM-Rollen können unbefugten Zugriff auf Cloud-Ressourcen gewähren, was zu Datenverletzungen oder Ressourcenmanipulation führen kann.

Wenn keine Berechtigungen für eine Lambda-Funktion angegeben sind, wird eine Rolle mit Berechtigungen nur zum Generieren von Protokollen erstellt, wie:

<details>

<summary>Minimale Lambda-Berechtigungen</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **Minderungsstrategien**

- **Prinzip der geringsten Privilegien:** Weisen Sie jeder Funktion nur die notwendigen Berechtigungen zu.

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **Verwenden Sie separate Rollen:** Unterscheiden Sie Rollen basierend auf den Anforderungen der Funktion.

---

### **Unsichere Geheimnisse und Konfigurationsmanagement**

Das Speichern sensibler Informationen (z. B. API-Schlüssel, Datenbankanmeldeinformationen) direkt in **`serverless.yml`** oder Code kann zu einer Offenlegung führen, wenn Repositories kompromittiert werden.

Die **empfohlene** Methode zum Speichern von Umgebungsvariablen in der **`serverless.yml`**-Datei von serverless.com (zum Zeitpunkt dieses Schreibens) besteht darin, die `ssm`- oder `s3`-Provider zu verwenden, die es ermöglichen, die **Umgebungswerte aus diesen Quellen zur Bereitstellungszeit abzurufen** und die **Umgebungsvariablen der **lambdas** mit dem **Text ohne die Werte** zu konfigurieren!

> [!CAUTION]
> Daher kann jeder mit Berechtigungen zum Lesen der Konfiguration der lambdas innerhalb von AWS **auf alle diese Umgebungsvariablen im Klartext zugreifen!**

Zum Beispiel wird das folgende Beispiel SSM verwenden, um eine Umgebungsvariable abzurufen:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
Und selbst wenn dies das Hardcoding des Wertes der Umgebungsvariable in der **`serverless.yml`**-Datei verhindert, wird der Wert zur Zeit der Bereitstellung abgerufen und wird **im Klartext in der Lambda-Umgebungsvariable hinzugefügt**.

> [!TIP]
> Der empfohlene Weg, Umgebungsvariablen mit serveless.com zu speichern, wäre, **sie in einem AWS-Geheimnis zu speichern** und nur den geheimen Namen in der Umgebungsvariable zu speichern, und der **Lambda-Code sollte es abrufen**.

#### **Minderungsstrategien**

- **Secrets Manager Integration:** Verwenden Sie Dienste wie **AWS Secrets Manager.**
- **Verschlüsselte Variablen:** Nutzen Sie die Verschlüsselungsfunktionen des Serverless Frameworks für sensible Daten.
- **Zugriffskontrollen:** Beschränken Sie den Zugriff auf Geheimnisse basierend auf Rollen.

---

### **Anfälliger Code und Abhängigkeiten**

Veraltete oder unsichere Abhängigkeiten können Schwachstellen einführen, während unsachgemäße Eingabeverarbeitung zu Code-Injection-Angriffen führen kann.

#### **Minderungsstrategien**

- **Abhängigkeitsmanagement:** Aktualisieren Sie regelmäßig Abhängigkeiten und scannen Sie nach Schwachstellen.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Eingangsvalidierung:** Implementieren Sie strenge Validierung und Sanitärung aller Eingaben.
- **Code-Überprüfungen:** Führen Sie gründliche Überprüfungen durch, um Sicherheitsfehler zu identifizieren.
- **Statische Analyse:** Verwenden Sie Tools, um Schwachstellen im Code zu erkennen.

---

### **Unzureichendes Logging und Monitoring**

Ohne angemessenes Logging und Monitoring können böswillige Aktivitäten unentdeckt bleiben, was die Reaktion auf Vorfälle verzögert.

#### **Minderungsstrategien**

- **Zentralisiertes Logging:** Aggregieren Sie Protokolle mit Diensten wie **AWS CloudWatch** oder **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Aktivieren Sie detailliertes Logging:** Erfassen Sie wesentliche Informationen, ohne sensible Daten offenzulegen.
- **Einrichten von Warnungen:** Konfigurieren Sie Warnungen für verdächtige Aktivitäten oder Anomalien.
- **Regelmäßige Überwachung:** Überwachen Sie kontinuierlich Protokolle und Metriken auf potenzielle Sicherheitsvorfälle.

---

### **Unsichere API-Gateway-Konfigurationen**

Offene oder unsachgemäß gesicherte APIs können für unbefugten Zugriff, Denial-of-Service (DoS)-Angriffe oder Cross-Site-Angriffe ausgenutzt werden.

#### **Minderungsstrategien**

- **Authentifizierung und Autorisierung:** Implementieren Sie robuste Mechanismen wie OAuth, API-Schlüssel oder JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Ratenbegrenzung und Drosselung:** Verhindern Sie Missbrauch, indem Sie die Anforderungsraten begrenzen.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Sichere CORS-Konfiguration:** Beschränken Sie erlaubte Ursprünge, Methoden und Header.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Verwenden Sie Web Application Firewalls (WAF):** Filtern und überwachen Sie HTTP-Anfragen auf bösartige Muster.

---

### **Unzureichende Funktionsisolierung**

Geteilte Ressourcen und unzureichende Isolation können zu Privilegieneskalationen oder unbeabsichtigten Interaktionen zwischen Funktionen führen.

#### **Minderungsstrategien**

- **Funktionen isolieren:** Weisen Sie unterschiedliche Ressourcen und IAM-Rollen zu, um einen unabhängigen Betrieb sicherzustellen.
- **Ressourcenteilung:** Verwenden Sie separate Datenbanken oder Speicherorte für verschiedene Funktionen.
- **Verwenden Sie VPCs:** Stellen Sie Funktionen innerhalb von Virtual Private Clouds für verbesserte Netzisolierung bereit.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **Berechtigungen für Funktionen einschränken:** Stellen Sie sicher, dass Funktionen nicht auf die Ressourcen anderer Funktionen zugreifen oder diese beeinträchtigen können, es sei denn, dies ist ausdrücklich erforderlich.

---

### **Unzureichender Datenschutz**

Unverschlüsselte Daten im Ruhezustand oder während der Übertragung können offengelegt werden, was zu Datenverletzungen oder Manipulationen führen kann.

#### **Minderungsstrategien**

- **Daten im Ruhezustand verschlüsseln:** Nutzen Sie die Verschlüsselungsfunktionen des Cloud-Dienstes.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **Daten während der Übertragung verschlüsseln:** Verwenden Sie HTTPS/TLS für alle Datenübertragungen.
- **Sichere API-Kommunikation:** Erzwingen Sie Verschlüsselungsprotokolle und validieren Sie Zertifikate.
- **Verwalten Sie Verschlüsselungsschlüssel sicher:** Verwenden Sie verwaltete Schlüsseldienste und rotieren Sie Schlüssel regelmäßig.

---

### **Mangelnde ordnungsgemäße Fehlerbehandlung**

Detaillierte Fehlermeldungen können sensible Informationen über die Infrastruktur oder den Code offenlegen, während nicht behandelte Ausnahmen zu Anwendungsabstürzen führen können.

#### **Minderungsstrategien**

- **Allgemeine Fehlermeldungen:** Vermeiden Sie die Offenlegung interner Details in Fehlermeldungen.

```javascript
javascriptCopy code// Beispiel in Node.js
exports.hello = async (event) => {
try {
// Funktionslogik
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Interner Serverfehler' }),
};
}
};
```

- **Zentralisierte Fehlerbehandlung:** Verwalten und sanitieren Sie Fehler konsistent über alle Funktionen hinweg.
- **Überwachen und Protokollieren von Fehlern:** Verfolgen und analysieren Sie Fehler intern, ohne Details für Endbenutzer offenzulegen.

---

### **Unsichere Bereitstellung Praktiken**

Offengelegte Bereitstellungskonfigurationen oder unbefugter Zugriff auf CI/CD-Pipelines können zu böswilligen Codebereitstellungen oder Fehlkonfigurationen führen.

#### **Minderungsstrategien**

- **Sichere CI/CD-Pipelines:** Implementieren Sie strenge Zugriffskontrollen, Multi-Faktor-Authentifizierung (MFA) und regelmäßige Audits.
- **Konfiguration sicher speichern:** Halten Sie Bereitstellungsdateien frei von hardcodierten Geheimnissen und sensiblen Daten.
- **Verwenden Sie Sicherheitswerkzeuge für Infrastruktur als Code (IaC):** Verwenden Sie Tools wie **Checkov** oder **Terraform Sentinel**, um Sicherheitsrichtlinien durchzusetzen.
- **Unveränderliche Bereitstellungen:** Verhindern Sie unbefugte Änderungen nach der Bereitstellung, indem Sie Praktiken für unveränderliche Infrastruktur übernehmen.

---

### **Schwachstellen in Plugins und Erweiterungen**

Die Verwendung von nicht geprüften oder bösartigen Drittanbieter-Plugins kann Schwachstellen in Ihren serverlosen Anwendungen einführen.

#### **Minderungsstrategien**

- **Plugins gründlich prüfen:** Bewerten Sie die Sicherheit von Plugins vor der Integration und bevorzugen Sie solche aus seriösen Quellen.
- **Verwendung von Plugins einschränken:** Verwenden Sie nur notwendige Plugins, um die Angriffsfläche zu minimieren.
- **Überwachen Sie Plugin-Updates:** Halten Sie Plugins auf dem neuesten Stand, um von Sicherheitsupdates zu profitieren.
- **Isolieren Sie Plugin-Umgebungen:** Führen Sie Plugins in isolierten Umgebungen aus, um potenzielle Kompromisse einzudämmen.

---

### **Offenlegung sensibler Endpunkte**

Öffentlich zugängliche Funktionen oder uneingeschränkte APIs können für unbefugte Operationen ausgenutzt werden.

#### **Minderungsstrategien**

- **Zugriff auf Funktionen einschränken:** Verwenden Sie VPCs, Sicherheitsgruppen und Firewall-Regeln, um den Zugriff auf vertrauenswürdige Quellen zu beschränken.
- **Robuste Authentifizierung implementieren:** Stellen Sie sicher, dass alle exponierten Endpunkte eine ordnungsgemäße Authentifizierung und Autorisierung erfordern.
- **API-Gateways sicher verwenden:** Konfigurieren Sie API-Gateways, um Sicherheitsrichtlinien durchzusetzen, einschließlich Eingangsvalidierung und Ratenbegrenzung.
- **Deaktivieren Sie ungenutzte Endpunkte:** Überprüfen Sie regelmäßig und deaktivieren Sie alle Endpunkte, die nicht mehr verwendet werden.

---

### **Übermäßige Berechtigungen für Teammitglieder und externe Mitarbeiter**

Das Gewähren übermäßiger Berechtigungen an Teammitglieder und externe Mitarbeiter kann zu unbefugtem Zugriff, Datenverletzungen und Missbrauch von Ressourcen führen. Dieses Risiko ist in Umgebungen erhöht, in denen mehrere Personen unterschiedliche Zugriffsrechte haben, was die Angriffsfläche und das Potenzial für Insider-Bedrohungen erhöht.

#### **Minderungsstrategien**

- **Prinzip der geringsten Privilegien:** Stellen Sie sicher, dass Teammitglieder und Mitarbeiter nur die Berechtigungen haben, die erforderlich sind, um ihre Aufgaben auszuführen.

---

### **Sicherheit von Zugriffsschlüsseln und Lizenzschlüsseln**

**Zugriffsschlüssel** und **Lizenzschlüssel** sind kritische Anmeldeinformationen, die zur Authentifizierung und Autorisierung von Interaktionen mit der Serverless Framework CLI verwendet werden.

- **Lizenzschlüssel:** Sie sind eindeutige Identifikatoren, die für die Authentifizierung des Zugriffs auf die Serverless Framework Version 4 erforderlich sind, die eine Anmeldung über die CLI ermöglicht.
- **Zugriffsschlüssel:** Anmeldeinformationen, die es der Serverless Framework CLI ermöglichen, sich beim Serverless Framework Dashboard zu authentifizieren. Bei der Anmeldung mit `serverless` cli wird ein Zugriffsschlüssel **generiert und auf dem Laptop gespeichert**. Sie können ihn auch als Umgebungsvariable mit dem Namen `SERVERLESS_ACCESS_KEY` festlegen.

#### **Sicherheitsrisiken**

1. **Offenlegung durch Code-Repositories:**
- Hardcoding oder versehentliches Committen von Zugriffsschlüsseln und Lizenzschlüsseln in Versionskontrollsysteme kann zu unbefugtem Zugriff führen.
2. **Unsichere Speicherung:**
- Das Speichern von Schlüsseln im Klartext innerhalb von Umgebungsvariablen oder Konfigurationsdateien ohne angemessene Verschlüsselung erhöht die Wahrscheinlichkeit eines Lecks.
3. **Unsachgemäße Verteilung:**
- Das Teilen von Schlüsseln über unsichere Kanäle (z. B. E-Mail, Chat) kann zu einer Abfangung durch böswillige Akteure führen.
4. **Mangelnde Rotation:**
- Das regelmäßige Rotieren von Schlüsseln verlängert die Expositionszeit, wenn Schlüssel kompromittiert werden.
5. **Übermäßige Berechtigungen:**
- Schlüssel mit breiten Berechtigungen können ausgenutzt werden, um unbefugte Aktionen über mehrere Ressourcen hinweg durchzuführen.

{{#include ../banners/hacktricks-training.md}}
