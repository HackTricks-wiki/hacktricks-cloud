# Serverless.com Security

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

### Organizacja

**Organizacja** to najwyższy poziom podmiotu w ekosystemie Serverless Framework. Reprezentuje **zbiorową grupę**, taką jak firma, dział lub jakikolwiek duży podmiot, który obejmuje wiele projektów, zespołów i aplikacji.

### Zespół

**Zespół** to użytkownicy z dostępem wewnątrz organizacji. Zespoły pomagają w organizowaniu członków na podstawie ról. **`Współpracownicy`** mogą przeglądać i wdrażać istniejące aplikacje, podczas gdy **`Administratorzy`** mogą tworzyć nowe aplikacje i zarządzać ustawieniami organizacji.

### Aplikacja

**Aplikacja** to logiczne grupowanie powiązanych usług w ramach Organizacji. Reprezentuje kompletną aplikację składającą się z wielu usług serverless, które współpracują, aby zapewnić spójną funkcjonalność.

### **Usługi**

**Usługa** to podstawowy komponent aplikacji Serverless. Reprezentuje cały projekt serverless, kapsułkując wszystkie funkcje, konfiguracje i zasoby potrzebne. Zwykle jest definiowana w pliku `serverless.yml`, usługa zawiera metadane, takie jak nazwa usługi, konfiguracje dostawcy, funkcje, zdarzenia, zasoby, wtyczki i zmienne niestandardowe.
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Funkcja</summary>

A **Funkcja** reprezentuje pojedynczą funkcję serverless, taką jak funkcja AWS Lambda. Zawiera kod, który jest wykonywany w odpowiedzi na zdarzenia.

Jest zdefiniowana w sekcji `functions` w `serverless.yml`, określając handler, runtime, zdarzenia, zmienne środowiskowe i inne ustawienia.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>Wydarzenie</summary>

**Wydarzenia** to wyzwalacze, które uruchamiają Twoje funkcje serverless. Określają, jak i kiedy funkcja powinna być wykonywana.

Typowe rodzaje wydarzeń to żądania HTTP, zaplanowane wydarzenia (zadania cron), wydarzenia z bazy danych, przesyłanie plików i inne.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>Zasób</summary>

**Zasoby** pozwalają na zdefiniowanie dodatkowych zasobów chmurowych, od których zależy Twoja usługa, takich jak bazy danych, kosze pamięci lub role IAM.

Są one określane w sekcji `resources`, często używając składni CloudFormation dla AWS.
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>Dostawca</summary>

Obiekt **Dostawca** określa dostawcę usług chmurowych (np. AWS, Azure, Google Cloud) i zawiera ustawienia konfiguracyjne istotne dla tego dostawcy.

Zawiera szczegóły takie jak czas wykonania, region, etap i dane uwierzytelniające.
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>Etap i Region</summary>

Etap reprezentuje różne środowiska (np. rozwój, staging, produkcja), w których Twoja usługa może być wdrożona. Umożliwia to konfiguracje i wdrożenia specyficzne dla środowiska.
```yaml
provider:
stage: dev
```
Region określa geograficzny obszar, w którym Twoje zasoby będą wdrażane. Jest to ważne z uwagi na opóźnienia, zgodność i dostępność.
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Wtyczki</summary>

**Wtyczki** rozszerzają funkcjonalność Serverless Framework, dodając nowe funkcje lub integrując się z innymi narzędziami i usługami. Są definiowane w sekcji `plugins` i instalowane za pomocą npm.
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>Warstwy</summary>

**Warstwy** pozwalają na pakowanie i zarządzanie wspólnym kodem lub zależnościami oddzielnie od twoich funkcji. To promuje ponowne użycie i zmniejsza rozmiary pakietów wdrożeniowych. Są definiowane w sekcji `layers` i są odniesione przez funkcje.
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>Zmienne i Zmienne Niestandardowe</summary>

**Zmienne** umożliwiają dynamiczną konfigurację, pozwalając na użycie miejsc zastępczych, które są rozwiązywane w czasie wdrażania.

- **Składnia:** składnia `${variable}` może odnosić się do zmiennych środowiskowych, zawartości plików lub innych parametrów konfiguracyjnych.

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **Zmienne Niestandardowe:** sekcja `custom` jest używana do definiowania zmiennych i konfiguracji specyficznych dla użytkownika, które mogą być ponownie używane w całym pliku `serverless.yml`.

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>Wyjścia</summary>

**Wyjścia** definiują wartości, które są zwracane po wdrożeniu usługi, takie jak ARNy zasobów, punkty końcowe lub inne przydatne informacje. Są one określone w sekcji `outputs` i często używane do udostępniania informacji innym usługom lub do łatwego dostępu po wdrożeniu.
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>Role i uprawnienia IAM</summary>

**Role i uprawnienia IAM** definiują dane uwierzytelniające bezpieczeństwa i prawa dostępu do Twoich funkcji i innych zasobów. Są zarządzane w ramach ustawień `provider` lub indywidualnych funkcji, aby określić niezbędne uprawnienia.
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>Zmienne Środowiskowe</summary>

**Zmienne** pozwalają na przekazywanie ustawień konfiguracyjnych i sekretów do twoich funkcji bez ich twardego kodowania. Są definiowane w sekcji `environment` dla dostawcy lub poszczególnych funkcji.
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Zależności</summary>

**Zależności** zarządzają zewnętrznymi bibliotekami i modułami, których potrzebują Twoje funkcje. Zazwyczaj są obsługiwane za pomocą menedżerów pakietów, takich jak npm lub pip, i pakowane z Twoim pakietem wdrożeniowym przy użyciu narzędzi lub wtyczek, takich jak `serverless-webpack`.
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>Hooks</summary>

**Hooks** pozwalają na uruchamianie niestandardowych skryptów lub poleceń w określonych punktach cyklu życia wdrożenia. Są definiowane za pomocą wtyczek lub w pliku `serverless.yml`, aby wykonywać akcje przed lub po wdrożeniach.
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

To jest podsumowanie oficjalnego tutorialu [**z dokumentacji**](https://www.serverless.com/framework/docs/tutorial):

1. Utwórz konto AWS (Serverless.com zaczyna w infrastrukturze AWS)
2. Utwórz konto w serverless.com
3. Utwórz aplikację:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
To powinno stworzyć **aplikację** o nazwie `tutorialapp`, którą możesz sprawdzić w [serverless.com](serverless.com-security.md) oraz folder o nazwie `Tutorial` z plikiem **`handler.js`** zawierającym kod JS z kodem `helloworld` oraz plikiem **`serverless.yml`** deklarującym tę funkcję:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. Utwórz dostawcę AWS, przechodząc do **dashboardu** w `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`.
1. Aby dać `serverless.com` dostęp do AWS, poprosi o uruchomienie stosu cloudformation przy użyciu tego pliku konfiguracyjnego (w momencie pisania tego tekstu): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. Ten szablon generuje rolę o nazwie **`SFRole-<ID>`** z **`arn:aws:iam::aws:policy/AdministratorAccess`** dla konta z tożsamością zaufania, która pozwala na dostęp do roli konta `Serverless.com` AWS.

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>Relacja zaufania</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. Tutorial prosi o utworzenie pliku `createCustomer.js`, który zasadniczo utworzy nowy punkt końcowy API obsługiwany przez nowy plik JS i prosi o modyfikację pliku `serverless.yml`, aby wygenerować **nową tabelę DynamoDB**, zdefiniować **zmienną środowiskową**, rolę, która będzie używać wygenerowanych lambd.

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. Wdróż to, uruchamiając **`serverless deploy`**
1. Wdrożenie zostanie przeprowadzone za pomocą CloudFormation Stack
2. Zauważ, że **lambdy są udostępniane za pośrednictwem API gateway** a nie za pomocą bezpośrednich URL-i
7. **Przetestuj to**
1. Poprzedni krok wydrukuje **URL-e**, gdzie Twoje funkcje lambda punktów końcowych API zostały wdrożone

## Przegląd bezpieczeństwa Serverless.com

### **Źle skonfigurowane role IAM i uprawnienia**

Zbyt szerokie role IAM mogą przyznać nieautoryzowany dostęp do zasobów chmurowych, prowadząc do naruszeń danych lub manipulacji zasobami.

Gdy nie określono uprawnień dla funkcji Lambda, zostanie utworzona rola z uprawnieniami tylko do generowania logów, jak:

<details>

<summary>Minimalne uprawnienia lambda</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **Strategie łagodzenia**

- **Zasada najmniejszych uprawnień:** Przydzielaj tylko niezbędne uprawnienia do każdej funkcji.

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **Używaj oddzielnych ról:** Rozróżniaj role w zależności od wymagań funkcji.

---

### **Niebezpieczne sekrety i zarządzanie konfiguracją**

Przechowywanie wrażliwych informacji (np. kluczy API, poświadczeń bazy danych) bezpośrednio w **`serverless.yml`** lub kodzie może prowadzić do ujawnienia, jeśli repozytoria zostaną skompromitowane.

Zalecanym sposobem przechowywania zmiennych środowiskowych w pliku **`serverless.yml`** z serverless.com (w momencie pisania tego tekstu) jest użycie dostawców `ssm` lub `s3`, co pozwala na pobranie **wartości środowiskowych z tych źródeł w czasie wdrażania** i **konfigurowanie** zmiennych środowiskowych **lambdas** z **czystym tekstem wartości**!

> [!OSTRZEŻENIE]
> Dlatego każdy, kto ma uprawnienia do odczytu konfiguracji lambdas w AWS, będzie mógł **uzyskać dostęp do wszystkich tych zmiennych środowiskowych w czystym tekście!**

Na przykład, poniższy przykład użyje SSM do pobrania zmiennej środowiskowej:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
I nawet jeśli to zapobiega twardemu kodowaniu wartości zmiennej środowiskowej w pliku **`serverless.yml`**, wartość ta zostanie uzyskana w czasie wdrażania i będzie **dodana w postaci czystego tekstu wewnątrz zmiennej środowiskowej lambda**.

> [!TIP]
> Zalecanym sposobem przechowywania zmiennych środowiskowych przy użyciu serveless.com byłoby **przechowywanie ich w tajemnicy AWS** i po prostu przechowywanie nazwy tajemnicy w zmiennej środowiskowej, a **kod lambda powinien ją zebrać**.

#### **Strategie łagodzenia**

- **Integracja z Menedżerem Tajemnic:** Użyj usług takich jak **AWS Secrets Manager.**
- **Szyfrowane Zmienne:** Wykorzystaj funkcje szyfrowania Frameworka Serverless dla wrażliwych danych.
- **Kontrola Dostępu:** Ogranicz dostęp do tajemnic w oparciu o role.

---

### **Wrażliwy Kod i Zależności**

Nieaktualne lub niebezpieczne zależności mogą wprowadzać luki, podczas gdy niewłaściwe przetwarzanie danych wejściowych może prowadzić do ataków typu injection.

#### **Strategie łagodzenia**

- **Zarządzanie Zależnościami:** Regularnie aktualizuj zależności i skanuj pod kątem luk.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Walidacja Danych Wejściowych:** Wprowadź ścisłą walidację i sanitację wszystkich danych wejściowych.
- **Przeglądy Kodu:** Przeprowadzaj dokładne przeglądy, aby zidentyfikować wady bezpieczeństwa.
- **Analiza Statyczna:** Użyj narzędzi do wykrywania luk w kodzie.

---

### **Niewystarczające Logowanie i Monitorowanie**

Bez odpowiedniego logowania i monitorowania, złośliwe działania mogą pozostać niezauważone, opóźniając reakcję na incydenty.

#### **Strategie łagodzenia**

- **Centralne Logowanie:** Agreguj logi za pomocą usług takich jak **AWS CloudWatch** lub **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Włącz Szczegółowe Logowanie:** Zbieraj istotne informacje bez ujawniania wrażliwych danych.
- **Ustaw Powiadomienia:** Skonfiguruj powiadomienia o podejrzanych działaniach lub anomaliach.
- **Regularne Monitorowanie:** Ciągłe monitorowanie logów i metryk w poszukiwaniu potencjalnych incydentów bezpieczeństwa.

---

### **Niezabezpieczone Konfiguracje API Gateway**

Otwarte lub niewłaściwie zabezpieczone API mogą być wykorzystywane do nieautoryzowanego dostępu, ataków typu Denial of Service (DoS) lub ataków między witrynami.

#### **Strategie łagodzenia**

- **Uwierzytelnianie i Autoryzacja:** Wprowadź solidne mechanizmy, takie jak OAuth, klucze API lub JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Ograniczenie Ruchu i Throttling:** Zapobiegaj nadużyciom, ograniczając tempo żądań.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Zabezpieczona Konfiguracja CORS:** Ogranicz dozwolone źródła, metody i nagłówki.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Użyj Zapór Aplikacji Webowych (WAF):** Filtruj i monitoruj żądania HTTP w poszukiwaniu złośliwych wzorców.

---

### **Niewystarczająca Izolacja Funkcji**

Wspólne zasoby i niewystarczająca izolacja mogą prowadzić do eskalacji uprawnień lub niezamierzonych interakcji między funkcjami.

#### **Strategie łagodzenia**

- **Izoluj Funkcje:** Przypisz odrębne zasoby i role IAM, aby zapewnić niezależne działanie.
- **Podział Zasobów:** Użyj oddzielnych baz danych lub koszyków do przechowywania dla różnych funkcji.
- **Użyj VPC:** Wdrażaj funkcje w Wirtualnych Prywatnych Chmurach dla lepszej izolacji sieci.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **Ogranicz Uprawnienia Funkcji:** Upewnij się, że funkcje nie mogą uzyskiwać dostępu do zasobów innych funkcji, chyba że jest to wyraźnie wymagane.

---

### **Niewystarczająca Ochrona Danych**

Niezaszyfrowane dane w spoczynku lub w tranzycie mogą być narażone, prowadząc do naruszeń danych lub manipulacji.

#### **Strategie łagodzenia**

- **Szyfruj Dane w Spoczynku:** Wykorzystaj funkcje szyfrowania usług chmurowych.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **Szyfruj Dane w Tranzycie:** Użyj HTTPS/TLS dla wszystkich transmisji danych.
- **Zabezpiecz Komunikację API:** Wymuszaj protokoły szyfrowania i weryfikuj certyfikaty.
- **Zarządzaj Kluczami Szyfrującymi Bezpiecznie:** Użyj zarządzanych usług kluczy i regularnie rotuj klucze.

---

### **Brak Odpowiedniego Obsługi Błędów**

Szczegółowe komunikaty o błędach mogą ujawniać wrażliwe informacje o infrastrukturze lub kodzie, podczas gdy nieobsługiwane wyjątki mogą prowadzić do awarii aplikacji.

#### **Strategie łagodzenia**

- **Ogólne Komunikaty o Błędach:** Unikaj ujawniania wewnętrznych szczegółów w odpowiedziach o błędach.

```javascript
javascriptCopy code// Przykład w Node.js
exports.hello = async (event) => {
try {
// Logika funkcji
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```

- **Centralna Obsługa Błędów:** Zarządzaj i sanitizuj błędy konsekwentnie w wszystkich funkcjach.
- **Monitoruj i Loguj Błędy:** Śledź i analizuj błędy wewnętrznie, nie ujawniając szczegółów użytkownikom końcowym.

---

### **Niezabezpieczone Praktyki Wdrażania**

Ujawniłe konfiguracje wdrożeniowe lub nieautoryzowany dostęp do pipeline'ów CI/CD mogą prowadzić do złośliwych wdrożeń kodu lub błędnych konfiguracji.

#### **Strategie łagodzenia**

- **Zabezpiecz Pipeline'y CI/CD:** Wprowadź ścisłe kontrole dostępu, uwierzytelnianie wieloskładnikowe (MFA) i regularne audyty.
- **Przechowuj Konfigurację Bezpiecznie:** Utrzymuj pliki wdrożeniowe wolne od twardo zakodowanych tajemnic i wrażliwych danych.
- **Użyj Narzędzi Bezpieczeństwa Infrastruktury jako Kodu (IaC):** Wykorzystaj narzędzia takie jak **Checkov** lub **Terraform Sentinel** do egzekwowania polityk bezpieczeństwa.
- **Niezmienne Wdrożenia:** Zapobiegaj nieautoryzowanym zmianom po wdrożeniu, przyjmując praktyki niezmiennej infrastruktury.

---

### **Luki w Wtyczkach i Rozszerzeniach**

Używanie nieweryfikowanych lub złośliwych wtyczek stron trzecich może wprowadzać luki do aplikacji serverless.

#### **Strategie łagodzenia**

- **Dokładnie Weryfikuj Wtyczki:** Oceń bezpieczeństwo wtyczek przed integracją, preferując te z wiarygodnych źródeł.
- **Ogranicz Użycie Wtyczek:** Używaj tylko niezbędnych wtyczek, aby zminimalizować powierzchnię ataku.
- **Monitoruj Aktualizacje Wtyczek:** Utrzymuj wtyczki zaktualizowane, aby korzystać z poprawek bezpieczeństwa.
- **Izoluj Środowiska Wtyczek:** Uruchamiaj wtyczki w izolowanych środowiskach, aby ograniczyć potencjalne kompromitacje.

---

### **Ujawnienie Wrażliwych Punktów Końcowych**

Funkcje dostępne publicznie lub nieograniczone API mogą być wykorzystywane do nieautoryzowanych operacji.

#### **Strategie łagodzenia**

- **Ogranicz Dostęp do Funkcji:** Użyj VPC, grup zabezpieczeń i reguł zapory, aby ograniczyć dostęp do zaufanych źródeł.
- **Wprowadź Solidne Uwierzytelnianie:** Upewnij się, że wszystkie ujawnione punkty końcowe wymagają odpowiedniego uwierzytelnienia i autoryzacji.
- **Bezpiecznie Używaj Bramek API:** Skonfiguruj bramki API, aby egzekwować polityki bezpieczeństwa, w tym walidację danych wejściowych i ograniczenie tempa.
- **Wyłącz Nieużywane Punkty Końcowe:** Regularnie przeglądaj i wyłączaj wszelkie punkty końcowe, które nie są już używane.

---

### **Nadmierne Uprawnienia dla Członków Zespołu i Zewnętrznych Współpracowników**

Przyznawanie nadmiernych uprawnień członkom zespołu i zewnętrznym współpracownikom może prowadzić do nieautoryzowanego dostępu, naruszeń danych i nadużyć zasobów. Ryzyko to wzrasta w środowiskach, w których wiele osób ma różne poziomy dostępu, zwiększając powierzchnię ataku i potencjał zagrożeń wewnętrznych.

#### **Strategie łagodzenia**

- **Zasada Najmniejszych Uprawnień:** Upewnij się, że członkowie zespołu i współpracownicy mają tylko te uprawnienia, które są niezbędne do wykonywania swoich zadań.

---

### **Bezpieczeństwo Kluczy Dostępu i Kluczy Licencyjnych**

**Klucze Dostępu** i **Klucze Licencyjne** to krytyczne poświadczenia używane do uwierzytelniania i autoryzacji interakcji z interfejsem CLI Frameworka Serverless.

- **Klucze Licencyjne:** To unikalne identyfikatory wymagane do uwierzytelnienia dostępu do Frameworka Serverless Wersja 4, które umożliwiają logowanie przez CLI.
- **Klucze Dostępu:** Poświadczenia, które pozwalają interfejsowi CLI Frameworka Serverless uwierzytelnić się z Dashboardem Frameworka Serverless. Podczas logowania za pomocą `serverless` cli klucz dostępu zostanie **wygenerowany i zapisany na laptopie**. Możesz również ustawić go jako zmienną środowiskową o nazwie `SERVERLESS_ACCESS_KEY`.

#### **Ryzyka Bezpieczeństwa**

1. **Ujawnienie przez Repozytoria Kodów:**
- Twarde kodowanie lub przypadkowe zatwierdzenie Kluczy Dostępu i Kluczy Licencyjnych do systemów kontroli wersji może prowadzić do nieautoryzowanego dostępu.
2. **Niezabezpieczone Przechowywanie:**
- Przechowywanie kluczy w postaci tekstu jawnego w zmiennych środowiskowych lub plikach konfiguracyjnych bez odpowiedniego szyfrowania zwiększa prawdopodobieństwo wycieku.
3. **Niewłaściwa Dystrybucja:**
- Udostępnianie kluczy przez niezabezpieczone kanały (np. e-mail, czat) może skutkować ich przechwyceniem przez złośliwych aktorów.
4. **Brak Rotacji:**
- Nieregularna rotacja kluczy wydłuża okres narażenia, jeśli klucze zostaną skompromitowane.
5. **Nadmierne Uprawnienia:**
- Klucze z szerokimi uprawnieniami mogą być wykorzystywane do wykonywania nieautoryzowanych działań w wielu zasobach.

{{#include ../banners/hacktricks-training.md}}
