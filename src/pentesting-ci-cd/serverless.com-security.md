# Serverless.com Security

{{#include ../banners/hacktricks-training.md}}

## Basic Information

### Organization

**Організація** - це найвищий рівень сутності в екосистемі Serverless Framework. Вона представляє **колективну групу**, таку як компанія, відділ або будь-яка велика сутність, яка охоплює кілька проектів, команд і додатків.

### Team

**Команда** - це користувачі з доступом всередині організації. Команди допомагають організувати учасників на основі ролей. **`Співпрацівники`** можуть переглядати та розгортати існуючі додатки, тоді як **`Адміністратори`** можуть створювати нові додатки та керувати налаштуваннями організації.

### Application

**Додаток** - це логічна група пов'язаних сервісів в організації. Він представляє собою повний додаток, що складається з кількох безсерверних сервісів, які працюють разом для забезпечення єдиної функціональності.

### **Services**

**Сервіс** - це основний компонент безсерверного додатку. Він представляє ваш весь безсерверний проект, інкапсулюючи всі функції, конфігурації та ресурси, які потрібні. Зазвичай він визначається у файлі `serverless.yml`, сервіс включає метадані, такі як назва сервісу, конфігурації постачальника, функції, події, ресурси, плагіни та користувацькі змінні.
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Функція</summary>

**Функція** представляє собою одну безсерверну функцію, таку як функція AWS Lambda. Вона містить код, який виконується у відповідь на події.

Вона визначається в секції `functions` у `serverless.yml`, вказуючи обробник, середовище виконання, події, змінні середовища та інші налаштування.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>Подія</summary>

**Події** - це тригери, які викликають ваші безсерверні функції. Вони визначають, як і коли функція повинна бути виконана.

Звичайні типи подій включають HTTP запити, заплановані події (cron jobs), події бази даних, завантаження файлів та інше.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>Ресурс</summary>

**Ресурси** дозволяють вам визначити додаткові хмарні ресурси, від яких залежить ваша служба, такі як бази даних, сховища або ролі IAM.

Вони вказуються в секції `resources`, часто використовуючи синтаксис CloudFormation для AWS.
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>Постачальник</summary>

Об'єкт **Постачальник** вказує на постачальника хмарних послуг (наприклад, AWS, Azure, Google Cloud) і містить налаштування конфігурації, що стосуються цього постачальника.

Він включає деталі, такі як середовище виконання, регіон, етап і облікові дані.
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>Стадія та Регіон</summary>

Стадія представляє різні середовища (наприклад, розробка, тестування, продуктивність), де ваш сервіс може бути розгорнутий. Це дозволяє налаштовувати та розгортати специфічні для середовища конфігурації.
```yaml
provider:
stage: dev
```
Регіон вказує географічний регіон, де будуть розгорнуті ваші ресурси. Це важливо для затримки, відповідності та доступності.
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Плагіни</summary>

**Плагіни** розширюють функціональність Serverless Framework, додаючи нові можливості або інтегруючись з іншими інструментами та сервісами. Вони визначені в секції `plugins` і встановлюються через npm.
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>Шари</summary>

**Шари** дозволяють вам упакувати та керувати спільним кодом або залежностями окремо від ваших функцій. Це сприяє повторному використанню та зменшує розміри пакетів розгортання. Вони визначаються в секції `layers` і посилаються на функції.
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>Змінні та Користувацькі Змінні</summary>

**Змінні** дозволяють динамічну конфігурацію, дозволяючи використовувати заповнювачі, які вирішуються під час розгортання.

- **Синтаксис:** `${variable}` синтаксис може посилатися на змінні середовища, вміст файлів або інші параметри конфігурації.

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **Користувацькі Змінні:** Розділ `custom` використовується для визначення змінних та конфігурацій, специфічних для користувача, які можуть бути повторно використані в `serverless.yml`.

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>Виходи</summary>

**Виходи** визначають значення, які повертаються після розгортання служби, такі як ARNs ресурсів, кінцеві точки або інша корисна інформація. Вони вказуються в розділі `outputs` і часто використовуються для надання інформації іншим службам або для легкого доступу після розгортання.
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAM Ролі та Дозволи</summary>

**IAM Ролі та Дозволи** визначають безпекові облікові дані та права доступу для ваших функцій та інших ресурсів. Вони керуються під `provider` або налаштуваннями окремих функцій для визначення необхідних дозволів.
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>Змінні середовища</summary>

**Змінні** дозволяють передавати налаштування конфігурації та секрети вашим функціям без їх жорсткого кодування. Вони визначаються в секції `environment` для постачальника або окремих функцій.
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Залежності</summary>

**Залежності** керують зовнішніми бібліотеками та модулями, які потрібні вашим функціям. Вони зазвичай обробляються за допомогою менеджерів пакетів, таких як npm або pip, і упаковуються з вашим пакетом розгортання за допомогою інструментів або плагінів, таких як `serverless-webpack`.
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>Hooks</summary>

**Hooks** дозволяють вам виконувати власні скрипти або команди в певні моменти життєвого циклу розгортання. Вони визначаються за допомогою плагінів або в `serverless.yml`, щоб виконувати дії до або після розгортань.
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

Це резюме офіційного навчального посібника [**з документації**](https://www.serverless.com/framework/docs/tutorial):

1. Створіть обліковий запис AWS (Serverless.com починається в інфраструктурі AWS)
2. Створіть обліковий запис на serverless.com
3. Створіть додаток:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
Це повинно було створити **app** під назвою `tutorialapp`, який ви можете перевірити на [serverless.com](serverless.com-security.md), і папку під назвою `Tutorial` з файлом **`handler.js`**, що містить деякий JS код з кодом `helloworld`, та файлом **`serverless.yml`**, що оголошує цю функцію:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. Створіть постачальника AWS, перейшовши в **панель управління** за адресою `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`.
1. Щоб надати `serverless.com` доступ до AWS, буде запропоновано запустити стек cloudformation, використовуючи цей конфігураційний файл (на момент написання): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. Цей шаблон генерує роль під назвою **`SFRole-<ID>`** з **`arn:aws:iam::aws:policy/AdministratorAccess`** для облікового запису з довірчою ідентичністю, яка дозволяє обліковому запису `Serverless.com` AWS отримати доступ до ролі.

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>Взаємовідносини довіри</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. У навчальному посібнику пропонується створити файл `createCustomer.js`, який в основному створить нову точку доступу API, оброблену новим JS файлом, і пропонується змінити файл `serverless.yml`, щоб він генерував **нову таблицю DynamoDB**, визначав **змінну середовища**, роль, яка буде використовувати згенеровані лямбди.

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. Розгорніть його, запустивши **`serverless deploy`**
1. Розгортання буде виконано через CloudFormation Stack
2. Зверніть увагу, що **lambdas доступні через API gateway** і не через прямі URL
7. **Протестуйте це**
1. Попередній крок виведе **URLs**, де ваші API endpoints lambda функції були розгорнуті

## Огляд безпеки Serverless.com

### **Неправильно налаштовані IAM ролі та дозволи**

Занадто широкі IAM ролі можуть надати несанкціонований доступ до ресурсів хмари, що призводить до витоків даних або маніпуляцій з ресурсами.

Коли для функції Lambda не вказані дозволи, буде створено роль з дозволами лише на генерацію журналів, наприклад:

<details>

<summary>Мінімальні дозволи lambda</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **Стратегії пом'якшення**

- **Принцип найменших привілеїв:** Призначайте лише необхідні дозволи для кожної функції.

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **Використовуйте окремі ролі:** Розрізняйте ролі на основі вимог функцій.

---

### **Небезпечні секрети та управління конфігурацією**

Зберігання чутливої інформації (наприклад, API ключів, облікових даних бази даних) безпосередньо в **`serverless.yml`** або коді може призвести до витоку, якщо репозиторії будуть скомпрометовані.

**Рекомендований** спосіб зберігання змінних середовища у файлі **`serverless.yml`** від serverless.com (на момент написання цього тексту) - це використання постачальників `ssm` або `s3`, які дозволяють отримувати **значення середовища з цих джерел під час розгортання** та **конфігурувати** змінні середовища **lambdas** з **текстом без значень**!

> [!CAUTION]
> Тому будь-хто з дозволами на читання конфігурації lambdas в AWS зможе **отримати доступ до всіх цих змінних середовища у відкритому тексті!**

Наприклад, наступний приклад використовуватиме SSM для отримання змінної середовища:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
And even if this prevents hardcoding the environment variable value in the **`serverless.yml`** file, the value will be obtained at deployment time and will be **додано у відкритому тексті всередині змінної середовища lambda**.

> [!TIP]
> The recommended way to store environment variables using serveless.com would be to **зберігати його в AWS secret** and just store the secret name in the environment variable and the **код lambda повинен його зібрати**.

#### **Mitigation Strategies**

- **Secrets Manager Integration:** Use services like **AWS Secrets Manager.**
- **Encrypted Variables:** Leverage Serverless Framework’s encryption features for sensitive data.
- **Access Controls:** Restrict access to secrets based on roles.

---

### **Vulnerable Code and Dependencies**

Outdated or insecure dependencies can introduce vulnerabilities, while improper input handling may lead to code injection attacks.

#### **Mitigation Strategies**

- **Dependency Management:** Regularly update dependencies and scan for vulnerabilities.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Input Validation:** Implement strict validation and sanitization of all inputs.
- **Code Reviews:** Conduct thorough reviews to identify security flaws.
- **Static Analysis:** Use tools to detect vulnerabilities in the codebase.

---

### **Inadequate Logging and Monitoring**

Without proper logging and monitoring, malicious activities may go undetected, delaying incident response.

#### **Mitigation Strategies**

- **Centralized Logging:** Aggregate logs using services like **AWS CloudWatch** or **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Enable Detailed Logging:** Capture essential information without exposing sensitive data.
- **Set Up Alerts:** Configure alerts for suspicious activities or anomalies.
- **Regular Monitoring:** Continuously monitor logs and metrics for potential security incidents.

---

### **Insecure API Gateway Configurations**

Open or improperly secured APIs can be exploited for unauthorized access, Denial of Service (DoS) attacks, or cross-site attacks.

#### **Mitigation Strategies**

- **Authentication and Authorization:** Implement robust mechanisms like OAuth, API keys, or JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Rate Limiting and Throttling:** Prevent abuse by limiting request rates.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Secure CORS Configuration:** Restrict allowed origins, methods, and headers.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Use Web Application Firewalls (WAF):** Filter and monitor HTTP requests for malicious patterns.

---

### **Insufficient Function Isolation**

Shared resources and inadequate isolation can lead to privilege escalations or unintended interactions between functions.

#### **Mitigation Strategies**

- **Isolate Functions:** Assign distinct resources and IAM roles to ensure independent operation.
- **Resource Partitioning:** Use separate databases or storage buckets for different functions.
- **Use VPCs:** Deploy functions within Virtual Private Clouds for enhanced network isolation.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **Limit Function Permissions:** Ensure functions cannot access or interfere with each other’s resources unless explicitly required.

---

### **Inadequate Data Protection**

Unencrypted data at rest or in transit can be exposed, leading to data breaches or tampering.

#### **Mitigation Strategies**

- **Encrypt Data at Rest:** Utilize cloud service encryption features.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **Encrypt Data in Transit:** Use HTTPS/TLS for all data transmissions.
- **Secure API Communication:** Enforce encryption protocols and validate certificates.
- **Manage Encryption Keys Securely:** Use managed key services and rotate keys regularly.

---

### **Lack of Proper Error Handling**

Detailed error messages can leak sensitive information about the infrastructure or codebase, while unhandled exceptions may lead to application crashes.

#### **Mitigation Strategies**

- **Generic Error Messages:** Avoid exposing internal details in error responses.

```javascript
javascriptCopy code// Example in Node.js
exports.hello = async (event) => {
try {
// Function logic
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```

- **Centralized Error Handling:** Manage and sanitize errors consistently across all functions.
- **Monitor and Log Errors:** Track and analyze errors internally without exposing details to end-users.

---

### **Insecure Deployment Practices**

Exposed deployment configurations or unauthorized access to CI/CD pipelines can lead to malicious code deployments or misconfigurations.

#### **Mitigation Strategies**

- **Secure CI/CD Pipelines:** Implement strict access controls, multi-factor authentication (MFA), and regular audits.
- **Store Configuration Securely:** Keep deployment files free from hardcoded secrets and sensitive data.
- **Use Infrastructure as Code (IaC) Security Tools:** Employ tools like **Checkov** or **Terraform Sentinel** to enforce security policies.
- **Immutable Deployments:** Prevent unauthorized changes post-deployment by adopting immutable infrastructure practices.

---

### **Vulnerabilities in Plugins and Extensions**

Using unvetted or malicious third-party plugins can introduce vulnerabilities into your serverless applications.

#### **Mitigation Strategies**

- **Vet Plugins Thoroughly:** Assess the security of plugins before integration, favoring those from reputable sources.
- **Limit Plugin Usage:** Use only necessary plugins to minimize the attack surface.
- **Monitor Plugin Updates:** Keep plugins updated to benefit from security patches.
- **Isolate Plugin Environments:** Run plugins in isolated environments to contain potential compromises.

---

### **Exposure of Sensitive Endpoints**

Publicly accessible functions or unrestricted APIs can be exploited for unauthorized operations.

#### **Mitigation Strategies**

- **Restrict Function Access:** Use VPCs, security groups, and firewall rules to limit access to trusted sources.
- **Implement Robust Authentication:** Ensure all exposed endpoints require proper authentication and authorization.
- **Use API Gateways Securely:** Configure API Gateways to enforce security policies, including input validation and rate limiting.
- **Disable Unused Endpoints:** Regularly review and disable any endpoints that are no longer in use.

---

### **Excessive Permissions for Team Members and External Collaborators**

Granting excessive permissions to team members and external collaborators can lead to unauthorized access, data breaches, and misuse of resources. This risk is heightened in environments where multiple individuals have varying levels of access, increasing the attack surface and potential for insider threats.

#### **Mitigation Strategies**

- **Principle of Least Privilege:** Ensure that team members and collaborators have only the permissions necessary to perform their tasks.

---

### **Access Keys and License Keys Security**

**Access Keys** and **License Keys** are critical credentials used to authenticate and authorize interactions with the Serverless Framework CLI.

- **License Keys:** Вони є унікальними ідентифікаторами, необхідними для аутентифікації доступу до Serverless Framework Version 4, що дозволяє входити через CLI.
- **Access Keys:** Облікові дані, які дозволяють CLI Serverless Framework аутентифікуватися з панеллю управління Serverless Framework. Коли ви входите за допомогою `serverless` cli, ключ доступу буде **згенеровано та збережено на ноутбуці**. Ви також можете встановити його як змінну середовища з назвою `SERVERLESS_ACCESS_KEY`.

#### **Security Risks**

1. **Exposure Through Code Repositories:**
- Hardcoding or accidentally committing Access Keys and License Keys to version control systems can lead to unauthorized access.
2. **Insecure Storage:**
- Storing keys in plaintext within environment variables or configuration files without proper encryption increases the likelihood of leakage.
3. **Improper Distribution:**
- Sharing keys through unsecured channels (e.g., email, chat) can result in interception by malicious actors.
4. **Lack of Rotation:**
- Not regularly rotating keys extends the exposure period if keys are compromised.
5. **Excessive Permissions:**
- Keys with broad permissions can be exploited to perform unauthorized actions across multiple resources.

{{#include ../banners/hacktricks-training.md}}
