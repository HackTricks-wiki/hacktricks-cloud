# Serverless.com सुरक्षा

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

### संगठन

एक **संगठन** Serverless Framework पारिस्थितिकी तंत्र के भीतर उच्चतम स्तर की इकाई है। यह एक **सामूहिक समूह** का प्रतिनिधित्व करता है, जैसे कि एक कंपनी, विभाग, या कोई बड़ा संगठन, जो कई परियोजनाओं, टीमों और अनुप्रयोगों को समाहित करता है।

### टीम

**टीम** वे उपयोगकर्ता हैं जिनके पास संगठन के भीतर पहुंच है। टीमें सदस्यों को भूमिकाओं के आधार पर व्यवस्थित करने में मदद करती हैं। **`सहयोगी`** मौजूदा ऐप्स को देख और तैनात कर सकते हैं, जबकि **`व्यवस्थापक`** नए ऐप्स बना सकते हैं और संगठन की सेटिंग्स प्रबंधित कर सकते हैं।

### अनुप्रयोग

एक **ऐप** एक संगठन के भीतर संबंधित सेवाओं का तार्किक समूह है। यह कई सर्वरलेस सेवाओं से मिलकर बना एक पूर्ण अनुप्रयोग का प्रतिनिधित्व करता है जो एक साथ मिलकर एक समग्र कार्यक्षमता प्रदान करता है।

### **सेवाएँ**

एक **सेवा** एक सर्वरलेस अनुप्रयोग का मुख्य घटक है। यह आपके पूरे सर्वरलेस प्रोजेक्ट का प्रतिनिधित्व करता है, जिसमें सभी कार्य, कॉन्फ़िगरेशन और आवश्यक संसाधन शामिल होते हैं। यह आमतौर पर `serverless.yml` फ़ाइल में परिभाषित किया जाता है, एक सेवा में सेवा का नाम, प्रदाता कॉन्फ़िगरेशन, कार्य, घटनाएँ, संसाधन, प्लगइन्स, और कस्टम वेरिएबल्स जैसी मेटाडेटा शामिल होती है।
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>कार्य</summary>

A **Function** एक एकल सर्वरलेस फ़ंक्शन का प्रतिनिधित्व करता है, जैसे कि एक AWS Lambda फ़ंक्शन। इसमें वह कोड होता है जो घटनाओं के जवाब में निष्पादित होता है।

यह `serverless.yml` में `functions` अनुभाग के तहत परिभाषित किया गया है, जिसमें हैंडलर, रनटाइम, घटनाएँ, पर्यावरण चर, और अन्य सेटिंग्स निर्दिष्ट की गई हैं।
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>इवेंट</summary>

**इवेंट** आपके सर्वरलेस फ़ंक्शंस को सक्रिय करने वाले ट्रिगर्स हैं। वे यह परिभाषित करते हैं कि एक फ़ंक्शन को कब और कैसे निष्पादित किया जाना चाहिए।

सामान्य इवेंट प्रकारों में HTTP अनुरोध, अनुसूचित इवेंट (क्रॉन जॉब), डेटाबेस इवेंट, फ़ाइल अपलोड और अधिक शामिल हैं।
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>संसाधन</summary>

**संसाधन** आपको अतिरिक्त क्लाउड संसाधनों को परिभाषित करने की अनुमति देते हैं जिन पर आपकी सेवा निर्भर करती है, जैसे डेटाबेस, स्टोरेज बकेट, या IAM भूमिकाएँ।

इन्हें `resources` अनुभाग के तहत निर्दिष्ट किया जाता है, अक्सर AWS के लिए CloudFormation सिंटैक्स का उपयोग करते हुए।
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>प्रदाता</summary>

**प्रदाता** ऑब्जेक्ट क्लाउड सेवा प्रदाता (जैसे, AWS, Azure, Google Cloud) को निर्दिष्ट करता है और उस प्रदाता से संबंधित कॉन्फ़िगरेशन सेटिंग्स को शामिल करता है।

इसमें रनटाइम, क्षेत्र, चरण, और क्रेडेंशियल्स जैसी जानकारी शामिल है।
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>स्टेज और क्षेत्र</summary>

स्टेज विभिन्न वातावरणों का प्रतिनिधित्व करता है (जैसे, विकास, स्टेजिंग, उत्पादन) जहाँ आपकी सेवा को तैनात किया जा सकता है। यह वातावरण-विशिष्ट कॉन्फ़िगरेशन और तैनाती की अनुमति देता है।
```yaml
provider:
stage: dev
```
क्षेत्र उस भौगोलिक क्षेत्र को निर्दिष्ट करता है जहाँ आपके संसाधन तैनात किए जाएंगे। यह विलंबता, अनुपालन और उपलब्धता के विचारों के लिए महत्वपूर्ण है।
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Plugins</summary>

**Plugins** Serverless Framework की कार्यक्षमता को नए फीचर्स जोड़कर या अन्य उपकरणों और सेवाओं के साथ एकीकृत करके बढ़ाते हैं। इन्हें `plugins` अनुभाग के तहत परिभाषित किया जाता है और npm के माध्यम से स्थापित किया जाता है।
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>परतें</summary>

**परतें** आपको साझा कोड या निर्भरताओं को आपके कार्यों से अलग पैकेज और प्रबंधित करने की अनुमति देती हैं। यह पुन: उपयोगिता को बढ़ावा देती है और तैनाती पैकेज के आकार को कम करती है। इन्हें `layers` अनुभाग के तहत परिभाषित किया जाता है और कार्यों द्वारा संदर्भित किया जाता है।
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>चर और कस्टम चर</summary>

**चर** गतिशील कॉन्फ़िगरेशन को सक्षम करते हैं, जिससे प्लेसहोल्डर्स का उपयोग किया जा सकता है जो तैनाती के समय हल होते हैं।

- **सिंटैक्स:** `${variable}` सिंटैक्स पर्यावरण चर, फ़ाइल सामग्री, या अन्य कॉन्फ़िगरेशन पैरामीटर को संदर्भित कर सकता है।

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **कस्टम चर:** `custom` अनुभाग का उपयोग उपयोगकर्ता-विशिष्ट चर और कॉन्फ़िगरेशन को परिभाषित करने के लिए किया जाता है जिन्हें `serverless.yml` में पुन: उपयोग किया जा सकता है।

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>आउटपुट</summary>

**आउटपुट** उन मानों को परिभाषित करते हैं जो एक सेवा के तैनात होने के बाद लौटाए जाते हैं, जैसे संसाधन ARN, एंडपॉइंट, या अन्य उपयोगी जानकारी। इन्हें `outputs` अनुभाग के तहत निर्दिष्ट किया जाता है और अक्सर अन्य सेवाओं के लिए जानकारी को उजागर करने या तैनाती के बाद आसान पहुँच के लिए उपयोग किया जाता है।
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAM भूमिकाएँ और अनुमतियाँ</summary>

**IAM भूमिकाएँ और अनुमतियाँ** आपके कार्यों और अन्य संसाधनों के लिए सुरक्षा क्रेडेंशियल्स और पहुँच अधिकारों को परिभाषित करती हैं। इन्हें आवश्यक अनुमतियों को निर्दिष्ट करने के लिए `provider` या व्यक्तिगत कार्य सेटिंग्स के अंतर्गत प्रबंधित किया जाता है।
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>पर्यावरण चर</summary>

**चर** आपको अपने कार्यों में कॉन्फ़िगरेशन सेटिंग्स और रहस्यों को हार्डकोड किए बिना पास करने की अनुमति देते हैं। इन्हें प्रदाता या व्यक्तिगत कार्यों के लिए `environment` अनुभाग के तहत परिभाषित किया जाता है।
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Dependencies</summary>

**Dependencies** आपके फ़ंक्शंस के लिए आवश्यक बाहरी पुस्तकालयों और मॉड्यूलों का प्रबंधन करते हैं। इन्हें आमतौर पर npm या pip जैसे पैकेज प्रबंधकों के माध्यम से संभाला जाता है, और `serverless-webpack` जैसे उपकरणों या प्लगइन्स का उपयोग करके आपके डिप्लॉयमेंट पैकेज के साथ बंडल किया जाता है।
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>हुक</summary>

**हुक** आपको परिनियोजन जीवनचक्र के विशिष्ट बिंदुओं पर कस्टम स्क्रिप्ट या कमांड चलाने की अनुमति देते हैं। उन्हें प्लगइन्स का उपयोग करके या `serverless.yml` के भीतर परिभाषित किया जाता है ताकि परिनियोजन से पहले या बाद में क्रियाएँ की जा सकें।
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### ट्यूटोरियल

यह आधिकारिक ट्यूटोरियल का सारांश है [**from the docs**](https://www.serverless.com/framework/docs/tutorial):

1. एक AWS खाता बनाएं (Serverless.com AWS अवसंरचना में शुरू होता है)
2. serverless.com में एक खाता बनाएं
3. एक ऐप बनाएं:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
यह एक **ऐप** `tutorialapp` बनाना चाहिए था जिसे आप [serverless.com](serverless.com-security.md) में देख सकते हैं और एक फ़ोल्डर `Tutorial` के साथ जिसमें **`handler.js`** फ़ाइल है जिसमें कुछ JS कोड है जिसमें `helloworld` कोड है और **`serverless.yml`** फ़ाइल है जो उस फ़ंक्शन की घोषणा करती है:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. एक AWS प्रदाता बनाएं, **डैशबोर्ड** में जाकर `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`।
1. `serverless.com` को AWS तक पहुंच देने के लिए यह इस कॉन्फ़िग फ़ाइल का उपयोग करके एक क्लाउडफॉर्मेशन स्टैक चलाने के लिए कहेगा (इस लेख के समय): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. यह टेम्पलेट **`SFRole-<ID>`** नामक एक भूमिका उत्पन्न करता है जिसमें **`arn:aws:iam::aws:policy/AdministratorAccess`** उस खाते पर है जिसमें एक ट्रस्ट पहचान है जो `Serverless.com` AWS खाते को भूमिका तक पहुंचने की अनुमति देती है।

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>विश्वास संबंध</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. ट्यूटोरियल में `createCustomer.js` फ़ाइल बनाने के लिए कहा गया है, जो मूल रूप से एक नया API एंडपॉइंट बनाएगा जिसे नए JS फ़ाइल द्वारा संभाला जाएगा और `serverless.yml` फ़ाइल को संशोधित करने के लिए कहा गया है ताकि यह एक **नया DynamoDB तालिका** उत्पन्न करे, एक **पर्यावरण चर** परिभाषित करे, और उस भूमिका को परिभाषित करे जो उत्पन्न लैंब्डा का उपयोग करेगी।

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. इसे चलाते हुए **`serverless deploy`** करें
1. तैनाती एक CloudFormation Stack के माध्यम से की जाएगी
2. ध्यान दें कि **lambdas API गेटवे के माध्यम से एक्सपोज़ किए गए हैं** और सीधे URLs के माध्यम से नहीं
7. **इसे परीक्षण करें**
1. पिछले चरण में **URLs** प्रिंट होंगे जहाँ आपके API एंडपॉइंट्स लैम्ब्डा फ़ंक्शंस तैनात किए गए हैं

## Serverless.com की सुरक्षा समीक्षा

### **गलत कॉन्फ़िगर किए गए IAM भूमिकाएँ और अनुमतियाँ**

अत्यधिक अनुमति देने वाली IAM भूमिकाएँ क्लाउड संसाधनों तक अनधिकृत पहुँच प्रदान कर सकती हैं, जिससे डेटा लीक या संसाधन हेरफेर हो सकता है।

जब किसी Lambda फ़ंक्शन के लिए कोई अनुमतियाँ निर्दिष्ट नहीं की जाती हैं, तो केवल लॉग उत्पन्न करने के लिए अनुमतियों के साथ एक भूमिका बनाई जाएगी, जैसे: 

<details>

<summary>न्यूनतम लैम्ब्डा अनुमतियाँ</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **निवारण रणनीतियाँ**

- **कम से कम विशेषाधिकार का सिद्धांत:** प्रत्येक फ़ंक्शन को केवल आवश्यक अनुमतियाँ सौंपें।

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **अलग-अलग भूमिकाएँ उपयोग करें:** फ़ंक्शन आवश्यकताओं के आधार पर भूमिकाओं में भिन्नता करें।

---

### **असुरक्षित रहस्य और कॉन्फ़िगरेशन प्रबंधन**

संवेदनशील जानकारी (जैसे, API कुंजी, डेटाबेस क्रेडेंशियल) को सीधे **`serverless.yml`** या कोड में संग्रहीत करने से जोखिम हो सकता है यदि रिपॉजिटरी से समझौता किया जाता है।

**`serverless.yml`** फ़ाइल में पर्यावरण चर को संग्रहीत करने का **सिफारिश की गई** विधि serverless.com से (इस लेख के समय) `ssm` या `s3` प्रदाताओं का उपयोग करना है, जो **तैनाती के समय इन स्रोतों से पर्यावरण मान प्राप्त करने** और **lambdas** पर्यावरण चर को **मानों के स्पष्ट पाठ के साथ कॉन्फ़िगर** करने की अनुमति देता है!

> [!CAUTION]
> इसलिए, AWS के अंदर lambdas कॉन्फ़िगरेशन को पढ़ने के लिए अनुमतियाँ रखने वाला कोई भी व्यक्ति **इन सभी पर्यावरण चर को स्पष्ट पाठ में एक्सेस कर सकेगा!**

उदाहरण के लिए, निम्नलिखित उदाहरण SSM का उपयोग करके एक पर्यावरण चर प्राप्त करेगा:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
और भले ही यह **`serverless.yml`** फ़ाइल में पर्यावरण चर मान को हार्डकोड करने से रोकता है, मान तैनाती के समय प्राप्त किया जाएगा और **लैम्ब्डा पर्यावरण चर के अंदर स्पष्ट पाठ में जोड़ा जाएगा**।

> [!TIP]
> serveless.com का उपयोग करके पर्यावरण चर को स्टोर करने का अनुशंसित तरीका **AWS सीक्रेट में स्टोर करना** होगा और बस पर्यावरण चर में सीक्रेट नाम को स्टोर करना और **लैम्ब्डा कोड को इसे इकट्ठा करना चाहिए**।

#### **निवारण रणनीतियाँ**

- **सीक्रेट्स मैनेजर इंटीग्रेशन:** **AWS Secrets Manager** जैसी सेवाओं का उपयोग करें।
- **एन्क्रिप्टेड वेरिएबल्स:** संवेदनशील डेटा के लिए Serverless Framework की एन्क्रिप्शन सुविधाओं का लाभ उठाएं।
- **एक्सेस कंट्रोल:** भूमिकाओं के आधार पर सीक्रेट्स तक पहुंच को प्रतिबंधित करें।

---

### **कमजोर कोड और निर्भरताएँ**

पुरानी या असुरक्षित निर्भरताएँ कमजोरियों को पेश कर सकती हैं, जबकि अनुचित इनपुट हैंडलिंग कोड इंजेक्शन हमलों का कारण बन सकती है।

#### **निवारण रणनीतियाँ**

- **निर्भरता प्रबंधन:** नियमित रूप से निर्भरताओं को अपडेट करें और कमजोरियों के लिए स्कैन करें।

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **इनपुट मान्यता:** सभी इनपुट की सख्त मान्यता और सफाई लागू करें।
- **कोड समीक्षाएँ:** सुरक्षा दोषों की पहचान के लिए गहन समीक्षाएँ करें।
- **स्टेटिक एनालिसिस:** कोडबेस में कमजोरियों का पता लगाने के लिए उपकरणों का उपयोग करें।

---

### **अपर्याप्त लॉगिंग और मॉनिटरिंग**

सही लॉगिंग और मॉनिटरिंग के बिना, दुर्भावनापूर्ण गतिविधियाँ अनदेखी रह सकती हैं, जिससे घटना प्रतिक्रिया में देरी हो सकती है।

#### **निवारण रणनीतियाँ**

- **केंद्रीकृत लॉगिंग:** **AWS CloudWatch** या **Datadog** जैसी सेवाओं का उपयोग करके लॉग को एकत्रित करें।

```yaml
plugins:
- serverless-plugin-datadog
```

- **विस्तृत लॉगिंग सक्षम करें:** संवेदनशील डेटा को उजागर किए बिना आवश्यक जानकारी कैप्चर करें।
- **अलर्ट सेट करें:** संदिग्ध गतिविधियों या विसंगतियों के लिए अलर्ट कॉन्फ़िगर करें।
- **नियमित मॉनिटरिंग:** संभावित सुरक्षा घटनाओं के लिए लॉग और मैट्रिक्स की निरंतर निगरानी करें।

---

### **असुरक्षित API गेटवे कॉन्फ़िगरेशन**

खुले या अनुचित रूप से सुरक्षित APIs का दुरुपयोग अनधिकृत पहुंच, सेवा से इनकार (DoS) हमलों, या क्रॉस-साइट हमलों के लिए किया जा सकता है।

#### **निवारण रणनीतियाँ**

- **प्रमाणीकरण और प्राधिकरण:** OAuth, API कुंजी, या JWT जैसे मजबूत तंत्र लागू करें।

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **रेट लिमिटिंग और थ्रॉटलिंग:** अनुरोध दरों को सीमित करके दुरुपयोग को रोकें।

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **सुरक्षित CORS कॉन्फ़िगरेशन:** अनुमत मूल, विधियों और हेडरों को प्रतिबंधित करें।

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **वेब एप्लिकेशन फ़ायरवॉल (WAF) का उपयोग करें:** दुर्भावनापूर्ण पैटर्न के लिए HTTP अनुरोधों को फ़िल्टर और मॉनिटर करें।

---

### **अपर्याप्त फ़ंक्शन अलगाव**

साझा संसाधन और अपर्याप्त अलगाव विशेषाधिकार वृद्धि या कार्यों के बीच अनपेक्षित इंटरैक्शन का कारण बन सकते हैं।

#### **निवारण रणनीतियाँ**

- **फंक्शंस को अलग करें:** स्वतंत्र संचालन सुनिश्चित करने के लिए विशिष्ट संसाधनों और IAM भूमिकाओं को असाइन करें।
- **संसाधन विभाजन:** विभिन्न कार्यों के लिए अलग डेटाबेस या स्टोरेज बकेट का उपयोग करें।
- **VPCs का उपयोग करें:** नेटवर्क अलगाव को बढ़ाने के लिए कार्यों को वर्चुअल प्राइवेट क्लाउड में तैनात करें।

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **फंक्शन अनुमतियों को सीमित करें:** सुनिश्चित करें कि कार्य एक-दूसरे के संसाधनों तक पहुंच या हस्तक्षेप नहीं कर सकते जब तक कि स्पष्ट रूप से आवश्यक न हो।

---

### **अपर्याप्त डेटा सुरक्षा**

आराम या ट्रांजिट में बिना एन्क्रिप्टेड डेटा को उजागर किया जा सकता है, जिससे डेटा उल्लंघन या छेड़छाड़ हो सकती है।

#### **निवारण रणनीतियाँ**

- **आराम में डेटा एन्क्रिप्ट करें:** क्लाउड सेवा एन्क्रिप्शन सुविधाओं का उपयोग करें।

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **ट्रांजिट में डेटा एन्क्रिप्ट करें:** सभी डेटा ट्रांसमिशन के लिए HTTPS/TLS का उपयोग करें।
- **API संचार को सुरक्षित करें:** एन्क्रिप्शन प्रोटोकॉल लागू करें और प्रमाणपत्रों को मान्य करें।
- **एन्क्रिप्शन कुंजियों का सुरक्षित प्रबंधन करें:** प्रबंधित कुंजी सेवाओं का उपयोग करें और नियमित रूप से कुंजियों को घुमाएँ।

---

### **सही त्रुटि हैंडलिंग की कमी**

विस्तृत त्रुटि संदेश बुनियादी ढांचे या कोडबेस के बारे में संवेदनशील जानकारी को उजागर कर सकते हैं, जबकि अनहैंडल्ड अपवाद एप्लिकेशन क्रैश का कारण बन सकते हैं।

#### **निवारण रणनीतियाँ**

- **सामान्य त्रुटि संदेश:** त्रुटि प्रतिक्रियाओं में आंतरिक विवरण को उजागर करने से बचें।

```javascript
javascriptCopy code// Example in Node.js
exports.hello = async (event) => {
try {
// Function logic
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```

- **केंद्रीकृत त्रुटि हैंडलिंग:** सभी कार्यों में त्रुटियों को लगातार प्रबंधित और साफ करें।
- **त्रुटियों की निगरानी और लॉगिंग करें:** अंत-उपयोगकर्ताओं को विवरण उजागर किए बिना आंतरिक रूप से त्रुटियों को ट्रैक और विश्लेषण करें।

---

### **असुरक्षित तैनाती प्रथाएँ**

खुले तैनाती कॉन्फ़िगरेशन या CI/CD पाइपलाइनों तक अनधिकृत पहुंच दुर्भावनापूर्ण कोड तैनात करने या गलत कॉन्फ़िगरेशन का कारण बन सकती है।

#### **निवारण रणनीतियाँ**

- **सुरक्षित CI/CD पाइपलाइन्स:** सख्त एक्सेस नियंत्रण, मल्टी-फैक्टर प्रमाणीकरण (MFA), और नियमित ऑडिट लागू करें।
- **कॉन्फ़िगरेशन को सुरक्षित रूप से स्टोर करें:** तैनाती फ़ाइलों को हार्डकोडेड सीक्रेट्स और संवेदनशील डेटा से मुक्त रखें।
- **इन्फ्रास्ट्रक्चर ऐज़ कोड (IaC) सुरक्षा उपकरणों का उपयोग करें:** सुरक्षा नीतियों को लागू करने के लिए **Checkov** या **Terraform Sentinel** जैसे उपकरणों का उपयोग करें।
- **अपरिवर्तनीय तैनाती:** अपरिवर्तनीय बुनियादी ढांचे की प्रथाओं को अपनाकर तैनाती के बाद अनधिकृत परिवर्तनों को रोकें।

---

### **प्लगइन्स और एक्सटेंशन में कमजोरियाँ**

अन्यथा अप्रूव्ड या दुर्भावनापूर्ण तृतीय-पक्ष प्लगइन्स का उपयोग आपके सर्वरलेस अनुप्रयोगों में कमजोरियाँ पेश कर सकता है।

#### **निवारण रणनीतियाँ**

- **प्लगइन्स की अच्छी तरह से जांच करें:** एकीकरण से पहले प्लगइन्स की सुरक्षा का आकलन करें, प्रतिष्ठित स्रोतों से उन पर प्राथमिकता दें।
- **प्लगइन उपयोग को सीमित करें:** हमले की सतह को कम करने के लिए केवल आवश्यक प्लगइन्स का उपयोग करें।
- **प्लगइन अपडेट की निगरानी करें:** सुरक्षा पैचों का लाभ उठाने के लिए प्लगइन्स को अपडेट रखें।
- **प्लगइन वातावरण को अलग करें:** संभावित समझौतों को सीमित करने के लिए प्लगइन्स को अलग वातावरण में चलाएँ।

---

### **संवेदनशील एंडपॉइंट्स का उजागर होना**

सार्वजनिक रूप से सुलभ कार्य या अनियंत्रित APIs का दुरुपयोग अनधिकृत संचालन के लिए किया जा सकता है।

#### **निवारण रणनीतियाँ**

- **कार्य पहुंच को प्रतिबंधित करें:** विश्वसनीय स्रोतों तक पहुंच को सीमित करने के लिए VPCs, सुरक्षा समूहों, और फ़ायरवॉल नियमों का उपयोग करें।
- **मजबूत प्रमाणीकरण लागू करें:** सुनिश्चित करें कि सभी उजागर एंडपॉइंट्स को उचित प्रमाणीकरण और प्राधिकरण की आवश्यकता है।
- **API गेटवे का सुरक्षित उपयोग करें:** सुरक्षा नीतियों को लागू करने के लिए API गेटवे को कॉन्फ़िगर करें, जिसमें इनपुट मान्यता और दर सीमित करना शामिल है।
- **अप्रयुक्त एंडपॉइंट्स को बंद करें:** नियमित रूप से समीक्षा करें और किसी भी एंडपॉइंट को बंद करें जो अब उपयोग में नहीं है।

---

### **टीम के सदस्यों और बाहरी सहयोगियों के लिए अत्यधिक अनुमतियाँ**

टीम के सदस्यों और बाहरी सहयोगियों को अत्यधिक अनुमतियाँ देना अनधिकृत पहुंच, डेटा उल्लंघन, और संसाधनों के दुरुपयोग का कारण बन सकता है। यह जोखिम उन वातावरणों में बढ़ जाता है जहाँ कई व्यक्तियों के पास विभिन्न स्तरों की पहुंच होती है, जिससे हमले की सतह और आंतरिक खतरों की संभावना बढ़ जाती है।

#### **निवारण रणनीतियाँ**

- **कम से कम विशेषाधिकार का सिद्धांत:** सुनिश्चित करें कि टीम के सदस्यों और सहयोगियों के पास केवल वही अनुमतियाँ हों जो उनके कार्यों को पूरा करने के लिए आवश्यक हैं।

---

### **एक्सेस कुंजी और लाइसेंस कुंजी सुरक्षा**

**एक्सेस कुंजी** और **लाइसेंस कुंजी** महत्वपूर्ण प्रमाणपत्र हैं जो Serverless Framework CLI के साथ इंटरैक्शन को प्रमाणित और अधिकृत करने के लिए उपयोग किए जाते हैं।

- **लाइसेंस कुंजी:** ये अद्वितीय पहचानकर्ता हैं जो Serverless Framework संस्करण 4 तक पहुंच को प्रमाणित करने के लिए आवश्यक हैं, जो CLI के माध्यम से लॉगिन की अनुमति देता है।
- **एक्सेस कुंजी:** प्रमाणपत्र जो Serverless Framework CLI को Serverless Framework डैशबोर्ड के साथ प्रमाणित करने की अनुमति देती हैं। जब `serverless` CLI के साथ लॉगिन किया जाता है, तो एक एक्सेस कुंजी **जनरेट और लैपटॉप में स्टोर की जाएगी**। आप इसे `SERVERLESS_ACCESS_KEY` नामक पर्यावरण चर के रूप में भी सेट कर सकते हैं।

#### **सुरक्षा जोखिम**

1. **कोड रिपॉजिटरी के माध्यम से उजागर होना:**
- एक्सेस कुंजी और लाइसेंस कुंजी को हार्डकोड करना या गलती से संस्करण नियंत्रण प्रणालियों में कमिट करना अनधिकृत पहुंच का कारण बन सकता है।
2. **असुरक्षित भंडारण:**
- उचित एन्क्रिप्शन के बिना पर्यावरण चर या कॉन्फ़िगरेशन फ़ाइलों में कुंजियों को स्पष्ट पाठ में स्टोर करना लीक होने की संभावना को बढ़ाता है।
3. **अनुचित वितरण:**
- असुरक्षित चैनलों (जैसे, ईमेल, चैट) के माध्यम से कुंजियों को साझा करना दुर्भावनापूर्ण तत्वों द्वारा इंटरसेप्शन का परिणाम हो सकता है।
4. **घुमाव की कमी:**
- कुंजियों को नियमित रूप से घुमाने में विफलता यदि कुंजियाँ समझौता की जाती हैं तो एक्सपोज़र अवधि को बढ़ा देती है।
5. **अत्यधिक अनुमतियाँ:**
- व्यापक अनुमतियों वाली कुंजियों का दुरुपयोग किया जा सकता है ताकि कई संसाधनों में अनधिकृत क्रियाएँ की जा सकें।

{{#include ../banners/hacktricks-training.md}}
