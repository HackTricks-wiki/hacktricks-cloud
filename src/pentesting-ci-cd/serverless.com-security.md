# Serverless.com 보안

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

### 조직

**조직**은 Serverless Framework 생태계 내에서 가장 높은 수준의 엔티티입니다. 이는 여러 프로젝트, 팀 및 애플리케이션을 포함하는 **집단 그룹**을 나타냅니다. 예를 들어 회사, 부서 또는 기타 대규모 엔티티가 될 수 있습니다.

### 팀

**팀**은 조직 내에서 접근 권한이 있는 사용자들입니다. 팀은 역할에 따라 구성원을 조직하는 데 도움을 줍니다. **`협력자`**는 기존 앱을 보고 배포할 수 있으며, **`관리자`**는 새로운 앱을 생성하고 조직 설정을 관리할 수 있습니다.

### 애플리케이션

**앱**은 조직 내 관련 서비스의 논리적 그룹화입니다. 이는 여러 서버리스 서비스로 구성된 완전한 애플리케이션을 나타내며, 이 서비스들은 함께 작동하여 일관된 기능을 제공합니다.

### **서비스**

**서비스**는 서버리스 애플리케이션의 핵심 구성 요소입니다. 이는 전체 서버리스 프로젝트를 나타내며, 필요한 모든 함수, 구성 및 리소스를 캡슐화합니다. 일반적으로 `serverless.yml` 파일에 정의되며, 서비스에는 서비스 이름, 제공자 구성, 함수, 이벤트, 리소스, 플러그인 및 사용자 정의 변수를 포함한 메타데이터가 포함됩니다.
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Function</summary>

A **Function**는 AWS Lambda 함수와 같은 단일 서버리스 함수를 나타냅니다. 이벤트에 응답하여 실행되는 코드를 포함합니다.

`serverless.yml`의 `functions` 섹션 아래에 정의되며, 핸들러, 런타임, 이벤트, 환경 변수 및 기타 설정을 지정합니다.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>이벤트</summary>

**이벤트**는 서버리스 함수를 호출하는 트리거입니다. 이들은 함수가 어떻게 그리고 언제 실행되어야 하는지를 정의합니다.

일반적인 이벤트 유형에는 HTTP 요청, 예약된 이벤트(크론 작업), 데이터베이스 이벤트, 파일 업로드 등이 포함됩니다.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>리소스</summary>

**리소스**는 데이터베이스, 스토리지 버킷 또는 IAM 역할과 같이 서비스가 의존하는 추가 클라우드 리소스를 정의할 수 있게 해줍니다.

이들은 `resources` 섹션 아래에 지정되며, 종종 AWS의 CloudFormation 구문을 사용합니다.
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>Provider</summary>

**Provider** 객체는 클라우드 서비스 제공업체(예: AWS, Azure, Google Cloud)를 지정하고 해당 제공업체와 관련된 구성 설정을 포함합니다.

여기에는 런타임, 지역, 단계 및 자격 증명과 같은 세부 정보가 포함됩니다.
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>단계 및 지역</summary>

단계는 서비스가 배포될 수 있는 다양한 환경(예: 개발, 스테이징, 프로덕션)을 나타냅니다. 이는 환경별 구성 및 배포를 허용합니다.
```yaml
provider:
stage: dev
```
지역은 리소스가 배포될 지리적 지역을 지정합니다. 이는 지연 시간, 규정 준수 및 가용성 고려 사항에 중요합니다.
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>플러그인</summary>

**플러그인**은 새로운 기능을 추가하거나 다른 도구 및 서비스와 통합하여 Serverless Framework의 기능을 확장합니다. 이들은 `plugins` 섹션 아래에 정의되며 npm을 통해 설치됩니다.
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>Layers</summary>

**Layers**는 공유 코드나 종속성을 함수와 별도로 패키징하고 관리할 수 있게 해줍니다. 이는 재사용성을 촉진하고 배포 패키지 크기를 줄입니다. 이들은 `layers` 섹션 아래에 정의되며 함수에서 참조됩니다.
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>변수 및 사용자 정의 변수</summary>

**변수**는 배포 시점에 해결되는 플레이스홀더를 사용하여 동적 구성을 가능하게 합니다.

- **구문:** `${variable}` 구문은 환경 변수, 파일 내용 또는 기타 구성 매개변수를 참조할 수 있습니다.

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

* **사용자 정의 변수:** `custom` 섹션은 `serverless.yml` 전반에 걸쳐 재사용할 수 있는 사용자 지정 변수 및 구성을 정의하는 데 사용됩니다.

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>출력</summary>

**출력**은 서비스가 배포된 후 반환되는 값들을 정의하며, 리소스 ARN, 엔드포인트 또는 기타 유용한 정보가 포함됩니다. 이들은 `outputs` 섹션 아래에 지정되며, 다른 서비스에 정보를 노출하거나 배포 후 쉽게 접근할 수 있도록 자주 사용됩니다.
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>IAM 역할 및 권한</summary>

**IAM 역할 및 권한**은 함수 및 기타 리소스에 대한 보안 자격 증명과 접근 권한을 정의합니다. 이들은 필요한 권한을 지정하기 위해 `provider` 또는 개별 함수 설정에서 관리됩니다.
```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```
</details>

<details>

<summary>환경 변수</summary>

**변수**는 하드코딩하지 않고 구성 설정 및 비밀을 함수에 전달할 수 있게 해줍니다. 이들은 제공자 또는 개별 함수의 `environment` 섹션 아래에 정의됩니다.
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>종속성</summary>

**종속성**은 함수가 필요로 하는 외부 라이브러리와 모듈을 관리합니다. 일반적으로 npm이나 pip와 같은 패키지 관리자를 통해 처리되며, `serverless-webpack`과 같은 도구나 플러그인을 사용하여 배포 패키지와 함께 번들됩니다.
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>Hooks</summary>

**Hooks**는 배포 생애 주기의 특정 지점에서 사용자 정의 스크립트나 명령을 실행할 수 있게 해줍니다. 이들은 플러그인을 사용하거나 `serverless.yml` 내에서 정의되어 배포 전후에 작업을 수행합니다.
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

이것은 공식 튜토리얼 [**문서에서**](https://www.serverless.com/framework/docs/tutorial)의 요약입니다:

1. AWS 계정을 생성합니다 (Serverless.com은 AWS 인프라에서 시작합니다)
2. serverless.com에 계정을 생성합니다
3. 앱을 생성합니다:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
이것은 **app** `tutorialapp`을 생성했어야 하며, [serverless.com](serverless.com-security.md)에서 확인할 수 있고, `helloworld` 코드가 포함된 JS 코드가 있는 **`handler.js`** 파일과 해당 함수를 선언하는 **`serverless.yml`** 파일이 있는 `Tutorial`이라는 폴더를 생성했어야 합니다:

{{#tabs }}
{{#tab name="handler.js" }}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
}
}
```
{{#endtab }}
{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{{#endtab }}
{{#endtabs }}

4. AWS 공급자를 생성하려면 `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`의 **대시보드**로 이동합니다.
1. `serverless.com`에 AWS 접근 권한을 부여하기 위해 이 구성 파일을 사용하여 클라우드포메이션 스택을 실행하라는 요청이 있습니다(이 글을 작성할 당시): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. 이 템플릿은 **`SFRole-<ID>`**라는 역할을 생성하며, **`arn:aws:iam::aws:policy/AdministratorAccess`**를 통해 `Serverless.com` AWS 계정이 역할에 접근할 수 있도록 허용하는 신뢰 ID를 가진 계정에 대해 설정됩니다.

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: "2012-10-17"
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub "ServerlessFramework-${OrgUid}"
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: "arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec"
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: "ARN for the IAM Role used by Serverless Framework"
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>신뢰 관계</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. 튜토리얼에서는 `createCustomer.js` 파일을 생성하라고 요청하며, 이 파일은 기본적으로 새로운 API 엔드포인트를 생성하고, `serverless.yml` 파일을 수정하여 **새로운 DynamoDB 테이블**을 생성하고, **환경 변수**를 정의하며, 생성된 람다를 사용할 역할을 설정하라고 요청합니다.

{{#tabs }}
{{#tab name="createCustomer.js" }}
```javascript
"use strict"
const AWS = require("aws-sdk")
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, "base64").toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{{#endtab }}

{{#tab name="serverless.yml" }}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: "Allow"
Action:
- "dynamodb:PutItem"
- "dynamodb:Get*"
- "dynamodb:Scan*"
- "dynamodb:UpdateItem"
- "dynamodb:DeleteItem"
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{{#endtab }}
{{#endtabs }}

6. **`serverless deploy`**를 실행하여 배포합니다.
1. 배포는 CloudFormation Stack을 통해 수행됩니다.
2. **람다 함수는 직접 URL이 아닌 API 게이트웨이를 통해 노출됩니다.**
7. **테스트합니다.**
1. 이전 단계에서는 API 엔드포인트 람다 함수가 배포된 **URL**이 출력됩니다.

## Serverless.com의 보안 검토

### **잘못 구성된 IAM 역할 및 권한**

과도하게 허용된 IAM 역할은 클라우드 리소스에 대한 무단 액세스를 허용하여 데이터 유출 또는 리소스 조작으로 이어질 수 있습니다.

람다 함수에 대한 권한이 지정되지 않으면, 로그 생성 권한만 있는 역할이 생성됩니다.
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"logs:CreateLogStream",
"logs:CreateLogGroup",
"logs:TagResource"
],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*"
],
"Effect": "Allow"
},
{
"Action": ["logs:PutLogEvents"],
"Resource": [
"arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/jito-cranker-scripts-dev*:*:*"
],
"Effect": "Allow"
}
]
}
```
</details>

#### **완화 전략**

- **최소 권한 원칙:** 각 함수에 필요한 권한만 할당합니다.

```yaml
provider:
[...]
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}
```

- **별도의 역할 사용:** 함수 요구 사항에 따라 역할을 구분합니다.

---

### **불안전한 비밀 및 구성 관리**

민감한 정보(예: API 키, 데이터베이스 자격 증명)를 **`serverless.yml`** 또는 코드에 직접 저장하면 리포지토리가 손상될 경우 노출될 수 있습니다.

**추천되는** 방법은 serverless.com의 **`serverless.yml`** 파일에서 환경 변수를 저장하기 위해 `ssm` 또는 `s3` 공급자를 사용하는 것입니다. 이는 **배포 시 이러한 소스에서 환경 값을 가져오고** **lambdas** 환경 변수를 **값이 없는 텍스트로 구성**할 수 있게 해줍니다!

> [!CAUTION]
> 따라서 AWS 내에서 lambdas 구성을 읽을 수 있는 권한이 있는 사람은 **이 모든 환경 변수를 평문으로 접근할 수 있습니다!**

예를 들어, 다음 예제는 SSM을 사용하여 환경 변수를 가져옵니다:
```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
And even if this prevents hardcoding the environment variable value in the **`serverless.yml`** file, the value will be obtained at deployment time and will be **added in clear text inside the lambda environment variable**.

> [!TIP]
> The recommended way to store environment variables using serveless.com would be to **store it in a AWS secret** and just store the secret name in the environment variable and the **lambda code should gather it**.

#### **Mitigation Strategies**

- **Secrets Manager Integration:** Use services like **AWS Secrets Manager.**
- **Encrypted Variables:** Leverage Serverless Framework’s encryption features for sensitive data.
- **Access Controls:** Restrict access to secrets based on roles.

---

### **Vulnerable Code and Dependencies**

Outdated or insecure dependencies can introduce vulnerabilities, while improper input handling may lead to code injection attacks.

#### **Mitigation Strategies**

- **Dependency Management:** Regularly update dependencies and scan for vulnerabilities.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```

- **Input Validation:** Implement strict validation and sanitization of all inputs.
- **Code Reviews:** Conduct thorough reviews to identify security flaws.
- **Static Analysis:** Use tools to detect vulnerabilities in the codebase.

---

### **Inadequate Logging and Monitoring**

Without proper logging and monitoring, malicious activities may go undetected, delaying incident response.

#### **Mitigation Strategies**

- **Centralized Logging:** Aggregate logs using services like **AWS CloudWatch** or **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```

- **Enable Detailed Logging:** Capture essential information without exposing sensitive data.
- **Set Up Alerts:** Configure alerts for suspicious activities or anomalies.
- **Regular Monitoring:** Continuously monitor logs and metrics for potential security incidents.

---

### **Insecure API Gateway Configurations**

Open or improperly secured APIs can be exploited for unauthorized access, Denial of Service (DoS) attacks, or cross-site attacks.

#### **Mitigation Strategies**

- **Authentication and Authorization:** Implement robust mechanisms like OAuth, API keys, or JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```

- **Rate Limiting and Throttling:** Prevent abuse by limiting request rates.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```

- **Secure CORS Configuration:** Restrict allowed origins, methods, and headers.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```

- **Use Web Application Firewalls (WAF):** Filter and monitor HTTP requests for malicious patterns.

---

### **Insufficient Function Isolation**

Shared resources and inadequate isolation can lead to privilege escalations or unintended interactions between functions.

#### **Mitigation Strategies**

- **Isolate Functions:** Assign distinct resources and IAM roles to ensure independent operation.
- **Resource Partitioning:** Use separate databases or storage buckets for different functions.
- **Use VPCs:** Deploy functions within Virtual Private Clouds for enhanced network isolation.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```

- **Limit Function Permissions:** Ensure functions cannot access or interfere with each other’s resources unless explicitly required.

---

### **Inadequate Data Protection**

Unencrypted data at rest or in transit can be exposed, leading to data breaches or tampering.

#### **Mitigation Strategies**

- **Encrypt Data at Rest:** Utilize cloud service encryption features.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```

- **Encrypt Data in Transit:** Use HTTPS/TLS for all data transmissions.
- **Secure API Communication:** Enforce encryption protocols and validate certificates.
- **Manage Encryption Keys Securely:** Use managed key services and rotate keys regularly.

---

### **Lack of Proper Error Handling**

Detailed error messages can leak sensitive information about the infrastructure or codebase, while unhandled exceptions may lead to application crashes.

#### **Mitigation Strategies**

- **Generic Error Messages:** Avoid exposing internal details in error responses.

```javascript
javascriptCopy code// Example in Node.js
exports.hello = async (event) => {
try {
// Function logic
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```

- **Centralized Error Handling:** Manage and sanitize errors consistently across all functions.
- **Monitor and Log Errors:** Track and analyze errors internally without exposing details to end-users.

---

### **Insecure Deployment Practices**

Exposed deployment configurations or unauthorized access to CI/CD pipelines can lead to malicious code deployments or misconfigurations.

#### **Mitigation Strategies**

- **Secure CI/CD Pipelines:** Implement strict access controls, multi-factor authentication (MFA), and regular audits.
- **Store Configuration Securely:** Keep deployment files free from hardcoded secrets and sensitive data.
- **Use Infrastructure as Code (IaC) Security Tools:** Employ tools like **Checkov** or **Terraform Sentinel** to enforce security policies.
- **Immutable Deployments:** Prevent unauthorized changes post-deployment by adopting immutable infrastructure practices.

---

### **Vulnerabilities in Plugins and Extensions**

Using unvetted or malicious third-party plugins can introduce vulnerabilities into your serverless applications.

#### **Mitigation Strategies**

- **Vet Plugins Thoroughly:** Assess the security of plugins before integration, favoring those from reputable sources.
- **Limit Plugin Usage:** Use only necessary plugins to minimize the attack surface.
- **Monitor Plugin Updates:** Keep plugins updated to benefit from security patches.
- **Isolate Plugin Environments:** Run plugins in isolated environments to contain potential compromises.

---

### **Exposure of Sensitive Endpoints**

Publicly accessible functions or unrestricted APIs can be exploited for unauthorized operations.

#### **Mitigation Strategies**

- **Restrict Function Access:** Use VPCs, security groups, and firewall rules to limit access to trusted sources.
- **Implement Robust Authentication:** Ensure all exposed endpoints require proper authentication and authorization.
- **Use API Gateways Securely:** Configure API Gateways to enforce security policies, including input validation and rate limiting.
- **Disable Unused Endpoints:** Regularly review and disable any endpoints that are no longer in use.

---

### **Excessive Permissions for Team Members and External Collaborators**

Granting excessive permissions to team members and external collaborators can lead to unauthorized access, data breaches, and misuse of resources. This risk is heightened in environments where multiple individuals have varying levels of access, increasing the attack surface and potential for insider threats.

#### **Mitigation Strategies**

- **Principle of Least Privilege:** Ensure that team members and collaborators have only the permissions necessary to perform their tasks.

---

### **Access Keys and License Keys Security**

**Access Keys** and **License Keys** are critical credentials used to authenticate and authorize interactions with the Serverless Framework CLI.

- **License Keys:** 그들은 Serverless Framework Version 4에 대한 접근을 인증하는 데 필요한 고유 식별자입니다. CLI를 통해 로그인할 수 있습니다.
- **Access Keys:** Serverless Framework CLI가 Serverless Framework Dashboard와 인증하는 데 사용하는 자격 증명입니다. `serverless` cli로 로그인할 때 액세스 키가 **생성되어 노트북에 저장됩니다**. 또한 `SERVERLESS_ACCESS_KEY`라는 환경 변수로 설정할 수 있습니다.

#### **Security Risks**

1. **Exposure Through Code Repositories:**
- Access Keys 및 License Keys를 하드코딩하거나 실수로 버전 관리 시스템에 커밋하면 무단 접근이 발생할 수 있습니다.
2. **Insecure Storage:**
- 적절한 암호화 없이 환경 변수나 구성 파일에 평문으로 키를 저장하면 유출 가능성이 높아집니다.
3. **Improper Distribution:**
- 안전하지 않은 채널(예: 이메일, 채팅)을 통해 키를 공유하면 악의적인 행위자에 의해 가로채질 수 있습니다.
4. **Lack of Rotation:**
- 키를 정기적으로 회전하지 않으면 키가 손상된 경우 노출 기간이 연장됩니다.
5. **Excessive Permissions:**
- 광범위한 권한을 가진 키는 여러 리소스에서 무단 작업을 수행하는 데 악용될 수 있습니다.

{{#include ../banners/hacktricks-training.md}}
