# Κατάχρηση Cloudflare Workers ως pass-through proxies (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers μπορούν να αναπτυχθούν ως διαφανείς HTTP pass-through proxies όπου το upstream target URL παρέχεται από τον client. Τα requests εξέρχονται από το δίκτυο της Cloudflare, οπότε ο στόχος βλέπει Cloudflare IPs αντί για τα IPs του client. Αυτό αντικατοπτρίζει την γνωστή τεχνική FireProx στο AWS API Gateway, αλλά χρησιμοποιεί Cloudflare Workers.

### Key capabilities
- Support for all HTTP methods (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- Target can be supplied via query parameter (?url=...), a header (X-Target-URL), or even encoded in the path (e.g., /https://target)
- Headers and body are proxied through with hop-by-hop/header filtering as needed
- Responses are relayed back, preserving status code and most headers
- Optional spoofing of X-Forwarded-For (if the Worker sets it from a user-controlled header)
- Extremely fast/easy rotation by deploying multiple Worker endpoints and fanning out requests

### Πώς λειτουργεί (flow)
1) Ο client στέλνει ένα HTTP request σε ένα Worker URL (`<name>.<account>.workers.dev` ή σε custom domain route).
2) Ο Worker εξάγει τον target από query parameter (?url=...), από το header X-Target-URL, ή από ένα path segment αν έχει υλοποιηθεί έτσι.
3) Ο Worker προωθεί το εισερχόμενο method, headers και body στο καθορισμένο upstream URL (φιλτράροντας προβληματικά headers).
4) Η upstream απάντηση streamάρεται πίσω στον client μέσω Cloudflare· η origin βλέπει τα Cloudflare egress IPs.

### Worker implementation example
- Διαβάζει το target URL από query param, header ή path
- Αντιγράφει ένα ασφαλές υποσύνολο headers και προωθεί το αρχικό method/body
- Προαιρετικά ορίζει X-Forwarded-For χρησιμοποιώντας ένα user-controlled header (X-My-X-Forwarded-For) ή ένα τυχαίο IP
- Προσθέτει permissive CORS και χειρίζεται τα preflight

<details>
<summary>Παράδειγμα Worker (JavaScript) for pass-through proxying</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Αυτοματοποίηση ανάπτυξης και περιστροφής με FlareProx

FlareProx είναι ένα εργαλείο Python που χρησιμοποιεί το Cloudflare API για να αναπτύξει πολλαπλά Worker endpoints και να κάνει rotation μεταξύ τους. Αυτό παρέχει FireProx-like εναλλαγή IP από το δίκτυο του Cloudflare.

Ρύθμιση
1) Δημιουργήστε ένα Cloudflare API Token χρησιμοποιώντας το “Edit Cloudflare Workers” template και πάρτε το Account ID σας από τον πίνακα ελέγχου.
2) Διαμορφώστε το FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Δημιουργήστε το config file flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**CLI χρήση**

- Δημιούργησε N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Λίστα endpoints:
```bash
python3 flareprox.py list
```
- endpoints δοκιμής υγείας:
```bash
python3 flareprox.py test
```
- Διαγράψτε όλα τα endpoints:
```bash
python3 flareprox.py cleanup
```
**Δρομολόγηση της κίνησης μέσω ενός Worker**
- Μορφή παραμέτρου query:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Μορφή επικεφαλίδας:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Μορφή διαδρομής (εάν υλοποιηθεί):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Παραδείγματα μεθόδων:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` έλεγχος**

Εάν ο Worker σέβεται την επικεφαλίδα `X-My-X-Forwarded-For`, μπορείτε να επηρεάσετε την upstream τιμή `X-Forwarded-For`:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Προγραμματιστική χρήση**

Χρησιμοποιήστε τη βιβλιοθήκη FlareProx για να δημιουργήσετε, να απαριθμήσετε και να δοκιμάσετε endpoints και να δρομολογήσετε αιτήματα από Python.

<details>
<summary>Παράδειγμα Python: Αποστολή POST μέσω τυχαίου Worker endpoint</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Burp/Scanner ενσωμάτωση**
- Κατευθύνετε τα εργαλεία (π.χ. Burp Suite) στο URL του Worker.
- Παρέχετε τον πραγματικό upstream χρησιμοποιώντας ?url= ή X-Target-URL.
- Η HTTP σημασιολογία (methods/headers/body) διατηρείται ενώ η πηγή IP σας αποκρύπτεται πίσω από το Cloudflare.

**Λειτουργικές σημειώσεις και περιορισμοί**
- Το Cloudflare Workers Free plan επιτρέπει περίπου 100.000 αιτήματα/ημέρα ανά λογαριασμό· χρησιμοποιήστε πολλαπλά endpoints για να διανείμετε την κίνηση αν χρειαστεί.
- Οι Workers τρέχουν στο δίκτυο του Cloudflare· πολλοί στόχοι θα βλέπουν μόνο Cloudflare IPs/ASN, κάτι που μπορεί να παρακάμψει απλές λίστες allow/deny ανά IP ή geo heuristics.
- Χρησιμοποιήστε υπεύθυνα και μόνο με εξουσιοδότηση. Σεβαστείτε τους ToS και το robots.txt.

## Αναφορές
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
