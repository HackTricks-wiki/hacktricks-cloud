# Abusare dei Cloudflare Workers come pass-through proxies (rotazione IP, stile FireProx)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers possono essere deployati come proxy HTTP trasparenti pass-through dove l'URL di destinazione upstream è fornito dal client. Le richieste escono dalla rete di Cloudflare, quindi il target osserva gli IP di Cloudflare invece di quelli del client. Questo rispecchia la nota tecnica FireProx su AWS API Gateway, ma utilizza Cloudflare Workers.

### Funzionalità principali
- Supporto per tutti i metodi HTTP (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- Il target può essere fornito tramite parametro di query (?url=...), un header (X-Target-URL), o anche codificato nel path (es., /https://target)
- Headers e body sono proxati attraverso con filtraggio di hop-by-hop/header se necessario
- Le risposte vengono relayate al client preservando il codice di stato e la maggior parte degli header
- Spoofing opzionale di X-Forwarded-For (se il Worker lo imposta da un header controllato dall'utente)
- Rotazione estremamente rapida/facile distribuendo più endpoint Worker e distribuendo le richieste

### Come funziona (flusso)
1) Il client invia una richiesta HTTP a un Worker URL (`<name>.<account>.workers.dev` o una route di dominio custom).
2) Il Worker estrae il target da un parametro di query (?url=...), dall'header X-Target-URL, o da un segmento del path se implementato.
3) Il Worker inoltra il metodo, gli header e il body in ingresso all'URL upstream specificato (filtrando gli header problematici).
4) La risposta upstream viene streamata indietro al client attraverso Cloudflare; l'origin vede gli IP di egress di Cloudflare.

### Esempio di implementazione del Worker
- Legge l'URL di destinazione dal parametro di query, dall'header o dal path
- Copia un sottoinsieme sicuro di header e inoltra il metodo/body originale
- Opzionalmente imposta X-Forwarded-For usando un header controllato dall'utente (X-My-X-Forwarded-For) o un IP casuale
- Aggiunge CORS permissivo e gestisce il preflight

<details>
<summary>Esempio Worker (JavaScript) per proxy pass-through</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Automatizzare la distribuzione e la rotazione con FlareProx

FlareProx è uno strumento Python che utilizza la Cloudflare API per distribuire molti endpoint Worker e ruotare tra di essi. Questo fornisce una rotazione degli IP simile a FireProx sfruttando la rete di Cloudflare.

Configurazione
1) Crea un Cloudflare API Token usando il template “Edit Cloudflare Workers” e ottieni il tuo Account ID dalla dashboard.
2) Configura FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Crea il config file flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**Uso della CLI**

- Crea N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Elenca endpoints:
```bash
python3 flareprox.py list
```
- Endpoint per il controllo dello stato:
```bash
python3 flareprox.py test
```
- Eliminare tutti gli endpoints:
```bash
python3 flareprox.py cleanup
```
**Instradamento del traffico attraverso un Worker**
- Forma con parametro di query:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Formato intestazione:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Formato del path (se implementato):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Esempi di metodo:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` controllo**

Se il Worker rispetta `X-My-X-Forwarded-For`, puoi influenzare il valore `X-Forwarded-For` a monte:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Uso programmatico**

Usare la libreria FlareProx per creare/elencare/testare endpoint e instradare richieste da Python.

<details>
<summary>Esempio Python: Inviare una richiesta POST tramite un endpoint Worker casuale</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Integrazione Burp/Scanner**
- Puntare gli strumenti (per esempio, Burp Suite) sull'URL del Worker.
- Fornire l'upstream reale usando ?url= o X-Target-URL.
- La semantica HTTP (methods/headers/body) viene preservata mentre si maschera il tuo indirizzo IP sorgente dietro Cloudflare.

**Note operative e limiti**
- Il piano Free di Cloudflare Workers consente approssimativamente 100.000 richieste/giorno per account; usa più endpoint per distribuire il traffico se necessario.
- I Workers girano sulla rete di Cloudflare; molti target vedranno soltanto gli IP/ASN di Cloudflare, il che può eludere liste naive di allow/deny basate su IP o euristiche geografiche.
- Usare responsabilmente e solo con autorizzazione. Rispettare i ToS e robots.txt.

## Riferimenti
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
