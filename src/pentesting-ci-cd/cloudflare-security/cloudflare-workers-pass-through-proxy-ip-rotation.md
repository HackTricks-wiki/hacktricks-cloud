# Abusing Cloudflare Workers as pass-through proxies (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers possono essere distribuiti come proxy HTTP trasparenti pass-through in cui l'URL di destinazione upstream è fornito dal client. Le richieste escono dalla rete di Cloudflare, quindi la destinazione vede gli IP di Cloudflare invece di quelli del client. Questo rispecchia la famosa tecnica FireProx su AWS API Gateway, ma utilizza Cloudflare Workers.

### Key capabilities
- Support for all HTTP methods (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- La destinazione può essere fornita tramite parametro di query (?url=...), un header (X-Target-URL), o persino codificata nel path (es., /https://target)
- Header e body vengono inoltrati tramite il proxy con filtraggio degli header hop-by-hop quando necessario
- Le risposte vengono rilanciate indietro, preservando lo status code e la maggior parte degli header
- Spoofing opzionale di X-Forwarded-For (se il Worker lo imposta da un header controllato dall'utente)
- Rotazione estremamente rapida/facile distribuendo più endpoint Worker e smistando le richieste

### How it works (flow)
1) Il client invia una richiesta HTTP a un URL Worker (`<name>.<account>.workers.dev` o una route su dominio custom).
2) Il Worker estrae la destinazione da un parametro di query (?url=...), dall'header X-Target-URL, o da un segmento del path se implementato.
3) Il Worker inoltra il metodo, gli header e il body in arrivo all'URL upstream specificato (filtrando gli header problematici).
4) La risposta upstream viene trasmessa al client attraverso Cloudflare; l'origine vede gli IP di uscita di Cloudflare.

### Worker implementation example
- Legge l'URL di destinazione dal parametro di query, dall'header o dal path
- Copia un sottoinsieme sicuro di header e inoltra il metodo/body originale
- Opzionalmente imposta X-Forwarded-For usando un header controllato dall'utente (X-My-X-Forwarded-For) o un IP casuale
- Aggiunge CORS permissivo e gestisce i preflight

<details>
<summary>Esempio di Worker (JavaScript) per proxy pass-through</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Automatizzare la distribuzione e la rotazione con FlareProx

FlareProx è uno strumento Python che usa la Cloudflare API per distribuire molti endpoint Worker e ruotare tra essi. Questo fornisce una rotazione IP in stile FireProx dalla rete di Cloudflare.

Configurazione
1) Crea un Cloudflare API Token usando il template “Edit Cloudflare Workers” e recupera il tuo Account ID dalla dashboard.
2) Configura FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Crea il file di configurazione flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**CLI usage**

- Crea N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Elencare gli endpoint:
```bash
python3 flareprox.py list
```
- Endpoint di controllo dello stato:
```bash
python3 flareprox.py test
```
- Elimina tutti gli endpoint:
```bash
python3 flareprox.py cleanup
```
**Instradare il traffico attraverso un Worker**
- Formato con parametri di query:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Formato intestazione:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Formato del path (se implementato):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Esempi di metodi:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` controllo**

Se il Worker rispetta `X-My-X-Forwarded-For`, puoi influenzare il valore upstream di `X-Forwarded-For`:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Uso programmatico**

Usa la libreria FlareProx per creare, elencare e testare endpoint e per instradare richieste da Python.

<details>
<summary>Esempio Python: Invia un POST tramite un endpoint Worker casuale</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Integrazione Burp/Scanner**
- Indirizzare gli strumenti (per esempio, Burp Suite) al Worker URL.
- Fornire l'upstream reale usando ?url= o X-Target-URL.
- La semantica HTTP (methods/headers/body) viene preservata mentre l'IP sorgente viene mascherato dietro Cloudflare.

**Note operative e limiti**
- Cloudflare Workers Free plan consente circa 100.000 richieste/giorno per account; usare più endpoint per distribuire il traffico se necessario.
- I Workers vengono eseguiti sulla rete di Cloudflare; molti target vedranno solo gli IP/ASN di Cloudflare, il che può bypassare semplici allow/deny lists basate su IP o le euristiche geografiche.
- Usare responsabilmente e solo con autorizzazione. Rispettare ToS e robots.txt.

## Riferimenti
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
