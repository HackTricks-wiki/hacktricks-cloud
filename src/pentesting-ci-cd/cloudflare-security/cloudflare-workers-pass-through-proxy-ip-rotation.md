# Abusing Cloudflare Workers as pass-through proxies (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers pueden desplegarse como proxies HTTP transparentes donde la URL objetivo upstream la proporciona el cliente. Las solicitudes salen por la red de Cloudflare, por lo que el destino observa las IPs de Cloudflare en lugar de las del cliente. Esto refleja la conocida técnica FireProx en AWS API Gateway, pero usando Cloudflare Workers.

### Key capabilities
- Soporte para todos los métodos HTTP (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- El target puede proporcionarse vía parámetro de consulta (?url=...), una cabecera (X-Target-URL), o incluso codificado en la ruta (por ejemplo, /https://target)
- Las cabeceras y el cuerpo se proxyean con filtrado de cabeceras hop-by-hop/según sea necesario
- Las respuestas se reenvían, preservando el código de estado y la mayoría de las cabeceras
- Suplantación opcional de X-Forwarded-For (si el Worker la establece desde una cabecera controlada por el usuario)
- Rotación extremadamente rápida/fácil desplegando múltiples endpoints de Worker y expandiendo las solicitudes

### How it works (flow)
1) El cliente envía una petición HTTP a una URL de Worker (`<name>.<account>.workers.dev` o una ruta de dominio personalizado).
2) El Worker extrae el target ya sea de un parámetro de consulta (?url=...), la cabecera X-Target-URL, o un segmento de la ruta si está implementado.
3) El Worker reenvía el método entrante, las cabeceras y el cuerpo a la URL upstream especificada (filtrando cabeceras problemáticas).
4) La respuesta del upstream se transmite de vuelta al cliente a través de Cloudflare; el origen ve las IPs de egreso de Cloudflare.

### Worker implementation example
- Lee la URL de destino desde el parámetro de consulta, la cabecera o la ruta
- Copia un subconjunto seguro de cabeceras y reenvía el método/cuerpo original
- Opcionalmente establece X-Forwarded-For usando una cabecera controlada por el usuario (X-My-X-Forwarded-For) o una IP aleatoria
- Añade CORS permisivo y maneja preflight

<details>
<summary>Ejemplo de Worker (JavaScript) para pass-through proxying</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Automatizando el despliegue y la rotación con FlareProx

FlareProx es una herramienta en Python que usa la Cloudflare API para desplegar muchos endpoints de Worker y rotar entre ellos. Esto proporciona una rotación de IP tipo FireProx desde la red de Cloudflare.

Configuración
1) Crea un Cloudflare API Token usando la plantilla “Edit Cloudflare Workers” y obtén tu ID de la cuenta desde el panel de control.
2) Configura FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Crear archivo de configuración flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**Uso de la CLI**

- Crear N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Listar endpoints:
```bash
python3 flareprox.py list
```
- Endpoints de comprobación de estado:
```bash
python3 flareprox.py test
```
- Eliminar todos los endpoints:
```bash
python3 flareprox.py cleanup
```
**Enrutando tráfico a través de un Worker**
- Formato de parámetro de consulta:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Formato del encabezado:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Formato de ruta (si está implementado):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Ejemplos de métodos:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` control**

Si el Worker respeta `X-My-X-Forwarded-For`, puedes influir en el valor `X-Forwarded-For` upstream:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Uso programático**

Usa la librería FlareProx para crear/listar/probar endpoints y enrutar solicitudes desde Python.

<details>
<summary>Ejemplo en Python: Enviar un POST vía un endpoint Worker aleatorio</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Burp/Scanner integración**
- Apunta la herramienta (por ejemplo, Burp Suite) a la Worker URL.
- Proporciona el upstream real usando ?url= o X-Target-URL.
- Se preservan las semánticas HTTP (methods/headers/body) mientras se enmascara tu IP de origen detrás de Cloudflare.

**Notas operativas y límites**
- Cloudflare Workers Free plan permite aproximadamente 100,000 solicitudes/día por cuenta; usa múltiples endpoints para distribuir el tráfico si es necesario.
- Workers se ejecutan en la red de Cloudflare; muchos objetivos solo verán las IPs/ASN de Cloudflare, lo que puede eludir listas ingenuas de allow/deny por IP o heurísticas geográficas.
- Úsalo responsablemente y solo con autorización. Respeta los ToS y robots.txt.

## Referencias
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
