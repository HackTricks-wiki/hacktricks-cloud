# Kutumia Vibaya Cloudflare Workers as pass-through proxies (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers zinaweza kutumika kama proxies wazi za HTTP za pass-through ambapo URL ya upstream target inatolewa na mteja. Maombi hutoka kutoka kwenye mtandao wa Cloudflare, hivyo target inaona Cloudflare IPs badala ya za mteja. Hii inaiga tekniki maarufu ya FireProx kwenye AWS API Gateway, lakini inatumia Cloudflare Workers.

### Sifa kuu
- Inasaidia njia zote za HTTP (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- Lengo linaweza kutolewa kupitia query parameter (?url=...), header (X-Target-URL), au hata kuingizwa kwenye path (mfano, /https://target)
- Headers na body hupitishwa kupitia proxy kwa kuchuja hop-by-hop/header inapohitajika
- Majibu hurudishwa, huku ikihifadhi status code na wengi wa headers
- Inaweza kufanya spoofing ya X-Forwarded-For (ikiwa Worker inaiweka kutoka kwa header inayodhibitiwa na mtumiaji)
- Mzunguko wa IP wa haraka/rahisi kwa kupeleka endpoints nyingi za Worker na kueneza maombi

### Jinsi inavyofanya kazi (mtiririko)
1) Mteja anatuma ombi la HTTP kwa Worker URL (`<name>.<account>.workers.dev` au custom domain route).
2) Worker hutambua target kutoka kwa query parameter (?url=...), header X-Target-URL, au segment ya path ikiwa imefanikiwa.
3) Worker inapitisha method, headers, na body zinazoingia kwa URL ya upstream iliyobainishwa (ikichuja headers zenye matatizo).
4) Majibu kutoka upstream yarejeshwa kwa mtiririko kwa mteja kupitia Cloudflare; origin inaona Cloudflare egress IPs.

### Mfano wa utekelezaji wa Worker
- Husoma URL ya target kutoka query param, header, au path
- Huanakili subset salama ya headers na kuipitisha method/body ya asili
- Inaweza kuweka X-Forwarded-For kwa kutumia header inayodhibitiwa na mtumiaji (X-My-X-Forwarded-For) au IP ya nasibu
- Inaongeza CORS yenye ruhusa na kushughulikia preflight

<details>
<summary>Example Worker (JavaScript) for pass-through proxying</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Kut automatisha deployment na mzunguko kwa FlareProx

FlareProx ni zana ya Python inayotumia Cloudflare API kuweka endpoints nyingi za Worker na kuzizungusha kati yao. Hii hutoa mzunguko wa IP unaofanana na FireProx kutoka kwenye mtandao wa Cloudflare.

Usanidi
1) Unda Cloudflare API Token ukitumia template “Edit Cloudflare Workers” na upate Account ID yako kutoka kwenye dashboard.
2) Sanidi FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Tengeneza faili ya usanidi flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**Matumizi ya CLI**

- Unda proxies N za Worker:
```bash
python3 flareprox.py create --count 2
```
- Orodhesha endpoints:
```bash
python3 flareprox.py list
```
- Endpoints za upimaji wa afya:
```bash
python3 flareprox.py test
```
- Futa endpoints zote:
```bash
python3 flareprox.py cleanup
```
**Kuongoza trafiki kupitia Worker**
- Fomu ya parameter za query:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Fomu ya kichwa:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Fomu ya path (ikiwa imetekelezwa):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Mifano ya mbinu:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` udhibiti**

Ikiwa Worker inaheshimu `X-My-X-Forwarded-For`, unaweza kuathiri thamani ya upstream ya `X-Forwarded-For`:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Matumizi kwa njia ya programu**

Tumia maktaba ya FlareProx kuunda/kuorodhesha/kujaribu endpoints na kupitisha maombi kutoka Python.

<details>
<summary>Mfano wa Python: Tuma POST kupitia endpoint ya Worker ya nasibu</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Muunganisho na Burp/Scanner**
- Elekeza zana (kwa mfano, Burp Suite) kwa Worker URL.
- Toa upstream halisi ukitumia ?url= au X-Target-URL.
- Semantiki za HTTP (methods/headers/body) zinahifadhiwa wakati ukificha IP yako ya asili nyuma ya Cloudflare.

**Vidokezo vya uendeshaji na mipaka**
- Cloudflare Workers Free plan inaruhusu takriban 100,000 requests/day kwa akaunti; tumia endpoints mbalimbali kusambaza trafiki ikiwa inahitajika.
- Workers zinaendesha kwenye mtandao wa Cloudflare; malengo mengi yataona tu Cloudflare IPs/ASN, jambo ambalo linaweza kupitisha naive IP allow/deny lists au geo heuristics.
- Tumia kwa uwajibikaji na tu kwa idhini. Heshimu ToS na robots.txt.

## Marejeo
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
