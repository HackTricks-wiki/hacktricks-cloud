# Cloudflare Workers का pass-through proxy के रूप में दुरुपयोग (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers को ऐसे transparent HTTP pass-through proxies के रूप में deploy किया जा सकता है जहाँ upstream target URL client द्वारा प्रदान किया जाता है। Requests Cloudflare के नेटवर्क से बाहर निकलती हैं इसलिए target क्लाइंट के बजाय Cloudflare IPs को देखता है। यह well-known FireProx technique on AWS API Gateway की नकल करता है, लेकिन यहाँ Cloudflare Workers का उपयोग होता है।

### मुख्य क्षमताएँ
- सभी HTTP methods का समर्थन (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- Target query parameter (?url=...), एक header (X-Target-URL), या path में encode करके (उदा., /https://target) प्रदान किया जा सकता है
- Headers और body को जरूरत के अनुसार hop-by-hop/header filtering के साथ proxy किया जाता है
- Responses वापस relay की जाती हैं, status code और अधिकतर headers को preserve करते हुए
- X-Forwarded-For का वैकल्पिक spoofing (यदि Worker इसे user-controlled header से सेट करता है)
- कई Worker endpoints deploy करके और requests को fan-out करके बेहद तेज़/आसान rotation

### यह कैसे काम करता है (flow)
1) Client एक HTTP request भेजता है एक Worker URL (`<name>.<account>.workers.dev` या एक custom domain route) पर।  
2) Worker target निकालता है या तो query parameter (?url=...), X-Target-URL header, या अगर लागू किया गया हो तो path segment से।  
3) Worker incoming method, headers, और body को निर्दिष्ट upstream URL पर forward करता है (समस्याग्रस्त headers को filter करते हुए)।  
4) Upstream response Cloudflare के माध्यम से client को stream की जाती है; origin Cloudflare के egress IPs देखता है।  

### Worker implementation का उदाहरण
- Query param, header, या path से target URL पढ़ता है  
- headers के सुरक्षित subset को कॉपी करके original method/body forward करता है  
- वैकल्पिक रूप से X-Forwarded-For सेट कर सकता है user-controlled header (X-My-X-Forwarded-For) या किसी random IP का उपयोग करके  
- permissive CORS जोड़ता है और preflight को handle करता है

<details>
<summary>उदाहरण Worker (JavaScript) — pass-through proxying के लिए</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### FlareProx के साथ तैनाती और रोटेशन को स्वचालित करना

FlareProx एक Python tool है जो Cloudflare API का उपयोग करके कई Worker endpoints तैनात करता है और उनके बीच rotate करता है। यह Cloudflare के नेटवर्क से FireProx-जैसी IP rotation प्रदान करता है।

Setup
1) एक Cloudflare API Token बनाइए “Edit Cloudflare Workers” template का उपयोग करके और dashboard से अपना Account ID प्राप्त करें।
2) FlareProx को configure करें:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**flareprox.json के लिए कॉन्फ़िग फ़ाइल बनाएं:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**CLI उपयोग**

- N Worker proxies बनाएँ:
```bash
python3 flareprox.py create --count 2
```
- endpoints की सूची:
```bash
python3 flareprox.py list
```
- हेल्थ-टेस्ट endpoints:
```bash
python3 flareprox.py test
```
- सभी endpoints हटाएँ:
```bash
python3 flareprox.py cleanup
```
**Worker के माध्यम से ट्रैफ़िक रूट करना**
- क्वेरी पैरामीटर फ़ॉर्म:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- हेडर फॉर्म:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- पथ रूप (यदि लागू किया गया):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- विधि के उदाहरण:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` नियंत्रण**

यदि Worker `X-My-X-Forwarded-For` का सम्मान करता है, तो आप upstream `X-Forwarded-For` मान को प्रभावित कर सकते हैं:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**प्रोग्रामेटिक उपयोग**

FlareProx लाइब्रेरी का उपयोग करके endpoints बनाएं/लिस्ट/टेस्ट करें और Python से requests को route करें।

<details>
<summary>Python उदाहरण: किसी random Worker endpoint के माध्यम से POST भेजें</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Burp/Scanner integration**
- टूलिंग (उदाहरण के लिए, Burp Suite) को Worker URL की ओर निर्देशित करें।
- वास्तविक upstream को ?url= या X-Target-URL का उपयोग करके प्रदान करें।
- HTTP semantics (methods/headers/body) बनाए रहते हैं जबकि आपका source IP Cloudflare के पीछे छिपाया जाता है।

**Operational notes and limits**
- Cloudflare Workers Free plan प्रति अकाउंट लगभग 100,000 requests/day की अनुमति देता है; आवश्यकता होने पर ट्रैफ़िक वितरित करने के लिए multiple endpoints का उपयोग करें।
- Workers Cloudflare के नेटवर्क पर चलते हैं; कई targets केवल Cloudflare IPs/ASN ही देखेंगे, जो naive IP allow/deny lists या geo heuristics को बाइपास कर सकते हैं।
- जिम्मेदारी से उपयोग करें और केवल authorization के साथ। ToS और robots.txt का सम्मान करें।

## References
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
