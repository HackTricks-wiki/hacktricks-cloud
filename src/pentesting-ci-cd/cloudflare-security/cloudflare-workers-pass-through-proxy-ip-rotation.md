# Zloupotreba Cloudflare Workers kao pass-through proxies (IP rotation, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers se mogu postaviti kao transparentni HTTP pass-through proxies gde upstream target URL obezbeđuje klijent. Zahtevi izlaze iz Cloudflare mreže pa cilj vidi Cloudflare IP adrese umesto klijentovih. Ovo odražava dobro poznatu FireProx tehniku na AWS API Gateway, ali koristi Cloudflare Workers.

### Ključne mogućnosti
- Podrška za sve HTTP metode (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- Target može biti prosleđen preko query parametra (?url=...), headera (X-Target-URL), ili čak enkodiran u putanji (npr. /https://target)
- Headers i body se proxiraju kroz uz hop-by-hop/header filtriranje po potrebi
- Odgovori se prosleđuju nazad, zadržavajući status code i većinu headers
- Opcionalno spoofovanje X-Forwarded-For (ako Worker postavi vrednost iz user-controlled headera)
- Veoma brzo/jednostavno rotation deploy-ovanjem više Worker endpointa i fan-outom zahteva

### Kako radi (flow)
1) Klijent šalje HTTP zahtev na Worker URL (`<name>.<account>.workers.dev` ili prilagođenu domensku rutu).
2) Worker izvlači target iz query parametra (?url=...), X-Target-URL headera, ili segmenta putanje ako je tako implementirano.
3) Worker prosleđuje dolaznu metodu, headers i body na specificirani upstream URL (filtrirajući problematične headers).
4) Odgovor iz upstream-a se stream-uje nazad ka klijentu preko Cloudflare; origin vidi Cloudflare izlazne IP adrese.

### Primer implementacije Workera
- Čita target URL iz query parametra, headera, ili putanje
- Kopira bezbedan podskup headers i prosleđuje originalnu metodu/body
- Opcionalno postavlja X-Forwarded-For koristeći user-controlled header (X-My-X-Forwarded-For) ili nasumičnu IP adresu
- Dodaje permisivan CORS i obrađuje preflight

<details>
<summary>Primer Worker-a (JavaScript) za pass-through proxying</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Automatizacija raspoređivanja i rotacije sa FlareProx

FlareProx je Python alat koji koristi Cloudflare API za raspoređivanje više Worker endpoints i rotiranje među njima. Ovo obezbeđuje FireProx-like IP rotation iz Cloudflare mreže.

Setup
1) Kreirajte Cloudflare API Token koristeći šablon “Edit Cloudflare Workers” i preuzmite vaš Account ID sa dashboard-a.
2) Konfigurišite FlareProx:
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Kreirajte konfiguracioni fajl flareprox.json:**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**Korišćenje CLI-a**

- Kreiraj N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Navedite endpoints:
```bash
python3 flareprox.py list
```
- Endpointi za proveru zdravlja:
```bash
python3 flareprox.py test
```
- Obriši sve endpoints:
```bash
python3 flareprox.py cleanup
```
**Usmeravanje saobraćaja kroz Worker**
- Oblik query parametara:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Oblik zaglavlja:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Oblik putanje (ako je implementirano):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Primeri metoda:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` kontrola**

Ako Worker poštuje `X-My-X-Forwarded-For`, možete uticati na upstream vrednost `X-Forwarded-For`:
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Programatsko korišćenje**

Koristite FlareProx biblioteku za kreiranje/listanje/testiranje endpoints i preusmeravanje zahteva iz Pythona.

<details>
<summary>Primer u Pythonu: Pošaljite POST preko slučajnog Worker endpoint-a</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Burp/Scanner integracija**
- Usmerite alatke (na primer, Burp Suite) na Worker URL.
- Obezbedite stvarni upstream koristeći ?url= ili X-Target-URL.
- HTTP semantika (metode/zaglavlja/telo) se zadržava dok maskirate svoj izvorni IP iza Cloudflare-a.

**Operativne napomene i ograničenja**
- Cloudflare Workers Free plan omogućava otprilike 100.000 zahteva/dan po nalogu; koristite više endpointa da raspodelite saobraćaj po potrebi.
- Workers se izvršavaju na mreži Cloudflare-a; mnogi ciljevi će videti samo Cloudflare IP-ove/ASN, što može zaobići naivne liste dozvoljenih/blokiranih IP-a ili geo heuristike.
- Koristite odgovorno i samo uz autorizaciju. Poštujte ToS i robots.txt.

## References
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
