# Abuser Cloudflare Workers en tant que proxies pass-through (rotation d'IP, FireProx-style)

{{#include ../../banners/hacktricks-training.md}}

Cloudflare Workers peuvent être déployés comme des proxies HTTP pass-through transparents où l'URL cible upstream est fournie par le client. Les requêtes sortent du réseau Cloudflare, de sorte que la cible observe les IPs de Cloudflare au lieu de celles du client. Cela reflète la technique bien connue FireProx sur AWS API Gateway, mais utilise Cloudflare Workers.

### Fonctionnalités clés
- Support de toutes les méthodes HTTP (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD)
- La cible peut être fournie via un paramètre de requête (?url=...), un header (X-Target-URL), ou même encodée dans le chemin (par ex. /https://target)
- Les headers et le body sont proxifiés avec filtrage des headers hop-by-hop/nécessaires
- Les réponses sont renvoyées au client en préservant le code de statut et la plupart des headers
- Possibilité facultative de spoofing de X-Forwarded-For (si le Worker le définit à partir d'un header contrôlé par l'utilisateur)
- Rotation extrêmement rapide/aisée en déployant plusieurs endpoints Worker et en répartissant les requêtes

### Comment ça fonctionne (flux)
1) Le client envoie une requête HTTP à une URL Worker (`<name>.<account>.workers.dev` ou une route de domaine custom).
2) Le Worker extrait la cible soit depuis un paramètre de requête (?url=...), le header X-Target-URL, ou un segment de chemin si implémenté.
3) Le Worker relaie la méthode entrante, les headers et le body vers l'URL upstream spécifiée (en filtrant les headers problématiques).
4) La réponse upstream est streamée de retour vers le client via Cloudflare ; l'origine voit les IPs d'egress de Cloudflare.

### Exemple d'implémentation du Worker
- Lit l'URL cible depuis le paramètre de requête, le header, ou le chemin
- Copie un sous-ensemble sûr de headers et relaie la méthode/body original(e)
- Optionnellement définit X-Forwarded-For en utilisant un header contrôlé par l'utilisateur (X-My-X-Forwarded-For) ou une IP aléatoire
- Ajoute un CORS permissif et gère les preflight

<details>
<summary>Example Worker (JavaScript) for pass-through proxying</summary>
```javascript
/**
* Minimal Worker pass-through proxy
* - Target URL from ?url=, X-Target-URL, or /https://...
* - Proxies method/headers/body to upstream; relays response
*/
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
try {
const url = new URL(request.url)
const targetUrl = getTargetUrl(url, request.headers)

if (!targetUrl) {
return errorJSON('No target URL specified', 400, {
usage: {
query_param: '?url=https://example.com',
header: 'X-Target-URL: https://example.com',
path: '/https://example.com'
}
})
}

let target
try { target = new URL(targetUrl) } catch (e) {
return errorJSON('Invalid target URL', 400, { provided: targetUrl })
}

// Forward original query params except control ones
const passthru = new URLSearchParams()
for (const [k, v] of url.searchParams) {
if (!['url', '_cb', '_t'].includes(k)) passthru.append(k, v)
}
if (passthru.toString()) target.search = passthru.toString()

// Build proxied request
const proxyReq = buildProxyRequest(request, target)
const upstream = await fetch(proxyReq)

return buildProxyResponse(upstream, request.method)
} catch (error) {
return errorJSON('Proxy request failed', 500, {
message: error.message,
timestamp: new Date().toISOString()
})
}
}

function getTargetUrl(url, headers) {
let t = url.searchParams.get('url') || headers.get('X-Target-URL')
if (!t && url.pathname !== '/') {
const p = url.pathname.slice(1)
if (p.startsWith('http')) t = p
}
return t
}

function buildProxyRequest(request, target) {
const h = new Headers()
const allow = [
'accept','accept-language','accept-encoding','authorization',
'cache-control','content-type','origin','referer','user-agent'
]
for (const [k, v] of request.headers) {
if (allow.includes(k.toLowerCase())) h.set(k, v)
}
h.set('Host', target.hostname)

// Optional: spoof X-Forwarded-For if provided
const spoof = request.headers.get('X-My-X-Forwarded-For')
h.set('X-Forwarded-For', spoof || randomIP())

return new Request(target.toString(), {
method: request.method,
headers: h,
body: ['GET','HEAD'].includes(request.method) ? null : request.body
})
}

function buildProxyResponse(resp, method) {
const h = new Headers()
for (const [k, v] of resp.headers) {
if (!['content-encoding','content-length','transfer-encoding'].includes(k.toLowerCase())) {
h.set(k, v)
}
}
// Permissive CORS for tooling convenience
h.set('Access-Control-Allow-Origin', '*')
h.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD')
h.set('Access-Control-Allow-Headers', '*')

if (method === 'OPTIONS') return new Response(null, { status: 204, headers: h })
return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers: h })
}

function errorJSON(msg, status=400, extra={}) {
return new Response(JSON.stringify({ error: msg, ...extra }), {
status, headers: { 'Content-Type': 'application/json' }
})
}

function randomIP() { return [1,2,3,4].map(() => Math.floor(Math.random()*255)+1).join('.') }
```
</details>

### Automatiser le déploiement et la rotation avec FlareProx

FlareProx est un outil Python qui utilise l'API Cloudflare pour déployer de nombreux Worker endpoints et effectuer une rotation entre eux. Cela fournit une rotation d'IP de type FireProx depuis le réseau Cloudflare.

Configuration
1) Créez un Cloudflare API Token en utilisant le modèle “Edit Cloudflare Workers” et récupérez votre Account ID depuis le tableau de bord.
2) Configurez FlareProx :
```bash
git clone https://github.com/MrTurvey/flareprox
cd flareprox
pip install -r requirements.txt
```
**Créer le fichier de configuration flareprox.json :**
```json
{
"cloudflare": {
"api_token": "your_cloudflare_api_token",
"account_id": "your_cloudflare_account_id"
}
}
```
**Utilisation CLI**

- Créer N Worker proxies:
```bash
python3 flareprox.py create --count 2
```
- Lister les endpoints :
```bash
python3 flareprox.py list
```
- Points de terminaison de test de santé :
```bash
python3 flareprox.py test
```
- Supprimer tous les endpoints :
```bash
python3 flareprox.py cleanup
```
**Routage du trafic via un Worker**
- Forme du paramètre de requête:
```bash
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/ip"
```
- Format de l'en-tête:
```bash
curl -H "X-Target-URL: https://httpbin.org/ip" https://your-worker.account.workers.dev
```
- Format de chemin (si implémenté):
```bash
curl https://your-worker.account.workers.dev/https://httpbin.org/ip
```
- Exemples de méthodes:
```bash
# GET
curl "https://your-worker.account.workers.dev?url=https://httpbin.org/get"

# POST (form)
curl -X POST -d "username=admin" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/post"

# PUT (JSON)
curl -X PUT -d '{"username":"admin"}' -H "Content-Type: application/json" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/put"

# DELETE
curl -X DELETE \
"https://your-worker.account.workers.dev?url=https://httpbin.org/delete"
```
**`X-Forwarded-For` contrôle**

Si le Worker prend en compte `X-My-X-Forwarded-For`, vous pouvez influencer la valeur en amont `X-Forwarded-For` :
```bash
curl -H "X-My-X-Forwarded-For: 203.0.113.10" \
"https://your-worker.account.workers.dev?url=https://httpbin.org/headers"
```
**Utilisation programmatique**

Utilisez la bibliothèque FlareProx pour créer/lister/t tester des endpoints et router des requêtes depuis Python.

<details>
<summary>Exemple Python: envoyer un POST via un endpoint Worker aléatoire</summary>
```python
#!/usr/bin/env python3
from flareprox import FlareProx, FlareProxError
import json

# Initialize
flareprox = FlareProx(config_file="flareprox.json")
if not flareprox.is_configured:
print("FlareProx not configured. Run: python3 flareprox.py config")
exit(1)

# Ensure endpoints exist
endpoints = flareprox.sync_endpoints()
if not endpoints:
print("Creating proxy endpoints...")
flareprox.create_proxies(count=2)

# Make a POST request through a random endpoint
try:
post_data = json.dumps({
"username": "testuser",
"message": "Hello from FlareProx!",
"timestamp": "2025-01-01T12:00:00Z"
})

headers = {
"Content-Type": "application/json",
"User-Agent": "FlareProx-Client/1.0"
}

response = flareprox.redirect_request(
target_url="https://httpbin.org/post",
method="POST",
headers=headers,
data=post_data
)

if response.status_code == 200:
result = response.json()
print("✓ POST successful via FlareProx")
print(f"Origin IP: {result.get('origin', 'unknown')}")
print(f"Posted data: {result.get('json', {})}")
else:
print(f"Request failed with status: {response.status_code}")

except FlareProxError as e:
print(f"FlareProx error: {e}")
except Exception as e:
print(f"Request error: {e}")
```
</details>

**Burp/Scanner intégration**
- Pointez les outils (par exemple, Burp Suite) vers l'URL du Worker.
- Fournissez l'upstream réel en utilisant ?url= ou X-Target-URL.
- HTTP semantics (methods/headers/body) are preserved while masking your source IP behind Cloudflare.

**Notes opérationnelles et limites**
- Cloudflare Workers Free plan allows roughly 100,000 requests/day per account; use multiple endpoints to distribute traffic if needed.
- Les Workers s'exécutent sur le réseau de Cloudflare ; de nombreuses cibles ne verront que les Cloudflare IPs/ASN, ce qui peut contourner des listes allow/deny IP naïves ou des heuristiques géographiques.
- Utilisez de manière responsable et uniquement avec autorisation. Respectez les ToS et robots.txt.

## Références
- [FlareProx (Cloudflare Workers pass-through/rotation)](https://github.com/MrTurvey/flareprox)
- [Cloudflare Workers fetch() API](https://developers.cloudflare.com/workers/runtime-apis/fetch/)
- [Cloudflare Workers pricing and free tier](https://developers.cloudflare.com/workers/platform/pricing/)
- [FireProx (AWS API Gateway)](https://github.com/ustayready/fireprox)

{{#include ../../banners/hacktricks-training.md}}
