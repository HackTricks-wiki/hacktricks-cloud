# Основна інформація про Jenkins

{{#include ../../banners/hacktricks-training.md}}

## Доступ

### Ім'я користувача + Пароль

Найпоширеніший спосіб входу в Jenkins - це використання імені користувача або пароля.

### Cookie

Якщо **авторизований cookie буде вкрадено**, його можна використовувати для доступу до сесії користувача. Cookie зазвичай називається `JSESSIONID.*`. (Користувач може завершити всі свої сесії, але спочатку йому потрібно дізнатися, що cookie було вкрадено).

### SSO/Плагіни

Jenkins можна налаштувати за допомогою плагінів, щоб бути **доступним через стороннє SSO**.

### Токени

**Користувачі можуть генерувати токени**, щоб надати доступ до додатків для їх ідентифікації через CLI або REST API.

### SSH Ключі

Цей компонент надає вбудований SSH сервер для Jenkins. Це альтернативний інтерфейс для [Jenkins CLI](https://www.jenkins.io/doc/book/managing/cli/), і команди можуть бути викликані таким чином, використовуючи будь-який SSH клієнт. (З [документації](https://plugins.jenkins.io/sshd/))

## Авторизація

У `/configureSecurity` можна **налаштувати метод авторизації Jenkins**. Є кілька варіантів:

- **Будь-хто може робити що завгодно**: Навіть анонімний доступ може адмініструвати сервер.
- **Режим спадщини**: Те ж саме, що і Jenkins <1.164. Якщо у вас є **роль "адміністратор"**, вам буде надано **повний контроль** над системою, а **в іншому випадку** (включаючи **анонімних** користувачів) ви матимете **доступ для читання**.
- **Увійшли користувачі можуть робити що завгодно**: У цьому режимі кожен **увійшовший користувач отримує повний контроль** над Jenkins. Єдиний користувач, який не матиме повного контролю, - це **анонімний користувач**, який отримує лише **доступ для читання**.
- **Матриця безпеки**: Ви можете налаштувати **хто може робити що** в таблиці. Кожен **стовпець** представляє **дозвіл**. Кожен **рядок** **представляє** **користувача або групу/роль.** Це включає спеціального користувача '**анонімний**', який представляє **неавтентифікованих користувачів**, а також '**автентифікований**', який представляє **всіх автентифікованих користувачів**.

![](<../../images/image (149).png>)

- **Стратегія авторизації на основі проекту:** Цей режим є **розширенням** до "**Матриці безпеки**", яке дозволяє додаткову матрицю ACL бути **визначеною для кожного проекту окремо.**
- **Стратегія на основі ролей:** Дозволяє визначати авторизації за допомогою **стратегії на основі ролей**. Керуйте ролями в `/role-strategy`.

## **Область безпеки**

У `/configureSecurity` можна **налаштувати область безпеки.** За замовчуванням Jenkins включає підтримку кількох різних областей безпеки:

- **Делегувати контейнеру сервлетів**: Для **делегування аутентифікації контейнеру сервлетів, що працює на контролері Jenkins**, наприклад, [Jetty](https://www.eclipse.org/jetty/).
- **Власна база даних користувачів Jenkins:** Використовуйте **вбудовану базу даних користувачів Jenkins** для аутентифікації замість делегування зовнішній системі. Це включено за замовчуванням.
- **LDAP**: Делегувати всю аутентифікацію на налаштований LDAP сервер, включаючи як користувачів, так і групи.
- **База даних користувачів/груп Unix**: **Делегує аутентифікацію на базу даних користувачів Unix** на контролері Jenkins. Цей режим також дозволить повторно використовувати групи Unix для авторизації.

Плагіни можуть надавати додаткові області безпеки, які можуть бути корисними для інтеграції Jenkins в існуючі системи ідентифікації, такі як:

- [Active Directory](https://plugins.jenkins.io/active-directory)
- [GitHub Authentication](https://plugins.jenkins.io/github-oauth)
- [Atlassian Crowd 2](https://plugins.jenkins.io/crowd2)

## Вузли, агенти та виконавці Jenkins

Визначення з [документації](https://www.jenkins.io/doc/book/managing/nodes/):

**Вузли** - це **машини**, на яких працюють **агенти збірки**. Jenkins контролює кожен підключений вузол на наявність вільного місця на диску, вільного тимчасового місця, вільного обміну, часу/синхронізації годинника та часу відгуку. Вузол виводиться з експлуатації, якщо будь-яке з цих значень виходить за межі налаштованого порогу.

**Агенти** **керують** **виконанням завдань** від імені контролера Jenkins, використовуючи **виконавців**. Агент може використовувати будь-яку операційну систему, яка підтримує Java. Інструменти, необхідні для збірок і тестів, встановлюються на вузлі, де працює агент; їх можна **встановити безпосередньо або в контейнері** (Docker або Kubernetes). Кожен **агент фактично є процесом зі своїм PID** на хост-машині.

**Виконавець** - це **слот для виконання завдань**; фактично, це **потік в агенті**. **Кількість виконавців** на вузлі визначає кількість **паралельних завдань**, які можуть бути виконані на цьому вузлі одночасно. Іншими словами, це визначає **кількість паралельних Pipeline `стадій`**, які можуть виконуватися на цьому вузлі одночасно.

## Секрети Jenkins

### Шифрування секретів і облікових даних

Визначення з [документації](https://www.jenkins.io/doc/developer/security/secrets/#encryption-of-secrets-and-credentials): Jenkins використовує **AES для шифрування та захисту секретів**, облікових даних та їх відповідних ключів шифрування. Ці ключі шифрування зберігаються в `$JENKINS_HOME/secrets/` разом з майстер-ключем, що використовується для захисту цих ключів. Цю директорію слід налаштувати так, щоб лише користувач операційної системи, під яким працює контролер Jenkins, мав доступ на читання та запис до цієї директорії (тобто значення `chmod` повинно бути `0700` або використовувати відповідні атрибути файлів). **Майстер-ключ** (іноді називається "ключ шифрування" у криптографії) **зберігається \_незашифрованим\_** на файловій системі контролера Jenkins у **`$JENKINS_HOME/secrets/master.key`**, що не захищає від атакуючих з прямим доступом до цього файлу. Більшість користувачів і розробників використовуватимуть ці ключі шифрування непрямо через API [Secret](https://javadoc.jenkins.io/byShortName/Secret) для шифрування загальних секретних даних або через API облікових даних. Для криптоцікавих, Jenkins використовує AES в режимі шифрувального блоку з ланцюгуванням (CBC) з PKCS#5 заповненням і випадковими IV для шифрування екземплярів [CryptoConfidentialKey](https://javadoc.jenkins.io/byShortName/CryptoConfidentialKey), які зберігаються в `$JENKINS_HOME/secrets/` з ім'ям файлу, що відповідає їх `CryptoConfidentialKey` id. Загальні id ключів включають:

- `hudson.util.Secret`: використовується для загальних секретів;
- `com.cloudbees.plugins.credentials.SecretBytes.KEY`: використовується для деяких типів облікових даних;
- `jenkins.model.Jenkins.crumbSalt`: використовується механізмом [CSRF захисту](https://www.jenkins.io/doc/book/managing/security/#cross-site-request-forgery); і

### Доступ до облікових даних

Облікові дані можуть бути **обмежені глобальними постачальниками** (`/credentials/`), до яких може отримати доступ будь-який налаштований проект, або можуть бути обмежені **конкретними проектами** (`/job/<project-name>/configure`) і, отже, доступні лише з конкретного проекту.

Згідно з [**документацією**](https://www.jenkins.io/blog/2019/02/21/credentials-masking/): Облікові дані, які знаходяться в межах, стають доступними для конвеєра без обмежень. Щоб **запобігти випадковому розкриттю в журналі збірки**, облікові дані **маскуються** від звичайного виводу, тому виклик `env` (Linux) або `set` (Windows), або програми, що друкують своє середовище або параметри, **не розкриють їх у журналі збірки** для користувачів, які інакше не мали б доступу до облікових даних.

**Ось чому, щоб ексфільтрувати облікові дані, атакуючий повинен, наприклад, закодувати їх у base64.**

## Посилання

- [https://www.jenkins.io/doc/book/security/managing-security/](https://www.jenkins.io/doc/book/security/managing-security/)
- [https://www.jenkins.io/doc/book/managing/nodes/](https://www.jenkins.io/doc/book/managing/nodes/)
- [https://www.jenkins.io/doc/developer/security/secrets/](https://www.jenkins.io/doc/developer/security/secrets/)
- [https://www.jenkins.io/blog/2019/02/21/credentials-masking/](https://www.jenkins.io/blog/2019/02/21/credentials-masking/)
- [https://www.jenkins.io/doc/book/managing/security/#cross-site-request-forgery](https://www.jenkins.io/doc/book/managing/security/#cross-site-request-forgery)
- [https://www.jenkins.io/doc/developer/security/secrets/#encryption-of-secrets-and-credentials](https://www.jenkins.io/doc/developer/security/secrets/#encryption-of-secrets-and-credentials)
- [https://www.jenkins.io/doc/book/managing/nodes/](https://www.jenkins.io/doc/book/managing/nodes/)

{{#include ../../banners/hacktricks-training.md}}
