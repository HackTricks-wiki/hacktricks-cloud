# Gitblit Ενσωματωμένη Παράκαμψη Αυθεντικοποίησης SSH (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## Περίληψη

CVE-2024-28080 είναι μια παράκαμψη αυθεντικοποίησης στην ενσωματωμένη υπηρεσία SSH του Gitblit λόγω λανθασμένης διαχείρισης του session state κατά την ενσωμάτωση με Apache MINA SSHD. Εάν ένας λογαριασμός χρήστη έχει εγγεγραμμένο τουλάχιστον ένα SSH public key, ένας επιτιθέμενος που γνωρίζει το όνομα χρήστη και οποιοδήποτε από τα public keys αυτού του χρήστη μπορεί να αυθεντικοποιηθεί χωρίς το ιδιωτικό κλειδί και χωρίς τον κωδικό πρόσβασης.

- Affected: Gitblit < 1.10.0 (observed on 1.9.3)
- Fixed: 1.10.0
- Requirements to exploit:
- Git over SSH enabled on the instance
- Ο λογαριασμός θύματος έχει τουλάχιστον ένα SSH public key καταχωρημένο στο Gitblit
- Ο επιτιθέμενος γνωρίζει το username του θύματος και ένα από τα public keys του (συχνά ανακαλύψιμο, π.χ., https://github.com/<username>.keys)

## Βασική αιτία (state leaks between SSH methods)

Στο RFC 4252, η public‑key authentication προχωρά σε δύο φάσεις: ο server πρώτα ελέγχει αν ένα παρεχόμενο public key είναι αποδεκτό για ένα username, και μόνο μετά από ένα challenge/response με υπογραφή γίνεται η τελική αυθεντικοποίηση του χρήστη. Στο MINA SSHD, το PublickeyAuthenticator καλείται δύο φορές: κατά την αποδοχή του κλειδιού (ακόμα χωρίς υπογραφή) και αργότερα όταν ο client επιστρέψει υπογραφή.

Το PublickeyAuthenticator του Gitblit τροποποιούσε το session context στην πρώτη, προ‑υπογραφής κλήση, συσχετίζοντας το UserModel με το session και επιστρέφοντας true ("key acceptable"). Όταν η αυθεντικοποίηση αργότερα έπεφτε πίσω στο password, το PasswordAuthenticator εμπιστευόταν αυτό το μεταβλημένο session state και συντόμευε τη διαδικασία, επιστρέφοντας true χωρίς να επαληθεύσει τον κωδικό. Ως αποτέλεσμα, οποιοσδήποτε κωδικός (συμπεριλαμβανομένου του κενό) γινόταν αποδεκτός μετά από μια προηγούμενη δημόσια‑κλειδιού "αποδοχή" για τον ίδιο χρήστη.

Υψηλού επιπέδου ελαττωματική ροή:

1) Client προσφέρει username + public key (ακόμα χωρίς υπογραφή)  
2) Server αναγνωρίζει ότι το κλειδί ανήκει στον χρήστη και προωρό προσδέτει τον χρήστη στο session, επιστρέφοντας true ("acceptable")  
3) Client δεν μπορεί να υπογράψει (δεν υπάρχει private key), οπότε η auth πέφτει πίσω στο password  
4) Η password auth βλέπει ότι υπάρχει ήδη χρήστης στο session και χωρίς προϋποθέσεις επιστρέφει επιτυχία

## Βήμα‑βήμα εκμετάλλευση

- Συλλέξτε το username του θύματος και ένα από τα public keys του:
- Το GitHub εκθέτει public keys στο https://github.com/<username>.keys
- Public servers συχνά εκθέτουν αρχεία authorized_keys
- Διαμορφώστε το OpenSSH ώστε να παρουσιάζει μόνο το δημόσιο μισό ώστε η δημιουργία υπογραφής να αποτύχει, αναγκάζοντας fallback στον κωδικό ενώ παράλληλα ενεργοποιείται η διαδρομή αποδοχής public‑key στον server.

Example SSH client config (no private key available):
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
Συνδεθείτε και πατήστε Enter στο password prompt (ή πληκτρολογήστε οποιαδήποτε string):
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Η αυθεντικοποίηση επιτυγχάνεται επειδή το προηγούμενο στάδιο public‑key μετέβαλε τη συνεδρία σε επαληθευμένο χρήστη, και η password auth εμπιστεύεται εσφαλμένα αυτή την κατάσταση.

Note: Εάν το ControlMaster multiplexing είναι ενεργοποιημένο στο SSH config σας, οι επόμενες εντολές Git μπορεί να επαναχρησιμοποιήσουν την επαληθευμένη σύνδεση, αυξάνοντας τον αντίκτυπο.

## Επιπτώσεις

- Πλήρης προσωποποίηση οποιουδήποτε χρήστη Gitblit που έχει τουλάχιστον ένα καταχωρισμένο SSH public key
- Πρόσβαση ανάγνωσης/εγγραφής σε αποθετήρια σύμφωνα με τα δικαιώματα του θύματος (source exfiltration, unauthorized pushes, supply‑chain risks)
- Πιθανός διοικητικός αντίκτυπος εάν στοχευτεί χρήστης admin
- Καθαρά network exploit· δεν απαιτείται brute force ή private key

## Ιδέες εντοπισμού

- Ελέγξτε τα SSH logs για ακολουθίες όπου μια προσπάθεια publickey ακολουθείται από επιτυχημένη password authentication με κενό ή πολύ σύντομο password
- Αναζητήστε ροές: publickey method που προσφέρει μη υποστηριζόμενο/ασύμβατο key material και ακολουθείται από άμεση επιτυχία password για το ίδιο username

## Μετριασμοί

- Αναβαθμίστε σε Gitblit v1.10.0+
- Μέχρι την αναβάθμιση:
  - Απενεργοποιήστε το Git over SSH στο Gitblit, ή
  - Περιορίστε την πρόσβαση δικτύου στην SSH service, και
  - Παρακολουθήστε για ύποπτα μοτίβα που περιγράφονται παραπάνω
- Αλλάξτε/ανανεώστε τα credentials των επηρεαζόμενων χρηστών εάν υπάρχει υποψία συμβιβασμού

## Γενικά: κατάχρηση SSH auth method state‑leakage (MINA/OpenSSH‑based services)

Πρότυπο: Εάν ο public‑key authenticator ενός server μεταβάλλει την κατάσταση χρήστη/συνεδρίας κατά τη διάρκεια του pre‑signature "key acceptable" σταδίου και άλλοι authenticators (π.χ. password) εμπιστεύονται αυτή την κατάσταση, μπορείτε να παρακάμψετε την αυθεντικοποίηση με:

- Παρουσίαση ενός έγκυρου public key για τον στοχευόμενο χρήστη (χωρίς private key)
- Αναγκάζοντας τον client να αποτύχει στο signing ώστε ο server να υποχωρήσει σε password
- Παροχή οποιουδήποτε password ενώ ο password authenticator short‑circuits λόγω leaked state

Πρακτικές συμβουλές:

- Public key harvesting at scale: εξαγάγετε public keys από κοινές πηγές όπως https://github.com/<username>.keys, οργανωτικούς καταλόγους, σελίδες ομάδων, leaked authorized_keys
- Forcing signature failure (client‑side): ρυθμίστε το IdentityFile ώστε να δείχνει μόνο στο .pub, θέστε IdentitiesOnly yes, κρατήστε το PreferredAuthentications να περιλαμβάνει publickey και μετά password
- MINA SSHD integration pitfalls:
  - PublickeyAuthenticator.authenticate(...) δεν πρέπει να επισυνάπτει user/session state μέχρι η post‑signature verification διαδρομή να επιβεβαιώσει την υπογραφή
  - PasswordAuthenticator.authenticate(...) δεν πρέπει να συμπεράνει επιτυχία από οποιαδήποτε κατάσταση μεταβλήθηκε κατά τη διάρκεια μιας προηγούμενης, ελλιπούς authentication μεθόδου

Σχετικές σημειώσεις πρωτοκόλλου/σχεδιασμού και βιβλιογραφία:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Ιστορικές συζητήσεις για early acceptance oracles και auth races, π.χ. διαμάχες CVE‑2016‑20012 γύρω από τη συμπεριφορά του OpenSSH

## References

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
