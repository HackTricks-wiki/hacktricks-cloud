# Gitblit Embedded SSH Auth Bypass (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## Sommario

CVE-2024-28080 è un bypass di autenticazione nel servizio SSH embedded di Gitblit dovuto a una gestione incorretta dello stato di sessione nell'integrazione con Apache MINA SSHD. Se un account utente ha almeno una SSH public key registrata, un attaccante che conosce lo username e una delle public key dell'utente può autenticarsi senza la private key e senza la password.

- Affetti: Gitblit < 1.10.0 (osservato su 1.9.3)
- Corretto: 1.10.0
- Requisiti per l'exploit:
- Git over SSH abilitato sull'istanza
- L'account vittima ha almeno una SSH public key registrata in Gitblit
- L'attaccante conosce lo username della vittima e una delle sue public key (spesso reperibile, es. https://github.com/<username>.keys)

## Causa principale (state leaks between SSH methods)

Nel RFC 4252, la public‑key authentication procede in due fasi: il server prima verifica se una public key fornita è accettabile per uno username, e solo dopo un challenge/response con una signature autentica l'utente. In MINA SSHD, il PublickeyAuthenticator viene invocato due volte: al momento dell'accettazione della key (ancora senza signature) e più tardi dopo che il client ritorna la signature.

Il PublickeyAuthenticator di Gitblit mutava il contesto di sessione nella prima chiamata pre‑signature legando lo UserModel autenticato alla sessione e restituendo true ("key acceptable"). Quando l'autenticazione successivamente ricadeva sulla password, il PasswordAuthenticator si è fidato di quello stato di sessione mutato e ha scavalcato la verifica, restituendo true senza validare la password. Di conseguenza, qualsiasi password (inclusa vuota) veniva accettata dopo una precedente "acceptance" della public‑key per lo stesso utente.

Flusso difettoso ad alto livello:

1) Client offre username + public key (ancora nessuna signature)
2) Server riconosce la key come appartenente all'utente e associa prematuramente l'utente alla sessione, restituendo true ("acceptable")
3) Il client non può firmare (nessuna private key), quindi l'autenticazione ricade sulla password
4) L'autenticazione via password vede un utente già presente nella sessione e restituisce success senza condizioni

## Sfruttamento passo‑per‑passo

- Raccogliere lo username della vittima e una delle sue public key:
- GitHub espone le public key su https://github.com/<username>.keys
- I server pubblici spesso espongono authorized_keys
- Configurare OpenSSH per presentare solo la metà pubblica così la generazione della signature fallisce, forzando il fallback alla password mentre si innesca comunque il percorso di acceptance della public‑key sul server.

Example SSH client config (no private key available):
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
Connettiti e premi Invio al prompt della password (o digita qualsiasi stringa):
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Authentication succeeds because the earlier public‑key phase mutated the session to an authenticated user, and password auth incorrectly trusts that state.

Nota: Se ControlMaster multiplexing è abilitato nella tua SSH config, i comandi Git successivi possono riutilizzare la connessione autenticata, aumentando l'impatto.

## Impact

- Impersonificazione completa di qualsiasi utente Gitblit con almeno una SSH public key registrata
- Accesso in lettura/scrittura ai repository in base ai permessi della vittima (source exfiltration, push non autorizzati, rischi per la supply‑chain)
- Potenziale impatto amministrativo se si prende di mira un utente admin
- Exploit puramente di rete; nessuna brute force o private key richiesta

## Detection ideas

- Esaminare i log SSH per sequenze in cui un tentativo publickey è seguito da una password authentication riuscita con una password vuota o molto corta
- Cercare flussi: publickey method che offre materiale di chiave non supportato/non corrispondente seguito da un successo immediato di password per lo stesso username

## Mitigations

- Upgrade to Gitblit v1.10.0+
- Until upgraded:
- Disabilitare Git over SSH su Gitblit, oppure
- Restringere l'accesso di rete al servizio SSH, e
- Monitorare la presenza dei pattern sospetti descritti sopra
- Ruotare le credenziali degli utenti interessati se si sospetta un compromesso

## General: abusing SSH auth method state‑leakage (MINA/OpenSSH‑based services)

Pattern: Se il public‑key authenticator di un server muta lo stato utente/sessione durante la fase pre‑signature "key acceptable" e altri authenticators (es., password) si fidano di quello stato, puoi bypassare l'autenticazione tramite:

- Presentare una public key legittima per l'utente target (nessuna private key)
- Forzare il client a fallire la signing così il server ricade su password
- Fornire qualsiasi password mentre il password authenticator si short‑circuits sul leaked state

Consigli pratici:

- Public key harvesting su larga scala: recuperare public keys da fonti comuni come https://github.com/<username>.keys, organizational directories, team pages, leaked authorized_keys
- Forzare la signature failure (client‑side): impostare IdentityFile solo sul .pub, settare IdentitiesOnly yes, mantenere PreferredAuthentications per includere publickey poi password
- MINA SSHD integration pitfalls:
- PublickeyAuthenticator.authenticate(...) non deve allegare stato utente/sessione fino a quando il percorso di verifica post‑signature non conferma la signature
- PasswordAuthenticator.authenticate(...) non deve inferire il successo da alcuno stato mutato durante un metodo di authentication precedente e incompleto

Related protocol/design notes and literature:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Historical discussions on early acceptance oracles and auth races, e.g., CVE‑2016‑20012 disputes around OpenSSH behavior

## References

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
