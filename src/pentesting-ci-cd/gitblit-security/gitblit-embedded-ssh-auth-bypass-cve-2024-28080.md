# Gitblit Embedded SSH Auth Bypass (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## 요약

CVE-2024-28080은 Apache MINA SSHD와 통합할 때 세션 상태 처리가 잘못되어 Gitblit의 embedded SSH 서비스에서 발생하는 authentication bypass입니다. 사용자 계정에 적어도 하나의 SSH public key가 등록되어 있으면, 공격자는 사용자 이름과 해당 사용자의 public key 중 하나를 알고 있는 경우 private key나 비밀번호 없이 인증할 수 있습니다.

- Affected: Gitblit < 1.10.0 (관찰: 1.9.3)
- Fixed: 1.10.0
- Requirements to exploit:
  - Git over SSH가 인스턴스에서 활성화되어 있어야 함
  - 피해자 계정에 Gitblit에 등록된 적어도 하나의 SSH public key가 있어야 함
  - 공격자가 피해자의 사용자 이름과 그 중 하나의 public key를 알고 있어야 함 (종종 노출됨, 예: https://github.com/<username>.keys)

## Root cause (state leaks between SSH methods)

RFC 4252에 따르면 public‑key authentication은 두 단계로 진행됩니다: 서버는 먼저 제공된 public key가 사용자 이름에 대해 허용되는지 확인하고, 클라이언트가 서명으로 응답한 이후에야 사용자를 인증합니다. MINA SSHD에서는 PublickeyAuthenticator가 두 번 호출됩니다: key 허용 시(아직 서명 없음)와 나중에 클라이언트가 서명을 반환한 후입니다.

Gitblit의 PublickeyAuthenticator는 첫 번째, 서명 이전 호출에서 세션 컨텍스트를 변경하여 인증된 UserModel을 세션에 바인딩하고 true를 반환("key acceptable")했습니다. 이후 인증이 password로 폴백될 때 PasswordAuthenticator는 변경된 세션 상태를 신뢰하고 단축 경로로 성공을 반환하여 비밀번호를 검증하지 않았습니다. 결과적으로 동일 사용자에 대해 이전에 public‑key "acceptance"가 있었던 경우, 어떤 비밀번호(비어 있는 값 포함)도 허용되었습니다.

높은 수준의 결함 흐름:

1) 클라이언트가 사용자 이름 + public key를 제시 (아직 서명 없음)  
2) 서버는 해당 키가 사용자에 속하는 것으로 인식하고 조기에 사용자를 세션에 연결하여 true 반환("acceptable")  
3) 클라이언트는 서명할 수 없음(비공개 키 없음), 그래서 인증이 password로 폴백  
4) Password auth는 세션에 이미 사용자 정보가 있는 것을 보고 무조건 성공 반환

## 단계별 익스플로잇

- 피해자의 사용자 이름과 그들의 public key 중 하나를 수집:
  - GitHub는 공개 키를 https://github.com/<username>.keys 에 노출함
  - 공개 서버는 종종 authorized_keys를 노출함
- OpenSSH를 구성하여 public half만 제시하도록 하여 서명 생성에 실패하게 하고, 서버에서 public‑key acceptance 경로를 여전히 트리거하면서 password 폴백을 강제함.

Example SSH client config (no private key available):
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
연결한 후 비밀번호 프롬프트에서 Enter 키를 누르세요(또는 아무 문자열을 입력하세요):
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Authentication succeeds because the earlier public‑key phase mutated the session to an authenticated user, and password auth incorrectly trusts that state.

Note: If ControlMaster multiplexing is enabled in your SSH config, subsequent Git commands may reuse the authenticated connection, increasing impact.

## Impact

- Full impersonation of any Gitblit user with at least one registered SSH public key
- Read/write access to repositories per victim’s permissions (source exfiltration, unauthorized pushes, supply‑chain risks)
- Potential administrative impact if targeting an admin user
- Pure network exploit; no brute force or private key required

## Detection ideas

- Review SSH logs for sequences where a publickey attempt is followed by a successful password authentication with an empty or very short password
- Look for flows: publickey method offering unsupported/mismatched key material followed by immediate password success for the same username

## Mitigations

- Upgrade to Gitblit v1.10.0+
- Until upgraded:
- Disable Git over SSH on Gitblit, or
- Restrict network access to the SSH service, and
- Monitor for suspicious patterns described above
- Rotate affected user credentials if compromise is suspected

## General: abusing SSH auth method state‑leakage (MINA/OpenSSH‑based services)

패턴: 서버의 public‑key authenticator가 pre‑signature "key acceptable" 단계에서 사용자/세션 state를 변경(mutate)하고 다른 authenticators(e.g., password)가 그 state를 신뢰하면, 다음과 같이 인증을 우회할 수 있습니다:

- 타깃 사용자에 대한 합법적인 public key를 제시 (private key 불필요)
- 클라이언트가 서명에 실패하게 강제하여 서버가 password로 폴백하게 함
- password authenticator가 leaked state에서 단축 판단(short‑circuit)하는 동안 임의의 password를 제출

실용 팁:

- Public key harvesting at scale: https://github.com/<username>.keys, organizational directories, team pages, leaked authorized_keys 같은 일반적인 출처에서 public keys를 수집
- Forcing signature failure (client‑side): IdentityFile을 .pub 파일만 가리키게 설정, IdentitiesOnly yes로 설정, PreferredAuthentications에 publickey 이후 password를 포함하도록 유지
- MINA SSHD integration pitfalls:
- PublickeyAuthenticator.authenticate(...) must not attach user/session state until the post‑signature verification path confirms the signature
- PasswordAuthenticator.authenticate(...) must not infer success from any state mutated during a prior, incomplete authentication method

Related protocol/design notes and literature:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Historical discussions on early acceptance oracles and auth races, e.g., CVE‑2016‑20012 disputes around OpenSSH behavior

## References

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
