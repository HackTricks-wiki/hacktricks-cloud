# Gitblit Embedded SSH Auth Bypass (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## Zusammenfassung

CVE-2024-28080 ist eine Authentifizierungsumgehung im embedded SSH‑Service von Gitblit aufgrund fehlerhafter Handhabung des Session‑Zustands bei der Integration mit Apache MINA SSHD. Wenn ein Benutzerkonto mindestens einen registrierten SSH‑Public‑Key hat, kann ein Angreifer, der den Benutzernamen und einen der öffentlichen Schlüssel dieses Benutzers kennt, sich ohne den privaten Schlüssel und ohne Passwort authentifizieren.

- Betroffen: Gitblit < 1.10.0 (beobachtet in 1.9.3)
- Behoben: 1.10.0
- Voraussetzungen für die Ausnutzung:
- Git over SSH enabled on the instance
- Das Konto des Opfers hat mindestens einen SSH public key in Gitblit registriert
- Der Angreifer kennt den Benutzernamen des Opfers und einen ihrer öffentlichen Schlüssel (oft auffindbar, z. B. https://github.com/<username>.keys)

## Root cause (state leaks between SSH methods)

In RFC 4252 verläuft die Public‑Key‑Authentifizierung in zwei Phasen: Der Server prüft zunächst, ob ein übergebener Public Key für einen Benutzernamen akzeptabel ist, und erst nach einem Challenge/Response mit einer Signatur authentifiziert er den Benutzer. In MINA SSHD wird der PublickeyAuthenticator zweimal aufgerufen: beim Key‑Acceptance (noch keine Signatur) und später, nachdem der Client eine Signatur zurückgibt.

Der PublickeyAuthenticator von Gitblit veränderte den Session‑Kontext beim ersten, vor der Signatur erfolgenden Aufruf, indem er das authentifizierte UserModel an die Session band und true zurückgab ("key acceptable"). Wenn die Authentifizierung später auf Passwort zurückfiel, vertraute der PasswordAuthenticator dem veränderten Session‑Zustand und machte abkürzend true, ohne das Passwort zu prüfen. Infolgedessen wurde nach einer vorherigen Public‑Key‑"Akzeptanz" für denselben Benutzer jedes Passwort (einschließlich leerer) akzeptiert.

Fehlerhafter Ablauf auf hoher Ebene:

1) Client bietet Benutzernamen + öffentlichen Schlüssel an (noch keine Signatur)  
2) Server erkennt den Schlüssel als zum Benutzer gehörig, hängt vorzeitig den User an die Session und gibt true zurück ("acceptable")  
3) Client kann nicht signieren (kein privater Schlüssel), daher fällt die Auth auf Passwort zurück  
4) Die Passwort‑Authentifizierung sieht bereits einen User in der Session und gibt bedingungslos Erfolg zurück

## Schritt‑für‑Schritt‑Ausnutzung

- Sammle den Benutzernamen des Opfers und einen ihrer öffentlichen Schlüssel:
- GitHub stellt öffentliche Schlüssel unter https://github.com/<username>.keys bereit
- Öffentliche Server veröffentlichen oft authorized_keys
- Konfiguriere OpenSSH so, dass nur die öffentliche Hälfte präsentiert wird, sodass die Signaturerzeugung fehlschlägt und ein Fallback auf Passwort erzwungen wird, während auf dem Server trotzdem der public‑key‑Acceptance‑Pfad ausgelöst wird.

Beispiel SSH‑Client‑Konfiguration (kein privater Schlüssel verfügbar):
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
Verbinde dich und drücke bei der Passwortaufforderung Enter (oder gib irgendeinen string ein):
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Die Authentifizierung gelingt, weil die vorherige public‑key‑Phase die Session in einen authentifizierten Benutzer verändert hat, und password auth diesem Zustand fälschlicherweise vertraut.

Hinweis: Wenn ControlMaster‑Multiplexing in Ihrer SSH‑Konfiguration aktiviert ist, können nachfolgende Git‑Befehle die bereits authentifizierte Verbindung wiederverwenden, wodurch die Auswirkungen steigen.

## Impact

- Vollständige Identitätsübernahme (Impersonation) jedes Gitblit‑Benutzers mit mindestens einem registrierten SSH public key
- Lese-/Schreibzugriff auf Repositories entsprechend den Rechten des Opfers (Quellcode‑Exfiltration, unautorisierte Pushes, Supply‑Chain‑Risiken)
- Potenzieller administrativer Schaden bei Angriff auf einen Admin‑Benutzer
- Reiner Netzwerk‑Exploit; kein Brute‑Force oder privater Schlüssel erforderlich

## Detection ideas

- Überprüfen Sie SSH‑Logs auf Sequenzen, in denen ein publickey‑Versuch von einer erfolgreichen password‑Authentifizierung mit einem leeren oder sehr kurzen Passwort gefolgt wird
- Suchen Sie nach Abläufen: publickey‑Methode bietet nicht unterstütztes/fehlangepasstes Schlüsselmaterial an, gefolgt von sofortigem Passwort‑Erfolg für denselben Benutzernamen

## Mitigations

- Upgrade to Gitblit v1.10.0+
- Until upgraded:
- Disable Git over SSH on Gitblit, or
- Restrict network access to the SSH service, and
- Monitor for suspicious patterns described above
- Rotate affected user credentials if compromise is suspected

## General: abusing SSH auth method state‑leakage (MINA/OpenSSH‑based services)

Muster: Wenn der public‑key‑Authenticator eines Servers Benutzer-/Session‑Zustand während der pre‑signature "key acceptable"‑Phase mutiert und andere Authenticators (z. B. password) diesem Zustand vertrauen, kann die Authentifizierung wie folgt umgangen werden:

- Vorzeigen eines legitimen public key des Zielbenutzers (kein privater Schlüssel)
- Den Client zum Signaturfehler zwingen, sodass der Server auf password zurückfällt
- Beliebiges Passwort eingeben, während der password‑Authenticator aufgrund des leaked state kurzschließt

Praktische Tipps:

- Public key harvesting at scale: pull public keys from common sources such as https://github.com/<username>.keys, organizational directories, team pages, leaked authorized_keys
- Forcing signature failure (client‑side): point IdentityFile to only the .pub, set IdentitiesOnly yes, keep PreferredAuthentications to include publickey then password
- MINA SSHD integration pitfalls:
- PublickeyAuthenticator.authenticate(...) must not attach user/session state until the post‑signature verification path confirms the signature
- PasswordAuthenticator.authenticate(...) must not infer success from any state mutated during a prior, incomplete authentication method

Related protocol/design notes and literature:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Historical discussions on early acceptance oracles and auth races, e.g., CVE‑2016‑20012 disputes around OpenSSH behavior

## References

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
