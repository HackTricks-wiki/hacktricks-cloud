# Gitblit Embedded SSH Auth Bypass (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## Résumé

CVE-2024-28080 est un contournement d'authentification dans le service SSH embarqué de Gitblit dû à une gestion incorrecte de l'état de session lors de l'intégration avec Apache MINA SSHD. Si un compte utilisateur a au moins une clé publique SSH enregistrée, un attaquant qui connaît le nom d'utilisateur et l'une des clés publiques de cet utilisateur peut s'authentifier sans la clé privée et sans le mot de passe.

- Affectés : Gitblit < 1.10.0 (observé sur 1.9.3)
- Corrigé : 1.10.0
- Conditions requises pour l'exploitation :
- Git over SSH activé sur l'instance
- Le compte victime a au moins une clé publique SSH enregistrée dans Gitblit
- L'attaquant connaît le nom d'utilisateur de la victime et l'une de ses clés publiques (souvent découvrable, par ex. https://github.com/<username>.keys)

## Cause principale (state leaks between SSH methods)

Dans le RFC 4252, l'authentification par clé publique se déroule en deux phases : le serveur vérifie d'abord si une clé publique fournie est acceptable pour un nom d'utilisateur, et ce n'est qu'après un challenge/response avec une signature qu'il authentifie l'utilisateur. Dans MINA SSHD, le PublickeyAuthenticator est invoqué deux fois : lors de l'acceptation de la clé (pas encore de signature) et plus tard après que le client renvoie une signature.

Le PublickeyAuthenticator de Gitblit modifiait le contexte de session lors du premier appel pré‑signature en liant le UserModel authentifié à la session et en renvoyant true ("key acceptable"). Lorsque l'authentification revenait ensuite au mot de passe, le PasswordAuthenticator faisait confiance à cet état de session muté et court‑circuitait, renvoyant true sans valider le mot de passe. En conséquence, tout mot de passe (y compris vide) était accepté après une précédente "acceptance" par clé publique pour le même utilisateur.

Flux général défaillant :

1) Le client propose le nom d'utilisateur + la clé publique (pas encore de signature)  
2) Le serveur reconnaît que la clé appartient à l'utilisateur et attache prématurément l'utilisateur à la session, renvoie true ("acceptable")  
3) Le client ne peut pas signer (pas de clé privée), donc l'authentification bascule sur le mot de passe  
4) L'authentification par mot de passe voit un utilisateur déjà présent dans la session et renvoie le succès sans condition

## Exploitation pas à pas

- Récupérer le nom d'utilisateur de la victime et l'une de ses clés publiques :
- GitHub expose les clés publiques à https://github.com/<username>.keys
- Les serveurs publics exposent souvent authorized_keys
- Configurer OpenSSH pour ne présenter que la partie publique afin que la génération de signature échoue, forçant un repli sur le mot de passe tout en déclenchant néanmoins le chemin d'acceptation par clé publique sur le serveur.

Exemple de configuration client SSH (pas de clé privée disponible) :
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
Connectez-vous et appuyez sur Entrée à l'invite du mot de passe (ou tapez n'importe quelle chaîne) :
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Authentication succeeds because the earlier public‑key phase mutated the session to an authenticated user, and password auth incorrectly trusts that state.

Remarque : Si ControlMaster multiplexing est activé dans votre SSH config, les commandes Git suivantes peuvent réutiliser la connexion authentifiée, augmentant l'impact.

## Impact

- Usurpation complète de n'importe quel utilisateur Gitblit disposant d'au moins une public key SSH enregistrée
- Accès en lecture/écriture aux repositories selon les permissions de la victime (exfiltration de source, pushes non autorisés, risques pour la supply‑chain)
- Impact administratif potentiel si l'on cible un admin user
- Exploit purement réseau ; aucun brute force ni private key requis

## Detection ideas

- Examinez les logs SSH pour des séquences où une tentative publickey est suivie d'une authentification password réussie avec un mot de passe vide ou très court
- Recherchez des flux : méthode publickey offrant du key material non supporté/non correspondant suivie d'un succès password immédiat pour le même username

## Mitigations

- Upgrade to Gitblit v1.10.0+
- Until upgraded:
- Disable Git over SSH on Gitblit, or
- Restrict network access to the SSH service, and
- Monitor for suspicious patterns described above
- Rotate affected user credentials if compromise is suspected

## General: abusing SSH auth method state‑leakage (MINA/OpenSSH‑based services)

Pattern: Si l'authentificateur public‑key d'un serveur modifie l'état user/session durant la phase pré‑signature "key acceptable" et que d'autres authenticators (par ex., password) font confiance à cet état, vous pouvez bypass l'authentification en :

- Présentant une public key légitime pour l'utilisateur cible (sans private key)
- Forçant le client à échouer la signature pour que le serveur retombe sur password
- Fournissant n'importe quel password pendant que le password authenticator court‑circuite sur l'état leak

Practical tips:

- Public key harvesting at scale: pull public keys from common sources such as https://github.com/<username>.keys, organizational directories, team pages, leaked authorized_keys
- Forcing signature failure (client‑side): point IdentityFile to only the .pub, set IdentitiesOnly yes, keep PreferredAuthentications to include publickey then password
- MINA SSHD integration pitfalls:
- PublickeyAuthenticator.authenticate(...) must not attach user/session state until the post‑signature verification path confirms the signature
- PasswordAuthenticator.authenticate(...) must not infer success from any state mutated during a prior, incomplete authentication method

Related protocol/design notes and literature:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Historical discussions on early acceptance oracles and auth races, e.g., CVE‑2016‑20012 disputes around OpenSSH behavior

## References

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
