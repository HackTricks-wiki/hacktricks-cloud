# Gitblit Embedded SSH Auth Bypass (CVE-2024-28080)

{{#include ../../banners/hacktricks-training.md}}

## Περίληψη

CVE-2024-28080 είναι ένα authentication bypass στην ενσωματωμένη υπηρεσία SSH του Gitblit λόγω λανθασμένης διαχείρισης της κατάστασης session κατά την ενσωμάτωση με Apache MINA SSHD. Εάν ένας λογαριασμός χρήστη έχει τουλάχιστον ένα SSH public key καταχωρημένο, ένας επιτιθέμενος που γνωρίζει το username και οποιοδήποτε από τα public keys αυτού του χρήστη μπορεί να πραγματοποιήσει authentication χωρίς το private key και χωρίς το password.

- Affected: Gitblit < 1.10.0 (observed on 1.9.3)
- Fixed: 1.10.0
- Requirements to exploit:
- Git over SSH enabled on the instance
- Victim account has at least one SSH public key registered in Gitblit
- Attacker knows victim username and one of their public keys (often discoverable, e.g., https://github.com/<username>.keys)

## Αιτία ρίζας (state leaks between SSH methods)

Στο RFC 4252, η public‑key authentication προχωρά σε δύο φάσεις: ο server πρώτα ελέγχει αν ένα παρεχόμενο public key είναι αποδεκτό για ένα username, και μόνο μετά από ένα challenge/response με υπογραφή authenticate τον χρήστη. Στο MINA SSHD, ο PublickeyAuthenticator καλείται δύο φορές: κατά την αποδοχή του key (no signature yet) και αργότερα αφού ο client επιστρέψει μια υπογραφή.

Ο PublickeyAuthenticator του Gitblit τροποποίησε το session context στην πρώτη, προ‑υπογραφής κλήση δεσμεύοντας το authenticated UserModel στο session και επιστρέφοντας true ("key acceptable"). Όταν αργότερα η authentication έπεσε πίσω στο password, ο PasswordAuthenticator εμπιστεύτηκε την τροποποιημένη αυτή κατάσταση session και διέκοψε τη ροή, επιστρέφοντας true χωρίς να επικυρώσει το password. Ως αποτέλεσμα, οποιοδήποτε password (συμπεριλαμβανομένου και του κενού) γινόταν αποδεκτό μετά από προηγούμενη public‑key "acceptance" για τον ίδιο χρήστη.

Υψηλού επιπέδου ελαττωματική ροή:

1) Client προσφέρει username + public key (no signature yet)
2) Server αναγνωρίζει ότι το key ανήκει στον χρήστη και πρόωρα επισυνάπτει τον χρήστη στο session, επιστρέφοντας true ("acceptable")
3) Client δεν μπορεί να υπογράψει (no private key), οπότε η auth πέφτει πίσω στο password
4) Η password auth βλέπει έναν χρήστη ήδη παρόν στο session και άνευ όρων επιστρέφει επιτυχία

## Βήμα‑προς‑βήμα exploitation

- Συλλέξτε το victim username και ένα από τα public keys τους:
- GitHub εκθέτει public keys στο https://github.com/<username>.keys
- Public servers συχνά εκθέτουν authorized_keys
- Διαμορφώστε το OpenSSH ώστε να παρουσιάζει μόνο το public half ώστε η δημιουργία υπογραφής να αποτύχει, αναγκάζοντας fallback στο password ενώ εξακολουθεί να ενεργοποιεί την public‑key acceptance διαδρομή στον server.

Example SSH client config (no private key available):
```sshconfig
# ~/.ssh/config
Host gitblit-target
HostName <host-or-ip>
User <victim-username>
PubkeyAuthentication yes
PreferredAuthentications publickey,password
IdentitiesOnly yes
IdentityFile ~/.ssh/victim.pub   # public half only (no private key present)
```
Συνδεθείτε και πατήστε Enter στην προτροπή κωδικού πρόσβασης (ή πληκτρολογήστε οποιαδήποτε συμβολοσειρά):
```bash
ssh gitblit-target
# or Git over SSH
GIT_SSH_COMMAND="ssh -F ~/.ssh/config" git ls-remote ssh://<victim-username>@<host>/<repo.git>
```
Η αυθεντικοποίηση επιτυγχάνει επειδή το προηγούμενο στάδιο public‑key μετέβαλε τη συνεδρία σε authenticated χρήστη, και η password auth εμπιστεύεται εσφαλμένα αυτήν την κατάσταση.

Σημείωση: Αν το ControlMaster multiplexing είναι ενεργοποιημένο στο SSH config σας, οι επόμενες εντολές Git μπορεί να επαναχρησιμοποιήσουν τη συνδεδεμένη σύνδεση, αυξάνοντας τον αντίκτυπο.

## Αντίκτυπο

- Πλήρης προσποίηση οποιουδήποτε χρήστη Gitblit που έχει τουλάχιστον ένα καταχωρημένο SSH public key
- Δικαιώματα ανάγνωσης/εγγραφής στα repositories σύμφωνα με τα permissions του θύματος (source exfiltration, unauthorized pushes, supply‑chain risks)
- Πιθανός διοικητικός αντίκτυπος αν στοχευθεί χρήστης admin
- Καθαρό network exploit· δεν απαιτείται brute force ή private key

## Ιδέες ανίχνευσης

- Ελέγξτε τα SSH logs για ακολουθίες όπου μια προσπάθεια publickey ακολουθείται από επιτυχή password authentication με κενό ή πολύ μικρό password
- Αναζητήστε ροές: μέθοδος publickey που προσφέρει μη υποστηριζόμενο/μη ταιριαστό key material και ακολουθείται αμέσως από επιτυχία password για το ίδιο username

## Αντιμετώπιση

- Αναβαθμίστε σε Gitblit v1.10.0+
- Μέχρι την αναβάθμιση:
- Απενεργοποιήστε το Git over SSH στο Gitblit, ή
- Περιορίστε την πρόσβαση δικτύου στην υπηρεσία SSH, και
- Παρακολουθήστε για ύποπτα πρότυπα που περιγράφονται παραπάνω
- Αλλάξτε τα credentials των επηρεασμένων χρηστών εάν υποπτευθείτε συμβιβασμό

## Γενικά: abusing SSH auth method state‑leakage (MINA/OpenSSH‑based services)

Πρότυπο: Εάν ο public‑key authenticator ενός server μεταβάλλει την κατάσταση χρήστη/συνεδρίας κατά τη φάση προ‑υπογραφής "key acceptable" και άλλοι authenticators (π.χ. password) εμπιστεύονται αυτή την κατάσταση, μπορείτε να παρακάμψετε την authentication ως εξής:

- Παρουσιάζοντας ένα νόμιμο public key για τον στοχευόμενο χρήστη (χωρίς private key)
- Εξαναγκάζοντας τον client να αποτύχει στην υπογραφή ώστε ο server να επιστρέψει σε password
- Παρέχοντας οποιοδήποτε password ενώ ο password authenticator κάνει short‑circuit λόγω leaked state

Πρακτικές συμβουλές:

- Συλλογή public keys σε μεγάλη κλίμακα: τραβήξτε public keys από κοινές πηγές όπως https://github.com/<username>.keys, organizational directories, team pages, leaked authorized_keys
- Εξαναγκασμός αποτυχίας υπογραφής (client‑side): ορίστε το IdentityFile μόνο στο .pub, βάλτε IdentitiesOnly yes, διατηρήστε το PreferredAuthentications ώστε να περιλαμβάνει publickey και μετά password
- Παγίδες ενσωμάτωσης MINA SSHD:
- PublickeyAuthenticator.authenticate(...) δεν πρέπει να επισυνάπτει κατάσταση χρήστη/συνεδρίας μέχρι η post‑signature verification διαδρομή να επιβεβαιώσει την υπογραφή
- PasswordAuthenticator.authenticate(...) δεν πρέπει να συμπεραίνει επιτυχία από οποιαδήποτε κατάσταση μεταβλήθηκε κατά τη διάρκεια προηγούμενης, ατελούς μεθόδου authentication

Σχετικές σημειώσεις πρωτοκόλλου/σχεδιασμού και βιβλιογραφία:
- SSH userauth protocol: RFC 4252 (publickey method is a two‑stage process)
- Ιστορικές συζητήσεις για early acceptance oracles και auth races, π.χ. CVE‑2016‑20012 disputes γύρω από το OpenSSH behavior

## Αναφορές

- [Gitblit CVE-2024-28080: SSH public‑key fallback to password authentication bypass (Silent Signal blog)](https://blog.silentsignal.eu/2025/06/14/gitblit-cve-CVE-2024-28080/)
- [Gitblit v1.10.0 release notes](https://github.com/gitblit-org/gitblit/releases/tag/v1.10.0)
- [Apache MINA SSHD project](https://mina.apache.org/sshd-project/)
- [PublickeyAuthenticator API](https://svn.apache.org/repos/infra/websites/production/mina/content/sshd-project/apidocs/org/apache/sshd/server/auth/pubkey/PublickeyAuthenticator.html)
- [RFC 4252: The Secure Shell (SSH) Authentication Protocol](https://datatracker.ietf.org/doc/html/rfc4252)


{{#include ../../banners/hacktricks-training.md}}
